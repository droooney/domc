(function () {
'use strict';

/* eslint no-nested-ternary: 0 */
/* eslint no-negated-condition: 0 */
var global$1 = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * @module constants/appliedRegExps
 * @private
 * @description Exports different types of syntax for {@link Elem#apply}.
 */

/**
 * @callback matchAppliedExprCallback
 * @param {Elem} elem - D-elem of an element to apply expression to.
 * @param {String} string - Matched applied name.
 * @param {String} arg - Argument within the parentheses.
 */

/**
 * @type {Object.<String, matchAppliedExprCallback|Object.<String, matchAppliedExprCallback>>}
 * @description Object of different types of syntax.
 */

var appliedRegExps = {
  '#': function _(elem, id) {
    elem.id(id);
  },
  '.': function _(elem, cls) {
    elem.addClass(cls);
  },
  $: function $(elem, attr, value) {
    elem.attr(attr, value);
  },
  '@': function _(elem, prop, value) {
    elem.css(prop, value);
  },
  '&': function _(elem, name, html) {
    elem.html(html);
  },
  '*': function _(elem, name, text) {
    elem.text(text);
  },

  '-': {
    '.': function _(elem, cls) {
      elem.removeClass(cls);
    },
    $: function $(elem, attr) {
      elem.removeAttr(attr);
    },
    '@': function _(elem, prop) {
      elem.removeCSS(prop);
    }
  }
};

/**
 * @module constants/elements
 * @private
 * @description Exports different canvas methods for {@link Elem} for creating html-elements.
 */

/**
 * @const
 * @type {String[]}
 */
var canvasGetMethods = [
/**
 * @member {Function} Elem#createImageData
 * @type {Function}
 * @param {...*} args
 * @returns {ImageData|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createImageData
 */
'createImageData',

/**
 * @member {Function} Elem#createLinearGradient
 * @type {Function}
 * @param {...*} args
 * @returns {CanvasGradient|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createLinearGradient
 */
'createLinearGradient',

/**
 * @member {Function} Elem#createPattern
 * @type {Function}
 * @param {...*} args
 * @returns {CanvasPattern|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createPattern
 */
'createPattern',

/**
 * @member {Function} Elem#createRadialGradient
 * @type {Function}
 * @param {...*} args
 * @returns {CanvasGradient|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createRadialGradient
 */
'createRadialGradient',

/**
 * @member {Function} Elem#getImageData
 * @type {Function}
 * @param {...*} args
 * @returns {ImageData|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getImageData
 */
'getImageData',

/**
 * @member {Function} Elem#getLineDash
 * @type {Function}
 * @param {...*} args
 * @returns {Number[]|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getLineDash
 */
'getLineDash',

/**
 * @member {Function} Elem#isPointInPath
 * @type {Function}
 * @param {...*} args
 * @returns {Boolean|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInPath
 */
'isPointInPath',

/**
 * @member {Function} Elem#isPointInStroke
 * @type {Function}
 * @param {...*} args
 * @returns {Boolean|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInStroke
 */
'isPointInStroke',

/**
 * @member {Function} Elem#measureText
 * @type {Function}
 * @param {...*} args
 * @returns {TextMetrics|void}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/measureText
 */
'measureText'];

var canvasRestMethods = [
/**
 * @member {Function} Elem#arc
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arc
 */
'arc',

/**
 * @member {Function} Elem#arcTo
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arcTo
 */
'arcTo',

/**
 * @member {Function} Elem#beginPath
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/beginPath
 */
'beginPath',

/**
 * @member {Function} Elem#bezierCurveTo
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo
 */
'bezierCurveTo',

/**
 * @member {Function} Elem#clearRect
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clearRect
 */
'clearRect',

/**
 * @member {Function} Elem#clip
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clip
 */
'clip',

/**
 * @member {Function} Elem#closePath
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/closePath
 */
'closePath',

/**
 * @member {Function} Elem#drawFocusIfNeeded
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawFocusIfNeeded
 */
'drawFocusIfNeeded',

/**
 * @member {Function} Elem#drawImage
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawImage
 */
'drawImage',

/**
 * @member {Function} Elem#ellipse
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/ellipse
 */
'ellipse',

/**
 * @member {Function} Elem#fill
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fill
 */
'fill',

/**
 * @member {Function} Elem#fillRect
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillRect
 */
'fillRect',

/**
 * @member {Function} Elem#fillText
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillText
 */
'fillText',

/**
 * @member {Function} Elem#lineTo
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineTo
 */
'lineTo',

/**
 * @member {Function} Elem#moveTo
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/moveTo
 */
'moveTo',

/**
 * @member {Function} Elem#putImageData
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/putImageData
 */
'putImageData',

/**
 * @member {Function} Elem#quadraticCurveTo
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/quadraticCurveTo
 */
'quadraticCurveTo',

/**
 * @member {Function} Elem#rect
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rect
 */
'rect',

/**
 * @member {Function} Elem#resetTransform
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/resetTransform
 */
'resetTransform',

/**
 * @member {Function} Elem#restore
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/restore
 */
'restore',

/**
 * @member {Function} Elem#rotate
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rotate
 */
'rotate',

/**
 * @member {Function} Elem#save
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/save
 */
'save',

/**
 * @member {Function} Elem#scale
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/scale
 */
'scale',

/**
 * @member {Function} Elem#setLineDash
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setLineDash
 */
'setLineDash',

/**
 * @member {Function} Elem#setTransform
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setTransform
 */
'setTransform',

/**
 * @member {Function} Elem#stroke
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/stroke
 */
'stroke',

/**
 * @member {Function} Elem#strokeRect
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeRect
 */
'strokeRect',

/**
 * @member {Function} Elem#strokeText
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeText
 */
'strokeText',

/**
 * @member {Function} Elem#transform
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/transform
 */
'transform',

/**
 * @member {Function} Elem#translate
 * @type {Function}
 * @param {...*} args
 * @returns {Elem}
 * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/translate
 */
'translate'];

/**
 * @module constants/constructors
 * @private
 * @description Exports constructors levels.
 */

/**
 * @const
 * @type {Array[]}
 */
var constructors = [[], [], []];

/**
 * @module constants/elements
 * @private
 * @description Exports methods for {@link Elem} for creating html-elements.
 */

/**
 * @const
 * @type {String[]}
 */
var htmlElements = [
/**
 * @member {Function} Elem#a
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'a',

/**
 * @member {Function} Elem#abbr
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'abbr',

/**
 * @member {Function} Elem#address
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'address',

/**
 * @member {Function} Elem#area
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'area',

/**
 * @member {Function} Elem#article
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'article',

/**
 * @member {Function} Elem#audio
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'audio',

/**
 * @member {Function} Elem#b
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'b',

/**
 * @member {Function} Elem#base
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'base',

/**
 * @member {Function} Elem#bdi
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'bdi',

/**
 * @member {Function} Elem#bdo
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'bdo',

/**
 * @member {Function} Elem#blockquote
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'blockquote',

/**
 * @member {Function} Elem#body
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'body',

/**
 * @member {Function} Elem#br
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'br',

/**
 * @member {Function} Elem#button
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'button',

/**
 * @member {Function} Elem#canvas
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'canvas',

/**
 * @member {Function} Elem#caption
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'caption',

/**
 * @member {Function} Elem#cite
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'cite',

/**
 * @member {Function} Elem#code
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'code',

/**
 * @member {Function} Elem#col
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'col',

/**
 * @member {Function} Elem#colgroup
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'colgroup',

/**
 * @member {Function} Elem#content
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'content',

/**
 * @member {Function} Elem#datalist
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'datalist',

/**
 * @member {Function} Elem#dd
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'dd',

/**
 * @member {Function} Elem#del
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'del',

/**
 * @member {Function} Elem#details
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'details',

/**
 * @member {Function} Elem#dfn
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'dfn',

/**
 * @member {Function} Elem#dialog
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'dialog',

/**
 * @member {Function} Elem#div
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'div',

/**
 * @member {Function} Elem#dl
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'dl',

/**
 * @member {Function} Elem#dt
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'dt',

/**
 * @member {Function} Elem#element
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'element',

/**
 * @member {Function} Elem#em
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'em',

/**
 * @member {Function} Elem#embed
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'embed',

/**
 * @member {Function} Elem#fieldset
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'fieldset',

/**
 * @member {Function} Elem#figcaption
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'figcaption',

/**
 * @member {Function} Elem#figure
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'figure',

/**
 * @member {Function} Elem#footer
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'footer',

/**
 * @member {Function} Elem#form
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'form',

/**
 * @member {Function} Elem#h1
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'h1',

/**
 * @member {Function} Elem#h2
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'h2',

/**
 * @member {Function} Elem#h3
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'h3',

/**
 * @member {Function} Elem#h4
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'h4',

/**
 * @member {Function} Elem#h5
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'h5',

/**
 * @member {Function} Elem#h6
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'h6',

/**
 * @member {Function} Elem#head
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'head',

/**
 * @member {Function} Elem#header
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'header',

/**
 * @member {Function} Elem#hgroup
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'hgroup',

/**
 * @member {Function} Elem#hr
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'hr',

/**
 * @member {Function} Elem#i
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'i',

/**
 * @member {Function} Elem#iframe
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'iframe',

/**
 * @member {Function} Elem#img
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'img',

/**
 * @member {Function} Elem#input
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'input',

/**
 * @member {Function} Elem#ins
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'ins',

/**
 * @member {Function} Elem#kbd
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'kbd',

/**
 * @member {Function} Elem#label
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'label',

/**
 * @member {Function} Elem#legend
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'legend',

/**
 * @member {Function} Elem#li
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'li',

/**
 * @member {Function} Elem#link
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'link',

/**
 * @member {Function} Elem#main
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'main',

/**
 * @member {Function} Elem#mark
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'mark',

/**
 * @member {Function} Elem#menu
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'menu',

/**
 * @member {Function} Elem#menuitem
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'menuitem',

/**
 * @member {Function} Elem#meta
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'meta',

/**
 * @member {Function} Elem#meter
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'meter',

/**
 * @member {Function} Elem#nav
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'nav',

/**
 * @member {Function} Elem#noscript
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'noscript',

/**
 * @member {Function} Elem#ol
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'ol',

/**
 * @member {Function} Elem#optgroup
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'optgroup',

/**
 * @member {Function} Elem#option
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'option',

/**
 * @member {Function} Elem#output
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'output',

/**
 * @member {Function} Elem#p
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'p',

/**
 * @member {Function} Elem#param
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'param',

/**
 * @member {Function} Elem#pre
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'pre',

/**
 * @member {Function} Elem#progress
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'progress',

/**
 * @member {Function} Elem#q
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'q',

/**
 * @member {Function} Elem#rp
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'rp',

/**
 * @member {Function} Elem#rt
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'rt',

/**
 * @member {Function} Elem#rtc
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'rtc',

/**
 * @member {Function} Elem#ruby
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'ruby',

/**
 * @member {Function} Elem#s
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
's',

/**
 * @member {Function} Elem#samp
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'samp',

/**
 * @member {Function} Elem#script
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'script',

/**
 * @member {Function} Elem#section
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'section',

/**
 * @member {Function} Elem#select
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'select',

/**
 * @member {Function} Elem#shadow
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'shadow',

/**
 * @member {Function} Elem#small
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'small',

/**
 * @member {Function} Elem#source
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'source',

/**
 * @member {Function} Elem#span
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'span',

/**
 * @member {Function} Elem#strong
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'strong',

/**
 * @member {Function} Elem#style
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'style',

/**
 * @member {Function} Elem#sub
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'sub',

/**
 * @member {Function} Elem#summary
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'summary',

/**
 * @member {Function} Elem#sup
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'sup',

/**
 * @member {Function} Elem#table
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'table',

/**
 * @member {Function} Elem#tbody
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'tbody',

/**
 * @member {Function} Elem#td
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'td',

/**
 * @member {Function} Elem#template
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'template',

/**
 * @member {Function} Elem#textarea
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'textarea',

/**
 * @member {Function} Elem#tfoot
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'tfoot',

/**
 * @member {Function} Elem#th
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'th',

/**
 * @member {Function} Elem#thead
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'thead',

/**
 * @member {Function} Elem#time
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'time',

/**
 * @member {Function} Elem#title
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'title',

/**
 * @member {Function} Elem#tr
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'tr',

/**
 * @member {Function} Elem#track
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'track',

/**
 * @member {Function} Elem#u
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'u',

/**
 * @member {Function} Elem#ul
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'ul',

/**
 * @member {Function} Elem#var
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'var',

/**
 * @member {Function} Elem#video
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'video',

/**
 * @member {Function} Elem#wbr
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'wbr'];

var svgElements = [
/**
 * @member {Function} Elem#altGlyph
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'altGlyph',

/**
 * @member {Function} Elem#altGlyphDef
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'altGlyphDef',

/**
 * @member {Function} Elem#altGlyphItem
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'altGlyphItem',

/**
 * @member {Function} Elem#animate
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'animate',

/**
 * @member {Function} Elem#animateColor
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'animateColor',

/**
 * @member {Function} Elem#animateMotion
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'animateMotion',

/**
 * @member {Function} Elem#animateTransform
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'animateTransform',

/**
 * @member {Function} Elem#circle
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'circle',

/**
 * @member {Function} Elem#clipPath
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'clipPath',

/**
 * @member {Function} Elem#colorProfile
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'color-profile',

/**
 * @member {Function} Elem#cursor
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'cursor',

/**
 * @member {Function} Elem#defs
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'defs',

/**
 * @member {Function} Elem#desc
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'desc',

/**
 * @member {Function} Elem#discard
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'discard',

/**
 * @member {Function} Elem#ellipse
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'ellipse',

/**
 * @member {Function} Elem#feBlend
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feBlend',

/**
 * @member {Function} Elem#feColorMatrix
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feColorMatrix',

/**
 * @member {Function} Elem#feComponentTransfer
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feComponentTransfer',

/**
 * @member {Function} Elem#feComposite
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feComposite',

/**
 * @member {Function} Elem#feConvolveMatrix
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feConvolveMatrix',

/**
 * @member {Function} Elem#feDiffuseLighting
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feDiffuseLighting',

/**
 * @member {Function} Elem#feDisplacementMap
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feDisplacementMap',

/**
 * @member {Function} Elem#feDistantLight
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feDistantLight',

/**
 * @member {Function} Elem#feDropShadow
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feDropShadow',

/**
 * @member {Function} Elem#feFlood
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feFlood',

/**
 * @member {Function} Elem#feFuncA
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feFuncA',

/**
 * @member {Function} Elem#feFuncB
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feFuncB',

/**
 * @member {Function} Elem#feFuncG
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feFuncG',

/**
 * @member {Function} Elem#feFuncR
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feFuncR',

/**
 * @member {Function} Elem#feGaussianBlur
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feGaussianBlur',

/**
 * @member {Function} Elem#feImage
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feImage',

/**
 * @member {Function} Elem#feMerge
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feMerge',

/**
 * @member {Function} Elem#feMergeNode
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feMergeNode',

/**
 * @member {Function} Elem#feMorphology
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feMorphology',

/**
 * @member {Function} Elem#feOffset
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feOffset',

/**
 * @member {Function} Elem#fePointLight
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'fePointLight',

/**
 * @member {Function} Elem#feSpecularLighting
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feSpecularLighting',

/**
 * @member {Function} Elem#feSpotLight
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feSpotLight',

/**
 * @member {Function} Elem#feTile
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feTile',

/**
 * @member {Function} Elem#feTurbulence
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'feTurbulence',

/**
 * @member {Function} Elem#font
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'font',

/**
 * @member {Function} Elem#fontFace
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'font-face',

/**
 * @member {Function} Elem#fontFaceFormat
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'font-face-format',

/**
 * @member {Function} Elem#fontFaceName
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'font-face-name',

/**
 * @member {Function} Elem#fontFaceSrc
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'font-face-src',

/**
 * @member {Function} Elem#fontFaceUri
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'font-face-uri',

/**
 * @member {Function} Elem#foreignObject
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'foreignObject',

/**
 * @member {Function} Elem#g
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'g',

/**
 * @member {Function} Elem#glyph
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'glyph',

/**
 * @member {Function} Elem#glyphRef
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'glyphRef',

/**
 * @member {Function} Elem#hatch
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'hatch',

/**
 * @member {Function} Elem#hatchpath
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'hatchpath',

/**
 * @member {Function} Elem#hkern
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'hkern',

/**
 * @member {Function} Elem#image
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'image',

/**
 * @member {Function} Elem#line
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'line',

/**
 * @member {Function} Elem#linearGradient
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'linearGradient',

/**
 * @member {Function} Elem#marker
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'marker',

/**
 * @member {Function} Elem#mask
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'mask',

/**
 * @member {Function} Elem#mesh
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'mesh',

/**
 * @member {Function} Elem#meshgradient
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'meshgradient',

/**
 * @member {Function} Elem#meshpatch
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'meshpatch',

/**
 * @member {Function} Elem#meshrow
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'meshrow',

/**
 * @member {Function} Elem#metadata
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'metadata',

/**
 * @member {Function} Elem#missingGlyph
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'missing-glyph',

/**
 * @member {Function} Elem#mpath
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'mpath',

/**
 * @member {Function} Elem#path
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'path',

/**
 * @member {Function} Elem#pattern
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'pattern',

/**
 * @member {Function} Elem#polygon
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'polygon',

/**
 * @member {Function} Elem#polyline
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'polyline',

/**
 * @member {Function} Elem#radialGradient
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'radialGradient',

/**
 * @member {Function} Elem#rect
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'rect',

/**
 * @member {Function} Elem#set
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'set',

/**
 * @member {Function} Elem#solidcolor
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'solidcolor',

/**
 * @member {Function} Elem#stop
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'stop',

/**
 * @member {Function} Elem#style
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'style',

/**
 * @member {Function} Elem#svg
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'svg',

/**
 * @member {Function} Elem#switch
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'switch',

/**
 * @member {Function} Elem#symbol
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'symbol',

/**
 * @member {Function} Elem#textPath
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'textPath',

/**
 * @member {Function} Elem#tref
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'tref',

/**
 * @member {Function} Elem#tspan
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'tspan',

/**
 * @member {Function} Elem#unknown
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'unknown',

/**
 * @member {Function} Elem#use
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'use',

/**
 * @member {Function} Elem#view
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'view',

/**
 * @member {Function} Elem#vkern
 * @type {Function}
 * @param {...String} appliedExpressions
 * @returns {Elem}
 */
'vkern'];

var voidElements = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

var htmlAllowedTagSymbols = '[a-z][a-z\\d\\-_.:!@#\\$%\\^&*()\\[\\]{}\\\\=\'"]*';
var htmlAllowedAttrSymbols = '[^\\u0000-\\u0020\\s"\'>/=]+';

/**
 * @module constants/regexpSpecialCharacters
 * @private
 * @description Exports special characters for RegExp.
 */

/**
 * @const
 * @name module:constants/regexpSpecialCharacters~regexpSpecialCharacters
 * @type {String[]}
 */
var regexpSpecialCharacters = ['.', '+', '*', '?', '(', ')', '[', ']', '{', '}', '<', '>', '^', '$', '!', '=', ':', '-', '|', ',', '\\'];

/**
 * @module helpers/toStringTag
 * @private
 * @description Exports toStringTag method.
 */

/**
 * @function toStringTag
 * @param {*} object - Object to get toStringTag of.
 * @returns {String} Cut string.
 * @description Cut "Type" string from "[object Type]" string that gotten from {}.toString,call(object).
 */
function toStringTag(object) {
  return {}.toString.call(object).replace(/^\[object |]$/g, '');
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * @module helpers/checkTypes
 * @private
 * @mixin
 * @description Exports is<Type> methods.
 */

/**
 * @function isArray
 * @public
 * @param {*} value - Value to check if it is an array.
 * @returns {Boolean} If the argument is an array or not.
 * 
 * @example
 * isArray([]);                             // true
 * isArray(0);                              // true
 * isArray(document.querySelectorAll('*')); // false
 */
function isArray(value) {
  return toStringTag(value) === 'Array';
}

/**
 * @function isArrayLike
 * @public
 * @param {*} value - Value to check if it is array-like.
 * @returns {Boolean} If the argument is array-like or not.
 * @description Basically returns if the argument has non-negative integer "length" property and isn't a function.
 * 
 * @example
 * isArrayLike([]);                             // true
 * isArrayLike('');                             // true
 * isArrayLike(() => {});                       // false
 * isArrayLike(document.querySelectorAll('*')); // true
 */
function isArrayLike(value) {
  if (!value || isFunction(value)) {
    return false;
  }

  var length = value.length;

  return isInteger(length) && length >= 0;
}

/**
 * @function isBoolean
 * @public
 * @param {*} value - Value to check if it is a boolean.
 * @returns {Boolean} If the argument is a boolean or not.
 * 
 * @example
 * isBoolean(true);               // true
 * isBoolean(new Boolean(false)); // true
 * isBoolean(null);               // false
 */
function isBoolean(value) {
  return toStringTag(value) === 'Boolean';
}

/**
 * @function isDate
 * @public
 * @param {*} value - Value to check if it is a date.
 * @returns {Boolean} If the argument is a date or not.
 * 
 * @example
 * isDate(new Date());                 // true
 * isDate('1999-12-31T23:59:59.999Z'); // false
 */
function isDate(value) {
  return toStringTag(value) === 'Date';
}

/**
 * @function isDateLike
 * @public
 * @param {*} value - Value to check if it is date-like.
 * @returns {Boolean} If the argument is date-like or not.
 * @description Basically returns if new Date(argument) is not invalid date.
 * 
 * @example
 * isDateLike(new Date());                 // true
 * isDateLike('1999-12-31T23:59:59.999Z'); // true
 * isDateLike(0);                          // true
 */
function isDateLike(value) {
  value = new Date(value);

  return !isNaN(value.getTime());
}

/**
 * @function isElement
 * @public
 * @param {*} value - Value to check if it is an element.
 * @returns {Boolean} If the argument is element or not.
 *
 * @example
 * isElement(document.querySelector('html')); // true
 */
function isElement(value) {
  return (/Element$/.test(toStringTag(value))
  );
}

/**
 * @function isFinite
 * @public
 * @param {*} value - Value to check if it is finite.
 * @returns {Boolean} If the argument is finite or not.
 * 
 * @example
 * isFinite(0);        // true
 * isFinite('0');      // false
 * isFinite(Infinity); // false
 * isFinite(NaN);      // false
 */
function isFinite(value) {
  if (!isNumber(value)) {
    return false;
  }

  value = Number(value);

  return !isNaN(value) && value !== Infinity && value !== -Infinity;
}

/**
 * @function isFunction
 * @public
 * @param {*} value - Value to check if it is a function.
 * @returns {Boolean} If the argument is a function or not.
 * 
 * @example
 * isFunction(() => {});            // true
 * 
 * const func = () => {};
 * Object.setPrototypeOf(func, {});
 * isFunction(func);                // true
 */
function isFunction(value) {
  return toStringTag(value) === 'Function' || typeof value === 'function';
}

/**
 * @function isInteger
 * @public
 * @param {*} value - Value to check if it is an integer.
 * @returns {Boolean} If the argument is an integer or not.
 *
 * @example
 * isInteger(0);             // true
 * isInteger(0.1);           // false
 * isInteger(new Number(0)); // true
 * isInteger('0');           // false
 * isInteger(Infinity);      // false
 * isInteger(NaN);           // false
 */
function isInteger(value) {
  return isNumber(value) && value % 1 === 0;
}

/**
 * @function isIntegerLike
 * @public
 * @param {*} value - Value to check if it is integer-like.
 * @returns {Boolean} If the argument is integer-like or not.
 *
 * @example
 * isIntegerLike(0);             // true
 * isIntegerLike(new Number(0)); // true
 * isIntegerLike(0.1);           // false
 * isIntegerLike('0');           // true
 */
function isIntegerLike(value) {
  value = parseInt(Number(value));

  return !!(value || value === 0);
}

/**
 * @function isNaN
 * @public
 * @param {*} value - Value to check if it is NaN.
 * @returns {Boolean} If the argument is NaN or not.
 *
 * @example
 * isNaN(0);               // false
 * isNaN('NaN');           // false
 * isNaN(NaN);             // true
 * isNaN(new Number(NaN)); // true
 */
function isNaN(value) {
  if (!isNumber(value)) {
    return false;
  }

  value = Number(value);

  return value !== value;
}

/**
 * @function isNull
 * @public
 * @param {*} value - Value to check if it is null.
 * @returns {Boolean} If the argument is null or not.
 *
 * @example
 * isNull(null);      // true
 * isNull(undefined); // false
 */
function isNull(value) {
  return value === null;
}

/**
 * @function isNil
 * @public
 * @param {*} value - Value to check if it is null or undefined.
 * @returns {Boolean} If the argument is null or undefined or not.
 *
 * @example
 * isNil(null);      // true
 * isNil(undefined); // true
 * isNil(false);     // false
 */
function isNil(value) {
  return value === null || typeof value === 'undefined';
}

/**
 * @function isNumber
 * @public
 * @param {*} value - Value to check if it is a number.
 * @returns {Boolean} If the argument is a number or not.
 *
 * @example
 * isNumber(0);             // true
 * isNumber(new Number(0)); // true
 * isNumber(NaN);           // true
 * isNumber('0');           // false
 */
function isNumber(value) {
  return toStringTag(value) === 'Number';
}

/**
 * @function isNumberLike
 * @public
 * @param {*} value - Value to check if it is number-like.
 * @returns {Boolean} If the argument is number-like or not.
 *
 * @example
 * isNumberLike(0);          // true
 * isNumberLike('0');        // true
 * isNumberLike('Infinity'); // true
 * isNumberLike('NaN');      // true
 * isNumberLike(NaN);        // true
 */
function isNumberLike(value) {
  if (isNaN(value) || value === 'NaN') {
    return true;
  }

  value = Number(value);

  return !!(value || value === 0);
}

/**
 * @function isObject
 * @public
 * @param {*} value - Value to check if it is an object.
 * @returns {Boolean} If the argument is an object or not.
 *
 * @example
 * isObject({});   // true
 * isObject(1);    // false
 * isObject(null); // false
 */
function isObject(value) {
  return !!value && (toStringTag(value) === 'Object' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || value instanceof Object);
}

/**
 * @function isPlainObject
 * @public
 * @param {*} value - Value to check if it is a plain object.
 * @returns {Boolean} If the argument is a plain object or not.
 *
 * @example
 * const obj = {};
 *
 * ifPlainObject(obj); // true
 *
 * Object.setPrototypeOf(object, null);
 *
 * ifPlainObject(obj); // true
 *
 * Object.setPrototypeOf(object, {});
 *
 * ifPlainObject(obj); // false
 */
function isPlainObject(value) {
  if (isPrimitive(value)) {
    return false;
  }

  var proto = Object.getPrototypeOf(value);

  if (isNull(proto)) {
    return true;
  }

  var constructor = proto.constructor;

  return isFunction(constructor) && constructor instanceof constructor && isNull(Object.getPrototypeOf(proto));
}

/**
 * @function isPrimitive
 * @public
 * @param {*} value - Value to check if it is primitive.
 * @returns {Boolean} If the argument is primitive or not.
 *
 * @example
 * isPrimitive(1);             // true
 * isPrimitive({});            // false
 * isPrimitive('');            // true
 * isPrimitive(new Number(0)); // false
 * isPrimitive(true);          // true
 * isPrimitive(Symbol('foo')); // true
 * isPrimitive(null);          // true
 * isPrimitive(undefined);     // true
 */
function isPrimitive(value) {
  return isNull(value) || /^(number|string|boolean|symbol|undefined)$/.test(typeof value === 'undefined' ? 'undefined' : _typeof(value));
}

/**
 * @function isRegExp
 * @public
 * @param {*} value - Value to check if it is a regular expression.
 * @returns {Boolean} If the argument is a regular expression or not.
 *
 * @example
 * isRegExp(/foo/);             // true
 * isRegExp('/foo/');           // false
 * isRegExp(new RegExp('foo')); // true
 */
function isRegExp(value) {
  return toStringTag(value) === 'RegExp';
}

/**
 * @function isString
 * @public
 * @param {*} value - Value to check if it is a string.
 * @returns {Boolean} If the argument is a string or not.
 *
 * @example
 * isString('0');             // true
 * isString(new String('0')); // true
 */
function isString(value) {
  return toStringTag(value) === 'String';
}

/**
 * @function isSymbol
 * @public
 * @param {*} value - Value to check if it is a symbol.
 * @returns {Boolean} If the argument is a symbol or not.
 *
 * @example
 * isSymbol(Symbol('1')); // true
 */
function isSymbol(value) {
  return toStringTag(value) === 'Symbol';
}

/**
 * @function isUndefined
 * @public
 * @param {*} value - Value to check if it is undefined.
 * @returns {Boolean} If the argument is undefined or not.
 *
 * @example
 * isUndefined(null);      // false
 * isUndefined(undefined); // true
 */
function isUndefined(value) {
  return typeof value === 'undefined';
}

/**
 * @module constants/validateCheckExpressions
 * @private
 * @description Exports different types of validate expressions for {@link module:helpers/validate}.
 */

/**
 * @callback checkValidityCallback
 * @private
 * @param {*} value - Value to check.
 */

/**
 * @typedef {Object} validateExpr
 * @private
 * @property {String} text - Text of the thrown error.
 * @property {Error} error - Type of the thrown error.
 * @property {checkValidityCallback} check - Callback for checking value.
 */

/**
 * @type {validateExpr[]}
 * @private
 * @description Object of different types of validation.
 */
var validateCheckExpressions = {
  '>0': {
    check: function check(n) {
      return n > 0;
    },
    text: '$n argument must be positive!',
    error: RangeError
  },
  '>=0': {
    check: function check(n) {
      return n >= 0;
    },
    text: '$n argument must be non-negative!',
    error: RangeError
  },
  '<0': {
    check: function check(n) {
      return n < 0;
    },
    text: '$n argument must be negative!',
    error: RangeError
  },
  '<=0': {
    check: function check(n) {
      return n <= 0;
    },
    text: '$n argument must be non-positive!',
    error: RangeError
  },
  '!!': {
    check: function check(v) {
      return !isNil(v);
    },
    text: '$n argument must be not null or undefined!',
    error: TypeError
  },
  array: {
    check: isArray,
    text: '$n argument must be an array!',
    error: TypeError
  },
  'array||!': {
    check: function check(a) {
      return isArray(a) || isNil(a);
    },
    text: '$n argument must be an array, or undefined, or null!',
    error: TypeError
  },
  arrayLike: {
    check: isArrayLike,
    text: '$n argument must be array-like!',
    error: TypeError
  },
  'arrayLike||!': {
    check: function check(a) {
      return isArrayLike(a) || isNil(a);
    },
    text: '$n argument must be array-like, or undefined, or null!',
    error: TypeError
  },
  date: {
    check: isDate,
    text: '$n argument must be a date!',
    error: TypeError
  },
  'date||!': {
    check: function check(d) {
      return isDate(d) || isNil(d);
    },
    text: '$n argument must be a date, or undefined, or null!',
    error: TypeError
  },
  dateLike: {
    check: isDateLike,
    text: '$n argument must be date-like!',
    error: TypeError
  },
  'dateLike||!': {
    check: function check(d) {
      return isDateLike(d) || isNil(d);
    },
    text: '$n argument must be date-like, or undefined, or null!',
    error: TypeError
  },
  function: {
    check: isFunction,
    text: '$n argument must be a function!',
    error: TypeError
  },
  'function||!': {
    check: function check(f) {
      return isFunction(f) || isNil(f);
    },
    text: '$n argument must be a function, or undefined, or null!',
    error: TypeError
  },
  int: {
    check: isInteger,
    text: '$n argument must be an integer!',
    error: TypeError
  },
  'int||!': {
    check: function check(i) {
      return isInteger(i) || isNil(i);
    },
    text: '$n argument must be an integer, or undefined, or null!',
    error: TypeError
  },
  intLike: {
    check: isIntegerLike,
    text: '$n argument must be integer-like!',
    error: TypeError
  },
  'intLike||!': {
    check: function check(i) {
      return isIntegerLike(i) || isNil(i);
    },
    text: '$n argument must be integer-like, or undefined, or null!',
    error: TypeError
  },
  number: {
    check: isNumber,
    text: '$n argument must be a number!',
    error: TypeError
  },
  'number||!': {
    check: function check(n) {
      return isNumber(n) || isNil(n);
    },
    text: '$n argument must be a number, or undefined, or null!',
    error: TypeError
  },
  numberLike: {
    check: isNumberLike,
    text: '$n argument must be number-like!',
    error: TypeError
  },
  'numberLike||!': {
    check: function check(n) {
      return isNumberLike(n) || isNil(n);
    },
    text: '$n argument must be number-like, or undefined, or null!',
    error: TypeError
  },
  object: {
    check: isObject,
    text: '$n argument must be an object!',
    error: TypeError
  },
  'object||!': {
    check: function check(o) {
      return isObject(o) || isNil(o);
    },
    text: '$n argument must be an object, or undefined, or null!',
    error: TypeError
  },
  regexp: {
    check: isRegExp,
    text: '$n argument must be a regular expression!',
    error: TypeError
  },
  'regexp||!': {
    check: function check(r) {
      return isRegExp(r) || isNil(r);
    },
    text: '$n argument must be a regular expression, or undefined, or null!',
    error: TypeError
  },
  string: {
    check: isString,
    text: '$n argument must be a string!',
    error: TypeError
  },
  'string||!': {
    check: function check(s) {
      return isString(s) || isNil(s);
    },
    text: '$n argument must be a string, or undefined, or null!',
    error: TypeError
  }
};

/**
 * @module D
 * @private
 * @description Exports D function.
 */

/**
 * @function D
 * @public
 * @param {*} [value] - Any value.
 * @returns {DWrap} Wrap of the argument.
 * @description Function for creating a D-wrap of an object.
 *
 * @example
 * D({});            // Super
 * D(() => {});      // Func
 * D([]);            // Arr
 * D(1);             // Num
 * D('1');           // Str
 * D(new Date());    // Dat
 * D(document.body); // Elem
 */
function D$1(value) {
  for (var i = constructors.length - 1; i >= 0; i--) {
    var levelConstructors = constructors[i];

    for (var k = 0, len = levelConstructors.length; k < len; k++) {
      var _constructor = levelConstructors[k];

      if (value instanceof _constructor.cls) {
        return value;
      }

      if (_constructor.check(value)) {
        return new _constructor.cls(value);
      }
    }
  }
}

/**
 * @module helpers/iterate
 * @private
 * @description Exports iterate method.
 */

/**
 * @callback IterationCallback
 * @param {*} value - Iteration value.
 * @param {String|Number} key - Iteration key.
 * @param {*} object - Initial iterable object.
 */

/**
 * @function iterate
 * @param {(Object|Array|null|undefined)} object - Value to iterate over.
 * @param {IterationCallback} callback - Callback that is called on every iteration.
 * @returns {*} If callback returns not undefined then iterate returns this value.
 * @description Function for iterating over all types of values.
 */
function iterate(object, callback) {
  var array = isArrayLike(object);
  var iteratedKeys = {};

  var iterated = 0;

  for (var key in object) {
    if ({}.hasOwnProperty.call(iteratedKeys, key)) {
      continue;
    }

    iteratedKeys[key] = true;

    if ({}.hasOwnProperty.call(object, key)) {
      if (array && iterated++ >= object.length) {
        break;
      }

      var value = callback(object[key], array ? Number(key) : key, object);

      if (!isUndefined(value)) {
        return value;
      }
    }
  }
}

/**
 * @module helpers/assign
 * @private
 * @description Exports Object.assign-like method.
 */

/**
 * @const
 * @function assign
 * @param {Object} target - Object to assign rest of arguments to.
 * @param {...Object} objects - Objects that are assigned to the target.
 * @returns {Object} Target.
 */
function assign$1(target) {
  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objects[_key - 1] = arguments[_key];
  }

  iterate(arguments, function (source, index) {
    if (index) {
      iterate(source, function (value, key) {
        target[key] = value;
      });
    }
  });

  return target;
}

/**
 * @module helpers/defineProperty
 * @private
 * @description Exports defineProperty and dynamicDefineProperties methods.
 */

/**
 * @callback propertyGeneratorCallback
 * @param {String} name - Name of the property.
 * @param {Number} i - Index of the array.
 * @returns {*} Generated property.
 */

/**
 * @function dynamicDefineProperties
 * @param {Object} target - Object to define properties for.
 * @param {Array} properties - Object which keys are properties.
 * @param {propertyGeneratorCallback} propertyGenerator - Callback for every property.
 * @returns {void}
 * @description Function for dynamic creating properties based on name of the method.
 */
function dynamicDefineProperties(target, properties, propertyGenerator) {
  iterate(properties, function (name, i) {
    Object.defineProperty(target, name, {
      value: propertyGenerator(name, i),
      writable: true,
      enumerable: false,
      configurable: true
    });
  });
}

/**
 * @function defineProperties
 * @param {Object} target - Target to define properties for.
 * @param {Object} properties - Object with properties needed to be assign to the target.
 * @returns {void}
 * @description Function for defining properties of an object.
 */
function defineProperties(target, properties) {
  iterate(properties, function (method, name) {
    if (/^get /.test(name)) {
      Object.defineProperty(target, name.replace(/^get /, ''), {
        get: method,
        set: undefined,
        enumerable: false,
        configurable: true
      });

      return;
    }

    if (/^set /.test(name)) {
      Object.defineProperty(target, name.replace(/^set /, ''), {
        set: method,
        get: undefined,
        enumerable: false,
        configurable: true
      });

      return;
    }

    if (/^get\/set /.test(name)) {
      Object.defineProperty(target, name.replace(/^get\/set /, ''), {
        get: method.get,
        set: method.set,
        enumerable: false,
        configurable: true
      });

      return;
    }

    if (name !== 'Symbol.toStringTag') {
      Object.defineProperty(target, name, {
        value: method,
        writable: true,
        enumerable: false,
        configurable: true
      });
    }
  });
}

/**
 * @module helpers/Symbol
 * @private
 * @description Exports Symbol class.
 */

var _Symbol = global$1.Symbol || {
  toStringTag: 'Symbol.toStringTag',
  iterator: Math.random().toString(36)
};

/**
 * @module helpers/toArray
 * @private
 * @description Exports toArray method.
 */

/**
 * @function toArray
 * @param {*} value - Any value.
 * @param {Boolean} [createNewArray = false] - If it is needed to create new array.
 * @returns {Array} Create array.
 * @description Function for creating an array of any value.
 */
function toArray$1(value, createNewArray) {
  if (isArray(value) && !createNewArray) {
    return value;
  }

  var array = [];

  if (isArrayLike(value) && !isString(value)) {
    iterate(value, function (value) {
      array.push(value);
    });
  } else {
    array.push(value);
  }

  return array;
}

/**
 * @module helpers/validate
 * @private
 * @description Exports validate method.
 */

var numbers = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th'];

/**
 * @function validate
 * @private
 * @param {Object} args - Arguments of function.
 * @param {Object} options - Object with validate parameters.
 * @param {String} [name] - Name of the function what called validate.
 * @returns {void}
 * @description Function for checking arguments of other functions.
 */
function validate$1(args, options, name) {
  iterate(options, function (array, number) {
    if (!isArray(array)) {
      array = [array];
    }

    iterate(array, function (checker) {
      checker = validateCheckExpressions[checker];

      if (!checker.check(args[number])) {
        throw new checker.error(checker.text.replace('$n', numbers[number]) + (name ? ' (at ' + name + ')' : ''));
      }
    });
  });
}

/**
 * @module Alphabet
 * @private
 * @mixin
 * @description Exports Alphabet class.
 */

/**
 * @typedef {String} Char
 * @public
 * @description A string of one char.
 */

/**
 * @class Alphabet
 * @public
 * @param {ArrayLike} alphabet - Alphabet to wrap.
 * @returns {Alphabet} Instance of Alphabet.
 * @description Class for alphabet manipulations: add, delete symbols, generate a token from an alphabet,
 * check if an alphabet contains a word.
 *
 * @example
 * new Alphabet(['a', 'b', 'c']);
 */

var Alphabet = function () {
  function Alphabet() {
    var alphabet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, Alphabet);

    var a = {};

    for (var i = 0, length = alphabet.length; i < length; i++) {
      var char = alphabet[i];

      if (!check$1(char)) {
        throw new Error('Each element of an array must be a single char! (in Alphabet)');
      }

      a[char] = char;
    }

    /**
     * @member {Object} Alphabet#$$
     * @public
     * @description The alphabet.
     */
    Object.defineProperty(this, '$$', { value: a });
  }

  /**
   * @method Alphabet#add
   * @public
   * @param {...Char} chars - Chars to add.
   * @returns {Alphabet} Returns this.
   * @description Method for adding new letters to the alphabet.
   *
   * @example
   * const alphabet = new Alphabet(['a', 'b', 'c']);
   *
   * alphabet.add('d', 'e');
   *
   * alphabet.get().$; // ['a', 'b', 'c', 'd', 'e']
   */


  createClass(Alphabet, [{
    key: 'add',
    value: function add() {
      for (var _len = arguments.length, chars = Array(_len), _key = 0; _key < _len; _key++) {
        chars[_key] = arguments[_key];
      }

      for (var i = 0, length = chars.length; i < length; i++) {
        var char = chars[i];

        if (!check$1(char)) {
          throw new Error('Each argument must be a single char! (in Alphabet#add)');
        }

        this.$$[char] = char;
      }

      return this;
    }

    /**
     * @method Alphabet#contains
     * @public
     * @param {String} word - Word to check if it is in the alphabet or not.
     * @returns {Boolean} If the word in the alphabet or not.
     * @description Method that returns if a word is in alphabet or not.
     *
     * @example
     * const alphabet = new Alphabet(['f', 'b', 'o', 'a', 'r']);
     *
     * alphabet.contains('foo'); // true
     * alphabet.contains('bar'); // true
     * alphabet.contains('baz'); // false
     */

  }, {
    key: 'contains',
    value: function contains(word) {
      validate$1([word], ['string'], 'Alphabet#contains');

      var alphabet = this.$$;

      for (var i = 0, length = word.length; i < length; i++) {
        if (!alphabet[word[i]]) {
          return false;
        }
      }

      return true;
    }

    /**
     * @method Alphabet#delete
     * @public
     * @param {...Char} chars - Chars to delete.
     * @returns {Alphabet} Returns this.
     * @description Method for deleting letters from the alphabet.
     *
     * @example
     * const alphabet = new Alphabet(['a', 'b', 'c', 'd']);
     *
     * alphabet.delete('a');
     *
     * alphabet.get().$; // ['b', 'c', 'd']
     *
     * alphabet.delete('b', 'd');
     *
     * alphabet.get().$; // ['c']
     */

  }, {
    key: 'delete',
    value: function _delete() {
      for (var _len2 = arguments.length, chars = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        chars[_key2] = arguments[_key2];
      }

      for (var i = 0, length = chars.length; i < length; i++) {
        var char = chars[i];

        if (!check$1(char)) {
          throw new Error('Each argument must be a single char! (in Alphabet#delete)');
        }

        delete this.$$[char];
      }

      return this;
    }

    /**
     * @method Alphabet#get
     * @returns {Array} Wrap of an array of alphabet letters.
     * @description Method for getting array of alphabet letters.
     *
     * @example
     * new Alphabet(['a', 'b', 'c']).get().$; // ['a', 'b', 'c']
     */

  }, {
    key: 'get',
    value: function get() {
      return Object.keys(this.$$);
    }

    /**
     * @method Alphabet#token
     * @public
     * @param {Number} length - Token length.
     * @returns {String} Token.
     * @description Method for generating random token with given length.
     *
     * @example
     * new Alphabet(['a', 'b', 'c']).token(4); // 'abcb'
     */

  }, {
    key: 'token',
    value: function token(length) {
      validate$1([length], [['intLike', '>0']], 'Alphabet#token');

      var alphabet = Object.keys(this.$$);
      var len = alphabet.length;
      var token = '';

      for (var i = 0; i < length; i++) {
        token += alphabet[Math.floor(Math.random() * len)];
      }

      return token;
    }
  }]);
  return Alphabet;
}();

defineProperties(Alphabet.prototype, defineProperty({}, _Symbol.toStringTag, 'Alphabet'));

function check$1(char) {
  return isString(char) && char.length === 1;
}

/**
 * @function alphabet
 * @public
 * @param {String} string - String to generate an alphabet from.
 * @returns {Alphabet} New instance of Alphabet.
 * @description Function for creating an alphabet from a string that has format like this:
 * '&lt;char1&gt;-&lt;char2&gt; &lt;char3&gt;-&lt;char4&gt;'
 *
 * @example
 * const a1 = alphabet('a-c 1-3');
 * const a2 = alphabet('5-5f-g');
 *
 * a1.get().$; // ['1', '2', '3', 'a', 'b', 'c']
 * a2.get().$; // ['5', 'f', 'g']
 */
function alphabet(string) {
  validate$1([string], ['string']);

  var ranges = string.split(/([\s\S]-+[\s\S])?/g);
  var length = ranges.length;
  var alphabet = [];

  for (var i = 0; i < length; i++) {
    var range = ranges[i];

    if (!range || range === ' ') {
      continue;
    }

    if (/-/.test(range) && !/[\s\S]-+[\s\S]/.test(range)) {
      throw new Error('Wrong part of the string (' + range + ')! (in alphabet)');
    }

    if (/-/.test(range)) {
      var start = range.charCodeAt(0);
      var end = range.charCodeAt(2);

      if (start > end) {
        throw new Error('Start of the range must be before its end! (in alphabet)');
      }

      for (var k = 0, len = end - start + 1; k < len; k++) {
        alphabet.push(String.fromCharCode(start + k));
      }

      continue;
    }

    if (range.length === 1) {
      alphabet.push(range);
    }
  }

  return new Alphabet(alphabet);
}

/**
 * @module Switcher
 * @private
 * @mixin
 * @description Exports Switcher class.
 */

/**
 * @typedef {'boolean'|'equals'|'strictEquals'|'call'} SwitcherMode
 * @public
 * @description Enum type of switcher modes.
 */

/**
 * @callback SwitcherCallCallback
 * @public
 * @param {*} value - Switcher value.
 * @returns {Boolean|*} On what the callback returns depends if the case is a match (truthy for the match).
 */

/**
 * @callback SwitcherMatchCallback
 * @public
 * @param {...*} args - Arguments from the second argument that switcher was called with.
 * @param {*} value - Switcher value.
 * @param {*} matched - Switcher matched case.
 */

/**
 * @class Switcher
 * @public
 * @param {Object} [cases = {}] - Object of cases.
 * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.
 * @param {*} [defaultValue] - Switcher default value.
 * @returns {Switcher} - Instance of Switcher.
 * @description Switcher class for creating functions working similar to switch (value) {} construction,
 * but with the value assignment. Switcher instance is a function that accepts a value argument and an optional
 * args argument. Args with additional switcher value and matched case
 * are passed into the function of the matched case (if it is a function).
 *
 * @example
 * const switcher = new Switcher();
 * const switcher = new Switcher({
 *   case1: 'value1',
 *   case2: 'value2'
 * });
 * const switcher = new Switcher('strictEquals');
 * const switcher = new Switcher({
 *   case1: 'value1',
 *   case2: 'value2'
 * }, 'strictEquals');
 * const switcher = new Switcher('strictEquals', 'defaultValue');
 * const switcher = new Switcher({
 *   case1: 'value1',
 *   case2: 'value2'
 * }, 'strictEquals', 'defaultValue');
 *
 * // See [switcher]{@link switcher} examples for more information.
 */

var Switcher = function (_Function) {
  inherits(Switcher, _Function);

  function Switcher() {
    var cases = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'equals';

    var _ret;

    var defaultValue = arguments[2];
    classCallCheck(this, Switcher);

    var _this = possibleConstructorReturn(this, (Switcher.__proto__ || Object.getPrototypeOf(Switcher)).call(this));

    if (isString(cases)) {
      if (!isUndefined(arguments[1])) {
        defaultValue = mode;
      }

      mode = cases;
      cases = {};
    }

    var eventualCases = [];

    iterate(cases, function (value, Case) {
      eventualCases.push({ case: Case, value: value });
    });

    function switcher(value) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var _switcher$$$ = switcher.$$,
          mode = _switcher$$$.mode,
          def = _switcher$$$.default,
          cases = _switcher$$$.cases;


      var ret = iterate(cases, function (_ref) {
        var val = _ref.value,
            Case = _ref.case;

        if (mode === 'boolean' && Case ||
        /* eslint eqeqeq: 0 */
        mode === 'equals' && Case == value || mode === 'strictEquals' && Case === value || mode === 'call' && Case(value)) {
          return { case: Case, value: val };
        }
      });

      if (isUndefined(ret)) {
        ret = { value: def };
      }

      if (!isFunction(ret.value)) {
        return ret.value;
      }

      args = toArray$1(args, true);
      args.push(value, ret.case);

      return ret.value.apply(null, args);
    }

    /**
     * @member Switcher#$$
     * @type {Object}
     * @protected
     * @property {Array} cases - Array of cases.
     * @property {SwitcherMode} mode - Switcher mode.
     * @property {*} default - Switcher default value.
     * @description Config parameters.
     */
    Object.defineProperty(switcher, '$$', {
      value: {
        cases: eventualCases,
        mode: mode,
        default: defaultValue
      }
    });
    Object.setPrototypeOf(switcher, Switcher.prototype);

    return _ret = switcher, possibleConstructorReturn(_this, _ret);
  }

  /**
   * @method Switcher#case
   * @public
   * @param {*|SwitcherCallCallback|Array.<*|SwitcherCallCallback>} cases - Case or an array of cases.
   * @param {*|SwitcherMatchCallback} value - Value that has to be assigned or a function
   * that is called with switcher value, if it's the case.
   * @returns {Switcher} Returns this.
   * @description Method for defining new cases.
   *
   * @example
   * const sw = new Switcher()
   *   .case(1, 'one')
   *   .case(2, 'two');
   *
   * sw(1); // 'one'
   * sw(2); // 'two'
   */


  createClass(Switcher, [{
    key: 'case',
    value: function _case(cases, value) {
      var _this2 = this;

      if (!isArray(cases)) {
        cases = [cases];
      }

      iterate(cases, function (Case) {
        _this2.$$.cases.push({ case: Case, value: value });
      });

      return this;
    }

    /**
     * @method Switcher#default
     * @public
     * @param {*} def - New default value.
     * @returns {Switcher} Returns this.
     * @description Method for redefining default switcher value.
     *
     * @example
     * const sw = new Switcher()
     *   .case(1, 'one')
     *   .default('three');
     *
     * sw(1); // 'one'
     * sw(2); // 'three'
     */

  }, {
    key: 'default',
    value: function _default(def) {
      this.$$.default = def;

      return this;
    }

    /**
     * @method Switcher#mode
     * @public
     * @param {SwitcherMode} mode - New switcher mode.
     * @returns {Switcher} Returns this.
     * @description Method for redefining switcher mode.
     *
     * @example
     * const sw = new Switcher()
     *   .mode('strictEquals')
     *   .case(1, 'number')
     *   .case('1', 'string');
     *
     * sw(1);   // 'number'
     * sw('1'); // 'string'
     */

  }, {
    key: 'mode',
    value: function mode(_mode) {
      this.$$.mode = _mode;

      return this;
    }
  }]);
  return Switcher;
}(Function);

defineProperties(Switcher.prototype, defineProperty({}, _Symbol.toStringTag, 'Switcher'));

/**
 * @function switcher
 * @public
 * @param {Object} [cases = {}] - Object of cases.
 * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.
 * @param {*} [defaultValue] - Switcher default value.
 * @returns {Switcher} New instance of Switcher.
 * @description Simple wrap of [new Switcher(...)]{@link Switcher}.
 * 
 * @example
 * const sw = switcher({
 *   1: 'foo',
 *   2: 'bar'
 * });
 * sw(1); // 'foo'
 * sw(2); // 'bar'
 * sw(3); // undefined
 * 
 * @example
 * const sw = switcher()
 *   .case([1, 2], 'foo')
 *   .case(3, 'bar');
 *   
 * sw(1); // 'foo'
 * sw(2); // 'foo'
 * sw(3); // 'bar'
 * 
 * @example
 * const sw = switcher('call')
 *   .case(isArray, 'array')
 *   .case(isString, 'string')
 *   .case(isNumber, 'number')
 *   .default('rest');
 *   
 * sw([]);    // 'array'
 * sw('foo'); // 'string'
 * sw(123);   // 'number'
 * sw({});    // 'rest'
 * 
 * @example
 * const sw = switcher({
 *   1: (value) => {
 *     console.log(value + 1);
 *   },
 *   2: () => {
 *     console.log(value - 1);
 *   }
 * });
 * 
 * sw(1); // 2
 * sw(2); // 1
 * 
 * @example
 * const sw = switcher({
 *   first: (array) => array[0],
 *   last: (array) => array[array.length - 1]
 * }, 'equals', (array, index) => array[index]);
 * const array = [1, 2, 3, 4];
 * 
 * sw('first', [array]); // 1
 * sw('last', [array]);  // 4
 * sw(1, [array]);       // 2
 * sw(2, [array]);       // 3
 */
function switcher(cases, mode, defaultValue) {
  return new (Function.prototype.bind.apply(Switcher, [null].concat(Array.prototype.slice.call(arguments))))();
}

/**
 * @function when
 * @public
 * @param {Boolean|*} condition - Condition used for returning the proper value.
 * @param {*} value1 - Value if the condition is truthy.
 * @param {*} value2 - Value if the condition is falsey.
 * @returns {*} value1 or value2.
 * @description Synonym for
 * [ternary operator]{@link https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Operators/Conditional_Operator}.
 * 
 * @example
 * when(true, 'true', 'false'); // 'true'
 */
function when(condition, value1, value2) {
  return condition ? value1 : value2;
}

/**
 * @module Super
 * @private
 * @mixin
 * @description Exports Super class.
 */

/**
 * @typedef {Super|Arr|Func|Elem|Str|Num|Dat|BlobObject} DWrap
 * @public
 * @description Any kind of D-Wrap.
 */

/**
 * @typedef {String|Number|null} Key
 * @public
 * @description Key type used in many methods.
 */

/**
 * @typedef {TreeElement[]} Tree
 * @public
 */

/**
 * @typedef {Object} TreeElement
 * @public
 * @property {Key} key - Tree element key.
 * @property {*} value - Tree element value.
 * @description {@link Tree} element.
 */

/**
 * @callback DeepIterationCallback
 * @public
 * @param {*} value - Current iteration value.
 * @param {String|Number} key - Current iteration key/index.
 * @param {*} object - Iteration object.
 * @param {Tree} tree - Tree of { key, value } elements.
 */

/**
 * @callback DeepReduceCallback
 * @public
 * @param {*} previousValue - Previous value.
 * @param {*} value - Current iteration value.
 * @param {String|Number} key - Current iteration key/index.
 * @param {*} object - Iteration object.
 * @param {Tree} tree - Tree of { key, value } elements.
 */

/**
 * @callback IterationCallback
 * @public
 * @param {*} value - Current iteration value.
 * @param {String|Number} key - Current iteration key/index.
 * @param {*} object - Iteration object.
 */

/**
 * @callback JSONCallback
 * @public
 * @param {String|null} key - Current value.
 * @param {*} value - Current key.
 * @param {Object} object - Iteration object.
 */

/**
 * @callback ObjectCallback
 * @public
 * @param {Object} newObject - The new object.
 * @param {*} value - Current iteration value.
 * @param {String|Number} key - Current iteration key/index.
 * @param {*} object - Iteration object.
 */

/**
 * @callback ReduceCallback
 * @public
 * @param {*} previousValue - Previous value.
 * @param {*} value - Current iteration value.
 * @param {String|Number} key - Current iteration key/index.
 * @param {*} object - Iteration object.
 */

/**
 * @callback SuperMethod
 * @public
 * @this {DWrap}
 */

var cloneSwitcher = switcher('call', function (object) {
  return object;
}).case(function (object) {
  return new Super(object) === object;
}, function (object) {
  return new (Object.getPrototypeOf(object).constructor)(new Super(object.$).deepClone().$);
}).case(isElement, function (object, deep) {
  return object.clone(deep);
}).case(isDate, function (object) {
  return new Date(object);
}).case(isRegExp, function (object) {
  return new RegExp(object.source, object.toString().match(/[gimuy]*$/)[0]);
}).case(isArray, function () {
  return [];
}).case(isPlainObject, function () {
  return {};
});

/**
 * @class Super
 * @public
 * @param {*} [object] - An object to wrap.
 * @returns {DWrap} Instance of Super.
 * @description Wrap of any value. And there is no way to create a nested wrap.
 *
 * @example
 * new Super({}); // Super
 */

var Super = function () {
  function Super(object) {
    classCallCheck(this, Super);

    if (object instanceof Super) {
      return object;
    }

    /**
     * @member Super#$
     * @type {*}
     * @public
     * @description Wrapped object.
     */
    Object.defineProperty(this, '$', { value: object });
  }

  /**
   * @method Super.addStaticProperties
   * @public
   * @param {String|Object} property - Either a string of a property or an object
   * with properties keys and values values.
   * @param {Object} [value] - If a property parameter is a string this has to be a property value.
   * @returns {this} Returns this.
   * @description Sets static properties for DWrap constructors.
   *
   * @example
   * Super.addStaticProperties('cool', 42);
   * Super.addStaticProperties('superCool', 42*42);
   */


  createClass(Super, [{
    key: 'assign',


    /**
     * @method Super#assign
     * @public
     * @param {...(Object|Super|*)} objects - Objects to be assigned to the object.
     * @returns {DWrap} Returns this.
     * @description Synonym for
     * [Object.assign]
     * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign}.
     *
     * @example
     * new Super({ a: 1, b: 2 }).assign({ a: 3 }, { c: 3, d: 4 }, { d: 5 }).$; // { a: 3, b: 2, c: 3, d: 5 }
     */
    value: function assign() {
      for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }

      var object = this.$;

      iterate(object && arguments, function (o) {
        iterate(new Super(o).$, function (value, key) {
          object[key] = value;
        });
      });

      return this;
    }

    /**
     * @method Super#average
     * @public
     * @param {IterationCallback} [callback = null] - Callback that is passed to {@link Super#sum}.
     * @returns {Number} Average value.
     * @description Synonym for object.sum(callback) / object.count.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).average();                         // 2
     * new Super({ a: 1, b: 2, c: 5 }).average((value) => value * value); // 10
     */

  }, {
    key: 'average',
    value: function average() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      validate$1([callback], ['function||!'], 'Super#average');

      return this.sum(callback) / this.count;
    }

    /**
     * @method Super#call
     * @public
     * @param {SuperMethod} func - Function to be called with this context.
     * @param {...*} args - Arguments to be called with.
     * @returns {*} Return of function call.
     * @description Synonym for func.call(DObject, ...args);
     *
     * @example
     * new Super({ a: 1 }).call(function (b, c) {
     *   return this.a + b + c;
     * }, 2, 3); // 6
     */

  }, {
    key: 'call',
    value: function call(func) {
      validate$1([func], ['function'], 'Super#call');

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return func.apply(this, args);
    }

    /**
     * @method Super#clone
     * @returns {DWrap} New object.
     * @description Method assigns properties of the object to an empty one and returns the new one.
     *
     * @example
     * new Super({ a: 1, b: { c: 2 } }).clone().$; // { a: 1, b: { c: 2 } }
     */

  }, {
    key: 'clone',
    value: function clone() {
      var object = this.$;
      var clone = cloneSwitcher(object, [object, false]);

      if (clone !== object) {
        iterate(object, function (value, key) {
          clone[key] = value;
        });
      }

      return new this.constructor(clone);
    }

    /**
     * @member Super#count
     * @type {Number}
     * @public
     * @readonly
     * @description Returns number of own enumerable keys of the object.
     *
     * @example
     * new Super({ a: 1, b: 2 }).count; // 2
     */

  }, {
    key: 'create',


    /**
     * @method Super#create
     * @public
     * @param {Object} [descriptors] - Descriptors passed to Object.create.
     * @returns {DWrap} New instance of D-Wrap.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create
     * @description Synonym for
     * [Object.create]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create}.
     *
     * @example
     * new Super({}).create({
     *   a: {
     *     value: 1,
     *     enumerable: false,
     *     writable: true,
     *     configurable: false
     *   }
     * }).$; // { a: 1 }
     */
    value: function create(descriptors) {
      return D$1(isPrimitive(this.$) ? undefined : Object.create(this.$, descriptors));
    }

    /**
     * @method Super#deepAssign
     * @public
     * @param {...*} objects - Objects to be assigned to the object.
     * @returns {DWrap} Returns this.
     * @description Deep analogue of {@link Super#assign}.
     *
     * @example
     * new Super({ a: 1 }).deepAssign(
     *   {
     *     b: {
     *       c: 2
     *     }
     *   },
     *   {
     *     a: {
     *       b: 1
     *     }
     *   },
     *   {
     *     a: {
     *       c: {
     *         d: 1
     *       }
     *     },
     *     b: 2
     *   },
     *   null
     * });
     * // {
     * //   a: {
     * //     b: 1,
     * //     c: {
     * //       d: 1
     * //     }
     * //   },
     * //   b: 2,
     * // }
     */

  }, {
    key: 'deepAssign',
    value: function deepAssign() {
      for (var _len3 = arguments.length, objects = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        objects[_key3] = arguments[_key3];
      }

      var object = this.$;

      if (isPrimitive(object)) {
        return this;
      }

      iterate(arguments, function (o) {
        _deepAssign(object, o);
      });

      return this;
    }

    /**
     * @method Super#deepClone
     * @public
     * @returns {DWrap} New instance of DWrap.
     * @description Deep cloning method. Clones plain objects, arrays, regular expressions and elements, the rest stays the same.
     *
     * @example
     * new Super({ a: 1, b: [2, 3], c: { d: 4 } }).deepClone().$;
     * // {
     * //   a: 1,
     * //   b: [2, 3],
     * //   c: { d: 4 }
     * // }
     */

  }, {
    key: 'deepClone',
    value: function deepClone() {
      return new this.constructor(_deepClone(this.$));
    }

    /**
     * @method Super#deepEquals
     * @public
     * @param {*} [object] - Object to compare to.
     * @returns {Boolean} - If the objects are deep equal or not.
     * @description Method for deep comparison of two objects.
     *
     * @example
     * new Super({ a: 1 }).deepEquals({ a: '1' }); // true
     * new Super(/1/).deepEquals(/1/);             // true
     */

  }, {
    key: 'deepEquals',
    value: function deepEquals() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return deepEqual(this.$, object, false);
    }

    /**
     * @method Super#deepEvery
     * @public
     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy iteration goes on and if falsey it stops.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {Boolean} If all the callback calls returned truthy value.
     * @description Returns boolean if all the callback calls returned truthy value.
     * Otherwise false. Deep analogue of {@link Super#every}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepEvery((value) => value < 4); // true
     * new Super({ a: {}, b: {}, c: {} }).deepEvery(() => false);              // true
     */

  }, {
    key: 'deepEvery',
    value: function deepEvery(callback, n) {
      if (arguments.length === 1 && !isFunction(callback)) {
        n = callback;
        callback = Boolean;
      } else if (arguments.length === 1) {
        n = Infinity;
      } else if (!arguments.length) {
        n = Infinity;
        callback = Boolean;
      }

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepEvery');

      n = Number(n);

      return _deepEvery(this.$, callback, n, [{ key: null, value: this.$ }]);
    }

    /**
     * @method Super#deepFilter
     * @public
     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy the element is included and if falsey it's excluded.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {DWrap} New D-Wrap of filtered object.
     * @description Returns filtered by the callback object. Deep analogue of {@link Super#filter}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value%2).$;     // { a: 1, b: { d: 3 } }
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value === 1).$; // { a: 1 }
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value > 3).$;   // {}
     */

  }, {
    key: 'deepFilter',
    value: function deepFilter(callback, n) {
      if (arguments.length === 1 && !isFunction(callback)) {
        n = callback;
        callback = Boolean;
      } else if (arguments.length === 1) {
        n = Infinity;
      } else if (!arguments.length) {
        n = Infinity;
        callback = Boolean;
      }

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFilter');

      var filtered = _deepFilter(this.$, callback, n, [{ key: null, value: this.$ }]);

      return D$1(isNil(filtered) ? filtered : filtered || {});
    }

    /**
     * @method Super#deepFind
     * @public
     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy iteration stops and if falsey it continues.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {Tree|null} Tree of { key, value } if something found and null if not.
     * @description Returns tree of the elements if something found and null if nothing found.
     * Deep analogue of {@link Super#find}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFind((value) => value === 2);
     * // [
     * //   { key: 'c', value: 2 },
     * //   { key: 'b', value: { c: 2, d: 3 } },
     * //   { key: null, value: <initial object> }
     * // ]
     */

  }, {
    key: 'deepFind',
    value: function deepFind(callback, n) {
      if (arguments.length === 1 && !isFunction(callback)) {
        n = callback;
        callback = Boolean;
      } else if (arguments.length === 1) {
        n = Infinity;
      } else if (!arguments.length) {
        n = Infinity;
        callback = Boolean;
      }

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFind');

      return _deepFind(this.$, callback, n, [{ key: null, value: this.$ }]);
    }

    /**
     * @method Super#deepForEach
     * @public
     * @param {DeepIterationCallback} callback - Called on each iteration.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {DWrap} Returns this.
     * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;
     * // { a: 1, b: { c: 4, d: 9 } }
     */

  }, {
    key: 'deepForEach',
    value: function deepForEach(callback) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');

      n = Number(n);

      _deepForEach(this.$, callback, n, [{ key: null, value: this.$ }]);

      return this;
    }

    /**
     * @method Super#deepForEach
     * @public
     * @param {DeepIterationCallback} callback - Called on each iteration.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {DWrap} Returns this.
     * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.
     * Unlike {@link Super#deepForEach} the callback is called on every value of every object inside
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;
     * // { a: 1, b: { c: 4, d: 9 } }
     */

  }, {
    key: 'deepForEachEntry',
    value: function deepForEachEntry(callback) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');

      n = Number(n);

      _deepForEachEntry(this.$, callback, n, [{ key: null, value: this.$ }]);

      return this;
    }

    /**
     * @method Super#deepFreeze
     * @public
     * @returns {DWrap} Returns this.
     * @description Deep analogue of {@link Super#freeze}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFreeze(); // Super
     */

  }, {
    key: 'deepFreeze',
    value: function deepFreeze() {
      _deepFreeze(this.$);

      return this;
    }

    /**
     * @method Super#deepMap
     * @public
     * @param {DeepIterationCallback} callback - Called on each iteration.
     * Return value is used for creating a new object.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {DWrap} D-Wrap of the new object.
     * @description Returns a wrap of a new object using the callback. Deep analogue of {@link Super#map}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepMap((value) => value * value).$;
     * // { a: 1, b: { c: 4, d: 9 } }
     */

  }, {
    key: 'deepMap',
    value: function deepMap(callback) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepMap');

      n = Number(n);

      return D$1(_deepMap(this.$, callback, n, [{ key: null, value: this.$ }]));
    }

    /**
     * @method Super#deepReduce
     * @public
     * @param {DeepReduceCallback} callback - Called on each iteration.
     * Return value is passed to the next callback call.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @param {*} [IV = <first value>|undefined] - Initial value.
     * @returns {*} Modified IV.
     * @description Returns modified IV. Deep analogue of {@link Super#reduce}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepReduce((sum, value) => sum + value * value, Infinity, 0); // 14
     */

  }, {
    key: 'deepReduce',
    value: function deepReduce(callback) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
      var IV = arguments[2];

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepReduce');

      n = Number(n);

      var object = this.$;
      var tree = [{ key: null, value: this.$ }];

      if (arguments.length < 3) {
        return _deepReduce(object, callback, n, false, undefined, tree).IV;
      }

      return _deepReduce(object, callback, n, false, { IV: IV }, tree).IV;
    }

    /**
     * @method Super#deepSome
     * @public
     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy iteration stops and if falsey it continues.
     * @param {Number} [n = Infinity] - Iteration depth.
     * @returns {Boolean} If all the callback calls returned truthy value.
     * @description Returns true if some of the callback calls returned truthy value.
     * Otherwise false. Deep analogue of {@link Super#some}.
     *
     * @example
     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepSome((value) => value > 4); // false
     * new Super({ a: {}, b: {}, c: {} }).deepSome(() => true);               // false
     */

  }, {
    key: 'deepSome',
    value: function deepSome(callback, n) {
      if (arguments.length === 1 && !isFunction(callback)) {
        n = callback;
        callback = Boolean;
      } else if (arguments.length === 1) {
        n = Infinity;
      } else if (!arguments.length) {
        n = Infinity;
        callback = Boolean;
      }

      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepSome');

      n = Number(n);

      return _deepSome(this.$, callback, n, [{ key: null, value: this.$ }]);
    }

    /**
     * @method Super#deepStrictEquals
     * @public
     * @param {*} [object] - Object to compare to.
     * @returns {Boolean} - If the objects are deep strict equal or not.
     * @description Method for deep strict comparison of two objects.
     *
     * @example
     * new Super({ a: 1 }).deepStrictEquals({ a: '1' }); // false
     * new Super(/1/).deepStrictEquals(/1/);             // true
     */

  }, {
    key: 'deepStrictEquals',
    value: function deepStrictEquals() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return deepEqual(this.$, object, true);
    }

    /**
     * @method Super#define
     * @param {String|Object} property - Either a string of a property or a descriptors object.
     * @param {Object} [descriptor] - If a property parameter is a string this has to be a property descriptor.
     * @returns {DWrap} Returns this.
     * @description Synonym for both
     * [Object.defineProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty}
     * and
     * [Object.defineProperties]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties}.
     *
     * @example
     * new Super({}).define('a', {
     *   value: 1,
     *   enumerable: false,
     *   writable: true,
     *   configurable: false
     * }).$; // { a: 1 }
     * new Super({}).define({
     *   a: {
     *     value: 1,
     *     enumerable: false,
     *     writable: true,
     *     configurable: false
     *   }
     * }).$; // { a: 1 }
     */

  }, {
    key: 'define',
    value: function define(property, descriptor) {
      if (arguments.length >= 2) {
        property = defineProperty({}, property, descriptor);
      }

      property = new Super(property).$;

      if (isObject(this.$)) {
        Object.defineProperties(this.$, property);
      }

      return this;
    }

    /**
     * @method Super#delete
     * @public
     * @param {...String} props - List of properties to delete.
     * @returns {DWrap} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete
     * @description Synonym for multiple
     * ["delete" operator]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete}.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).delete('c', 'a').$; // { b: 2 }
     */

  }, {
    key: 'delete',
    value: function _delete() {
      var object = this.$;

      for (var _len4 = arguments.length, props = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        props[_key4] = arguments[_key4];
      }

      iterate(object && props, function (property) {
        delete object[property];
      });

      return this;
    }

    /**
     * @method Super#equals
     * @public
     * @param {*} [object] - Object to compare.
     * @returns {Boolean} If the objects are equal or not.
     * @description Returns true if objects are equal using '==' operator and false if not. NaNs are considered to be equal.
     *
     * @example
     * new Super(3).equals('3');   // true
     * new Super(NaN).equals(NaN); // true
     */

  }, {
    key: 'equals',
    value: function equals(object) {
      var o = this.$;

      object = new Super(object).$;

      /* eslint eqeqeq: 0 */
      return o == object || isNaN(o) && isNaN(object);
    }

    /**
     * @method Super#every
     * @public
     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy iteration goes on and if falsey it stops.
     * @returns {Boolean} If all the callback calls returned truthy value.
     * @description Returns boolean if all the callback calls returned truthy value.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).every((value) => value < 4); // true
     * new Super({}).every(() => false);                            // true
     */

  }, {
    key: 'every',
    value: function every() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;

      validate$1([callback], ['function'], 'Super#every');

      return iterate(this.$, function (value, key, object) {
        if (!callback(value, key, object)) {
          return false;
        }
      }) !== false;
    }

    /**
     * @method Super#filter
     * @public
     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy the element is included and if falsey it's excluded.
     * @returns {DWrap} New D-Wrap of filtered object.
     * @description Returns filtered by the callback object.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).filter((value) => value%2).$; // { a: 1, c: 3 }
     * new Super(null).filter((value) => value%2).$;                 // null
     */

  }, {
    key: 'filter',
    value: function filter() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;

      validate$1([callback], ['function'], 'Super#filter');

      var object = this.$;
      var array = isArrayLike(object);

      /* eslint no-nested-ternary: 0 */
      var o = array ? [] : isNil(object) ? object : {};

      iterate(object, function (value, key) {
        if (callback(value, key, object)) {
          if (array) {
            o.push(value);
          } else {
            o[key] = value;
          }
        }
      });

      return D$1(o);
    }

    /**
     * @method Super#find
     * @public
     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy iteration stops and if falsey it continues.
     * @returns {{ key: Key, value: * }|null} { key, value } if found and null if not.
     * @description Returns found { key, value } if something found and null if nothing found.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).find((value) => value === 2); // { key: 'b', value: 2 }
     * new Super([1, 2, 3]).find((value) => value === 2);            // { key: 1, value: 2 }
     */

  }, {
    key: 'find',
    value: function find(callback) {
      validate$1([callback], ['function'], 'Super#find');

      return iterate(this.$, function (value, key, object) {
        if (callback(value, key, object)) {
          return { key: key, value: value };
        }
      }) || null;
    }

    /**
     * @method Super#forEach
     * @public
     * @param {IterationCallback} callback - Called on each iteration.
     * @returns {DWrap} Returns this.
     * @description Method for iterating over any object.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).forEach((value, key, object) => {
     *   object[key] = value * value;
     * }).$; // { a: 1, b: { c: 4, d: 5 } }
     */

  }, {
    key: 'forEach',
    value: function forEach(callback) {
      validate$1([callback], ['function'], 'Super#forEach');

      iterate(this.$, function (value, key, object) {
        callback(value, key, object);
      });

      return this;
    }

    /**
     * @method Super#freeze
     * @public
     * @returns {DWrap} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
     * @description Synonym for
     * [Object.freeze]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze}.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).freeze(); // Super
     */

  }, {
    key: 'freeze',
    value: function freeze() {
      Object.freeze(this.$);

      return this;
    }

    /**
     * @method Super#get
     * @public
     * @param {String|Object.<String, Function>} property - Either a string of a property or a getters object.
     * @param {Function} [getter] - If a property parameter is a string this has to be a getter function.
     * @returns {DWrap} Returns this.
     * @description Method for defining getters.
     *
     * @example
     * const object1 = new Super({}).get('a', () => 1).$;
     * object1.a; // 1
     *
     * const object2 = new Super({}).get({
     *   a: () => 2
     * }).$;
     * object2.a; // 2
     */

  }, {
    key: 'get',
    value: function get(property, getter) {
      if (arguments.length >= 2) {
        property = defineProperty({}, property, getter);
      }

      var object = this.$;

      iterate(isObject(object) && new Super(property).$, function (getter, property) {
        Object.defineProperty(object, property, { get: getter });
      });

      return this;
    }

    /**
     * @method Super#has
     * @public
     * @param {String|*} key - Property to check.
     * @returns {Boolean} Returns true if the object has the key and false if not.
     * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in
     * @description Synonym for
     * ["in" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in}.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).has('b'); // true
     */

  }, {
    key: 'has',
    value: function has(key) {
      var object = this.$;

      if (!isObject(object)) {
        return false;
      }

      return key in object;
    }

    /**
     * @method Super#hasOwn
     * @public
     * @param {String|*} key - Property to check.
     * @returns {Boolean} Returns true if the object has its own key and false if not.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty
     * @description Synonym for
     * [Object#hasOwnProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty}.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).hasOwn('b');              // true
     * new Super({ a: 1, b: 2, c: 3 }).hasOwn('hasOwnProperty'); // false
     */

  }, {
    key: 'hasOwn',
    value: function hasOwn(key) {
      var object = this.$;

      if (!isObject(object)) {
        return false;
      }

      return {}.hasOwnProperty.call(object, key);
    }

    /**
     * @method Super#instanceof
     * @public
     * @param {Function} constructor - Constructor to check.
     * @returns {Boolean} If the object is an instance of constructor.
     * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof
     * @description Synonym for
     * ["instanceof" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}.
     */

  }, {
    key: 'instanceof',
    value: function _instanceof(constructor) {
      return this.$ instanceof constructor;
    }

    /**
     * @method Super#isFrozen
     * @public
     * @returns {Boolean} If the object is frozen.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
     * @description Synonym for
     * [Object.isFrozen]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen}.
     *
     * @example
     * new Super({}).freeze().isFrozen(); // true
     */

  }, {
    key: 'isFrozen',
    value: function isFrozen() {
      return Object.isFrozen(this.$);
    }

    /**
     * @method Super#json
     * @public
     * @param {JSONCallback|String[]} [replacer] - See the link.
     * @param {String|Number} [space] - See the link.
     * @returns {String} JSON string.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
     * @description Synonym for
     * [JSON.stringify]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify}.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).json(); // '{"a":1,"b":2,"c":3}'
     * new Super({ a: 1, b: 2, c: 3 }).json('    ');
     * // {
     * //     "a": 1,
     * //     "b": 2,
     * //     "c": 3
     * // }
     * new Super({ a: 1, b: 2, c: 3 }).json((key, value) => {
     *   if (typeof value === 'number') {
     *     return value%2 ? key + value0 : undefined;
     *   }
     *
     *   return value;
     * }, 2);
     * // {
     * //   "a": "a1",
     * //   "c": "c3"
     * // }
     */

  }, {
    key: 'json',
    value: function json(replacer, space) {
      if (arguments.length === 1 && !isFunction(replacer) && !isArray(replacer)) {
        [].unshift.call(arguments, null);
      }

      [].unshift.call(arguments, this.$);

      return JSON.stringify.apply(JSON, arguments);
    }

    /**
     * @method Super#keyOf
     * @public
     * @param {*} value - Value to find.
     * @returns {String|Number|null} A key or an index if found and null if not.
     * @description Method for finding equal to the argument value in the object. NaNs are considered to be equal.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).keyOf(2);   // 'b'
     * new Super({ a: 1, b: 2, c: 3 }).keyOf('2'); // 'b'
     */

  }, {
    key: 'keyOf',
    value: function keyOf(value) {
      var key = iterate(this.$, function (val, key) {
        if (val == value || isNaN(val) && isNaN(value)) {
          return key;
        }
      });

      return isUndefined(key) ? null : key;
    }

    /**
     * @method Super#keyOfStrict
     * @public
     * @param {*} value - Value to find.
     * @returns {String|Number|null} A key or an index if found and null if not.
     * @description Method for finding strict equal to the argument value in the object. NaNs are considered to be equal.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict(2);   // 'b'
     * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict('2'); // 'b'
     */

  }, {
    key: 'keyOfStrict',
    value: function keyOfStrict(value) {
      var key = iterate(this.$, function (val, key) {
        if (val === value || isNaN(val) && isNaN(value)) {
          return key;
        }
      });

      return isUndefined(key) ? null : key;
    }

    /**
     * @method Super#keys
     * @public
     * @returns {DWrap} A wrap of the keys array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
     * @description Synonym for
     * [Object.keys]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys}.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).keys().$; // ['a', 'b', 'c']
     * new Super(null).keys().$;                 // []
     */

  }, {
    key: 'keys',
    value: function keys() {
      var object = this.$;

      return D$1(isObject(object) ? Object.keys(object) : []);
    }

    /**
     * @method Super#map
     * @public
     * @param {IterationCallback} callback - Called on each iteration.
     * Return value is used for creating a new object.
     * @returns {DWrap} D-Wrap of the new object.
     * @description Returns a wrap of a new object using the callback.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).map((value) => value * 2).$; // { a: 2, b: 4, c: 6 }
     * new Super(null).map((value) => value * 2).$;                 // null
     */

  }, {
    key: 'map',
    value: function map(callback) {
      validate$1([callback], ['function'], 'Super#map');

      var object = this.$;
      var o = isArrayLike(object) ? [] : isNull(object) ? null : {};

      iterate(object, function (value, key) {
        o[key] = callback(value, key, object);
      });

      return D$1(o);
    }

    /**
     * @method Super#max
     * @public
     * @param {IterationCallback} callback - Called on each iteration.
     * Return value is used for comparison with the previous max value.
     * @returns {{key: Key, value: Number}} Object with max value and key of the max value.
     * @description Method for finding max value in the object.
     * If no callback is present comparison is between values of the object.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).max();                     // { key: 'c', value: 3 }
     * new Super({ a: 1, b: 2, c: 3 }).max((value) => 4 - value); // { key: 'a', value: 3 }
     * new Super({ a: 'a', b: 'b', c: 'c' }).max();               // { key: null, value: -Infinity }
     */

  }, {
    key: 'max',
    value: function max() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      validate$1([callback], ['function||!'], 'Super#max');

      return this.object(function (max, value, key, object) {
        var val = Number(callback ? callback(value, key, object) : value);

        if (val > max.value) {
          max.key = key;
          max.value = val;
        }
      }, { key: null, value: -Infinity }).$;
    }

    /**
     * @method Super#min
     * @public
     * @param {IterationCallback} callback - Called on each iteration.
     * Return value is used for comparison with the previous min value.
     * @returns {{key: Key, value: Number}} Object with min value and key of the min value.
     * @description Method for finding min value in the object.
     * If no callback is present comparison is between values of the object.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).min();                     // { key: 'a', value: 1 }
     * new Super({ a: 1, b: 2, c: 3 }).min((value) => 4 - value); // { key: 'c', value: 1 }
     * new Super({ a: 'a', b: 'b', c: 'c' }).min();               // { key: null, value: Infinity }
     */

  }, {
    key: 'min',
    value: function min() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      validate$1([callback], ['function||!'], 'Super#min');

      return this.object(function (min, value, key, object) {
        var val = Number(callback ? callback(value, key, object) : value);

        if (val < min.value) {
          min.key = key;
          min.value = val;
        }
      }, { key: null, value: Infinity }).$;
    }

    /**
     * @method Super#object
     * @public
     * @param {ObjectCallback} callback - Called on each iteration.
     * @param {Object|*} [object = {}] - Object that is passed to the callback.
     * @returns {DWrap} Wrap of the new object.
     * @description Type of {@link Super#reduce}.
     * The object is passed as an argument into the callback. The output is this object.
     *
     * @example
     * new Super({ a: 1, b: 2 }).object((object, value, key) => {
     *   object[key] = value;
     *   object[key + key] = value * 2;
     * }).$; // { a: 1, aa: 2, b: 2, bb: 4 }
     */

  }, {
    key: 'object',
    value: function object(callback) {
      var _object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      validate$1([callback], ['function'], 'Super#object');

      iterate(this.$, function (value, key, obj) {
        callback(_object, value, key, obj);
      });

      return D$1(_object);
    }

    /**
     * @method Super#prop
     * @public
     * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.
     * @param {*} [value] - If a property parameter is a string
     * this has to be an assigned value if it's present.
     * @returns {DWrap|*} Returns this if it's a setter or a value if getter.
     * @description Method for getting and setting properties.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).prop('a');              // 1
     * new Super({ a: 1, b: 2, c: 3 }).prop('a', 7).$;         // { a: 7, b: 2, c: 3 }
     * new Super({ a: 1, b: 2, c: 3 }).prop({ a: 7, b: 8 }).$; // { a: 7, b: 8, c: 3 }
     */

  }, {
    key: 'prop',
    value: function prop(property, value) {
      if (arguments.length <= 1 && isString(property)) {
        return this.$ ? this.$[property] : undefined;
      }

      if (arguments.length >= 2) {
        property = defineProperty({}, property, value);
      }

      return this.assign(property);
    }

    /**
     * @method Super#propertyDescriptor
     * @public
     * @param {String} property - Property of the object.
     * @returns {Object|undefined} Property descriptor.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
     * @descriptor Synonym for
     * [Object.getOwnPropertyDescriptor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor}.
     *
     * @example
     * new Super({ a: 1 }).propertyDescriptor('a');
     * // {
     * //   value: 1,
     * //   enumerable: true,
     * //   writable: true,
     * //   configurable: true
     * // }
     */

  }, {
    key: 'propertyDescriptor',
    value: function propertyDescriptor(property) {
      var object = this.$;

      return isObject(object) ? Object.getOwnPropertyDescriptor(object, property) : undefined;
    }

    /**
     * @method Super#propertyNames
     * @public
     * @returns {DWrap} D-Wrap of the names array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames
     * @descriptor Synonym for
     * [Object.getOwnPropertyNames]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames}.
     *
     * @example
     * new Super({ a: 1, b: 2 }).define('c', { value: 3 }).$; // ['a', 'b', 'c']
     */

  }, {
    key: 'propertyNames',
    value: function propertyNames() {
      var object = this.$;

      return D$1(isObject(object) ? Object.getOwnPropertyNames(object) : []);
    }

    /**
     * @method Super#propertySymbols
     * @public
     * @returns {DWrap} D-Wrap of the names array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols
     * @descriptor Synonym for
     * [Object.getOwnPropertySymbols]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols}.
     *
     * @example
     * new Super({ [Symbol('foo')]: 1 }).define(Symbol('bar'), { value: 2 }).$; // [Symbol('foo'), Symbol('bar')]
     */

  }, {
    key: 'propertySymbols',
    value: function propertySymbols() {
      var object = this.$;

      return D$1(isObject(object) ? Object.getOwnPropertySymbols(object) : []);
    }

    /**
     * @method Super#proto
     * @public
     * @param {*} [proto] - If it's present it's set as a prototype to the object.
     * @returns {DWrap} In getter mode returns wrap of the prototype and in setter mode returns this.
     * @description Synonym for both
     * [Object.getPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf}
     * and
     * [Object.setPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf}.
     */

  }, {
    key: 'proto',
    value: function proto(_proto) {
      var object = this.$;
      var isContextObject = !isNil(object);

      if (arguments.length) {
        if (isContextObject && (isObject(_proto) || isNull(_proto))) {
          Object.setPrototypeOf(object, _proto);
        }

        return this;
      }

      return isContextObject ? new Super(Object.getPrototypeOf(object)) : new Super();
    }

    /**
     * @method Super#reduce
     * @public
     * @param {ReduceCallback} callback - Called on each iteration.
     * Return value is passed to the next callback call.
     * @param {*} [IV = <first value>|undefined] - Initial value.
     * @returns {*} Modified IV.
     * @description Returns modified IV. If the second argument is not present first value in the object is taken
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).reduce((sum, value) => sum + value * value, 0); // 14
     */

  }, {
    key: 'reduce',
    value: function reduce(callback, IV) {
      validate$1([callback], ['function'], 'Super#reduce');

      var object = this.$;

      var startKey = void 0;

      if (arguments.length === 1) {
        iterate(object, function (value, key) {
          startKey = key;
          IV = value;

          return true;
        });
      }

      iterate(object, function (value, key) {
        if (key !== startKey) {
          IV = callback(IV, value, key, object);
        }
      });

      return IV;
    }

    /**
     * @method Super#set
     * @public
     * @param {String|Object.<String, Function>} property - Either a string of a property or a setters object.
     * @param {Function} [setter] - If a property parameter is a string this has to be a setter function.
     * @returns {DWrap} Returns this.
     * @description Method for defining setters.
     *
     * @example
     * const object = new Super({})
     *   .get('public', function () {
     *     return this._private;
     *   })
     *   .set('public', function (value) {
     *     if (typeof value === 'number') {
     *       this._private = value;
     *     }
     *   });
     * object.prop('public', '1').$; // { public: undefined }
     * object.prop('public', 1).$;   // { public: 1, _private: 1 }
     *
     * new Super({}).set({
     *   public(value) {
     *     if (typeof value === 'number') {
     *       this._private = value;
     *     }
     *   }
     * });
     */

  }, {
    key: 'set',
    value: function set(property, setter) {
      if (arguments.length >= 2) {
        property = defineProperty({}, property, setter);
      }

      var object = this.$;

      iterate(isObject(object) && new Super(property).$, function (setter, property) {
        Object.defineProperty(object, property, { set: setter });
      });

      return this;
    }

    /**
     * @method Super#some
     * @public
     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.
     * If returns truthy iteration stops and if falsey it continues.
     * @returns {Boolean} If all the callback calls returned truthy value.
     * @description Returns true if some of the callback calls returned truthy value. Otherwise false.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).some((value) => value > 4); // false
     * new Super({}).some(() => true);                             // false
     */

  }, {
    key: 'some',
    value: function some() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;

      validate$1([callback], ['function'], 'Super#some');

      return iterate(this.$, function (value, key, object) {
        if (callback(value, key, object)) {
          return true;
        }
      }) || false;
    }

    /**
     * @method Super#strictEquals
     * @public
     * @param {*} [object] - Object to compare.
     * @returns {Boolean} If the objects are equal or not.
     * @description Returns true if objects are equal using '===' operator and false if not.
     * NaNs are considered to be strict equal.
     *
     * @example
     * new Super(3).strictEquals('3');   // false
     * new Super(NaN).strictEquals(NaN); // true
     */

  }, {
    key: 'strictEquals',
    value: function strictEquals(object) {
      var o = this.$;

      object = new Super(object).$;

      return o === object || isNaN(o) && isNaN(object);
    }

    /**
     * @method Super#sum
     * @public
     * @param {IterationCallback} [callback = null] - Called on each iteration.
     * @returns {Number} Sum.
     * @description Type of {@link Super#reduce}.
     * If the callback is present it's used for summing. If not the value is used.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).sum();                         // 6
     * new Super({ a: 1, b: 2, c: 3 }).sum((value) => value * value); // 14
     */

  }, {
    key: 'sum',
    value: function sum() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      validate$1([callback], ['function||!'], 'Super#sum');

      return this.reduce(function (sum, value, key, object) {
        return sum + Number(callback ? callback(value, key, object) : value);
      }, 0);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.$;
    }

    /**
     * @member Super#toStringTag
     * @type {String}
     * @public
     * @readonly
     * @description Returns toString tag of the object.
     *
     * @example
     * new Super({}).toStringTag; // 'Object'
     * new Super([]).toStringTag; // 'Array'
     * new Super(1).toStringTag;  // 'Number'
     */

  }, {
    key: 'value',


    /**
     * @method Super#value
     * @public
     * @param {String|Object.<String, *>} property - Either a string of a property or a values object.
     * @param {Object.<String, *>} [value] - If a property parameter is a string this has to be a value to be set.
     * @returns {DWrap} Returns this.
     * @description Method for defining non-enumerable, non-writable, non-configurable values.
     * Synonym for object.define(property, { value: value }).
     *
     * @example
     * new Super({}).value('a', 1).$; // { a: 1 }
     * new Super({}).value({
     *   a: 1
     * }).$;                          // { a: 1 }
     */
    value: function value(property, _value) {
      if (arguments.length >= 2) {
        property = defineProperty({}, property, _value);
      }

      var object = this.$;

      iterate(isObject(object) && new Super(property).$, function (value, property) {
        Object.defineProperty(object, property, { value: value });
      });

      return this;
    }

    /**
     * @method Super#values
     * @public
     * @returns {DWrap} A wrap of the values array.
     * @description Returns D-Wrap of the values array.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).values().$; // [1, 2, 3]
     * new Super(null).values().$;                 // []
     */

  }, {
    key: 'values',
    value: function values() {
      var array = [];

      iterate(this.$, function (value) {
        array.push(value);
      });

      return D$1(array);
    }

    /**
     * @method Super#word
     * @public
     * @param {IterationCallback} callback - Called on each iteration.
     * @returns {String} Concatenated string.
     * @description Type of {@link Super#reduce}.
     * If the callback is present it's used for concatenating. If not the value is used.
     *
     * @example
     * new Super({ a: 1, b: 2, c: 3 }).word();                         // '123'
     * new Super({ a: 1, b: 2, c: 3 }).word((value) => value + value); // '112233'
     */

  }, {
    key: 'word',
    value: function word() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      validate$1([callback], ['function||!'], 'Super#word');

      return this.reduce(function (word, value, key, object) {
        return word + String(callback ? callback(value, key, object) : value);
      }, '');
    }
  }, {
    key: 'count',
    get: function get() {
      var object = this.$;

      if (!isObject(object)) {
        return 0;
      }

      return isArrayLike(object) ? object.length : Object.keys(object).length;
    }
  }, {
    key: 'toStringTag',
    get: function get() {
      return toStringTag(this.$);
    }

    /**
     * @member Super#type
     * @type {String}
     * @public
     * @readonly
     * @description Synonym for
     * ["typeof" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}..
     *
     * @example
     * new Super({}).type;   // 'object'
     * new Super(1).type;    // 'number'
     * new Super('1').type;  // 'string'
     * new Super(true).type; // 'boolean'
     */

  }, {
    key: 'type',
    get: function get() {
      return _typeof(this.$);
    }
  }], [{
    key: 'addStaticProperties',
    value: function addStaticProperties(property, value) {
      if (arguments.length >= 2) {
        property = defineProperty({}, property, value);
      }

      defineProperties(this, property);

      return this;
    }

    /**
     * @method Super.addInstanceProperties
     * @public
     * @param {String|Object} property - Either a string of a property or an object
     * with properties keys and values values.
     * @param {Object} [value] - If a property parameter is a string this has to be a property value.
     * @returns {this} Returns this.
     * @description Sets static properties for DWrap prototypes.
     *
     * @example
     * Super.addInstanceProperties('cool', 42);
     * Super.addInstanceProperties('superCool', 42*42);
     */

  }, {
    key: 'addInstanceProperties',
    value: function addInstanceProperties(property, value) {
      if (arguments.length >= 2) {
        property = defineProperty({}, property, value);
      }

      defineProperties(this.prototype, property);

      return this;
    }
  }]);
  return Super;
}();

defineProperties(Super.prototype, defineProperty({}, _Symbol.toStringTag, 'Super'));

/**
 * @function deepAssign
 * @private
 * @param {*} target - Object to assign properties to.
 * @param {*} object - Object to assign properties from.
 * @returns {void}
 */
function _deepAssign(target, object) {
  iterate(object, function (value, key) {
    if (isPrimitive(target[key]) || !{}.hasOwnProperty.call(target, key)) {
      target[key] = _deepClone(value);

      return;
    }

    if (!isPrimitive(target[key])) {
      _deepAssign(target[key], value);
    }
  });
}

/**
 * @function deepClone
 * @private
 * @param {*} object - Object to clone.
 * @description Does the deep cloning.
 */
function _deepClone(object) {
  var clone = cloneSwitcher(object, [object, true]);

  if (clone !== object) {
    iterate(object, function (value, key) {
      clone[key] = _deepClone(value);
    });
  }

  return clone;
}

/**
 * @function deepEqual
 * @private
 * @param {*} o1 - First object to compare.
 * @param {*} o2 - Second object to compare.
 * @param {Boolean} strict - If comparison should be strict or not.
 * @returns {Boolean} - If the object are deep equal or not.
 */
function deepEqual(o1, o2, strict) {
  if (o1 === o2) {
    return true;
  }

  if (isNaN(o1) && isNaN(o2) && isPrimitive(o1) && isPrimitive(o2)) {
    return true;
  }

  if (isNaN(o1) || isNaN(o2)) {
    return false;
  }

  if (isPrimitive(o1) || isPrimitive(o2)) {
    return strict ? o1 === o2 : o1 == o2;
  }

  if (isDate(o1) && isDate(o2)) {
    return o1.getTime() === o2.getTime();
  }

  if (isDate(o1) || isDate(o2)) {
    return false;
  }

  if (isRegExp(o1) && isRegExp(o2)) {
    return o1.source === o2.source && o1.toString().match(/[gimuy]*$/)[0] === o2.toString().match(/[gimuy]*$/)[0] && o1.lastIndex === o2.lastIndex;
  }

  if (isRegExp(o1) || isRegExp(o2)) {
    return false;
  }

  if (!isPlainObject(o1) && !isArray(o1) || !isPlainObject(o2) && !isArray(o2)) {
    return false;
  }

  var p1 = Object.getPrototypeOf(o1);
  var p2 = Object.getPrototypeOf(o1);

  if (Object.keys(o1).length !== Object.keys(o2).length) {
    return false;
  }

  if (p1 && p2 && toStringTag(p1.constructor) !== toStringTag(p2.constructor)) {
    return false;
  }

  return iterate(o1, function (value, key) {
    if (!(key in o2) || !deepEqual(value, o2[key], strict)) {
      return false;
    }
  }) !== false;
}

/**
 * @function deepEvery
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * If returns truthy the iteration goes on and if not it stops.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {Boolean} - If all the callback calls returned truthy value.
 */
function _deepEvery(object, callback, n, tree) {
  var end = n === 1;

  return iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    if (end || isPrimitive(value) ? !callback(value, key, object, newTree) : !_deepEvery(value, callback, n - 1, newTree)) {
      return false;
    }
  }) !== false;
}

/**
 * @function deepFilter
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * If returns truthy the element is included in the output and if not it's excluded.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {*} Filtered object.
 */
function _deepFilter(object, callback, n, tree) {
  var array = isArrayLike(object);
  var nul = isNil(object);
  var o = array ? [] : nul ? object : {};
  var end = n === 1;

  iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    if ((end || isPrimitive(value)) && callback(value, key, object, newTree)) {
      if (array) {
        o.push(value);
      } else {
        o[key] = value;
      }

      return;
    }

    if (!end) {
      var filtered = _deepFilter(value, callback, n - 1, newTree);

      if (filtered) {
        if (array) {
          o.push(filtered);
        } else {
          o[key] = filtered;
        }
      }
    }
  });

  if (array) {
    return o.length ? o : undefined;
  }

  if (!nul) {
    return Object.keys(o).length ? o : undefined;
  }

  return o;
}

/**
 * @function deepFind
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * If returns truthy the iteration stops and if not it continues.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {Tree|null} - If found the whole tree is returned and if not it's null what's returned.
 */
function _deepFind(object, callback, n, tree) {
  var end = n === 1;

  return iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    if (end || isPrimitive(value)) {
      if (callback(value, key, object, newTree)) {
        return newTree;
      }

      return;
    }

    var result = _deepFind(value, callback, n - 1, newTree);

    if (result) {
      return result;
    }
  }) || null;
}

/**
 * @function deepForEach
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {void}
 */
function _deepForEach(object, callback, n, tree) {
  var end = n === 1;

  iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    if (end || isPrimitive(value)) {
      callback(value, key, object, newTree);
    } else {
      _deepForEach(value, callback, n - 1, newTree);
    }
  });
}

/**
 * @function deepForEachEntry
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {void}
 */
function _deepForEachEntry(object, callback, n, tree) {
  var end = n === 1;

  iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    callback(value, key, object, newTree);

    if (!end && !isPrimitive(value)) {
      _deepForEachEntry(value, callback, n - 1, newTree);
    }
  });
}

/**
 * @function deepFreeze
 * @private
 * @param {*} object - Object to freeze.
 * @returns {void}
 */
function _deepFreeze(object) {
  Object.freeze(object);
  iterate(object, _deepFreeze);
}

/**
 * @function deepMap
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * Returned value is used to create to new object.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {*} New object.
 */
function _deepMap(object, callback, n, tree) {
  var o = isArrayLike(object) ? [] : isNil(object) ? object : {};
  var end = n === 1;

  iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    o[key] = end || isPrimitive(value) ? callback(value, key, object, newTree) : _deepMap(value, callback, n - 1, newTree);
  });

  return o;
}

/**
 * @function deepReduce
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepReduceCallback} callback - Callback that is called on every element.
 * Returned value is used to create to new object.
 * @param {Number} n - Depth of iteration.
 * @param {Boolean} start - If callback was called already or not.
 * @param {{ IV: * }|undefined} IV - If callback was called already or not.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {{ IV: * }} Transformed IV.
 */
function _deepReduce(object, callback, n, start, IV, tree) {
  var end = n === 1;

  iterate(object, function (value, key, object) {
    if (!IV && (end || isPrimitive(value)) && !start) {
      IV = { IV: value };
      start = true;

      return;
    }

    var newTree = [{ key: key, value: value }].concat(tree);

    IV = end || isPrimitive(value) ? { IV: callback(IV.IV, value, key, object, newTree) } : _deepReduce(value, callback, n - 1, start, IV, newTree);
  });

  return IV;
}

/**
 * @function deepSome
 * @private
 * @param {*} object - Object to iterate over.
 * @param {DeepIterationCallback} callback - Callback that is called on every element.
 * If returns truthy the iteration stops and if not it continues.
 * @param {Number} n - Depth of iteration.
 * @param {Tree} tree - Tree of { key, value } objects of iteration.
 * @returns {Boolean} - If some of the callback calls returned truthy value.
 */
function _deepSome(object, callback, n, tree) {
  var end = n === 1;

  return iterate(object, function (value, key, object) {
    var newTree = [{ key: key, value: value }].concat(tree);

    if (end || isPrimitive(value) ? callback(value, key, object, newTree) : _deepSome(value, callback, n - 1, newTree)) {
      return true;
    }
  }) || false;
}

constructors[0].push({
  check: function check() {
    return true;
  },
  cls: Super
});

/**
 * @module Promise
 * @private
 * @mixin
 * @description Exports Promise class.
 */

/**
 * @callback onFulfilledOrRejected
 * @public
 * @param {*} value - Promise value.
 * @param {Boolean} success - If the previous promise is fulfilled it's true and false if rejected.
 */

/**
 * @callback onRejected
 * @public
 * @param {Error|*} err - Promise error.
 */

/**
 * @callback onFulfilled
 * @public
 * @param {*} value - Promise value.
 */

var secret = {};
var iterator = _Symbol.iterator;

/**
 * @class Promise
 * @public
 * @param {Function} executor - Function that takes two arguments: resolve and reject functions.
 * Call the resolve function when you need to fulfill the promise and call the reject one
 * when you need to reject it.
 * @returns {Promise} Instance of Promise.
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
 * @description Class with almost identical API to
 * [ES6 Promise]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.
 * There is a couple differences: set Promise.onError to a function with which you want to
 * subscribe to a promise error and set Promise.onUnhandledRejection to a function with which
 * you want to subscribe to an unhandled error
 * (defaults to console.error.bind(console, '%s %o', 'Uncaught (in promise)')).
 */

var Promise$1 = function () {
  function Promise(executor) {
    classCallCheck(this, Promise);

    if (!isFunction(executor)) {
      throw new TypeError('Promise resolver ' + {}.toString.call(executor) + ' is not a function');
    }

    var hiddenStatus = void 0;
    var hiddenValue = void 0;

    var onFulfill = [];
    var onReject = [];
    var realPromise = this;
    var hiddenPromise = {
      handled: false,
      get status() {
        return hiddenStatus;
      },
      set status(value) {
        hiddenStatus = value;
        realPromise.status = value;
      },
      get value() {
        return hiddenValue;
      },
      set value(val) {
        hiddenValue = val;
        realPromise.value = val;
      }
    };

    hiddenPromise.status = 'pending';
    hiddenPromise.value = undefined;

    /**
     * @typedef {Object} hiddenPromise
     * @private
     * @property {Boolean|Object} handled - If the promise is handled or not.
     * @property {'pending'|'fulfilled'|'rejected'} status - Status of the promise.
     * @property {*} value - Value of the promise.
     */

    /**
     * @member {Function} hiddenPromise#handle
     * @private
     * @param {('reject'|'resolve')} event - Type of the event to handle.
     * @param {Function} handler - Handler itself.
     * @param {Function} resolve - Resolve function.
     * @param {Function} reject - Reject function.
     * @param {Object} secret - Secret.
     * @description Private method for handling promises.
     */

    /**
     * @member {hiddenPromise} Promise#$$
     * @protected
     */
    defineProperties(this.$$ = {}, {
      'get/set handled': {
        get: function get() {
          return hiddenPromise.handled;
        },
        set: function set(key) {
          if (key === secret) {
            hiddenPromise.handled = true;
          }
        }
      },
      handle: function handle(status, f, resolve, reject, key) {
        if (key === secret) {
          var proxy = isFunction(f) ? function (value) {
            try {
              resolve(f(value));
            } catch (err) {
              reject(err);
            }
          } : null;

          if (status === 'resolve') {
            onFulfill.push(proxy || function (value) {
              return resolve(value);
            });
          } else if (status === 'reject') {
            onReject.push(proxy || function (err) {
              return reject(err);
            });
          }
        }
      },
      'get status': function getStatus() {
        return hiddenPromise.status;
      },
      'get value': function getValue() {
        return hiddenPromise.value;
      }
    });

    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }

    function reject(err) {
      if (hiddenPromise.status === 'pending') {
        (function () {
          hiddenPromise.status = 'rejected';
          hiddenPromise.value = err;

          for (var i = 0, length = onReject.length; i < length; i++) {
            hiddenPromise.handled = true;

            onReject[i](err);
          }

          var onUnhandledRejection = Promise.onUnhandledRejection,
              onError = Promise.onError;


          if (isFunction(onError)) {
            onError(err);
          }

          setTimeout(function () {
            if (!hiddenPromise.handled && isFunction(onUnhandledRejection)) {
              onUnhandledRejection(err);
            }
          }, 1);
        })();
      }
    }

    function resolve(value) {
      if (hiddenPromise.status === 'pending') {
        if (value && isFunction(value.then)) {
          return value.then(function (value) {
            resolve(value);
          }, function (err) {
            reject(err);
          });
        }

        hiddenPromise.status = 'fulfilled';
        hiddenPromise.value = value;

        for (var i = 0, length = onFulfill.length; i < length; i++) {
          hiddenPromise.handled = true;

          onFulfill[i](value);
        }
      }
    }
  }

  /**
   * @method Promise.all
   * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises
   * or any values.
   * @returns {Promise} New instance of Promise.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
   */


  createClass(Promise, [{
    key: 'abort',
    value: function abort() {}

    /**
     * @method Promise#catch
     * @param {onRejected} onRejected - onRejected callback.
     * @returns {Promise} New instance of Promise.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
     */

  }, {
    key: 'catch',
    value: function _catch(onRejected) {
      return this.then(null, onRejected);
    }

    /**
     * @method Promise#finally
     * @public
     * @param {onFulfilledOrRejected} onFulfilledOrRejected - onFulfilledOrRejected callback.
     * @returns {Promise}
     * @description Method for catching both fulfilled and rejected promises.
     *
     * @example
     * spinner.show();
     * fetchData()
     *   .then((data) => {
     *     // do something with data
     *   })
     *   .catch((err) => {
     *     // handle error somehow
     *   })
     *   .finally(() => {
     *     spinner.hide();
     *   });
     */

  }, {
    key: 'finally',
    value: function _finally(onFulfilledOrRejected) {
      var isFunc = isFunction(onFulfilledOrRejected);

      return this.then(function (value) {
        return Promise.resolve(isFunc ? onFulfilledOrRejected(value, true) : 0).then(function () {
          return value;
        });
      }, function (err) {
        return Promise.resolve(isFunc ? onFulfilledOrRejected(err, false) : 0).then(function () {
          return Promise.reject(err);
        });
      });
    }

    /**
     * @method Promise#then
     * @param {onFulfilled} [onFulfilled] - onFulfilled callback.
     * @param {onRejected} [onRejected] - onRejected callback.
     * @returns {Promise} New instance of Promise.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
     */

  }, {
    key: 'then',
    value: function then(onFulfilled, onRejected) {
      var promise = this.$$;

      if (promise.status === 'pending') {
        return new Promise(function (resolve, reject) {
          promise.handle('reject', onRejected, resolve, reject, secret);
          promise.handle('resolve', onFulfilled, resolve, reject, secret);
        });
      }

      promise.handled = secret;

      var value = promise.value;


      var method = void 0;
      var handler = void 0;

      if (promise.status === 'fulfilled') {
        method = 'resolve';
        handler = onFulfilled;
      } else {
        method = 'reject';
        handler = onRejected;
      }

      if (!isFunction(handler)) {
        return Promise[method](value);
      }

      try {
        return Promise.resolve(handler(value));
      } catch (err) {
        return Promise.reject(err);
      }
    }
  }], [{
    key: 'all',
    value: function all(iterable) {
      var array = [];

      var toResolve = 0;

      if (iterable[iterator]) {
        iterable = iterable[iterator]();

        return new Promise(function (resolve, reject) {
          var next = void 0;
          var i = 0;

          var _loop = function _loop() {
            var promise = Promise.resolve(next.value);

            toResolve++;

            (function (i) {
              promise.then(function (value) {
                toResolve--;
                array[i] = value;

                setTimeout(function () {
                  if (next.done && !toResolve) {
                    resolve(array);
                  }
                }, 1);
              }, reject);
            })(i++);
          };

          while (!(next = iterable.next()).done) {
            _loop();
          }

          if (!i) {
            return Promise.resolve([]);
          }
        });
      }

      var length = iterable.length;

      if (!length) {
        return Promise.resolve([]);
      }

      toResolve = length;

      return new Promise(function (resolve, reject) {
        var _loop2 = function _loop2(i) {
          var promise = Promise.resolve(iterable[i]);

          promise.then(function (value) {
            toResolve--;
            array[i] = value;

            if (!toResolve) {
              resolve(array);
            }
          }, reject);
        };

        for (var i = 0; i < length; i++) {
          _loop2(i);
        }
      });
    }

    /**
     * @method Promise.race
     * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises
     * or any values.
     * @returns {Promise} New instance of Promise.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
     */

  }, {
    key: 'race',
    value: function race(iterable) {
      if (iterable[iterator]) {
        iterable = iterable[iterator]();

        return new Promise(function (resolve, reject) {
          var next = void 0;

          while (!(next = iterable.next()).done) {
            next.value.then(resolve, reject);
          }
        });
      }

      return new Promise(function (resolve, reject) {
        for (var i = 0, length = iterable.length; i < length; i++) {
          iterable[i].then(resolve, reject);
        }
      });
    }

    /**
     * @method Promise.reject
     * @param {*} value - Value to reject.
     * @returns {Promise} New instance of Promise.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject
     */

  }, {
    key: 'reject',
    value: function reject(value) {
      return new Promise(function (resolve, reject) {
        reject(value);
      });
    }

    /**
     * @method Promise.resolve
     * @param {Promise|Thenable|*} value - Promise, thenable or any value to resolve.
     * @returns {Promise} New instance of Promise.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve
     */

  }, {
    key: 'resolve',
    value: function resolve(value) {
      if (value && isFunction(value.then)) {
        return value;
      }

      return new Promise(function (resolve) {
        resolve(value);
      });
    }
  }]);
  return Promise;
}();

Promise$1.onError = null;
Promise$1.onUnhandledRejection = console.error.bind(console, '%s %o', 'Uncaught (in promise)');


defineProperties(Promise$1.prototype, defineProperty({}, _Symbol.toStringTag, 'Promise'));

/**
 * @module Func
 * @private
 * @mixin
 * @description Exports Func class.
 */

/**
 * @callback BeforeMiddleware
 * @param {Array} args - Previous arguments.
 * @param {Func} func - This function.
 * @returns {Array} - New arguments.
 */

/**
 * @callback AfterMiddleware
 * @param {*} returnValue - Previous return value.
 * @param {Func} func - This function.
 * @returns {*} - New return value.
 */

/**
 * @class Func
 * @extends Super
 * @public
 * @param {Function} [func = function () {}] - Function to wrap.
 * @returns {Func} Instance of Func.
 * @description A wrap of a function.
 *
 * @example
 * const func = new Func(Math.max);
 *
 * func(1, 4, -2, 5); // 5
 */

var Func = function (_Super) {
  inherits(Func, _Super);

  function Func() {
    var _ret;

    var func = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
    classCallCheck(this, Func);

    var _this = possibleConstructorReturn(this, (Func.__proto__ || Object.getPrototypeOf(Func)).call(this));

    function proxy() {
      var _this2 = this,
          _arguments = arguments;

      if (++proxy.$$.called < proxy.$$.canBeCalled) {
        var _ret2 = function () {
          var _proxy$$$ = proxy.$$,
              before = _proxy$$$.before,
              after = _proxy$$$.after,
              sync = _proxy$$$.sync,
              contextLocked = _proxy$$$.contextLocked;
          var _proxy$$$2 = proxy.$$,
              context = _proxy$$$2.context,
              args = _proxy$$$2.args;

          var ret = void 0;

          context = contextLocked ? context : context || _this2;
          args = args.concat(toArray$1(_arguments));

          if (sync) {
            iterate(before, function (middleware) {
              args = middleware.call(context, toArray$1(args), proxy);
            });

            ret = func.apply(context, toArray$1(args));

            iterate(after, function (middleware) {
              ret = middleware.call(context, ret, proxy);
            });

            return {
              v: ret
            };
          }

          var promise = Promise$1.resolve(args);

          iterate(before, function (middleware) {
            promise = promise.then(function (args) {
              return middleware.call(context, toArray$1(args), proxy);
            });
          });

          promise = promise.then(function (args) {
            return func.apply(context, toArray$1(args));
          });

          iterate(after, function (middleware) {
            promise = promise.then(function (ret) {
              return middleware.call(context, ret, proxy);
            });
          });

          return {
            v: promise
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }
    }

    /**
     * @member {Object} Func#$$
     * @type {Object}
     * @protected
     * @property {Array} after - After middleware array.
     * @property {Array} args - Locked and bound arguments.
     * @property {Array} argsLocked - Locked arguments.
     * @property {Array} before - Before middleware array.
     * @property {Number} called - How many times the function was called.
     * @property {Number} canBeCalled - How many times the function can be actually called.
     * @property {*} context - Locked or bound context.
     * @property {Boolean} contextLocked - Is context locked or not.
     * @property {Boolean} sync - Is function synchronous or not.
     * @description Config parameters.
     */
    Object.defineProperty(proxy, '$$', {
      value: {
        after: [],
        args: [],
        argsLocked: [],
        before: [],
        called: 0,
        canBeCalled: Infinity,
        context: null,
        contextLocked: false,
        sync: true
      }
    });

    /**
     * @member {Function} Func#$
     * @type {Function}
     * @public
     * @description Original function.
     */
    Object.defineProperty(proxy, '$', { value: func });
    Object.setPrototypeOf(proxy, Func.prototype);

    return _ret = proxy, possibleConstructorReturn(_this, _ret);
  }

  /**
   * @method Func#after
   * @public
   * @param {AfterMiddleware} middleware - After middleware.
   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put middleware.
   * Truthy parameter stands for "to the end" and falsey for "to the beginning".
   * @returns {Func} Returns this.
   * @description Adds after middleware.
   *
   * @example
   * const func = new Func((a) => a + 1)
   *   .after((result) => result * result);
   *
   * func(4);  // 25
   * func(-4); // 9
   */


  createClass(Func, [{
    key: 'after',
    value: function after(middleware) {
      var afterAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      validate$1([middleware], ['function'], 'Func#after');

      var after = this.$$.after;


      if (afterAll) {
        after.push(middleware);
      } else {
        after.unshift(middleware);
      }

      return this;
    }

    /**
     * @method Func#apply
     * @public
     * @param {*} [context] - Context to call with.
     * @param {(Array|Arguments)} [args] - Arguments to call with.
     * @returns {*} Return of function call.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
     * @description Synonym for
     * [Function#apply]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply}.
     */

  }, {
    key: 'apply',
    value: function apply(context, args) {
      return function () {}.apply.apply(this, arguments);
    }

    /**
     * @method Func#async
     * @public
     * @param {Boolean|*} [condition] - If the function should be synchronous or not.
     * @returns {Func} Returns this.
     * @description If the function should be synchronous or not.
     *
     * @example
     * const func = new Func((a) => a + 1).async();
     *
     * func(4).then((result) => {
     *   console.log(result); // 5
     * });
     */

  }, {
    key: 'async',
    value: function async() {
      var condition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.$$.sync = !condition;

      return this;
    }

    /**
     * @method Func#before
     * @public
     * @param {BeforeMiddleware} middleware - Before middleware.
     * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put middleware.
     * Truthy parameter stands for "to the beginning" and falsey for "to the end".
     * @returns {Func} Returns this.
     * @description Adds before middleware.
     *
     * @example
     * const func = new Func((a) => a + 1)
     *   .before(([arg]) => [arg * arg]);
     *
     * func(4); // 17
     * func(3); // 10
     */

  }, {
    key: 'before',
    value: function before(middleware) {
      var beforeAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      validate$1([middleware], ['function'], 'Func#before');

      var before = this.$$.before;


      if (beforeAll) {
        before.unshift(middleware);
      } else {
        before.push(middleware);
      }

      return this;
    }

    /**
     * @method Func#bind
     * @public
     * @param {*} context - Context to bind.
     * @param {...(Array|Arguments|*)} args - Arguments to bind.
     * @returns {Func} Returns this.
     * @description Composition of {@link Func#bindContext} and {@link Func#bindArgs}.
     *
     * @example
     * const func = new Func(function (a, b) {
     *   return this.a + a + b;
     * }).bind({ a: 2 }, 1);
     *
     * func(1); // 4
     * func(3); // 6
     */

  }, {
    key: 'bind',
    value: function bind(context) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this.bindContext(context).bindArgs(args);
    }

    /**
     * @method Func#bindArgs
     * @public
     * @param {(Array|Arguments)} args - Arguments to bind.
     * @returns {Func} Returns this.
     * @description Binds arguments in addition to already locked and bound ones.
     *
     * @example
     * const func = new Func((...args) => {
     *   let sum = 0;
     *
     *   for (let i = 0; i < args.length; i++) {
     *     sum += args[i];
     *   }
     *
     *   return sum;
     * });
     *
     * func(1, 2, 3); // 6
     *
     * func.bindArgs([4]);
     *
     * func(1, 2, 3); // 10
     *
     * func.bindArgs([5]);
     *
     * func(1, 2, 3); // 15
     */

  }, {
    key: 'bindArgs',
    value: function bindArgs(args) {
      var func = this.$$;

      func.args = func.args.concat(toArray$1(args));

      return this;
    }

    /**
     * @method Func#bindContext
     * @public
     * @param {*} context - Context to bind.
     * @returns {Func} Returns this.
     * @description Bind new context if it's not already locked.
     *
     * @example
     * const func = new Func(function () {
     *   return this.a;
     * }).bindContext({ a: 1 });
     *
     * func(); // 1
     *
     * func.bindContext({ a: 2 });
     *
     * func(); // 2
     */

  }, {
    key: 'bindContext',
    value: function bindContext(context) {
      var func = this.$$;

      if (!func.contextLocked) {
        func.context = context;
      }

      return this;
    }

    /**
     * @method Func#call
     * @public
     * @param {*} [context] - Context to call with.
     * @param {...*} [args] - Arguments to call with.
     * @returns {*} Return of function call.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call
     * @description Synonym for
     * [Function#call]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call}.
     */

  }, {
    key: 'call',
    value: function call(context) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return function () {}.call.apply(this, arguments);
    }

    /**
     * @member {Number} Func#called
     * @public
     * @readonly
     * @description Returns how many times the function was called.
     *
     * @example
     * const func = new Func((a) => a + 1);
     *
     * func();
     * func();
     *
     * func.called // 2
     */

  }, {
    key: 'canBeCalled',


    /**
     * @method Func#canBeCalled
     * @public
     * @param {Number} times - Number of maximum times the function is called (middlewares are also taken for a count).
     * @returns {Func} Returns this.
     * @description Method for limiting call times of function.
     *
     * @example
     * const func = new Func((a) => a + 1)
     *   .canBeCalled(1);
     *
     * func(1); // 2
     * func(1); // undefined
     */
    value: function canBeCalled(times) {
      this.$$.canBeCalled = times;

      return this;
    }

    /**
     * @method Func#limitArgsTo
     * @public
     * @param {Number} number - Number of arguments to limit to.
     * @returns {Func} Returns this.
     * @description Built-in before middleware for limiting number of arguments
     * that is put to the end of before middlewares.
     *
     * @example
     * const func = new Func((a, b) => [a, b]);
     *
     * func(1, 2); // [1, 2]
     *
     * func.limitArgsTo(1);
     *
     * func(1, 2); // [1, undefined]
     */

  }, {
    key: 'limitArgsTo',
    value: function limitArgsTo(number) {
      return this.before(function (args) {
        return args.slice(0, number);
      }, false);
    }

    /**
     * @method Func#lock
     * @public
     * @param {*} context - Context to lock.
     * @param {(Array|Arguments|*)} args - Arguments to lock.
     * @returns {Func} Returns this.
     * @description Composition of {@link Func#lockContext} and {@link Func#lockArgs}.
     *
     * @example
     * const func = new Func(function (a, b) {
     *   return this.a + a + b;
     * }).lock({ a: 2 }, [1]);
     *
     * func(1); // 4
     * func(3); // 6
     */

  }, {
    key: 'lock',
    value: function lock(context, args) {
      return this.lockContext(context).lockArgs(args);
    }

    /**
     * @method Func#lockArgs
     * @public
     * @param {(Array|Arguments|*)} args - Arguments to lock.
     * @returns {Func} Returns this.
     * @description Erases bound arguments and adds new arguments to already locked ones.
     *
     * @example
     * const func = new Func((...args) => {
     *   let sum = 0;
     *
     *   for (let i = 0; i < args.length; i++) {
     *     sum += args[i];
     *   }
     *
     *   return sum;
     * });
     *
     * func(1, 2, 3); // 6
     *
     * func.lockArgs([4]);
     *
     * func(1, 2, 3); // 10
     *
     * func.bindArgs([6, 7]);
     * func.lockArgs([5]);
     *
     * func(1, 2, 3); // 15
     */

  }, {
    key: 'lockArgs',
    value: function lockArgs(args) {
      var func = this.$$;

      func.args = func.argsLocked = func.argsLocked.concat(toArray$1(args));

      return this;
    }

    /**
     * @method Func#lockContext
     * @public
     * @param {*} context - Context to lock.
     * @returns {Func} Returns this.
     * @description Locks context if it's not already locked.
     *
     * @example
     * const func = new Func(function () {
     *   return this.a;
     * }).lockContext({ a: 1 });
     *
     * func(); // 1
     *
     * func.lockContext({ a: 2 });
     *
     * func(); // 1
     */

  }, {
    key: 'lockContext',
    value: function lockContext(context) {
      var func = this.$$;

      if (!func.contextLocked) {
        func.context = context;
        func.contextLocked = true;
      }

      return this;
    }

    /**
     * @method Func#timing
     * @public
     * @param {String} mark - Argument that is passed to console.time() and console.timeEnd().
     * By default name of the original function, or if it's not present, 'anonymous' is used.
     * @returns {Func} Returns this.
     * @description Built-in before and after middlewares for noting calling time.
     * In case of asynchronous functions it notes time between calling function and resolving or rejecting the result.
     *
     * @example
     * const func = new Func((a) => a + 1)
     *   .timing('plus 1');
     *
     * func(2); // plus 1: 0.010ms
     *
     * const async = new Func(() => new Promise(() => {
     *     setTimeout(resolve, 1000);
     *   }))
     *   .async()
     *   .timing();
     *
     * async();
     * // After 1 second...
     * // anonymous: 1000.010ms
     */

  }, {
    key: 'timing',
    value: function timing(mark) {
      mark = arguments.length ? String(mark) : this.$.name || 'anonymous';

      this.before(function (args) {
        console.time(mark);

        return args;
      }, false);

      this.after(function (ret) {
        console.timeEnd(mark);

        return ret;
      }, false);

      return this;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return function () {}.toString.call(this.$);
    }

    /**
     * @method Func#unbind
     * @public
     * @returns {Func} Returns this.
     * @description Composition of {@link Func#unbindContext} and {@link Func#unbindArgs}.
     *
     * @example
     * const func = new Func(function (a) {
     *   return this.foo + ' & ' +  a;
     * }).bind({ foo: 2 }, 1);
     *
     * func(); // '2 & 1'
     *
     * func.unbind();
     *
     * func(); // 'undefined & undefined'
     */

  }, {
    key: 'unbind',
    value: function unbind() {
      return this.unbindContext().unbindArgs();
    }

    /**
     * @method Func#unbindArgs
     * @public
     * @returns {Func} Returns this.
     * @description Erases all bound arguments.
     *
     * @example
     * const func = new Func((...args) => {
     *   let sum = 0;
     *
     *   for (let i = 0; i < args.length; i++) {
     *     sum += args[i];
     *   }
     *
     *   return sum;
     * }).bindArgs([4, 5]);
     *
     * func(1, 2, 3); // 15
     *
     * func.unbindArgs();
     *
     * func(1, 2, 3); // 6
     */

  }, {
    key: 'unbindArgs',
    value: function unbindArgs() {
      var func = this.$$;

      func.args = func.argsLocked;

      return this;
    }

    /**
     * @method Func#unbindContext
     * @public
     * @returns {Func} Returns this.
     * @description Erases context if it's not locked.
     *
     * @example
     * const func = new Func(function () {
     *   return this.foo;
     * }).bindContext({ foo: 1 });
     *
     * func(); // 1
     *
     * func.unbindArgs();
     *
     * func(); // undefined
     */

  }, {
    key: 'unbindContext',
    value: function unbindContext() {
      var func = this.$$;

      if (!func.contextLocked) {
        func.context = null;
      }

      return this;
    }
  }, {
    key: 'called',
    get: function get() {
      return this.$$.called;
    }
  }]);
  return Func;
}(Super);

defineProperties(Func.prototype, defineProperty({}, _Symbol.toStringTag, 'Func'));

constructors[1].push({
  check: isFunction,
  cls: Func
});

/**
 * @function method
 * @public
 * @param {String} method - Method to call.
 * @param {(Array|Arguments|*)} args - Arguments to call the method with.
 * @returns {Function} Function that calls stated method with given arguments.
 * @description Function that returns the function
 * that calls stated method of its first argument with given arguments.
 *
 * @example
 * [1.2345, 2.789, 3.14].map(method('toFixed', [2])); // ['1.23', '2.79', '3.14']
 */
function method(method) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  return function (x) {
    return x[method].apply(x, toArray$1(args));
  };
}

/**
 * @function noop
 * @public
 * @returns {void}
 * @description Empty function.
 */
function noop() {}

/**
 * @function prop
 * @public
 * @param {String} prop - Property to return.
 * @returns {Function} Function that returns given property of its first argument.
 * @description Function that return the function that returns given property of its first argument.
 *
 * @example
 * ['foo', '12', '7890'].map(prop('length')); // [3, 2, 4]
 */
function prop$1(prop) {
  return function (_ref) {
    var value = _ref[prop];
    return value;
  };
}

/**
 * @function self
 * @public
 * @returns {*} First argument itself.
 * @description Function that returns the first argument.
 *
 * @example
 * [1, 2].map(self);                     // [1, 2]
 * [1, 3, NaN, 0, 7, null].filter(self); // [1, 3, 7]
 */
function self$1() {
  return arguments[0];
}

/**
 * @module Num
 * @private
 * @mixin
 * @description Exports Num class.
 */

var toRadian = Math.PI / 180;
var toDegree = 180 / Math.PI;
var ln2 = Math.LN2;
var ln10 = Math.LN10;

/**
 * @class Num
 * @extends Super
 * @public
 * @param {Number} [number = 0] - A number to wrap.
 * @returns {Num} Instance of Num.
 * @description Wrap of a number.
 *
 * @example
 * const num = new Num(1);
 */

var Num = function (_Super) {
  inherits(Num, _Super);

  function Num() {
    var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    classCallCheck(this, Num);
    return possibleConstructorReturn(this, (Num.__proto__ || Object.getPrototypeOf(Num)).call(this, +number));

    /**
     * @member Num#$
     * @type {Number}
     * @public
     * @description Original number.
     */
  }

  /**
   * @member Num#abs
   * @type {Number}
   * @public
   * @readonly
   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs
   * @description Synonym for
   * [Math.abs]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs}.
   *
   * @example
   * new Num(1).abs;  // 1
   * new Num(-1).abs; // 1
   */


  createClass(Num, [{
    key: 'acos',


    /**
     * @method Num#acos
     * @public
     * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.
     * @returns {Number} Arccosine of the number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos
     * @description Synonym for
     * [Math.acos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos}.
     */
    value: function acos(toDegrees) {
      return (toDegrees ? toDegree : 1) * Math.acos(this.$);
    }

    /**
     * @member Num#acosh
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh
     * @description Synonym for
     * [Math.acosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh}.
     */

  }, {
    key: 'asin',


    /**
     * @method Num#asin
     * @public
     * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.
     * @returns {Number} Arcsine of the number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin
     * @description Synonym for
     * [Math.asin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin}.
     */
    value: function asin(toDegrees) {
      return (toDegrees ? toDegree : 1) * Math.asin(this.$);
    }

    /**
     * @method Num#atan
     * @public
     * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.
     * @returns {Number} Arcsine of the number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan
     * @description Synonym for
     * [Math.atan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan}.
     */

  }, {
    key: 'atan',
    value: function atan(toDegrees) {
      return (toDegrees ? toDegree : 1) * Math.atan(this.$);
    }

    /**
     * @member Num#atanh
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh
     * @description Synonym for
     * [Math.atanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh}.
     */

  }, {
    key: 'cos',


    /**
     * @method Num#cos
     * @public
     * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.
     * @returns {Number} Cosine of the number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos
     * @description Synonym for
     * [Math.cos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos}.
     */
    value: function cos(asDegrees) {
      return Math.cos((asDegrees ? toRadian : 1) * this.$);
    }

    /**
     * @member Num#cosh
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh
     * @description Synonym for
     * [Math.cosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh}.
     */

  }, {
    key: 'interval',


    /**
     * @method Num#interval
     * @public
     * @param {Function} func - Function that is called every <number> milliseconds.
     * @param {Array} [args] - Arguments passed to the function.
     * @returns {Function} Function that aborts the interval. The context of the function (if it's not already bound)
     * is the object with the abort method.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/setInterval
     * @description Analogue of the
     * [setInterval]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setInterval}.
     *
     * @example
     * const times = 0;
     * new Num(50).interval(function () {
     *   if (++times === 10) {
     *     this.abort();
     *   }
     * });
     */
    value: function interval(func) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      validate$1([func], ['function'], 'Num#interval');

      func = new Func(func).bindContext({ abort: abort });
      args = toArray$1(args);

      var number = this.$;

      var aborted = void 0;
      var timeout = setTimeout(function interval() {
        if (!aborted) {
          func.apply(null, args);

          if (!aborted) {
            timeout = setTimeout(interval, number);
          }
        }
      }, 0);

      return abort;

      function abort() {
        aborted = true;

        return clearTimeout(timeout);
      }
    }

    /**
     * @member Num#ln
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log
     * @description Synonym for
     * [Math.log]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log}.
     */

  }, {
    key: 'log',


    /**
     * @method Num#log
     * @public
     * @param {Number} number - Number to get logarithm of.
     * @returns {Number} Logarithm of the argument number to the number base.
     * @description Returns the logarithm of the argument number to the number base.
     *
     * @example
     * new Num(2).log(16);  // 4
     * new Num(3).log(243); // 5
     */
    value: function log(number) {
      return Math.log(number) / Math.log(this.$);
    }

    /**
     * @member Num#log2
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2
     * @description Synonym for
     * [Math.log2]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2}.
     */

  }, {
    key: 'pow',


    /**
     * @method Num#pow
     * @public
     * @param {Number} power - Power the number should be raised to.
     * @returns {Number} The number to the <power> power.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow
     * @description Synonym for
     * [Math.pow]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow}.
     *
     * @example
     * new Num(4).pow(.5); // 2
     * new Num(3).pow(2);  // 9
     */
    value: function pow(power) {
      return Math.pow(this.$, power);
    }

    /**
     * @method Num#root
     * @public
     * @param {Number} power - Power the number should be raised to.
     * @returns {Number} The <power> root of the number.
     * @description Synonym for number.pow(1 / power);
     *
     * @example
     * new Num(4).root(2);   // 0.5
     * new Num(243).root(5); // 3
     */

  }, {
    key: 'root',
    value: function root(power) {
      return Math.pow(this.$, 1 / power);
    }

    /**
     * @member Num#round
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round
     * @description Synonym for
     * [Math.round]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round}.
     *
     * @example
     * new Num(1.1).floor;  // 1
     * new Num(-1.1).floor; // -1
     * new Num(1.5).floor;  // 2
     */

  }, {
    key: 'sin',


    /**
     * @method Num#sin
     * @public
     * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.
     * @returns {Number} Sine of the number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin
     * @description Synonym for
     * [Math.sin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin}.
     */
    value: function sin(asDegrees) {
      return Math.sin((asDegrees ? toRadian : 1) * this.$);
    }

    /**
     * @member Num#sinh
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh
     * @description Synonym for
     * [Math.sinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh}.
     */

  }, {
    key: 'tan',


    /**
     * @method Num#tan
     * @public
     * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.
     * @returns {Number} Tangent of the number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan
     * @description Synonym for
     * [Math.tan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan}.
     */
    value: function tan(asDegrees) {
      return Math.tan((asDegrees ? toRadian : 1) * this.$);
    }

    /**
     * @member Num#tanh
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh
     * @description Synonym for
     * [Math.tanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh}.
     */

  }, {
    key: 'timeout',


    /**
     * @method Num#timeout
     * @public
     * @param {*} [value] - Value to be resolved by the promise.
     * @returns {Promise} Promise that could be aborted.
     * @see https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout
     * @description Promise-based analogue of
     * [setTimeout]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout}.
     *
     * @example
     * new Num(50).timeout('resolved').then((value) => {
     *   console.log(value); // 'resolved'
     * });
     *
     * const promise = new Num(50).timeout();
     * promise.abort();
     */
    value: function timeout(value) {
      var _this2 = this;

      var timeout = void 0;
      var reject = void 0;

      var promise = new Promise$1(function (resolve, rej) {
        reject = rej;
        timeout = setTimeout(resolve, _this2.$, value);
      });

      promise.abort = function abort() {
        clearTimeout(timeout);

        reject(new Error('Timeout was aborted'));

        return this;
      };

      return promise;
    }

    /**
     * @method Num#toBase
     * @public
     * @param {Number} [base = 10] - Base that the number should inverted to.
     * @returns {String} A string representation of the number in <base> base.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString
     * @description Synonym for
     * [Number#toString]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString}.
     *
     * @example
     * new Num(4).toBase(2); // 100
     * new Num(3).toBase();  // 3
     */

  }, {
    key: 'toBase',
    value: function toBase() {
      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      return this.$.toString(base);
    }

    /**
     * @method Num#toExponential
     * @public
     * @param {Number} [fractionDigits] - See the link.
     * @returns {String} A string representation of the number in the exponential format.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential
     * @description Synonym for
     * [Number#toExponential]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential}.
     */

  }, {
    key: 'toExponential',
    value: function toExponential(fractionDigits) {
      return this.$.toExponential(fractionDigits);
    }

    /**
     * @method Num#toFixed
     * @public
     * @param {Number} [digits = 0] - See the link.
     * @returns {String} Fixed-point formatted number.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed
     * @description Synonym for
     * [Number#toFixed]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed}.
     */

  }, {
    key: 'toFixed',
    value: function toFixed(digits) {
      return this.$.toFixed(digits);
    }

    /**
     * @method Num#toPrecision
     * @public
     * @param {Number} [precision] - See the link.
     * @returns {String} A string representation of the number to the specified precision.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision
     * @description Synonym for
     * [Number#toPrecision]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision}.
     */

  }, {
    key: 'toPrecision',
    value: function toPrecision(precision) {
      return this.$.toPrecision(precision);
    }
  }, {
    key: 'valueOf',
    value: function valueOf() {
      return Number(this.$);
    }
  }, {
    key: 'abs',
    get: function get() {
      return Math.abs(this.$);
    }
  }, {
    key: 'acosh',
    get: function get() {
      var number = this.$;

      return Math.log(number + Math.sqrt(number * number - 1));
    }

    /**
     * @member Num#asinh
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh
     * @description Synonym for
     * [Math.asinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh}.
     */

  }, {
    key: 'asinh',
    get: function get() {
      var number = this.$;

      return Math.log(number + Math.sqrt(number * number + 1));
    }
  }, {
    key: 'atanh',
    get: function get() {
      var number = this.$;

      return Math.log((1 + number) / (1 - number)) / 2;
    }

    /**
     * @member Num#cbrt
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt
     * @description Synonym for
     * [Math.cbrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt}.
     */

  }, {
    key: 'cbrt',
    get: function get() {
      var cbrt = Math.pow(Math.abs(this.$), 1 / 3);

      return this.$ > 0 ? cbrt : -cbrt;
    }

    /**
     * @member Num#ceil
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil
     * @description Synonym for
     * [Math.ceil]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil}.
     *
     * @example
     * new Num(1.1).ceil;  // 2
     * new Num(-1.1).ceil; // -1
     */

  }, {
    key: 'ceil',
    get: function get() {
      return Math.ceil(this.$);
    }
  }, {
    key: 'cosh',
    get: function get() {
      var exp = this.exp;

      return (exp + 1 / exp) / 2;
    }

    /**
     * @member Num#cube
     * @type {Number}
     * @public
     * @readonly
     * @description Cube of the number.
     *
     * @example
     * new Num(2).cube;  // 8
     * new Num(-3).ceil; // -27
     */

  }, {
    key: 'cube',
    get: function get() {
      return this.$ * this.$ * this.$;
    }

    /**
     * @member Num#exp
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp
     * @description Synonym for
     * [Math.exp]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp}.
     */

  }, {
    key: 'exp',
    get: function get() {
      return Math.exp(this.$);
    }

    /**
     * @member Num#floor
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor
     * @description Synonym for
     * [Math.floor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor}.
     *
     * @example
     * new Num(1.1).floor;  // 1
     * new Num(-1.1).floor; // -2
     */

  }, {
    key: 'floor',
    get: function get() {
      return Math.floor(this.$);
    }
  }, {
    key: 'ln',
    get: function get() {
      return Math.log(this.$);
    }
  }, {
    key: 'log2',
    get: function get() {
      return this.ln / ln2;
    }

    /**
     * @member Num#log10
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10
     * @description Synonym for
     * [Math.log10]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10}.
     */

  }, {
    key: 'log10',
    get: function get() {
      return this.ln / ln10;
    }
  }, {
    key: 'round',
    get: function get() {
      return Math.round(this.$);
    }

    /**
     * @member Num#sign
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
     * @description Synonym for
     * [Math.sign]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign}.
     */

  }, {
    key: 'sign',
    get: function get() {
      var number = this.$;

      if (!number) {
        return number;
      }

      return number > 0 ? 1 : -1;
    }
  }, {
    key: 'sinh',
    get: function get() {
      var exp = this.exp;

      return (exp - 1 / exp) / 2;
    }

    /**
     * @member Num#sq
     * @type {Number}
     * @public
     * @readonly
     * @description The square of the number.
     *
     * @example
     * new Num(2).sq;  // 4
     * new Num(-3).sq; // 9
     */

  }, {
    key: 'sq',
    get: function get() {
      return this.$ * this.$;
    }

    /**
     * @member Num#sqrt
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt
     * @description Synonym for
     * [Math.sqrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt}.
     */

  }, {
    key: 'sqrt',
    get: function get() {
      return Math.sqrt(this.$);
    }
  }, {
    key: 'tanh',
    get: function get() {
      var number = this.$;

      if (!isFinite(number)) {
        return this.sign;
      }

      var exp = Math.exp(2 * number);

      return (exp - 1) / (exp + 1);
    }
  }]);
  return Num;
}(Super);

defineProperties(Num.prototype, defineProperty({}, _Symbol.toStringTag, 'Num'));

constructors[1].push({
  check: isNumber,
  cls: Num
});

/**
 * @function rand
 * @public
 * @param {Number} [start = 0] - Start of the range.
 * @param {Number} [end = 1] - End of the range.
 * @returns {Number} Random number.
 * @description Returns a random number in the range specified by the arguments.
 *
 * @example
 * rand(1, 5); // 2.315
 * rand(1, 5); // 4.356763
 */
function rand() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return start + (end - start) * Math.random();
}

/**
 * @function random
 * @public
 * @param {Integer} start - Start of the range.
 * @param {Integer} end - End of the range.
 * @returns {Number} Random integer.
 * @description Returns a random integer number in the range specified by the arguments.
 *
 * @example
 * random(1, 5); // 3
 * random(1, 5); // 1
 */
function random$1(start, end) {
  validate$1([start, end], ['intLike', 'intLike'], 'random');

  if (end <= start) {
    throw new Error('The second argument must be greater than the first!', 'random');
  }

  return Math.floor(rand(start, end + 1));
}

/**
 * @module Arr
 * @private
 * @mixin
 * @description Exports Arr class.
 */

/**
 * @typedef {Array|*} ArrayLike
 * @public
 * @description Array-like type.
 */

/**
 * @callback ArrayCallback
 * @public
 * @param {Number} i - Iteration index.
 */

/**
 * @callback IterateCallback
 * @public
 * @param {Number} i - Iteration index.
 */

/**
 * @callback CompareFunction
 * @public
 * @param {*} x - First value to be compared.
 * @param {*} y - Second value to be compared.
 */

/**
 * @class Arr
 * @extends Super
 * @public
 * @param {Array} [array = []] - An array to wrap.
 * @returns {Arr} Instance of Arr.
 * @description Wrap of an array.
 *
 * @example
 * new Arr([1, 2]);
 */

var Arr = function (_Super) {
  inherits(Arr, _Super);

  function Arr() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, Arr);
    return possibleConstructorReturn(this, (Arr.__proto__ || Object.getPrototypeOf(Arr)).call(this, toArray$1(array instanceof Arr ? array.$ : array)));

    /**
     * @member Arr#$
     * @type {Array}
     * @public
     * @description Made array.
     */
  }

  /**
   * @method Arr#concat
   * @public
   * @param {...(Array|Arr|*)} values - Arrays or any other values to concat the array with.
   * @returns {Arr} New instance of Arr.
   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat
   * @description Synonym for
   * [Array#concat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat}.
   */


  createClass(Arr, [{
    key: 'concat',
    value: function concat() {
      for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      var array = toArray$1(this.$, true);

      iterate(arguments, function (value) {
        value = new Super(value).$;

        if (isArrayLike(value) && !isString(value)) {
          iterate(value, function (value) {
            array.push(value);
          });

          return;
        }

        array.push(value);
      });

      return new this.constructor(array);
    }

    /**
     * @member Arr#first
     * @type {*}
     * @public
     * @readonly
     * @description Returns the first element of the array.
     *
     * @example
     * new Arr([1, 2, 3]).first; // 1
     * new Arr([]).first;        // undefined
     */

  }, {
    key: 'indexOf',


    /**
     * @method Arr#indexOf
     * @public
     * @param {*} value - Value to search.
     * @returns {Number} Index of the argument.
     * @description Almost the same as {@link Super#keyOf}. The difference is that if the value is not found
     * -1 returned instead of null and if found Number(key) returned.
     *
     * @example
     * new Arr([1, 2, 3]).indexOf(1);       // 0
     * new Arr([1, 2, 3]).indexOf('1');     // 0
     * new Arr([1, 2, 3]).indexOf(3);       // -1
     * new Arr([1, 2, NaN]).indexOf(NaN);   // 2
     */
    value: function indexOf(value) {
      var key = this.keyOf(value);

      return key === null ? -1 : Number(key);
    }

    /**
     * @method Arr#indexOfStrict
     * @public
     * @param {*} value - Value to search.
     * @returns {Number} Index of the argument.
     * @description Almost the same as {@link Super#keyOfStrict}. The difference is that if the value is not found
     * -1 returned instead of null and if found Number(key) returned.
     *
     * @example
     * new Arr([1, 2, 3]).indexOfStrict(1);       // 0
     * new Arr([1, 2, 3]).indexOfStrict('1');     // -1
     * new Arr([1, 2, 3]).indexOfStrict(3);       // -1
     * new Arr([1, 2, NaN]).indexOfStrict(NaN);   // 2
     */

  }, {
    key: 'indexOfStrict',
    value: function indexOfStrict(value) {
      var key = this.keyOfStrict(value);

      return key === null ? -1 : Number(key);
    }

    /**
     * @method Arr#join
     * @public
     * @param {String} [separator = ','] - See the link.
     * @returns {String} - String of joined array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join
     * @description Synonym for
     * [Array#join]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join}.
     */

  }, {
    key: 'join',
    value: function join(separator) {
      return this.$.join.apply(this.$, arguments);
    }

    /**
     * @member Arr#last
     * @type {*}
     * @public
     * @readonly
     * @description The last element of the array.
     *
     * @example
     * new Arr([1, 2, 3]).last; // 3
     * new Arr([]).last;        // undefined
     */

  }, {
    key: 'pop',


    /**
     * @method Arr#pop
     * @public
     * @returns {*} Returns deleted element.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop
     * @description Synonym for
     * [Array#pop]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop}.
     */
    value: function pop() {
      return this.$.pop();
    }

    /**
     * @method Arr#push
     * @public
     * @param {...*} values See the link.
     * @this {Arr}
     * @returns {Arr} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push
     * @description Synonym for
     * [Array#push]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push}
     * besides returning this.
     */

  }, {
    key: 'push',
    value: function push() {
      for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        values[_key2] = arguments[_key2];
      }

      this.$.push.apply(this.$, arguments);

      return this;
    }

    /**
     * @method Arr#random
     * @public
     * @returns {*} Random item of the array.
     * @description Method for getting random items of the array.
     *
     * @example
     * new Arr([1, 5, 3]).random(); // 3
     * new Arr([1, 5, 3]).random(); // 5
     */

  }, {
    key: 'random',
    value: function random() {
      return this.$[random$1(0, this.$.length - 1)];
    }

    /**
     * @method Arr#reverse
     * @public
     * @returns {Arr} A wrap of the reversed array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
     * @description Synonym for
     * [Array#reverse]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}.
     */

  }, {
    key: 'reverse',
    value: function reverse() {
      this.$.reverse();

      return this;
    }

    /**
     * @method Arr#shift
     * @public
     * @returns {*} Returns deleted element.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift
     * @description Synonym for
     * [Array#shift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift}.
     */

  }, {
    key: 'shift',
    value: function shift() {
      return this.$.shift();
    }

    /**
     * @method Arr#shuffle
     * @public
     * @returns {Arr} Returns this.
     * @description Method for shuffling.
     *
     * @example
     * new Arr([1, 2, 3, 4]).shuffle().$; // [4, 2, 3, 1]
     * new Arr([1, 2, 3, 4]).shuffle().$; // [1, 3, 4, 2]
     */

  }, {
    key: 'shuffle',
    value: function shuffle() {
      var length = this.$.length;

      return this.forEach(function (value, index, array) {
        var randomIndex = index + Math.floor((length - index) * Math.random());

        array[index] = array[randomIndex];
        array[randomIndex] = value;
      });
    }

    /**
     * @method Arr#slice
     * @public
     * @param {Number} [begin = 0] - See the link.
     * @param {Number} [end = array.length] - See the link.
     * @returns {Arr} A wrap of a sliced array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     * @description Synonym for
     * [Array#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}.
     */

  }, {
    key: 'slice',
    value: function slice(begin, end) {
      return new this.constructor(this.$.slice.apply(this.$, arguments));
    }

    /**
     * @method Arr#sort
     * @public
     * @param {CompareFunction} [compareFunction] - See the link.
     * @returns {Arr} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
     * @description Synonym for
     * [Array#sort]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}.
     */

  }, {
    key: 'sort',
    value: function sort(compareFunction) {
      validate$1([compareFunction], ['function||!'], 'Arr#sort');

      this.$.sort(compareFunction);

      return this;
    }

    /**
     * @method Arr#sortAsc
     * @public
     * @returns {Arr} Returns this.
     * @description Method for ascending sorting. Puts non-numbers first, then NaNs, then sorted values.
     *
     * @example
     * new Arr([NaN, 1, -7, '100', 5]).sortAsc().$; // ['100', NaN, -7, 1, 5]
     */

  }, {
    key: 'sortAsc',
    value: function sortAsc() {
      return this.sort(asc);
    }

    /**
     * @method Arr#sortDesc
     * @public
     * @returns {Arr} Returns this.
     * @description Method for descending sorting. Puts sorted values first, then NaNs, then non-numbers.
     *
     * @example
     * new Arr([NaN, 1, -7, '100', 5]).sortDesc().$; // [5, 1, -7, NaN, '100']
     */

  }, {
    key: 'sortDesc',
    value: function sortDesc() {
      return this.sort(function (y, x) {
        return asc(x, y);
      });
    }

    /**
     * @method Arr#splice
     * @public
     * @param {Number} [start] - See the link.
     * @param {Number} [deleteCount] - See the link.
     * @param {...*} [items] - See the link.
     * @returns {Arr} A wrap of return value of #splice call.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
     * @description Synonym for
     * [Array#splice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}.
     */

  }, {
    key: 'splice',
    value: function splice(start, deleteCount) {
      for (var _len3 = arguments.length, items = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        items[_key3 - 2] = arguments[_key3];
      }

      return new Arr(this.$.splice.apply(this.$, arguments));
    }

    /**
     * @method Arr#string
     * @public
     * @returns {String} Concatenated array.
     * @description Synonym for array.join('').
     *
     * @example
     * new Arr([1, 2, 3]).string(); // '123'
     */

  }, {
    key: 'string',
    value: function string() {
      return this.join('');
    }

    /**
     * @method Arr#unshift
     * @public
     * @param {...*} [values] - See the link.
     * @returns {Arr} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift
     * @description Synonym for
     * [Array#unshift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}
     * besides returning this.
     */

  }, {
    key: 'unshift',
    value: function unshift() {
      for (var _len4 = arguments.length, values = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        values[_key4] = arguments[_key4];
      }

      this.$.unshift.apply(this.$, arguments);

      return this;
    }
  }, {
    key: 'first',
    get: function get() {
      return this.$[0];
    }
  }, {
    key: 'last',
    get: function get() {
      var array = this.$;

      return array[array.length - 1];
    }

    /**
     * @member Arr#length
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length
     * @description Synonym for
     * [Array#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length}.
     */

  }, {
    key: 'length',
    get: function get() {
      return this.$.length;
    }
  }]);
  return Arr;
}(Super);

defineProperties(Arr.prototype, defineProperty({}, _Symbol.toStringTag, 'Arr'));

/**
 * @function asc
 * @private
 * @param {*} x - First value to be compared.
 * @param {*} y - Second value to be compared.
 * @returns {Number} Where to put the first element: before or after.
 */
function asc(x, y) {
  if (!isNumber(x) && !isNumber(y)) {
    return 0;
  }

  if (!isNumber(x)) {
    return -1;
  }

  if (!isNumber(y)) {
    return 1;
  }

  if (isNaN(x) && isNaN(y)) {
    return 0;
  }

  if (isNaN(x)) {
    return -1;
  }

  if (isNaN(y)) {
    return 1;
  }

  return x - y;
}

constructors[1].push({
  check: isArrayLike,
  cls: Arr
});

/**
 * @function array
 * @public
 * @param {Number} number - Length of the array.
 * @param {ArrayCallback} [callback] - If it's present it has to be a function
 * that returns the element that is pushed to the new array.
 * @returns {Arr} New instance of Arr.
 * @description Method for creating new array from the length using optional callback.
 *
 * @example
 * array(3).$;               // [0, 1, 2]
 * array(3, (i) => i * 2).$; // [0, 2, 4]
 */
function array(number, callback) {
  validate$1([number, callback], [['intLike', '>=0'], 'function||!'], 'array');

  var array = [];

  for (var i = 0; i < number; i++) {
    array.push(callback ? callback(i) : i);
  }

  return new Arr(array);
}

/**
 * @function iterate
 * @public
 * @param {Number} number - Number of iterations.
 * @param {IterateCallback} callback - Callback that is called on each iteration with the iteration index.
 * @returns {void}
 * @description Method for replacing for (...) construction.
 *
 * @example
 * iterate();
 */
function iterate$1(number, callback) {
  validate$1([number, callback], [['intLike', '>=0'], 'function'], 'iterate');

  for (var i = 0; i < number; i++) {
    callback(i);
  }
}

/**
 * @module BlobObject
 * @private
 * @mixin
 * @description Exports BlobObject class.
 */

/**
 * @typedef {{ buffer: String, binary: String, dataURL: String, text: String }} methods
 * @private
 * @description List of read blob methods.
 */
var methods = {
  buffer: 'ArrayBuffer',
  binary: 'BinaryString',
  dataURL: 'DataURL',
  text: 'Text'
};
var _global = global$1;
var URL = _global.URL;

/**
 * @typedef {('buffer'|'binary'|'dataURL'|'text')} ReadBlobMethod
 * @public
 * @description Enum type of read blob methods.
 */

/**
 * @typedef {ArrayBuffer|ArrayBufferView|Blob|String} BlobParts
 * @public
 * @description Allowed blob parts.
 */

/**
 * @callback ReaderEventListener
 * @public
 * @param {Event} e - Fired event.
 * @param {FileReader} reader - FileReader.
 */

/**
 * @class BlobObject
 * @extends Super
 * @public
 * @param {Blob} blob - Blob to wrap.
 * @returns {BlobObject} Instance of BlobObject.
 * @description Wrap of a blob.
 *
 * @example
 * new BlobObject(new Blob(['{"foo":"bar"}'], { type: 'application/json' }));
 */

var BlobObject = function (_Super) {
  inherits(BlobObject, _Super);

  function BlobObject() {
    classCallCheck(this, BlobObject);
    return possibleConstructorReturn(this, (BlobObject.__proto__ || Object.getPrototypeOf(BlobObject)).apply(this, arguments));
  }

  createClass(BlobObject, [{
    key: 'readAs',


    /**
     * @method BlobObject#readAs
     * @public
     * @param {ReadBlobMethod} method - Method that is used for reading from blob.
     * @param {ReaderEventListener} [progress] - Progress listener.
     * @returns {Promise} Promise that could be aborted.
     * @description Method for reading from blobs.
     *
     * @example
     * new BlobObject(new Blob(['{"foo":"bar"}'], { type: 'application/json' }))
     *   .readAs('text')
     *   .then((value) => {
     *     console.log(value); // '{"foo":"bar"}'
     *   });
     */
    value: function readAs(method, progress) {
      var _this2 = this;

      if (!methods[method]) {
        throw new Error('1st argument must be one of following values: buffer, binary, dataURL, text');
      }

      var reader = new FileReader();
      var toReject = void 0;

      if (isFunction(progress)) {
        reader.onprogress = function (e) {
          progress(e, this);
        };
      }

      var promise = new Promise$1(function (resolve, reject) {
        toReject = reject;

        reader.onerror = function (_ref) {
          var target = _ref.target;

          if (reader) {
            reject(target.error);
          }
        };

        reader.onload = function (_ref2) {
          var target = _ref2.target;

          resolve(target.result);
        };

        reader['readAs' + methods[method]](_this2.$);
      });

      promise.abort = function abort() {
        toReject(new Error('Reading was aborted'));

        reader.abort();

        reader = null;

        return this;
      };

      return promise;
    }

    /**
     * @method BlobObject#saveAs
     * @public
     * @param {String} [name] - Name that is used for saving file.
     * @returns {BlobObject} Returns this.
     * @description Method for saving blobs.
     *
     * @example
     * new BlobObject(new Blob(['{"foo":"bar"}'], { type: 'application/json' }))
     *   .saveAs('blob.json');
     */

  }, {
    key: 'saveAs',
    value: function saveAs() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'download';

      var anchor = document.createElement('a');

      anchor.href = this.dataURL;
      anchor.setAttribute('download', name);
      anchor.click();

      return this;
    }
  }, {
    key: 'dataURL',

    /**
     * @member BlobObject#$
     * @type {Blob}
     * @public
     * @description Original Blob.
     */

    /**
     * @member {String} BlobObject#dataURL
     * @type {String}
     * @public
     * @readonly
     * @description Returns dataURL representation of the blob.
     */
    get: function get() {
      return URL.createObjectURL(this.$);
    }
  }]);
  return BlobObject;
}(Super);

defineProperties(BlobObject.prototype, defineProperty({}, _Symbol.toStringTag, 'BlobObject'));

constructors[1].push({
  check: function check(blob) {
    return (/^(Blob|File)$/.test(toStringTag(blob))
    );
  },
  cls: BlobObject
});

/**
 * @function blob
 * @public
 * @param {(BlobParts[]|BlobParts)} blobParts - Blob parts that are passed to
 * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.
 * @param {Object} [options] - Options that are passed to
 * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.
 * @returns {BlobObject} New instance of BlobObject.
 * @description Function for creating blobs not involving BlobObject and Blob constructors.
 */
function blob$1(blobParts) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isArray(blobParts)) {
    blobParts = [blobParts];
  }

  return new BlobObject(new Blob(blobParts, options));
}

/**
 * @module Str
 * @private
 * @mixin
 * @description Exports Str class.
 */

var htmlSpecials = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;'
};
var regexpSpecialsRegexp = new RegExp(new Super(regexpSpecialCharacters).word(function (x) {
  return '\\' + x + '|';
}).replace(/\|$/, ''), 'g');

/**
 * @class Str
 * @extends Super
 * @public
 * @param {String} [string = ''] - A string to wrap.
 * @returns {Str} Instance of Str.
 * @description Wrap of a string.
 *
 * @example
 * const s = new Num('1');
 */

var Str = function (_Super) {
  inherits(Str, _Super);

  function Str() {
    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    classCallCheck(this, Str);
    return possibleConstructorReturn(this, (Str.__proto__ || Object.getPrototypeOf(Str)).call(this, '' + string));

    /**
     * @member Str#$
     * @type {String}
     * @public
     * @description Original string.
     */
  }

  /**
   * @method Str#capitalizeFirst
   * @public
   * @returns {Str} Capitalized string.
   * @description Method capitalizing the first symbol.
   *
   * @example
   * new Str('foo').capitalizeFirst().$; // 'Foo'
   */


  createClass(Str, [{
    key: 'capitalizeFirst',
    value: function capitalizeFirst() {
      var string = this.$;

      return new Str(string.slice(0, 1).toUpperCase() + string.slice(1));
    }

    /**
     * @method Str#endsWith
     * @public
     * @param {String} searchString - See the link.
     * @param {Number} [position = string.length] - See the link.
     * @returns {Boolean} If the string ends with the argument string.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
     * @description Synonym for
     * [String#endsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith}.
     */

  }, {
    key: 'endsWith',
    value: function endsWith(searchString, position) {
      if (arguments.length < 2) {
        position = this.$.length;
      }

      return this.slice(0, position).revert().startsWith(new Str(searchString).revert().$);
    }

    /**
     * @method Str#escapeHTML
     * @public
     * @returns {Str} New instance of Str.
     * @description Methods escaping "&", "<" and ">" symbols.
     *
     * @example
     * new Str('"1 < 2" & "7 > 4" are true expressions.').escapeHTML().$;
     * // '"1 &lt; 2" &amp "7 &gt; 2" are true expressions.'
     */

  }, {
    key: 'escapeHTML',
    value: function escapeHTML() {
      var string = this.$;

      iterate(htmlSpecials, function (escaped, symbol) {
        string = string.replace(new RegExp(symbol, 'g'), escaped);
      });

      return new Str(string);
    }

    /**
     * @method Str#escapeRegExp
     * @public
     * @returns {Str} New instance of Str.
     * @description Method escaping RegExp special characters.
     *
     * @example
     * new Str('(213.98 - [] {})').escapeRegExp().$; // '\(213\.98 \- \[\] \{\}\)'
     */

  }, {
    key: 'escapeRegExp',
    value: function escapeRegExp() {
      return this.replace(regexpSpecialsRegexp, '\\$&');
    }

    /**
     * @method Str#in
     * @public
     * @param {*} object - Object to check the string as a property in.
     * @returns {Boolean} If it is in the object or not.
     * @description Returns string in object.
     *
     * @example
     * new Str('a').in({ a: 1 }); // true
     * new Str('toFixed').in(1);  // false
     * new Str('a').in(null);     // false
     */

  }, {
    key: 'in',
    value: function _in(object) {
      if (!isObject(object)) {
        return false;
      }

      return this.$ in object;
    }

    /**
     * @method Str#indexOf
     * @public
     * @param {String} searchValue - See the link.
     * @param {Number} [fromIndex = 0] - See the link.
     * @returns {Number} Found index or -1.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf
     * @description Synonym for
     * [String#indexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf}.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(searchValue, fromIndex) {
      return this.$.indexOf.apply(this.$, arguments);
    }

    /**
     * @method Str#lastIndexOf
     * @public
     * @param {String} searchValue - See the link.
     * @param {Number} [fromIndex = string.length] - See the link.
     * @returns {Number} Found index or -1.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf
     * @description Synonym for
     * [String#lastIndexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf}.
     */

  }, {
    key: 'lastIndexOf',
    value: function lastIndexOf(searchValue, fromIndex) {
      return this.$.lastIndexOf.apply(this.$, arguments);
    }

    /**
     * @member Str#length
     * @type {Number}
     * @public
     * @readonly
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length
     * @description Synonym for
     * [String#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length}.
     */

  }, {
    key: 'match',


    /**
     * @method Str#match
     * @public
     * @returns {Arr|Super} D-Wrap of found match.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match
     * @description Synonym for
     * [String#match]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match}.
     */
    value: function match(regexp) {
      return D$1(this.$.match.apply(this.$, arguments));
    }

    /**
     * @method Str#repeat
     * @public
     * @param {Integer} times - Times to repeat the string.
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
     * @description Synonym for
     * [String#repeat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat}.
     *
     * @example
     * new Str('123').repeat(2).$; // '123123'
     * new Str('123').repeat(0).$; // ''
     */

  }, {
    key: 'repeat',
    value: function repeat(times) {
      validate$1([times], [['intLike', '>=0']], 'Str#repeat');

      times = +times;

      var string = this.$;

      var s = '';

      for (var i = 0; i < times; i++) {
        s += string;
      }

      return new Str(s);
    }

    /**
     * @method Str#replace
     * @public
     * @param {RegExp|String} regexp - See the link.
     * @param {String|Function} [replacer = ''] - See the link.
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace
     * @description Synonym for
     * [String#replace]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace}
     * besides that replacer has a default value of ''.
     */

  }, {
    key: 'replace',
    value: function replace(regexp) {
      var replacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      return new Str(this.$.replace(regexp, replacer));
    }

    /**
     * @method Str#replaceString
     * @public
     * @param {String} string - String to replace.
     * @param {String} [replacer = ''] - String to replace with.
     * @returns {Str} New instance of Str.
     * @description Method for global string replaceing.
     *
     * @example
     * new Str('123123').replaceString('1', '4').$; // '423423'
     * new Str('123123').replaceString('1').$;      // '2323'
     */

  }, {
    key: 'replaceString',
    value: function replaceString(string) {
      var replacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      string = new Super(string).$;

      validate$1([string], ['string'], 'Str#replaceString');

      return new Str(this.$.split(string).join(replacer));
    }

    /**
     * @method Str#revert
     * @public
     * @returns {Str} New instance of string.
     * @description Method for reverting a string.
     *
     * @example
     * new Str('1234').revert().$; // '4321'
     */

  }, {
    key: 'revert',
    value: function revert() {
      var string = this.$;
      var str = '';

      for (var i = string.length - 1; i >= 0; i--) {
        str += string[i];
      }

      return new Str(str);
    }

    /**
     * @method Str#search
     * @public
     * @param {RegExp} regexp - See the link.
     * @returns {Number} Index of the first match, if found, and -1 if not.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search
     * @description Synonym for
     * [String#search]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search}.
     */

  }, {
    key: 'search',
    value: function search(regexp) {
      validate$1([regexp], ['regexp']);

      return this.$.search.apply(this.$, arguments);
    }

    /**
     * @method Str#slice
     * @public
     * @param {Number} [beginSlice = 0] - See the link.
     * @param {Number} [endSlice = string.length] - See the link.
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice
     * @description Synonym for
     * [String#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice}.
     */

  }, {
    key: 'slice',
    value: function slice(beginSlice, endSlice) {
      return new Str(this.$.slice.apply(this.$, arguments));
    }

    /**
     * @method Str#split
     * @public
     * @param {RegExp|String} [separator] - See the link.
     * @returns {Arr|Super} D-Wrap of the array.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split
     * @description Synonym for
     * [String#split]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split}.
     */

  }, {
    key: 'split',
    value: function split(separator) {
      return D$1(this.$.split.apply(this.$, arguments));
    }

    /**
     * @method Str#startsWith
     * @public
     * @param {String} searchString - See the link.
     * @param {Number} [position = 0] - See the link.
     * @returns {Boolean} If the string ends with the argument string.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
     * @description Synonym for
     * [String#startsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith}.
     */

  }, {
    key: 'startsWith',
    value: function startsWith(searchString) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      return this.$.indexOf.apply(this.$, arguments) === position;
    }

    /**
     * @method Str#substr
     * @public
     * @param {Number} [start = 0] - See the link.
     * @param {Number} [length = string.length] - See the link.
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr
     * @description Synonym for
     * [String#substr]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr}.
     */

  }, {
    key: 'substr',
    value: function substr(start, length) {
      return new Str(this.$.substr.apply(this.$, arguments));
    }

    /**
     * @method Str#substring
     * @public
     * @param {Number} [indexStart = 0] - See the link.
     * @param {Number} [indexEnd = string.length] - See the link.
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring
     * @description Synonym for
     * [String#substring]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring}.
     */

  }, {
    key: 'substring',
    value: function substring(indexStart, indexEnd) {
      return new Str(this.$.substring.apply(this.$, arguments));
    }

    /**
     * @method Str#toCamelCase
     * @public
     * @returns {Str} New instance of Str.
     * @description Removes following regexp /\s\-_\./ making the string camel cased.
     *
     * @example
     * new Str('spinal-case').toCamelCase().$;  // 'spinalCase'
     * new Str('_snake_case_').toCamelCase().$; // 'snakeCase'
     */

  }, {
    key: 'toCamelCase',
    value: function toCamelCase() {
      return new Str(trim(this.$).replace(/[\s\-_.]+/g, '-').replace(/-[^-]/g, function (match) {
        return match[1].toUpperCase();
      }).replace(/^[\S]/, function (match) {
        return match.toLowerCase();
      }));
    }

    /**
     * @method Str#toCapitalCase
     * @public
     * @returns {Str} New instance of Str.
     * @description Removes following regexp /\-_\./ making the string capital letter cased.
     *
     * @example
     * new Str('spinal-case').toCapitalCase().$;  // 'Spinal Case'
     * new Str('_snake_case_').toCapitalCase().$; // 'Snake Case'
     */

  }, {
    key: 'toCapitalCase',
    value: function toCapitalCase() {
      return new Str(trim(this.$).replace(/[\s\-_.]+/g, ' ').replace(/[\S]/g, function (match) {
        return match.toLowerCase() === match ? match : ' ' + match;
      }).replace(/\s[\S]/g, function (match) {
        return match.toUpperCase();
      }).replace(/\s+/g, ' ').replace(/^\s/, '').replace(/^[\S]/, function (match) {
        return match.toUpperCase();
      }));
    }

    /**
     * @method Str#toDotCase
     * @public
     * @returns {Str} New instance of Str.
     * @description Removes following regexp /\-_\./ making the string dot cased.
     *
     * @example
     * new Str('spinal-case').toDotCase().$;  // 'spinal.case'
     * new Str('_snake_case_').toDotCase().$; // 'snake.case'
     */

  }, {
    key: 'toDotCase',
    value: function toDotCase() {
      return new Str(trim(this.$).replace(/[\s\-_.]+/g, '.').replace(/[^.]/g, function (match) {
        return match.toLowerCase() === match ? match : '.' + match;
      }).replace(/\.+/g, '.').replace(/^\./, '').toLowerCase());
    }

    /**
     * @method Str#toHyphenCase
     * @public
     * @returns {Str} New instance of Str.
     * @description Removes following regexp /\s\-_\./ making the string camel cased.
     *
     * @example
     * new Str('camelCase').toSpinalCase().$;    // 'camel-case'
     * new Str('_snake_case_').toSpinalCase().$; // 'snake-case'
     */

  }, {
    key: 'toHyphenCase',
    value: function toHyphenCase() {
      return new Str(trim(this.$).replace(/[\s\-_.]+/g, '-').replace(/[^-]/g, function (match) {
        return match.toLowerCase() === match ? match : '-' + match;
      }).replace(/-+/g, '-').replace(/^-/, '').toLowerCase());
    }

    /**
     * @method Str#toLowerCase
     * @public
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase
     * @description Synonym for
     * [String#toLowerCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase}.
     *
     * @example
     * new Str('UPPER-CASE').toLowerCase().$;  // 'upper-case'
     */

  }, {
    key: 'toLowerCase',
    value: function toLowerCase() {
      return new Str(this.$.toLowerCase());
    }

    /**
     * @method Str#toSnakeCase
     * @public
     * @returns {Str} New instance of Str.
     * @description Removes following regexp /\s\-\./ making the string spinal cased.
     *
     * @example
     * new Str('spinal-case').toSnakeCase().$; // 'spinal_case'
     * new Str('camelCase').toSnakeCase().$;   // 'camel_case'
     */

  }, {
    key: 'toSnakeCase',
    value: function toSnakeCase() {
      return new Str(trim(this.$).replace(/[\s\-_.]+/g, '_').replace(/[^_]/g, function (match) {
        return match.toLowerCase() === match ? match : '_' + match;
      }).replace(/_+/g, '_').replace(/^_/, '').toLowerCase());
    }

    /**
     * @method Str#toSpaceCase
     * @public
     * @returns {Str} New instance of Str.
     * @description Removes following regexp /\-_\./ making the string space cased.
     *
     * @example
     * new Str('spinal-case').toSpaceCase().$;  // 'spinal case'
     * new Str('_snake_case_').toSpaceCase().$; // 'snake case'
     */

  }, {
    key: 'toSpaceCase',
    value: function toSpaceCase() {
      return new Str(trim(this.$).replace(/[\s\-_.]+/g, ' ').replace(/[\S]/g, function (match) {
        return match.toLowerCase() === match ? match : ' ' + match;
      }).replace(/\s+/g, ' ').replace(/^\s/, '').toLowerCase());
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.$;
    }

    /**
     * @method Str#toUpperCase
     * @public
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase
     * @description Synonym for
     * [String#toUpperCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase}.
     *
     * @example
     * new Str('lower-case').toUpperCase().$;  // 'LOWER-CASE'
     */

  }, {
    key: 'toUpperCase',
    value: function toUpperCase() {
      return new Str(this.$.toUpperCase());
    }

    /**
     * @method Str#trim
     * @public
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim
     * @description Synonym for
     * [String#trim]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim}.
     */

  }, {
    key: 'trim',
    value: function trim() {
      return new Str(this.$.replace(/^[\s\ufeff\u00a0]+|[\s\ufeff\u00a0]+$/g, ''));
    }

    /**
     * @method Str#trimLeft
     * @public
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft
     * @description Synonym for
     * [String#trimLeft]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft}.
     */

  }, {
    key: 'trimLeft',
    value: function trimLeft() {
      return new Str(this.$.replace(/^[\s\ufeff\u00a0]+/, ''));
    }

    /**
     * @method Str#trimRight
     * @public
     * @returns {Str} New instance of Str.
     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight
     * @description Synonym for
     * [String#trimRight]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight}.
     */

  }, {
    key: 'trimRight',
    value: function trimRight() {
      return new Str(this.$.replace(/[\s\ufeff\u00a0]+$/, ''));
    }
  }, {
    key: 'length',
    get: function get() {
      return this.$.length;
    }
  }]);
  return Str;
}(Super);

defineProperties(Str.prototype, defineProperty({}, _Symbol.toStringTag, 'Str'));

constructors[2].push({
  check: isString,
  cls: Str
});

function trim(string) {
  return string.replace(/^[\s\-_.]+|[\s\-_.]+$/g, '');
}

/**
 * @function parseJSON
 * @public
 * @param {String} [json = null] - String to parse.
 * @param {Object} [options] - Options.
 * @param {Boolean|*} [options.numbers] - If it is needed to parse number-like strings as numbers.
 * @param {Boolean|*} [options.dates] - If it is needed to parse date-like string as dates.
 * Date-like string is considered to match ^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d\.\d\d\dZ?$
 * @param {JSONCallback} [callback] - Callback that called on every iteration.
 * @returns {DWrap} D-Wrap of found match.
 * @description Method for parsing json.
 *
 * @example
 * parseJSON('{ "a": 1 }').$;                                           // { a: 1 }
 * parseJSON('{ "a": "1" }', { numbers: true }).$;                      // { numbers: true }
 * parseJSON('{ "a": "1999-12-31T23:59:59.999Z" }', { dates: true }).$; // { a: Date {...} }
 */
function parseJSON() {
  var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var callback = arguments[2];

  if (arguments.length <= 1) {
    return D$1(JSON.parse(json));
  }

  if (isFunction(options)) {
    callback = options;
    options = {};
  }

  var _options = options,
      numbers = _options.numbers,
      dates = _options.dates;

  var parsed = JSON.parse(json, function (key, value) {
    if (dates && /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d\.\d\d\dZ?$/.test(value)) {
      value = new Date(value);
    } else if (numbers && isNumberLike(value) && isString(value)) {
      value = Number(value);
    }

    return callback ? callback.apply(this, arguments) : value;
  });

  return D$1(parsed);
}

/**
 * @module helpers/markupToJSON
 * @private
 * @description Exports markupToJSON method.
 */

/**
 * @typedef {Object} MarkupElement
 * @property {'comment'|'text'|'element'} type - Type of the node.
 * @property {MarkupElement} parent - Type of the node.
 * @property {Object.<String, String>} attrs - Node attributes
 * @property {MarkupElement[]} children - Node children.
 */

var submitString = 'Please, submit an issue at https://github.com/dwaynejs/dwayne/issues.';
var NODE_REGEX_SET = new Super({
  'tag-open': new RegExp('<(' + htmlAllowedTagSymbols + ')\\s*', 'i'),
  'tag-close': constructCloseTagRegExp(htmlAllowedTagSymbols),
  comment: /<!--((?:-[^\->]|[^\->])(?:-?[^-])*[^-]?|)-->/
});
var TAG_OPEN_CLOSE = /^(\/?)>/;
// const ATTRIBUTE = /^([^\u0000-\u0020\s"'>\/=]+)(?:\s*=\s*('[^']*'|"[^"]*"|[^\s"'`<>=]+))?\s*/;
var ATTRIBUTE = new RegExp('^(' + htmlAllowedAttrSymbols + ')(?:\\s*=\\s*(\'[^\']*\'|"[^"]*"|[^\\s"\'`<>=]+))?\\s*');
var div = document.createElement('div');
var nodeSwitcher = switcher('strictEquals', function (elem) {
  return elem;
}).case('tag-open', function (elem, node) {
  var _node = node,
      name = _node.value,
      selfClosing = _node.selfClosing;


  node = {
    name: name,
    attrs: new Super(node.attrs).map(function (value) {
      return parseCharacterData(value);
    }).$,
    parent: elem,
    children: new Arr([])
  };

  elem.children.push(node);

  if (!selfClosing && voidElements.indexOf(name) === -1) {
    elem = node;
  }

  return elem;
}).case('tag-close', function (elem, node) {
  if (elem.name === node.value) {
    elem = elem.parent;
  }

  return elem;
}).case(['comment', 'text'], function (elem, node, collapseWhiteSpace, type) {
  var element = {
    name: '#' + type,
    parent: elem,
    value: node.value
  };

  if (type === 'text' && elem.name !== 'script' && elem.name !== 'style') {
    element.value = parseCharacterData(element.value);

    if (collapseWhiteSpace) {
      element.value = new Str(element.value).trim().$;
    }
  }

  if (!collapseWhiteSpace || !/^\s*$/.test(element.value)) {
    elem.children.push(element);
  }

  return elem;
});
var rawTextSwitcher = switcher('strictEquals', false).case(['title', 'textarea', 'style', 'script'], true);

var InternalParsingError = function InternalParsingError(index) {
  classCallCheck(this, InternalParsingError);

  this.index = index;
};

var ParsingError = function (_Error) {
  inherits(ParsingError, _Error);

  function ParsingError() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ParsingError);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParsingError.__proto__ || Object.getPrototypeOf(ParsingError)).call.apply(_ref, [this].concat(args))), _this), _this.type = 'PARSING_ERROR', _temp), possibleConstructorReturn(_this, _ret);
  }

  return ParsingError;
}(Error);

/**
 * @function markupToJSON
 * @private
 * @param {String} markup - Markup to parse to JSON.
 * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be collapsed.
 * @returns {Arr.<MarkupElement>} Markup elements array.
 * @description Function for parsing html and xml to JSON.
 */


var markupToJSON = (function (markup, collapseWhiteSpace) {
  collapseWhiteSpace = !!collapseWhiteSpace;

  var elements = new Arr([]);
  var startMarkup = markup;
  var found = void 0;
  var globalIndex = 0;
  var elem = {
    name: null,
    children: elements
  };

  while (markup.length) {
    try {
      found = find$1(markup, elem);
    } catch (err) {
      if (!(err instanceof InternalParsingError)) {
        throwUnexpectedError();
      }

      throw new ParsingError('Parsing error near index ' + nearString(startMarkup, globalIndex + err.index));
    }

    var _found = found,
        type = _found.type,
        attrs = _found.attrs,
        selfClosing = _found.selfClosing,
        index = _found.index,
        value = _found.value;


    globalIndex += index;

    if (!index) {
      throwUnexpectedError();
    }

    var node = {
      type: type,
      value: value
    };

    if (type === 'tag-open') {
      node.attrs = attrs;
      node.selfClosing = selfClosing;
    }

    elem = nodeSwitcher(node.type, [elem, node, collapseWhiteSpace]);

    markup = markup.slice(index);
  }

  return elements;

  function throwUnexpectedError() {
    throw new ParsingError('Unexpected parsing error near index ' + nearString(startMarkup, globalIndex) + '. ' + submitString);
  }
});

function find$1(markup, elem) {
  var name = elem.name;

  var matches = void 0;

  if (rawTextSwitcher(name)) {
    matches = new Super({
      'tag-close': markup.match(constructCloseTagRegExp(name))
    });
  } else {
    matches = NODE_REGEX_SET.map(function (regex) {
      return markup.match(regex);
    });
  }

  var match = void 0;

  if (match = matches.find(function (match) {
    return match && match.index === 0;
  })) {
    var returning = {
      type: match.key,
      index: match.value[0].length,
      value: match.value[1]
    };
    var attrs = {};

    if (match.key === 'tag-open') {
      var startMarkup = markup;
      var closeMatch = void 0;

      returning.selfClosing = false;
      returning.attrs = attrs;

      while ((markup = startMarkup.slice(returning.index)) && !(closeMatch = markup.match(TAG_OPEN_CLOSE))) {
        var attr = markup.match(ATTRIBUTE);

        if (!attr) {
          returning.index += 1;

          continue;
        }

        attrs[attr[1]] = (attr[2] || '').replace(/^("|')|("|')$/g, '');
        returning.index += attr[0].length;
      }

      if (closeMatch) {
        returning.index += closeMatch[0].length;
        returning.selfClosing = !!closeMatch[1];
      }
    }

    return returning;
  }

  var _matches$min = matches.min(function (match) {
    return match ? match.index : NaN;
  }),
      index = _matches$min.value;

  if (index === Infinity) {
    index = markup.length;
  }

  return {
    type: 'text',
    index: index,
    value: markup.slice(0, index)
  };
}

function constructCloseTagRegExp(tagName) {
  return new RegExp('</(' + tagName + ')\\s*>', 'i');
}

function nearString(markup, index) {
  return index + ' (~~~ "' + markup.slice(index, index + 15) + '" ~~~, the string itself is "' + markup + '")';
}

function parseCharacterData(string) {
  return string.replace(/&(\w+|#x?\d+);/g, function (match) {
    div.innerHTML = match;

    return div.textContent || div.innerText;
  });
}

/**
 * @module Elem
 * @private
 * @mixin
 * @description Exports Elem class.
 */

/**
 * @typedef {String} ElemEventString
 * @public
 * @description A string containing events separated by a comma with zero or more spaces or just spaces.
 */

/**
 * @callback ElemValueCallback
 * @public
 * @param {String} value - Old value.
 * @param {Elem} elem - Current element.
 * @param {Number} index - Index in the set of the elements.
 */

/**
 * @callback ElemSetOfCallback
 * @public
 * @param {Element} created - Created element.
 * @param {*} value - Value of the iterated element in the object.
 * @param {Key} key - Key of the iterated element in the object.
 * @param {*} object - Object that is iterated over.
 * @param {Element} elem - Current element.
 * @param {Number} index - Index of the current element.
 */

/**
 * @callback ValidateCallback
 * @public
 * @param {*} value - Element value.
 * @param {Element} elem - Element to validate.
 * @param {Number} index - Index of the element.
 */

/**
 * @callback CtxCallback
 * @public
 * @param {CanvasRenderingContext2D} ctx - Canvas rendering context.
 */

/**
 * @callback ElemListener
 * @public
 * @param {Event} e - Fired event.
 * @param {Element} elem - Element on which the listener was called.
 * @param {Number} index - Index of the element on which the listener was called.
 */

/**
 * @callback ElemRemoveListeners
 * @public
 * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified
 * by the events in the arguments.
 */

var nativeDocument = global$1.document;
var emptyDiv = nativeDocument.createElement('div');
var eventSeparator = /(,| ) */;
var textProperty = new Super(Node.prototype).propertyDescriptor('textContent') ? 'textContent' : 'innerText';
var classes = {};
var attrs = {};
var windowsDwayneData = new Arr([]);
var inputElements = 'input, select, textarea, datalist, keygen, output';
var click$1 = method('click');
var svgNS$1 = 'http://www.w3.org/2000/svg';
var xmlNS = 'http://www.w3.org/2000/xmlns/';
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xhtmlNS = 'http://www.w3.org/1999/xhtml';
var typeSwitcher = switcher('call', function (elem, type) {
  var ns = type === 'svg' ? svgNS$1 : elem.prop('namespaceURI') || nativeDocument.documentElement.namespaceURI || xhtmlNS;

  return nativeDocument.createElementNS(ns, type);
}).case(function (type) {
  return type === '#comment';
}, function () {
  return nativeDocument.createComment('');
}).case(function (type) {
  return type === '#text';
}, function () {
  return nativeDocument.createTextNode('');
});
var refSwitcher = switcher('strictEquals', 'href').case(['img', 'script', 'iframe', 'audio', 'video'], 'src').case('form', 'action');
var filterSwitcher = switcher('call', function (selector) {
  return selector;
}).case(isString, function (selector) {
  return function (elem) {
    return new Elem(elem).is(selector);
  };
}).case([isArray, isElem], function (elems) {
  elems = new Arr(elems);

  return function (elem) {
    return elems.indexOf(elem) !== -1;
  };
});
var innerSwitcher = switcher('strictEquals', 0).case('padding-box', function (paddings) {
  return paddings;
}).case('border-box', function (paddings, borders) {
  return paddings + borders;
});
var outerSwitcher = switcher('strictEquals', function (borders, paddings) {
  return borders + paddings;
}).case('padding-box', function (borders) {
  return borders;
}).case('border-box', 0);
var attrNSSwitcher = switcher('call', null).case(function (attr) {
  return attr === 'xmlns' || attr === 'xmlns:xlink';
}, function (elem) {
  return elem.name === 'svg' ? xmlNS : null;
}).case(function (attr) {
  return (/^xlink:\w/.test(attr)
  );
}, function (elem) {
  return elem.closest('svg').length ? xlinkNS : null;
});

/**
 * @class Elem
 * @extends Arr
 * @public
 * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.
 * @returns {Elem} Instance of Elem.
 * @description Wrap of an elements set. Also has all methods from from
 * [CanvasRenderingContext2D]{@link https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D}.
 * Getters methods return the same as methods from CanvasRenderingContext2D and the rest return this.
 * Work for the first canvas element in the set.
 *
 * @example
 * new Elem(document.body);
 * new Elem(document.querySelectorAll('.cls'));
 * new Elem(document.getElementsByClassName('cls'));
 */

var Elem = function (_Arr) {
  inherits(Elem, _Arr);

  function Elem() {
    var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, Elem);

    var _this = possibleConstructorReturn(this, (Elem.__proto__ || Object.getPrototypeOf(Elem)).call(this, function () {
      var element = elem;

      if (isArrayLike(element) && (isWindow(element) || isHTMLDocument(element) || isDocumentFragment(element) || isElement(element) || isCommentOrText(element) || isStyleRule(element))) {
        element = [element];
      }

      return new Arr(toArray$1(new Super(element).$, true)).object(function (elems, elem) {
        if (elems.indexOf(elem) === -1 && (isElement(elem) || isWindow(elem) || isHTMLDocument(elem) || isDocumentFragment(elem) || isCommentOrText(elem) || isStyleRule(elem))) {
          return elems.push(elem);
        }

        if (isElem(elem)) {
          elems.push.apply(elems, elem.$);
        }
      }, []).$;
    }()));

    _this.$$ = elem;

    _this.forEach(addDwayneData);

    /**
     * @member {Array.<Node|Window>} Elem#$
     * @type {Array.<Node|Window>}
     * @public
     * @description Constructed element set.
     */

    /**
     * @member {*} Elem#$$
     * @type {*}
     * @public
     * @description Initial element set.
     */
    return _this;
  }

  /**
   * @method Elem#add
   * @public
   * @param {...(String|Elem|Element|Element[])} elements - Each argument is a selector, or Elem, or Element, or array of Elements.
   * @returns {Elem} Returns this.
   * @description Method for adding new elements to the set.
   *
   * @example
   * elem1.find('.cls1')
   *   .add(elem2.find('.cls2'))
   *   .hide();
   */


  createClass(Elem, [{
    key: 'add',
    value: function add() {
      var _this2 = this;

      for (var _len = arguments.length, elements = Array(_len), _key = 0; _key < _len; _key++) {
        elements[_key] = arguments[_key];
      }

      iterate(arguments, function (elem) {
        toFind(elem).forEach(function (elem) {
          if (_this2.indexOf(elem) === -1) {
            _this2.push(elem);
          }
        });
      });

      return this;
    }

    /**
     * @method Elem#addClass
     * @public
     * @param {...String} classes - Classes to add.
     * @returns {Elem} Returns this.
     * @description Method for adding classes to the all the elements in the set.
     *
     * @example
     * elem.addClass('red', 'round');
     */

  }, {
    key: 'addClass',
    value: function addClass() {
      var _arguments = arguments;

      for (var _len2 = arguments.length, classes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }

      return this.forEach(function (elem) {
        var list = elem.classList;

        iterate(isElement(elem) && _arguments, function (cls) {
          return list.add(cls);
        });
      });
    }

    /**
     * @method Elem#addComment
     * @public
     * @param {String} text - Text of comment to add.
     * @param {Boolean} end - If the comment should be inserted to the end. If false it's inserted to the start.
     * @returns {Elem} Returns this.
     * @description Method for adding comment to all the elements in the set.
     *
     * @example
     * elem.addHTML('<div>1</div>');
     */

  }, {
    key: 'addComment',
    value: function addComment(text) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', '<!--' + text + '-->');
        }
      });
    }

    /**
     * @method Elem#addHTML
     * @public
     * @param {String} html - HTML to add.
     * @param {Boolean} end - If the HTML should be inserted to the end. If false it's inserted to the start.
     * @returns {Elem} Returns this.
     * @description Method for adding HTML to all the elements in the set.
     *
     * @example
     * elem.addHTML('<div>1</div>');
     */

  }, {
    key: 'addHTML',
    value: function addHTML(html) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', html);
        }
      });
    }

    /**
     * @method Elem#addRule
     * @public
     * @param {String} name - Name of the rule.
     * @param {String} selector - Selector for the rule
     * @param {Object.<String, String>} style - Style for the selector.
     * @returns {Elem} Returns this.
     * @description Method for adding css styles into the first style tag in the set.
     * Note: style element should be inside the document.
     *
     * @example
     * style.addRule('img-size', 'img.square', {
     *   width: '40px !important',
     *   height: '40px !important'
     * });
     */

  }, {
    key: 'addRule',
    value: function addRule(name, selector, style) {
      this.some(function (elem) {
        if (getName(elem) === 'style') {
          var sheet = elem.sheet;
          var length = sheet.cssRules.length;

          var rules = new Super(style).word(function (value, property) {
            return new Str(property).toHyphenCase() + ': ' + value + ';\n';
          });

          sheet.insertRule(selector + ' {' + (rules && '\n') + rules + '}', length);
          sheet.cssRules[length].dwayneData = { name: name };

          return true;
        }
      });

      return this;
    }

    /**
     * @method Elem#addText
     * @public
     * @param {String} text - Text to add.
     * @param {Boolean} end - If the text should be inserted to the end. If false it's inserted to the start.
     * @returns {Elem} Returns this.
     * @description Method for adding text to all the elements in the set.
     *
     * @example
     * elem.addText('123');
     */

  }, {
    key: 'addText',
    value: function addText(text) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.forEach(function (elem) {
        new Elem(nativeDocument.createTextNode(text)).into(elem, end);
      });
    }

    /**
     * @method Elem#apply
     * @public
     * @param {...String} strings - Strings to apply.
     * @returns {Elem} Returns this.
     * @description Method that is a shorthand for many other methods.
     * All shorthands can be separated with space and written within one string.
     *
     * @example
     * elem.apply(
     *   '#id .c1 .c2 @border(1px solid black) $disabled $attr(some value) *(Click me!)'
     * );
     * // shorthand for
     * // elem
     * //   .id('id')
     * //   .addClass('c1', 'c2')
     * //   .css('border', '1px solid black')
     * //   .attr({
     * //     attr, 'some value'
     * //     disabled: ''
     * //   })
     * //   .text('Click me!');
     * // There is a full list of possible types of syntax below...
     *
     * elem.apply('#id');                    // shorthand for elem.id('id');
     * elem.apply('.c1 .c2');                // shorthand for elem.addClass('c1', 'c2');
     * elem.apply('-.c1 -.c2');              // shorthand for elem.removeClass('c1', 'c2');
     * elem.apply('-@float -@display');      // shorthand for elem.removeCSS('float', 'display');
     * elem.apply('-$a1 -$a2');              // shorthand for elem.removeAttr('a1', 'a2');
     * elem.apply('*(some text)');           // shorthand for elem.text('some text');
     * elem.apply('&(<div>1</div>)');        // shorthand for elem.html('<div>1</div>');
     * elem.apply('@float(right)');          // shorthand for elem.css('float', 'right');
     * elem.apply('@transform(scale(5px))'); // shorthand for elem.css('transform', 'scale(5px)');
     * elem.apply('@margin(2px 2px)');       // shorthand for elem.css('margin', '2px 2px');
     * elem.apply('@marginLeft(2px)');       // shorthand for elem.css('marginLeft', '2px 2px');
     * elem.apply('@margin-left(2px)');      // shorthand for elem.css('margin-left', '2px 2px');
     * elem.apply('$attr(some value)');      // shorthand for elem.attr('attr', 'some value');
     * elem.apply('$attr');                  // shorthand for elem.attr('attr', '');
     */

  }, {
    key: 'apply',
    value: function apply() {
      var _this3 = this;

      for (var _len3 = arguments.length, strings = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        strings[_key3] = arguments[_key3];
      }

      var applied = void 0;
      var setApplied = void 0;
      var callback = void 0;
      var name = void 0;
      var np1 = void 0;
      var slice = void 0;

      new Str(new Arr(arguments).join(' ')).split(/(\s+)/).forEach(function (string) {
        if (!applied) {
          np1 = string.slice(0, 1);
          callback = appliedRegExps[np1];
          slice = 1;

          if (callback && !isFunction(callback)) {
            callback = callback[string.slice(1, 2)];
            slice = 2;
          }

          if (/^\s+$/.test(string) || !callback) {
            return;
          }

          name = string.slice(slice).match(/^[^()]+/);

          if (!name && np1 !== '*' && np1 !== '&') {
            return;
          }

          applied = {
            name: name ? name[0] : '',
            args: string.slice(slice + (name ? name[0] : '').length),
            callback: callback
          };

          setApplied = true;
        }

        if (!setApplied) {
          applied.args += string;
        }

        if (!applied.args || /^\([\s\S]+\)$/.test(applied.args)) {
          applied.callback(_this3, applied.name, applied.args.replace(/^\(|\)$/g, ''));
          applied = null;
        }

        setApplied = false;
      });

      return this;
    }

    /**
     * @method Elem#attr
     * @public
     * @param {String|Object.<String, String|ElemValueCallback>} [attr] - Name of the attribute to get or
     * an object of the format { [attrName]: value, ... } to set attributes.
     * @param {String|ElemValueCallback} [value] - If the first argument is a string
     * it should be a value to set for that attribute.
     * @returns {Super|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set
     * returned, if 1 string argument is passed the value of the attribute of the first element in the set
     * returned otherwise returns this.
     * @description Method for getting/setting attributes.
     *
     * @example
     * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned
     * elem.attr('attr1');           // 'value1'
     * elem.attr({
     *   attr1: 'value3',            // attribute attr1 set to 'value3'
     *   attr2: 'value2'             // attribute attr2 set to 'value2'
     * });                           // this returned
     * elem.attr().$;                // { attr1: 'value3', attr2: 'value2' }
     */

  }, {
    key: 'attr',
    value: function attr(_attr, value) {
      var elem = getElem(this);

      if (!arguments.length) {
        return new Super(elem.attributes).object(function (o, attr) {
          o[attr.name] = attr.value;
        });
      }

      if (arguments.length <= 1 && isString(_attr)) {
        var ns = attrNSSwitcher(_attr, [new Elem(elem)]);

        return isNull(ns) ? elem.getAttribute(_attr) : elem.getAttributeNS(ns, _attr);
      }

      if (arguments.length >= 2) {
        _attr = defineProperty({}, _attr, value);
      }

      return this.forEach(function (elem, index) {
        if (!isElement(elem)) {
          return;
        }

        new Super(_attr).forEach(function (value, key) {
          if (isNil(value)) {
            return new Elem(elem).removeAttr(key);
          }

          if (isFunction(value)) {
            value = value(new Elem(elem).attr(key), elem, index);
          }

          if (isNil(value)) {
            return new Elem(elem).removeAttr(key);
          }

          var ns = attrNSSwitcher(key, [new Elem(elem)]);

          if (isNull(ns)) {
            elem.setAttribute(key, value);
          } else {
            elem.setAttributeNS(ns, key, value);
          }
        });
      });
    }

    /**
     * @method Elem#blob
     * @public
     * @param {Object} [options = {}] - Options that are passed into {@link blob}.
     * @returns {Promise.<BlobObject>} New instance of promise.
     * @description Returns a {@link BlobObject} Promise. Works with image or canvas first element.
     *
     * @example
     * image.blob().then((blob) => console.log(blob));  // BlobObject
     * canvas.blob().then((blob) => console.log(blob)); // BlobObject
     */

  }, {
    key: 'blob',
    value: function blob() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new Promise$1(function (resolve, reject) {
        var elem = _this4.first();
        var name = elem.name;


        if (name !== 'img' && name !== 'canvas') {
          reject(new Error('First element in the set isn\'t an image or a canvas! (Elem#blob)'));
        }

        if (name === 'canvas') {
          return resolve(elem);
        }

        elem.load().then(function () {
          if (elem.isBroken()) {
            return reject(new Error('The image is broken! (Elem#blob)'));
          }

          var canvas = new Elem(nativeDocument).canvas();
          var width = elem.width();
          var height = elem.height();

          canvas.width(width).height(height).drawImage(elem.$[0], 0, 0);

          resolve(canvas);
        });
      }).then(function (canvas) {
        var dataURL = canvas.dataURL();
        var byteString = atob(dataURL.split(',')[1]);
        var length = byteString.length;
        var ab = new ArrayBuffer(length);
        var ia = new Uint8Array(ab);

        iterate$1(length, function (i) {
          ia[i] = byteString.charCodeAt(i);
        });

        return blob$1(ab, options);
      });
    }

    /**
     * @method Elem#blur
     * @returns {Elem} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur
     * @description Synonym for
     * [HTMLElement#blur]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur}.
     */

  }, {
    key: 'blur',
    value: function blur() {
      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.blur();
        }
      });
    }

    /**
     * @method Elem#calcCSS
     * @param {String} [pseudo] - See the link.
     * @returns {CSSStyleDeclaration} See the link.
     * @see https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle
     * @description Synonym for
     * [getComputedStyle]{@link https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle}.
     * Returns computed style for the first element in the set or undefined.
     */

  }, {
    key: 'calcCSS',
    value: function calcCSS() {
      var pseudo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return getComputedStyle(getElem(this), pseudo);
    }

    /**
     * @method Elem#changeRule
     * @public
     * @param {String} name - Name of the rule.
     * @param {Object.<String, String>} style - Style for the selector.
     * @returns {Elem} Returns this.
     * @description Method for changing css styles in the first style tag in the set.
     * Note: style element should be inside the document.
     *
     * @example
     * style.changeRule('img-size', {
     *   width: '50px !important',
     *   height: '50px !important'
     * });
     */

  }, {
    key: 'changeRule',
    value: function changeRule(name, style) {
      this.some(function (elem) {
        if (getName(elem) === 'style') {
          var _ref = new Arr(elem.sheet.cssRules).find(function (rule) {
            return rule.dwayneData && rule.dwayneData.name === name;
          }) || {},
              rule = _ref.value;

          if (rule) {
            new Elem(rule).css(style);

            return true;
          }
        }
      });

      return this;
    }

    /**
     * @method Elem#child
     * @public
     * @param {Number|String|Elem|Element|Element[]} element - If the argument is a number a wrap of the set of the children
     * of this index of each element in the set returned otherwise an element to put into this element, a collection
     * or a selector of it.
     * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.
     * @returns {Elem} Returns a wrap of children or inserted elements.
     * @description Method is similar to
     * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.
     *
     * @example
     * const child = elem.child(1);
     *
     * elem.child(elem2);
     * elem.child(document.getElementById('id'));
     * elem.child('#id div.c1');
     */

  }, {
    key: 'child',
    value: function child(element) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (isInteger(element) && element >= 0) {
        return this.children().elem(element);
      }

      return toFind(element).into(this, end);
    }

    /**
     * @method Elem#children
     * @public
     * @returns {Elem} D-Wrap of the children of the first element in the set.
     * @description Method for getting element's children.
     *
     * @example
     * const children = elem.children();
     */

  }, {
    key: 'children',
    value: function children() {
      return new Elem(this.length ? this.$[0].childNodes : []);
    }

    /**
     * @method Elem#class
     * @public
     * @param {String} [cls] - If it's present it has to contain class attribute to set.
     * @returns {Arr|Elem} If the argument is present this returned otherwise a wrap of the classes array returned.
     * @description Method for getting/setting classes.
     *
     * @example
     * elem.class('c1 c2'); // class set to 'c1 c2'
     * elem.class().$;      // ['c1', 'c2']
     */

  }, {
    key: 'class',
    value: function _class(cls) {
      if (!arguments.length) {
        return new Arr(getElem(this).className.split(' '));
      }

      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.className = cls;
        }
      });
    }

    /**
     * @method Elem#click
     * @returns {Elem} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click
     * @description Synonym for
     * [HTMLElement#click]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click}.
     */

  }, {
    key: 'click',
    value: function click$1() {
      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.click();
        }
      });
    }

    /**
     * @method Elem#clone
     * @public
     * @param {Boolean|*} [deep = false] - See thee link.
     * @returns {Elem} New instance of Elem.
     * @see https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode
     * @description Synonym for
     * [Node#cloneNode]{@link https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode}.
     */

  }, {
    key: 'clone',
    value: function clone() {
      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return this.object(function (elems, elem) {
        elems.add(elem.cloneNode(!!deep));
      }, new Elem());
    }

    /**
     * @method Elem#closest
     * @public
     * @param {String} selector - See the link.
     * @returns {Elem} Set of the closest elements.
     * @description Synonym for
     * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.
     */

  }, {
    key: 'closest',
    value: function closest(selector) {
      return this.object(function (elems, elem) {
        while (elem) {
          if (new Elem(elem).is(selector)) {
            return elems.add(elem);
          }

          elem = elem.parentNode;
        }
      }, new Elem());
    }

    /**
     * @method Elem#contains
     * @public
     * @param {String|Elem|Element} element - Element to find out if it's within the first element
     * in the set or a selector of it.
     * @returns {Boolean} Returns if the argument within this element.
     * @description Method is extension for
     * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.
     *
     * @example
     * elem1.contains(elem2);   // true|false
     * elem.contains(selector); // true|false
     */

  }, {
    key: 'contains',
    value: function contains(element) {
      element = toFind(element);

      return getElem(this).contains(getElem(element));
    }

    /**
     * @method Elem#create
     * @public
     * @param {String} type - Type of created element. If type is "#text" a text node is created.
     * If type is "#comment" a comment node is created.
     * @param {...String} appliedExpressions - Strings that are passed into {@link Elem#apply}.
     * @returns {Elem} New instance of Elem - wrap of the created elements.
     * @description Method for creating elements inside this element.
     * If this element is not an Element the element is just created.
     *
     * @example
     * elem.create('div', '#id .c1 .c2 *Some text*');
     *
     * // also there are shorthands for almost every HTML-element
     * elem.div();
     * elem.input('$type(checkbox) $name(country)');
     */

  }, {
    key: 'create',
    value: function create(type) {
      for (var _len4 = arguments.length, appliedExpressions = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        appliedExpressions[_key4 - 1] = arguments[_key4];
      }

      return this.object(function (elems, elem) {
        var element = new Elem(typeSwitcher(type, [new Elem(elem)]));

        element.into(elem);

        elems.add(element.apply.apply(element, appliedExpressions));
      }, new Elem());
    }

    /**
     * @method Elem#createComment
     * @public
     * @param {String} text - Text of the comment.
     * @returns {Elem} New instance of Elem - wrap of the created comments.
     * @description Method for creating comments inside this element.
     * If this element is not an Element the comment is just created.
     *
     * @example
     * elem.createComment('comment');
     */

  }, {
    key: 'createComment',
    value: function createComment(text) {
      return this.create('#comment').text(text);
    }

    /**
     * @method Elem#createText
     * @public
     * @param {String} text - Text.
     * @returns {Elem} New instance of Elem - wrap of the created text nodes.
     * @description Method for creating text nodes inside this element.
     * If this element is not an Element the text node is just created.
     *
     * @example
     * elem.createText('text');
     */

  }, {
    key: 'createText',
    value: function createText(text) {
      return this.create('#text').text(text);
    }

    /**
     * @method Elem#css
     * @public
     * @param {String|Object.<String, String|ElemValueCallback>} [property] - Name of the property to get or
     * an object of the format { [property]: value, ... } to set styles.
     * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that property.
     * @returns {Super|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,
     * if 1 string argument is passed the value of the property returned otherwise returns this.
     * @description Method for getting/setting styles. Supports !important.
     *
     * @example
     * elem.css('display', 'none'); // display set to 'none' and this returned
     * elem.css('display');         // 'none'
     * elem.css({
     *   display: 'inline',         // display set to 'inline'
     *   cursor: 'pointer'          // cursor set to 'pointer'
     * });                          // this returned
     * elem.css().$;                // { display: 'none', cursor: 'pointer' }
     */

  }, {
    key: 'css',
    value: function css(property, value) {
      var style = getElem(this).style;

      if (isStyleRule(this.$[0])) {
        style = this.$[0].style;
      }

      if (!arguments.length) {
        return new Str(style.cssText).split(/; ?/).object(function (o, value) {
          if (value) {
            property = value.split(/: /);

            o[new Str(property[0]).toCamelCase().$] = property[1];
          }
        });
      }

      if (arguments.length <= 1 && isString(property)) {
        property = new Str(property).toHyphenCase().$;

        return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');
      }

      if (arguments.length >= 2) {
        property = defineProperty({}, property, value);
      }

      return this.forEach(function (elem, index) {
        if (!isElement(elem) && !isStyleRule(elem)) {
          return;
        }

        new Super(property).forEach(function (value, property) {
          if (isNil(value)) {
            return new Elem(elem).removeCSS(property);
          }

          property = new Str(property).toHyphenCase().$;

          if (isFunction(value)) {
            value = value(new Elem(elem).css(property), elem, index);
          }

          if (isNil(value)) {
            return new Elem(elem).removeAttr(key);
          }

          elem.style.removeProperty(property);
          elem.style.setProperty(property, value.replace(/ ?!important$/, ''), /!important$/.test(value) ? 'important' : '');
        });
      });
    }

    /**
     * @method Elem#ctx
     * @public
     * @param {String|Object|CtxCallback} [property] - If present and object
     * it's assigned to the canvas rendering context, if function
     * it's called with canvas rendering context argument, if string
     * the value from the second argument is used for assigning
     * this property to canvas rendering context and if not present
     * canvas rendering context returned.
     * @param {*} [value] - See the property argument.
     * @returns {CanvasRenderingContext2D|Elem}
     * @description Rendering context of the first canvas in the set.
     *
     * @example
     * canvas.ctx; // CanvasRenderingContext2D
     */

  }, {
    key: 'ctx',
    value: function ctx(property, value) {
      var ctx = void 0;

      this.some(function (elem) {
        if (getName(elem) === 'canvas') {
          ctx = elem.dwayneData.ctx;

          return true;
        }
      });

      if (!arguments.length) {
        return ctx;
      }

      if (!ctx) {
        return this;
      }

      if (isFunction(property)) {
        property(ctx);
      } else {
        if (arguments.length >= 2) {
          property = defineProperty({}, property, value);
        }

        assign$1(ctx, property);
      }

      return this;
    }

    /**
     * @method Elem#data
     * @public
     * @param {String|Object.<String, String|ElemValueCallback>} [key] - Name of the data attribute (without data- prefix)
     * to get or an object of the format { [attrName]: value, ... } to set attributes.
     * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that attribute.
     * @returns {Super|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,
     * if 1 string argument is passed the value of the data attribute returned otherwise returns this.
     * @description Method for getting/setting data attributes. See
     * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.
     *
     * @example
     * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned
     * elem.data('someKey1');          // 'value1'
     * elem.data({
     *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'
     *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'
     * });                             // this returned
     * elem.data().$;                  // { someKey1: 'value3', someKey2: 'value2' }
     */

  }, {
    key: 'data',
    value: function data(key, value) {
      var dataset = getElem(this).dataset;

      if (!arguments.length) {
        return new Super(dataset).object(function (o, value, key) {
          o[key] = value;
        });
      }

      if (arguments.length === 1 && isString(key)) {
        return dataset[key];
      }

      if (arguments.length >= 2) {
        key = defineProperty({}, key, value);
      }

      return this.forEach(function (elem, index) {
        if (!isElement(elem)) {
          return;
        }

        iterate(key, function (value, key) {
          elem.dataset[key] = isFunction(value) ? value(elem.dataset[key], elem, index) : value;
        });
      });
    }

    /**
     * @method Elem#dataURL
     * @param {String} [type = 'image/png'] - See the link
     * @param {Number} [encoderOptions = 0.92] - See the link.
     * @returns {String} Data URL for the first canvas element in the set.
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL
     * @description Synonym for
     * [HTMLCanvasElement#toDataURL]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL}.
     *
     * @example
     * canvas.dataURL();
     */

  }, {
    key: 'dataURL',
    value: function dataURL(type, encoderOptions) {
      var ctx = this.ctx();

      if (!ctx) {
        return '';
      }

      return ctx.canvas.toDataURL.apply(ctx.canvas, arguments);
    }

    /**
     * @method Elem#deleteRule
     * @public
     * @param {String} name - Name of the rule.
     * @returns {Elem} Returns this.
     * @description Method for deleting css styles in a style tag.
     * Note: style element should be inside the document.
     *
     * @example
     * style.deleteRule('img-size');
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(name) {
      this.some(function (elem) {
        if (getName(elem) === 'style') {
          var rule = new Arr(elem.sheet.cssRules).find(function (rule) {
            return rule.dwayneData && rule.dwayneData.name === name;
          });

          if (rule) {
            elem.sheet.deleteRule(rule.key);

            return true;
          }
        }
      });

      return this;
    }

    /**
     * @method Elem#dispatch
     * @public
     * @param {String|Event} event - Event or a string (new Event(event) is created).
     * @param {Object} [eventInit = {}] - See the link.
     * @param {Boolean} [eventInit.bubbles = true] - See the link.
     * @param {Boolean} [eventInit.cancelable = true] - See the link.
     * @param {Object} [details = {}] - Object that is assigned to the event.
     * @returns {Elem} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event
     * @description Synonym for
     * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.
     *
     * @example
     * elem.dispatch('click');
     * elem.dispatch('click', { bubbles: false, cancellable: false });
     * elem.dispatch(new CustomEvent('custom-event'));
     */

  }, {
    key: 'dispatch',
    value: function dispatch(event) {
      var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _ref2 = eventInit || {},
          _ref2$bubbles = _ref2.bubbles,
          bubbles = _ref2$bubbles === undefined ? true : _ref2$bubbles,
          _ref2$cancelable = _ref2.cancelable,
          cancelable = _ref2$cancelable === undefined ? true : _ref2$cancelable;

      var finalEvent = event;

      if (!/Event$/.test(toStringTag(finalEvent))) {
        try {
          finalEvent = new Event(finalEvent, { bubbles: bubbles, cancelable: cancelable });
        } catch (err) {
          finalEvent = nativeDocument.createEvent('Event');
          finalEvent.initEvent(event, bubbles, cancelable);
        }

        assign$1(finalEvent, details);
      }

      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.dispatchEvent(finalEvent);
        }
      });
    }

    /**
     * @method Elem#elem
     * @public
     * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.
     * @returns {Elem} New instance of Elem.
     *
     * @example
     * elem.elem(1); // a wrap of the element in the set that has index 1
     * elem.elem();  // a wrap of the element in the set that has index 0
     */

  }, {
    key: 'elem',
    value: function elem() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (index < 0) {
        index = this.length + index;
      }

      return new Elem(this.$[index]);
    }

    /**
     * @method Elem#filter
     * @public
     * @param {String|Function|Element[]|Elem} [selector = Boolean] - If it's a string the method filters elements with the selector
     * otherwise super.filter is called.
     * @returns {Elem} New instance of Elem.
     * @description Method for filtering elements.
     *
     * @example
     * elem.filter((elem) => new Elem(elem).closest('.parent'));
     * elem.filter(elemsInArray);
     * elem.filter(elemsInElem);
     * elem.filter('.child');
     */

  }, {
    key: 'filter',
    value: function filter() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;

      return new Elem(get$1(Elem.prototype.__proto__ || Object.getPrototypeOf(Elem.prototype), 'filter', this).call(this, filterSwitcher(selector)));
    }

    /**
     * @method Elem#find
     * @public
     * @param {String|Function} selector - Selector to find.
     * @returns {Elem|{ key: Key, value: * }|null} New instance of Elem if selector is a string
     * otherwise super.find is called.
     * @description Synonym for
     * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.
     */

  }, {
    key: 'find',
    value: function find(selector) {
      if (!isString(selector)) {
        return get$1(Elem.prototype.__proto__ || Object.getPrototypeOf(Elem.prototype), 'find', this).call(this, selector);
      }

      return this.object(function (elems, elem) {
        elems.add(_find(selector, elem));
      }, new Elem());
    }

    /**
     * @method Elem#first
     * @public
     * @returns {Elem} New instance of Elem.
     * @description Synonym for elem.elem(0).
     */

  }, {
    key: 'first',
    value: function first() {
      return this.elem(0);
    }

    /**
     * @method Elem#firstChild
     * @public
     * @param {String} [selector = null] - If present, finds first child in every elem that matches the selector.
     * If not, finds first child of each element in the set.
     * @returns {Elem} New instance of Elem.
     * @description Method for finding first children of each element in the set.
     *
     * @example
     * elem.first();       // finds first child of each element in the elem set
     * elem.first('.foo'); // find first child that has foo class of each element in the set
     */

  }, {
    key: 'firstChild',
    value: function firstChild() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return this.object(function (elems, elem) {
        var _ref3 = new Elem(elem).children().find(function (elem) {
          return new Elem(elem).is(selector);
        }) || {},
            found = _ref3.value;

        elems.add(found);
      }, new Elem());
    }

    /**
     * @method Elem#focus
     * @returns {Elem} Returns this.
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus
     * @description Synonym for
     * [HTMLElement#focus]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus}.
     */

  }, {
    key: 'focus',
    value: function focus() {
      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.focus();
        }
      });
    }

    /**
     * @method Elem#getRule
     * @public
     * @param {String} name - Name of the rule.
     * @returns {{ selector: (String|void), rules: Object }} Set of the css rules.
     * @description Method for getting set of the rules under the name.
     * Note: style element should be inside the document.
     *
     * @example
     * style.addRule('img-size', 'img.square', {
     *   width: '40px',
     *   height: '40px'
     * });
     * style.getRule('img-size');
     * // {
     * //   selector: 'img.square',
     * //   rules: {
     * //     width: '40px',
     * //     height: '40px'
     * //   }
     * // }
     */

  }, {
    key: 'getRule',
    value: function getRule(name) {
      var found = {
        selector: undefined,
        rules: {}
      };

      this.some(function (elem) {
        if (getName(elem) === 'style') {
          var _ref4 = new Arr(elem.sheet.cssRules).find(function (rule) {
            return rule.dwayneData && rule.dwayneData.name === name;
          }) || {},
              rule = _ref4.value;

          if (rule) {
            found = {
              selector: rule.selectorText,
              rules: new Elem(rule).css().$
            };

            return true;
          }
        }
      });

      return found;
    }

    /**
     * @method Elem#hasAttr
     * @public
     * @param {String} attr - Name of the attribute.
     * @returns {Boolean} If the first element in the set has the attribute.
     * @description Method that returns if the first element in the set has the attribute or not.
     *
     * @example
     * elem.attr('attr', 'value').hasAttr('attr'); // true
     * elem.removeAttr('attr').hasAttr('attr');    // false
     */

  }, {
    key: 'hasAttr',
    value: function hasAttr(attr) {
      var elem = getElem(this);
      var ns = attrNSSwitcher(attr, [new Elem(elem)]);

      return isNull(ns) ? elem.hasAttribute(attr) : elem.hasAttributeNS(ns, attr);
    }

    /**
     * @method Elem#hasClass
     * @public
     * @param {String} cls - Name of the class.
     * @returns {Boolean} If the first element in the set has the class.
     * @description Method that returns if the first element in the set has the class or not.
     *
     * @example
     * elem.addClass('cls').hasClass('cls');    // true
     * elem.removeClass('cls').hasClass('cls'); // false
     */

  }, {
    key: 'hasClass',
    value: function hasClass(cls) {
      return getElem(this).classList.contains(cls);
    }

    /**
     * @method Elem#height
     * @public
     * @param {*|ElemValueCallback} [height] - Height to set.
     * @returns {Elem|String} If no arguments passed height of the first element in the set returned.
     * Otherwise all elements heights in the set are set to the height argument.
     * @description Gets or sets height.
     *
     * @example
     * elem.height(123);
     * elem.height(); // 123
     */

  }, {
    key: 'height',
    value: function height(_height) {
      return this.prop.apply(this, new Arr(arguments).unshift('height').$);
    }

    /**
     * @method Elem#hide
     * @public
     * @returns {Elem} Returns this.
     * @description Hides all elements in the set.
     *
     * @example
     * elem.hide();
     */

  }, {
    key: 'hide',
    value: function hide() {
      return this.forEach(function (elem) {
        elem = new Elem(elem);

        var currentDisplay = elem.css('display');

        if (currentDisplay.indexOf('none')) {
          elem.prop('dwayneData').previousDisplay = currentDisplay;
        }

        elem.css('display', 'none !important');
      });
    }

    /**
     * @method Elem#html
     * @public
     * @param {String|ElemValueCallback|*} [html] - HTML to write instead of current HTML.
     * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.
     * Otherwise all elements HTML in the set are set to the html argument.
     * @description Gets or sets HTML.
     *
     * @example
     * elem.html('<div>1</div>');
     * elem.html(); // '<div>1</div>'
     */

  }, {
    key: 'html',
    value: function html(_html) {
      if (!arguments.length) {
        return getElem(this).innerHTML;
      }

      return this.forEach(function (elem, index) {
        if (isElement(elem)) {
          elem.innerHTML = isFunction(_html) ? _html(elem.innerHTML, elem, index) : _html;
        }
      });
    }

    /**
     * @method Elem#id
     * @public
     * @param {String|*} [id] - Id to set.
     * @returns {Elem|String} If no arguments passed id of the first element in the set returned.
     * Otherwise all elements ids in the set are set to the id argument.
     * @description Gets id or sets ids.
     *
     * @example
     * elem.id('unique');
     * elem.id(); // 'unique'
     */

  }, {
    key: 'id',
    value: function id(_id) {
      if (!arguments.length) {
        return getElem(this).id;
      }

      return this.forEach(function (elem) {
        if (isElement(elem)) {
          elem.id = _id;
        }
      });
    }

    /**
     * @member {Number} Elem#innerHeight
     * @type {Number}
     * @public
     * @readonly
     * @description Getter for finding how much height content of the first element can be.
     *
     * @example
     * elem.css({
     *   boxSizing: 'border-box',
     *   height: '200px',
     *   paddingTop: '2px',
     *   paddingBottom: '3px',
     *   borderTop: '1px solid black',
     *   borderBottom: '4px solid black'
     * }).innerHeight; // 190
     * elem
     *   .css('box-sizing', 'content-box')
     *   .innerHeight; // 200
     * elem
     *   .css('box-sizing', 'padding-box')
     *   .innerHeight; // 195
     */

  }, {
    key: 'insertAfter',


    /**
     * @method Elem#insertAfter
     * @public
     * @param {String|Elem|Element} element - Element to insert this element after or a selector of it.
     * @returns {Elem} Returns this.
     * @description Puts the elements from the set after the element specified by the argument.
     * The elements remain in the same order.
     *
     * @example
     * elem.insertAfter(elem2);
     * elem.insertAfter(document.getElementById('id'));
     * elem.insertAfter('#id div.c1');
     */
    value: function insertAfter(element) {
      element = toFind(element).first();

      var parent = element.parent();

      if (!parent.length) {
        return this;
      }

      element = element.next().$[0];
      parent = parent.$[0];

      return this.forEach(function (elem) {
        if (element) {
          parent.insertBefore(elem, element);
        } else {
          parent.appendChild(elem);
        }
      });
    }

    /**
     * @method Elem#insertBefore
     * @public
     * @param {String|Elem|Element} element - Element to insert this element before or a selector of it.
     * @returns {Elem} Returns this.
     * @description Puts the elements from the set before the element specified by the argument.
     * The elements remain in the same order.
     *
     * @example
     * elem.insertBefore(elem2);
     * elem.insertBefore(document.getElementById('id'));
     * elem.insertBefore('#id div.c1');
     */

  }, {
    key: 'insertBefore',
    value: function insertBefore(element) {
      element = toFind(element).first();

      var parent = element.parent();

      if (!parent.length) {
        return this;
      }

      element = element.$[0];
      parent = parent.$[0];

      return this.forEach(function (elem) {
        parent.insertBefore(elem, element);
      });
    }

    /**
     * @method Elem#into
     * @public
     * @param {String|Elem|Element} element - Element to put this elements into or a selector of it.
     * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.
     * @returns {Elem} Returns this.
     * @description Method is similar to
     * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.
     *
     * @example
     * elem.into(elem2);
     * elem.into(document.getElementById('id'));
     * elem.into('#id div.c1');
     */

  }, {
    key: 'into',
    value: function into(element) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      element = toFind(element).$[0];

      if (!element || isWindow(element) || isHTMLDocument(element) || isCommentOrText(element)) {
        return this;
      }

      if (!end && element.firstChild) {
        return this.slice().reverse().forEach(function (elem) {
          element.insertBefore(elem, element.firstChild);
        });
      }

      return this.forEach(function (elem) {
        element.appendChild(elem);
      });
    }

    /**
     * @method Elem#is
     * @public
     * @param {String} selector
     * @returns {Boolean} If the first element in the set matches the selector.
     * If the selector is undefined or null always returns true. If it's not for not elements
     * entries returns false.
     * @description Synonym for
     * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.
     *
     * @example
     * elem.addClass('cls');
     * elem.is('.cls');         // true
     *
     * elem.removeClass('cls');
     * elem.is('.cls');         // false
     */

  }, {
    key: 'is',
    value: function is(selector) {
      if (isNull(selector)) {
        return true;
      }

      var elem = getElem(this);
      var matches = elem.matches || elem.matchesSelector || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector || elem.oMatchesSelector;

      if (!isElement(this.$[0])) {
        return false;
      }

      try {
        return matches.call(elem, selector);
      } catch (err) {
        console.error('Selector \'' + selector + '\' is not a valid selector (Elem#is)');

        return false;
      }
    }

    /**
     * @method Elem#isBroken
     * @public
     * @returns {Boolean} If the first image in the set is broken.
     * @description Returns if the first element in the set is broken. Not image and not loaded image is considered proper.
     *
     * @example
     * const img = elem.img().on({
     *   'load': onload,
     *   'error': onload
     * });
     *
     * onload = () => {
     *   console.log(img.isBroken()); // true
     * };
     *
     * img.ref('/some/non-existent/site/not-found.png');
     */

  }, {
    key: 'isBroken',
    value: function isBroken() {
      var isBroken = false;

      this.some(function (elem) {
        if (getName(elem) === 'img') {
          isBroken = !!(elem.complete && (!elem.naturalWidth || !elem.naturalHeight));

          return true;
        }
      });

      return isBroken;
    }

    /**
     * @method Elem#isWithinDocument
     * @public
     * @returns {Boolean} Returns if the first element in the set is within the document or not.
     * @description Returns if the first element in the set is within the document or not.
     *
     * @example
     * new Elem(document.body).isWithinDocument();  // true
     * new Elem(document).div().isWithinDocument(); // false
     */

  }, {
    key: 'isWithinDocument',
    value: function isWithinDocument() {
      return this.first().closest('html').length !== 0;
    }

    /**
     * @method Elem#last
     * @public
     * @returns {Elem} New instance of Elem.
     * @description Synonym for elem.elem(-1).
     */

  }, {
    key: 'last',
    value: function last() {
      return this.elem(-1);
    }

    /**
     * @method Elem#lastChild
     * @public
     * @param {String} [selector = null] - If present, finds last child in every elem that matches the selector.
     * If not, finds last child of each element in the set.
     * @returns {Elem} New instance of Elem.
     * @description Method for finding last children of each element in the set.
     *
     * @example
     * elem.last();       // finds last child of each element in the elem set
     * elem.last('.foo'); // find last child that has 'foo' class of each element in the set
     */

  }, {
    key: 'lastChild',
    value: function lastChild() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return this.object(function (elems, elem) {
        var _ref5 = new Elem(elem).children().reverse().find(function (elem) {
          return new Elem(elem).is(selector);
        }) || {},
            found = _ref5.value;

        elems.add(found);
      }, new Elem());
    }

    /**
     * @method Elem#load
     * @public
     * @returns {Promise.<{ proper: Elem, broken: Elem }>} Promise with broken and proper images.
     * @description Loads each image in the set and puts it to the proper or broken array.
     *
     * @example
     * images.load().then(({ broken }) => {
     *   broken.filter('img').ref('/fallback.png');
     * });
     */

  }, {
    key: 'load',
    value: function load() {
      var images = {
        proper: new Elem(),
        broken: new Elem()
      };

      return Promise$1.all(this.filter(function (elem) {
        return getName(elem) === 'img';
      }).map(function (elem) {
        var $elem = new Elem(elem);

        if (elem.complete) {
          images[$elem.isBroken() ? 'broken' : 'proper'].push(elem);

          return;
        }

        return new Promise$1(function (resolve) {
          var removeListeners = $elem.on({
            load: function load() {
              images.proper.add(elem);

              removeListeners();
              resolve();
            },
            error: function error() {
              images.broken.add(elem);

              removeListeners();
              resolve();
            }
          });
        });
      }).$).then(function () {
        return images;
      });
    }

    /**
     * @method Elem#moveAttr
     * @public
     * @param {String} attr - Attribute to move to the first element.
     * @param {String} [value = ''] - Value to set for the attribute. If not set attribute of the previous element or '' used.
     * @returns {Elem} Returns this.
     * @description Method for moving an attribute from previous element to the next one (first element in this set).
     *
     * @example
     * elem1.moveAttr('attr', 'value');     // attribute 'attr' set to 'value' on elem1
     * elem2.moveAttr('attr');              // attribute 'attr' removed from elem1. set to 'value' on elem2
     * elem3.moveAttr('attr', 'new value'); // attribute 'attr' removed from elem2. set to 'new value' on elem3
     */

  }, {
    key: 'moveAttr',
    value: function moveAttr(attr) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var prev = attrs[attr];
      var elem = this.elem();

      if (prev && elem.length) {
        if (arguments.length < 2) {
          value = prev.attr(attr);
        }

        prev.removeAttr(attr);
      }

      if (elem.length) {
        attrs[attr] = elem.attr(attr, value);
      }

      return this;
    }

    /**
     * @method Elem#moveClass
     * @public
     * @param {String} cls - Class to move to the first element.
     * @returns {Elem} Returns this.
     * @description Method for moving a class from previous element to the next one (first element in this set).
     *
     * @example
     * elem1.moveClass('cls'); // class 'cls' added to elem1
     * elem2.moveClass('cls'); // class 'cls' removed from elem1. added to elem1
     */

  }, {
    key: 'moveClass',
    value: function moveClass(cls) {
      var prev = classes[cls];
      var elem = this.elem();

      if (prev && elem.length) {
        prev.removeClass(cls);
      }

      if (elem.length) {
        classes[cls] = elem.addClass(cls);
      }

      return this;
    }

    /**
     * @member {String} Elem#name
     * @type {String}
     * @public
     * @readonly
     * @description nodeName (lowercased) of the first element in the set.
     *
     * @example
     * const elem1 = elem.create('div');
     * elem1.name // 'div'
     */

  }, {
    key: 'next',


    /**
     * @method Elem#next
     * @public
     * @param {String} [selector = null] - If present, finds next element to every elem that matches the selector.
     * If not, finds next element to each element in the set.
     * @returns {Elem} New instance of Elem.
     * @description Method for finding next element to each element in the set.
     *
     * @example
     * elem.next();       // finds next element to each element in the set
     * elem.next('.foo'); // finds next element to each element that has 'foo' class
     */
    value: function next() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return this.object(function (elems, elem) {
        /* eslint no-cond-assign: 0 */
        while (elem = elem.nextSibling) {
          if (new Elem(elem).is(selector)) {
            return elems.add(elem);
          }
        }
      }, new Elem());
    }

    /**
     * @method Elem#off
     * @public
     * @param {...ElemEventString} events - Events to remove.
     * @returns {Elem} Returns this.
     * @description Method that removes all the listeners from each element in the set specified by the events arguments.
     *
     * @example
     * elem.off('click');
     * elem.off('click, input');
     * elem.off('click, input', 'focus');
     */

  }, {
    key: 'off',
    value: function off() {
      var _arguments2 = arguments;

      for (var _len5 = arguments.length, events = Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
        events[_key6] = arguments[_key6];
      }

      return this.forEach(function (elem) {
        var listeners = elem.dwayneData.listeners;


        iterate(_arguments2, function (event) {
          iterate(event.split(eventSeparator), function (event) {
            (listeners[event] || new Super()).forEach(function (_ref6) {
              var removeListener = _ref6.removeListener;
              return removeListener();
            });
          });
        });
      });
    }

    /**
     * @method Elem#on
     * @public
     * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string
     * or an object with event keys (a key is also ElemEventString) and listeners values.
     * @param {String} [selector = null] - Selector to filter event targets.
     * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for
     * specified event(s).
     * @returns {ElemRemoveListeners} Function that takes optional event argument.
     * @description Adds event listeners for all the elements in the set.
     * For debugging: If you need to know what listeners are in work (and what selectors filter targets)
     * you can look at the base property of the only dwayne listener that listens for the event
     * and find all working listeners in listener.base.dwayneData.listeners[event].$.
     *
     * @example
     * elem.on(
     *   'change, input',
     *   'input, select, textarea, datalist, keygen, output',
     *   (e, elem, index) => console.log(elem.value)
     * );
     * elem.on(
     *   'change, input',
     *   (e, elem, index) => console.log(elem.value)
     * );
     * elem.on(
     *   {
     *     'change, input': (e, elem, index) => console.log(elem.value),
     *     'blur': () => console.log('blur')
     *   },
     *   'input, select, textarea, datalist, keygen, output'
     * );
     *
     * const removeListeners = elem.on({
     *   'change, input': (e, elem, index) => console.log(elem.value),
     *   'blur': () => console.log('blur')
     * });
     *
     * removeListeners('click');
     * removeListeners('blur, change');
     * removeListeners('blur, change', 'input');
     * removeListeners();
     */

  }, {
    key: 'on',
    value: function on(event) {
      var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var listener = arguments[2];

      var allListeners = new Super({});

      if (isFunction(selector)) {
        listener = selector;
        selector = null;
      }

      if (isString(event)) {
        event = defineProperty({}, event, listener);
      }

      event = new Super(event).object(function (listeners, listener, event) {
        iterate(event.split(eventSeparator), function (event) {
          listeners[event] = listener;
        });
      });

      this.forEach(function (elem) {
        if (!isElement(elem) && !isWindow(elem) && !isHTMLDocument(elem)) {
          return;
        }

        var _ref7 = (windowsDwayneData.find(function (_ref8) {
          var element = _ref8.element;
          return element === elem;
        }) || {}).value || elem.dwayneData,
            listeners = _ref7.listeners;

        event.forEach(function (listener, event) {
          var removeEventListeners = listeners[event] = listeners[event] || new Super({}).define('index', {
            value: 0,
            configurable: true,
            writable: true
          });
          var index = removeEventListeners.prop('index');

          if (!removeEventListeners.has('listener')) {
            var newListener = function newListener(e) {
              removeEventListeners.forEach(function (_ref9) {
                var selector = _ref9.selector,
                    listener = _ref9.listener;

                if (new Elem(e.target).is(selector)) {
                  listener.call(elem, e, elem, index);
                }
              });
            };

            newListener.base = elem;

            elem.addEventListener(event, newListener, false);
            removeEventListeners.define('listener', {
              value: newListener,
              configurable: true,
              writable: true
            });
          }

          var removeListener = function removeListener() {
            removeEventListeners.delete(index);

            if (!removeEventListeners.count) {
              elem.removeEventListener(event, removeEventListeners.prop('listener'), false);
              removeEventListeners.delete('listener');
            }
          };

          allListeners.prop(event, (allListeners.prop(event) || new Arr()).push(removeListener));

          removeEventListeners.assign(defineProperty({
            index: index + 1
          }, index, {
            selector: selector,
            listener: listener,
            removeListener: removeListener
          }));
        });
      });

      return function removeEventListeners(event) {
        if (arguments.length) {
          iterate(arguments, function (event) {
            iterate(event.split(eventSeparator), function (event) {
              if (allListeners.has(event)) {
                allListeners.prop(event).forEach(function (removeListener) {
                  return removeListener();
                });
                allListeners.delete(event);
              }
            });
          });

          return;
        }

        allListeners.forEach(function (removeListeners) {
          removeListeners.forEach(function (removeListener) {
            return removeListener();
          });
        });
      };
    }

    /**
     * @member {Number} Elem#outerHeight
     * @type {Number}
     * @public
     * @readonly
     * @description Getter for finding how much height the element actually is.
     *
     * @example
     * elem.css({
     *   boxSizing: 'border-box',
     *   height: '200px',
     *   paddingTop: '2px',
     *   paddingBottom: '3px',
     *   borderTop: '1px solid black',
     *   borderBottom: '4px solid black'
     *   marginTop: '0px',
     *   marginBottom: '5px'
     * }).outerHeight; // 205
     * elem
     *   .css('box-sizing', 'content-box')
     *   .outerHeight; // 215
     * elem
     *   .css('box-sizing', 'padding-box')
     *   .outerHeight; // 210
     */

  }, {
    key: 'parent',


    /**
     * @method Elem#parent
     * @public
     * @returns {Elem} New instance of Elem.
     * @description Method returns wrap of the set of the parent elements of each element in the set.
     */
    value: function parent() {
      return this.object(function (elems, elem) {
        return elems.add(elem.parentNode);
      }, new Elem());
    }

    /**
     * @method Elem#parentTree
     * @public
     * @returns {Elem} New instance of Elem.
     * @description Returns wrap of all parents of each element in the set.
     *
     * @example
     * elem.parentTree(); // Elem
     */

  }, {
    key: 'parentTree',
    value: function parentTree() {
      return this.object(function (elems, elem) {
        while (elem = elem.parentNode) {
          elems.add(elem);
        }
      }, new Elem());
    }

    /**
     * @method Elem#prev
     * @public
     * @param {String} [selector = null] - If present, finds previous element to every elem that matches the selector.
     * If not, finds previous element to each element in the set.
     * @returns {Elem} New instance of Elem.
     * @description Method for finding previous element to each element in the set.
     *
     * @example
     * elem.next();       // finds previous element to each element in the set
     * elem.next('.foo'); // finds previous element to each element that has 'foo' class
     */

  }, {
    key: 'prev',
    value: function prev() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return this.object(function (elems, elem) {
        /* eslint no-cond-assign: 0 */
        while (elem = elem.previousSibling) {
          if (new Elem(elem).is(selector)) {
            return elems.add(elem);
          }
        }
      }, new Elem());
    }

    /**
     * @method Elem#prop
     * @public
     * @param {String|Object.<String, ElemValueCallback|*>} property - Either a string of a property or an assigned object.
     * @param {ElemValueCallback|*} [value] - If a property parameter is a string
     * this has to be an assigned value if it's present.
     * @returns {Elem|*} Returns this if it's setter or a value if getter.
     * @description Method that is either a property getter for the first element in the set
     * or a setter for every element in the set.
     *
     * @example
     * elem.prop('draggable', false);
     * elem.prop('draggable'); // false
     */

  }, {
    key: 'prop',
    value: function prop(property, value) {
      if (arguments.length <= 1 && isString(property)) {
        return this.$[0] ? this.$[0][property] : undefined;
      }

      if (arguments.length >= 2) {
        property = defineProperty({}, property, value);
      }

      return this.forEach(function (elem, index) {
        iterate(property, function (value, prop$$1) {
          elem[prop$$1] = isFunction(value) ? value(elem[prop$$1], elem, index) : value;
        });
      });
    }

    /**
     * @method Elem#ref
     * @public
     * @param {String|ElemValueCallback} [link] - If it's present link to a resource.
     * @returns {Elem|String} If the link argument isn't present it's a getter of the 'src' attribute
     * for the one of following elements: img, script, iframe, audio, video; of the 'action' attribute
     * for a form element and of the 'href' attribute for the rest. If it's present it's a setter
     * of the same attribute for all the element in the set.
     * @description Method for getting resources links and setting them.
     *
     * @example
     * elem.ref('/some/cool/image.png');
     * elem.ref(); // '/some/cool/image.png'
     */

  }, {
    key: 'ref',
    value: function ref(link) {
      if (!arguments.length) {
        return this.attr(refSwitcher(this.name));
      }

      return this.forEach(function (elem) {
        elem = new Elem(elem);

        elem.attr(refSwitcher(elem.name), link);
      });
    }

    /**
     * @method Elem#remove
     * @public
     * @returns {Elem} Returns this.
     * @description Removes all the elements from the set from the document.
     * Note: it doesn't remove them from the set so watch out for the memory leaks.
     *
     * @example
     * elem.remove();
     */

  }, {
    key: 'remove',
    value: function remove() {
      return this.forEach(function (elem) {
        var parent = elem.parentNode;

        if (parent) {
          parent.removeChild(elem);
        }
      });
    }

    /**
     * @method Elem#removeAttr
     * @public
     * @param {...String} attributes - Attributes to remove.
     * @returns {Elem} Returns this.
     * @description Removes all the attributes from arguments from all the elements in the set.
     *
     * @example
     * elem.removeAttr('foo', 'bar', 'baz');
     */

  }, {
    key: 'removeAttr',
    value: function removeAttr() {
      var _arguments3 = arguments;

      for (var _len6 = arguments.length, attributes = Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
        attributes[_key7] = arguments[_key7];
      }

      return this.forEach(function (elem) {
        if (!isElement(elem)) {
          return;
        }

        iterate(_arguments3, function (attr) {
          var ns = attrNSSwitcher(attr, [new Elem(elem)]);

          if (isNull(ns)) {
            elem.removeAttribute(attr);
          } else {
            elem.removeAttributeNS(ns, attr);
          }
        });
      });
    }

    /**
     * @method Elem#removeClass
     * @public
     * @param {...String} classes - Classes to remove.
     * @returns {Elem} Returns this.
     * @description Removes all the classes from arguments from all the elements in the set.
     *
     * @example
     * elem.removeClass('foo', 'bar', 'baz');
     */

  }, {
    key: 'removeClass',
    value: function removeClass() {
      var _arguments4 = arguments;

      for (var _len7 = arguments.length, classes = Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
        classes[_key8] = arguments[_key8];
      }

      return this.forEach(function (elem) {
        var list = elem.classList;

        iterate(isElement(elem) && _arguments4, function (cls) {
          return list.remove(cls);
        });
      });
    }

    /**
     * @method Elem#removeCSS
     * @public
     * @param {...String} props - CSS properties to remove.
     * @returns {Elem} Returns this.
     * @description Removes all the CSS properties from arguments from all the elements in the set.
     *
     * @example
     * elem.removeCSS('display', 'position', 'margin');
     */

  }, {
    key: 'removeCSS',
    value: function removeCSS() {
      var _arguments5 = arguments;

      for (var _len8 = arguments.length, props = Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {
        props[_key9] = arguments[_key9];
      }

      return this.forEach(function (elem) {
        if (!isElement(elem)) {
          return;
        }

        iterate(_arguments5, function (css) {
          elem.style.removeProperty(css);
        });
      });
    }

    /**
     * @method Elem#replace
     * @public
     * @param {String|Elem|Element} element - Element to replace the first element in the set
     * with a set of elements specified by the argument (Element, set of elements or a selector of them).
     * @returns {Elem} Returns this.
     * @description Method is similar to
     * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.
     *
     * @example
     * elem.replace(elem2);
     * elem.replace(document.getElementById('id'));
     * elem.replace('#id div.c1');
     */

  }, {
    key: 'replace',
    value: function replace(element) {
      element = toFind(element);

      var parent = this.first().parent();

      if (!parent.length) {
        return this;
      }

      var elem = parent;
      var method$$1 = 'into';
      var next = this.next().first().$[0];
      var prev = this.prev().first().$[0];

      if (next) {
        elem = next;
        method$$1 = 'insertBefore';
      } else if (prev) {
        elem = prev;
        method$$1 = 'insertAfter';
      }

      this.first().remove();

      element[method$$1](elem);
    }

    /**
     * @method Elem#setOf
     * @public
     * @param {String} type - HTML element type.
     * @param {Number|Object|Array.<*>} iterator - A number (how many elements to create inside each element),
     * an object or an array to iterate over.
     * @param {ElemSetOfCallback} callback
     * @returns {Elem} New instance of Elem.
     * @description Function for creating set of elements inside each element in the set based on an array or an object.
     *
     * @example
     * table.setOf('tr', [[1, 2], [3, 4], [5, 6]], (row, array) => {
     *   D(row).setOf('td', array, (col, number) => {
     *     D(col).text(number);
     *   });
     * });
     */

  }, {
    key: 'setOf',
    value: function setOf(type, iterator, callback) {
      validate$1({ 2: callback }, { 2: ['function'] }, 'Elem#setOf');

      iterator = new Super(iterator).$;

      if (isNumber(iterator)) {
        try {
          validate$1({ 1: iterator }, { 1: ['intLike', '>=0'] }, 'Elem#setOf');
        } catch (e) {
          throw new Error('2nd argument must be either or non-negative integer, or object! (at Elem#setOf)');
        }

        iterator = array(iterator).$;
      }

      return this.object(function (elems, elem, index) {
        iterate(iterator, function (value, key) {
          var created = new Elem(elem).create(type);

          callback(created.$[0], value, key, iterator, elem, index);

          elems.add(created);
        });
      }, new Elem());
    }

    /**
     * @method Elem#show
     * @public
     * @returns {Elem} Returns this.
     * @description Shows all elements in the set.
     * If an element was hidden using {@link Elem#hide} previous display is set.
     *
     * @example
     * elem.show();
     */

  }, {
    key: 'show',
    value: function show() {
      return this.forEach(function (elem) {
        var _elem = elem,
            dwayneData = _elem.dwayneData;


        elem = new Elem(elem);

        if (elem.css('display').indexOf('none') === 0) {
          elem.css('display', dwayneData.previousDisplay);
        }

        dwayneData.previousDisplay = '';
      });
    }

    /**
     * @method Elem#text
     * @public
     * @param {String|ElemValueCallback|*} [text] - Text to write instead of current text.
     * @returns {Elem|String} If no arguments passed text of the first element in the set returned.
     * Otherwise all elements texts in the set are set to the text argument.
     * @description Gets or sets text.
     *
     * @example
     * elem.text('123');
     * elem.text(); // '123'
     */

  }, {
    key: 'text',
    value: function text(_text) {
      if (!arguments.length) {
        return this.prop(textProperty);
      }

      return this.forEach(function (elem, index) {
        var txt = elem[textProperty];

        new Elem(elem).prop(textProperty, isFunction(_text) ? _text(txt, elem, index) : _text);
      });
    }

    /**
     * @method Elem#toggleAttr
     * @public
     * @param {String} attr - Attribute to toggle.
     * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute
     * with the '' value and if falsey method removes the attribute. If not present method adds
     * the attribute if it doesn't exist and removes if it does.
     * @returns {Elem} Returns this.
     * @description Method for toggling attributes.
     *
     * @example
     * elem.toggleAttr('attr');
     * elem.toggleAttr('attr', someCondition);
     */

  }, {
    key: 'toggleAttr',
    value: function toggleAttr(attr, condition) {
      var _arguments6 = arguments;

      return this.forEach(function (elem) {
        elem = new Elem(elem);

        if (_arguments6.length < 2 ? !elem.hasAttr(attr) : condition) {
          elem.attr(attr, '');
        } else {
          elem.removeAttr(attr);
        }
      });
    }

    /**
     * @method Elem#toggleAttr
     * @public
     * @param {String} cls - Class to toggle.
     * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class
     * and if falsey method removes the class. If not present method adds
     * the class if it doesn't exist and removes if it does.
     * @returns {Elem} Returns this.
     * @description Method for toggling classes.
     *
     * @example
     * elem.toggleClass('cls');
     * elem.toggleClass('cls', someCondition);
     */

  }, {
    key: 'toggleClass',
    value: function toggleClass(cls, condition) {
      return (arguments.length < 2 ? !this.hasClass(cls) : condition) ? this.addClass(cls) : this.removeClass(cls);
    }
  }, {
    key: 'up',


    /**
     * @method Elem#up
     * @public
     * @param {Integer} [level = 1] - What level up along the tree should be the parent.
     * @returns {Elem} New instance of Elem.
     * @description Creates a collection of parents of level &lt;level&gt;.
     *
     * @example
     * elem.up();
     * elem.up(2);
     */
    value: function up() {
      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      validate$1([level], [['intLike', '>=0']], 'Elem#up');

      level = Number(level);

      return this.object(function (elems, elem) {
        var n = level;

        while (n-- && elem) {
          elem = elem.parentNode;
        }

        elems.add(elem);
      }, new Elem());
    }

    /**
     * @method Elem#validate
     * @public
     * @param {ValidateCallback} [validator] - If present, function that validates inputs.
     * @returns {Elem|Object.<String, Error|*>|null}
     * If a callback argument provided returns this. If no arguments provided returns either an object
     * with input names keys and errors values or null if no errors found.
     * @description If a callback argument provided adds it to the element validators list.
     * If no arguments provided validates every input element in the set with its own functions.
     * If an element is a form it validates all input elements inside it. After the validation
     * fires 'validate' event with 'valid' and 'error' (if form it's errors) properties.
     *
     * @example
     * form.on('input change', 'input', (value, input) => {
     *   input = D(input);
     *
     *   if (Number(value) % 3) {
     *     input.addClass('invalid');
     *
     *     throw new Error('The value should be divided by 3!');
     *   }
     *
     *   input.removeClass('invalid');
     * });
     */

  }, {
    key: 'validate',
    value: function validate(validator) {
      validate$1([validator], ['function||!'], 'Elem#validate');

      if (validator) {
        return this.forEach(function (_ref10) {
          var dwayneData = _ref10.dwayneData;

          dwayneData.validators.push(validator);
        });
      }

      var errors = new Super({ errors: null });

      this.filter(inputElements + ', form').forEach(function (elem, index) {
        if (getName(elem) === 'form') {
          var _ret = function () {
            var formErrors = { errors: null };
            var form = new Elem(elem);
            var inputs = form.find(inputElements);

            inputs.forEach(function (input, index) {
              validatorWrap(input, index, formErrors);
            });

            errors.deepAssign(formErrors);

            formErrors = formErrors.errors;

            form.dispatch('validate', {}, {
              valid: !formErrors,
              errors: formErrors
            });

            return {
              v: inputs.forEach(function (input) {
                var inputError = (formErrors || {})[input.name];

                new Elem(input).dispatch('validate', {}, {
                  valid: !inputError,
                  error: inputError || null
                });
              })
            };
          }();

          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }

        var inputError = { errors: null };

        validatorWrap(elem, index, inputError);
        errors.deepAssign(inputError);

        inputError = (inputError.errors || {})[elem.name];

        new Elem(elem).dispatch('validate', {}, {
          valid: !inputError,
          error: inputError || null
        });
      });

      function validatorWrap(input, index, errors) {
        try {
          if (input.validity && !input.validity.valid) {
            throw new Error(input.validationMessage);
          }

          input.dwayneData.validators.forEach(function (validator) {
            validator(input.value, input, index);
          });
        } catch (err) {
          (errors.errors = errors.errors || {})[input.name] = err;
        }
      }

      if (errors.every(function (error) {
        return isNull(error);
      })) {
        return null;
      }

      return errors.$.errors;
    }

    /**
     * @method Elem#width
     * @public
     * @param {*|ElemValueCallback} [width] - Width to set.
     * @returns {Elem|String} If no arguments passed width of the first element in the set returned.
     * Otherwise all elements widths in the set are set to the width argument.
     * @description Gets or sets width.
     *
     * @example
     * elem.width(123);
     * elem.width(); // 123
     */

  }, {
    key: 'width',
    value: function width(_width) {
      return this.prop.apply(this, new Arr(arguments).unshift('width').$);
    }
  }, {
    key: 'innerHeight',
    get: function get() {
      var elem = this.$[0];

      if (isWindow(elem)) {
        return elem.innerHeight;
      }

      var _calcCSS = this.calcCSS(),
          borderTopWidth = _calcCSS.borderTopWidth,
          borderBottomWidth = _calcCSS.borderBottomWidth,
          boxSizing = _calcCSS.boxSizing,
          height = _calcCSS.height,
          paddingTop = _calcCSS.paddingTop,
          paddingBottom = _calcCSS.paddingBottom;

      var borders = px(borderTopWidth) + px(borderBottomWidth);
      var paddings = px(paddingTop) + px(paddingBottom);

      return px(height) - innerSwitcher(boxSizing, [paddings, borders]);
    }

    /**
     * @member {Number} Elem#innerWidth
     * @type {Number}
     * @public
     * @readonly
     * @description Getter for finding how much width content of the first element can be.
     *
     * @example
     * elem.css({
     *   boxSizing: 'border-box',
     *   width: '200px',
     *   paddingLeft: '2px',
     *   paddingRight: '3px',
     *   borderLeft: '1px solid black',
     *   borderRight: '4px solid black'
     * }).innerWidth; // 190
     * elem
     *   .css('box-sizing', 'content-box')
     *   .innerWidth; // 200
     * elem
     *   .css('box-sizing', 'padding-box')
     *   .innerWidth; // 195
     */

  }, {
    key: 'innerWidth',
    get: function get() {
      var elem = this.$[0];

      if (isWindow(elem)) {
        return elem.innerWidth;
      }

      var _calcCSS2 = this.calcCSS(),
          borderLeftWidth = _calcCSS2.borderLeftWidth,
          borderRightWidth = _calcCSS2.borderRightWidth,
          boxSizing = _calcCSS2.boxSizing,
          paddingLeft = _calcCSS2.paddingLeft,
          paddingRight = _calcCSS2.paddingRight,
          width = _calcCSS2.width;

      var borders = px(borderLeftWidth) + px(borderRightWidth);
      var paddings = px(paddingLeft) + px(paddingRight);

      return px(width) - innerSwitcher(boxSizing, [paddings, borders]);
    }
  }, {
    key: 'name',
    get: function get() {
      return getName(this.$[0]);
    }
  }, {
    key: 'outerHeight',
    get: function get() {
      var elem = this.$[0];

      if (isWindow(elem)) {
        return elem.outerHeight;
      }

      var _calcCSS3 = this.calcCSS(),
          borderTopWidth = _calcCSS3.borderTopWidth,
          borderBottomWidth = _calcCSS3.borderBottomWidth,
          boxSizing = _calcCSS3.boxSizing,
          height = _calcCSS3.height,
          marginTop = _calcCSS3.marginTop,
          marginBottom = _calcCSS3.marginBottom,
          paddingTop = _calcCSS3.paddingTop,
          paddingBottom = _calcCSS3.paddingBottom;

      var borders = px(borderTopWidth) + px(borderBottomWidth);
      var paddings = px(paddingTop) + px(paddingBottom);

      return px(height) + px(marginTop) + px(marginBottom) + outerSwitcher(boxSizing, [borders, paddings]);
    }

    /**
     * @member {Number} Elem#outerWidth
     * @type {Number}
     * @public
     * @readonly
     * @description Getter for finding how much width the element actually is.
     *
     * @example
     * elem.css({
     *   boxSizing: 'border-box',
     *   width: '200px',
     *   paddingLeft: '2px',
     *   paddingRight: '3px',
     *   borderLeft: '1px solid black',
     *   borderRight: '4px solid black'
     *   marginLeft: '0px',
     *   marginRight: '5px'
     * }).outerWidth; // 205
     * elem
     *   .css('box-sizing', 'content-box')
     *   .outerWidth; // 215
     * elem
     *   .css('box-sizing', 'padding-box')
     *   .outerWidth; // 210
     */

  }, {
    key: 'outerWidth',
    get: function get() {
      var elem = this.$[0];

      if (isWindow(elem)) {
        return elem.outerWidth;
      }

      var _calcCSS4 = this.calcCSS(),
          borderLeftWidth = _calcCSS4.borderLeftWidth,
          borderRightWidth = _calcCSS4.borderRightWidth,
          boxSizing = _calcCSS4.boxSizing,
          marginLeft = _calcCSS4.marginLeft,
          marginRight = _calcCSS4.marginRight,
          paddingLeft = _calcCSS4.paddingLeft,
          paddingRight = _calcCSS4.paddingRight,
          width = _calcCSS4.width;

      var borders = px(borderLeftWidth) + px(borderRightWidth);
      var paddings = px(paddingLeft) + px(paddingRight);

      return px(width) + px(marginLeft) + px(marginRight) + outerSwitcher(boxSizing, [borders, paddings]);
    }
  }, {
    key: 'toStringTag',
    get: function get() {
      return toStringTag(this.$$);
    }
  }]);
  return Elem;
}(Arr);

defineProperties(Elem.prototype, defineProperty({}, _Symbol.toStringTag, 'Elem'));

/**
 * @const {Elem} win
 * @type {Elem}
 * @public
 * @description Elem instance of window.
 */
var win = new Elem(global$1);

/**
 * @const {Elem} doc
 * @type {Elem}
 * @public
 * @description Elem instance of document.
 */
var doc = new Elem(nativeDocument);

/**
 * @const {Elem} html
 * @type {Elem}
 * @public
 * @description Elem instance of document.documentElement.
 */
var html = new Elem(nativeDocument.documentElement);

/**
 * @const {Elem} body
 * @type {Elem}
 * @public
 * @description Elem instance of document.body.
 */
var body = new Elem(nativeDocument.body);

/**
 * @const {Elem} head
 * @type {Elem}
 * @public
 * @description Elem instance of document.head.
 */
var head$1 = new Elem(nativeDocument.head);

var elements = new Arr(htmlElements).concat(svgElements).$;
var props = new Arr(elements).map(function (type) {
  return new Str(type).toCamelCase().$;
}).$;

dynamicDefineProperties(Elem.prototype, props, function (elem, i) {
  return function () {
    return this.create.apply(this, new Arr(arguments).unshift(elements[i]).$);
  };
});

dynamicDefineProperties(Elem.prototype, canvasGetMethods, function (method$$1) {
  return function () {
    var ctx = this.ctx();

    if (ctx) {
      return ctx[method$$1].apply(ctx, arguments);
    }
  };
});

dynamicDefineProperties(Elem.prototype, canvasRestMethods, function (method$$1) {
  return function () {
    var ctx = this.ctx();

    if (ctx) {
      ctx[method$$1].apply(ctx, arguments);
    }

    return this;
  };
});

/**
 * @function toFind
 * @private
 * @param {Element|Elem|String} elem - Element, selector of Elements or Elem.
 * @returns {Elem} Instance of Elem.
 */
function toFind(elem) {
  if (isElem(elem)) {
    return elem;
  }

  if (isString(elem)) {
    elem = _find(elem);
  }

  return new Elem(elem);
}

/**
 * @function isElem
 * @private
 * @param {*} value - Value to check if it's Elem.
 * @returns {Boolean} If the value is Elem.
 * @description Returns if the value is Elem or not.
 */
function isElem(value) {
  return value instanceof Elem;
}

/**
 * @function isWindow
 * @private
 * @param {*} value - Value to check if it's Window.
 * @returns {Boolean} If the value is Window.
 * @description Returns if the value is Window or not.
 */
function isWindow(value) {
  return toStringTag(value) === 'Window';
}

/**
 * @function isHTMLDocument
 * @private
 * @param {*} value - Value to check if it's HTMLDocument.
 * @returns {Boolean} If the value is HTMLDocument.
 * @description Returns if the value is HTMLDocument or not.
 */
function isHTMLDocument(value) {
  return toStringTag(value) === 'HTMLDocument';
}

/**
 * @function isDocumentFragment
 * @private
 * @param {*} value - Value to check if it's a DocumentFragment.
 * @returns {Boolean} If the value is a DocumentFragment.
 * @description Returns if the value is a DocumentFragment or not.
 */
function isDocumentFragment(value) {
  return toStringTag(value) === 'DocumentFragment';
}

/**
 * @function isStyleRule
 * @private
 * @param {*} value - Value to check if it's a style rule.
 * @returns {Boolean} If the value is a style rule.
 * @description Returns if the value is a style rule or not.
 */
function isStyleRule(value) {
  return toStringTag(value) === 'CSSStyleRule';
}

/**
 * @function
 * @private
 * @param {*} value - Value to check if it's Comment or Text.
 * @returns {Boolean} If the value is HTMLDocument.
 * @description Returns if the value is Comment or Text or not.
 */
function isCommentOrText(value) {
  var tag = toStringTag(value);

  return tag === 'Comment' || tag === 'Text';
}

/**
 * @function getElem
 * @private
 * @param {Elem} elem - Element to check.
 * @returns {Element} The argument or a fallback if needed.
 */
function getElem(elem) {
  return isElement(elem.$[0]) ? elem.$[0] : emptyDiv;
}

/**
 * @function getName
 * @private
 * @param {Element} [elem] - Element which name is needed to know.
 * @returns {String} Element name.
 */
function getName(elem) {
  return elem && elem.nodeName && elem.nodeName.toLowerCase() || '';
}

/**
 * @function addDwayneData
 * @private
 * @param {Element} elem - Element to add dwayneData to.
 * @returns {void}
 */
function addDwayneData(elem) {
  if (!{}.hasOwnProperty.call(elem, 'dwayneData') && !isWindow(elem)) {
    /**
     * @member Element#dwayneData
     * @type {Object}
     * @protected
     * @property {String} previousDisplay - Parameter used for hiding/showing elements.
     * @property {Object.<String, Super>} removeListeners - Parameter used for remove event listeners.
     * @property {CanvasRenderingContext2D} [ctx] - Canvas rendering context.
     * @property {Arr} validators - Validators assigned to element.
     * @description D data.
     */
    Object.defineProperty(elem, 'dwayneData', {
      value: {
        previousDisplay: '',
        listeners: {},
        ctx: getName(elem) === 'canvas' && elem.getContext('2d'),
        validators: new Arr([])
      }
    });
  } else if (isWindow(elem) && !windowsDwayneData.some(function (_ref11) {
    var element = _ref11.element;
    return element === elem;
  })) {
    windowsDwayneData.push({
      element: elem,
      listeners: {}
    });
  }
}

constructors[2].push({
  check: function check(elem) {
    return isElement(elem) || isWindow(elem) || isHTMLDocument(elem) || isCommentOrText(elem) || isDocumentFragment(elem) || /^(HTMLCollection|NodeList)$/.test(toStringTag(elem));
  },
  cls: Elem
});

/**
 * @function find
 * @public
 * @param {String} selector - Selector to find.
 * @param {Element} [base = document] - Base to find in.
 * @returns {Elem} New instance of Elem.
 * @description Synonym for
 * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.
 */
function _find(selector) {
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nativeDocument;

  return new Elem(isElement(base) || isHTMLDocument(base) ? base.querySelectorAll(String(selector)) : []);
}

/**
 * @function parseHTML
 * @public
 * @param {String} html - HTML to parse.
 * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be
 * collapsed during the parsing.
 * @returns {Elem} New instance of Elem.
 * @description Parses HTML and returns a wrap of #document-fragment containing the contents.
 *
 * @example
 * parseHTML('<div>123</div>'); // Elem
 */
function parseHTML(html, collapseWhiteSpace) {
  var json = markupToJSON(html, collapseWhiteSpace);
  var template = doc.template();
  var elem = new Elem(template.$[0].content);

  json.forEach(function forEachNode(node) {
    var name = node.name,
        attrs = node.attrs,
        value = node.value,
        parent = node.parent,
        children = node.children;


    var parentNode = parent.elem || elem;
    var element = parentNode.create(name);

    node.elem = element;

    if (value) {
      element.text(value);
    }

    if (attrs) {
      element.attr(attrs);
    }

    if (name === 'template') {
      node.elem = new Elem(element.prop('content'));
    }

    if (children) {
      children.forEach(forEachNode);
    }
  });

  return new Elem(elem);
}

/**
 * @function px
 * @public
 * @param {String|Number} size - String containing pixels value or a number.
 * @returns {Number} Number of pixels.
 * @description Function for parsing pixel strings.
 *
 * @example
 * px('0px');  // 0
 * px('42px'); // 42
 */
function px(size) {
  return Number(String(size).replace(/px$/, ''));
}

function registerDBlock(Block) {
  var DBlock = function (_Block) {
    inherits(DBlock, _Block);

    function DBlock() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, DBlock);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DBlock.__proto__ || Object.getPrototypeOf(DBlock)).call.apply(_ref, [this].concat(args))), _this), _this.elems = null, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(DBlock, [{
      key: 'afterConstruct',
      value: function afterConstruct() {
        var children = this.$$.parent.children;
        var name = this.args.name;

        var found = void 0;

        if (name) {
          found = children.find(function (_ref2) {
            var nodeName = _ref2.name;
            return nodeName === 'd-block-' + name;
          });

          if (found && found.value.children.length) {
            this.elems = found.value.children;
          }
        } else {
          this.elems = children;
        }
      }
    }]);
    return DBlock;
  }(Block);

  DBlock.template = '<d-elements value="{elems}" />';


  return {
    name: 'd-block',
    value: DBlock
  };
}

function registerDEach(Block, createBlock) {
  var DEach = function (_Block) {
    inherits(DEach, _Block);

    function DEach(opts) {
      classCallCheck(this, DEach);

      var _this = possibleConstructorReturn(this, (DEach.__proto__ || Object.getPrototypeOf(DEach)).call(this, opts));

      var _this$args = _this.args,
          _this$args$item = _this$args.item,
          itemName = _this$args$item === undefined ? '$item' : _this$args$item,
          _this$args$index = _this$args.index,
          indexName = _this$args$index === undefined ? '$index' : _this$args$index;


      assign$1(_this.$$, {
        uids: new Super({}),
        items: new Arr([]),
        UID: String(_this.args.uid),
        itemName: itemName,
        indexName: indexName
      });
      return _this;
    }

    createClass(DEach, [{
      key: 'afterRender',
      value: function afterRender() {
        var _this2 = this;

        this.constructValues(this.args.set);
        this.watchArgs('set', function (set$$1) {
          _this2.constructValues(set$$1);
        });
      }
    }, {
      key: 'constructValues',
      value: function constructValues(set$$1) {
        var _this3 = this;

        var _$$ = this.$$,
            _$$$elems = _$$.elems,
            start = _$$$elems.start,
            parentElem = _$$$elems.parent,
            uids = _$$.uids,
            parent = _$$.parent,
            scope = _$$.scope,
            itemName = _$$.itemName,
            indexName = _$$.indexName,
            UID = _$$.UID;
        var children = this.children;

        var $uids = uids.$;
        var newKeys = {};
        var newUIDs = {};

        new Super(set$$1).forEach(function (item, index) {
          scope[itemName] = item;
          scope[indexName] = index;

          var uid = parent.$$.evaluate(String(UID), null, null, false, false, _this3);

          newKeys[uid] = newKeys[uid] || {};
          newKeys[uid][index] = true;
          newUIDs[index] = uid;
        });

        scope[itemName] = null;
        scope[indexName] = null;

        uids.forEach(function (items, uid) {
          if (!newKeys[uid]) {
            items.forEach(function (Item) {
              Item.remove();
            });

            return;
          }

          items.splice(Object.keys(newKeys[uid]).length).forEach(function (Item) {
            Item.remove();
          });
        });

        var after = start;

        new Super(set$$1).forEach(function (item, index) {
          var uid = newUIDs[index];
          var block = void 0;

          if ($uids[uid] && $uids[uid].length) {
            block = newKeys[uid][index] = uids.$[uid].shift();
            block.$$.scope[indexName] = index;
            block.$$.scope[itemName] = item;
          } else {
            block = newKeys[uid][index] = createBlock({
              node: {
                itemName: itemName,
                indexName: indexName,
                item: item,
                index: index,
                name: '#d-item',
                block: parent,
                children: children
              },
              after: after,
              parent: parentElem,
              parentBlock: _this3,
              parentScope: parent
            });
          }

          var _block$$$$elems = block.$$.elems,
              start = _block$$$$elems.start,
              end = _block$$$$elems.end;


          if (start.prev().$[0] !== after.$[0]) {
            var content = block.$$.elems.content;


            new Elem([start, content, end]).insertAfter(after);
          }

          after = end;
        });

        this.$$.uids = new Super(newKeys).map(function (items) {
          return new Super(items).values();
        });
      }
    }]);
    return DEach;
  }(Block);

  return {
    name: 'd-each',
    value: DEach
  };
}

function registerDElements(Block, createBlock) {
  var DElements = function (_Block) {
    inherits(DElements, _Block);

    function DElements() {
      classCallCheck(this, DElements);
      return possibleConstructorReturn(this, (DElements.__proto__ || Object.getPrototypeOf(DElements)).apply(this, arguments));
    }

    createClass(DElements, [{
      key: 'afterConstruct',
      value: function afterConstruct() {
        var _this2 = this;

        this.watchArgs('value', function (value) {
          var _$$ = _this2.$$,
              children = _$$.children,
              mixins = _$$.mixins,
              watchersToRemove = _$$.watchersToRemove,
              _$$$elems = _$$.elems,
              start = _$$$elems.start,
              content = _$$$elems.content,
              parent = _$$$elems.parent;

          var after = start;

          children.forEach(function (child) {
            child.remove(true);
          });
          mixins.forEach(function (mixin) {
            mixin.remove(true);
          });
          content.remove();

          _this2.$$.children = new Arr([]);
          _this2.$$.mixins = new Arr([]);
          _this2.$$.watchersToRemove = watchersToRemove.filter(function (_ref) {
            var watchers = _ref.watchers,
                watcher = _ref.watcher,
                forDElements = _ref.forDElements;

            if (forDElements) {
              return true;
            }

            var index = watchers.indexOf(watcher);

            if (index !== -1) {
              watchers.splice(index, 1);
            }
          });

          var newContent = new Elem();

          new Arr(value || []).forEach(function (child) {
            var block = createBlock({
              node: child,
              after: after,
              parent: parent,
              parentBlock: _this2,
              parentScope: _this2
            });

            if (block instanceof Block) {
              var elems = block.$$.elems;


              after = elems.end;

              newContent.add(elems.start, elems.content, elems.end);
            } else {
              after = block;

              newContent.add(block);
            }
          });

          _this2.$$.elems.content = newContent;
        });
      }
    }]);
    return DElements;
  }(Block);

  return {
    name: 'd-elements',
    value: DElements
  };
}

function registerDIf(Block) {
  var DIf = function (_Block) {
    inherits(DIf, _Block);

    function DIf() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, DIf);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DIf.__proto__ || Object.getPrototypeOf(DIf)).call.apply(_ref, [this].concat(args))), _this), _this.index = Infinity, _this.elems = null, _this.values = _this.children.map(function (child, i) {
        var name = child.name,
            attrs = child.attrs,
            children = child.children;

        var cond = _this.evaluateAndWatch(name === 'd-else' ? '{true}' : attrs.if || '{true}', function (newValue) {
          if (!!newValue === _this.values.$[i]) {
            return;
          }

          _this.values.$[i] = !!newValue;

          if (i > _this.index) {
            return;
          }

          if (i < _this.index) {
            _this.index = i;
            _this.elems = children;

            return;
          }

          var found = _this.values.find(Boolean);

          if (found) {
            _this.index = found.key;
            _this.elems = _this.children.$[found.key].children;
          } else {
            _this.index = Infinity;
            _this.elems = null;
          }
        });

        if (cond && _this.index === Infinity) {
          _this.index = i;
          _this.elems = children;
        }

        return cond;
      }), _temp), possibleConstructorReturn(_this, _ret);
    }

    return DIf;
  }(Block);

  DIf.template = '<d-elements value="{elems}"/>';


  return {
    name: 'd-if',
    value: DIf
  };
}

function registerDItem(Block) {
  var DItem = function (_Block) {
    inherits(DItem, _Block);

    function DItem() {
      classCallCheck(this, DItem);
      return possibleConstructorReturn(this, (DItem.__proto__ || Object.getPrototypeOf(DItem)).apply(this, arguments));
    }

    return DItem;
  }(Block);

  DItem.template = '<d-elements value="{children}"/>';


  return {
    name: '#d-item',
    value: DItem
  };
}

function registerDSwitch(Block) {
  var DSwitch = function (_Block) {
    inherits(DSwitch, _Block);

    function DSwitch(opts) {
      classCallCheck(this, DSwitch);

      var _this = possibleConstructorReturn(this, (DSwitch.__proto__ || Object.getPrototypeOf(DSwitch)).call(this, opts));

      _this.index = Infinity;
      _this.elems = null;
      var args = _this.args,
          value = _this.args.value;

      var wasDefault = void 0;

      _this.values = _this.children.object(function (values, child, i) {
        var name = child.name,
            attrs = child.attrs,
            children = child.children;


        if (wasDefault) {
          return;
        }

        if (name !== 'd-case' && name !== 'd-default') {
          return;
        }

        if (name === 'd-default') {
          wasDefault = true;
        }

        var val = void 0;

        if (name === 'd-default') {
          val = args.value;
        } else {
          val = _this.evaluateAndWatch(attrs.if || '{undefined}', function (newValue) {
            if (_this.equals(_this.values.$[i].value, newValue)) {
              return;
            }

            _this.values.$[i].value = newValue;

            if (i > _this.index) {
              return;
            }

            if (i < _this.index) {
              _this.index = i;
              _this.elems = children;

              return;
            }

            var found = _this.values.find(function (_ref) {
              var value = _ref.value;
              return _this.equals(value, args.value);
            });

            if (found) {
              _this.index = found.key;
              _this.elems = found.value.children;
            } else {
              _this.index = Infinity;
              _this.elems = null;
            }
          });
        }

        if (_this.equals(val, value) && _this.index === Infinity) {
          _this.index = i;
          _this.elems = children;
        }

        values.push({
          name: name,
          children: children,
          value: val
        });
      }, new Arr([]));
      return _this;
    }

    createClass(DSwitch, [{
      key: 'afterConstruct',
      value: function afterConstruct() {
        var _this2 = this;

        this.watchArgs('value', function (newValue) {
          _this2.index = Infinity;
          _this2.values.forEach(function (_ref2, i) {
            var name = _ref2.name,
                value = _ref2.value,
                children = _ref2.children;

            var val = name === 'd-default' ? newValue : value;

            if (_this2.equals(val, newValue) && _this2.index === Infinity) {
              _this2.index = i;
              _this2.elems = children;
            }
          });

          if (_this2.index === Infinity) {
            _this2.elems = null;
          }
        });
      }
    }, {
      key: 'equals',
      value: function equals(value1, value2) {
        return new Super(value1).equals(value2);
      }
    }]);
    return DSwitch;
  }(Block);

  DSwitch.template = '<d-elements value="{elems}"/>';


  return {
    name: 'd-switch',
    value: DSwitch
  };
}

function registerDText(Block) {
  var DText = function (_Block) {
    inherits(DText, _Block);

    function DText() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, DText);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DText.__proto__ || Object.getPrototypeOf(DText)).call.apply(_ref, [this].concat(args))), _this), _this.text = '', _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(DText, [{
      key: 'afterConstruct',
      value: function afterConstruct() {
        var _this2 = this;

        this.text = isNil(this.args.value) ? '' : this.args.value;

        this.watchArgs('value', function (newValue) {
          _this2.text = isNil(newValue) ? '' : newValue;
        });
      }
    }]);
    return DText;
  }(Block);

  DText.template = '<d-elements value="{[{ name: \'#text\', value: text }]}"/>';


  return {
    name: 'd-text',
    value: DText
  };
}



var Blocks = Object.freeze({
	registerDBlock: registerDBlock,
	registerDEach: registerDEach,
	registerDElements: registerDElements,
	registerDIf: registerDIf,
	registerDItem: registerDItem,
	registerDSwitch: registerDSwitch,
	registerDText: registerDText
});

function registerDAttr(Mixin) {
  var DAttr = function (_Mixin) {
    inherits(DAttr, _Mixin);

    function DAttr() {
      classCallCheck(this, DAttr);
      return possibleConstructorReturn(this, (DAttr.__proto__ || Object.getPrototypeOf(DAttr)).apply(this, arguments));
    }

    createClass(DAttr, [{
      key: 'afterUpdate',
      value: function afterUpdate(newValue, oldValue) {
        var elem = this.elem;


        newValue = new Super(newValue).$;

        new Super(oldValue).forEach(function (value, prop) {
          if (!newValue[prop]) {
            elem.removeAttr(prop);
          }
        });
        elem.attr(newValue);
      }
    }]);
    return DAttr;
  }(Mixin);

  return {
    name: 'd-attr',
    value: DAttr
  };
}

function registerDBind(Mixin) {
  var DBind = function (_Mixin) {
    inherits(DBind, _Mixin);

    function DBind() {
      classCallCheck(this, DBind);
      return possibleConstructorReturn(this, (DBind.__proto__ || Object.getPrototypeOf(DBind)).apply(this, arguments));
    }

    createClass(DBind, [{
      key: 'afterUpdate',
      value: function afterUpdate(value) {
        if (this.off) {
          this.off();
        }

        if (!isFunction(value)) {
          return;
        }

        this.off = this.elem.on(this.match[0], value);
      }
    }]);
    return DBind;
  }(Mixin);

  return {
    name: 'd-bind',
    value: DBind
  };
}

function registerDClass(Mixin) {
  var DClass = function (_Mixin) {
    inherits(DClass, _Mixin);

    function DClass() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, DClass);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DClass.__proto__ || Object.getPrototypeOf(DClass)).call.apply(_ref, [this].concat(args))), _this), _this.classes = [], _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(DClass, [{
      key: 'afterUpdate',
      value: function afterUpdate(newValue) {
        var elem = this.elem,
            classes = this.classes;

        var newClasses = [];

        newValue = new Super(newValue).$;

        if (isString(newValue)) {
          newValue = newValue.split(/\s+/);
        }

        if (isArray(newValue)) {
          iterate(classes, function (cls) {
            if (newValue.indexOf(cls) === -1) {
              elem.removeClass(cls);
            }
          });
          iterate(newValue, function (cls) {
            if (isString(cls)) {
              newClasses.push(cls);
              elem.addClass(cls);
            }
          });
        } else {
          iterate(classes, function (cls) {
            if (!newValue || !newValue[cls]) {
              elem.removeClass(cls);
            }
          });
          iterate(newValue, function (val, cls) {
            if (val) {
              newClasses.push(cls);
              elem.addClass(cls);
            }
          });
        }

        this.classes = newClasses;
      }
    }]);
    return DClass;
  }(Mixin);

  return {
    name: 'd-class',
    value: DClass
  };
}

function registerDElem(Mixin) {
  var DElem = function (_Mixin) {
    inherits(DElem, _Mixin);

    function DElem(opts) {
      classCallCheck(this, DElem);

      var _this = possibleConstructorReturn(this, (DElem.__proto__ || Object.getPrototypeOf(DElem)).call(this, opts));

      var block = _this.block,
          elem = _this.elem;

      var value = _this.evaluateOnce();

      if (isFunction(value)) {
        value(elem);
      } else if (isString(value)) {
        block[value] = elem;
      }
      return _this;
    }

    return DElem;
  }(Mixin);

  DElem.evaluate = false;


  return {
    name: 'd-elem',
    value: DElem
  };
}

function registerDHide(Mixin) {
  var DHide = function (_Mixin) {
    inherits(DHide, _Mixin);

    function DHide() {
      classCallCheck(this, DHide);
      return possibleConstructorReturn(this, (DHide.__proto__ || Object.getPrototypeOf(DHide)).apply(this, arguments));
    }

    createClass(DHide, [{
      key: 'afterUpdate',
      value: function afterUpdate(value) {
        var elem = this.elem;


        if (value) {
          elem.hide();
        } else {
          elem.show();
        }
      }
    }]);
    return DHide;
  }(Mixin);

  return {
    name: 'd-hide',
    value: DHide
  };
}

function registerDOn(Mixin) {
  var DOn = function (_Mixin) {
    inherits(DOn, _Mixin);

    function DOn(opts) {
      classCallCheck(this, DOn);

      var _this = possibleConstructorReturn(this, (DOn.__proto__ || Object.getPrototypeOf(DOn)).call(this, opts));

      _this.elem.on(_this.match[0], function () {
        _this.evaluateOnce();
      });
      return _this;
    }

    return DOn;
  }(Mixin);

  DOn.evaluate = false;


  return {
    name: 'd-on',
    value: DOn
  };
}

function registerDShow(Mixin) {
  var DShow = function (_Mixin) {
    inherits(DShow, _Mixin);

    function DShow() {
      classCallCheck(this, DShow);
      return possibleConstructorReturn(this, (DShow.__proto__ || Object.getPrototypeOf(DShow)).apply(this, arguments));
    }

    createClass(DShow, [{
      key: 'afterUpdate',
      value: function afterUpdate(value) {
        var elem = this.elem;


        if (value) {
          elem.show();
        } else {
          elem.hide();
        }
      }
    }]);
    return DShow;
  }(Mixin);

  return {
    name: 'd-show',
    value: DShow
  };
}

function registerDStyle(Mixin) {
  var DStyle = function (_Mixin) {
    inherits(DStyle, _Mixin);

    function DStyle() {
      classCallCheck(this, DStyle);
      return possibleConstructorReturn(this, (DStyle.__proto__ || Object.getPrototypeOf(DStyle)).apply(this, arguments));
    }

    createClass(DStyle, [{
      key: 'afterUpdate',
      value: function afterUpdate(newValue, oldValue) {
        var elem = this.elem;


        newValue = new Super(newValue).$;

        new Super(oldValue).forEach(function (value, prop) {
          if (!newValue[prop]) {
            elem.removeCSS(prop);
          }
        });
        elem.css(newValue);
      }
    }]);
    return DStyle;
  }(Mixin);

  return {
    name: 'd-style',
    value: DStyle
  };
}

function registerDText$1(Mixin) {
  var DText = function (_Mixin) {
    inherits(DText, _Mixin);

    function DText() {
      classCallCheck(this, DText);
      return possibleConstructorReturn(this, (DText.__proto__ || Object.getPrototypeOf(DText)).apply(this, arguments));
    }

    createClass(DText, [{
      key: 'afterUpdate',
      value: function afterUpdate(value) {
        this.elem.text(isNil(value) ? '' : '' + value);
      }
    }]);
    return DText;
  }(Mixin);

  return {
    name: 'd-text',
    value: DText
  };
}

var listenerSwitcher = switcher('strictEquals', 'input').case('form', 'input, change').case('select', 'change').case('input', function (type) {
  return type === 'radio' || type === 'checkbox' || type === 'color' || type === 'file' ? 'change' : 'input';
});

function registerDValidate(Mixin) {
  var DValidate = function (_Mixin) {
    inherits(DValidate, _Mixin);

    function DValidate(opts) {
      classCallCheck(this, DValidate);

      var _this = possibleConstructorReturn(this, (DValidate.__proto__ || Object.getPrototypeOf(DValidate)).call(this, opts));

      var elem = _this.elem;

      var validator = _this.evaluateOnce();

      if (isFunction(validator)) {
        elem.validate(validator);
      } else if (validator === true) {
        elem.on(listenerSwitcher(elem.name, [elem.prop('type')]), function () {
          elem.validate();
        });
      }
      return _this;
    }

    return DValidate;
  }(Mixin);

  DValidate.evaluate = false;


  return {
    name: 'd-validate',
    value: DValidate
  };
}

var propSwitcher = switcher('strictEquals', function (type, elem) {
  return elem.hasAttr('contenteditable') || elem.hasAttr('contentEditable') ? 'text' : 'value';
}).case('select', function (type, elem) {
  return elem.hasAttr('multiple') ? 'multiple-select' : 'value';
}).case('input', function (type) {
  if (type === 'file') {
    return 'files';
  }

  return type === 'radio' || type === 'checkbox' ? 'checked' : 'value';
});
var setValueSwitcher = switcher('strictEquals', function (value) {
  return value;
}).case('input', function (value, type, inputValue) {
  if (type !== 'radio' && type !== 'checkbox') {
    return value;
  }

  if (type === 'radio') {
    return value === inputValue;
  }

  return value.indexOf(inputValue) !== -1;
});
var getValueSwitcher = switcher('strictEquals', function (value) {
  return value;
}).case('select', function (value, type, inputValue, values, elem, options) {
  if (!elem.hasAttr('multiple')) {
    return value;
  }

  return options.object(function (values, _ref) {
    var selected = _ref.selected,
        value = _ref.value;

    if (selected && values.indexOf(value) === -1) {
      values.push(value);
    }
  }, []).$;
}).case('input', function (value, type, inputValue, values, elem, options, init) {
  if (type !== 'radio' && type !== 'checkbox') {
    return value;
  }

  if (type === 'radio') {
    return value ? inputValue : null;
  }

  if (!value && init) {
    return values;
  }

  if (value) {
    if (values) {
      return values.indexOf(inputValue) === -1 ? new Arr(values).concat(inputValue).$ : values;
    }

    return [inputValue];
  }

  if (!isArray(values)) {
    return [];
  }

  var index = values.indexOf(inputValue);

  if (index !== -1) {
    return [].concat(toConsumableArray(new Arr(values).slice(0, index).$), toConsumableArray(new Arr(values).slice(index + 1).$));
  }

  return values;
});
var listenerSwitcher$1 = switcher('strictEquals', 'input').case('select', 'change').case('input', function (type) {
  return type === 'radio' || type === 'checkbox' || type === 'color' || type === 'file' ? 'change' : 'input';
});

function registerDValue(Mixin) {
  var DValue = function (_Mixin) {
    inherits(DValue, _Mixin);

    function DValue(opts) {
      classCallCheck(this, DValue);

      var _this = possibleConstructorReturn(this, (DValue.__proto__ || Object.getPrototypeOf(DValue)).call(this, opts));

      var _value = _this.$$._value,
          block = _this.block,
          elem = _this.elem,
          node = _this.node;

      var name = elem.name;
      var type = elem.prop('type');
      var value = _this.evaluateOnce();
      var initialScopeValue = null;

      _this.prop = propSwitcher(name, [type, elem]);
      _this.name = name;
      _this.type = type;
      _this.value = value;
      _this.options = elem.find('option');

      if (!isFunction(value)) {
        initialScopeValue = block.$$.evaluate('{' + _value + '}', function (newValue) {
          _this.currentValue = newValue;
          _this.setProp(newValue);
        }, _this);
      }

      var initialElemValue = _this.getProp(initialScopeValue, true);
      var isInitialScopeValueNull = isNil(initialScopeValue);
      var isCheckbox = type === 'checkbox';

      if (isInitialScopeValueNull || isCheckbox) {
        _this.currentValue = initialElemValue;
        _this.changeScope();

        if (!isInitialScopeValueNull && isCheckbox) {
          _this.setProp(initialScopeValue);
        }
      } else {
        _this.currentValue = initialScopeValue;
        _this.setProp(initialScopeValue);
      }

      elem.on(listenerSwitcher$1(name, [type]), function (e) {
        if (e.target === node) {
          _this.currentValue = _this.getProp(_this.currentValue);
          _this.changeScope();
        }
      });
      return _this;
    }

    createClass(DValue, [{
      key: 'changeScope',
      value: function changeScope() {
        var block = this.block,
            value = this.value,
            currentValue = this.currentValue;


        if (isFunction(value)) {
          value(currentValue);
        } else {
          block[value] = currentValue;
        }
      }
    }, {
      key: 'setProp',
      value: function setProp(value) {
        var elem = this.elem,
            name = this.name,
            prop = this.prop,
            type = this.type,
            node = this.node,
            options = this.options;


        if (prop === 'text') {
          elem.text(value);
        } else if (prop === 'multiple-select') {
          options.forEach(function (option) {
            option.selected = value.indexOf(option.value) !== -1;
          });
        } else {
          elem.prop(prop, setValueSwitcher(name, [value, type, node.value]));
        }
      }
    }, {
      key: 'getProp',
      value: function getProp(values, init) {
        var elem = this.elem,
            name = this.name,
            prop = this.prop,
            type = this.type,
            node = this.node,
            options = this.options;


        return prop === 'text' ? elem.text() : getValueSwitcher(name, [elem.prop(prop), type, node.value, values, elem, options, init]);
      }
    }]);
    return DValue;
  }(Mixin);

  DValue.evaluate = false;


  return {
    name: 'd-value',
    value: DValue
  };
}



var Mixins = Object.freeze({
	registerDAttr: registerDAttr,
	registerDBind: registerDBind,
	registerDClass: registerDClass,
	registerDElem: registerDElem,
	registerDHide: registerDHide,
	registerDOn: registerDOn,
	registerDShow: registerDShow,
	registerDStyle: registerDStyle,
	registerDText: registerDText$1,
	registerDValidate: registerDValidate,
	registerDValue: registerDValue
});

/**
 * @module Block
 * @private
 * @mixin
 * @description Exports Block class.
 */

/**
 * @callback Watcher
 * @param {*} newValue - New value.
 * @param {*} oldValue - Old value.
 */

/**
 * @callback Wrapper
 * @param {Block} Block class to wrap.
 * @returns {Block} New Block class.
 */

var rootBlocks = Object.create(null);
var rootMixins = Object.create(null);
var isPrototypeOf = {}.isPrototypeOf;
var tagName = new RegExp('^' + htmlAllowedTagSymbols + '$', 'i');
var attrName = new RegExp('^' + htmlAllowedAttrSymbols + '$');
var expressionRegExp = /^\{[\s\S]+\}$/;
var _global$1 = global$1;
var document$1 = _global$1.document;

var svgNS = 'http://www.w3.org/2000/svg';
var onEvalError = function onEvalError(err) {
  console.error('Eval error (evaluating "' + err.expression + '" in context of block "' + err.block.$$.name + '"):', err);
};
var evalMode = void 0;
var getting = void 0;
var changed = void 0;

/**
 * @class Block
 * @public
 * @param {Object} opts - Element options.
 * @returns {Block} Instance of Block.
 * @description Class for dynamic templating.
 *
 * @example
 * import { D, Block, initApp, registerBlock } from 'dwayne';
 *
 * class App extends Block {
 *   static template = '<Hello text="{text}"/>';
 *
 *   constructor(args, children) {
 *     super(args, children);
 *
 *     this.text = 'world (0)';
 *     this.times = 0;
 *
 *     this.setInterval();
 *   }
 *
 *   setInterval() {
 *     D(1000).interval(() => {
 *       this.text = `world (${ ++this.times })`;
 *     });
 *   }
 * }
 *
 * class Hello extends Block {
 *   static template = 'Hello, <d-text value="{args.text}"/>!';
 * }
 *
 * Block.App = App;
 * Block.Hello = Hello;
 *
 * initApp();
 */

var Block = function () {
  createClass(Block, null, [{
    key: 'getBlocks',
    value: function getBlocks() {
      return new Super(_extends({}, this._blocks));
    }
  }, {
    key: 'getMixins',
    value: function getMixins() {
      return new Super(_extends({}, this._mixins));
    }

    /**
     * @method Block.register
     * @public
     * @param {String} name - Block or mixin name.
     * @param {Block|Mixin} Subclass - Subclass of Block or Mixin.
     * @returns {void}
     * @description Register block or mixin in the namespace of this.
     */

  }, {
    key: 'register',
    value: function register(name, Subclass) {
      var _this = new Super(this);

      if (!_this.hasOwn('_blocks')) {
        Subclass._blocks = Object.create(_this.proto().$._blocks);
      }

      if (!_this.hasOwn('_mixins')) {
        Subclass._mixins = Object.create(_this.proto().$._mixins);
      }

      var _blocks = this._blocks,
          _mixins = this._mixins;


      if (!isInstanceOfBlock(Subclass) && !isInstanceOfMixin(Subclass)) {
        console.warn('The "' + name + '" class does not extend Block or Mixin and will not be registered (Block.register)');

        return;
      }

      if (isInstanceOfBlock(Subclass)) {
        if (rootBlocks[name]) {
          console.warn('The "' + name + '" block is a built-in block so the block will not be registered (Block.register)');

          return;
        }

        if (!tagName.test(name)) {
          console.warn('Name "' + name + '" is not allowed for blocks so the block will not be registered (Block.register)');

          return;
        }

        Subclass._html = deepCloneChildren(markupToJSON('' + (Subclass.template || ''), Subclass.collapseWhiteSpace));

        _blocks[name] = Subclass;
      } else {
        if (rootMixins[name]) {
          console.warn('The "' + name + '" mixin is a built-in mixin so the mixin will not be registered (Block.register)');

          return;
        }

        if (!attrName.test(name)) {
          console.warn('Name "' + name + '" is not allowed for mixins so the mixin will not be registered (Block.register)');

          return;
        }

        Subclass._match = new RegExp('^' + new Str(name).escapeRegExp().$ + '(?:-([\\s\\S]+))?$');

        _mixins[name] = Subclass;
      }
    }

    /**
     * @member {String} Block.template
     * @type {String}
     * @public
     * @description Block template.
     */

    /**
     * @method Block.wrap
     * @public
     * @param {Wrapper} func - Function that returns wrapped block.
     * @returns {Block} New block.
     * @description Method for wrapping blocks into another blocks.
     * It is considered best practice to just extends the old block with a new one.
     *
     * @example
     * class MyBlock extends Block {
     *   static template = '<div>123</div>';
     * }
     *
     * MyBlock.wrap((Block) => {
     *   return class extends Block {
     *     static template = `<section class="wrapper">${ Block.template }</section>`;
     *
     *     constructor() {
     *       this.additionalVar = 'additional';
     *     }
     *   };
     * });
     */

  }, {
    key: 'wrap',
    value: function wrap(func) {
      validate$1([func], ['function']);

      return func(this);
    }
  }, {
    key: 'onEvalError',
    get: function get() {
      return onEvalError;
    }

    /**
     * @member {Boolean} [Block.collapseWhiteSpace = true]
     * @type {Boolean}
     * @public
     * @description If the whitespace between html elements and
     * in the start and the end inside the tag should be omitted during parsing.
     */
    ,
    set: function set(listener) {
      if (isFunction(listener)) {
        onEvalError = listener;
      } else {
        onEvalError = null;
      }
    }
  }]);

  function Block(opts) {
    var _this2 = this;

    classCallCheck(this, Block);
    var name = opts.name,
        originalArgs = opts.args,
        children = opts.children,
        parent = opts.parent,
        parentBlock = opts.parentBlock,
        parentScope = opts.parentScope;

    var watchersToRemove = new Arr([]);

    Object.defineProperties(this, {
      /**
       * @member {Block} Block#$
       * @type {Block}
       * @public
       * @description This.
       */
      $: {
        value: this
      },

      /**
       * @member {Object} Block#$$
       * @type {Object}
       * @protected
       * @property {Object} args - Private args scope.
       * @property {Arr} children - Child blocks.
       * @property {Arr} mixins - Child mixins.
       * @property {Object} elems - Elements connected to the block.
       * @property {Elem} elems.parent - Parent element.
       * @property {Elem} elems.start - Start comment block.
       * @property {Elem} elems.end - End comment block.
       * @property {Elem} elems.content - Content elements.
       * @property {Function} evaluate - Evaluate function.
       * @property {Object} global - Private global scope.
       * @property {Object} locals - Private locals scope.
       * @property {Arr} watchersToRemove - Watchers to remove before removing element.
       */
      $$: {
        value: {
          name: name,
          parent: parentScope,
          parentBlock: parentBlock,
          ns: new Super(this).proto().$.constructor,
          children: new Arr([]),
          mixins: new Arr([]),
          elems: {
            start: doc.createComment(' ' + name + ': start '),
            end: doc.createComment(' ' + name + ': end '),
            content: new Elem(),
            parent: parent
          },
          watchersToRemove: watchersToRemove,
          evaluate: function evaluate(expression, onChange, instance, forDElements, forDItem, forDEach) {
            if (!expressionRegExp.test(expression)) {
              return expression || true;
            }

            forDElements = !!forDElements;
            forDItem = !!forDItem;
            expression = expression.replace(/^\{|\}$/g, '');

            var store = name === '#d-item' && !forDItem || forDEach ? (forDEach || _this2).$$.scope : _this2;

            /* eslint no-new-func: 0 */

            var _ref = instance ? instance.$$ : {},
                watchersToRemove = _ref.watchersToRemove;

            var func = new Function('', 'with(document.DwayneStore){$$.expr=eval("$$.expr="+$$.expr);return $$.expr}');

            return evaluate.call(_this2);

            function evaluate() {
              var _this3 = this;

              var result = void 0;

              if (onChange) {
                evalMode = true;
                getting = new Arr([]);
              }

              store.$$.expr = expression;
              document$1.DwayneStore = store;

              try {
                result = func();
              } catch (err) {
                if (onEvalError) {
                  err.expression = expression;
                  err.block = this;
                  onEvalError(err);
                }
              }

              if (onChange) {
                (function () {
                  var localWatchers = new Arr([]);

                  getting.forEach(function (watchers) {
                    var watcher = function watcher() {
                      var newResult = evaluate.call(_this3);

                      if (newResult !== result) {
                        onChange(newResult, result);
                      }
                    };
                    var watcherBlock = {
                      forDElements: forDElements,
                      watcher: watcher,
                      watchers: watchers
                    };

                    watcher.onRemove = function () {
                      localWatchers.forEach(function (watcherBlock) {
                        var watcher = watcherBlock.watcher,
                            watchers = watcherBlock.watchers;

                        var index1 = watchersToRemove.indexOf(watcherBlock);
                        var index2 = watchers.indexOf(watcher);

                        if (index1 !== -1) {
                          watchersToRemove.splice(index1, 1);
                        }

                        if (index2 !== -1) {
                          watchers.splice(index2, 1);
                        }
                      });
                    };

                    localWatchers.push(watcherBlock);
                    watchersToRemove.push(watcherBlock);
                    watchers.push(watcher);
                  });

                  evalMode = false;
                  getting = new Arr([]);
                })();
              }

              store.$$.expr = null;
              document$1.DwayneStore = null;

              return result;
            }
          }
        }
      }
    });

    var args = new Super(originalArgs).map(function (value, arg) {
      if (name === 'd-each' && (arg === 'item' || arg === 'index' || arg === 'uid')) {
        return value;
      }

      var forDElements = name === 'd-elements' && arg === 'value';

      return parentScope.$$.evaluate(value, function (value) {
        _this2.args[arg] = value;
      }, _this2, forDElements, forDElements && parentBlock.$$.name === '#d-item');
    }).$;

    this.args = args;
    this.children = children || new Arr([]);
    this.global = Object.create(parentScope ? Object.create(parentScope.global) : null);

    this.$$.elems.start.$[0].DwayneBlock = this;
    this.$$.elems.end.$[0].DwayneBlock = this;

    if (parentBlock) {
      parentBlock.$$.children.push(this);
    }
  }

  /**
   * @method Block#afterConstruct
   * @public
   * @description Is called after block construction (including all scopes)
   * but before rendering the block and its children.
   */


  createClass(Block, [{
    key: 'afterConstruct',
    value: function afterConstruct() {}

    /**
     * @method Block#afterRender
     * @public
     * @description Is called after block has been rendered.
     */

  }, {
    key: 'afterRender',
    value: function afterRender() {}

    /**
     * @method Block#afterRender
     * @public
     * @description Is called before the block removal.
     */

  }, {
    key: 'beforeRemove',
    value: function beforeRemove() {}
  }, {
    key: 'evaluateAndWatch',
    value: function evaluateAndWatch(expression, callback) {
      return this.$$.parent.$$.evaluate(expression, callback, this);
    }
  }, {
    key: 'evaluateOnce',
    value: function evaluateOnce(expression) {
      return this.$$.parent.$$.evaluate(expression);
    }

    /**
     * @method Block#remove
     * @public
     * @description Method fot forcing the block to be removed. Calls
     * remove method for all of its child blocks and calls beforeRemove function.
     */

  }, {
    key: 'remove',
    value: function remove(isParentSignal) {
      var _$$ = this.$$,
          name = _$$.name,
          parentBlock = _$$.parentBlock,
          children = _$$.children,
          mixins = _$$.mixins,
          _$$$elems = _$$.elems,
          start = _$$$elems.start,
          content = _$$$elems.content,
          end = _$$$elems.end,
          watchersToRemove = _$$.watchersToRemove;


      removeWatchers(watchersToRemove);

      children.forEach(function (child) {
        child.remove(true);
      });

      mixins.forEach(function (mixin) {
        mixin.remove(true);
      });

      try {
        this.beforeRemove();
      } catch (err) {
        console.error('Uncaught error in ' + name + '#beforeRemove:', err);
      }

      if (!isParentSignal && parentBlock) {
        var index = parentBlock.$$.children.indexOf(this);

        if (index !== -1) {
          parentBlock.$$.children.splice(index, 1);
        }
      }

      new Elem([start, content, end]).remove();
    }

    /**
     * @method Block#watch
     * @public
     * @param {...String} [args] - Vars to watch (args, global or local).
     * @param {Watcher} watcher - Called when watched vars are changed.
     * @description Method for watching for vars. If no vars passed in arguments
     * all vars are to be watched. Otherwise specified vars will be watched.
     * Watchers should not be put inside the constructor. It is considered best
     * practice to do it inside the {@link Block#afterConstruct} method.
     * Note that these expressions (vars, i.e. "args.arg") are not to be
     * evaluated so you cannot put there things like "a[b]" or any js code,
     * only expressions like "a", "b", "args.a", "args.b" and "global.a", "global.b".
     *
     * @example
     * class MyBlock extends Block {
     *   static template = '<div />';
     *
     *   afterConstruct() {
     *     this.watch('a', () => {});
     *     this.watch('args.a', 'global.r', () => {});
     *     this.watch(() => {});
     *   }
     * }
     */

  }, {
    key: 'watch',
    value: function watch() {
      var _this4 = this;

      var watcher = arguments[arguments.length - 1];

      if (!isFunction(watcher)) {
        return;
      }

      if (arguments.length === 1) {
        for (var _global2 in this.$$.global) {
          /* eslint guard-for-in: 0 */
          this.$$.global[_global2].watchers.perm.push(watcher);
        }

        iterate(this.$$.args, function (_ref2) {
          var watchers = _ref2.watchers;

          watchers.perm.push(watcher);
        });

        return iterate(this.$$.locals, function (_ref3) {
          var watchers = _ref3.watchers;

          watchers.perm.push(watcher);
        });
      }

      iterate(arguments, function (variable) {
        if (variable === watcher) {
          return;
        }

        variable = '' + variable;

        if (/^args\./.test(variable)) {
          variable = variable.replace(/^args\./, '');

          if (!_this4.$$.args[variable]) {
            return;
          }

          _this4.$$.args[variable].watchers.perm.push(watcher);

          return;
        }

        if (/^global\./.test(variable)) {
          variable = variable.replace(/^global\./, '');

          if (!_this4.$$.global[variable]) {
            return;
          }

          _this4.$$.global[variable].watchers.perm.push(watcher);

          return;
        }

        if (!_this4.$$.locals[variable]) {
          return;
        }

        _this4.$$.locals[variable].watchers.perm.push(watcher);
      });
    }

    /**
     * @method Block#watchArgs
     * @public
     * @param {...String} [args] - Args to watch.
     * @param {Watcher} watcher - Called when watched args are changed.
     * @description Method for watching for args. If no args passed in arguments
     * all args are to be watched. Otherwise specified args will be watched.
     * Watchers should not be put inside the constructor. It is considered best
     * practice to do it inside the {@link Block#afterConstruct} method.
     *
     * @example
     * class MyBlock extends Block {
     *   static template = '<div />';
     *
     *   afterConstruct() {
     *     this.watchArgs('a', () => {});
     *     this.watchArgs('a', 'b', () => {});
     *     this.watchArgs(() => {});
     *   }
     * }
     */

  }, {
    key: 'watchArgs',
    value: function watchArgs() {
      var _this5 = this;

      var watcher = arguments[arguments.length - 1];

      if (!isFunction(watcher)) {
        return;
      }

      if (arguments.length === 1) {
        return iterate(this.$$.args, function (_ref4) {
          var watchers = _ref4.watchers;

          watchers.perm.push(watcher);
        });
      }

      iterate(arguments, function (arg) {
        if (arg === watcher) {
          return;
        }

        if (!_this5.$$.args[arg]) {
          return;
        }

        _this5.$$.args[arg].watchers.perm.push(watcher);
      });
    }

    /**
     * @method Block#watchGlobal
     * @public
     * @param {...String} [globals] - Globals to watch.
     * @param {Watcher} watcher - Called when watched globals are changed.
     * @description Method for watching for globals. If no globals passed in arguments
     * all globals are to be watched. Otherwise specified globals will be watched.
     * Watchers should not be put inside the constructor. It is considered best
     * practice to do it inside the {@link Block#afterConstruct} method.
     *
     * @example
     * class MyBlock extends Block {
     *   static template = '<div />';
     *
     *   afterConstruct() {
     *     this.watchGlobal('a', () => {});
     *     this.watchGlobal('a', 'b', () => {});
     *     this.watchGlobal(() => {});
     *   }
     * }
     */

  }, {
    key: 'watchGlobals',
    value: function watchGlobals() {
      var _this6 = this;

      var watcher = arguments[arguments.length - 1];

      if (!isFunction(watcher)) {
        return;
      }

      if (arguments.length === 1) {
        for (var _global3 in this.$$.global) {
          /* eslint guard-for-in: 0 */
          this.$$.global[_global3].watchers.perm.push(watcher);
        }

        return;
      }

      iterate(arguments, function (global) {
        if (global === watcher) {
          return;
        }

        if (!_this6.$$.global[global]) {
          return;
        }

        _this6.$$.global[global].watchers.perm.push(watcher);
      });
    }

    /**
     * @method Block#watchLocals
     * @public
     * @param {...String} [locals] - Locals to watch.
     * @param {Watcher} watcher - Called when watched locals are changed.
     * @description Method for watching for locals. If no locals passed in arguments
     * all locals are to be watched. Otherwise specified locals will be watched.
     * Watchers should not be put inside the constructor. It is considered best
     * practice to do it inside the {@link Block#afterConstruct} method.
     *
     * @example
     * class MyBlock extends Block {
     *   static template = '<div />';
     *
     *   afterConstruct() {
     *     this.watchLocals('a', () => {});
     *     this.watchLocals('a', 'b', () => {});
     *     this.watchLocals(() => {});
     *   }
     * }
     */

  }, {
    key: 'watchLocals',
    value: function watchLocals() {
      var _this7 = this;

      var watcher = arguments[arguments.length - 1];

      if (!isFunction(watcher)) {
        return;
      }

      if (arguments.length === 1) {
        return iterate(this.$$.locals, function (_ref5) {
          var watchers = _ref5.watchers;

          watchers.perm.push(watcher);
        });
      }

      iterate(arguments, function (local) {
        if (local === watcher) {
          return;
        }

        if (!_this7.$$.locals[local]) {
          return;
        }

        _this7.$$.locals[local].watchers.perm.push(watcher);
      });
    }
  }]);
  return Block;
}();

Block._blocks = Object.create(rootBlocks);
Block._mixins = Object.create(rootMixins);
Block.collapseWhiteSpace = true;


registerBuiltIns(Blocks, rootBlocks, Block);

var blocks = Block._blocks;

var Mixin = function () {
  function Mixin(opts) {
    classCallCheck(this, Mixin);
    var name = opts.name,
        value = opts.value,
        elem = opts.elem,
        match = opts.match,
        parentBlock = opts.parentBlock,
        parentScope = opts.parentScope;


    Object.defineProperties(this, {
      $$: {
        value: {
          name: name,
          _value: value,
          parent: parentScope,
          parentBlock: parentBlock,
          watchersToRemove: new Arr([])
        }
      }
    });

    this.match = new Arr(match).slice(1).$;
    this.block = parentScope;
    this.elem = elem;
    this.node = elem.$[0];

    if (parentBlock) {
      parentBlock.$$.mixins.push(this);
    }
  }

  createClass(Mixin, [{
    key: 'afterUpdate',
    value: function afterUpdate() {}
  }, {
    key: 'beforeRemove',
    value: function beforeRemove() {}
  }, {
    key: 'evaluateAndWatch',
    value: function evaluateAndWatch(callback) {
      var _$$2 = this.$$,
          _value = _$$2._value,
          parent = _$$2.parent;


      return parent.$$.evaluate(_value, callback, this);
    }
  }, {
    key: 'evaluateOnce',
    value: function evaluateOnce() {
      var _$$3 = this.$$,
          _value = _$$3._value,
          parent = _$$3.parent;


      return parent.$$.evaluate(_value);
    }

    /**
     * @method Mixin#remove
     * @public
     * @description Method fot forcing the mixin to be removed.
     */

  }, {
    key: 'remove',
    value: function remove(isParentSignal) {
      var _$$4 = this.$$,
          name = _$$4.name,
          parentBlock = _$$4.parentBlock,
          watchersToRemove = _$$4.watchersToRemove;


      removeWatchers(watchersToRemove);

      try {
        this.beforeRemove();
      } catch (err) {
        console.error('Uncaught error in ' + name + '#beforeRemove:', err);
      }

      if (!isParentSignal && parentBlock) {
        var index = parentBlock.$$.mixins.indexOf(this);

        if (index !== -1) {
          parentBlock.$$.mixins.splice(index, 1);
        }
      }
    }
  }]);
  return Mixin;
}();

Mixin.evaluate = true;


registerBuiltIns(Mixins, rootMixins, Mixin);

var mixins = Block._mixins;

function initApp(block, node) {
  if (!blocks[block]) {
    throw new Error('No "' + block + '" block is registered! (initApp)');
  }

  var start = doc.createComment(' d-root: start ');
  var end = doc.createComment(' d-root: end ');
  var parent = new Elem(node);

  parent.html('');

  new Elem([start, end]).into(parent);

  createBlock({
    node: {
      name: block,
      attrs: {},
      children: new Arr([])
    },
    after: start,
    parent: parent
  });
}

function registerBuiltIns(set$$1, scope, proto) {
  iterate(set$$1, function (register) {
    var _register = register(proto, createBlock),
        name = _register.name,
        value = _register.value;

    if (proto === Block) {
      value._html = deepCloneChildren(markupToJSON('' + (value.template || ''), value.collapseWhiteSpace));
    } else {
      value._match = new RegExp('^' + new Str(name).escapeRegExp().$ + '(?:-([\\s\\S]+))?$');
    }

    scope[name] = value;
  });
}

function createBlock(_ref6) {
  var node = _ref6.node,
      after = _ref6.after,
      parent = _ref6.parent,
      parentBlock = _ref6.parentBlock,
      parentScope = _ref6.parentScope;

  parentScope = node && node.block || parentScope;

  var name = node && node.name || 'UnknownBlock';
  var args = node && node.attrs || {};
  var children = node && node.children || new Arr([]);
  var elem = parent.prop('namespaceURI') === svgNS ? doc.svg() : new Elem(doc.template().$[0].content);
  var localBlocks = parentScope ? parentScope.$$.ns._blocks : blocks;
  var localMixins = parentScope ? parentScope.$$.ns._mixins : mixins;
  var constructor = node && node.name && localBlocks[node.name];
  var dBlockMatch = void 0;

  if (!children.length && ((dBlockMatch = name.match(/^d-block-([\s\S]+)$/)) || name === 'd-block')) {
    constructor = blocks['d-block'];
    args.name = dBlockMatch ? dBlockMatch[1] : '{null}';
  }

  if (!constructor) {
    var _ret2 = function () {
      var value = node.value,
          children = node.children;


      if (name === '#text' && expressionRegExp.test(value)) {
        return {
          v: createBlock({
            node: {
              name: 'd-text',
              attrs: { value: value },
              children: new Arr([]),
              block: parentScope
            },
            after: after,
            parent: parent,
            parentBlock: parentBlock,
            parentScope: parentScope
          })
        };
      }

      var element = elem.create(name);
      var currentMixins = new Arr([]);

      var attrs = new Super(args).object(function (object, value, attr) {
        var match = void 0;

        for (var _name in localMixins) {
          var _Mixin = localMixins[_name];
          var localMatch = attr.match(_Mixin._match);

          if (localMatch) {
            match = {
              match: localMatch,
              Mixin: _Mixin,
              name: _name
            };

            break;
          }
        }

        if (match) {
          currentMixins.push({
            name: match.name,
            Mixin: match.Mixin,
            match: match.match,
            value: value,
            elem: element,
            parentBlock: parentBlock,
            parentScope: parentScope
          });

          return;
        }

        if (!value) {
          object[attr] = '';

          return;
        }

        object[attr] = parentScope.$$.evaluate(value, function (value) {
          element.attr(attr, value);
        }, parentBlock);
      }).$;

      if (!isNil(value)) {
        element.text(value);
      }

      if (attrs) {
        element.attr(attrs);
      }

      if (after.length) {
        element.insertAfter(after);
      } else {
        element.into(parent);
      }

      after = new Elem();

      if (children) {
        transformDIfChildren(children).forEach(function (child) {
          var block = createBlock({
            node: child,
            after: after,
            parent: element,
            parentBlock: parentBlock,
            parentScope: parentScope
          });

          if (block instanceof Block) {
            after = block.$$.elems.end;
          } else {
            after = block;
          }
        });
      }

      currentMixins.forEach(function (opts) {
        createMixin(opts);
      });

      return {
        v: element
      };
    }();

    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
  }

  var blockInstance = new constructor({
    name: name,
    args: args,
    children: children,
    parent: parent,
    parentBlock: parentBlock,
    parentScope: parentScope
  });

  Object.defineProperties(blockInstance, {
    args: {
      value: blockInstance.args
    },
    global: {
      value: blockInstance.global
    }
  });

  var html$$1 = name === 'd-elements' ? new Arr(blockInstance.args.value || []) : deepCloneChildren(constructor._html, blockInstance);

  if (name === 'd-elements' && parentBlock.$$.name === '#d-item') {
    html$$1 = deepCloneChildren(html$$1, parentBlock);
  }

  var $$ = blockInstance.$$,
      Args = blockInstance.args,
      global = blockInstance.global,
      locals = objectWithoutProperties(blockInstance, ['$$', 'args', 'global']);


  delete locals.$;
  delete locals.$$;

  $$.args = constructPrivateScope(Args);
  $$.locals = constructPrivateScope(locals);
  $$.global = constructPrivateScope(global, 'global', parentScope);

  if (name === '#d-item') {
    var _scopeValues;

    var scopeValues = (_scopeValues = {}, defineProperty(_scopeValues, node.itemName, node.item), defineProperty(_scopeValues, node.indexName, node.index), _scopeValues);
    var _parent = blockInstance;
    var scope = parentScope;
    var DItemFound = void 0;

    while (!DItemFound && (_parent = _parent.$$.parentBlock)) {
      DItemFound = _parent.$$.name === '#d-item';
    }

    if (DItemFound) {
      scope = _parent.$$.scope;
    }

    $$.ns = parentScope.$$.ns;
    $$.privateScope = constructPrivateScope(scopeValues);
    constructPublicScope($$.scope = Object.create(scope), scopeValues, $$.privateScope);
  }

  if (name === 'd-each') {
    $$.scope = Object.create(parentScope);
  }

  constructPublicScope(Args, Args, $$.args);
  constructPublicScope(global, global, $$.global);
  constructPublicScope(blockInstance, locals, $$.locals);

  try {
    blockInstance.afterConstruct();
  } catch (err) {
    console.error('Uncaught error in ' + name + '#afterConstruct:', err);
  }

  var elems = new Elem([$$.elems.start, $$.elems.end]);

  if (after.length) {
    elems.insertAfter(after);
  } else {
    elems.into(parent);
  }

  after = $$.elems.start;

  transformDIfChildren(html$$1).forEach(function (child) {
    var block = createBlock({
      node: child,
      after: after,
      parent: parent,
      parentBlock: blockInstance,
      parentScope: parentScope
    });

    if (block instanceof Block) {
      var _elems = block.$$.elems;


      after = _elems.end;

      $$.elems.content.add(_elems.start, _elems.content, _elems.end);
    } else {
      after = block;

      $$.elems.content.add(block);
    }
  });

  try {
    blockInstance.afterRender();
  } catch (err) {
    console.error('Uncaught error in ' + name + '#afterRender:', err);
  }

  return blockInstance;
}

function createMixin(_ref7) {
  var name = _ref7.name,
      Mixin = _ref7.Mixin,
      value = _ref7.value,
      match = _ref7.match,
      elem = _ref7.elem,
      parentBlock = _ref7.parentBlock,
      parentScope = _ref7.parentScope;

  var mixin = new Mixin({
    name: name,
    value: value,
    match: match,
    elem: elem,
    parentBlock: parentBlock,
    parentScope: parentScope
  });

  if (Mixin.evaluate) {
    var _value2 = mixin.value = mixin.evaluateAndWatch(function (newValue, oldValue) {
      mixin.value = newValue;

      try {
        mixin.afterUpdate(newValue, oldValue);
      } catch (err) {
        console.error('Uncaught error in ' + name + '#afterUpdate:', err);
      }
    });

    mixin.afterUpdate(_value2);
  }
}

function deepCloneChildren(children, block) {
  return new Arr(children || []).map(function (child) {
    var name = child.name,
        attrs = child.attrs,
        value = child.value,
        children = child.children;

    var newChild = {
      name: name,
      value: value,
      attrs: _extends({}, attrs)
    };

    if (block) {
      newChild.block = block;
    }

    if (children) {
      newChild.children = deepCloneChildren(children, block);
    }

    return newChild;
  });
}

function transformDIfChildren(children) {
  return new Arr(children || []).concat({}).object(function (object, child) {
    var name = child.name;
    var html$$1 = object.html,
        ifElse = object.ifElse;


    if (name !== 'd-else-if' && name !== 'd-else') {
      if (ifElse) {
        html$$1.push({
          name: 'd-if',
          block: ifElse.$[0].block,
          children: ifElse
        });

        object.ifElse = null;
      }

      if (name === 'd-if') {
        object.ifElse = new Arr([child]);
      } else if (!isUndefined(name)) {
        html$$1.push(child);
      }
    } else {
      (ifElse || html$$1).push(child);

      if (name === 'd-else' && ifElse) {
        html$$1.push({
          name: 'd-if',
          block: ifElse.$[0].block,
          children: ifElse
        });

        object.ifElse = null;
      }
    }
  }, {
    html: new Arr([]),
    ifElse: null
  }).$.html;
}

function isInstanceOfBlock(block) {
  return isPrototypeOf.call(Block, block) && isPrototypeOf.call(Block.prototype, block.prototype);
}

function isInstanceOfMixin(mixin) {
  return isPrototypeOf.call(Mixin, mixin) && isPrototypeOf.call(Mixin.prototype, mixin.prototype);
}

function removeWatchers(watchersToRemove) {
  watchersToRemove.forEach(function (_ref8) {
    var watcher = _ref8.watcher,
        watchers = _ref8.watchers;

    var index = watchers.indexOf(watcher);

    if (index !== -1) {
      watchers.splice(index, 1);
    }
  });
}

function constructPrivateScope(object, type, parentScope) {
  var scope = {};

  if (type === 'global') {
    scope = Object.create(parentScope ? parentScope.$$.global : null);
  }

  return new Super(object).object(function (scope, value, key) {
    scope[key] = {
      value: value,
      watchers: {
        temp: new Arr([]),
        perm: new Arr([])
      }
    };
  }, scope).$;
}

function constructPublicScope(scope, scopeValues, privateScope) {
  new Super(scope).define(new Super(scopeValues).map(function (value, key) {
    var scope = privateScope[key];

    return {
      get: function get() {
        if (evalMode) {
          if (getting.indexOf(scope.watchers.temp) === -1) {
            getting.push(scope.watchers.temp);
          }
        }

        return scope.value;
      },
      set: function set(value) {
        if (value === scope.value) {
          return;
        }

        if (!changed) {
          changed = [];
        }

        var oldTempWatchers = scope.watchers.temp.slice();
        var oldValue = scope.value;

        scope.watchers.temp = new Arr([]);
        scope.value = value;

        oldTempWatchers.forEach(function (watcher) {
          watcher.onRemove();
          watcher();
        });
        changed.push({
          scope: scope,
          oldValue: oldValue,
          value: value
        });

        setTimeout(function () {
          if (!changed) {
            return;
          }

          var was = new Arr([]);
          var values = [];

          var _loop = function _loop(i) {
            var _changed$i = changed[i],
                scope = _changed$i.scope,
                value = _changed$i.value,
                oldValue = _changed$i.oldValue;


            scope.watchers.perm.forEach(function (watcher) {
              var index = was.indexOf(watcher);

              if (index === -1) {
                was.push(watcher);
                values.push({
                  value: value,
                  oldValue: oldValue
                });
              } else {
                values[index].oldValue = oldValue;
              }
            });

            changed.splice(i, 1);
          };

          for (var i = changed.length - 1; i >= 0; i--) {
            _loop(i);
          }

          changed = null;

          was.forEach(function (watcher, i) {
            var _values$i = values[i],
                value = _values$i.value,
                oldValue = _values$i.oldValue;


            watcher(value, oldValue);
          });
        }, 0);
      }
    };
  }).$);
}

/**
 * @module constants/formats
 * @private
 * @description Exports different types of formatting for {@link Date#format}.
 */

var zero = new Str('0');
var daysOfTheWeekNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var daysOfTheWeekAliases = new Super(daysOfTheWeekNames).map(function (value) {
  return value.slice(0, 3);
}).$;
var monthsNames = ['January', 'February', 'March', 'April', 'May', 'June', 'Jule', 'August', 'September', 'October', 'November', 'December'];
var monthsAliases = new Super(monthsNames).map(function (value) {
  return value.slice(0, 3);
}).$;

/**
 * @callback module:constants/formats~matchCallback
 * @param {Dat} date - D-wrap of a date to apply format to.
 * @param {String} string - Matched applied expression.
 */

/**
 * @typedef {Object} module:constants/formats~formatExpr
 * @property {String} format - Matched format.
 * @property {module:constants/formats~matchCallback} match - Callback if there was a match.
 */

/**
 * @type {module:constants/formats~formatExpr[]}
 * @description Array of different formats.
 */
var formats = [{
  format: 'ccc',
  match: function match(date, utc) {
    return round(date[utc]('c'), 3);
  }
}, {
  format: 'c',
  match: function match(date, utc) {
    return date[utc]('c');
  }
}, {
  format: 'ss',
  match: function match(date, utc) {
    return round(date[utc]('s'), 2);
  }
}, {
  format: 's',
  match: function match(date, utc) {
    return date[utc]('s');
  }
}, {
  format: 'mm',
  match: function match(date, utc) {
    return round(date[utc]('m'), 2);
  }
}, {
  format: 'm',
  match: function match(date, utc) {
    return date[utc]('m');
  }
}, {
  format: 'hh',
  match: function match(date, utc) {
    return round(date[utc]('h'), 2);
  }
}, {
  format: 'h',
  match: function match(date, utc) {
    return date[utc]('h');
  }
}, {
  format: 'dddd',
  match: function match(date, utc) {
    return daysOfTheWeekNames[date[utc]('dw')];
  }
}, {
  format: 'ddd',
  match: function match(date, utc) {
    return daysOfTheWeekAliases[date[utc]('dw')];
  }
}, {
  format: 'dd',
  match: function match(date, utc) {
    return round(date[utc]('d'), 2);
  }
}, {
  format: 'd',
  match: function match(date, utc) {
    return date[utc]('d');
  }
}, {
  format: 'MMMM',
  match: function match(date, utc) {
    return monthsNames[date[utc]('M') - 1];
  }
}, {
  format: 'MMM',
  match: function match(date, utc) {
    return monthsAliases[date[utc]('M') - 1];
  }
}, {
  format: 'MM',
  match: function match(date, utc) {
    return round(date[utc]('M'), 2);
  }
}, {
  format: 'M',
  match: function match(date, utc) {
    return date[utc]('M');
  }
}, {
  format: 'yyyy',
  match: function match(date, utc) {
    return round(date[utc]('y'), 4);
  }
}, {
  format: 'yy',
  match: function match(date, utc) {
    return String(date[utc]('y')).slice(-2);
  }
}, {
  format: 'y',
  match: function match(date, utc) {
    return date[utc]('y');
  }
}];

/**
 * @function round
 * @private
 * @param {Number} number - Number to round.
 * @param {Number} digits - Number of the digits of the output.
 * @returns {String} String with necessary additional starting zeroes.
 */
function round(number, digits) {
  var string = String(number);
  var zeroes = digits - string.length;

  zeroes = zeroes < 0 ? 0 : zeroes;

  return zero.repeat(zeroes).$ + string;
}

/**
 * @module Dat
 * @private
 * @mixin
 * @description Exports Dat class.
 */

/**
 * @typedef {*} DateLike
 * @public
 */

/**
 * @typedef {'c'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} AddPeriod
 * @public
 */

/**
 * @typedef {'c'|'s'|'m'|'h'|'d'|'dw'|'M'|'y'} GetPeriod
 * @public
 */

/**
 * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} OfOnePeriod
 * @public
 */

/**
 * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} SetPeriod
 * @public
 */

/**
 * @typedef {'ccc'|'c'|'ss'|'s'|'mm'|'m'|'hh'|'h'|'dddd'|'ddd'|'dd'|'d'|'MMMM'|'MMM'|'MM'|'M'|'yyyy'|'yy'|'y'} Format
 * @public
 */

var coeffs = {
  c: 1,
  s: 1000,
  m: 60000,
  h: 3600000,
  d: 86400000,
  w: 604800000,
  M: 2592000000,
  y: 31536000000
};

var getSwitcher = switcher({
  c: function c(date, utc) {
    return date[utc + 'Milliseconds']();
  },
  s: function s(date, utc) {
    return date[utc + 'Seconds']();
  },
  m: function m(date, utc) {
    return date[utc + 'Minutes']();
  },
  h: function h(date, utc) {
    return date[utc + 'Hours']();
  },
  d: function d(date, utc) {
    return date[utc + 'Date']();
  },
  dw: function dw(date, utc) {
    return date[utc + 'Day']();
  },
  M: function M(date, utc) {
    return date[utc + 'Month']() + 1;
  },
  y: function y(date, utc) {
    return date[utc + 'FullYear']();
  }
}, 'equals', NaN);
var setSwitcher = switcher({
  c: function c(date, value, utc) {
    return date[utc + 'Milliseconds'](value);
  },
  s: function s(date, value, utc) {
    return date[utc + 'Seconds'](value);
  },
  m: function m(date, value, utc) {
    return date[utc + 'Minutes'](value);
  },
  h: function h(date, value, utc) {
    return date[utc + 'Hours'](value);
  },
  d: function d(date, value, utc) {
    return date[utc + 'Date'](value);
  },
  M: function M(date, value, utc) {
    return date[utc + 'Month'](value - 1);
  },
  y: function y(date, value, utc) {
    return date[utc + 'FullYear'](value);
  }
});

/**
 * @class Dat
 * @extends Super
 * @public
 * @param {Date} [date = new Date()] - A date to wrap.
 * @returns {Dat} Instance of Dat.
 * @description Wrap of a date.
 *
 * @example
 * const date = new Dat(new Date());
 */

var Dat = function (_Super) {
  inherits(Dat, _Super);

  function Dat() {
    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
    classCallCheck(this, Dat);
    return possibleConstructorReturn(this, (Dat.__proto__ || Object.getPrototypeOf(Dat)).call(this, date));

    /**
     * @member Dat#$
     * @type {Date}
     * @public
     * @description Original date.
     */
  }

  /**
   * @method Dat#add
   * @public
   * @param {AddPeriod|Object.<AddPeriod, Number>} what - What to add.
   * @param {Number} [number] - Number of what to add if the first argument is a period string.
   * @returns {Dat} Returns this.
   * @description Method for adding amounts of time to the date. Returns new instance of Dat.
   *
   * @example
   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add('c', 2).toISOString();         // '2000-01-01T00:00:00.001Z'
   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add({ c: 2, d: 5 }).toISOString(); // '2000-01-06T00:00:00.001Z'
   */


  createClass(Dat, [{
    key: 'add',
    value: function add(what, number) {
      if (arguments.length >= 2) {
        what = defineProperty({}, what, number);
      }

      return this.time(this.time() + new Super(what).sum(function (value, what) {
        return coeffs[what] * value;
      }));
    }

    /**
     * @method Dat#expires
     * @public
     * @param {*} [value = this] - Value to resolve after the date expires.
     * @returns {Promise} New instance of Promise.
     * @description Method for defining when the date expires.
     *
     * @example
     * new Dat().add('c', 500).expires('Expired').then((value) => {
     *   // After 500 milliseconds
     *   console.log(value); // 'Expired'
     * });
     */

  }, {
    key: 'expires',
    value: function expires(value) {
      if (!arguments.length) {
        value = this;
      }

      return new Num(this.$ - now()).timeout(value);
    }

    /**
     * @method Dat#format
     * @public
     * @param {String} string - Template for the output.
     * @param {String} [prefix = ''] - If needed [all special strings]{@link Format}
     * are treated as they should be prefix with prefix.
     * @returns {String} Formatted string.
     * @description Method for creating formatted output based on a string.
     *
     * @example
     * new Dat('1999-12-31T23:59:59.999Z').format('Seconds: $ss, milliseconds: $ccc.', '$');
     * // 'Seconds: 59, milliseconds: 999.'
     */

  }, {
    key: 'format',
    value: function format(string) {
      var _this2 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      string = new Str(new Super(string).$);
      prefix = String(new Super(prefix).$);

      iterate(formats, function (format) {
        string = string.replaceString(prefix + format.format, format.match(_this2, 'get'));
      });

      return string.$;
    }

    /**
     * @method Dat#formatUTC
     * @public
     * @param {String} string - See {@link Dat#format}.
     * @param {String} [prefix = ''] - See {@link Dat#format}.
     * @returns {String} Formatted string.
     * @description UTC version of {@link Dat#format}.
     *
     * @example
     * new Dat('1999-07-07T03:09:09.099Z').formatUTC(
     *   `
     *     Milliseconds: $ccc|$c.
     *     Seconds:      $ss|$s.
     *     Minutes:      $mm|$m.
     *     Hours:        $hh|$h.
     *     Day:          $dddd|$ddd|$dd|$d.
     *     Month:        $MMMM|$MMM|$MM|$M.
     *     Year:         $yyyy|$yy|$y.
     *   `,
     *   '$'
     * );
     * // Milliseconds: 099|99.
     * // Seconds:      09|9.
     * // Minutes:      09|9.
     * // Hours:        03|3.
     * // Day:          Friday|Fri|07|7.
     * // Month:        July|Jul|07|7.
     * // Year:         1999|99|1999.
     */

  }, {
    key: 'formatUTC',
    value: function formatUTC(string) {
      var _this3 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      string = new Str(new Super(string).$);
      prefix = String(new Super(prefix).$);

      iterate(formats, function (format) {
        string = string.replaceString(prefix + format.format, format.match(_this3, 'getUTC'));
      });

      return string.$;
    }

    /**
     * @method Dat#get
     * @public
     * @param {GetPeriod} what - What to get.
     * @returns {Number} Number of what to get.
     * @description Method for getting values such as seconds or minutes.
     *
     * @example
     * new Dat(new Date('1999-12-31T23:59:59.999Z')).get('s'); // 59
     */

  }, {
    key: 'get',
    value: function get(what) {
      return getSwitcher(what, [this.$, 'get']);
    }

    /**
     * @method Dat#getUTC
     * @public
     * @param {GetPeriod} what - See {@link Dat#get}.
     * @returns {Number} Number of what to get.
     * @description UTC version of {@link Dat#get}.
     *
     * @example
     * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));
     *
     * date.getUTC('c');  // 999
     * date.getUTC('s');  // 59
     * date.getUTC('m');  // 59
     * date.getUTC('h');  // 23
     * date.getUTC('d');  // 31
     * date.getUTC('dw'); // 5
     * date.getUTC('M');  // 12
     * date.getUTC('y');  // 1999
     */

  }, {
    key: 'getUTC',
    value: function getUTC(what) {
      return getSwitcher(what, [this.$, 'getUTC']);
    }

    /**
     * @method Dat#isAfter
     * @public
     * @param {DateLike} date - Date to be compared to this date.
     * @returns {Boolean} If this date is after the argument one.
     * @description Finds out if this date is after the argument one.
     *
     * @example
     * new Dat(new Date(333)).isAfter(new Date(334)); // false
     * new Dat(new Date(333)).isAfter(new Date(332)); // true
     */

  }, {
    key: 'isAfter',
    value: function isAfter(date) {
      date = new Date(new Super(date).$);

      return date.getTime() < this.$.getTime();
    }

    /**
     * @method Dat#isBefore
     * @public
     * @param {DateLike} date - Date to be compared to this date.
     * @returns {Boolean} If this date is before the argument one.
     * @description Finds out if this date is before the argument one.
     *
     * @example
     * new Dat(new Date(333)).isBefore(new Date(334)); // true
     * new Dat(new Date(333)).isBefore(new Date(332)); // false
     */

  }, {
    key: 'isBefore',
    value: function isBefore(date) {
      date = new Date(new Super(date).$);

      return date.getTime() > this.$.getTime();
    }

    /**
     * @method Dat#isBetween
     * @public
     * @param {DateLike} date1 - Start of the range.
     * @param {DateLike} date2 - End of the range.
     * @returns {Boolean} If this date is after date1 and before date2.
     * @description Finds out if this date is after date1 and before date2.
     *
     * @example
     * new Dat(new Date(333)).isBetween(new Date(332), new Date(334)); // true
     * new Dat(new Date(333)).isBetween(new Date(334), new Date(332)); // false
     */

  }, {
    key: 'isBetween',
    value: function isBetween(date1, date2) {
      var time = this.$.getTime();

      date1 = new Date(new Super(date1).$);
      date2 = new Date(new Super(date2).$);

      return time > date1.getTime() && time < date2.getTime();
    }

    /**
     * @method Dat#isInvalid
     * @public
     * @returns {Boolean} If the date is invalid.
     * @description Returns if the date is invalid.
     *
     * @example
     * new Dat(new Date('a')).isInvalid(); // true
     * new Dat(new Date(1)).isInvalid();   // false
     */

  }, {
    key: 'isInvalid',
    value: function isInvalid() {
      return this.$.toString() === 'Invalid Date';
    }

    /**
     * @method Dat#isPassed
     * @public
     * @returns {Boolean} If the date is passed.
     * @description Returns if the date is passed.
     *
     * @example
     * new Dat(new Date(1)).isPassed(); // true
     */

  }, {
    key: 'isPassed',
    value: function isPassed() {
      return this.isBefore(now());
    }

    /**
     * @method Dat#ofOne
     * @public
     * @param {OfOnePeriod} what - Period to check.
     * @param {DateLike} date - Date to check.
     * @returns {Boolean} If two dates are of one second, minute or something else.
     * @description Returns if two dates are of one second, minute or something else.
     *
     * @example
     * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:59.333Z')); // true
     * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:58.999Z')); // false
     */

  }, {
    key: 'ofOne',
    value: function ofOne(what, date) {
      var _this4 = this;

      if (!(what in coeffs) || what === 'w') {
        return false;
      }

      date = new Dat(new Date(date));

      var started = void 0;

      return iterate(coeffs, function (coeff, w) {
        if (w === what) {
          started = true;
        }

        if (!started || w === 'w') {
          return;
        }

        if (started && _this4.get(w) !== date.get(w)) {
          return false;
        }
      }) !== false;
    }

    /**
     * @method Dat#set
     * @public
     * @param {SetPeriod|Object.<SetPeriod, Number>} what - What to add.
     * @param {Number} [number] - Number of what to set if the first argument is a period string.
     * @returns {Dat} Returns this.
     * @description Method for setting values such as seconds or minutes.
     *
     * @example
     * new Dat(new Date('1999-12-31T23:59:59.999Z')).set('s', 58).get('s');           // 58
     * new Dat(new Date('1999-12-31T23:59:59.999Z')).set({ c: 998, s: 58 }).get('c'); // 998
     */

  }, {
    key: 'set',
    value: function set(what, number) {
      var date = this.$;

      if (arguments.length >= 2) {
        what = defineProperty({}, what, number);
      }

      what = new Super(what).$;

      iterate(what, function (value, what) {
        setSwitcher(what, [date, value, 'set']);
      });

      return this;
    }

    /**
     * @method Dat#setUTC
     * @public
     * @param {SetPeriod|Object.<SetPeriod, Number>} what - See {@link Dat#set}.
     * @param {Number} [number] - See {@link Dat#set}.
     * @returns {Dat} Returns this.
     * @description UTC version of {@link Dat#set}.
     *
     * @example
     * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));
     *
     * date.setUTC('ccc', 998).getUTC('ccc'); // 998
     * date.setUTC({
     *   s: 58,
     *   m: 58,
     *   h: 22
     * });
     *
     * date.getUTC('s'); // 58
     * date.getUTC('m'); // 58
     * date.getUTC('h'); // 23
     */

  }, {
    key: 'setUTC',
    value: function setUTC(what, number) {
      var date = this.$;

      if (arguments.length >= 2) {
        what = defineProperty({}, what, number);
      }

      what = new Super(what).$;

      iterate(what, function (value, what) {
        setSwitcher(what, [date, value, 'setUTC']);
      });

      return this;
    }

    /**
     * @method Dat#setUTC
     * @public
     * @param {Number} [time] - Time to set.
     * @returns {Dat|Number} - If the time argument is present this is returned otherwise the time is returned.
     * @description Synonym for both
     * [Date#getTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime} and
     * [Date#setTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime}.
     */

  }, {
    key: 'time',
    value: function time(_time) {
      var date = this.$;

      if (arguments.length) {
        date.setTime(_time);
      }

      return date.getTime();
    }
  }, {
    key: 'toISOString',
    value: function toISOString() {
      return this.$.toISOString();
    }
  }, {
    key: 'toLocaleString',
    value: function toLocaleString() {
      return this.$.toLocaleString();
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.$.toString();
    }
  }, {
    key: 'valueOf',
    value: function valueOf() {
      return this.$.valueOf();
    }
  }]);
  return Dat;
}(Super);

defineProperties(Dat.prototype, defineProperty({}, _Symbol.toStringTag, 'Dat'));

constructors[1].push({
  check: isDate,
  cls: Dat
});

/**
 * @function now
 * @public
 * @returns {Number} Number of milliseconds.
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now
 * @description Synonym for
 * [Date.now]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now}.
 */
function now() {
  return Date.now();
}

/**
 * @function date
 * @public
 * @param {DateLike} [date = new Date()] - Date-like value that is passed to the Date constructor.
 * @returns {Dat} New instance of Dat.
 * @description Synonym for new Dat(new Date(date));
 */
function date(date) {
  if (!arguments.length) {
    return new Dat(new Date(now()));
  }

  date = new Super(date).$;

  return new Dat(new Date(date));
}

/**
 * @module helpers/constructURL
 * @private
 * @description Exports constructURL method.
 */

/**
 * @type {RegExp}
 * @description Absolute URL pattern.
 */
var absoluteURLRegexp = /^(([a-z][a-z\d+\-.]*:)?\/\/|data:[a-z]+\/[a-z]+;base64,)/i;
var querySwitcher = switcher('call', function () {
  return new Arr([]);
}).case(isArray, function (prefix, query) {
  var queryParams = new Arr([]);

  iterate(query, function (value) {
    if (isPlainObject(value) || isArray(value)) {
      queryParams = queryParams.concat(querySwitcher(value, [prefix + '[]']));

      return;
    }

    queryParams.push({
      param: prefix + '[]',
      value: value
    });
  });

  return queryParams.$;
}).case(isPlainObject, function (prefix, query) {
  var queryParams = new Arr([]);

  iterate(query, function (value, param) {
    if (isPlainObject(value) || isArray(value)) {
      queryParams = queryParams.concat(querySwitcher(value, [prefix ? prefix + '[' + param + ']' : param]));

      return;
    }

    queryParams.push({
      param: prefix ? prefix + '[' + param + ']' : param,
      value: isObject(value) ? JSON.stringify(value) : String(value)
    });
  });

  return queryParams.$;
});

/**
 * @function constructURL
 * @param {String} baseURL - BaseURL of the output URL.
 * @param {String} url - Main part of the output URL.
 * @param {Object} params - Params to replace in the url expressions like ":param".
 * @param {Object} query - Object with query params.
 * @param {Object} [hash = ''] - URL hash.
 * @param {Object} [encodeOptions = {}] - If you need to encode something.
 * @param {Object} [encodeOptions.params = true] - If you need to encode params.
 * @param {Object} [encodeOptions.query = true] - If you need to encode query params.
 * @returns {String} Constructed URL.
 * @description Function for constructing URL from the base URL, URL, params and query params.
 */
var constructURL = (function (baseURL, url, params, query) {
  var hash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  var encodeOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  var _encodeOptions$params = encodeOptions.params,
      encodeParams = _encodeOptions$params === undefined ? true : _encodeOptions$params,
      _encodeOptions$query = encodeOptions.query,
      encodeQuery = _encodeOptions$query === undefined ? true : _encodeOptions$query;

  var URL = isAbsolute(url) ? url : String(baseURL).replace(/\/+$/, '') + '/' + String(url).replace(/^\/+/, '');

  iterate(params, function (value, param) {
    URL = new Str(URL).replaceString(':' + param, encode(value, encodeParams)).$;
  });

  var queryParams = querySwitcher(query, ['']);

  if (queryParams.length) {
    URL += (URL.indexOf('?') === -1 ? '?' : '&') + queryParams.map(function (_ref) {
      var param = _ref.param,
          value = _ref.value;
      return encode(param, encodeQuery) + '=' + encode(value, encodeQuery);
    }).join('&');
  }

  return '' + URL + (hash ? '#' + hash : '');
});

/**
 * @function isAbsolute
 * @param {String} url - URL to check if it is absolute or not.
 * @returns {Boolean} If the argument URL is absolute or not.
 */
function isAbsolute(url) {
  return absoluteURLRegexp.test(url);
}

/**
 * @function encode
 * @param {String} string - String to encode using encodeURIComponent.
 * @param {Boolean} isEncoded - If the string should be encoded.
 * @returns {String} Encoded string.
 */
function encode(string, isEncoded) {
  return isEncoded ? encodeURIComponent(string) : string;
}

/**
 * @module helpers/parseHeaders
 * @private
 * @description Exports parseHeaders method.
 */

/**
 * @function parseHeaders
 * @param {String} rawHeaders - Raw headers.
 * @returns {Object} Headers object
 * @description Function for parsing raw headers.
 */
var parseHeaders = (function (rawHeaders) {
  var headers = {};

  iterate((rawHeaders || '').split('\n'), function (value) {
    var index = value.indexOf(':');
    var key = new Str(value.substring(0, index)).trim().toCamelCase().$;
    var val = new Str(value.substring(index + 1)).trim().$;

    if (key) {
      headers[key] = (headers[key] ? headers[key] + ', ' : '') + val;
    }
  });

  return headers;
});

/**
 * @module helpers/transformData
 * @private
 * @description Exports transformData method.
 */

var notToTransform = new Arr(['FormData', 'File', 'Blob', 'ArrayBuffer', 'String', 'Number']);
var withoutBody = new Arr(['DELETE', 'GET', 'HEAD']);

/**
 * @function transformData
 * @param {*} data - Data to transform
 * @param {String} method - HTTP method.
 * @param {Object} headers - Object with headers.
 * @returns {*} - Transformed data.
 */
var transformData = (function (data, method, headers) {
  data = new Super(data).$;

  if (withoutBody.indexOfStrict(method) !== -1) {
    return null;
  }

  if (isObject(data) && notToTransform.indexOfStrict(toStringTag(data)) === -1) {
    if (!headers.contentType) {
      headers.contentType = ['application/json;charset=utf-8'];
    }

    return new Super(data).json();
  }

  return data;
});

/**
 * @module Fetch
 * @private
 * @mixin
 * @description Exports Fetch class.
 */

/**
 * @typedef {'get'|'post'|'delete'|'head'|'put'|'patch'} FetchMethod
 * @public
 */

/**
 * @typedef {Object} FetchConfig
 * @public
 * @property {Array.<AfterMiddleware|FetchErrorAfterMiddleware>} [after]
 * @property {Object} [auth]
 * @property {String} [auth.username]
 * @property {String} [auth.password]
 * @property {String} [baseURL]
 * @property {Array.<BeforeMiddleware|FetchErrorBeforeMiddleware>} [before]
 * @property {*} [data]
 * @property {Object.<String, String[]>} [headers]
 * @property {FetchMethod} [method]
 * @property {Object} [params]
 * @property {Object} [query]
 * @property {String} [responseType]
 * @property {Number} [timeout]
 * @property {String} [url]
 * @property {Boolean} [withCredentials]
 */

/**
 * @typedef {Object} FetchResponse
 * @public
 * @property {FetchConfig} config
 * @property {*} data
 * @property {Object.<String, String>} headers
 * @property {Number} status
 * @property {String} statusText
 * @property {XMLHttpRequest} xhr
 */

/**
 * @callback FetchAfterMiddleware
 * @public
 * @param {FetchResponse} config - Fetch response.
 */

/**
 * @callback FetchErrorAfterMiddleware
 * @public
 * @param {Error|*} err - Thrown error.
 * @param {FetchResponse} config - Fetch response.
 */

/**
 * @callback FetchBeforeMiddleware
 * @public
 * @param {FetchConfig} config - Fetch config.
 */

/**
 * @callback FetchErrorBeforeMiddleware
 * @public
 * @param {Error|*} err - Thrown error.
 * @param {FetchConfig} config - Fetch config.
 */

/**
 * @callback FetchConfigFunction
 * @public
 * @param {FetchConfig} config
 */

var defaults$1 = {
  after: [],
  auth: {
    username: '',
    password: ''
  },
  baseURL: global$1.location.origin,
  before: [],
  data: null,
  headers: {},
  method: 'get',
  params: {},
  query: {},
  responseType: '',
  timeout: 0,
  url: '',
  withCredentials: false
};
var uploadMethods = new Arr(['post', 'put']);

/**
 * @class Fetch
 * @extends Function
 * @public
 * @param {FetchConfig} [config = {}] - A number to wrap.
 * @returns {Fetch} Instance of Fetch.
 * An instance of Fetch is a function that simply calls #request with the same arguments.
 * @description Class for fetching data.
 *
 * @example
 * const fetch = new Fetch();
 *
 * fetch('/data').then((res) => {
 *   console.log(res);
 * });
 */

var Fetch = function (_Function) {
  inherits(Fetch, _Function);

  function Fetch() {
    var _ret;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Fetch);

    var _this = possibleConstructorReturn(this, (Fetch.__proto__ || Object.getPrototypeOf(Fetch)).call(this));

    function fetch() {
      return fetch.request.apply(fetch, arguments);
    }

    var conf = new Super({}).deepAssign(defaults$1, config).$;

    if (conf.before.indexOf(fetchBeforeMiddleware) === -1) {
      conf.before.push(fetchBeforeMiddleware);
    }

    /**
     * @member {FetchConfig} Fetch#$$
     * @type {FetchConfig}
     * @public
     * @description Fetch config.
     */
    Object.defineProperty(fetch, '$$', { value: conf });
    Object.setPrototypeOf(fetch, Fetch.prototype);

    return _ret = fetch, possibleConstructorReturn(_this, _ret);
  }

  /**
   * @method Fetch#after
   * @public
   * @param {FetchAfterMiddleware|FetchErrorAfterMiddleware} middleware - Middleware to add.
   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put the middleware.
   * Truthy parameter stands for "to the end" and falsey for "to the beginning".
   * @returns {Fetch} Returns this.
   * @description Middleware that is called after the request.
   * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.
   * If the middleware returns a promise it becomes a part of the middleware chain.
   *
   * @example
   * const fetch = new Fetch()
   *   .after((err, res) => {
   *     console.log(err);
   *
   *     throw err;
   *   })
   *   .after((res) => {
   *     res.json = D(res.data).parseJSON():
   *   });
   */


  createClass(Fetch, [{
    key: 'after',
    value: function after(middleware) {
      var afterAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      validate$1([middleware], ['function'], 'Fetch#after');

      var after = this.$$.after;


      if (afterAll) {
        after.push(middleware);
      } else {
        after.unshift(middleware);
      }

      return this;
    }

    /**
     * @method Fetch#before
     * @public
     * @param {FetchBeforeMiddleware|FetchErrorBeforeMiddleware} middleware - Middleware to add.
     * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put the middleware.
     * Truthy parameter stands for "to the beginning" and falsey for "to the end".
     * @returns {Fetch} Returns this.
     * @description Middleware that is called before the request.
     * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.
     * If the middleware returns a promise it becomes a part of the middleware chain.
     *
     * @example
     * const fetch = new Fetch()
     *   .before((err, req) => {
     *     console.log(err);
     *
     *     throw err;
     *   })
     *   .before((req) => {
     *     if (req.url === '/veryLongRequest') {
     *       req.timeout = 30000;
     *     }
     *   });
     */

  }, {
    key: 'before',
    value: function before(middleware) {
      var beforeAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      validate$1([middleware], ['function'], 'Fetch#before');

      var before = this.$$.before;


      if (beforeAll) {
        before.unshift(middleware);
      } else {
        before.push(middleware);
      }

      return this;
    }

    /**
     * @method Fetch#config
     * @public
     * @param {String|FetchConfig|FetchConfigFunction} [property] - If it's a function
     * it's called with the fetch config argument, if it's a string the value argument
     * is used for assigning this property to the fetch config
     * otherwise it's assigned to the fetch config.
     * @param {*} [value] - See the property argument.
     * @returns {Fetch|FetchConfig} If the argument is present this is returned otherwise the fetch config is returned.
     * @description Method for getting and setting config.
     *
     * @example
     * const fetch = new Fetch();
     *
     * fetch.config({ baseURL: 5000 });
     * fetch.config().timeout; // 5000
     *
     * fetch.config((config) => {
     *   config.baseURL += '/api';
     * });
     */

  }, {
    key: 'config',
    value: function config(property, value) {
      var conf = this.$$;

      if (!arguments.length) {
        return conf;
      }

      if (isFunction(property)) {
        property(conf);
      } else {
        if (arguments.length >= 2) {
          property = defineProperty({}, property, value);
        }

        new Super(conf).deepAssign(property);
      }

      return this;
    }

    /**
     * @method Fetch#delete
     * @public
     * @param {String} [url] - See {@link Fetch#request}.
     * @param {FetchConfig} [config] - See {@link Fetch#request}.
     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.
     * @description Shorthand for #request for delete requests.
     *
     * @example
     * new Fetch().delete('/data').then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'delete',
    value: function _delete(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isString(url)) {
        config = url;
        url = undefined;
      }

      return this.request(url, assign$1({ method: 'delete' }, config));
    }

    /**
     * @method Fetch#get
     * @public
     * @param {String} [url] - See {@link Fetch#request}.
     * @param {FetchConfig} [config] - See {@link Fetch#request}.
     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.
     * @description Shorthand for #request for get requests.
     *
     * @example
     * new Fetch().get('/data').then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'get',
    value: function get(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isString(url)) {
        config = url;
        url = undefined;
      }

      return this.request(url, assign$1({ method: 'get' }, config));
    }

    /**
     * @method Fetch#head
     * @public
     * @param {String} [url] - See {@link Fetch#request}.
     * @param {FetchConfig} [config] - See {@link Fetch#request}.
     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.
     * @description Shorthand for #request for head requests.
     *
     * @example
     * new Fetch().head('/data').then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'head',
    value: function head(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isString(url)) {
        config = url;
        url = undefined;
      }

      return this.request(url, assign$1({ method: 'head' }, config));
    }

    /**
     * @method Fetch#headers
     * @public
     * @param {String|Object.<String, String|String[]>} header - A header string or an object of the following format:
     * { [header]: [value1, value2, ...] }.
     * @param {String|String[]} [value] - Header value. If the first argument is a string
     * this has to be a header value or an array of header values.
     * @returns {Fetch} Returns this.
     * @description Method for setting request headers.
     *
     * @example
     * const fetch = new Fetch()
     *   .headers('Header1', 'Value')
     *   .headers('Header2', ['Value1', 'Value2'])
     *   .headers({
     *     Header3: ['Value1', 'Value2']
     *   });
     */

  }, {
    key: 'headers',
    value: function headers(header, value) {
      var headers = this.$$.headers;


      if (arguments.length >= 2) {
        header = defineProperty({}, header, value);
      }

      iterate(header, function (value, header) {
        var array$$1 = headers[header] || [];
        var toPush = isArray(value) ? value : [value];

        (headers[header] = array$$1).push.apply(array$$1, toPush);
      });

      return this;
    }

    /**
     * @method Fetch#instance
     * @public
     * @param {FetchConfig} [config] - New config if needed.
     * @returns {Fetch} New instance of Fetch.
     * @description Method for creating new fetch instances based on already existent.
     *
     * @example
     * const mainFetch = new Fetch({
     *   baseURL: '//other.domain.com/api',
     *   withCredentials: true
     * });
     *
     * const longFetch = mainFetch.instance({
     *   timeout: 10000
     * });
     */

  }, {
    key: 'instance',
    value: function instance() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var dataConfig = new Super(config).hasOwn('data') ? { data: config.data } : {};

      delete config.data;

      var conf = new Super({}).deepAssign(this.$$, config).assign(dataConfig).$;

      return new Fetch(conf);
    }

    /**
     * @method Fetch#patch
     * @public
     * @param {String} [url] - See {@link Fetch#request}.
     * @param {*} [data] - Additional parameter for uploading data.
     * @param {FetchConfig} [config] - See {@link Fetch#request}.
     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.
     * @description Shorthand for #request for head requests.
     *
     * @example
     * new Fetch().patch('/data', { user: 'John' }).then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'patch',
    value: function patch(url) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (arguments.length && !isString(url)) {
        config = data;
        data = url;
        url = undefined;
      }

      return this.request(url, assign$1({ method: 'patch', data: data }, config));
    }

    /**
     * @method Fetch#post
     * @public
     * @param {String} [url] - See {@link Fetch#request}.
     * @param {*} [data] - Additional parameter for uploading data.
     * @param {FetchConfig} [config] - See {@link Fetch#request}.
     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.
     * @description Shorthand for #request for head requests.
     *
     * @example
     * new Fetch().post('/data', { user: 'John' }).then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'post',
    value: function post(url) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (arguments.length && !isString(url)) {
        config = data;
        data = url;
        url = undefined;
      }

      return this.request(url, assign$1({ method: 'post', data: data }, config));
    }

    /**
     * @method Fetch#put
     * @public
     * @param {String} [url] - See {@link Fetch#request}.
     * @param {*} [data] - Additional parameter for uploading data.
     * @param {FetchConfig} [config] - See {@link Fetch#request}.
     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.
     * @description Shorthand for #request for head requests.
     *
     * @example
     * new Fetch().put('/data', { user: 'John' }).then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'put',
    value: function put(url) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (arguments.length && !isString(url)) {
        config = data;
        data = url;
        url = undefined;
      }

      return this.request(url, assign$1({ method: 'put', data: data }, config));
    }

    /**
     * @method Fetch#request
     * @public
     * @param {String} [url] - URL for the request.
     * @param {FetchConfig} [config] - Additional config for this particular request.
     * @returns {Promise.<FetchResponse, Error>} Promise that is resolved with the request response.
     * @description Main function for making requests. All request methods call this method
     * including the fetch instance itself.
     *
     * @example
     * const fetch = new Fetch();
     *
     * fetch.request('/data', { timeout: 1000 }).then((res) => {
     *   console.log(res);
     * });
     *
     * fetch.request({ timeout: 1000 }).then((res) => {
     *   console.log(res);
     * });
     *
     * fetch.request().then((res) => {
     *   console.log(res);
     * });
     */

  }, {
    key: 'request',
    value: function request(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (arguments.length === 1 && !isString(url)) {
        config = url;
      }

      var dataConfig = new Super(config).hasOwn('data') ? { data: config.data } : {};
      var urlConfig = isString(url) ? { url: url } : {};

      delete config.data;

      var conf = new Super(this.$$).deepClone().deepAssign(urlConfig, config).assign(dataConfig).$;

      var xhr = void 0;
      var promise = Promise$1.resolve();

      iterate(conf.before, function (middleware) {
        promise = promise.then(function () {
          if (middleware.length >= 2) {
            return Promise$1.resolve();
          }

          return new Promise$1(function (resolve) {
            resolve(middleware(conf));
          });
        }, function (err) {
          if (middleware.length < 2) {
            return Promise$1.reject(err);
          }

          return new Promise$1(function (resolve) {
            resolve(middleware(err, conf));
          });
        });
      });

      promise = promise.then(function () {
        return new Promise$1(function (resolve, reject) {
          var after = conf.after,
              _conf$auth = conf.auth,
              username = _conf$auth.username,
              password = _conf$auth.password,
              data = conf.data,
              headers = conf.headers,
              method = conf.method,
              onprogress = conf.onprogress,
              responseType = conf.responseType,
              timeout = conf.timeout,
              url = conf.url,
              withCredentials = conf.withCredentials;


          xhr = new XMLHttpRequest();

          xhr.open(method, url, true, username, password);

          iterate(headers, function (value, header) {
            xhr.setRequestHeader(header, value);
          });

          if (onprogress) {
            if (uploadMethods.indexOfStrict(method) === -1) {
              xhr.onprogress = onprogress;
            } else {
              xhr.upload.onprogress = onprogress;
            }
          }

          xhr.onabort = function () {
            var error = new Error('Request was aborted');

            error.type = 'ABORT_ERROR';

            reject(error);

            xhr = null;
          };

          xhr.onerror = function () {
            var error = new Error('Network error');

            error.type = 'NETWORK_ERROR';

            reject(error);

            xhr = null;
          };

          xhr.ontimeout = function () {
            var error = new Error('Request time exceeded');

            error.type = 'TIMEOUT_ERROR';

            reject(error);

            xhr = null;
          };

          xhr.onreadystatechange = function () {
            if (!xhr || !xhr.status || xhr.readyState !== 4) {
              return;
            }

            var response = {
              config: conf,
              data: !responseType || responseType === 'text' ? xhr.responseText : xhr.response,
              headers: parseHeaders(xhr.getAllResponseHeaders()),
              status: xhr.status === 1223 ? 204 : xhr.status,
              statusText: xhr.status === 1223 ? 'No Content' : xhr.statusText,
              xhr: xhr
            };

            var promise = Promise$1.resolve();

            iterate(after, function (middleware) {
              promise = promise.then(function () {
                if (middleware.length >= 2) {
                  return Promise$1.resolve();
                }

                return new Promise$1(function (resolve) {
                  resolve(middleware(response));
                });
              }, function (err) {
                if (middleware.length < 2) {
                  return Promise$1.reject(err);
                }

                return new Promise$1(function (resolve) {
                  resolve(middleware(err, response));
                });
              });
            });

            resolve(promise.then(function () {
              return response;
            }).catch(function (err) {
              try {
                err.response = response;
              } catch (e) {
                throw err;
              }

              throw err;
            }));
          };

          xhr.responseType = responseType;
          xhr.timeout = Number(timeout) || 0;
          xhr.withCredentials = !!withCredentials;

          xhr.send(data);
        });
      });

      promise.abort = function abort() {
        if (xhr) {
          xhr.abort();
        }

        return this;
      };

      return promise;
    }
  }]);
  return Fetch;
}(Function);

defineProperties(Fetch.prototype, defineProperty({}, _Symbol.toStringTag, 'Fetch'));

/**
 * @function fetchBeforeMiddleware
 * @private
 * @param {FetchConfig} config
 * @description Built-in before middleware for url, data, method, headers construction.
 */
function fetchBeforeMiddleware(config) {
  var baseURL = config.baseURL,
      data = config.data,
      headers = config.headers,
      method = config.method,
      params = config.params,
      query = config.query,
      url = config.url;

  var METHOD = method.toUpperCase();

  config.method = METHOD;
  config.url = constructURL(baseURL, url, params, query);
  config.data = transformData(data, METHOD, headers);
  config.headers = new Super(headers).object(function (headers, values, header) {
    header = new Str(header).toCapitalCase().replace(/\s+/g, '-').$;

    headers[header] = values.join(', ');
  }).$;
}

/**
 * @const {Fetch} fetch
 * @type {Fetch}
 * @public
 * @description Empty instance of Fetch.
 */
var fetch = new Fetch();

/**
 * @module helpers/resolveURL
 * @private
 * @description Exports Object.assign-like method.
 */

var _global$3 = global$1;
var location$1 = _global$3.location;


var resolveURL = (function (decodeQuery) {
  var query = location$1.search,
      hash = location$1.hash;

  var params = {
    query: {},
    hash: hash.replace(/^#/, '')
  };

  if (!query) {
    return params;
  }

  new Str(query.replace(/^\?/, '')).split('&').forEach(function (rawParam) {
    var _rawParam$split = rawParam.split('='),
        _rawParam$split2 = slicedToArray(_rawParam$split, 2),
        param = _rawParam$split2[0],
        _rawParam$split2$ = _rawParam$split2[1],
        value = _rawParam$split2$ === undefined ? '' : _rawParam$split2$;

    param = decodeQuery ? decodeURIComponent(param) : param;
    value = decodeQuery ? decodeURIComponent(value) : value;

    if (!/^[^[]+/.test(param)) {
      return;
    }

    var paramName = void 0;
    var paramObject = params.query;

    new Str(param).match(/^[^[\]]*|\[[^[\]]*]/g).forEach(function (name) {
      if (name.indexOf('[')) {
        paramName = name;

        return;
      }

      name = name.slice(1, -1);

      paramObject = paramObject[paramName] = paramObject[paramName] || (name ? {} : []);
      paramName = name || paramObject.length;
    });

    paramObject[paramName] = value;
  });

  return params;
});

/**
 * @module Router
 * @private
 * @mixin
 * @description Exports Router.
 */

var Routes = new Arr([]);
var currentRoutes = new Arr([]);
var subscribers = new Super({});
var _global$2 = global$1;
var history = _global$2.history;
var location = _global$2.location;
var _global$location = _global$2.location;
var origin = _global$location.origin;
var href = _global$location.href;

var initialized = void 0;
var pushed = void 0;
var wasRoot = void 0;
var wasDefault = void 0;
var rootRoute = void 0;
var redirectRoute = void 0;
var RedirectRoute = void 0;
var defaultRoute = void 0;
var DefaultRoute = void 0;
var currentRoute = void 0;
var currentRouteParams = void 0;

var pathSwitcher = switcher('call', function () {
  throw new Error('State path must be a string, a regular expression or undefined! (at registerState)');
}).case(isRegExp, function (path) {
  return {
    path: path.source.replace(/\\\//g, '/'),
    url: path,
    params: {}
  };
}).case(isNil, function () {
  return {
    path: '/',
    url: '/',
    params: {}
  };
}).case(isString, function (path) {
  if (path.indexOf('/')) {
    throw new Error('If route path is a string it must start with "/"! (at registerState)');
  }

  var index = path.indexOf('?');
  var params = new Super({});
  var newURL = '';
  var newPath = new Str(path).slice(0, index === -1 ? path.length : index).replace(/^\/|\/$/g).split(/\//).map(function (part, i, array$$1) {
    if (!part && array$$1.length > 1) {
      throw new Error('If route path is a string it must not contain "//" or end with "/"! (at makeRoute)');
    }

    var index = part.indexOf(':');

    if (index > 0) {
      throw new Error('If route path is a string resource part must be either a string or an URL parameter! (at makeRoute)');
    }

    if (index === -1) {
      return {
        url: part,
        value: part
      };
    }

    var _resolveParameter = resolveParameter(part.slice(1), 'URL parameter must not be an empty string or contain characters besides "a-zA-Z_$"! (at makeRoute)', 'URL parameter regexp validator must be within parentheses (e.g. :userId(\\d+) and not contain ones)! (at makeRoute)'),
        name = _resolveParameter.name,
        _resolveParameter$reg = _resolveParameter.regexp,
        regexp = _resolveParameter$reg === undefined ? /[^/]*/ : _resolveParameter$reg;

    params.$[name] = params.count;

    return {
      type: 'param',
      url: ':' + name,
      value: regexp
    };
  }).word(function (_ref) {
    var type = _ref.type,
        url = _ref.url,
        value = _ref.value;

    var newPath = void 0;

    if (type === 'param') {
      newPath = '(' + value.source.replace(/\\\//g, '/') + ')';
    } else {
      newPath = new Str(value).escapeRegExp().$;
    }

    newURL += '/' + url;

    return '/' + newPath;
  });

  return {
    path: newPath,
    url: newURL,
    params: params.$
  };
});

var Route = function Route(options) {
  classCallCheck(this, Route);

  options = options || {};

  var _ref2 = options || {},
      name = _ref2.name,
      _ref2$path = _ref2.path,
      path = _ref2$path === undefined ? '/' : _ref2$path,
      _ref2$abstract = _ref2.abstract,
      abstract = _ref2$abstract === undefined ? false : _ref2$abstract,
      parent = _ref2.parent,
      _ref2$decodeQuery = _ref2.decodeQuery,
      decodeQuery = _ref2$decodeQuery === undefined ? true : _ref2$decodeQuery,
      _ref2$encodeQuery = _ref2.encodeQuery,
      encodeQuery = _ref2$encodeQuery === undefined ? true : _ref2$encodeQuery,
      _ref2$decodeParams = _ref2.decodeParams,
      decodeParams = _ref2$decodeParams === undefined ? true : _ref2$decodeParams,
      _ref2$encodeParams = _ref2.encodeParams,
      encodeParams = _ref2$encodeParams === undefined ? true : _ref2$encodeParams;

  var _pathSwitcher = pathSwitcher(path),
      relativeURL = _pathSwitcher.url,
      relativePath = _pathSwitcher.path,
      params = _pathSwitcher.params;

  var query = {};

  new Super(this).assign({
    name: name,
    parentName: parent,
    abstract: !!abstract,
    children: new Arr([]),
    decodeParams: !!decodeParams,
    decodeQuery: !!decodeQuery,
    encodeParams: !!encodeParams,
    encodeQuery: !!encodeQuery,
    params: params,
    query: query,
    relativePath: relativePath,
    relativeURL: relativeURL
  });

  var index = isString(path) ? path.indexOf('?') : -1;

  if (index !== -1) {
    new Str(path).replace(/&$/).slice(index + 1).split('&').forEach(function (param) {
      var _resolveParameter2 = resolveParameter(param, 'Query parameter must not be an empty string or contain characters besides "a-zA-Z_$"! (at makeRoute)', 'Query parameter regexp validator must be within parentheses (e.g. :userId(\\d+)) and not contain them! (at makeRoute)'),
          name = _resolveParameter2.name,
          _resolveParameter2$re = _resolveParameter2.regexp,
          regexp = _resolveParameter2$re === undefined ? /[\s\S]*/ : _resolveParameter2$re;

      query[name] = new RegExp('^' + regexp.source.replace(/\\\//g, '/') + '$');
    });
  }

  if (name === defaultRoute && (new Super(params).count || new Super(query).count)) {
    throw new Error('Default route must not have URL or query params! (at makeRoute)');
  }
};

var baseRoute = new Route();

function initRouter() {
  if (initialized) {
    return;
  }

  initialized = true;
  RedirectRoute = (Routes.find(function (_ref3) {
    var name = _ref3.name;
    return name === redirectRoute;
  }) || {}).value;
  DefaultRoute = (Routes.find(function (_ref4) {
    var name = _ref4.name;
    return name === defaultRoute;
  }) || {}).value;

  if (redirectRoute && !RedirectRoute) {
    throw new Error('There is no specified fallback route ("' + redirectRoute + '")! (at initRouter)');
  }

  Routes.forEach(function (route) {
    var parentName = route.parentName,
        name = route.name;

    var ParentName = parentName || rootRoute;

    var _ref5 = Routes.find(function (_ref6) {
      var name = _ref6.name;
      return name === ParentName;
    }) || {},
        parent = _ref5.value;

    if (!parent) {
      throw new Error('No such parent route ("' + ParentName + '") found for the route ("' + name + '")! (at initRouter)');
    }

    if (!parent.abstract && name !== rootRoute) {
      throw new Error('Parent route must be abstract (for "' + name + '")! (at initRouter)');
    }

    if (name !== rootRoute) {
      route.parentName = ParentName;
    }

    route.parent = name === rootRoute ? baseRoute : parent;
  }).forEach(function (route) {
    var name = route.name,
        _route$parent = route.parent,
        parentParams = _route$parent.params,
        parentQuery = _route$parent.query,
        path = _route$parent.path,
        params = route.params,
        query = route.query,
        relativeURL = route.relativeURL,
        relativePath = route.relativePath;

    var proto = route;
    var count = 0;
    var newPath = relativePath;
    var newURL = '';

    if (isRegExp(path)) {
      throw new Error('URL regexp route cannot be extended! (at initRouter)');
    }

    while (proto = proto.parent) {
      count += new Super(proto.params).count;
      newPath = proto.relativePath + newPath;
      newURL = proto.relativeURL + newURL;

      proto.children.push(route);
    }

    newPath = new RegExp('^' + (newPath.replace(/\/+/g, '/').replace(/\/$/, '') || '/') + '$');
    newURL = isRegExp(relativeURL) ? newPath : (newURL + relativeURL).replace(/\/+/g, '/').replace(/\/$/, '') || '/';

    new Super(query).proto(parentQuery);
    new Super(params).proto(parentParams).forEach(function (value, key, params) {
      params[key] += count;
    });

    if (name === defaultRoute && (new Super(params).count || new Super(query).count)) {
      throw new Error('Default route must not have URL or query params! (at initRouter)');
    }

    route.url = newURL;
    route.validatePath = newPath;
  });

  changeRoute();

  win.on({
    popstate: function popstate() {
      if (location.href !== href) {
        pushed = true;
      }

      if (pushed) {
        changeRoute();
      }
    },
    click: function click(e) {
      var closestLink = new Elem(e.target).closest('a');

      if (closestLink.length && closestLink.attr('target') !== '_blank') {
        var push = !closestLink.hasAttr('replace');

        e.preventDefault();

        forward(closestLink.attr('href') || '', push);
      }
    }
  });
}

function makeRoute(options) {
  return function (Block) {
    var _class, _temp;

    options = assign$1({}, options, Block.routerOptions);

    var _ref7 = options || {},
        name = _ref7.name,
        path = _ref7.path,
        abstract = _ref7.abstract,
        root = _ref7.root,
        fallbackTo = _ref7.fallbackTo,
        isDefault = _ref7.default;

    if (initialized) {
      console.warn('Router was already initialized (at makeRoute)');

      return self$1;
    }

    if (wasRoot && root) {
      throw new Error('There can\'t be two root routes ("' + rootRoute + '" and "' + name + '")! (at makeRoute)');
    }

    if (wasDefault && isDefault) {
      throw new Error('There can\'t be two default routes ("' + defaultRoute + '" and "' + name + '")! (at makeRoute)');
    }

    if (!name) {
      throw new Error('State must have a non-empty string "name" property! (at makeRoute)');
    }

    if (Routes.some(function (_ref8) {
      var Name = _ref8.name;
      return Name === name;
    })) {
      throw new Error('State must have unique "name" property! (at makeRoute)');
    }

    if (root) {
      wasRoot = true;
      rootRoute = name;
      options.parent = null;

      if (fallbackTo) {
        redirectRoute = fallbackTo;
      }
    }

    if (isDefault) {
      wasDefault = true;
      defaultRoute = name;

      if (abstract) {
        throw new Error('Default route can\'t be abstract! (at makeRoute)');
      }

      if (isRegExp(path)) {
        throw new Error('Default route can\'t have a regexp path! (at makeRoute)');
      }
    }

    var route = new Route(options);

    Routes.push(route);

    var unsubscribe = void 0;
    var routeLoaded = void 0;

    return _temp = _class = function (_Block) {
      inherits(_class, _Block);

      function _class(opts) {
        classCallCheck(this, _class);

        var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, opts));

        if (root) {
          (function () {
            initRouter();

            var router = {
              buildURL: function buildURL(name) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                var _ref9 = Routes.find(function (_ref10) {
                  var n = _ref10.name;
                  return n === name;
                }) || {},
                    route = _ref9.value;

                if (!route) {
                  throw new Error('There are no routes with name "' + name + '"! (at router.buildURL)');
                }

                var url = route.url,
                    encodeParams = route.encodeParams,
                    encodeQuery = route.encodeQuery;


                if (isRegExp(url)) {
                  throw new Error('URL can be built only from the string URLs! (at router.buildURL)');
                }

                var _options$params = options.params,
                    params = _options$params === undefined ? {} : _options$params,
                    _options$query = options.query,
                    query = _options$query === undefined ? {} : _options$query,
                    _options$hash = options.hash,
                    hash = _options$hash === undefined ? '' : _options$hash;


                return constructURL(origin, url, params, query, hash, {
                  params: encodeParams,
                  query: encodeQuery
                });
              },
              go: function go(name, options) {
                forward(router.buildURL(name, options), true);
              },
              goToURL: function goToURL(url) {
                forward(url, true);
              },
              pushURL: function pushURL(url) {
                changeHistory(url, true);
              },
              redirect: function redirect(name, options) {
                forward(router.buildURL(name, options));
              },
              redirectToURL: function redirectToURL(url) {
                forward(url);
              },
              replaceURL: function replaceURL(url) {
                changeHistory(url);
              }
            };

            _this.global.router = router;
          })();
        }

        _this.__routerInstance__ = route;
        _this.__isCurrentRoute__ = route === currentRoute || route.children.indexOf(currentRoute) !== -1;
        _this.args.route = currentRouteParams;

        routeLoaded = false;
        unsubscribe = subscribe(name, function () {
          var isCurrentRoute = route === currentRoute || route.children.indexOf(currentRoute) !== -1;

          if (isCurrentRoute) {
            callBeforeLoad(_this);
          } else {
            callBeforeLeave(_this);
          }

          if (route === currentRoute) {
            _this.args.route = currentRouteParams;
          }

          _this.__isCurrentRoute__ = isCurrentRoute;
        });

        if (_this.__isCurrentRoute__) {
          callBeforeLoad(_this);
        }
        return _this;
      }
      /* eslint prefer-template: 0 */


      createClass(_class, [{
        key: 'beforeRemove',
        value: function beforeRemove() {
          unsubscribe();
          unsubscribe = null;
          callBeforeLeave(this);
          get$1(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'beforeRemove', this).call(this);
        }
      }]);
      return _class;
    }(Block), _class.template = '<div' + (' class="dwayne-route route-' + name + '"') + ' d-class="{{ \'active-route\': __isCurrentRoute__ }}"' + ' d-show="{__isCurrentRoute__}"' + '>' + Block.template + '</div>', _temp;

    function callBeforeLoad(route) {
      if (routeLoaded) {
        return;
      }

      var block = {
        $$: {
          children: new Arr([route])
        }
      };

      block.$$.children.forEach(function beforeLoad(block) {
        var route = block.__routerInstance__;

        if (route) {
          var index = currentRoutes.indexOf(block);
          var isCurrentRoute = route === currentRoute || route.children.indexOf(currentRoute) !== -1;

          if (index !== -1 || !isCurrentRoute) {
            return;
          }

          currentRoutes.push(block);
        }

        var _block$$$ = block.$$,
            name = _block$$$.name,
            children = _block$$$.children,
            mixins = _block$$$.mixins;


        if (children) {
          children.forEach(beforeLoad);
        }

        if (mixins) {
          mixins.forEach(beforeLoad);
        }

        if (block.beforeLoadRoute) {
          try {
            block.beforeLoadRoute();
          } catch (err) {
            console.error('Uncaught error in ' + name + '#beforeLeave:', err);
          }
        }
      });

      routeLoaded = true;
    }

    function callBeforeLeave(route) {
      if (!routeLoaded) {
        return;
      }

      var block = {
        $$: {
          children: new Arr([route])
        }
      };

      block.$$.children.forEach(function beforeLeave(block) {
        var route = block.__routerInstance__;

        if (route) {
          var index = currentRoutes.indexOf(block);
          var isCurrentRoute = route === currentRoute || route.children.indexOf(currentRoute) !== -1;

          if (index === -1 || isCurrentRoute) {
            return;
          }

          currentRoutes.splice(index, 1);
        }

        var _block$$$2 = block.$$,
            name = _block$$$2.name,
            children = _block$$$2.children,
            mixins = _block$$$2.mixins;


        if (children) {
          children.forEach(beforeLeave);
        }

        if (mixins) {
          mixins.forEach(beforeLeave);
        }

        if (block.beforeLeaveRoute) {
          try {
            block.beforeLeaveRoute();
          } catch (err) {
            console.error('Uncaught error in ' + name + '#beforeLeave:', err);
          }
        }
      });

      routeLoaded = false;
    }
  };
}

function subscribe(name, callback) {
  subscribers.$[name] = callback;

  return function () {
    subscribers.delete(name);
  };
}

function forward(url, push) {
  changeHistory(url, push);
  changeRoute();
}

function changeRoute() {
  var route = findRouteByURL();

  if (route) {
    var _route = route;
    currentRoute = _route.route;
    currentRouteParams = objectWithoutProperties(_route, ['route']);

    assign$1(currentRouteParams, {
      name: currentRoute.name,
      host: location.host,
      hostname: location.hostname,
      href: location.href,
      origin: location.origin,
      pathname: location.pathname,
      port: location.port,
      protocol: location.protocol,
      search: location.search
    });
  } else {
    if (redirectRoute) {
      var _RedirectRoute = RedirectRoute,
          url = _RedirectRoute.url,
          encodeParams = _RedirectRoute.encodeParams,
          encodeQuery = _RedirectRoute.encodeQuery;


      return forward(constructURL(origin, url, {}, {}, '', {
        params: encodeParams,
        query: encodeQuery
      }));
    }

    currentRoute = null;
    currentRouteParams = null;
  }

  subscribers.forEach(function (callback) {
    return callback();
  });
}

function findRouteByURL() {
  var pathname = location.pathname || '/';
  var search = location.search || '';
  var urlParams = void 0;

  Routes.some(function (route) {
    if (route.abstract) {
      return;
    }

    var routeURL = route.url,
        validatePath = route.validatePath,
        params = route.params,
        requiredQuery = route.query,
        decodeParams = route.decodeParams,
        decodeQuery = route.decodeQuery;

    var resolved = resolveURL(decodeQuery);
    var query = new Super(resolved.query);
    var eventualParams = {};
    var match = ((pathname.replace(/\/$/, '') || '/') + (isRegExp(routeURL) ? search : '')).match(validatePath);

    if (!match) {
      return;
    }

    /* eslint guard-for-in: 0 */
    for (var param in requiredQuery) {
      if (!query.hasOwn(param) || !requiredQuery[param].test(query.$[param])) {
        return;
      }
    }

    match.shift();

    for (var _param in params) {
      eventualParams[_param] = decode(match[params[_param]], decodeParams);
    }

    urlParams = {
      route: route,
      params: eventualParams,
      query: query.$,
      hash: resolved.hash
    };

    return true;
  });

  if (urlParams) {
    return urlParams;
  }

  if (!defaultRoute) {
    return;
  }

  return _extends({
    route: DefaultRoute,
    params: {}
  }, resolveURL(DefaultRoute.decodeQuery));
}

function decode(string, decodeParams) {
  return decodeParams ? decodeURIComponent(string) : string;
}

function changeHistory(url, push) {
  try {
    history[push ? 'pushState' : 'replaceState'](null, null, url);
    pushed = true;
  } catch (err) {
    location.href = url;
  }
}

function resolveParameter(param, nameErrorName, valueErrorName) {
  var nameMatch = param.match(/^[a-z_$]+/i);

  if (!nameMatch) {
    throw new Error(nameErrorName);
  }

  var name = nameMatch[0];
  var value = param.slice(name.length);
  var regexp = void 0;

  if (value && (value.indexOf('(') || value.indexOf(')') !== value.length - 1)) {
    throw new Error(valueErrorName);
  }

  if (value) {
    regexp = new RegExp(value.slice(1, -1));
  }

  return {
    name: name,
    regexp: regexp
  };
}



var statics = Object.freeze({
	D: D$1,
	isArray: isArray,
	isArrayLike: isArrayLike,
	isBoolean: isBoolean,
	isDate: isDate,
	isDateLike: isDateLike,
	isElement: isElement,
	isFinite: isFinite,
	isFunction: isFunction,
	isInteger: isInteger,
	isIntegerLike: isIntegerLike,
	isNaN: isNaN,
	isNull: isNull,
	isNil: isNil,
	isNumber: isNumber,
	isNumberLike: isNumberLike,
	isObject: isObject,
	isPlainObject: isPlainObject,
	isPrimitive: isPrimitive,
	isRegExp: isRegExp,
	isString: isString,
	isSymbol: isSymbol,
	isUndefined: isUndefined,
	Alphabet: Alphabet,
	alphabet: alphabet,
	Arr: Arr,
	array: array,
	iterate: iterate$1,
	BlobObject: BlobObject,
	blob: blob$1,
	Block: Block,
	Mixin: Mixin,
	initApp: initApp,
	Dat: Dat,
	now: now,
	date: date,
	Elem: Elem,
	win: win,
	doc: doc,
	html: html,
	body: body,
	head: head$1,
	find: _find,
	parseHTML: parseHTML,
	px: px,
	Fetch: Fetch,
	fetch: fetch,
	Func: Func,
	method: method,
	noop: noop,
	prop: prop$1,
	self: self$1,
	Num: Num,
	rand: rand,
	random: random$1,
	Promise: Promise$1,
	makeRoute: makeRoute,
	Str: Str,
	parseJSON: parseJSON,
	Super: Super,
	Switcher: Switcher,
	switcher: switcher,
	when: when
});

var D$$1 = D$1;


assign$1(D$$1, statics);

delete D$$1.D;

global$1.D = D$$1;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uL2xpYi9jb25zdGFudHMvZ2xvYmFsLmpzIiwiLi4vbGliL2NvbnN0YW50cy9hcHBsaWVkUmVnRXhwcy5qcyIsIi4uL2xpYi9jb25zdGFudHMvY2FudmFzTWV0aG9kcy5qcyIsIi4uL2xpYi9jb25zdGFudHMvY29uc3RydWN0b3JzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9lbGVtZW50cy5qcyIsIi4uL2xpYi9jb25zdGFudHMvaHRtbEFsbG93ZWRUYWdTeW1ib2xzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9yZWdleHBTcGVjaWFsQ2hhcmFjdGVycy5qcyIsIi4uL2xpYi9oZWxwZXJzL3RvU3RyaW5nVGFnLmpzIiwiLi4vbGliL2hlbHBlcnMvY2hlY2tUeXBlcy5qcyIsIi4uL2xpYi9jb25zdGFudHMvdmFsaWRhdGVDaGVja0V4cHJlc3Npb25zLmpzIiwiLi4vbGliL0QuanMiLCIuLi9saWIvaGVscGVycy9pdGVyYXRlLmpzIiwiLi4vbGliL2hlbHBlcnMvYXNzaWduLmpzIiwiLi4vbGliL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCIuLi9saWIvaGVscGVycy9TeW1ib2wuanMiLCIuLi9saWIvaGVscGVycy90b0FycmF5LmpzIiwiLi4vbGliL2hlbHBlcnMvdmFsaWRhdGUuanMiLCIuLi9saWIvQWxwaGFiZXQuanMiLCIuLi9saWIvU3dpdGNoZXIuanMiLCIuLi9saWIvU3VwZXIuanMiLCIuLi9saWIvUHJvbWlzZS5qcyIsIi4uL2xpYi9GdW5jLmpzIiwiLi4vbGliL051bS5qcyIsIi4uL2xpYi9BcnIuanMiLCIuLi9saWIvQmxvYk9iamVjdC5qcyIsIi4uL2xpYi9TdHIuanMiLCIuLi9saWIvaGVscGVycy9tYXJrdXBUb0pTT04uanMiLCIuLi9saWIvRWxlbS5qcyIsIi4uL2xpYi9ibG9ja3MvZC1ibG9jay5qcyIsIi4uL2xpYi9ibG9ja3MvZC1lYWNoLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWVsZW1lbnRzLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWlmLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWl0ZW0uanMiLCIuLi9saWIvYmxvY2tzL2Qtc3dpdGNoLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLXRleHQuanMiLCIuLi9saWIvbWl4aW5zL2QtYXR0ci5qcyIsIi4uL2xpYi9taXhpbnMvZC1iaW5kLmpzIiwiLi4vbGliL21peGlucy9kLWNsYXNzLmpzIiwiLi4vbGliL21peGlucy9kLWVsZW0uanMiLCIuLi9saWIvbWl4aW5zL2QtaGlkZS5qcyIsIi4uL2xpYi9taXhpbnMvZC1vbi5qcyIsIi4uL2xpYi9taXhpbnMvZC1zaG93LmpzIiwiLi4vbGliL21peGlucy9kLXN0eWxlLmpzIiwiLi4vbGliL21peGlucy9kLXRleHQuanMiLCIuLi9saWIvbWl4aW5zL2QtdmFsaWRhdGUuanMiLCIuLi9saWIvbWl4aW5zL2QtdmFsdWUuanMiLCIuLi9saWIvQmxvY2suanMiLCIuLi9saWIvY29uc3RhbnRzL2Zvcm1hdHMuanMiLCIuLi9saWIvRGF0LmpzIiwiLi4vbGliL2hlbHBlcnMvY29uc3RydWN0VVJMLmpzIiwiLi4vbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwiLi4vbGliL2hlbHBlcnMvdHJhbnNmb3JtRGF0YS5qcyIsIi4uL2xpYi9GZXRjaC5qcyIsIi4uL2xpYi9oZWxwZXJzL3Jlc29sdmVVUkwuanMiLCIuLi9saWIvUm91dGVyLmpzIiwiLi4vYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cclxuLyogZXNsaW50IG5vLW5lZ2F0ZWQtY29uZGl0aW9uOiAwICovXHJcbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9hcHBsaWVkUmVnRXhwc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBkaWZmZXJlbnQgdHlwZXMgb2Ygc3ludGF4IGZvciB7QGxpbmsgRWxlbSNhcHBseX0uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBtYXRjaEFwcGxpZWRFeHByQ2FsbGJhY2tcclxuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gRC1lbGVtIG9mIGFuIGVsZW1lbnQgdG8gYXBwbHkgZXhwcmVzc2lvbiB0by5cclxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIE1hdGNoZWQgYXBwbGllZCBuYW1lLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnIC0gQXJndW1lbnQgd2l0aGluIHRoZSBwYXJlbnRoZXNlcy5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGUge09iamVjdC48U3RyaW5nLCBtYXRjaEFwcGxpZWRFeHByQ2FsbGJhY2t8T2JqZWN0LjxTdHJpbmcsIG1hdGNoQXBwbGllZEV4cHJDYWxsYmFjaz4+fVxyXG4gKiBAZGVzY3JpcHRpb24gT2JqZWN0IG9mIGRpZmZlcmVudCB0eXBlcyBvZiBzeW50YXguXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGxpZWRSZWdFeHBzID0ge1xyXG4gICcjJyhlbGVtLCBpZCkge1xyXG4gICAgZWxlbS5pZChpZCk7XHJcbiAgfSxcclxuICAnLicoZWxlbSwgY2xzKSB7XHJcbiAgICBlbGVtLmFkZENsYXNzKGNscyk7XHJcbiAgfSxcclxuICAkKGVsZW0sIGF0dHIsIHZhbHVlKSB7XHJcbiAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xyXG4gIH0sXHJcbiAgJ0AnKGVsZW0sIHByb3AsIHZhbHVlKSB7XHJcbiAgICBlbGVtLmNzcyhwcm9wLCB2YWx1ZSk7XHJcbiAgfSxcclxuICAnJicoZWxlbSwgbmFtZSwgaHRtbCkge1xyXG4gICAgZWxlbS5odG1sKGh0bWwpO1xyXG4gIH0sXHJcbiAgJyonKGVsZW0sIG5hbWUsIHRleHQpIHtcclxuICAgIGVsZW0udGV4dCh0ZXh0KTtcclxuICB9LFxyXG4gICctJzoge1xyXG4gICAgJy4nKGVsZW0sIGNscykge1xyXG4gICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XHJcbiAgICB9LFxyXG4gICAgJChlbGVtLCBhdHRyKSB7XHJcbiAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcclxuICAgIH0sXHJcbiAgICAnQCcoZWxlbSwgcHJvcCkge1xyXG4gICAgICBlbGVtLnJlbW92ZUNTUyhwcm9wKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9lbGVtZW50c1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBkaWZmZXJlbnQgY2FudmFzIG1ldGhvZHMgZm9yIHtAbGluayBFbGVtfSBmb3IgY3JlYXRpbmcgaHRtbC1lbGVtZW50cy5cclxuICovXHJcblxyXG4vKipcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtTdHJpbmdbXX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBjYW52YXNHZXRNZXRob2RzID0gW1xyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NyZWF0ZUltYWdlRGF0YVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NyZWF0ZUltYWdlRGF0YVxyXG4gICAqL1xyXG4gICdjcmVhdGVJbWFnZURhdGEnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjcmVhdGVMaW5lYXJHcmFkaWVudFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7Q2FudmFzR3JhZGllbnR8dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY3JlYXRlTGluZWFyR3JhZGllbnRcclxuICAgKi9cclxuICAnY3JlYXRlTGluZWFyR3JhZGllbnQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjcmVhdGVQYXR0ZXJuXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtDYW52YXNQYXR0ZXJufHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NyZWF0ZVBhdHRlcm5cclxuICAgKi9cclxuICAnY3JlYXRlUGF0dGVybicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NyZWF0ZVJhZGlhbEdyYWRpZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtDYW52YXNHcmFkaWVudHx2b2lkfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jcmVhdGVSYWRpYWxHcmFkaWVudFxyXG4gICAqL1xyXG4gICdjcmVhdGVSYWRpYWxHcmFkaWVudCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dldEltYWdlRGF0YVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dldEltYWdlRGF0YVxyXG4gICAqL1xyXG4gICdnZXRJbWFnZURhdGEnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNnZXRMaW5lRGFzaFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7TnVtYmVyW118dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2V0TGluZURhc2hcclxuICAgKi9cclxuICAnZ2V0TGluZURhc2gnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpc1BvaW50SW5QYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2lzUG9pbnRJblBhdGhcclxuICAgKi9cclxuICAnaXNQb2ludEluUGF0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2lzUG9pbnRJblN0cm9rZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbnx2b2lkfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9pc1BvaW50SW5TdHJva2VcclxuICAgKi9cclxuICAnaXNQb2ludEluU3Ryb2tlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVhc3VyZVRleHRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge1RleHRNZXRyaWNzfHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL21lYXN1cmVUZXh0XHJcbiAgICovXHJcbiAgJ21lYXN1cmVUZXh0J1xyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNhbnZhc1Jlc3RNZXRob2RzID0gW1xyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FyY1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvYXJjXHJcbiAgICovXHJcbiAgJ2FyYycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FyY1RvXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9hcmNUb1xyXG4gICAqL1xyXG4gICdhcmNUbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2JlZ2luUGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvYmVnaW5QYXRoXHJcbiAgICovXHJcbiAgJ2JlZ2luUGF0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2JlemllckN1cnZlVG9cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2JlemllckN1cnZlVG9cclxuICAgKi9cclxuICAnYmV6aWVyQ3VydmVUbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NsZWFyUmVjdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY2xlYXJSZWN0XHJcbiAgICovXHJcbiAgJ2NsZWFyUmVjdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NsaXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NsaXBcclxuICAgKi9cclxuICAnY2xpcCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Nsb3NlUGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY2xvc2VQYXRoXHJcbiAgICovXHJcbiAgJ2Nsb3NlUGF0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RyYXdGb2N1c0lmTmVlZGVkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9kcmF3Rm9jdXNJZk5lZWRlZFxyXG4gICAqL1xyXG4gICdkcmF3Rm9jdXNJZk5lZWRlZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RyYXdJbWFnZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZHJhd0ltYWdlXHJcbiAgICovXHJcbiAgJ2RyYXdJbWFnZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2VsbGlwc2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2VsbGlwc2VcclxuICAgKi9cclxuICAnZWxsaXBzZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpbGxcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxcclxuICAgKi9cclxuICAnZmlsbCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpbGxSZWN0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9maWxsUmVjdFxyXG4gICAqL1xyXG4gICdmaWxsUmVjdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpbGxUZXh0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9maWxsVGV4dFxyXG4gICAqL1xyXG4gICdmaWxsVGV4dCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2xpbmVUb1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvbGluZVRvXHJcbiAgICovXHJcbiAgJ2xpbmVUbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21vdmVUb1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvbW92ZVRvXHJcbiAgICovXHJcbiAgJ21vdmVUbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3B1dEltYWdlRGF0YVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcHV0SW1hZ2VEYXRhXHJcbiAgICovXHJcbiAgJ3B1dEltYWdlRGF0YScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3F1YWRyYXRpY0N1cnZlVG9cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3F1YWRyYXRpY0N1cnZlVG9cclxuICAgKi9cclxuICAncXVhZHJhdGljQ3VydmVUbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JlY3RcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3JlY3RcclxuICAgKi9cclxuICAncmVjdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Jlc2V0VHJhbnNmb3JtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9yZXNldFRyYW5zZm9ybVxyXG4gICAqL1xyXG4gICdyZXNldFRyYW5zZm9ybScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Jlc3RvcmVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3Jlc3RvcmVcclxuICAgKi9cclxuICAncmVzdG9yZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JvdGF0ZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcm90YXRlXHJcbiAgICovXHJcbiAgJ3JvdGF0ZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NhdmVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NhdmVcclxuICAgKi9cclxuICAnc2F2ZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NjYWxlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zY2FsZVxyXG4gICAqL1xyXG4gICdzY2FsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NldExpbmVEYXNoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaFxyXG4gICAqL1xyXG4gICdzZXRMaW5lRGFzaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NldFRyYW5zZm9ybVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0VHJhbnNmb3JtXHJcbiAgICovXHJcbiAgJ3NldFRyYW5zZm9ybScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N0cm9rZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc3Ryb2tlXHJcbiAgICovXHJcbiAgJ3N0cm9rZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N0cm9rZVJlY3RcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3N0cm9rZVJlY3RcclxuICAgKi9cclxuICAnc3Ryb2tlUmVjdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N0cm9rZVRleHRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3N0cm9rZVRleHRcclxuICAgKi9cclxuICAnc3Ryb2tlVGV4dCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RyYW5zZm9ybVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvdHJhbnNmb3JtXHJcbiAgICovXHJcbiAgJ3RyYW5zZm9ybScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RyYW5zbGF0ZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvdHJhbnNsYXRlXHJcbiAgICovXHJcbiAgJ3RyYW5zbGF0ZSdcclxuXTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2NvbnN0cnVjdG9yc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBjb25zdHJ1Y3RvcnMgbGV2ZWxzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY29uc3RcclxuICogQHR5cGUge0FycmF5W119XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29uc3RydWN0b3JzID0gW1xyXG4gIFtdLFxyXG4gIFtdLFxyXG4gIFtdXHJcbl07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9lbGVtZW50c1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBtZXRob2RzIGZvciB7QGxpbmsgRWxlbX0gZm9yIGNyZWF0aW5nIGh0bWwtZWxlbWVudHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7U3RyaW5nW119XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaHRtbEVsZW1lbnRzID0gW1xyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWJiclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FiYnInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhZGRyZXNzXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYWRkcmVzcycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FyZWFcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhcmVhJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYXJ0aWNsZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FydGljbGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhdWRpb1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2F1ZGlvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2InLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiYXNlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYmFzZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2JkaVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2JkaScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Jkb1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2JkbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Jsb2NrcXVvdGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdibG9ja3F1b3RlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYm9keVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2JvZHknLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2JyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYnV0dG9uXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYnV0dG9uJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2FudmFzXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY2FudmFzJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2FwdGlvblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2NhcHRpb24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjaXRlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY2l0ZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NvZGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjb2RlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29sXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY29sJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29sZ3JvdXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjb2xncm91cCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NvbnRlbnRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjb250ZW50JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGF0YWxpc3RcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkYXRhbGlzdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkZWxcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkZWwnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkZXRhaWxzXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGV0YWlscycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RmblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2RmbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RpYWxvZ1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2RpYWxvZycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RpdlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2RpdicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RsXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGwnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2R0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZWxlbWVudFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2VsZW1lbnQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNlbVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2VtJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZW1iZWRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdlbWJlZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpZWxkc2V0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmllbGRzZXQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmaWdjYXB0aW9uXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmlnY2FwdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpZ3VyZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZpZ3VyZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Zvb3RlclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2Zvb3RlcicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Zvcm1cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmb3JtJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaDFcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoMScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2gyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaDInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoM1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2gzJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaDRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoNCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2g1XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaDUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoNlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2g2JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaGVhZFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2hlYWQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoZWFkZXJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoZWFkZXInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoZ3JvdXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoZ3JvdXAnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2hyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2knLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpZnJhbWVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdpZnJhbWUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpbWdcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdpbWcnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpbnB1dFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2lucHV0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaW5zXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaW5zJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0ja2JkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAna2JkJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGFiZWxcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdsYWJlbCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2xlZ2VuZFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2xlZ2VuZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2xpXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbGknLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsaW5rXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbGluaycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21haW5cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtYWluJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWFya1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21hcmsnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZW51XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWVudScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lbnVpdGVtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWVudWl0ZW0nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZXRhXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWV0YScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21ldGVyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWV0ZXInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNuYXZcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICduYXYnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNub3NjcmlwdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ25vc2NyaXB0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jb2xcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdvbCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI29wdGdyb3VwXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnb3B0Z3JvdXAnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNvcHRpb25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdvcHRpb24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNvdXRwdXRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdvdXRwdXQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BhcmFtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncGFyYW0nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwcmVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdwcmUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwcm9ncmVzc1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3Byb2dyZXNzJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3EnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNycFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3JwJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcnRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdydCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3J0Y1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3J0YycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3J1YnlcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdydWJ5JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3MnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzYW1wXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc2FtcCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NjcmlwdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NjcmlwdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NlY3Rpb25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzZWN0aW9uJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2VsZWN0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc2VsZWN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2hhZG93XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc2hhZG93JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc21hbGxcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzbWFsbCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NvdXJjZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NvdXJjZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NwYW5cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzcGFuJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3Ryb25nXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3Ryb25nJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3R5bGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzdHlsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N1YlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3N1YicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N1bW1hcnlcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzdW1tYXJ5JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3VwXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3VwJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGFibGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0YWJsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Rib2R5XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGJvZHknLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0ZFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RkJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGVtcGxhdGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0ZW1wbGF0ZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RleHRhcmVhXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGV4dGFyZWEnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0Zm9vdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3Rmb290JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RoZWFkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGhlYWQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0aW1lXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGltZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RpdGxlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGl0bGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0clxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdHJhY2tcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0cmFjaycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd1JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdWxcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd1bCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3ZhclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3ZhcicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3ZpZGVvXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndmlkZW8nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN3YnJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd3YnInXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3Qgc3ZnRWxlbWVudHMgPSBbXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWx0R2x5cGhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhbHRHbHlwaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FsdEdseXBoRGVmXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYWx0R2x5cGhEZWYnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhbHRHbHlwaEl0ZW1cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhbHRHbHlwaEl0ZW0nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhbmltYXRlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYW5pbWF0ZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FuaW1hdGVDb2xvclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FuaW1hdGVDb2xvcicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FuaW1hdGVNb3Rpb25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhbmltYXRlTW90aW9uJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYW5pbWF0ZVRyYW5zZm9ybVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FuaW1hdGVUcmFuc2Zvcm0nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjaXJjbGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjaXJjbGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjbGlwUGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2NsaXBQYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29sb3JQcm9maWxlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY29sb3ItcHJvZmlsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2N1cnNvclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2N1cnNvcicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RlZnNcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkZWZzJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGVzY1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2Rlc2MnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkaXNjYXJkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGlzY2FyZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2VsbGlwc2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdlbGxpcHNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVCbGVuZFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlQmxlbmQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUNvbG9yTWF0cml4XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVDb2xvck1hdHJpeCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlQ29tcG9uZW50VHJhbnNmZXJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVDb21wb3NpdGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUNvbXBvc2l0ZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlQ29udm9sdmVNYXRyaXhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUNvbnZvbHZlTWF0cml4JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVEaWZmdXNlTGlnaHRpbmdcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZURpZmZ1c2VMaWdodGluZycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRGlzcGxhY2VtZW50TWFwXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVEaXNwbGFjZW1lbnRNYXAnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZURpc3RhbnRMaWdodFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlRGlzdGFudExpZ2h0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVEcm9wU2hhZG93XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVEcm9wU2hhZG93JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVGbG9vZFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlRmxvb2QnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUZ1bmNBXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVGdW5jQScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRnVuY0JcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUZ1bmNCJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVGdW5jR1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlRnVuY0cnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUZ1bmNSXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVGdW5jUicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlR2F1c3NpYW5CbHVyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVHYXVzc2lhbkJsdXInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUltYWdlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVJbWFnZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlTWVyZ2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZU1lcmdlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVNZXJnZU5vZGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZU1lcmdlTm9kZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlTW9ycGhvbG9neVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlTW9ycGhvbG9neScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlT2Zmc2V0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVPZmZzZXQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZVBvaW50TGlnaHRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZVBvaW50TGlnaHQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZVNwZWN1bGFyTGlnaHRpbmdcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZVNwZWN1bGFyTGlnaHRpbmcnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZVNwb3RMaWdodFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlU3BvdExpZ2h0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVUaWxlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVUaWxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVUdXJidWxlbmNlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVUdXJidWxlbmNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZvbnQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb250RmFjZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZvbnQtZmFjZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZvbnRGYWNlRm9ybWF0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZm9udC1mYWNlLWZvcm1hdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZvbnRGYWNlTmFtZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZvbnQtZmFjZS1uYW1lJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VTcmNcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmb250LWZhY2Utc3JjJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VVcmlcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmb250LWZhY2UtdXJpJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9yZWlnbk9iamVjdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZvcmVpZ25PYmplY3QnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNnXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dseXBoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZ2x5cGgnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNnbHlwaFJlZlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2dseXBoUmVmJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaGF0Y2hcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoYXRjaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hhdGNocGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2hhdGNocGF0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hrZXJuXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaGtlcm4nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpbWFnZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ltYWdlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGluZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2xpbmUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsaW5lYXJHcmFkaWVudFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2xpbmVhckdyYWRpZW50JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWFya2VyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWFya2VyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWFza1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21hc2snLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZXNoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWVzaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lc2hncmFkaWVudFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21lc2hncmFkaWVudCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lc2hwYXRjaFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21lc2hwYXRjaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lc2hyb3dcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZXNocm93JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWV0YWRhdGFcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZXRhZGF0YScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21pc3NpbmdHbHlwaFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21pc3NpbmctZ2x5cGgnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtcGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21wYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3BhdGgnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwYXR0ZXJuXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncGF0dGVybicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BvbHlnb25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdwb2x5Z29uJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcG9seWxpbmVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdwb2x5bGluZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JhZGlhbEdyYWRpZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncmFkaWFsR3JhZGllbnQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNyZWN0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncmVjdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NldFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NldCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NvbGlkY29sb3JcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzb2xpZGNvbG9yJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3RvcFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3N0b3AnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHlsZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3N0eWxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3ZnXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3ZnJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3dpdGNoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3dpdGNoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3ltYm9sXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3ltYm9sJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGV4dFBhdGhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0ZXh0UGF0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RyZWZcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0cmVmJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdHNwYW5cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0c3BhbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Vua25vd25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd1bmtub3duJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdXNlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndXNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdmlld1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3ZpZXcnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN2a2VyblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3ZrZXJuJ1xyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZvaWRFbGVtZW50cyA9IFtcclxuICAnYXJlYScsXHJcbiAgJ2Jhc2UnLFxyXG4gICdicicsXHJcbiAgJ2NvbCcsXHJcbiAgJ2NvbW1hbmQnLFxyXG4gICdlbWJlZCcsXHJcbiAgJ2hyJyxcclxuICAnaW1nJyxcclxuICAnaW5wdXQnLFxyXG4gICdrZXlnZW4nLFxyXG4gICdsaW5rJyxcclxuICAnbWV0YScsXHJcbiAgJ3BhcmFtJyxcclxuICAnc291cmNlJyxcclxuICAndHJhY2snLFxyXG4gICd3YnInXHJcbl07XHJcbiIsImV4cG9ydCBjb25zdCBodG1sQWxsb3dlZFRhZ1N5bWJvbHMgPSAnW2Etel1bYS16XFxcXGRcXFxcLV8uOiFAI1xcXFwkJVxcXFxeJiooKVxcXFxbXFxcXF17fVxcXFxcXFxcPVxcJ1wiXSonO1xyXG5leHBvcnQgY29uc3QgaHRtbEFsbG93ZWRBdHRyU3ltYm9scyA9ICdbXlxcXFx1MDAwMC1cXFxcdTAwMjBcXFxcc1wiXFwnPi89XSsnO1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBjb25zdGFudHMvcmVnZXhwU3BlY2lhbENoYXJhY3RlcnNcclxuICogQHByaXZhdGVcclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgc3BlY2lhbCBjaGFyYWN0ZXJzIGZvciBSZWdFeHAuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdFxyXG4gKiBAbmFtZSBtb2R1bGU6Y29uc3RhbnRzL3JlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzfnJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzXHJcbiAqIEB0eXBlIHtTdHJpbmdbXX1cclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdleHBTcGVjaWFsQ2hhcmFjdGVycyA9IFtcclxuICAnLicsXHJcbiAgJysnLCAnKicsICc/JyxcclxuICAnKCcsICcpJyxcclxuICAnWycsICddJyxcclxuICAneycsICd9JyxcclxuICAnPCcsICc+JyxcclxuICAnXicsICckJyxcclxuICAnIScsXHJcbiAgJz0nLFxyXG4gICc6JyxcclxuICAnLScsXHJcbiAgJ3wnLFxyXG4gICcsJyxcclxuICAnXFxcXCdcclxuXTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy90b1N0cmluZ1RhZ1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyB0b1N0cmluZ1RhZyBtZXRob2QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB0b1N0cmluZ1RhZ1xyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBnZXQgdG9TdHJpbmdUYWcgb2YuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEN1dCBzdHJpbmcuXHJcbiAqIEBkZXNjcmlwdGlvbiBDdXQgXCJUeXBlXCIgc3RyaW5nIGZyb20gXCJbb2JqZWN0IFR5cGVdXCIgc3RyaW5nIHRoYXQgZ290dGVuIGZyb20ge30udG9TdHJpbmcsY2FsbChvYmplY3QpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG9iamVjdCkge1xyXG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iamVjdCkucmVwbGFjZSgvXlxcW29iamVjdCB8XSQvZywgJycpO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvY2hlY2tUeXBlc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgaXM8VHlwZT4gbWV0aG9kcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyB0b1N0cmluZ1RhZyB9IGZyb20gJy4vdG9TdHJpbmdUYWcnO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0FycmF5XHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGFycmF5LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9yIG5vdC5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzQXJyYXkoW10pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc0FycmF5KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNBcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpOyAvLyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQXJyYXknO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzQXJyYXlMaWtlXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFycmF5LWxpa2UuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYXJyYXktbGlrZSBvciBub3QuXHJcbiAqIEBkZXNjcmlwdGlvbiBCYXNpY2FsbHkgcmV0dXJucyBpZiB0aGUgYXJndW1lbnQgaGFzIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIFwibGVuZ3RoXCIgcHJvcGVydHkgYW5kIGlzbid0IGEgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0FycmF5TGlrZShbXSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzQXJyYXlMaWtlKCcnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNBcnJheUxpa2UoKCkgPT4ge30pOyAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcclxuICogaXNBcnJheUxpa2UoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpKTsgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XHJcbiAgaWYgKCF2YWx1ZSB8fCBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcbiAgXHJcbiAgcmV0dXJuIGlzSW50ZWdlcihsZW5ndGgpICYmIGxlbmd0aCA+PSAwO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzQm9vbGVhblxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIGJvb2xlYW4uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBib29sZWFuIG9yIG5vdC5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzQm9vbGVhbih0cnVlKTsgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzQm9vbGVhbihuZXcgQm9vbGVhbihmYWxzZSkpOyAvLyB0cnVlXHJcbiAqIGlzQm9vbGVhbihudWxsKTsgICAgICAgICAgICAgICAvLyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdCb29sZWFuJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0RhdGVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBkYXRlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZGF0ZSBvciBub3QuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0RhdGUobmV3IERhdGUoKSk7ICAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJyk7IC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0RhdGUnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzRGF0ZUxpa2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgZGF0ZS1saWtlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGRhdGUtbGlrZSBvciBub3QuXHJcbiAqIEBkZXNjcmlwdGlvbiBCYXNpY2FsbHkgcmV0dXJucyBpZiBuZXcgRGF0ZShhcmd1bWVudCkgaXMgbm90IGludmFsaWQgZGF0ZS5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzRGF0ZUxpa2UobmV3IERhdGUoKSk7ICAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzRGF0ZUxpa2UoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpOyAvLyB0cnVlXHJcbiAqIGlzRGF0ZUxpa2UoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlTGlrZSh2YWx1ZSkge1xyXG4gIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xyXG4gIFxyXG4gIHJldHVybiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0VsZW1lbnRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYW4gZWxlbWVudC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBlbGVtZW50IG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNFbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKSk7IC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcclxuICByZXR1cm4gL0VsZW1lbnQkLy50ZXN0KHRvU3RyaW5nVGFnKHZhbHVlKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNGaW5pdGVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgZmluaXRlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGZpbml0ZSBvciBub3QuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0Zpbml0ZSgwKTsgICAgICAgIC8vIHRydWVcclxuICogaXNGaW5pdGUoJzAnKTsgICAgICAvLyBmYWxzZVxyXG4gKiBpc0Zpbml0ZShJbmZpbml0eSk7IC8vIGZhbHNlXHJcbiAqIGlzRmluaXRlKE5hTik7ICAgICAgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xyXG4gIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIFxyXG4gIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuXHJcbiAgcmV0dXJuICFpc05hTih2YWx1ZSkgJiYgdmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gb3Igbm90LlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogaXNGdW5jdGlvbigoKSA9PiB7fSk7ICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBcclxuICogY29uc3QgZnVuYyA9ICgpID0+IHt9O1xyXG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZnVuYywge30pO1xyXG4gKiBpc0Z1bmN0aW9uKGZ1bmMpOyAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdGdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzSW50ZWdlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhbiBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGludGVnZXIgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0ludGVnZXIoMCk7ICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNJbnRlZ2VyKDAuMSk7ICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc0ludGVnZXIobmV3IE51bWJlcigwKSk7IC8vIHRydWVcclxuICogaXNJbnRlZ2VyKCcwJyk7ICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc0ludGVnZXIoSW5maW5pdHkpOyAgICAgIC8vIGZhbHNlXHJcbiAqIGlzSW50ZWdlcihOYU4pOyAgICAgICAgICAgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcclxuICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICUgMSA9PT0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0ludGVnZXJMaWtlXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGludGVnZXItbGlrZS5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBpbnRlZ2VyLWxpa2Ugb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0ludGVnZXJMaWtlKDApOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzSW50ZWdlckxpa2UobmV3IE51bWJlcigwKSk7IC8vIHRydWVcclxuICogaXNJbnRlZ2VyTGlrZSgwLjEpOyAgICAgICAgICAgLy8gZmFsc2VcclxuICogaXNJbnRlZ2VyTGlrZSgnMCcpOyAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlckxpa2UodmFsdWUpIHtcclxuICB2YWx1ZSA9IHBhcnNlSW50KE51bWJlcih2YWx1ZSkpO1xyXG5cclxuICByZXR1cm4gISEodmFsdWUgfHwgdmFsdWUgPT09IDApO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzTmFOXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIE5hTi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBOYU4gb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc05hTigwKTsgICAgICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc05hTignTmFOJyk7ICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc05hTihOYU4pOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7IC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xyXG4gIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIFxyXG4gIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuXHJcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc051bGxcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgbnVsbC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBudWxsIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNOdWxsKG51bGwpOyAgICAgIC8vIHRydWVcclxuICogaXNOdWxsKHVuZGVmaW5lZCk7IC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzTmlsXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNOaWwobnVsbCk7ICAgICAgLy8gdHJ1ZVxyXG4gKiBpc05pbCh1bmRlZmluZWQpOyAvLyB0cnVlXHJcbiAqIGlzTmlsKGZhbHNlKTsgICAgIC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc051bWJlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIG51bWJlci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzTnVtYmVyKDApOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzTnVtYmVyKG5ldyBOdW1iZXIoMCkpOyAvLyB0cnVlXHJcbiAqIGlzTnVtYmVyKE5hTik7ICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzTnVtYmVyKCcwJyk7ICAgICAgICAgICAvLyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ051bWJlcic7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNOdW1iZXJMaWtlXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIG51bWJlci1saWtlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIG51bWJlci1saWtlIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNOdW1iZXJMaWtlKDApOyAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzTnVtYmVyTGlrZSgnMCcpOyAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc051bWJlckxpa2UoJ0luZmluaXR5Jyk7IC8vIHRydWVcclxuICogaXNOdW1iZXJMaWtlKCdOYU4nKTsgICAgICAvLyB0cnVlXHJcbiAqIGlzTnVtYmVyTGlrZShOYU4pOyAgICAgICAgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyTGlrZSh2YWx1ZSkge1xyXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09ICdOYU4nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgXHJcbiAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG4gIFxyXG4gIHJldHVybiAhISh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNPYmplY3RcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYW4gb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzT2JqZWN0KHt9KTsgICAvLyB0cnVlXHJcbiAqIGlzT2JqZWN0KDEpOyAgICAvLyBmYWxzZVxyXG4gKiBpc09iamVjdChudWxsKTsgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiAhIXZhbHVlICYmICh0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdPYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzUGxhaW5PYmplY3RcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBwbGFpbiBvYmplY3QuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBwbGFpbiBvYmplY3Qgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBvYmogPSB7fTtcclxuICpcclxuICogaWZQbGFpbk9iamVjdChvYmopOyAvLyB0cnVlXHJcbiAqXHJcbiAqIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmplY3QsIG51bGwpO1xyXG4gKlxyXG4gKiBpZlBsYWluT2JqZWN0KG9iaik7IC8vIHRydWVcclxuICpcclxuICogT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iamVjdCwge30pO1xyXG4gKlxyXG4gKiBpZlBsYWluT2JqZWN0KG9iaik7IC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcclxuXHJcbiAgaWYgKGlzTnVsbChwcm90bykpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY29uc3RydWN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgcmV0dXJuIGlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmXHJcbiAgICBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yICYmXHJcbiAgICBpc051bGwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNQcmltaXRpdmVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgcHJpbWl0aXZlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIHByaW1pdGl2ZSBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzUHJpbWl0aXZlKDEpOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzUHJpbWl0aXZlKHt9KTsgICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc1ByaW1pdGl2ZSgnJyk7ICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc1ByaW1pdGl2ZShuZXcgTnVtYmVyKDApKTsgLy8gZmFsc2VcclxuICogaXNQcmltaXRpdmUodHJ1ZSk7ICAgICAgICAgIC8vIHRydWVcclxuICogaXNQcmltaXRpdmUoU3ltYm9sKCdmb28nKSk7IC8vIHRydWVcclxuICogaXNQcmltaXRpdmUobnVsbCk7ICAgICAgICAgIC8vIHRydWVcclxuICogaXNQcmltaXRpdmUodW5kZWZpbmVkKTsgICAgIC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xyXG4gIHJldHVybiBpc051bGwodmFsdWUpIHx8IC9eKG51bWJlcnxzdHJpbmd8Ym9vbGVhbnxzeW1ib2x8dW5kZWZpbmVkKSQvLnRlc3QodHlwZW9mIHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc1JlZ0V4cFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzUmVnRXhwKC9mb28vKTsgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc1JlZ0V4cCgnL2Zvby8nKTsgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqIGlzUmVnRXhwKG5ldyBSZWdFeHAoJ2ZvbycpKTsgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1JlZ0V4cCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNTdHJpbmdcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc1N0cmluZygnMCcpOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzU3RyaW5nKG5ldyBTdHJpbmcoJzAnKSk7IC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdTdHJpbmcnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzU3ltYm9sXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3ltYm9sLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgc3ltYm9sIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNTeW1ib2woU3ltYm9sKCcxJykpOyAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnU3ltYm9sJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc1VuZGVmaW5lZFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyB1bmRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgdW5kZWZpbmVkIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNVbmRlZmluZWQobnVsbCk7ICAgICAgLy8gZmFsc2VcclxuICogaXNVbmRlZmluZWQodW5kZWZpbmVkKTsgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgY29uc3RhbnRzL3ZhbGlkYXRlQ2hlY2tFeHByZXNzaW9uc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBkaWZmZXJlbnQgdHlwZXMgb2YgdmFsaWRhdGUgZXhwcmVzc2lvbnMgZm9yIHtAbGluayBtb2R1bGU6aGVscGVycy92YWxpZGF0ZX0uXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgbWV0aG9kcyBmcm9tICcuLi9oZWxwZXJzL2NoZWNrVHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBjaGVja1ZhbGlkaXR5Q2FsbGJhY2tcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2YWxpZGF0ZUV4cHJcclxuICogQHByaXZhdGVcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSB0aHJvd24gZXJyb3IuXHJcbiAqIEBwcm9wZXJ0eSB7RXJyb3J9IGVycm9yIC0gVHlwZSBvZiB0aGUgdGhyb3duIGVycm9yLlxyXG4gKiBAcHJvcGVydHkge2NoZWNrVmFsaWRpdHlDYWxsYmFja30gY2hlY2sgLSBDYWxsYmFjayBmb3IgY2hlY2tpbmcgdmFsdWUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHt2YWxpZGF0ZUV4cHJbXX1cclxuICogQHByaXZhdGVcclxuICogQGRlc2NyaXB0aW9uIE9iamVjdCBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgdmFsaWRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUNoZWNrRXhwcmVzc2lvbnMgPSB7XHJcbiAgJz4wJzoge1xyXG4gICAgY2hlY2s6IChuKSA9PiBuID4gMCxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIHBvc2l0aXZlIScsXHJcbiAgICBlcnJvcjogUmFuZ2VFcnJvclxyXG4gIH0sXHJcbiAgJz49MCc6IHtcclxuICAgIGNoZWNrOiAobikgPT4gbiA+PSAwLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbm9uLW5lZ2F0aXZlIScsXHJcbiAgICBlcnJvcjogUmFuZ2VFcnJvclxyXG4gIH0sXHJcbiAgJzwwJzoge1xyXG4gICAgY2hlY2s6IChuKSA9PiBuIDwgMCxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIG5lZ2F0aXZlIScsXHJcbiAgICBlcnJvcjogUmFuZ2VFcnJvclxyXG4gIH0sXHJcbiAgJzw9MCc6IHtcclxuICAgIGNoZWNrOiAobikgPT4gbiA8PSAwLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbm9uLXBvc2l0aXZlIScsXHJcbiAgICBlcnJvcjogUmFuZ2VFcnJvclxyXG4gIH0sXHJcbiAgJyEhJzoge1xyXG4gICAgY2hlY2s6ICh2KSA9PiAhbWV0aG9kcy5pc05pbCh2KSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIG5vdCBudWxsIG9yIHVuZGVmaW5lZCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgYXJyYXk6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzQXJyYXksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ2FycmF5fHwhJzoge1xyXG4gICAgY2hlY2s6IChhKSA9PiBtZXRob2RzLmlzQXJyYXkoYSkgfHwgbWV0aG9kcy5pc05pbChhKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIGFycmF5TGlrZToge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNBcnJheUxpa2UsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhcnJheS1saWtlIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICAnYXJyYXlMaWtlfHwhJzoge1xyXG4gICAgY2hlY2s6IChhKSA9PiBtZXRob2RzLmlzQXJyYXlMaWtlKGEpIHx8IG1ldGhvZHMuaXNOaWwoYSksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhcnJheS1saWtlLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIGRhdGU6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzRGF0ZSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgZGF0ZSEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ2RhdGV8fCEnOiB7XHJcbiAgICBjaGVjazogKGQpID0+IG1ldGhvZHMuaXNEYXRlKGQpIHx8IG1ldGhvZHMuaXNOaWwoZCksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIGRhdGUsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgZGF0ZUxpa2U6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzRGF0ZUxpa2UsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBkYXRlLWxpa2UhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdkYXRlTGlrZXx8ISc6IHtcclxuICAgIGNoZWNrOiAoZCkgPT4gbWV0aG9kcy5pc0RhdGVMaWtlKGQpIHx8IG1ldGhvZHMuaXNOaWwoZCksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBkYXRlLWxpa2UsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgZnVuY3Rpb246IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzRnVuY3Rpb24sXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICAnZnVuY3Rpb258fCEnOiB7XHJcbiAgICBjaGVjazogKGYpID0+IG1ldGhvZHMuaXNGdW5jdGlvbihmKSB8fCBtZXRob2RzLmlzTmlsKGYpLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICBpbnQ6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzSW50ZWdlcixcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdpbnR8fCEnOiB7XHJcbiAgICBjaGVjazogKGkpID0+IG1ldGhvZHMuaXNJbnRlZ2VyKGkpIHx8IG1ldGhvZHMuaXNOaWwoaSksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIGludExpa2U6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzSW50ZWdlckxpa2UsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBpbnRlZ2VyLWxpa2UhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdpbnRMaWtlfHwhJzoge1xyXG4gICAgY2hlY2s6IChpKSA9PiBtZXRob2RzLmlzSW50ZWdlckxpa2UoaSkgfHwgbWV0aG9kcy5pc05pbChpKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGludGVnZXItbGlrZSwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICBudW1iZXI6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzTnVtYmVyLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdudW1iZXJ8fCEnOiB7XHJcbiAgICBjaGVjazogKG4pID0+IG1ldGhvZHMuaXNOdW1iZXIobikgfHwgbWV0aG9kcy5pc05pbChuKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIG51bWJlckxpa2U6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzTnVtYmVyTGlrZSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIG51bWJlci1saWtlIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICAnbnVtYmVyTGlrZXx8ISc6IHtcclxuICAgIGNoZWNrOiAobikgPT4gbWV0aG9kcy5pc051bWJlckxpa2UobikgfHwgbWV0aG9kcy5pc05pbChuKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIG51bWJlci1saWtlLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIG9iamVjdDoge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNPYmplY3QsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdvYmplY3R8fCEnOiB7XHJcbiAgICBjaGVjazogKG8pID0+IG1ldGhvZHMuaXNPYmplY3QobykgfHwgbWV0aG9kcy5pc05pbChvKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICByZWdleHA6IHtcclxuICAgIGNoZWNrOiBtZXRob2RzLmlzUmVnRXhwLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSByZWd1bGFyIGV4cHJlc3Npb24hJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdyZWdleHB8fCEnOiB7XHJcbiAgICBjaGVjazogKHIpID0+IG1ldGhvZHMuaXNSZWdFeHAocikgfHwgbWV0aG9kcy5pc05pbChyKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgcmVndWxhciBleHByZXNzaW9uLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIHN0cmluZzoge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNTdHJpbmcsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ3N0cmluZ3x8ISc6IHtcclxuICAgIGNoZWNrOiAocykgPT4gbWV0aG9kcy5pc1N0cmluZyhzKSB8fCBtZXRob2RzLmlzTmlsKHMpLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH1cclxufTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgRFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBEIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gRFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIEFueSB2YWx1ZS5cclxuICogQHJldHVybnMge0RXcmFwfSBXcmFwIG9mIHRoZSBhcmd1bWVudC5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIEQtd3JhcCBvZiBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIEQoe30pOyAgICAgICAgICAgIC8vIFN1cGVyXHJcbiAqIEQoKCkgPT4ge30pOyAgICAgIC8vIEZ1bmNcclxuICogRChbXSk7ICAgICAgICAgICAgLy8gQXJyXHJcbiAqIEQoMSk7ICAgICAgICAgICAgIC8vIE51bVxyXG4gKiBEKCcxJyk7ICAgICAgICAgICAvLyBTdHJcclxuICogRChuZXcgRGF0ZSgpKTsgICAgLy8gRGF0XHJcbiAqIEQoZG9jdW1lbnQuYm9keSk7IC8vIEVsZW1cclxuICovXHJcbmZ1bmN0aW9uIEQodmFsdWUpIHtcclxuICBmb3IgKGxldCBpID0gY29uc3RydWN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBjb25zdCBsZXZlbENvbnN0cnVjdG9ycyA9IGNvbnN0cnVjdG9yc1tpXTtcclxuXHJcbiAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gbGV2ZWxDb25zdHJ1Y3RvcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBsZXZlbENvbnN0cnVjdG9yc1trXTtcclxuXHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yLmNscykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvbnN0cnVjdG9yLmNoZWNrKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IuY2xzKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzL2NoZWNrVHlwZXMnO1xyXG5leHBvcnQgeyBEIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvaXRlcmF0ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBpdGVyYXRlIG1ldGhvZC5cclxuICovXHJcblxyXG5pbXBvcnQgeyBpc0FycmF5TGlrZSwgaXNVbmRlZmluZWQgfSBmcm9tICcuL2NoZWNrVHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gSXRlcmF0aW9uIHZhbHVlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEl0ZXJhdGlvbiBrZXkuXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gSW5pdGlhbCBpdGVyYWJsZSBvYmplY3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpdGVyYXRlXHJcbiAqIEBwYXJhbSB7KE9iamVjdHxBcnJheXxudWxsfHVuZGVmaW5lZCl9IG9iamVjdCAtIFZhbHVlIHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHsqfSBJZiBjYWxsYmFjayByZXR1cm5zIG5vdCB1bmRlZmluZWQgdGhlbiBpdGVyYXRlIHJldHVybnMgdGhpcyB2YWx1ZS5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBpdGVyYXRpbmcgb3ZlciBhbGwgdHlwZXMgb2YgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGUob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gIGNvbnN0IGFycmF5ID0gaXNBcnJheUxpa2Uob2JqZWN0KTtcclxuICBjb25zdCBpdGVyYXRlZEtleXMgPSB7fTtcclxuXHJcbiAgbGV0IGl0ZXJhdGVkID0gMDtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYXRlZEtleXMsIGtleSkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgaXRlcmF0ZWRLZXlzW2tleV0gPSB0cnVlO1xyXG5cclxuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xyXG4gICAgICBpZiAoYXJyYXkgJiYgaXRlcmF0ZWQrKyA+PSBvYmplY3QubGVuZ3RoKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsbGJhY2sob2JqZWN0W2tleV0sIGFycmF5ID8gTnVtYmVyKGtleSkgOiBrZXksIG9iamVjdCk7XHJcblxyXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL2Fzc2lnblxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBPYmplY3QuYXNzaWduLWxpa2UgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdFxyXG4gKiBAZnVuY3Rpb24gYXNzaWduXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdG8gYXNzaWduIHJlc3Qgb2YgYXJndW1lbnRzIHRvLlxyXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0cyAtIE9iamVjdHMgdGhhdCBhcmUgYXNzaWduZWQgdG8gdGhlIHRhcmdldC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIC4uLm9iamVjdHMpIHtcclxuICBpdGVyYXRlKGFyZ3VtZW50cywgKHNvdXJjZSwgaW5kZXgpID0+IHtcclxuICAgIGlmIChpbmRleCkge1xyXG4gICAgICBpdGVyYXRlKHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICAgIFxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9kZWZpbmVQcm9wZXJ0eVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBkZWZpbmVQcm9wZXJ0eSBhbmQgZHluYW1pY0RlZmluZVByb3BlcnRpZXMgbWV0aG9kcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgcHJvcGVydHlHZW5lcmF0b3JDYWxsYmFja1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaSAtIEluZGV4IG9mIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgeyp9IEdlbmVyYXRlZCBwcm9wZXJ0eS5cclxuICovXHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0aWVzIC0gT2JqZWN0IHdoaWNoIGtleXMgYXJlIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7cHJvcGVydHlHZW5lcmF0b3JDYWxsYmFja30gcHJvcGVydHlHZW5lcmF0b3IgLSBDYWxsYmFjayBmb3IgZXZlcnkgcHJvcGVydHkuXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGR5bmFtaWMgY3JlYXRpbmcgcHJvcGVydGllcyBiYXNlZCBvbiBuYW1lIG9mIHRoZSBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY0RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eUdlbmVyYXRvcikge1xyXG4gIGl0ZXJhdGUocHJvcGVydGllcywgKG5hbWUsIGkpID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcclxuICAgICAgdmFsdWU6IHByb3BlcnR5R2VuZXJhdG9yKG5hbWUsIGkpLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGFyZ2V0IHRvIGRlZmluZSBwcm9wZXJ0aWVzIGZvci5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG5lZWRlZCB0byBiZSBhc3NpZ24gdG8gdGhlIHRhcmdldC5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgZGVmaW5pbmcgcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMpIHtcclxuICBpdGVyYXRlKHByb3BlcnRpZXMsIChtZXRob2QsIG5hbWUpID0+IHtcclxuICAgIGlmICgvXmdldCAvLnRlc3QobmFtZSkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZS5yZXBsYWNlKC9eZ2V0IC8sICcnKSwge1xyXG4gICAgICAgIGdldDogbWV0aG9kLFxyXG4gICAgICAgIHNldDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoL15zZXQgLy50ZXN0KG5hbWUpKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUucmVwbGFjZSgvXnNldCAvLCAnJyksIHtcclxuICAgICAgICBzZXQ6IG1ldGhvZCxcclxuICAgICAgICBnZXQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC9eZ2V0XFwvc2V0IC8udGVzdChuYW1lKSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLnJlcGxhY2UoL15nZXRcXC9zZXQgLywgJycpLCB7XHJcbiAgICAgICAgZ2V0OiBtZXRob2QuZ2V0LFxyXG4gICAgICAgIHNldDogbWV0aG9kLnNldCxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5hbWUgIT09ICdTeW1ib2wudG9TdHJpbmdUYWcnKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogbWV0aG9kLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL1N5bWJvbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBTeW1ib2wgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgfHwge1xyXG4gIHRvU3RyaW5nVGFnOiAnU3ltYm9sLnRvU3RyaW5nVGFnJyxcclxuICBpdGVyYXRvcjogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNilcclxufTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy90b0FycmF5XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRvQXJyYXkgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGlzQXJyYXksIGlzQXJyYXlMaWtlLCBpc1N0cmluZyB9IGZyb20gJy4vY2hlY2tUeXBlcyc7XHJcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB0b0FycmF5XHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBBbnkgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZU5ld0FycmF5ID0gZmFsc2VdIC0gSWYgaXQgaXMgbmVlZGVkIHRvIGNyZWF0ZSBuZXcgYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gQ3JlYXRlIGFycmF5LlxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIGFycmF5IG9mIGFueSB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KHZhbHVlLCBjcmVhdGVOZXdBcnJheSkge1xyXG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiAhY3JlYXRlTmV3QXJyYXkpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGFycmF5ID0gW107XHJcblxyXG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgIWlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgaXRlcmF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XHJcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFycmF5LnB1c2godmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFycmF5O1xyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvdmFsaWRhdGVcclxuICogQHByaXZhdGVcclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgdmFsaWRhdGUgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IHZhbGlkYXRlQ2hlY2tFeHByZXNzaW9ucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xyXG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi9jaGVja1R5cGVzJztcclxuXHJcbmNvbnN0IG51bWJlcnMgPSBbJzFzdCcsICcybmQnLCAnM3JkJywgJzR0aCcsICc1dGgnLCAnNnRoJywgJzd0aCddO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB2YWxpZGF0ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50cyBvZiBmdW5jdGlvbi5cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPYmplY3Qgd2l0aCB2YWxpZGF0ZSBwYXJhbWV0ZXJzLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gTmFtZSBvZiB0aGUgZnVuY3Rpb24gd2hhdCBjYWxsZWQgdmFsaWRhdGUuXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNoZWNraW5nIGFyZ3VtZW50cyBvZiBvdGhlciBmdW5jdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoYXJncywgb3B0aW9ucywgbmFtZSkge1xyXG4gIGl0ZXJhdGUob3B0aW9ucywgKGFycmF5LCBudW1iZXIpID0+IHtcclxuICAgIGlmICghaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgYXJyYXkgPSBbYXJyYXldO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZXJhdGUoYXJyYXksIChjaGVja2VyKSA9PiB7XHJcbiAgICAgIGNoZWNrZXIgPSB2YWxpZGF0ZUNoZWNrRXhwcmVzc2lvbnNbY2hlY2tlcl07XHJcblxyXG4gICAgICBpZiAoIWNoZWNrZXIuY2hlY2soYXJnc1tudW1iZXJdKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBjaGVja2VyLmVycm9yKGNoZWNrZXIudGV4dC5yZXBsYWNlKCckbicsIG51bWJlcnNbbnVtYmVyXSkgKyAobmFtZSA/IGAgKGF0ICR7IG5hbWUgfSlgIDogJycpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgQWxwaGFiZXRcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEFscGhhYmV0IGNsYXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGlzU3RyaW5nLCB2YWxpZGF0ZSwgZGVmaW5lUHJvcGVydGllcywgU3ltYm9sIH0gZnJvbSAnLi9oZWxwZXJzJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7U3RyaW5nfSBDaGFyXHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIG9mIG9uZSBjaGFyLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgQWxwaGFiZXRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gYWxwaGFiZXQgLSBBbHBoYWJldCB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7QWxwaGFiZXR9IEluc3RhbmNlIG9mIEFscGhhYmV0LlxyXG4gKiBAZGVzY3JpcHRpb24gQ2xhc3MgZm9yIGFscGhhYmV0IG1hbmlwdWxhdGlvbnM6IGFkZCwgZGVsZXRlIHN5bWJvbHMsIGdlbmVyYXRlIGEgdG9rZW4gZnJvbSBhbiBhbHBoYWJldCxcclxuICogY2hlY2sgaWYgYW4gYWxwaGFiZXQgY29udGFpbnMgYSB3b3JkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBuZXcgQWxwaGFiZXQoWydhJywgJ2InLCAnYyddKTtcclxuICovXHJcbmNsYXNzIEFscGhhYmV0IHtcclxuICBjb25zdHJ1Y3RvcihhbHBoYWJldCA9IFtdKSB7XHJcbiAgICBjb25zdCBhID0ge307XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFscGhhYmV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGNoYXIgPSBhbHBoYWJldFtpXTtcclxuXHJcbiAgICAgIGlmICghY2hlY2soY2hhcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VhY2ggZWxlbWVudCBvZiBhbiBhcnJheSBtdXN0IGJlIGEgc2luZ2xlIGNoYXIhIChpbiBBbHBoYWJldCknKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYVtjaGFyXSA9IGNoYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEFscGhhYmV0IyQkXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGFscGhhYmV0LlxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJyQkJywgeyB2YWx1ZTogYSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQWxwaGFiZXQjYWRkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uQ2hhcn0gY2hhcnMgLSBDaGFycyB0byBhZGQuXHJcbiAgICogQHJldHVybnMge0FscGhhYmV0fSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIG5ldyBsZXR0ZXJzIHRvIHRoZSBhbHBoYWJldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgYWxwaGFiZXQgPSBuZXcgQWxwaGFiZXQoWydhJywgJ2InLCAnYyddKTtcclxuICAgKlxyXG4gICAqIGFscGhhYmV0LmFkZCgnZCcsICdlJyk7XHJcbiAgICpcclxuICAgKiBhbHBoYWJldC5nZXQoKS4kOyAvLyBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXHJcbiAgICovXHJcbiAgYWRkKC4uLmNoYXJzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY2hhcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xyXG5cclxuICAgICAgaWYgKCFjaGVjayhjaGFyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRWFjaCBhcmd1bWVudCBtdXN0IGJlIGEgc2luZ2xlIGNoYXIhIChpbiBBbHBoYWJldCNhZGQpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJCRbY2hhcl0gPSBjaGFyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBbHBoYWJldCNjb250YWluc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gd29yZCAtIFdvcmQgdG8gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIGFscGhhYmV0IG9yIG5vdC5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHdvcmQgaW4gdGhlIGFscGhhYmV0IG9yIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgcmV0dXJucyBpZiBhIHdvcmQgaXMgaW4gYWxwaGFiZXQgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldChbJ2YnLCAnYicsICdvJywgJ2EnLCAnciddKTtcclxuICAgKlxyXG4gICAqIGFscGhhYmV0LmNvbnRhaW5zKCdmb28nKTsgLy8gdHJ1ZVxyXG4gICAqIGFscGhhYmV0LmNvbnRhaW5zKCdiYXInKTsgLy8gdHJ1ZVxyXG4gICAqIGFscGhhYmV0LmNvbnRhaW5zKCdiYXonKTsgLy8gZmFsc2VcclxuICAgKi9cclxuICBjb250YWlucyh3b3JkKSB7XHJcbiAgICB2YWxpZGF0ZShbd29yZF0sIFsnc3RyaW5nJ10sICdBbHBoYWJldCNjb250YWlucycpO1xyXG5cclxuICAgIGNvbnN0IGFscGhhYmV0ID0gdGhpcy4kJDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gd29yZC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIWFscGhhYmV0W3dvcmRbaV1dKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFscGhhYmV0I2RlbGV0ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLkNoYXJ9IGNoYXJzIC0gQ2hhcnMgdG8gZGVsZXRlLlxyXG4gICAqIEByZXR1cm5zIHtBbHBoYWJldH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlbGV0aW5nIGxldHRlcnMgZnJvbSB0aGUgYWxwaGFiZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGFscGhhYmV0ID0gbmV3IEFscGhhYmV0KFsnYScsICdiJywgJ2MnLCAnZCddKTtcclxuICAgKlxyXG4gICAqIGFscGhhYmV0LmRlbGV0ZSgnYScpO1xyXG4gICAqXHJcbiAgICogYWxwaGFiZXQuZ2V0KCkuJDsgLy8gWydiJywgJ2MnLCAnZCddXHJcbiAgICpcclxuICAgKiBhbHBoYWJldC5kZWxldGUoJ2InLCAnZCcpO1xyXG4gICAqXHJcbiAgICogYWxwaGFiZXQuZ2V0KCkuJDsgLy8gWydjJ11cclxuICAgKi9cclxuICBkZWxldGUoLi4uY2hhcnMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjaGFycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjaGFyID0gY2hhcnNbaV07XHJcblxyXG4gICAgICBpZiAoIWNoZWNrKGNoYXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIGFyZ3VtZW50IG11c3QgYmUgYSBzaW5nbGUgY2hhciEgKGluIEFscGhhYmV0I2RlbGV0ZSknKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGVsZXRlIHRoaXMuJCRbY2hhcl07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFscGhhYmV0I2dldFxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gV3JhcCBvZiBhbiBhcnJheSBvZiBhbHBoYWJldCBsZXR0ZXJzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgYXJyYXkgb2YgYWxwaGFiZXQgbGV0dGVycy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFscGhhYmV0KFsnYScsICdiJywgJ2MnXSkuZ2V0KCkuJDsgLy8gWydhJywgJ2InLCAnYyddXHJcbiAgICovXHJcbiAgZ2V0KCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuJCQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBbHBoYWJldCN0b2tlblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gVG9rZW4gbGVuZ3RoLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRva2VuLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdlbmVyYXRpbmcgcmFuZG9tIHRva2VuIHdpdGggZ2l2ZW4gbGVuZ3RoLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQWxwaGFiZXQoWydhJywgJ2InLCAnYyddKS50b2tlbig0KTsgLy8gJ2FiY2InXHJcbiAgICovXHJcbiAgdG9rZW4obGVuZ3RoKSB7XHJcbiAgICB2YWxpZGF0ZShbbGVuZ3RoXSwgW1snaW50TGlrZScsICc+MCddXSwgJ0FscGhhYmV0I3Rva2VuJyk7XHJcblxyXG4gICAgY29uc3QgYWxwaGFiZXQgPSBPYmplY3Qua2V5cyh0aGlzLiQkKTtcclxuICAgIGNvbnN0IGxlbiA9IGFscGhhYmV0Lmxlbmd0aDtcclxuICAgIGxldCB0b2tlbiA9ICcnO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdG9rZW4gKz0gYWxwaGFiZXRbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRva2VuO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhBbHBoYWJldC5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0FscGhhYmV0J1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrKGNoYXIpIHtcclxuICByZXR1cm4gaXNTdHJpbmcoY2hhcikgJiYgY2hhci5sZW5ndGggPT09IDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gYWxwaGFiZXRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gU3RyaW5nIHRvIGdlbmVyYXRlIGFuIGFscGhhYmV0IGZyb20uXHJcbiAqIEByZXR1cm5zIHtBbHBoYWJldH0gTmV3IGluc3RhbmNlIG9mIEFscGhhYmV0LlxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIGFscGhhYmV0IGZyb20gYSBzdHJpbmcgdGhhdCBoYXMgZm9ybWF0IGxpa2UgdGhpczpcclxuICogJyZsdDtjaGFyMSZndDstJmx0O2NoYXIyJmd0OyAmbHQ7Y2hhcjMmZ3Q7LSZsdDtjaGFyNCZndDsnXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IGExID0gYWxwaGFiZXQoJ2EtYyAxLTMnKTtcclxuICogY29uc3QgYTIgPSBhbHBoYWJldCgnNS01Zi1nJyk7XHJcbiAqXHJcbiAqIGExLmdldCgpLiQ7IC8vIFsnMScsICcyJywgJzMnLCAnYScsICdiJywgJ2MnXVxyXG4gKiBhMi5nZXQoKS4kOyAvLyBbJzUnLCAnZicsICdnJ11cclxuICovXHJcbmZ1bmN0aW9uIGFscGhhYmV0KHN0cmluZykge1xyXG4gIHZhbGlkYXRlKFtzdHJpbmddLCBbJ3N0cmluZyddKTtcclxuXHJcbiAgY29uc3QgcmFuZ2VzID0gc3RyaW5nLnNwbGl0KC8oW1xcc1xcU10tK1tcXHNcXFNdKT8vZyk7XHJcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VzLmxlbmd0aDtcclxuICBjb25zdCBhbHBoYWJldCA9IFtdO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcclxuXHJcbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlID09PSAnICcpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC8tLy50ZXN0KHJhbmdlKSAmJiAhL1tcXHNcXFNdLStbXFxzXFxTXS8udGVzdChyYW5nZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwYXJ0IG9mIHRoZSBzdHJpbmcgKCR7IHJhbmdlIH0pISAoaW4gYWxwaGFiZXQpYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC8tLy50ZXN0KHJhbmdlKSkge1xyXG4gICAgICBjb25zdCBzdGFydCA9IHJhbmdlLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLmNoYXJDb2RlQXQoMik7XHJcblxyXG4gICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXJ0IG9mIHRoZSByYW5nZSBtdXN0IGJlIGJlZm9yZSBpdHMgZW5kISAoaW4gYWxwaGFiZXQpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBlbmQgLSBzdGFydCArIDE7IGsgPCBsZW47IGsrKykge1xyXG4gICAgICAgIGFscGhhYmV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydCArIGspKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBhbHBoYWJldC5wdXNoKHJhbmdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgQWxwaGFiZXQoYWxwaGFiZXQpO1xyXG59XHJcblxyXG5leHBvcnQgeyBBbHBoYWJldCwgYWxwaGFiZXQgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgU3dpdGNoZXJcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIFN3aXRjaGVyIGNsYXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVW5kZWZpbmVkLFxyXG4gIGl0ZXJhdGUsIFN5bWJvbCwgdG9BcnJheSwgZGVmaW5lUHJvcGVydGllc1xyXG59IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeydib29sZWFuJ3wnZXF1YWxzJ3wnc3RyaWN0RXF1YWxzJ3wnY2FsbCd9IFN3aXRjaGVyTW9kZVxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBFbnVtIHR5cGUgb2Ygc3dpdGNoZXIgbW9kZXMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBTd2l0Y2hlckNhbGxDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBTd2l0Y2hlciB2YWx1ZS5cclxuICogQHJldHVybnMge0Jvb2xlYW58Kn0gT24gd2hhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyBkZXBlbmRzIGlmIHRoZSBjYXNlIGlzIGEgbWF0Y2ggKHRydXRoeSBmb3IgdGhlIG1hdGNoKS5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIFN3aXRjaGVyTWF0Y2hDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyAtIEFyZ3VtZW50cyBmcm9tIHRoZSBzZWNvbmQgYXJndW1lbnQgdGhhdCBzd2l0Y2hlciB3YXMgY2FsbGVkIHdpdGguXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBTd2l0Y2hlciB2YWx1ZS5cclxuICogQHBhcmFtIHsqfSBtYXRjaGVkIC0gU3dpdGNoZXIgbWF0Y2hlZCBjYXNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgU3dpdGNoZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW2Nhc2VzID0ge31dIC0gT2JqZWN0IG9mIGNhc2VzLlxyXG4gKiBAcGFyYW0ge1N3aXRjaGVyTW9kZX0gW21vZGUgPSAnZXF1YWxzJ10gLSBTd2l0Y2hlciBtb2RlLlxyXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIC0gU3dpdGNoZXIgZGVmYXVsdCB2YWx1ZS5cclxuICogQHJldHVybnMge1N3aXRjaGVyfSAtIEluc3RhbmNlIG9mIFN3aXRjaGVyLlxyXG4gKiBAZGVzY3JpcHRpb24gU3dpdGNoZXIgY2xhc3MgZm9yIGNyZWF0aW5nIGZ1bmN0aW9ucyB3b3JraW5nIHNpbWlsYXIgdG8gc3dpdGNoICh2YWx1ZSkge30gY29uc3RydWN0aW9uLFxyXG4gKiBidXQgd2l0aCB0aGUgdmFsdWUgYXNzaWdubWVudC4gU3dpdGNoZXIgaW5zdGFuY2UgaXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSB2YWx1ZSBhcmd1bWVudCBhbmQgYW4gb3B0aW9uYWxcclxuICogYXJncyBhcmd1bWVudC4gQXJncyB3aXRoIGFkZGl0aW9uYWwgc3dpdGNoZXIgdmFsdWUgYW5kIG1hdGNoZWQgY2FzZVxyXG4gKiBhcmUgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uIG9mIHRoZSBtYXRjaGVkIGNhc2UgKGlmIGl0IGlzIGEgZnVuY3Rpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcigpO1xyXG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XHJcbiAqICAgY2FzZTE6ICd2YWx1ZTEnLFxyXG4gKiAgIGNhc2UyOiAndmFsdWUyJ1xyXG4gKiB9KTtcclxuICogY29uc3Qgc3dpdGNoZXIgPSBuZXcgU3dpdGNoZXIoJ3N0cmljdEVxdWFscycpO1xyXG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XHJcbiAqICAgY2FzZTE6ICd2YWx1ZTEnLFxyXG4gKiAgIGNhc2UyOiAndmFsdWUyJ1xyXG4gKiB9LCAnc3RyaWN0RXF1YWxzJyk7XHJcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAnZGVmYXVsdFZhbHVlJyk7XHJcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKHtcclxuICogICBjYXNlMTogJ3ZhbHVlMScsXHJcbiAqICAgY2FzZTI6ICd2YWx1ZTInXHJcbiAqIH0sICdzdHJpY3RFcXVhbHMnLCAnZGVmYXVsdFZhbHVlJyk7XHJcbiAqXHJcbiAqIC8vIFNlZSBbc3dpdGNoZXJde0BsaW5rIHN3aXRjaGVyfSBleGFtcGxlcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbmNsYXNzIFN3aXRjaGVyIGV4dGVuZHMgRnVuY3Rpb24ge1xyXG4gIGNvbnN0cnVjdG9yKGNhc2VzID0ge30sIG1vZGUgPSAnZXF1YWxzJywgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGlmIChpc1N0cmluZyhjYXNlcykpIHtcclxuICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmd1bWVudHNbMV0pKSB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gbW9kZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9kZSA9IGNhc2VzO1xyXG4gICAgICBjYXNlcyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV2ZW50dWFsQ2FzZXMgPSBbXTtcclxuXHJcbiAgICBpdGVyYXRlKGNhc2VzLCAodmFsdWUsIENhc2UpID0+IHtcclxuICAgICAgZXZlbnR1YWxDYXNlcy5wdXNoKHsgY2FzZTogQ2FzZSwgdmFsdWUgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBzd2l0Y2hlcih2YWx1ZSwgYXJncyA9IFtdKSB7XHJcbiAgICAgIGNvbnN0IHsgbW9kZSwgZGVmYXVsdDogZGVmLCBjYXNlcyB9ID0gc3dpdGNoZXIuJCQ7XHJcblxyXG4gICAgICBsZXQgcmV0ID0gaXRlcmF0ZShjYXNlcywgKHsgdmFsdWU6IHZhbCwgY2FzZTogQ2FzZSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgKG1vZGUgPT09ICdib29sZWFuJyAmJiBDYXNlKSB8fFxyXG4gICAgICAgICAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xyXG4gICAgICAgICAgKG1vZGUgPT09ICdlcXVhbHMnICYmIENhc2UgPT0gdmFsdWUpIHx8XHJcbiAgICAgICAgICAobW9kZSA9PT0gJ3N0cmljdEVxdWFscycgJiYgQ2FzZSA9PT0gdmFsdWUpIHx8XHJcbiAgICAgICAgICAobW9kZSA9PT0gJ2NhbGwnICYmIENhc2UodmFsdWUpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHsgY2FzZTogQ2FzZSwgdmFsdWU6IHZhbCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoaXNVbmRlZmluZWQocmV0KSkge1xyXG4gICAgICAgIHJldCA9IHsgdmFsdWU6IGRlZiB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzRnVuY3Rpb24ocmV0LnZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByZXQudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFyZ3MgPSB0b0FycmF5KGFyZ3MsIHRydWUpO1xyXG4gICAgICBhcmdzLnB1c2godmFsdWUsIHJldC5jYXNlKTtcclxuXHJcbiAgICAgIHJldHVybiByZXQudmFsdWUuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIFN3aXRjaGVyIyQkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gY2FzZXMgLSBBcnJheSBvZiBjYXNlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3dpdGNoZXJNb2RlfSBtb2RlIC0gU3dpdGNoZXIgbW9kZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Kn0gZGVmYXVsdCAtIFN3aXRjaGVyIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29uZmlnIHBhcmFtZXRlcnMuXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzd2l0Y2hlciwgJyQkJywge1xyXG4gICAgICB2YWx1ZToge1xyXG4gICAgICAgIGNhc2VzOiBldmVudHVhbENhc2VzLFxyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFZhbHVlXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHN3aXRjaGVyLCBTd2l0Y2hlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIHJldHVybiBzd2l0Y2hlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3dpdGNoZXIjY2FzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp8U3dpdGNoZXJDYWxsQ2FsbGJhY2t8QXJyYXkuPCp8U3dpdGNoZXJDYWxsQ2FsbGJhY2s+fSBjYXNlcyAtIENhc2Ugb3IgYW4gYXJyYXkgb2YgY2FzZXMuXHJcbiAgICogQHBhcmFtIHsqfFN3aXRjaGVyTWF0Y2hDYWxsYmFja30gdmFsdWUgLSBWYWx1ZSB0aGF0IGhhcyB0byBiZSBhc3NpZ25lZCBvciBhIGZ1bmN0aW9uXHJcbiAgICogdGhhdCBpcyBjYWxsZWQgd2l0aCBzd2l0Y2hlciB2YWx1ZSwgaWYgaXQncyB0aGUgY2FzZS5cclxuICAgKiBAcmV0dXJucyB7U3dpdGNoZXJ9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWZpbmluZyBuZXcgY2FzZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IHN3ID0gbmV3IFN3aXRjaGVyKClcclxuICAgKiAgIC5jYXNlKDEsICdvbmUnKVxyXG4gICAqICAgLmNhc2UoMiwgJ3R3bycpO1xyXG4gICAqXHJcbiAgICogc3coMSk7IC8vICdvbmUnXHJcbiAgICogc3coMik7IC8vICd0d28nXHJcbiAgICovXHJcbiAgY2FzZShjYXNlcywgdmFsdWUpIHtcclxuICAgIGlmICghaXNBcnJheShjYXNlcykpIHtcclxuICAgICAgY2FzZXMgPSBbY2FzZXNdO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZXJhdGUoY2FzZXMsIChDYXNlKSA9PiB7XHJcbiAgICAgIHRoaXMuJCQuY2FzZXMucHVzaCh7IGNhc2U6IENhc2UsIHZhbHVlIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN3aXRjaGVyI2RlZmF1bHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBkZWYgLSBOZXcgZGVmYXVsdCB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7U3dpdGNoZXJ9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZWRlZmluaW5nIGRlZmF1bHQgc3dpdGNoZXIgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IHN3ID0gbmV3IFN3aXRjaGVyKClcclxuICAgKiAgIC5jYXNlKDEsICdvbmUnKVxyXG4gICAqICAgLmRlZmF1bHQoJ3RocmVlJyk7XHJcbiAgICpcclxuICAgKiBzdygxKTsgLy8gJ29uZSdcclxuICAgKiBzdygyKTsgLy8gJ3RocmVlJ1xyXG4gICAqL1xyXG4gIGRlZmF1bHQoZGVmKSB7XHJcbiAgICB0aGlzLiQkLmRlZmF1bHQgPSBkZWY7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN3aXRjaGVyI21vZGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTd2l0Y2hlck1vZGV9IG1vZGUgLSBOZXcgc3dpdGNoZXIgbW9kZS5cclxuICAgKiBAcmV0dXJucyB7U3dpdGNoZXJ9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZWRlZmluaW5nIHN3aXRjaGVyIG1vZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IHN3ID0gbmV3IFN3aXRjaGVyKClcclxuICAgKiAgIC5tb2RlKCdzdHJpY3RFcXVhbHMnKVxyXG4gICAqICAgLmNhc2UoMSwgJ251bWJlcicpXHJcbiAgICogICAuY2FzZSgnMScsICdzdHJpbmcnKTtcclxuICAgKlxyXG4gICAqIHN3KDEpOyAgIC8vICdudW1iZXInXHJcbiAgICogc3coJzEnKTsgLy8gJ3N0cmluZydcclxuICAgKi9cclxuICBtb2RlKG1vZGUpIHtcclxuICAgIHRoaXMuJCQubW9kZSA9IG1vZGU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKFN3aXRjaGVyLnByb3RvdHlwZSwge1xyXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnU3dpdGNoZXInXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBzd2l0Y2hlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2FzZXMgPSB7fV0gLSBPYmplY3Qgb2YgY2FzZXMuXHJcbiAqIEBwYXJhbSB7U3dpdGNoZXJNb2RlfSBbbW9kZSA9ICdlcXVhbHMnXSAtIFN3aXRjaGVyIG1vZGUuXHJcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gLSBTd2l0Y2hlciBkZWZhdWx0IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7U3dpdGNoZXJ9IE5ldyBpbnN0YW5jZSBvZiBTd2l0Y2hlci5cclxuICogQGRlc2NyaXB0aW9uIFNpbXBsZSB3cmFwIG9mIFtuZXcgU3dpdGNoZXIoLi4uKV17QGxpbmsgU3dpdGNoZXJ9LlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogY29uc3Qgc3cgPSBzd2l0Y2hlcih7XHJcbiAqICAgMTogJ2ZvbycsXHJcbiAqICAgMjogJ2JhcidcclxuICogfSk7XHJcbiAqIHN3KDEpOyAvLyAnZm9vJ1xyXG4gKiBzdygyKTsgLy8gJ2JhcidcclxuICogc3coMyk7IC8vIHVuZGVmaW5lZFxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogY29uc3Qgc3cgPSBzd2l0Y2hlcigpXHJcbiAqICAgLmNhc2UoWzEsIDJdLCAnZm9vJylcclxuICogICAuY2FzZSgzLCAnYmFyJyk7XHJcbiAqICAgXHJcbiAqIHN3KDEpOyAvLyAnZm9vJ1xyXG4gKiBzdygyKTsgLy8gJ2ZvbydcclxuICogc3coMyk7IC8vICdiYXInXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBzdyA9IHN3aXRjaGVyKCdjYWxsJylcclxuICogICAuY2FzZShpc0FycmF5LCAnYXJyYXknKVxyXG4gKiAgIC5jYXNlKGlzU3RyaW5nLCAnc3RyaW5nJylcclxuICogICAuY2FzZShpc051bWJlciwgJ251bWJlcicpXHJcbiAqICAgLmRlZmF1bHQoJ3Jlc3QnKTtcclxuICogICBcclxuICogc3coW10pOyAgICAvLyAnYXJyYXknXHJcbiAqIHN3KCdmb28nKTsgLy8gJ3N0cmluZydcclxuICogc3coMTIzKTsgICAvLyAnbnVtYmVyJ1xyXG4gKiBzdyh7fSk7ICAgIC8vICdyZXN0J1xyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogY29uc3Qgc3cgPSBzd2l0Y2hlcih7XHJcbiAqICAgMTogKHZhbHVlKSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh2YWx1ZSArIDEpO1xyXG4gKiAgIH0sXHJcbiAqICAgMjogKCkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codmFsdWUgLSAxKTtcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKiBcclxuICogc3coMSk7IC8vIDJcclxuICogc3coMik7IC8vIDFcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IHN3ID0gc3dpdGNoZXIoe1xyXG4gKiAgIGZpcnN0OiAoYXJyYXkpID0+IGFycmF5WzBdLFxyXG4gKiAgIGxhc3Q6IChhcnJheSkgPT4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV1cclxuICogfSwgJ2VxdWFscycsIChhcnJheSwgaW5kZXgpID0+IGFycmF5W2luZGV4XSk7XHJcbiAqIGNvbnN0IGFycmF5ID0gWzEsIDIsIDMsIDRdO1xyXG4gKiBcclxuICogc3coJ2ZpcnN0JywgW2FycmF5XSk7IC8vIDFcclxuICogc3coJ2xhc3QnLCBbYXJyYXldKTsgIC8vIDRcclxuICogc3coMSwgW2FycmF5XSk7ICAgICAgIC8vIDJcclxuICogc3coMiwgW2FycmF5XSk7ICAgICAgIC8vIDNcclxuICovXHJcbmZ1bmN0aW9uIHN3aXRjaGVyKGNhc2VzLCBtb2RlLCBkZWZhdWx0VmFsdWUpIHtcclxuICByZXR1cm4gbmV3IFN3aXRjaGVyKC4uLmFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gd2hlblxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBjb25kaXRpb24gLSBDb25kaXRpb24gdXNlZCBmb3IgcmV0dXJuaW5nIHRoZSBwcm9wZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUxIC0gVmFsdWUgaWYgdGhlIGNvbmRpdGlvbiBpcyB0cnV0aHkuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUyIC0gVmFsdWUgaWYgdGhlIGNvbmRpdGlvbiBpcyBmYWxzZXkuXHJcbiAqIEByZXR1cm5zIHsqfSB2YWx1ZTEgb3IgdmFsdWUyLlxyXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICogW3Rlcm5hcnkgb3BlcmF0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL25sL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9Db25kaXRpb25hbF9PcGVyYXRvcn0uXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiB3aGVuKHRydWUsICd0cnVlJywgJ2ZhbHNlJyk7IC8vICd0cnVlJ1xyXG4gKi9cclxuZnVuY3Rpb24gd2hlbihjb25kaXRpb24sIHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgcmV0dXJuIGNvbmRpdGlvbiA/IHZhbHVlMSA6IHZhbHVlMjtcclxufVxyXG5cclxuZXhwb3J0IHsgU3dpdGNoZXIsIHN3aXRjaGVyLCB3aGVuIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIFN1cGVyXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBTdXBlciBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBEIH0gZnJvbSAnLi9EJztcclxuaW1wb3J0IHsgc3dpdGNoZXIgfSBmcm9tICcuL1N3aXRjaGVyJztcclxuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMvY29uc3RydWN0b3JzJztcclxuaW1wb3J0IHtcclxuICBpc0FycmF5LCBpc0FycmF5TGlrZSwgaXNEYXRlLCBpc0VsZW1lbnQsIGlzRnVuY3Rpb24sIGlzTmlsLCBpc05hTiwgaXNOdWxsLFxyXG4gIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LCBpc1ByaW1pdGl2ZSwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCxcclxuICB2YWxpZGF0ZSwgdG9TdHJpbmdUYWcsIGl0ZXJhdGUsIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllc1xyXG59IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge1N1cGVyfEFycnxGdW5jfEVsZW18U3RyfE51bXxEYXR8QmxvYk9iamVjdH0gRFdyYXBcclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gQW55IGtpbmQgb2YgRC1XcmFwLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7U3RyaW5nfE51bWJlcnxudWxsfSBLZXlcclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gS2V5IHR5cGUgdXNlZCBpbiBtYW55IG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtUcmVlRWxlbWVudFtdfSBUcmVlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gVHJlZUVsZW1lbnRcclxuICogQHB1YmxpY1xyXG4gKiBAcHJvcGVydHkge0tleX0ga2V5IC0gVHJlZSBlbGVtZW50IGtleS5cclxuICogQHByb3BlcnR5IHsqfSB2YWx1ZSAtIFRyZWUgZWxlbWVudCB2YWx1ZS5cclxuICogQGRlc2NyaXB0aW9uIHtAbGluayBUcmVlfSBlbGVtZW50LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgRGVlcEl0ZXJhdGlvbkNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQgaXRlcmF0aW9uIHZhbHVlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEN1cnJlbnQgaXRlcmF0aW9uIGtleS9pbmRleC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IGVsZW1lbnRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgRGVlcFJlZHVjZUNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIC0gUHJldmlvdXMgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGl0ZXJhdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgLSBDdXJyZW50IGl0ZXJhdGlvbiBrZXkvaW5kZXguXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gSXRlcmF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBlbGVtZW50cy5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEl0ZXJhdGlvbkNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQgaXRlcmF0aW9uIHZhbHVlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEN1cnJlbnQgaXRlcmF0aW9uIGtleS9pbmRleC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgSlNPTkNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtTdHJpbmd8bnVsbH0ga2V5IC0gQ3VycmVudCB2YWx1ZS5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQga2V5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gSXRlcmF0aW9uIG9iamVjdC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIE9iamVjdENhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtPYmplY3R9IG5ld09iamVjdCAtIFRoZSBuZXcgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQ3VycmVudCBpdGVyYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gQ3VycmVudCBpdGVyYXRpb24ga2V5L2luZGV4LlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIEl0ZXJhdGlvbiBvYmplY3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBSZWR1Y2VDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSAtIFByZXZpb3VzIHZhbHVlLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQ3VycmVudCBpdGVyYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gQ3VycmVudCBpdGVyYXRpb24ga2V5L2luZGV4LlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIEl0ZXJhdGlvbiBvYmplY3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBTdXBlck1ldGhvZFxyXG4gKiBAcHVibGljXHJcbiAqIEB0aGlzIHtEV3JhcH1cclxuICovXHJcblxyXG5jb25zdCBjbG9uZVN3aXRjaGVyID0gc3dpdGNoZXIoJ2NhbGwnLCAob2JqZWN0KSA9PiBvYmplY3QpXHJcbiAgLmNhc2UoXHJcbiAgICAob2JqZWN0KSA9PiBuZXcgU3VwZXIob2JqZWN0KSA9PT0gb2JqZWN0LFxyXG4gICAgKG9iamVjdCkgPT4gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KS5jb25zdHJ1Y3RvcikobmV3IFN1cGVyKG9iamVjdC4kKS5kZWVwQ2xvbmUoKS4kKVxyXG4gIClcclxuICAuY2FzZShpc0VsZW1lbnQsIChvYmplY3QsIGRlZXApID0+IG9iamVjdC5jbG9uZShkZWVwKSlcclxuICAuY2FzZShpc0RhdGUsIChvYmplY3QpID0+IG5ldyBEYXRlKG9iamVjdCkpXHJcbiAgLmNhc2UoaXNSZWdFeHAsIChvYmplY3QpID0+IG5ldyBSZWdFeHAob2JqZWN0LnNvdXJjZSwgb2JqZWN0LnRvU3RyaW5nKCkubWF0Y2goL1tnaW11eV0qJC8pWzBdKSlcclxuICAuY2FzZShpc0FycmF5LCAoKSA9PiBbXSlcclxuICAuY2FzZShpc1BsYWluT2JqZWN0LCAoKSA9PiAoe30pKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IFtvYmplY3RdIC0gQW4gb2JqZWN0IHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtEV3JhcH0gSW5zdGFuY2Ugb2YgU3VwZXIuXHJcbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFueSB2YWx1ZS4gQW5kIHRoZXJlIGlzIG5vIHdheSB0byBjcmVhdGUgYSBuZXN0ZWQgd3JhcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogbmV3IFN1cGVyKHt9KTsgLy8gU3VwZXJcclxuICovXHJcbmNsYXNzIFN1cGVyIHtcclxuICBjb25zdHJ1Y3RvcihvYmplY3QpIHtcclxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdXBlcikge1xyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciBTdXBlciMkXHJcbiAgICAgKiBAdHlwZSB7Kn1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBXcmFwcGVkIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICckJywgeyB2YWx1ZTogb2JqZWN0IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlci5hZGRTdGF0aWNQcm9wZXJ0aWVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBvYmplY3RcclxuICAgKiB3aXRoIHByb3BlcnRpZXMga2V5cyBhbmQgdmFsdWVzIHZhbHVlcy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgcHJvcGVydHkgdmFsdWUuXHJcbiAgICogQHJldHVybnMge3RoaXN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gU2V0cyBzdGF0aWMgcHJvcGVydGllcyBmb3IgRFdyYXAgY29uc3RydWN0b3JzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBTdXBlci5hZGRTdGF0aWNQcm9wZXJ0aWVzKCdjb29sJywgNDIpO1xyXG4gICAqIFN1cGVyLmFkZFN0YXRpY1Byb3BlcnRpZXMoJ3N1cGVyQ29vbCcsIDQyKjQyKTtcclxuICAgKi9cclxuICBzdGF0aWMgYWRkU3RhdGljUHJvcGVydGllcyhwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wZXJ0eSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyLmFkZEluc3RhbmNlUHJvcGVydGllc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gb2JqZWN0XHJcbiAgICogd2l0aCBwcm9wZXJ0aWVzIGtleXMgYW5kIHZhbHVlcyB2YWx1ZXMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGlzIGhhcyB0byBiZSBhIHByb3BlcnR5IHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHt0aGlzfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFNldHMgc3RhdGljIHByb3BlcnRpZXMgZm9yIERXcmFwIHByb3RvdHlwZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIFN1cGVyLmFkZEluc3RhbmNlUHJvcGVydGllcygnY29vbCcsIDQyKTtcclxuICAgKiBTdXBlci5hZGRJbnN0YW5jZVByb3BlcnRpZXMoJ3N1cGVyQ29vbCcsIDQyKjQyKTtcclxuICAgKi9cclxuICBzdGF0aWMgYWRkSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMucHJvdG90eXBlLCBwcm9wZXJ0eSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2Fzc2lnblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLihPYmplY3R8U3VwZXJ8Kil9IG9iamVjdHMgLSBPYmplY3RzIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBvYmplY3QuXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5hc3NpZ25dXHJcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ259LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyIH0pLmFzc2lnbih7IGE6IDMgfSwgeyBjOiAzLCBkOiA0IH0sIHsgZDogNSB9KS4kOyAvLyB7IGE6IDMsIGI6IDIsIGM6IDMsIGQ6IDUgfVxyXG4gICAqL1xyXG4gIGFzc2lnbiguLi5vYmplY3RzKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgaXRlcmF0ZShvYmplY3QgJiYgYXJndW1lbnRzLCAobykgPT4ge1xyXG4gICAgICBpdGVyYXRlKG5ldyBTdXBlcihvKS4kLCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2F2ZXJhZ2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gbnVsbF0gLSBDYWxsYmFjayB0aGF0IGlzIHBhc3NlZCB0byB7QGxpbmsgU3VwZXIjc3VtfS5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBBdmVyYWdlIHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBvYmplY3Quc3VtKGNhbGxiYWNrKSAvIG9iamVjdC5jb3VudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5hdmVyYWdlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDJcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiA1IH0pLmF2ZXJhZ2UoKHZhbHVlKSA9PiB2YWx1ZSAqIHZhbHVlKTsgLy8gMTBcclxuICAgKi9cclxuICBhdmVyYWdlKGNhbGxiYWNrID0gbnVsbCkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjYXZlcmFnZScpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnN1bShjYWxsYmFjaykgLyB0aGlzLmNvdW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNjYWxsXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3VwZXJNZXRob2R9IGZ1bmMgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGlzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gQXJndW1lbnRzIHRvIGJlIGNhbGxlZCB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gb2YgZnVuY3Rpb24gY2FsbC5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgZnVuYy5jYWxsKERPYmplY3QsIC4uLmFyZ3MpO1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxIH0pLmNhbGwoZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgKiAgIHJldHVybiB0aGlzLmEgKyBiICsgYztcclxuICAgKiB9LCAyLCAzKTsgLy8gNlxyXG4gICAqL1xyXG4gIGNhbGwoZnVuYywgLi4uYXJncykge1xyXG4gICAgdmFsaWRhdGUoW2Z1bmNdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNjYWxsJyk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2Nsb25lXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBOZXcgb2JqZWN0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgYXNzaWducyBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgdG8gYW4gZW1wdHkgb25lIGFuZCByZXR1cm5zIHRoZSBuZXcgb25lLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIgfSB9KS5jbG9uZSgpLiQ7IC8vIHsgYTogMSwgYjogeyBjOiAyIH0gfVxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG4gICAgY29uc3QgY2xvbmUgPSBjbG9uZVN3aXRjaGVyKG9iamVjdCwgW29iamVjdCwgZmFsc2VdKTtcclxuXHJcbiAgICBpZiAoY2xvbmUgIT09IG9iamVjdCkge1xyXG4gICAgICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICBjbG9uZVtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihjbG9uZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIFN1cGVyI2NvdW50XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIGtleXMgb2YgdGhlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiB9KS5jb3VudDsgLy8gMlxyXG4gICAqL1xyXG4gIGdldCBjb3VudCgpIHtcclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBvYmplY3QubGVuZ3RoIDogT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2NyZWF0ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Rlc2NyaXB0b3JzXSAtIERlc2NyaXB0b3JzIHBhc3NlZCB0byBPYmplY3QuY3JlYXRlLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IGluc3RhbmNlIG9mIEQtV3JhcC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0LmNyZWF0ZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7fSkuY3JlYXRlKHtcclxuICAgKiAgIGE6IHtcclxuICAgKiAgICAgdmFsdWU6IDEsXHJcbiAgICogICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAqICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgKiAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAqICAgfVxyXG4gICAqIH0pLiQ7IC8vIHsgYTogMSB9XHJcbiAgICovXHJcbiAgY3JlYXRlKGRlc2NyaXB0b3JzKSB7XHJcbiAgICByZXR1cm4gRChpc1ByaW1pdGl2ZSh0aGlzLiQpID8gdW5kZWZpbmVkIDogT2JqZWN0LmNyZWF0ZSh0aGlzLiQsIGRlc2NyaXB0b3JzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBBc3NpZ25cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi4qfSBvYmplY3RzIC0gT2JqZWN0cyB0byBiZSBhc3NpZ25lZCB0byB0aGUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNhc3NpZ259LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxIH0pLmRlZXBBc3NpZ24oXHJcbiAgICogICB7XHJcbiAgICogICAgIGI6IHtcclxuICAgKiAgICAgICBjOiAyXHJcbiAgICogICAgIH1cclxuICAgKiAgIH0sXHJcbiAgICogICB7XHJcbiAgICogICAgIGE6IHtcclxuICAgKiAgICAgICBiOiAxXHJcbiAgICogICAgIH1cclxuICAgKiAgIH0sXHJcbiAgICogICB7XHJcbiAgICogICAgIGE6IHtcclxuICAgKiAgICAgICBjOiB7XHJcbiAgICogICAgICAgICBkOiAxXHJcbiAgICogICAgICAgfVxyXG4gICAqICAgICB9LFxyXG4gICAqICAgICBiOiAyXHJcbiAgICogICB9LFxyXG4gICAqICAgbnVsbFxyXG4gICAqIH0pO1xyXG4gICAqIC8vIHtcclxuICAgKiAvLyAgIGE6IHtcclxuICAgKiAvLyAgICAgYjogMSxcclxuICAgKiAvLyAgICAgYzoge1xyXG4gICAqIC8vICAgICAgIGQ6IDFcclxuICAgKiAvLyAgICAgfVxyXG4gICAqIC8vICAgfSxcclxuICAgKiAvLyAgIGI6IDIsXHJcbiAgICogLy8gfVxyXG4gICAqL1xyXG4gIGRlZXBBc3NpZ24oLi4ub2JqZWN0cykge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAobykgPT4ge1xyXG4gICAgICBkZWVwQXNzaWduKG9iamVjdCwgbyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcENsb25lXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IGluc3RhbmNlIG9mIERXcmFwLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBEZWVwIGNsb25pbmcgbWV0aG9kLiBDbG9uZXMgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCByZWd1bGFyIGV4cHJlc3Npb25zIGFuZCBlbGVtZW50cywgdGhlIHJlc3Qgc3RheXMgdGhlIHNhbWUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IFsyLCAzXSwgYzogeyBkOiA0IH0gfSkuZGVlcENsb25lKCkuJDtcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICBhOiAxLFxyXG4gICAqIC8vICAgYjogWzIsIDNdLFxyXG4gICAqIC8vICAgYzogeyBkOiA0IH1cclxuICAgKiAvLyB9XHJcbiAgICovXHJcbiAgZGVlcENsb25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGRlZXBDbG9uZSh0aGlzLiQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcEVxdWFsc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IFtvYmplY3RdIC0gT2JqZWN0IHRvIGNvbXBhcmUgdG8uXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG9iamVjdHMgYXJlIGRlZXAgZXF1YWwgb3Igbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZXAgY29tcGFyaXNvbiBvZiB0d28gb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSB9KS5kZWVwRXF1YWxzKHsgYTogJzEnIH0pOyAvLyB0cnVlXHJcbiAgICogbmV3IFN1cGVyKC8xLykuZGVlcEVxdWFscygvMS8pOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAgICovXHJcbiAgZGVlcEVxdWFscyhvYmplY3QgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMuJCwgb2JqZWN0LCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBFdmVyeVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogSWYgcmV0dXJucyB0cnV0aHkgaXRlcmF0aW9uIGdvZXMgb24gYW5kIGlmIGZhbHNleSBpdCBzdG9wcy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGJvb2xlYW4gaWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXHJcbiAgICogT3RoZXJ3aXNlIGZhbHNlLiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNldmVyeX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBFdmVyeSgodmFsdWUpID0+IHZhbHVlIDwgNCk7IC8vIHRydWVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiB7fSwgYjoge30sIGM6IHt9IH0pLmRlZXBFdmVyeSgoKSA9PiBmYWxzZSk7ICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAgICovXHJcbiAgZGVlcEV2ZXJ5KGNhbGxiYWNrLCBuKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgbiA9IGNhbGxiYWNrO1xyXG4gICAgICBjYWxsYmFjayA9IEJvb2xlYW47XHJcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgbiA9IEluZmluaXR5O1xyXG4gICAgfSBlbHNlIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBuID0gSW5maW5pdHk7XHJcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcclxuICAgIH1cclxuXHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEV2ZXJ5Jyk7XHJcblxyXG4gICAgbiA9IE51bWJlcihuKTtcclxuXHJcbiAgICByZXR1cm4gZGVlcEV2ZXJ5KHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGaWx0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBlbGVtZW50IGlzIGluY2x1ZGVkIGFuZCBpZiBmYWxzZXkgaXQncyBleGNsdWRlZC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBOZXcgRC1XcmFwIG9mIGZpbHRlcmVkIG9iamVjdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBmaWx0ZXJlZCBieSB0aGUgY2FsbGJhY2sgb2JqZWN0LiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNmaWx0ZXJ9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUlMikuJDsgICAgIC8vIHsgYTogMSwgYjogeyBkOiAzIH0gfVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gMSkuJDsgLy8geyBhOiAxIH1cclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPiAzKS4kOyAgIC8vIHt9XHJcbiAgICovXHJcbiAgZGVlcEZpbHRlcihjYWxsYmFjaywgbikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgIG4gPSBjYWxsYmFjaztcclxuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIG4gPSBJbmZpbml0eTtcclxuICAgIH0gZWxzZSBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgbiA9IEluZmluaXR5O1xyXG4gICAgICBjYWxsYmFjayA9IEJvb2xlYW47XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrLCBuXSwgWydmdW5jdGlvbicsIFsnbnVtYmVyTGlrZScsICc+MCddXSwgJ1N1cGVyI2RlZXBGaWx0ZXInKTtcclxuXHJcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGRlZXBGaWx0ZXIodGhpcy4kLCBjYWxsYmFjaywgbiwgW3sga2V5OiBudWxsLCB2YWx1ZTogdGhpcy4kIH1dKTtcclxuXHJcbiAgICByZXR1cm4gRChpc05pbChmaWx0ZXJlZCkgPyBmaWx0ZXJlZCA6IGZpbHRlcmVkIHx8IHt9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcEZpbmRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgZmFsc2V5IGl0IGNvbnRpbnVlcy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge1RyZWV8bnVsbH0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBpZiBzb21ldGhpbmcgZm91bmQgYW5kIG51bGwgaWYgbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRyZWUgb2YgdGhlIGVsZW1lbnRzIGlmIHNvbWV0aGluZyBmb3VuZCBhbmQgbnVsbCBpZiBub3RoaW5nIGZvdW5kLlxyXG4gICAqIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2ZpbmR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRmluZCgodmFsdWUpID0+IHZhbHVlID09PSAyKTtcclxuICAgKiAvLyBbXHJcbiAgICogLy8gICB7IGtleTogJ2MnLCB2YWx1ZTogMiB9LFxyXG4gICAqIC8vICAgeyBrZXk6ICdiJywgdmFsdWU6IHsgYzogMiwgZDogMyB9IH0sXHJcbiAgICogLy8gICB7IGtleTogbnVsbCwgdmFsdWU6IDxpbml0aWFsIG9iamVjdD4gfVxyXG4gICAqIC8vIF1cclxuICAgKi9cclxuICBkZWVwRmluZChjYWxsYmFjaywgbikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgIG4gPSBjYWxsYmFjaztcclxuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIG4gPSBJbmZpbml0eTtcclxuICAgIH0gZWxzZSBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgbiA9IEluZmluaXR5O1xyXG4gICAgICBjYWxsYmFjayA9IEJvb2xlYW47XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrLCBuXSwgWydmdW5jdGlvbicsIFsnbnVtYmVyTGlrZScsICc+MCddXSwgJ1N1cGVyI2RlZXBGaW5kJyk7XHJcblxyXG4gICAgcmV0dXJuIGRlZXBGaW5kKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGb3JFYWNoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgYW55IG9iamVjdC4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZm9yRWFjaH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGb3JFYWNoKCh2YWx1ZSwga2V5LCBvYmplY3QpID0+IG9iamVjdFtrZXldID0gdmFsdWUgKiB2YWx1ZSkuJDtcclxuICAgKiAvLyB7IGE6IDEsIGI6IHsgYzogNCwgZDogOSB9IH1cclxuICAgKi9cclxuICBkZWVwRm9yRWFjaChjYWxsYmFjaywgbiA9IEluZmluaXR5KSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEZvckVhY2gnKTtcclxuXHJcbiAgICBuID0gTnVtYmVyKG4pO1xyXG5cclxuICAgIGRlZXBGb3JFYWNoKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGb3JFYWNoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgYW55IG9iamVjdC4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZm9yRWFjaH0uXHJcbiAgICogVW5saWtlIHtAbGluayBTdXBlciNkZWVwRm9yRWFjaH0gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBvbiBldmVyeSB2YWx1ZSBvZiBldmVyeSBvYmplY3QgaW5zaWRlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGb3JFYWNoKCh2YWx1ZSwga2V5LCBvYmplY3QpID0+IG9iamVjdFtrZXldID0gdmFsdWUgKiB2YWx1ZSkuJDtcclxuICAgKiAvLyB7IGE6IDEsIGI6IHsgYzogNCwgZDogOSB9IH1cclxuICAgKi9cclxuICBkZWVwRm9yRWFjaEVudHJ5KGNhbGxiYWNrLCBuID0gSW5maW5pdHkpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwRm9yRWFjaCcpO1xyXG5cclxuICAgIG4gPSBOdW1iZXIobik7XHJcblxyXG4gICAgZGVlcEZvckVhY2hFbnRyeSh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwRnJlZXplXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNmcmVlemV9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRnJlZXplKCk7IC8vIFN1cGVyXHJcbiAgICovXHJcbiAgZGVlcEZyZWV6ZSgpIHtcclxuICAgIGRlZXBGcmVlemUodGhpcy4kKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcE1hcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBELVdyYXAgb2YgdGhlIG5ldyBvYmplY3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSB3cmFwIG9mIGEgbmV3IG9iamVjdCB1c2luZyB0aGUgY2FsbGJhY2suIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI21hcH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBNYXAoKHZhbHVlKSA9PiB2YWx1ZSAqIHZhbHVlKS4kO1xyXG4gICAqIC8vIHsgYTogMSwgYjogeyBjOiA0LCBkOiA5IH0gfVxyXG4gICAqL1xyXG4gIGRlZXBNYXAoY2FsbGJhY2ssIG4gPSBJbmZpbml0eSkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrLCBuXSwgWydmdW5jdGlvbicsIFsnbnVtYmVyTGlrZScsICc+MCddXSwgJ1N1cGVyI2RlZXBNYXAnKTtcclxuXHJcbiAgICBuID0gTnVtYmVyKG4pO1xyXG5cclxuICAgIHJldHVybiBEKGRlZXBNYXAodGhpcy4kLCBjYWxsYmFjaywgbiwgW3sga2V5OiBudWxsLCB2YWx1ZTogdGhpcy4kIH1dKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBSZWR1Y2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEZWVwUmVkdWNlQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIFJldHVybiB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIG5leHQgY2FsbGJhY2sgY2FsbC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHBhcmFtIHsqfSBbSVYgPSA8Zmlyc3QgdmFsdWU+fHVuZGVmaW5lZF0gLSBJbml0aWFsIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHsqfSBNb2RpZmllZCBJVi5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBtb2RpZmllZCBJVi4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjcmVkdWNlfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcFJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUgKiB2YWx1ZSwgSW5maW5pdHksIDApOyAvLyAxNFxyXG4gICAqL1xyXG4gIGRlZXBSZWR1Y2UoY2FsbGJhY2ssIG4gPSBJbmZpbml0eSwgSVYpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwUmVkdWNlJyk7XHJcblxyXG4gICAgbiA9IE51bWJlcihuKTtcclxuXHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcbiAgICBjb25zdCB0cmVlID0gW3sga2V5OiBudWxsLCB2YWx1ZTogdGhpcy4kIH1dO1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xyXG4gICAgICByZXR1cm4gZGVlcFJlZHVjZShvYmplY3QsIGNhbGxiYWNrLCBuLCBmYWxzZSwgdW5kZWZpbmVkLCB0cmVlKS5JVjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVlcFJlZHVjZShvYmplY3QsIGNhbGxiYWNrLCBuLCBmYWxzZSwgeyBJViB9LCB0cmVlKS5JVjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcFNvbWVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgZmFsc2V5IGl0IGNvbnRpbnVlcy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRydWUgaWYgc29tZSBvZiB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqIE90aGVyd2lzZSBmYWxzZS4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjc29tZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBTb21lKCh2YWx1ZSkgPT4gdmFsdWUgPiA0KTsgLy8gZmFsc2VcclxuICAgKiBuZXcgU3VwZXIoeyBhOiB7fSwgYjoge30sIGM6IHt9IH0pLmRlZXBTb21lKCgpID0+IHRydWUpOyAgICAgICAgICAgICAgIC8vIGZhbHNlXHJcbiAgICovXHJcbiAgZGVlcFNvbWUoY2FsbGJhY2ssIG4pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICBuID0gY2FsbGJhY2s7XHJcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcclxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBuID0gSW5maW5pdHk7XHJcbiAgICB9IGVsc2UgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIG4gPSBJbmZpbml0eTtcclxuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwU29tZScpO1xyXG5cclxuICAgIG4gPSBOdW1iZXIobik7XHJcblxyXG4gICAgcmV0dXJuIGRlZXBTb21lKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBTdHJpY3RFcXVhbHNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbb2JqZWN0XSAtIE9iamVjdCB0byBjb21wYXJlIHRvLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRoZSBvYmplY3RzIGFyZSBkZWVwIHN0cmljdCBlcXVhbCBvciBub3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVlcCBzdHJpY3QgY29tcGFyaXNvbiBvZiB0d28gb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSB9KS5kZWVwU3RyaWN0RXF1YWxzKHsgYTogJzEnIH0pOyAvLyBmYWxzZVxyXG4gICAqIG5ldyBTdXBlcigvMS8pLmRlZXBTdHJpY3RFcXVhbHMoLzEvKTsgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGRlZXBTdHJpY3RFcXVhbHMob2JqZWN0ID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLiQsIG9iamVjdCwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZmluZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhIGRlc2NyaXB0b3JzIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Rlc2NyaXB0b3JdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhpcyBoYXMgdG8gYmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBib3RoXHJcbiAgICogW09iamVjdC5kZWZpbmVQcm9wZXJ0eV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnR5fVxyXG4gICAqIGFuZFxyXG4gICAqIFtPYmplY3QuZGVmaW5lUHJvcGVydGllc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnRpZXN9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoe30pLmRlZmluZSgnYScsIHtcclxuICAgKiAgIHZhbHVlOiAxLFxyXG4gICAqICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICogICB3cml0YWJsZTogdHJ1ZSxcclxuICAgKiAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgKiB9KS4kOyAvLyB7IGE6IDEgfVxyXG4gICAqIG5ldyBTdXBlcih7fSkuZGVmaW5lKHtcclxuICAgKiAgIGE6IHtcclxuICAgKiAgICAgdmFsdWU6IDEsXHJcbiAgICogICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAqICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgKiAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAqICAgfVxyXG4gICAqIH0pLiQ7IC8vIHsgYTogMSB9XHJcbiAgICovXHJcbiAgZGVmaW5lKHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiBkZXNjcmlwdG9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJvcGVydHkgPSBuZXcgU3VwZXIocHJvcGVydHkpLiQ7XHJcblxyXG4gICAgaWYgKGlzT2JqZWN0KHRoaXMuJCkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy4kLCBwcm9wZXJ0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlbGV0ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gcHJvcHMgLSBMaXN0IG9mIHByb3BlcnRpZXMgdG8gZGVsZXRlLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL2RlbGV0ZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBtdWx0aXBsZVxyXG4gICAqIFtcImRlbGV0ZVwiIG9wZXJhdG9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvZGVsZXRlfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5kZWxldGUoJ2MnLCAnYScpLiQ7IC8vIHsgYjogMiB9XHJcbiAgICovXHJcbiAgZGVsZXRlKC4uLnByb3BzKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgaXRlcmF0ZShvYmplY3QgJiYgcHJvcHMsIChwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNlcXVhbHNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbb2JqZWN0XSAtIE9iamVjdCB0byBjb21wYXJlLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgb3Igbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0cyBhcmUgZXF1YWwgdXNpbmcgJz09JyBvcGVyYXRvciBhbmQgZmFsc2UgaWYgbm90LiBOYU5zIGFyZSBjb25zaWRlcmVkIHRvIGJlIGVxdWFsLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoMykuZXF1YWxzKCczJyk7ICAgLy8gdHJ1ZVxyXG4gICAqIG5ldyBTdXBlcihOYU4pLmVxdWFscyhOYU4pOyAvLyB0cnVlXHJcbiAgICovXHJcbiAgZXF1YWxzKG9iamVjdCkge1xyXG4gICAgY29uc3QgbyA9IHRoaXMuJDtcclxuXHJcbiAgICBvYmplY3QgPSBuZXcgU3VwZXIob2JqZWN0KS4kO1xyXG5cclxuICAgIC8qIGVzbGludCBlcWVxZXE6IDAgKi9cclxuICAgIHJldHVybiBvID09IG9iamVjdCB8fCAoaXNOYU4obykgJiYgaXNOYU4ob2JqZWN0KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2V2ZXJ5XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBnb2VzIG9uIGFuZCBpZiBmYWxzZXkgaXQgc3RvcHMuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGJvb2xlYW4gaWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuZXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA8IDQpOyAvLyB0cnVlXHJcbiAgICogbmV3IFN1cGVyKHt9KS5ldmVyeSgoKSA9PiBmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICAgKi9cclxuICBldmVyeShjYWxsYmFjayA9IEJvb2xlYW4pIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI2V2ZXJ5Jyk7XHJcblxyXG4gICAgcmV0dXJuIGl0ZXJhdGUodGhpcy4kLCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSkgIT09IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNmaWx0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGVsZW1lbnQgaXMgaW5jbHVkZWQgYW5kIGlmIGZhbHNleSBpdCdzIGV4Y2x1ZGVkLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IEQtV3JhcCBvZiBmaWx0ZXJlZCBvYmplY3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgZmlsdGVyZWQgYnkgdGhlIGNhbGxiYWNrIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSUyKS4kOyAvLyB7IGE6IDEsIGM6IDMgfVxyXG4gICAqIG5ldyBTdXBlcihudWxsKS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSUyKS4kOyAgICAgICAgICAgICAgICAgLy8gbnVsbFxyXG4gICAqL1xyXG4gIGZpbHRlcihjYWxsYmFjayA9IEJvb2xlYW4pIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI2ZpbHRlcicpO1xyXG5cclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuICAgIGNvbnN0IGFycmF5ID0gaXNBcnJheUxpa2Uob2JqZWN0KTtcclxuXHJcbiAgICAvKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cclxuICAgIGNvbnN0IG8gPSBhcnJheSA/IFtdIDogaXNOaWwob2JqZWN0KSA/IG9iamVjdCA6IHt9O1xyXG5cclxuICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xyXG4gICAgICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgICAgby5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gRChvKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZmluZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBJZiByZXR1cm5zIHRydXRoeSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIGZhbHNleSBpdCBjb250aW51ZXMuXHJcbiAgICogQHJldHVybnMge3sga2V5OiBLZXksIHZhbHVlOiAqIH18bnVsbH0geyBrZXksIHZhbHVlIH0gaWYgZm91bmQgYW5kIG51bGwgaWYgbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGZvdW5kIHsga2V5LCB2YWx1ZSB9IGlmIHNvbWV0aGluZyBmb3VuZCBhbmQgbnVsbCBpZiBub3RoaW5nIGZvdW5kLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gMik7IC8vIHsga2V5OiAnYicsIHZhbHVlOiAyIH1cclxuICAgKiBuZXcgU3VwZXIoWzEsIDIsIDNdKS5maW5kKCh2YWx1ZSkgPT4gdmFsdWUgPT09IDIpOyAgICAgICAgICAgIC8vIHsga2V5OiAxLCB2YWx1ZTogMiB9XHJcbiAgICovXHJcbiAgZmluZChjYWxsYmFjaykge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbiddLCAnU3VwZXIjZmluZCcpO1xyXG5cclxuICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiB7IGtleSwgdmFsdWUgfTtcclxuICAgICAgfVxyXG4gICAgfSkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZm9yRWFjaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpdGVyYXRpbmcgb3ZlciBhbnkgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmZvckVhY2goKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAqICAgb2JqZWN0W2tleV0gPSB2YWx1ZSAqIHZhbHVlO1xyXG4gICAqIH0pLiQ7IC8vIHsgYTogMSwgYjogeyBjOiA0LCBkOiA1IH0gfVxyXG4gICAqL1xyXG4gIGZvckVhY2goY2FsbGJhY2spIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI2ZvckVhY2gnKTtcclxuXHJcbiAgICBpdGVyYXRlKHRoaXMuJCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2ZyZWV6ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9mcmVlemVcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0LmZyZWV6ZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2ZyZWV6ZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuZnJlZXplKCk7IC8vIFN1cGVyXHJcbiAgICovXHJcbiAgZnJlZXplKCkge1xyXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzLiQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNnZXRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhIGdldHRlcnMgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZXR0ZXJdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhpcyBoYXMgdG8gYmUgYSBnZXR0ZXIgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVmaW5pbmcgZ2V0dGVycy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3Qgb2JqZWN0MSA9IG5ldyBTdXBlcih7fSkuZ2V0KCdhJywgKCkgPT4gMSkuJDtcclxuICAgKiBvYmplY3QxLmE7IC8vIDFcclxuICAgKlxyXG4gICAqIGNvbnN0IG9iamVjdDIgPSBuZXcgU3VwZXIoe30pLmdldCh7XHJcbiAgICogICBhOiAoKSA9PiAyXHJcbiAgICogfSkuJDtcclxuICAgKiBvYmplY3QyLmE7IC8vIDJcclxuICAgKi9cclxuICBnZXQocHJvcGVydHksIGdldHRlcikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogZ2V0dGVyIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGl0ZXJhdGUoaXNPYmplY3Qob2JqZWN0KSAmJiBuZXcgU3VwZXIocHJvcGVydHkpLiQsIChnZXR0ZXIsIHByb3BlcnR5KSA9PiB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7IGdldDogZ2V0dGVyIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2hhc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBrZXkgLSBQcm9wZXJ0eSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaGFzIHRoZSBrZXkgYW5kIGZhbHNlIGlmIG5vdC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9pblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtcImluXCIgb3BlcmF0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9pbn0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuaGFzKCdiJyk7IC8vIHRydWVcclxuICAgKi9cclxuICBoYXMoa2V5KSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ga2V5IGluIG9iamVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjaGFzT3duXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IGtleSAtIFByb3BlcnR5IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgaXRzIG93biBrZXkgYW5kIGZhbHNlIGlmIG5vdC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9oYXNPd25Qcm9wZXJ0eVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtPYmplY3QjaGFzT3duUHJvcGVydHlde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9oYXNPd25Qcm9wZXJ0eX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuaGFzT3duKCdiJyk7ICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5oYXNPd24oJ2hhc093blByb3BlcnR5Jyk7IC8vIGZhbHNlXHJcbiAgICovXHJcbiAgaGFzT3duKGtleSkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNpbnN0YW5jZW9mXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIC0gQ29uc3RydWN0b3IgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgY29uc3RydWN0b3IuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvaW5zdGFuY2VvZlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtcImluc3RhbmNlb2ZcIiBvcGVyYXRvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL2luc3RhbmNlb2Z9LlxyXG4gICAqL1xyXG4gIGluc3RhbmNlb2YoY29uc3RydWN0b3IpIHtcclxuICAgIHJldHVybiB0aGlzLiQgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjaXNGcm96ZW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBvYmplY3QgaXMgZnJvemVuLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRnJvemVuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5pc0Zyb3plbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRnJvemVufS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHt9KS5mcmVlemUoKS5pc0Zyb3plbigpOyAvLyB0cnVlXHJcbiAgICovXHJcbiAgaXNGcm96ZW4oKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2pzb25cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtKU09OQ2FsbGJhY2t8U3RyaW5nW119IFtyZXBsYWNlcl0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbc3BhY2VdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEpTT04gc3RyaW5nLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnlcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbSlNPTi5zdHJpbmdpZnlde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5fS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5qc29uKCk7IC8vICd7XCJhXCI6MSxcImJcIjoyLFwiY1wiOjN9J1xyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuanNvbignICAgICcpO1xyXG4gICAqIC8vIHtcclxuICAgKiAvLyAgICAgXCJhXCI6IDEsXHJcbiAgICogLy8gICAgIFwiYlwiOiAyLFxyXG4gICAqIC8vICAgICBcImNcIjogM1xyXG4gICAqIC8vIH1cclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmpzb24oKGtleSwgdmFsdWUpID0+IHtcclxuICAgKiAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICogICAgIHJldHVybiB2YWx1ZSUyID8ga2V5ICsgdmFsdWUwIDogdW5kZWZpbmVkO1xyXG4gICAqICAgfVxyXG4gICAqXHJcbiAgICogICByZXR1cm4gdmFsdWU7XHJcbiAgICogfSwgMik7XHJcbiAgICogLy8ge1xyXG4gICAqIC8vICAgXCJhXCI6IFwiYTFcIixcclxuICAgKiAvLyAgIFwiY1wiOiBcImMzXCJcclxuICAgKiAvLyB9XHJcbiAgICovXHJcbiAganNvbihyZXBsYWNlciwgc3BhY2UpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKHJlcGxhY2VyKSAmJiAhaXNBcnJheShyZXBsYWNlcikpIHtcclxuICAgICAgW10udW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgW10udW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgdGhpcy4kKTtcclxuXHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkuYXBwbHkoSlNPTiwgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIja2V5T2ZcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGZpbmQuXHJcbiAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ8bnVsbH0gQSBrZXkgb3IgYW4gaW5kZXggaWYgZm91bmQgYW5kIG51bGwgaWYgbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgZXF1YWwgdG8gdGhlIGFyZ3VtZW50IHZhbHVlIGluIHRoZSBvYmplY3QuIE5hTnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgZXF1YWwuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkua2V5T2YoMik7ICAgLy8gJ2InXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5rZXlPZignMicpOyAvLyAnYidcclxuICAgKi9cclxuICBrZXlPZih2YWx1ZSkge1xyXG4gICAgY29uc3Qga2V5ID0gaXRlcmF0ZSh0aGlzLiQsICh2YWwsIGtleSkgPT4ge1xyXG4gICAgICBpZiAodmFsID09IHZhbHVlIHx8IChpc05hTih2YWwpICYmIGlzTmFOKHZhbHVlKSkpIHtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoa2V5KSA/IG51bGwgOiBrZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2tleU9mU3RyaWN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBmaW5kLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfG51bGx9IEEga2V5IG9yIGFuIGluZGV4IGlmIGZvdW5kIGFuZCBudWxsIGlmIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIHN0cmljdCBlcXVhbCB0byB0aGUgYXJndW1lbnQgdmFsdWUgaW4gdGhlIG9iamVjdC4gTmFOcyBhcmUgY29uc2lkZXJlZCB0byBiZSBlcXVhbC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5rZXlPZlN0cmljdCgyKTsgICAvLyAnYidcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmtleU9mU3RyaWN0KCcyJyk7IC8vICdiJ1xyXG4gICAqL1xyXG4gIGtleU9mU3RyaWN0KHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBpdGVyYXRlKHRoaXMuJCwgKHZhbCwga2V5KSA9PiB7XHJcbiAgICAgIGlmICh2YWwgPT09IHZhbHVlIHx8IChpc05hTih2YWwpICYmIGlzTmFOKHZhbHVlKSkpIHtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoa2V5KSA/IG51bGwgOiBrZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2tleXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBBIHdyYXAgb2YgdGhlIGtleXMgYXJyYXkuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1xyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtPYmplY3Qua2V5c117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXN9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmtleXMoKS4kOyAvLyBbJ2EnLCAnYicsICdjJ11cclxuICAgKiBuZXcgU3VwZXIobnVsbCkua2V5cygpLiQ7ICAgICAgICAgICAgICAgICAvLyBbXVxyXG4gICAqL1xyXG4gIGtleXMoKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIEQoaXNPYmplY3Qob2JqZWN0KSA/IE9iamVjdC5rZXlzKG9iamVjdCkgOiBbXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI21hcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBSZXR1cm4gdmFsdWUgaXMgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gRC1XcmFwIG9mIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgd3JhcCBvZiBhIG5ldyBvYmplY3QgdXNpbmcgdGhlIGNhbGxiYWNrLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLm1hcCgodmFsdWUpID0+IHZhbHVlICogMikuJDsgLy8geyBhOiAyLCBiOiA0LCBjOiA2IH1cclxuICAgKiBuZXcgU3VwZXIobnVsbCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKiAyKS4kOyAgICAgICAgICAgICAgICAgLy8gbnVsbFxyXG4gICAqL1xyXG4gIG1hcChjYWxsYmFjaykge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbiddLCAnU3VwZXIjbWFwJyk7XHJcblxyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG4gICAgY29uc3QgbyA9IGlzQXJyYXlMaWtlKG9iamVjdCkgPyBbXSA6IGlzTnVsbChvYmplY3QpID8gbnVsbCA6IHt9O1xyXG5cclxuICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICBvW2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEQobyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI21heFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBSZXR1cm4gdmFsdWUgaXMgdXNlZCBmb3IgY29tcGFyaXNvbiB3aXRoIHRoZSBwcmV2aW91cyBtYXggdmFsdWUuXHJcbiAgICogQHJldHVybnMge3trZXk6IEtleSwgdmFsdWU6IE51bWJlcn19IE9iamVjdCB3aXRoIG1heCB2YWx1ZSBhbmQga2V5IG9mIHRoZSBtYXggdmFsdWUuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBtYXggdmFsdWUgaW4gdGhlIG9iamVjdC5cclxuICAgKiBJZiBubyBjYWxsYmFjayBpcyBwcmVzZW50IGNvbXBhcmlzb24gaXMgYmV0d2VlbiB2YWx1ZXMgb2YgdGhlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5tYXgoKTsgICAgICAgICAgICAgICAgICAgICAvLyB7IGtleTogJ2MnLCB2YWx1ZTogMyB9XHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5tYXgoKHZhbHVlKSA9PiA0IC0gdmFsdWUpOyAvLyB7IGtleTogJ2EnLCB2YWx1ZTogMyB9XHJcbiAgICogbmV3IFN1cGVyKHsgYTogJ2EnLCBiOiAnYicsIGM6ICdjJyB9KS5tYXgoKTsgICAgICAgICAgICAgICAvLyB7IGtleTogbnVsbCwgdmFsdWU6IC1JbmZpbml0eSB9XHJcbiAgICovXHJcbiAgbWF4KGNhbGxiYWNrID0gbnVsbCkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjbWF4Jyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChtYXgsIHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB2YWwgPSBOdW1iZXIoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpO1xyXG5cclxuICAgICAgaWYgKHZhbCA+IG1heC52YWx1ZSkge1xyXG4gICAgICAgIG1heC5rZXkgPSBrZXk7XHJcbiAgICAgICAgbWF4LnZhbHVlID0gdmFsO1xyXG4gICAgICB9XHJcbiAgICB9LCB7IGtleTogbnVsbCwgdmFsdWU6IC1JbmZpbml0eSB9KS4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNtaW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIGNvbXBhcmlzb24gd2l0aCB0aGUgcHJldmlvdXMgbWluIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHt7a2V5OiBLZXksIHZhbHVlOiBOdW1iZXJ9fSBPYmplY3Qgd2l0aCBtaW4gdmFsdWUgYW5kIGtleSBvZiB0aGUgbWluIHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbWluIHZhbHVlIGluIHRoZSBvYmplY3QuXHJcbiAgICogSWYgbm8gY2FsbGJhY2sgaXMgcHJlc2VudCBjb21wYXJpc29uIGlzIGJldHdlZW4gdmFsdWVzIG9mIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkubWluKCk7ICAgICAgICAgICAgICAgICAgICAgLy8geyBrZXk6ICdhJywgdmFsdWU6IDEgfVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkubWluKCh2YWx1ZSkgPT4gNCAtIHZhbHVlKTsgLy8geyBrZXk6ICdjJywgdmFsdWU6IDEgfVxyXG4gICAqIG5ldyBTdXBlcih7IGE6ICdhJywgYjogJ2InLCBjOiAnYycgfSkubWluKCk7ICAgICAgICAgICAgICAgLy8geyBrZXk6IG51bGwsIHZhbHVlOiBJbmZpbml0eSB9XHJcbiAgICovXHJcbiAgbWluKGNhbGxiYWNrID0gbnVsbCkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjbWluJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChtaW4sIHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB2YWwgPSBOdW1iZXIoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpO1xyXG5cclxuICAgICAgaWYgKHZhbCA8IG1pbi52YWx1ZSkge1xyXG4gICAgICAgIG1pbi5rZXkgPSBrZXk7XHJcbiAgICAgICAgbWluLnZhbHVlID0gdmFsO1xyXG4gICAgICB9XHJcbiAgICB9LCB7IGtleTogbnVsbCwgdmFsdWU6IEluZmluaXR5IH0pLiQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI29iamVjdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge09iamVjdENhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBAcGFyYW0ge09iamVjdHwqfSBbb2JqZWN0ID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFdyYXAgb2YgdGhlIG5ldyBvYmplY3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIFR5cGUgb2Yge0BsaW5rIFN1cGVyI3JlZHVjZX0uXHJcbiAgICogVGhlIG9iamVjdCBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQgaW50byB0aGUgY2FsbGJhY2suIFRoZSBvdXRwdXQgaXMgdGhpcyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIgfSkub2JqZWN0KChvYmplY3QsIHZhbHVlLCBrZXkpID0+IHtcclxuICAgKiAgIG9iamVjdFtrZXldID0gdmFsdWU7XHJcbiAgICogICBvYmplY3Rba2V5ICsga2V5XSA9IHZhbHVlICogMjtcclxuICAgKiB9KS4kOyAvLyB7IGE6IDEsIGFhOiAyLCBiOiAyLCBiYjogNCB9XHJcbiAgICovXHJcbiAgb2JqZWN0KGNhbGxiYWNrLCBvYmplY3QgPSB7fSkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbiddLCAnU3VwZXIjb2JqZWN0Jyk7XHJcblxyXG4gICAgaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSwga2V5LCBvYmopID0+IHtcclxuICAgICAgY2FsbGJhY2sob2JqZWN0LCB2YWx1ZSwga2V5LCBvYmopO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEQob2JqZWN0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjcHJvcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgKj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gYXNzaWduZWQgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nXHJcbiAgICogdGhpcyBoYXMgdG8gYmUgYW4gYXNzaWduZWQgdmFsdWUgaWYgaXQncyBwcmVzZW50LlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcHwqfSBSZXR1cm5zIHRoaXMgaWYgaXQncyBhIHNldHRlciBvciBhIHZhbHVlIGlmIGdldHRlci5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGFuZCBzZXR0aW5nIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkucHJvcCgnYScpOyAgICAgICAgICAgICAgLy8gMVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkucHJvcCgnYScsIDcpLiQ7ICAgICAgICAgLy8geyBhOiA3LCBiOiAyLCBjOiAzIH1cclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnByb3AoeyBhOiA3LCBiOiA4IH0pLiQ7IC8vIHsgYTogNywgYjogOCwgYzogMyB9XHJcbiAgICovXHJcbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcocHJvcGVydHkpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiQgPyB0aGlzLiRbcHJvcGVydHldIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXNzaWduKHByb3BlcnR5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjcHJvcGVydHlEZXNjcmlwdG9yXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIFByb3BlcnR5IG9mIHRoZSBvYmplY3QuXHJcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IFByb3BlcnR5IGRlc2NyaXB0b3IuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXHJcbiAgICogQGRlc2NyaXB0b3IgU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5RGVzY3JpcHRvcn0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEgfSkucHJvcGVydHlEZXNjcmlwdG9yKCdhJyk7XHJcbiAgICogLy8ge1xyXG4gICAqIC8vICAgdmFsdWU6IDEsXHJcbiAgICogLy8gICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAqIC8vICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICogLy8gICBjb25maWd1cmFibGU6IHRydWVcclxuICAgKiAvLyB9XHJcbiAgICovXHJcbiAgcHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnR5KSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNwcm9wZXJ0eU5hbWVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gRC1XcmFwIG9mIHRoZSBuYW1lcyBhcnJheS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgICogQGRlc2NyaXB0b3IgU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eU5hbWVzfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiB9KS5kZWZpbmUoJ2MnLCB7IHZhbHVlOiAzIH0pLiQ7IC8vIFsnYScsICdiJywgJ2MnXVxyXG4gICAqL1xyXG4gIHByb3BlcnR5TmFtZXMoKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIEQoaXNPYmplY3Qob2JqZWN0KSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkgOiBbXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3Byb3BlcnR5U3ltYm9sc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IEQtV3JhcCBvZiB0aGUgbmFtZXMgYXJyYXkuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlTeW1ib2xzXHJcbiAgICogQGRlc2NyaXB0b3IgU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5U3ltYm9sc30uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IFtTeW1ib2woJ2ZvbycpXTogMSB9KS5kZWZpbmUoU3ltYm9sKCdiYXInKSwgeyB2YWx1ZTogMiB9KS4kOyAvLyBbU3ltYm9sKCdmb28nKSwgU3ltYm9sKCdiYXInKV1cclxuICAgKi9cclxuICBwcm9wZXJ0eVN5bWJvbHMoKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIEQoaXNPYmplY3Qob2JqZWN0KSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSA6IFtdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjcHJvdG9cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbcHJvdG9dIC0gSWYgaXQncyBwcmVzZW50IGl0J3Mgc2V0IGFzIGEgcHJvdG90eXBlIHRvIHRoZSBvYmplY3QuXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBJbiBnZXR0ZXIgbW9kZSByZXR1cm5zIHdyYXAgb2YgdGhlIHByb3RvdHlwZSBhbmQgaW4gc2V0dGVyIG1vZGUgcmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBib3RoXHJcbiAgICogW09iamVjdC5nZXRQcm90b3R5cGVPZl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldFByb3RvdHlwZU9mfVxyXG4gICAqIGFuZFxyXG4gICAqIFtPYmplY3Quc2V0UHJvdG90eXBlT2Zde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9zZXRQcm90b3R5cGVPZn0uXHJcbiAgICovXHJcbiAgcHJvdG8ocHJvdG8pIHtcclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuICAgIGNvbnN0IGlzQ29udGV4dE9iamVjdCA9ICFpc05pbChvYmplY3QpO1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIGlmIChpc0NvbnRleHRPYmplY3QgJiYgKGlzT2JqZWN0KHByb3RvKSB8fCBpc051bGwocHJvdG8pKSkge1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmplY3QsIHByb3RvKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzQ29udGV4dE9iamVjdCA/IG5ldyBTdXBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkgOiBuZXcgU3VwZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjcmVkdWNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7UmVkdWNlQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIFJldHVybiB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIG5leHQgY2FsbGJhY2sgY2FsbC5cclxuICAgKiBAcGFyYW0geyp9IFtJViA9IDxmaXJzdCB2YWx1ZT58dW5kZWZpbmVkXSAtIEluaXRpYWwgdmFsdWUuXHJcbiAgICogQHJldHVybnMgeyp9IE1vZGlmaWVkIElWLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIG1vZGlmaWVkIElWLiBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIG5vdCBwcmVzZW50IGZpcnN0IHZhbHVlIGluIHRoZSBvYmplY3QgaXMgdGFrZW5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlICogdmFsdWUsIDApOyAvLyAxNFxyXG4gICAqL1xyXG4gIHJlZHVjZShjYWxsYmFjaywgSVYpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI3JlZHVjZScpO1xyXG5cclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuXHJcbiAgICBsZXQgc3RhcnRLZXk7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgc3RhcnRLZXkgPSBrZXk7XHJcbiAgICAgICAgSVYgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICBpZiAoa2V5ICE9PSBzdGFydEtleSkge1xyXG4gICAgICAgIElWID0gY2FsbGJhY2soSVYsIHZhbHVlLCBrZXksIG9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBJVjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjc2V0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYSBzZXR0ZXJzIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dGVyXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgc2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZmluaW5nIHNldHRlcnMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IG9iamVjdCA9IG5ldyBTdXBlcih7fSlcclxuICAgKiAgIC5nZXQoJ3B1YmxpYycsIGZ1bmN0aW9uICgpIHtcclxuICAgKiAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGU7XHJcbiAgICogICB9KVxyXG4gICAqICAgLnNldCgncHVibGljJywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICogICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICogICAgICAgdGhpcy5fcHJpdmF0ZSA9IHZhbHVlO1xyXG4gICAqICAgICB9XHJcbiAgICogICB9KTtcclxuICAgKiBvYmplY3QucHJvcCgncHVibGljJywgJzEnKS4kOyAvLyB7IHB1YmxpYzogdW5kZWZpbmVkIH1cclxuICAgKiBvYmplY3QucHJvcCgncHVibGljJywgMSkuJDsgICAvLyB7IHB1YmxpYzogMSwgX3ByaXZhdGU6IDEgfVxyXG4gICAqXHJcbiAgICogbmV3IFN1cGVyKHt9KS5zZXQoe1xyXG4gICAqICAgcHVibGljKHZhbHVlKSB7XHJcbiAgICogICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICogICAgICAgdGhpcy5fcHJpdmF0ZSA9IHZhbHVlO1xyXG4gICAqICAgICB9XHJcbiAgICogICB9XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgc2V0KHByb3BlcnR5LCBzZXR0ZXIpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHNldHRlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuXHJcbiAgICBpdGVyYXRlKGlzT2JqZWN0KG9iamVjdCkgJiYgbmV3IFN1cGVyKHByb3BlcnR5KS4kLCAoc2V0dGVyLCBwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyBzZXQ6IHNldHRlciB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNzb21lXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgZmFsc2V5IGl0IGNvbnRpbnVlcy5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdHJ1ZSBpZiBzb21lIG9mIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuIE90aGVyd2lzZSBmYWxzZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPiA0KTsgLy8gZmFsc2VcclxuICAgKiBuZXcgU3VwZXIoe30pLnNvbWUoKCkgPT4gdHJ1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIHNvbWUoY2FsbGJhY2sgPSBCb29sZWFuKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNzb21lJyk7XHJcblxyXG4gICAgcmV0dXJuIGl0ZXJhdGUodGhpcy4kLCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pIHx8IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNzdHJpY3RFcXVhbHNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbb2JqZWN0XSAtIE9iamVjdCB0byBjb21wYXJlLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgb3Igbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0cyBhcmUgZXF1YWwgdXNpbmcgJz09PScgb3BlcmF0b3IgYW5kIGZhbHNlIGlmIG5vdC5cclxuICAgKiBOYU5zIGFyZSBjb25zaWRlcmVkIHRvIGJlIHN0cmljdCBlcXVhbC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKDMpLnN0cmljdEVxdWFscygnMycpOyAgIC8vIGZhbHNlXHJcbiAgICogbmV3IFN1cGVyKE5hTikuc3RyaWN0RXF1YWxzKE5hTik7IC8vIHRydWVcclxuICAgKi9cclxuICBzdHJpY3RFcXVhbHMob2JqZWN0KSB7XHJcbiAgICBjb25zdCBvID0gdGhpcy4kO1xyXG5cclxuICAgIG9iamVjdCA9IG5ldyBTdXBlcihvYmplY3QpLiQ7XHJcblxyXG4gICAgcmV0dXJuIG8gPT09IG9iamVjdCB8fCAoaXNOYU4obykgJiYgaXNOYU4ob2JqZWN0KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3N1bVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBudWxsXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBTdW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIFR5cGUgb2Yge0BsaW5rIFN1cGVyI3JlZHVjZX0uXHJcbiAgICogSWYgdGhlIGNhbGxiYWNrIGlzIHByZXNlbnQgaXQncyB1c2VkIGZvciBzdW1taW5nLiBJZiBub3QgdGhlIHZhbHVlIGlzIHVzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuc3VtKCk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDZcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnN1bSgodmFsdWUpID0+IHZhbHVlICogdmFsdWUpOyAvLyAxNFxyXG4gICAqL1xyXG4gIHN1bShjYWxsYmFjayA9IG51bGwpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb258fCEnXSwgJ1N1cGVyI3N1bScpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnJlZHVjZSgoc3VtLCB2YWx1ZSwga2V5LCBvYmplY3QpID0+IChcclxuICAgICAgc3VtICsgTnVtYmVyKGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSA6IHZhbHVlKVxyXG4gICAgKSwgMCk7XHJcbiAgfVxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBTdXBlciN0b1N0cmluZ1RhZ1xyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRvU3RyaW5nIHRhZyBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoe30pLnRvU3RyaW5nVGFnOyAvLyAnT2JqZWN0J1xyXG4gICAqIG5ldyBTdXBlcihbXSkudG9TdHJpbmdUYWc7IC8vICdBcnJheSdcclxuICAgKiBuZXcgU3VwZXIoMSkudG9TdHJpbmdUYWc7ICAvLyAnTnVtYmVyJ1xyXG4gICAqL1xyXG4gIGdldCB0b1N0cmluZ1RhZygpIHtcclxuICAgIHJldHVybiB0b1N0cmluZ1RhZyh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBTdXBlciN0eXBlXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1widHlwZW9mXCIgb3BlcmF0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9pbnN0YW5jZW9mfS4uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7fSkudHlwZTsgICAvLyAnb2JqZWN0J1xyXG4gICAqIG5ldyBTdXBlcigxKS50eXBlOyAgICAvLyAnbnVtYmVyJ1xyXG4gICAqIG5ldyBTdXBlcignMScpLnR5cGU7ICAvLyAnc3RyaW5nJ1xyXG4gICAqIG5ldyBTdXBlcih0cnVlKS50eXBlOyAvLyAnYm9vbGVhbidcclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdGhpcy4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciN2YWx1ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgKj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYSB2YWx1ZXMgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsICo+fSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhpcyBoYXMgdG8gYmUgYSB2YWx1ZSB0byBiZSBzZXQuXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVmaW5pbmcgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSwgbm9uLWNvbmZpZ3VyYWJsZSB2YWx1ZXMuXHJcbiAgICogU3lub255bSBmb3Igb2JqZWN0LmRlZmluZShwcm9wZXJ0eSwgeyB2YWx1ZTogdmFsdWUgfSkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7fSkudmFsdWUoJ2EnLCAxKS4kOyAvLyB7IGE6IDEgfVxyXG4gICAqIG5ldyBTdXBlcih7fSkudmFsdWUoe1xyXG4gICAqICAgYTogMVxyXG4gICAqIH0pLiQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7IGE6IDEgfVxyXG4gICAqL1xyXG4gIHZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgaXRlcmF0ZShpc09iamVjdChvYmplY3QpICYmIG5ldyBTdXBlcihwcm9wZXJ0eSkuJCwgKHZhbHVlLCBwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyB2YWx1ZSB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciN2YWx1ZXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBBIHdyYXAgb2YgdGhlIHZhbHVlcyBhcnJheS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBELVdyYXAgb2YgdGhlIHZhbHVlcyBhcnJheS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS52YWx1ZXMoKS4kOyAvLyBbMSwgMiwgM11cclxuICAgKiBuZXcgU3VwZXIobnVsbCkudmFsdWVzKCkuJDsgICAgICAgICAgICAgICAgIC8vIFtdXHJcbiAgICovXHJcbiAgdmFsdWVzKCkge1xyXG4gICAgY29uc3QgYXJyYXkgPSBbXTtcclxuXHJcbiAgICBpdGVyYXRlKHRoaXMuJCwgKHZhbHVlKSA9PiB7XHJcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEQoYXJyYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciN3b3JkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENvbmNhdGVuYXRlZCBzdHJpbmcuXHJcbiAgICogQGRlc2NyaXB0aW9uIFR5cGUgb2Yge0BsaW5rIFN1cGVyI3JlZHVjZX0uXHJcbiAgICogSWYgdGhlIGNhbGxiYWNrIGlzIHByZXNlbnQgaXQncyB1c2VkIGZvciBjb25jYXRlbmF0aW5nLiBJZiBub3QgdGhlIHZhbHVlIGlzIHVzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkud29yZCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTIzJ1xyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkud29yZCgodmFsdWUpID0+IHZhbHVlICsgdmFsdWUpOyAvLyAnMTEyMjMzJ1xyXG4gICAqL1xyXG4gIHdvcmQoY2FsbGJhY2sgPSBudWxsKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9ufHwhJ10sICdTdXBlciN3b3JkJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKCh3b3JkLCB2YWx1ZSwga2V5LCBvYmplY3QpID0+IChcclxuICAgICAgd29yZCArIFN0cmluZyhjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkgOiB2YWx1ZSlcclxuICAgICksICcnKTtcclxuICB9XHJcbn1cclxuXHJcbmRlZmluZVByb3BlcnRpZXMoU3VwZXIucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdTdXBlcidcclxufSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBBc3NpZ25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB0YXJnZXQgLSBPYmplY3QgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGFzc2lnbiBwcm9wZXJ0aWVzIGZyb20uXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQsIG9iamVjdCkge1xyXG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgaWYgKGlzUHJpbWl0aXZlKHRhcmdldFtrZXldKSB8fCAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcclxuICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwQ2xvbmUodmFsdWUpO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNQcmltaXRpdmUodGFyZ2V0W2tleV0pKSB7XHJcbiAgICAgIGRlZXBBc3NpZ24odGFyZ2V0W2tleV0sIHZhbHVlKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwQ2xvbmVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gY2xvbmUuXHJcbiAqIEBkZXNjcmlwdGlvbiBEb2VzIHRoZSBkZWVwIGNsb25pbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqZWN0KSB7XHJcbiAgY29uc3QgY2xvbmUgPSBjbG9uZVN3aXRjaGVyKG9iamVjdCwgW29iamVjdCwgdHJ1ZV0pO1xyXG5cclxuICBpZiAoY2xvbmUgIT09IG9iamVjdCkge1xyXG4gICAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgIGNsb25lW2tleV0gPSBkZWVwQ2xvbmUodmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2xvbmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcEVxdWFsXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gbzEgLSBGaXJzdCBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHsqfSBvMiAtIFNlY29uZCBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtCb29sZWFufSBzdHJpY3QgLSBJZiBjb21wYXJpc29uIHNob3VsZCBiZSBzdHJpY3Qgb3Igbm90LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBJZiB0aGUgb2JqZWN0IGFyZSBkZWVwIGVxdWFsIG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFcXVhbChvMSwgbzIsIHN0cmljdCkge1xyXG4gIGlmIChvMSA9PT0gbzIpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTmFOKG8xKSAmJiBpc05hTihvMikgJiYgaXNQcmltaXRpdmUobzEpICYmIGlzUHJpbWl0aXZlKG8yKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNOYU4obzEpIHx8IGlzTmFOKG8yKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzUHJpbWl0aXZlKG8xKSB8fCBpc1ByaW1pdGl2ZShvMikpIHtcclxuICAgIHJldHVybiBzdHJpY3QgPyBvMSA9PT0gbzIgOiBvMSA9PSBvMjtcclxuICB9XHJcblxyXG4gIGlmIChpc0RhdGUobzEpICYmIGlzRGF0ZShvMikpIHtcclxuICAgIHJldHVybiBvMS5nZXRUaW1lKCkgPT09IG8yLmdldFRpbWUoKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0RhdGUobzEpIHx8IGlzRGF0ZShvMikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChpc1JlZ0V4cChvMSkgJiYgaXNSZWdFeHAobzIpKSB7XHJcbiAgICByZXR1cm4gbzEuc291cmNlID09PSBvMi5zb3VyY2UgJiZcclxuICAgICAgbzEudG9TdHJpbmcoKS5tYXRjaCgvW2dpbXV5XSokLylbMF0gPT09IG8yLnRvU3RyaW5nKCkubWF0Y2goL1tnaW11eV0qJC8pWzBdICYmXHJcbiAgICAgIG8xLmxhc3RJbmRleCA9PT0gbzIubGFzdEluZGV4O1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzUmVnRXhwKG8xKSB8fCBpc1JlZ0V4cChvMikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICgoIWlzUGxhaW5PYmplY3QobzEpICYmICFpc0FycmF5KG8xKSkgfHwgKCFpc1BsYWluT2JqZWN0KG8yKSAmJiAhaXNBcnJheShvMikpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvMSk7XHJcbiAgY29uc3QgcDIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzEpO1xyXG5cclxuICBpZiAoT2JqZWN0LmtleXMobzEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMobzIpLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHAxICYmIHAyICYmICh0b1N0cmluZ1RhZyhwMS5jb25zdHJ1Y3RvcikgIT09IHRvU3RyaW5nVGFnKHAyLmNvbnN0cnVjdG9yKSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpdGVyYXRlKG8xLCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgaWYgKCEoa2V5IGluIG8yKSB8fCAhZGVlcEVxdWFsKHZhbHVlLCBvMltrZXldLCBzdHJpY3QpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9KSAhPT0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcEV2ZXJ5XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgZWxlbWVudC5cclxuICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGl0ZXJhdGlvbiBnb2VzIG9uIGFuZCBpZiBub3QgaXQgc3RvcHMuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBJZiBhbGwgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFdmVyeShvYmplY3QsIGNhbGxiYWNrLCBuLCB0cmVlKSB7XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgcmV0dXJuIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpXHJcbiAgICAgICAgPyAhY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0LCBuZXdUcmVlKVxyXG4gICAgICAgIDogIWRlZXBFdmVyeSh2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9KSAhPT0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcEZpbHRlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBlbGVtZW50IGlzIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQgYW5kIGlmIG5vdCBpdCdzIGV4Y2x1ZGVkLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbiAtIERlcHRoIG9mIGl0ZXJhdGlvbi5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMgeyp9IEZpbHRlcmVkIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBGaWx0ZXIob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xyXG4gIGNvbnN0IGFycmF5ID0gaXNBcnJheUxpa2Uob2JqZWN0KTtcclxuICBjb25zdCBudWwgPSBpc05pbChvYmplY3QpO1xyXG4gIGNvbnN0IG8gPSBhcnJheSA/IFtdIDogbnVsID8gb2JqZWN0IDoge307XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcclxuXHJcbiAgICBpZiAoKGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSkpICYmIGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSkpIHtcclxuICAgICAgaWYgKGFycmF5KSB7XHJcbiAgICAgICAgby5wdXNoKHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZW5kKSB7XHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gZGVlcEZpbHRlcih2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKTtcclxuXHJcbiAgICAgIGlmIChmaWx0ZXJlZCkge1xyXG4gICAgICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgICAgby5wdXNoKGZpbHRlcmVkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb1trZXldID0gZmlsdGVyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChhcnJheSkge1xyXG4gICAgcmV0dXJuIG8ubGVuZ3RoID8gbyA6IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGlmICghbnVsKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykubGVuZ3RoID8gbyA6IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHJldHVybiBvO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBGaW5kXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgZWxlbWVudC5cclxuICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgbm90IGl0IGNvbnRpbnVlcy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZSAtIFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gb2JqZWN0cyBvZiBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtUcmVlfG51bGx9IC0gSWYgZm91bmQgdGhlIHdob2xlIHRyZWUgaXMgcmV0dXJuZWQgYW5kIGlmIG5vdCBpdCdzIG51bGwgd2hhdCdzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEZpbmQob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xyXG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XHJcblxyXG4gIHJldHVybiBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IFt7IGtleSwgdmFsdWUgfV0uY29uY2F0KHRyZWUpO1xyXG5cclxuICAgIGlmIChlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpKSB7XHJcbiAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1RyZWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBkZWVwRmluZCh2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKTtcclxuXHJcbiAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSkgfHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwRm9yRWFjaFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBGb3JFYWNoKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcclxuICBjb25zdCBlbmQgPSBuID09PSAxO1xyXG5cclxuICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IFt7IGtleSwgdmFsdWUgfV0uY29uY2F0KHRyZWUpO1xyXG5cclxuICAgIGlmIChlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpKSB7XHJcbiAgICAgIGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWVwRm9yRWFjaCh2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwRm9yRWFjaEVudHJ5XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgZWxlbWVudC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZSAtIFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gb2JqZWN0cyBvZiBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEZvckVhY2hFbnRyeShvYmplY3QsIGNhbGxiYWNrLCBuLCB0cmVlKSB7XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcclxuXHJcbiAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpO1xyXG5cclxuICAgIGlmICghZW5kICYmICFpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcclxuICAgICAgZGVlcEZvckVhY2hFbnRyeSh2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwRnJlZXplXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGZyZWV6ZS5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRnJlZXplKG9iamVjdCkge1xyXG4gIE9iamVjdC5mcmVlemUob2JqZWN0KTtcclxuICBpdGVyYXRlKG9iamVjdCwgZGVlcEZyZWV6ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcE1hcFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIFJldHVybmVkIHZhbHVlIGlzIHVzZWQgdG8gY3JlYXRlIHRvIG5ldyBvYmplY3QuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7Kn0gTmV3IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBNYXAob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xyXG4gIGNvbnN0IG8gPSBpc0FycmF5TGlrZShvYmplY3QpID8gW10gOiBpc05pbChvYmplY3QpID8gb2JqZWN0IDoge307XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcclxuXHJcbiAgICBvW2tleV0gPSBlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpXHJcbiAgICAgID8gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0LCBuZXdUcmVlKVxyXG4gICAgICA6IGRlZXBNYXAodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBvO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBSZWR1Y2VcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0RlZXBSZWR1Y2VDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxyXG4gKiBSZXR1cm5lZCB2YWx1ZSBpcyB1c2VkIHRvIGNyZWF0ZSB0byBuZXcgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbiAtIERlcHRoIG9mIGl0ZXJhdGlvbi5cclxuICogQHBhcmFtIHtCb29sZWFufSBzdGFydCAtIElmIGNhbGxiYWNrIHdhcyBjYWxsZWQgYWxyZWFkeSBvciBub3QuXHJcbiAqIEBwYXJhbSB7eyBJVjogKiB9fHVuZGVmaW5lZH0gSVYgLSBJZiBjYWxsYmFjayB3YXMgY2FsbGVkIGFscmVhZHkgb3Igbm90LlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7eyBJVjogKiB9fSBUcmFuc2Zvcm1lZCBJVi5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBSZWR1Y2Uob2JqZWN0LCBjYWxsYmFjaywgbiwgc3RhcnQsIElWLCB0cmVlKSB7XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGlmICghSVYgJiYgKGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSkpICYmICFzdGFydCkge1xyXG4gICAgICBJViA9IHsgSVY6IHZhbHVlIH07XHJcbiAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XHJcblxyXG4gICAgSVYgPSBlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpXHJcbiAgICAgID8geyBJVjogY2FsbGJhY2soSVYuSVYsIHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSkgfVxyXG4gICAgICA6IGRlZXBSZWR1Y2UodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgc3RhcnQsIElWLCBuZXdUcmVlKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIElWO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBTb21lXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgZWxlbWVudC5cclxuICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgbm90IGl0IGNvbnRpbnVlcy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZSAtIFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gb2JqZWN0cyBvZiBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHNvbWUgb2YgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBTb21lKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcclxuICBjb25zdCBlbmQgPSBuID09PSAxO1xyXG5cclxuICByZXR1cm4gaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSlcclxuICAgICAgICA/IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSlcclxuICAgICAgICA6IGRlZXBTb21lKHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIG5ld1RyZWUpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSkgfHwgZmFsc2U7XHJcbn1cclxuXHJcbmNvbnN0cnVjdG9yc1swXS5wdXNoKHtcclxuICBjaGVjazogKCkgPT4gdHJ1ZSxcclxuICBjbHM6IFN1cGVyXHJcbn0pO1xyXG5cclxuZXhwb3J0IHsgU3VwZXIgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgUHJvbWlzZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgUHJvbWlzZSBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBkZWZpbmVQcm9wZXJ0aWVzLCBTeW1ib2wgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gUHJvbWlzZSB2YWx1ZS5cclxuICogQHBhcmFtIHtCb29sZWFufSBzdWNjZXNzIC0gSWYgdGhlIHByZXZpb3VzIHByb21pc2UgaXMgZnVsZmlsbGVkIGl0J3MgdHJ1ZSBhbmQgZmFsc2UgaWYgcmVqZWN0ZWQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBvblJlamVjdGVkXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtFcnJvcnwqfSBlcnIgLSBQcm9taXNlIGVycm9yLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgb25GdWxmaWxsZWRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gUHJvbWlzZSB2YWx1ZS5cclxuICovXHJcblxyXG5jb25zdCBzZWNyZXQgPSB7fTtcclxuY29uc3QgaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFByb21pc2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciAtIEZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIGFyZ3VtZW50czogcmVzb2x2ZSBhbmQgcmVqZWN0IGZ1bmN0aW9ucy5cclxuICogQ2FsbCB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB3aGVuIHlvdSBuZWVkIHRvIGZ1bGZpbGwgdGhlIHByb21pc2UgYW5kIGNhbGwgdGhlIHJlamVjdCBvbmVcclxuICogd2hlbiB5b3UgbmVlZCB0byByZWplY3QgaXQuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBJbnN0YW5jZSBvZiBQcm9taXNlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2VcclxuICogQGRlc2NyaXB0aW9uIENsYXNzIHdpdGggYWxtb3N0IGlkZW50aWNhbCBBUEkgdG9cclxuICogW0VTNiBQcm9taXNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlfS5cclxuICogVGhlcmUgaXMgYSBjb3VwbGUgZGlmZmVyZW5jZXM6IHNldCBQcm9taXNlLm9uRXJyb3IgdG8gYSBmdW5jdGlvbiB3aXRoIHdoaWNoIHlvdSB3YW50IHRvXHJcbiAqIHN1YnNjcmliZSB0byBhIHByb21pc2UgZXJyb3IgYW5kIHNldCBQcm9taXNlLm9uVW5oYW5kbGVkUmVqZWN0aW9uIHRvIGEgZnVuY3Rpb24gd2l0aCB3aGljaFxyXG4gKiB5b3Ugd2FudCB0byBzdWJzY3JpYmUgdG8gYW4gdW5oYW5kbGVkIGVycm9yXHJcbiAqIChkZWZhdWx0cyB0byBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgJyVzICVvJywgJ1VuY2F1Z2h0IChpbiBwcm9taXNlKScpKS5cclxuICovXHJcbmNsYXNzIFByb21pc2Uge1xyXG4gIHN0YXRpYyBvbkVycm9yID0gbnVsbDtcclxuICBzdGF0aWMgb25VbmhhbmRsZWRSZWplY3Rpb24gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgJyVzICVvJywgJ1VuY2F1Z2h0IChpbiBwcm9taXNlKScpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xyXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGV4ZWN1dG9yKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9taXNlIHJlc29sdmVyICR7IHt9LnRvU3RyaW5nLmNhbGwoZXhlY3V0b3IpIH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaGlkZGVuU3RhdHVzO1xyXG4gICAgbGV0IGhpZGRlblZhbHVlO1xyXG5cclxuICAgIGNvbnN0XHRvbkZ1bGZpbGwgPSBbXTtcclxuICAgIGNvbnN0IG9uUmVqZWN0ID0gW107XHJcbiAgICBjb25zdCByZWFsUHJvbWlzZSA9IHRoaXM7XHJcbiAgICBjb25zdCBoaWRkZW5Qcm9taXNlID0ge1xyXG4gICAgICBoYW5kbGVkOiBmYWxzZSxcclxuICAgICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gaGlkZGVuU3RhdHVzO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQgc3RhdHVzKHZhbHVlKSB7XHJcbiAgICAgICAgaGlkZGVuU3RhdHVzID0gdmFsdWU7XHJcbiAgICAgICAgcmVhbFByb21pc2Uuc3RhdHVzID0gdmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gaGlkZGVuVmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldCB2YWx1ZSh2YWwpIHtcclxuICAgICAgICBoaWRkZW5WYWx1ZSA9IHZhbDtcclxuICAgICAgICByZWFsUHJvbWlzZS52YWx1ZSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBoaWRkZW5Qcm9taXNlLnN0YXR1cyA9ICdwZW5kaW5nJztcclxuICAgIGhpZGRlblByb21pc2UudmFsdWUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBoaWRkZW5Qcm9taXNlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gaGFuZGxlZCAtIElmIHRoZSBwcm9taXNlIGlzIGhhbmRsZWQgb3Igbm90LlxyXG4gICAgICogQHByb3BlcnR5IHsncGVuZGluZyd8J2Z1bGZpbGxlZCd8J3JlamVjdGVkJ30gc3RhdHVzIC0gU3RhdHVzIG9mIHRoZSBwcm9taXNlLlxyXG4gICAgICogQHByb3BlcnR5IHsqfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gaGlkZGVuUHJvbWlzZSNoYW5kbGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geygncmVqZWN0J3wncmVzb2x2ZScpfSBldmVudCAtIFR5cGUgb2YgdGhlIGV2ZW50IHRvIGhhbmRsZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBIYW5kbGVyIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgLSBSZXNvbHZlIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IC0gUmVqZWN0IGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlY3JldCAtIFNlY3JldC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBQcml2YXRlIG1ldGhvZCBmb3IgaGFuZGxpbmcgcHJvbWlzZXMuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge2hpZGRlblByb21pc2V9IFByb21pc2UjJCRcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLiQkID0ge30sIHtcclxuICAgICAgJ2dldC9zZXQgaGFuZGxlZCc6IHtcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICByZXR1cm4gaGlkZGVuUHJvbWlzZS5oYW5kbGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KGtleSkge1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gc2VjcmV0KSB7XHJcbiAgICAgICAgICAgIGhpZGRlblByb21pc2UuaGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBoYW5kbGUoc3RhdHVzLCBmLCByZXNvbHZlLCByZWplY3QsIGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHNlY3JldCkge1xyXG4gICAgICAgICAgY29uc3QgcHJveHkgPSBpc0Z1bmN0aW9uKGYpID8gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShmKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IDogbnVsbDtcclxuXHJcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSAncmVzb2x2ZScpIHtcclxuICAgICAgICAgICAgb25GdWxmaWxsLnB1c2gocHJveHkgfHwgKCh2YWx1ZSkgPT4gcmVzb2x2ZSh2YWx1ZSkpKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAncmVqZWN0Jykge1xyXG4gICAgICAgICAgICBvblJlamVjdC5wdXNoKHByb3h5IHx8ICgoZXJyKSA9PiByZWplY3QoZXJyKSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgJ2dldCBzdGF0dXMnKCkge1xyXG4gICAgICAgIHJldHVybiBoaWRkZW5Qcm9taXNlLnN0YXR1cztcclxuICAgICAgfSxcclxuICAgICAgJ2dldCB2YWx1ZScoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhpZGRlblByb21pc2UudmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcmVqZWN0KGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KGVycikge1xyXG4gICAgICBpZiAoaGlkZGVuUHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgIGhpZGRlblByb21pc2Uuc3RhdHVzID0gJ3JlamVjdGVkJztcclxuICAgICAgICBoaWRkZW5Qcm9taXNlLnZhbHVlID0gZXJyO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gb25SZWplY3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGhpZGRlblByb21pc2UuaGFuZGxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgb25SZWplY3RbaV0oZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIG9uVW5oYW5kbGVkUmVqZWN0aW9uLFxyXG4gICAgICAgICAgb25FcnJvclxyXG4gICAgICAgIH0gPSBQcm9taXNlO1xyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvbkVycm9yKSkge1xyXG4gICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWhpZGRlblByb21pc2UuaGFuZGxlZCAmJiBpc0Z1bmN0aW9uKG9uVW5oYW5kbGVkUmVqZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBvblVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xyXG4gICAgICBpZiAoaGlkZGVuUHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICB9LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoaWRkZW5Qcm9taXNlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xyXG4gICAgICAgIGhpZGRlblByb21pc2UudmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG9uRnVsZmlsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaGlkZGVuUHJvbWlzZS5oYW5kbGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICBvbkZ1bGZpbGxbaV0odmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBQcm9taXNlLmFsbFxyXG4gICAqIEBwYXJhbSB7KEFycmF5fEl0ZXJhYmxlKS48UHJvbWlzZXwqPn0gaXRlcmFibGUgLSBJdGVyYWJsZSBvYmplY3QgKGxpa2UgYXJyYXkpIG9mIHByb21pc2VzXHJcbiAgICogb3IgYW55IHZhbHVlcy5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL2FsbFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhbGwoaXRlcmFibGUpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gW107XHJcblxyXG4gICAgbGV0IHRvUmVzb2x2ZSA9IDA7XHJcblxyXG4gICAgaWYgKGl0ZXJhYmxlW2l0ZXJhdG9yXSkge1xyXG4gICAgICBpdGVyYWJsZSA9IGl0ZXJhYmxlW2l0ZXJhdG9yXSgpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICghKG5leHQgPSBpdGVyYWJsZS5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV4dC52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgdG9SZXNvbHZlKys7XHJcblxyXG4gICAgICAgICAgKChpKSA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2UudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICB0b1Jlc29sdmUtLTtcclxuICAgICAgICAgICAgICBhcnJheVtpXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUgJiYgIXRvUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGFycmF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pKGkrKyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWkpIHtcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoO1xyXG5cclxuICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgfVxyXG5cclxuICAgIHRvUmVzb2x2ZSA9IGxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpdGVyYWJsZVtpXSk7XHJcblxyXG4gICAgICAgIHByb21pc2UudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRvUmVzb2x2ZS0tO1xyXG4gICAgICAgICAgYXJyYXlbaV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICBpZiAoIXRvUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlKGFycmF5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgUHJvbWlzZS5yYWNlXHJcbiAgICogQHBhcmFtIHsoQXJyYXl8SXRlcmFibGUpLjxQcm9taXNlfCo+fSBpdGVyYWJsZSAtIEl0ZXJhYmxlIG9iamVjdCAobGlrZSBhcnJheSkgb2YgcHJvbWlzZXNcclxuICAgKiBvciBhbnkgdmFsdWVzLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvcmFjZVxyXG4gICAqL1xyXG4gIHN0YXRpYyByYWNlKGl0ZXJhYmxlKSB7XHJcbiAgICBpZiAoaXRlcmFibGVbaXRlcmF0b3JdKSB7XHJcbiAgICAgIGl0ZXJhYmxlID0gaXRlcmFibGVbaXRlcmF0b3JdKCk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG5cclxuICAgICAgICB3aGlsZSAoIShuZXh0ID0gaXRlcmFibGUubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICBuZXh0LnZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZXJhYmxlW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFByb21pc2UucmVqZWN0XHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIHJlamVjdC5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL3JlamVjdFxyXG4gICAqL1xyXG4gIHN0YXRpYyByZWplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJlamVjdCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgUHJvbWlzZS5yZXNvbHZlXHJcbiAgICogQHBhcmFtIHtQcm9taXNlfFRoZW5hYmxlfCp9IHZhbHVlIC0gUHJvbWlzZSwgdGhlbmFibGUgb3IgYW55IHZhbHVlIHRvIHJlc29sdmUuXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IE5ldyBpbnN0YW5jZSBvZiBQcm9taXNlLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yZXNvbHZlXHJcbiAgICovXHJcbiAgc3RhdGljIHJlc29sdmUodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFib3J0KCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBQcm9taXNlI2NhdGNoXHJcbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSBvblJlamVjdGVkIC0gb25SZWplY3RlZCBjYWxsYmFjay5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL2NhdGNoXHJcbiAgICovXHJcbiAgY2F0Y2gob25SZWplY3RlZCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgUHJvbWlzZSNmaW5hbGx5XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7b25GdWxmaWxsZWRPclJlamVjdGVkfSBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgLSBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgY2FsbGJhY2suXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY2F0Y2hpbmcgYm90aCBmdWxmaWxsZWQgYW5kIHJlamVjdGVkIHByb21pc2VzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBzcGlubmVyLnNob3coKTtcclxuICAgKiBmZXRjaERhdGEoKVxyXG4gICAqICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggZGF0YVxyXG4gICAqICAgfSlcclxuICAgKiAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICogICAgIC8vIGhhbmRsZSBlcnJvciBzb21laG93XHJcbiAgICogICB9KVxyXG4gICAqICAgLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAqICAgICBzcGlubmVyLmhpZGUoKTtcclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG4gIGZpbmFsbHkob25GdWxmaWxsZWRPclJlamVjdGVkKSB7XHJcbiAgICBjb25zdCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9uRnVsZmlsbGVkT3JSZWplY3RlZCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGhlbigodmFsdWUpID0+IChcclxuICAgICAgUHJvbWlzZVxyXG4gICAgICAgIC5yZXNvbHZlKFxyXG4gICAgICAgICAgaXNGdW5jXHJcbiAgICAgICAgICAgID8gb25GdWxmaWxsZWRPclJlamVjdGVkKHZhbHVlLCB0cnVlKVxyXG4gICAgICAgICAgICA6IDBcclxuICAgICAgICApXHJcbiAgICAgICAgLnRoZW4oKCkgPT4gdmFsdWUpXHJcbiAgICApLCAoZXJyKSA9PiAoXHJcbiAgICAgIFByb21pc2VcclxuICAgICAgICAucmVzb2x2ZShcclxuICAgICAgICAgIGlzRnVuY1xyXG4gICAgICAgICAgICA/IG9uRnVsZmlsbGVkT3JSZWplY3RlZChlcnIsIGZhbHNlKVxyXG4gICAgICAgICAgICA6IDBcclxuICAgICAgICApXHJcbiAgICAgICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5yZWplY3QoZXJyKSlcclxuICAgICkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBQcm9taXNlI3RoZW5cclxuICAgKiBAcGFyYW0ge29uRnVsZmlsbGVkfSBbb25GdWxmaWxsZWRdIC0gb25GdWxmaWxsZWQgY2FsbGJhY2suXHJcbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSBbb25SZWplY3RlZF0gLSBvblJlamVjdGVkIGNhbGxiYWNrLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvdGhlblxyXG4gICAqL1xyXG4gIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcHJvbWlzZS5oYW5kbGUoJ3JlamVjdCcsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCwgc2VjcmV0KTtcclxuICAgICAgICBwcm9taXNlLmhhbmRsZSgncmVzb2x2ZScsIG9uRnVsZmlsbGVkLCByZXNvbHZlLCByZWplY3QsIHNlY3JldCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb21pc2UuaGFuZGxlZCA9IHNlY3JldDtcclxuXHJcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBwcm9taXNlO1xyXG5cclxuICAgIGxldCBtZXRob2Q7XHJcbiAgICBsZXQgaGFuZGxlcjtcclxuXHJcbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XHJcbiAgICAgIG1ldGhvZCA9ICdyZXNvbHZlJztcclxuICAgICAgaGFuZGxlciA9IG9uRnVsZmlsbGVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWV0aG9kID0gJ3JlamVjdCc7XHJcbiAgICAgIGhhbmRsZXIgPSBvblJlamVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZVttZXRob2RdKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIodmFsdWUpKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmRlZmluZVByb3BlcnRpZXMoUHJvbWlzZS5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1Byb21pc2UnXHJcbn0pO1xyXG5cclxuZXhwb3J0IHsgUHJvbWlzZSB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBGdW5jXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBGdW5jIGNsYXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IFByb21pc2UgfSBmcm9tICcuL1Byb21pc2UnO1xyXG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGlzRnVuY3Rpb24sIHZhbGlkYXRlLCB0b0FycmF5LCBTeW1ib2wsIGRlZmluZVByb3BlcnRpZXMsIGl0ZXJhdGUgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBCZWZvcmVNaWRkbGV3YXJlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBQcmV2aW91cyBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB7RnVuY30gZnVuYyAtIFRoaXMgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBOZXcgYXJndW1lbnRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgQWZ0ZXJNaWRkbGV3YXJlXHJcbiAqIEBwYXJhbSB7Kn0gcmV0dXJuVmFsdWUgLSBQcmV2aW91cyByZXR1cm4gdmFsdWUuXHJcbiAqIEBwYXJhbSB7RnVuY30gZnVuYyAtIFRoaXMgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIHsqfSAtIE5ldyByZXR1cm4gdmFsdWUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBGdW5jXHJcbiAqIEBleHRlbmRzIFN1cGVyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Z1bmMgPSBmdW5jdGlvbiAoKSB7fV0gLSBGdW5jdGlvbiB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7RnVuY30gSW5zdGFuY2Ugb2YgRnVuYy5cclxuICogQGRlc2NyaXB0aW9uIEEgd3JhcCBvZiBhIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoTWF0aC5tYXgpO1xyXG4gKlxyXG4gKiBmdW5jKDEsIDQsIC0yLCA1KTsgLy8gNVxyXG4gKi9cclxuY2xhc3MgRnVuYyBleHRlbmRzIFN1cGVyIHtcclxuICBjb25zdHJ1Y3RvcihmdW5jID0gKCkgPT4ge30pIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgIGlmICgrK3Byb3h5LiQkLmNhbGxlZCA8IHByb3h5LiQkLmNhbkJlQ2FsbGVkKSB7XHJcbiAgICAgICAgY29uc3QgeyBiZWZvcmUsIGFmdGVyLCBzeW5jLCBjb250ZXh0TG9ja2VkIH0gPSBwcm94eS4kJDtcclxuICAgICAgICBsZXQgeyBjb250ZXh0LCBhcmdzIH0gPSBwcm94eS4kJDtcclxuICAgICAgICBsZXQgcmV0O1xyXG5cclxuICAgICAgICBjb250ZXh0ID0gY29udGV4dExvY2tlZCA/IGNvbnRleHQgOiBjb250ZXh0IHx8IHRoaXM7XHJcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KHRvQXJyYXkoYXJndW1lbnRzKSk7XHJcblxyXG4gICAgICAgIGlmIChzeW5jKSB7XHJcbiAgICAgICAgICBpdGVyYXRlKGJlZm9yZSwgKG1pZGRsZXdhcmUpID0+IHtcclxuICAgICAgICAgICAgYXJncyA9IG1pZGRsZXdhcmUuY2FsbChjb250ZXh0LCB0b0FycmF5KGFyZ3MpLCBwcm94eSk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIHRvQXJyYXkoYXJncykpO1xyXG5cclxuICAgICAgICAgIGl0ZXJhdGUoYWZ0ZXIsIChtaWRkbGV3YXJlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldCA9IG1pZGRsZXdhcmUuY2FsbChjb250ZXh0LCByZXQsIHByb3h5KTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhcmdzKTtcclxuXHJcbiAgICAgICAgaXRlcmF0ZShiZWZvcmUsIChtaWRkbGV3YXJlKSA9PiB7XHJcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKChhcmdzKSA9PiBtaWRkbGV3YXJlLmNhbGwoY29udGV4dCwgdG9BcnJheShhcmdzKSwgcHJveHkpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoYXJncykgPT4gZnVuYy5hcHBseShjb250ZXh0LCB0b0FycmF5KGFyZ3MpKSk7XHJcblxyXG4gICAgICAgIGl0ZXJhdGUoYWZ0ZXIsIChtaWRkbGV3YXJlKSA9PiB7XHJcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKChyZXQpID0+IG1pZGRsZXdhcmUuY2FsbChjb250ZXh0LCByZXQsIHByb3h5KSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEZ1bmMjJCRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBhZnRlciAtIEFmdGVyIG1pZGRsZXdhcmUgYXJyYXkuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBhcmdzIC0gTG9ja2VkIGFuZCBib3VuZCBhcmd1bWVudHMuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBhcmdzTG9ja2VkIC0gTG9ja2VkIGFyZ3VtZW50cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJlZm9yZSAtIEJlZm9yZSBtaWRkbGV3YXJlIGFycmF5LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNhbGxlZCAtIEhvdyBtYW55IHRpbWVzIHRoZSBmdW5jdGlvbiB3YXMgY2FsbGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNhbkJlQ2FsbGVkIC0gSG93IG1hbnkgdGltZXMgdGhlIGZ1bmN0aW9uIGNhbiBiZSBhY3R1YWxseSBjYWxsZWQuXHJcbiAgICAgKiBAcHJvcGVydHkgeyp9IGNvbnRleHQgLSBMb2NrZWQgb3IgYm91bmQgY29udGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29udGV4dExvY2tlZCAtIElzIGNvbnRleHQgbG9ja2VkIG9yIG5vdC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3luYyAtIElzIGZ1bmN0aW9uIHN5bmNocm9ub3VzIG9yIG5vdC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb25maWcgcGFyYW1ldGVycy5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCAnJCQnLCB7XHJcbiAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgYWZ0ZXI6IFtdLFxyXG4gICAgICAgIGFyZ3M6IFtdLFxyXG4gICAgICAgIGFyZ3NMb2NrZWQ6IFtdLFxyXG4gICAgICAgIGJlZm9yZTogW10sXHJcbiAgICAgICAgY2FsbGVkOiAwLFxyXG4gICAgICAgIGNhbkJlQ2FsbGVkOiBJbmZpbml0eSxcclxuICAgICAgICBjb250ZXh0OiBudWxsLFxyXG4gICAgICAgIGNvbnRleHRMb2NrZWQ6IGZhbHNlLFxyXG4gICAgICAgIHN5bmM6IHRydWVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRnVuYyMkXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gT3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJyQnLCB7IHZhbHVlOiBmdW5jIH0pO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3h5LCBGdW5jLnByb3RvdHlwZSk7XHJcblxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2FmdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7QWZ0ZXJNaWRkbGV3YXJlfSBtaWRkbGV3YXJlIC0gQWZ0ZXIgbWlkZGxld2FyZS5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2FmdGVyQWxsID0gdHJ1ZV0gLSBCb29sZWFuIHBhcmFtZXRlciB3aGVyZSB0byBwdXQgbWlkZGxld2FyZS5cclxuICAgKiBUcnV0aHkgcGFyYW1ldGVyIHN0YW5kcyBmb3IgXCJ0byB0aGUgZW5kXCIgYW5kIGZhbHNleSBmb3IgXCJ0byB0aGUgYmVnaW5uaW5nXCIuXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBhZnRlciBtaWRkbGV3YXJlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKVxyXG4gICAqICAgLmFmdGVyKChyZXN1bHQpID0+IHJlc3VsdCAqIHJlc3VsdCk7XHJcbiAgICpcclxuICAgKiBmdW5jKDQpOyAgLy8gMjVcclxuICAgKiBmdW5jKC00KTsgLy8gOVxyXG4gICAqL1xyXG4gIGFmdGVyKG1pZGRsZXdhcmUsIGFmdGVyQWxsID0gdHJ1ZSkge1xyXG4gICAgdmFsaWRhdGUoW21pZGRsZXdhcmVdLCBbJ2Z1bmN0aW9uJ10sICdGdW5jI2FmdGVyJyk7XHJcblxyXG4gICAgY29uc3QgeyBhZnRlciB9ID0gdGhpcy4kJDtcclxuXHJcbiAgICBpZiAoYWZ0ZXJBbGwpIHtcclxuICAgICAgYWZ0ZXIucHVzaChtaWRkbGV3YXJlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFmdGVyLnVuc2hpZnQobWlkZGxld2FyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjYXBwbHlcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gLSBDb250ZXh0IHRvIGNhbGwgd2l0aC5cclxuICAgKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHMpfSBbYXJnc10gLSBBcmd1bWVudHMgdG8gY2FsbCB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gb2YgZnVuY3Rpb24gY2FsbC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2FwcGx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0Z1bmN0aW9uI2FwcGx5XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9hcHBseX0uXHJcbiAgICovXHJcbiAgYXBwbHkoY29udGV4dCwgYXJncykge1xyXG4gICAgcmV0dXJuICgoKSA9PiB7fSkuYXBwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNhc3luY1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIHN5bmNocm9ub3VzIG9yIG5vdC5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBJZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIHN5bmNocm9ub3VzIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKChhKSA9PiBhICsgMSkuYXN5bmMoKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoNCkudGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyA1XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgYXN5bmMoY29uZGl0aW9uID0gdHJ1ZSkge1xyXG4gICAgdGhpcy4kJC5zeW5jID0gIWNvbmRpdGlvbjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNiZWZvcmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCZWZvcmVNaWRkbGV3YXJlfSBtaWRkbGV3YXJlIC0gQmVmb3JlIG1pZGRsZXdhcmUuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtiZWZvcmVBbGwgPSB0cnVlXSAtIEJvb2xlYW4gcGFyYW1ldGVyIHdoZXJlIHRvIHB1dCBtaWRkbGV3YXJlLlxyXG4gICAqIFRydXRoeSBwYXJhbWV0ZXIgc3RhbmRzIGZvciBcInRvIHRoZSBiZWdpbm5pbmdcIiBhbmQgZmFsc2V5IGZvciBcInRvIHRoZSBlbmRcIi5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGJlZm9yZSBtaWRkbGV3YXJlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKVxyXG4gICAqICAgLmJlZm9yZSgoW2FyZ10pID0+IFthcmcgKiBhcmddKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoNCk7IC8vIDE3XHJcbiAgICogZnVuYygzKTsgLy8gMTBcclxuICAgKi9cclxuICBiZWZvcmUobWlkZGxld2FyZSwgYmVmb3JlQWxsID0gdHJ1ZSkge1xyXG4gICAgdmFsaWRhdGUoW21pZGRsZXdhcmVdLCBbJ2Z1bmN0aW9uJ10sICdGdW5jI2JlZm9yZScpO1xyXG5cclxuICAgIGNvbnN0IHsgYmVmb3JlIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmIChiZWZvcmVBbGwpIHtcclxuICAgICAgYmVmb3JlLnVuc2hpZnQobWlkZGxld2FyZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiZWZvcmUucHVzaChtaWRkbGV3YXJlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNiaW5kXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgdG8gYmluZC5cclxuICAgKiBAcGFyYW0gey4uLihBcnJheXxBcmd1bWVudHN8Kil9IGFyZ3MgLSBBcmd1bWVudHMgdG8gYmluZC5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBDb21wb3NpdGlvbiBvZiB7QGxpbmsgRnVuYyNiaW5kQ29udGV4dH0gYW5kIHtAbGluayBGdW5jI2JpbmRBcmdzfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICogICByZXR1cm4gdGhpcy5hICsgYSArIGI7XHJcbiAgICogfSkuYmluZCh7IGE6IDIgfSwgMSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEpOyAvLyA0XHJcbiAgICogZnVuYygzKTsgLy8gNlxyXG4gICAqL1xyXG4gIGJpbmQoY29udGV4dCwgLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLmJpbmRDb250ZXh0KGNvbnRleHQpXHJcbiAgICAgIC5iaW5kQXJncyhhcmdzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNiaW5kQXJnc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHMpfSBhcmdzIC0gQXJndW1lbnRzIHRvIGJpbmQuXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gQmluZHMgYXJndW1lbnRzIGluIGFkZGl0aW9uIHRvIGFscmVhZHkgbG9ja2VkIGFuZCBib3VuZCBvbmVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKC4uLmFyZ3MpID0+IHtcclxuICAgKiAgIGxldCBzdW0gPSAwO1xyXG4gICAqXHJcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgKiAgICAgc3VtICs9IGFyZ3NbaV07XHJcbiAgICogICB9XHJcbiAgICpcclxuICAgKiAgIHJldHVybiBzdW07XHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyA2XHJcbiAgICpcclxuICAgKiBmdW5jLmJpbmRBcmdzKFs0XSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxMFxyXG4gICAqXHJcbiAgICogZnVuYy5iaW5kQXJncyhbNV0pO1xyXG4gICAqXHJcbiAgICogZnVuYygxLCAyLCAzKTsgLy8gMTVcclxuICAgKi9cclxuICBiaW5kQXJncyhhcmdzKSB7XHJcbiAgICBjb25zdCBmdW5jID0gdGhpcy4kJDtcclxuXHJcbiAgICBmdW5jLmFyZ3MgPSBmdW5jLmFyZ3MuY29uY2F0KHRvQXJyYXkoYXJncykpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2JpbmRDb250ZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgdG8gYmluZC5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBCaW5kIG5ldyBjb250ZXh0IGlmIGl0J3Mgbm90IGFscmVhZHkgbG9ja2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoZnVuY3Rpb24gKCkge1xyXG4gICAqICAgcmV0dXJuIHRoaXMuYTtcclxuICAgKiB9KS5iaW5kQ29udGV4dCh7IGE6IDEgfSk7XHJcbiAgICpcclxuICAgKiBmdW5jKCk7IC8vIDFcclxuICAgKlxyXG4gICAqIGZ1bmMuYmluZENvbnRleHQoeyBhOiAyIH0pO1xyXG4gICAqXHJcbiAgICogZnVuYygpOyAvLyAyXHJcbiAgICovXHJcbiAgYmluZENvbnRleHQoY29udGV4dCkge1xyXG4gICAgY29uc3QgZnVuYyA9IHRoaXMuJCQ7XHJcblxyXG4gICAgaWYgKCFmdW5jLmNvbnRleHRMb2NrZWQpIHtcclxuICAgICAgZnVuYy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNjYWxsXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gQ29udGV4dCB0byBjYWxsIHdpdGguXHJcbiAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBBcmd1bWVudHMgdG8gY2FsbCB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gb2YgZnVuY3Rpb24gY2FsbC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2NhbGxcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbRnVuY3Rpb24jY2FsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbH0uXHJcbiAgICovXHJcbiAgY2FsbChjb250ZXh0LCAuLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gKCgpID0+IHt9KS5jYWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IEZ1bmMjY2FsbGVkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGhvdyBtYW55IHRpbWVzIHRoZSBmdW5jdGlvbiB3YXMgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTtcclxuICAgKiBmdW5jKCk7XHJcbiAgICpcclxuICAgKiBmdW5jLmNhbGxlZCAvLyAyXHJcbiAgICovXHJcbiAgZ2V0IGNhbGxlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLiQkLmNhbGxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNjYW5CZUNhbGxlZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZXMgLSBOdW1iZXIgb2YgbWF4aW11bSB0aW1lcyB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIChtaWRkbGV3YXJlcyBhcmUgYWxzbyB0YWtlbiBmb3IgYSBjb3VudCkuXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBsaW1pdGluZyBjYWxsIHRpbWVzIG9mIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKVxyXG4gICAqICAgLmNhbkJlQ2FsbGVkKDEpO1xyXG4gICAqXHJcbiAgICogZnVuYygxKTsgLy8gMlxyXG4gICAqIGZ1bmMoMSk7IC8vIHVuZGVmaW5lZFxyXG4gICAqL1xyXG4gIGNhbkJlQ2FsbGVkKHRpbWVzKSB7XHJcbiAgICB0aGlzLiQkLmNhbkJlQ2FsbGVkID0gdGltZXM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjbGltaXRBcmdzVG9cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAtIE51bWJlciBvZiBhcmd1bWVudHMgdG8gbGltaXQgdG8uXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gQnVpbHQtaW4gYmVmb3JlIG1pZGRsZXdhcmUgZm9yIGxpbWl0aW5nIG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgKiB0aGF0IGlzIHB1dCB0byB0aGUgZW5kIG9mIGJlZm9yZSBtaWRkbGV3YXJlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKChhLCBiKSA9PiBbYSwgYl0pO1xyXG4gICAqXHJcbiAgICogZnVuYygxLCAyKTsgLy8gWzEsIDJdXHJcbiAgICpcclxuICAgKiBmdW5jLmxpbWl0QXJnc1RvKDEpO1xyXG4gICAqXHJcbiAgICogZnVuYygxLCAyKTsgLy8gWzEsIHVuZGVmaW5lZF1cclxuICAgKi9cclxuICBsaW1pdEFyZ3NUbyhudW1iZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmJlZm9yZSgoYXJncykgPT4gYXJncy5zbGljZSgwLCBudW1iZXIpLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjbG9ja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgLSBDb250ZXh0IHRvIGxvY2suXHJcbiAgICogQHBhcmFtIHsoQXJyYXl8QXJndW1lbnRzfCopfSBhcmdzIC0gQXJndW1lbnRzIHRvIGxvY2suXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gQ29tcG9zaXRpb24gb2Yge0BsaW5rIEZ1bmMjbG9ja0NvbnRleHR9IGFuZCB7QGxpbmsgRnVuYyNsb2NrQXJnc30uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhmdW5jdGlvbiAoYSwgYikge1xyXG4gICAqICAgcmV0dXJuIHRoaXMuYSArIGEgKyBiO1xyXG4gICAqIH0pLmxvY2soeyBhOiAyIH0sIFsxXSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEpOyAvLyA0XHJcbiAgICogZnVuYygzKTsgLy8gNlxyXG4gICAqL1xyXG4gIGxvY2soY29udGV4dCwgYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLmxvY2tDb250ZXh0KGNvbnRleHQpXHJcbiAgICAgIC5sb2NrQXJncyhhcmdzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNsb2NrQXJnc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHN8Kil9IGFyZ3MgLSBBcmd1bWVudHMgdG8gbG9jay5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBFcmFzZXMgYm91bmQgYXJndW1lbnRzIGFuZCBhZGRzIG5ldyBhcmd1bWVudHMgdG8gYWxyZWFkeSBsb2NrZWQgb25lcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKCguLi5hcmdzKSA9PiB7XHJcbiAgICogICBsZXQgc3VtID0gMDtcclxuICAgKlxyXG4gICAqICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICogICAgIHN1bSArPSBhcmdzW2ldO1xyXG4gICAqICAgfVxyXG4gICAqXHJcbiAgICogICByZXR1cm4gc3VtO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogZnVuYygxLCAyLCAzKTsgLy8gNlxyXG4gICAqXHJcbiAgICogZnVuYy5sb2NrQXJncyhbNF0pO1xyXG4gICAqXHJcbiAgICogZnVuYygxLCAyLCAzKTsgLy8gMTBcclxuICAgKlxyXG4gICAqIGZ1bmMuYmluZEFyZ3MoWzYsIDddKTtcclxuICAgKiBmdW5jLmxvY2tBcmdzKFs1XSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxNVxyXG4gICAqL1xyXG4gIGxvY2tBcmdzKGFyZ3MpIHtcclxuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xyXG5cclxuICAgIGZ1bmMuYXJncyA9IGZ1bmMuYXJnc0xvY2tlZCA9IGZ1bmMuYXJnc0xvY2tlZC5jb25jYXQodG9BcnJheShhcmdzKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjbG9ja0NvbnRleHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dCB0byBsb2NrLlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIExvY2tzIGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBsb2NrZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhmdW5jdGlvbiAoKSB7XHJcbiAgICogICByZXR1cm4gdGhpcy5hO1xyXG4gICAqIH0pLmxvY2tDb250ZXh0KHsgYTogMSB9KTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gMVxyXG4gICAqXHJcbiAgICogZnVuYy5sb2NrQ29udGV4dCh7IGE6IDIgfSk7XHJcbiAgICpcclxuICAgKiBmdW5jKCk7IC8vIDFcclxuICAgKi9cclxuICBsb2NrQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBmdW5jID0gdGhpcy4kJDtcclxuXHJcbiAgICBpZiAoIWZ1bmMuY29udGV4dExvY2tlZCkge1xyXG4gICAgICBmdW5jLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICBmdW5jLmNvbnRleHRMb2NrZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI3RpbWluZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFyayAtIEFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRvIGNvbnNvbGUudGltZSgpIGFuZCBjb25zb2xlLnRpbWVFbmQoKS5cclxuICAgKiBCeSBkZWZhdWx0IG5hbWUgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLCBvciBpZiBpdCdzIG5vdCBwcmVzZW50LCAnYW5vbnltb3VzJyBpcyB1c2VkLlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWx0LWluIGJlZm9yZSBhbmQgYWZ0ZXIgbWlkZGxld2FyZXMgZm9yIG5vdGluZyBjYWxsaW5nIHRpbWUuXHJcbiAgICogSW4gY2FzZSBvZiBhc3luY2hyb25vdXMgZnVuY3Rpb25zIGl0IG5vdGVzIHRpbWUgYmV0d2VlbiBjYWxsaW5nIGZ1bmN0aW9uIGFuZCByZXNvbHZpbmcgb3IgcmVqZWN0aW5nIHRoZSByZXN1bHQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpXHJcbiAgICogICAudGltaW5nKCdwbHVzIDEnKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMik7IC8vIHBsdXMgMTogMC4wMTBtc1xyXG4gICAqXHJcbiAgICogY29uc3QgYXN5bmMgPSBuZXcgRnVuYygoKSA9PiBuZXcgUHJvbWlzZSgoKSA9PiB7XHJcbiAgICogICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCk7XHJcbiAgICogICB9KSlcclxuICAgKiAgIC5hc3luYygpXHJcbiAgICogICAudGltaW5nKCk7XHJcbiAgICpcclxuICAgKiBhc3luYygpO1xyXG4gICAqIC8vIEFmdGVyIDEgc2Vjb25kLi4uXHJcbiAgICogLy8gYW5vbnltb3VzOiAxMDAwLjAxMG1zXHJcbiAgICovXHJcbiAgdGltaW5nKG1hcmspIHtcclxuICAgIG1hcmsgPSBhcmd1bWVudHMubGVuZ3RoID8gU3RyaW5nKG1hcmspIDogdGhpcy4kLm5hbWUgfHwgJ2Fub255bW91cyc7XHJcblxyXG4gICAgdGhpcy5iZWZvcmUoKGFyZ3MpID0+IHtcclxuICAgICAgY29uc29sZS50aW1lKG1hcmspO1xyXG5cclxuICAgICAgcmV0dXJuIGFyZ3M7XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5hZnRlcigocmV0KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrKTtcclxuXHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiAoKCkgPT4ge30pLnRvU3RyaW5nLmNhbGwodGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyN1bmJpbmRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gQ29tcG9zaXRpb24gb2Yge0BsaW5rIEZ1bmMjdW5iaW5kQ29udGV4dH0gYW5kIHtAbGluayBGdW5jI3VuYmluZEFyZ3N9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoZnVuY3Rpb24gKGEpIHtcclxuICAgKiAgIHJldHVybiB0aGlzLmZvbyArICcgJiAnICsgIGE7XHJcbiAgICogfSkuYmluZCh7IGZvbzogMiB9LCAxKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gJzIgJiAxJ1xyXG4gICAqXHJcbiAgICogZnVuYy51bmJpbmQoKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gJ3VuZGVmaW5lZCAmIHVuZGVmaW5lZCdcclxuICAgKi9cclxuICB1bmJpbmQoKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAudW5iaW5kQ29udGV4dCgpXHJcbiAgICAgIC51bmJpbmRBcmdzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjdW5iaW5kQXJnc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBFcmFzZXMgYWxsIGJvdW5kIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKCguLi5hcmdzKSA9PiB7XHJcbiAgICogICBsZXQgc3VtID0gMDtcclxuICAgKlxyXG4gICAqICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICogICAgIHN1bSArPSBhcmdzW2ldO1xyXG4gICAqICAgfVxyXG4gICAqXHJcbiAgICogICByZXR1cm4gc3VtO1xyXG4gICAqIH0pLmJpbmRBcmdzKFs0LCA1XSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxNVxyXG4gICAqXHJcbiAgICogZnVuYy51bmJpbmRBcmdzKCk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyA2XHJcbiAgICovXHJcbiAgdW5iaW5kQXJncygpIHtcclxuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xyXG5cclxuICAgIGZ1bmMuYXJncyA9IGZ1bmMuYXJnc0xvY2tlZDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyN1bmJpbmRDb250ZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIEVyYXNlcyBjb250ZXh0IGlmIGl0J3Mgbm90IGxvY2tlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKGZ1bmN0aW9uICgpIHtcclxuICAgKiAgIHJldHVybiB0aGlzLmZvbztcclxuICAgKiB9KS5iaW5kQ29udGV4dCh7IGZvbzogMSB9KTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gMVxyXG4gICAqXHJcbiAgICogZnVuYy51bmJpbmRBcmdzKCk7XHJcbiAgICpcclxuICAgKiBmdW5jKCk7IC8vIHVuZGVmaW5lZFxyXG4gICAqL1xyXG4gIHVuYmluZENvbnRleHQoKSB7XHJcbiAgICBjb25zdCBmdW5jID0gdGhpcy4kJDtcclxuXHJcbiAgICBpZiAoIWZ1bmMuY29udGV4dExvY2tlZCkge1xyXG4gICAgICBmdW5jLmNvbnRleHQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhGdW5jLnByb3RvdHlwZSwge1xyXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnRnVuYydcclxufSk7XHJcblxyXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XHJcbiAgY2hlY2s6IGlzRnVuY3Rpb24sXHJcbiAgY2xzOiBGdW5jXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBtZXRob2RcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gTWV0aG9kIHRvIGNhbGwuXHJcbiAqIEBwYXJhbSB7KEFycmF5fEFyZ3VtZW50c3wqKX0gYXJncyAtIEFyZ3VtZW50cyB0byBjYWxsIHRoZSBtZXRob2Qgd2l0aC5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGNhbGxzIHN0YXRlZCBtZXRob2Qgd2l0aCBnaXZlbiBhcmd1bWVudHMuXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZ1bmN0aW9uXHJcbiAqIHRoYXQgY2FsbHMgc3RhdGVkIG1ldGhvZCBvZiBpdHMgZmlyc3QgYXJndW1lbnQgd2l0aCBnaXZlbiBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFsxLjIzNDUsIDIuNzg5LCAzLjE0XS5tYXAobWV0aG9kKCd0b0ZpeGVkJywgWzJdKSk7IC8vIFsnMS4yMycsICcyLjc5JywgJzMuMTQnXVxyXG4gKi9cclxuZnVuY3Rpb24gbWV0aG9kKG1ldGhvZCwgYXJncyA9IFtdKSB7XHJcbiAgcmV0dXJuICh4KSA9PiB4W21ldGhvZF0uYXBwbHkoeCwgdG9BcnJheShhcmdzKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gbm9vcFxyXG4gKiBAcHVibGljXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKiBAZGVzY3JpcHRpb24gRW1wdHkgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBub29wKCkge31cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gcHJvcFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIC0gUHJvcGVydHkgdG8gcmV0dXJuLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBnaXZlbiBwcm9wZXJ0eSBvZiBpdHMgZmlyc3QgYXJndW1lbnQuXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB0aGF0IHJldHVybiB0aGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGdpdmVuIHByb3BlcnR5IG9mIGl0cyBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogWydmb28nLCAnMTInLCAnNzg5MCddLm1hcChwcm9wKCdsZW5ndGgnKSk7IC8vIFszLCAyLCA0XVxyXG4gKi9cclxuZnVuY3Rpb24gcHJvcChwcm9wKSB7XHJcbiAgcmV0dXJuICh7IFtwcm9wXTogdmFsdWUgfSkgPT4gdmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gc2VsZlxyXG4gKiBAcHVibGljXHJcbiAqIEByZXR1cm5zIHsqfSBGaXJzdCBhcmd1bWVudCBpdHNlbGYuXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBbMSwgMl0ubWFwKHNlbGYpOyAgICAgICAgICAgICAgICAgICAgIC8vIFsxLCAyXVxyXG4gKiBbMSwgMywgTmFOLCAwLCA3LCBudWxsXS5maWx0ZXIoc2VsZik7IC8vIFsxLCAzLCA3XVxyXG4gKi9cclxuZnVuY3Rpb24gc2VsZigpIHtcclxuICByZXR1cm4gYXJndW1lbnRzWzBdO1xyXG59XHJcblxyXG5leHBvcnQgeyBGdW5jLCBtZXRob2QsIG5vb3AsIHByb3AsIHNlbGYgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgTnVtXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBOdW0gY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcclxuaW1wb3J0IHsgRnVuYyB9IGZyb20gJy4vRnVuYyc7XHJcbmltcG9ydCB7IFByb21pc2UgfSBmcm9tICcuL1Byb21pc2UnO1xyXG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7XHJcbiAgaXNOdW1iZXIsIGlzRmluaXRlLCB0b0FycmF5LFxyXG4gIGRlZmluZVByb3BlcnRpZXMsIHZhbGlkYXRlLCBTeW1ib2xcclxufSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuY29uc3QgdG9SYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xyXG5jb25zdCB0b0RlZ3JlZSA9IDE4MCAvIE1hdGguUEk7XHJcbmNvbnN0IGxuMiA9IE1hdGguTE4yO1xyXG5jb25zdCBsbjEwID0gTWF0aC5MTjEwO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBOdW1cclxuICogQGV4dGVuZHMgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW251bWJlciA9IDBdIC0gQSBudW1iZXIgdG8gd3JhcC5cclxuICogQHJldHVybnMge051bX0gSW5zdGFuY2Ugb2YgTnVtLlxyXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhIG51bWJlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgbnVtID0gbmV3IE51bSgxKTtcclxuICovXHJcbmNsYXNzIE51bSBleHRlbmRzIFN1cGVyIHtcclxuICBjb25zdHJ1Y3RvcihudW1iZXIgPSAwKSB7XHJcbiAgICBzdXBlcigrbnVtYmVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIgTnVtIyRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gT3JpZ2luYWwgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNhYnNcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWJzXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguYWJzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fic30uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBOdW0oMSkuYWJzOyAgLy8gMVxyXG4gICAqIG5ldyBOdW0oLTEpLmFiczsgLy8gMVxyXG4gICAqL1xyXG4gIGdldCBhYnMoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI2Fjb3NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFt0b0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSByZXR1cm4gdmFsdWUgaXMgdHJhbnNmb3JtZWQgaW50byBkZWdyZWVzLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEFyY2Nvc2luZSBvZiB0aGUgbnVtYmVyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hY29zXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguYWNvc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hY29zfS5cclxuICAgKi9cclxuICBhY29zKHRvRGVncmVlcykge1xyXG4gICAgcmV0dXJuICh0b0RlZ3JlZXMgPyB0b0RlZ3JlZSA6IDEpICogTWF0aC5hY29zKHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNhY29zaFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hY29zaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmFjb3NoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fjb3NofS5cclxuICAgKi9cclxuICBnZXQgYWNvc2goKSB7XHJcbiAgICBjb25zdCBudW1iZXIgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubG9nKG51bWJlciArIE1hdGguc3FydChudW1iZXIgKiBudW1iZXIgLSAxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNhc2luaFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hc2luaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmFzaW5oXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2FzaW5ofS5cclxuICAgKi9cclxuICBnZXQgYXNpbmgoKSB7XHJcbiAgICBjb25zdCBudW1iZXIgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubG9nKG51bWJlciArIE1hdGguc3FydChudW1iZXIgKiBudW1iZXIgKyAxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSNhc2luXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbdG9EZWdyZWVzID0gZmFsc2VdIElmIGl0IGlzIHRydXRoeSB0aGUgcmV0dXJuIHZhbHVlIGlzIHRyYW5zZm9ybWVkIGludG8gZGVncmVlcy5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBBcmNzaW5lIG9mIHRoZSBudW1iZXIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2FzaW5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5hc2luXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2FzaW59LlxyXG4gICAqL1xyXG4gIGFzaW4odG9EZWdyZWVzKSB7XHJcbiAgICByZXR1cm4gKHRvRGVncmVlcyA/IHRvRGVncmVlIDogMSkgKiBNYXRoLmFzaW4odGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI2F0YW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFt0b0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSByZXR1cm4gdmFsdWUgaXMgdHJhbnNmb3JtZWQgaW50byBkZWdyZWVzLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEFyY3NpbmUgb2YgdGhlIG51bWJlci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXRhblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmF0YW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXRhbn0uXHJcbiAgICovXHJcbiAgYXRhbih0b0RlZ3JlZXMpIHtcclxuICAgIHJldHVybiAodG9EZWdyZWVzID8gdG9EZWdyZWUgOiAxKSAqIE1hdGguYXRhbih0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jYXRhbmhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXRhbmhcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5hdGFuaF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hdGFuaH0uXHJcbiAgICovXHJcbiAgZ2V0IGF0YW5oKCkge1xyXG4gICAgY29uc3QgbnVtYmVyID0gdGhpcy4kO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmxvZygoMSArIG51bWJlcikgLyAoMSAtIG51bWJlcikpIC8gMjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2NicnRcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2JydFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmNicnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2JydH0uXHJcbiAgICovXHJcbiAgZ2V0IGNicnQoKSB7XHJcbiAgICBjb25zdCBjYnJ0ID0gTWF0aC5wb3coTWF0aC5hYnModGhpcy4kKSwgMSAvIDMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLiQgPiAwID8gY2JydCA6IC1jYnJ0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jY2VpbFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jZWlsXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguY2VpbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jZWlsfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSgxLjEpLmNlaWw7ICAvLyAyXHJcbiAgICogbmV3IE51bSgtMS4xKS5jZWlsOyAvLyAtMVxyXG4gICAqL1xyXG4gIGdldCBjZWlsKCkge1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jY29zXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYXNEZWdyZWVzID0gZmFsc2VdIElmIGl0IGlzIHRydXRoeSB0aGUgbnVtYmVyIGlzIHRyZWF0ZWQgYXMgYSBkZWdyZWUgdmFsdWUuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gQ29zaW5lIG9mIHRoZSBudW1iZXIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Nvc1xyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmNvc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jb3N9LlxyXG4gICAqL1xyXG4gIGNvcyhhc0RlZ3JlZXMpIHtcclxuICAgIHJldHVybiBNYXRoLmNvcygoYXNEZWdyZWVzID8gdG9SYWRpYW4gOiAxKSAqIHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNjb3NoXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Nvc2hcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5jb3NoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Nvc2h9LlxyXG4gICAqL1xyXG4gIGdldCBjb3NoKCkge1xyXG4gICAgY29uc3QgZXhwID0gdGhpcy5leHA7XHJcblxyXG4gICAgcmV0dXJuIChleHAgKyAxIC8gZXhwKSAvIDI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNjdWJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIEN1YmUgb2YgdGhlIG51bWJlci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSgyKS5jdWJlOyAgLy8gOFxyXG4gICAqIG5ldyBOdW0oLTMpLmNlaWw7IC8vIC0yN1xyXG4gICAqL1xyXG4gIGdldCBjdWJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJCAqIHRoaXMuJCAqIHRoaXMuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2V4cFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9leHBcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5leHBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvZXhwfS5cclxuICAgKi9cclxuICBnZXQgZXhwKCkge1xyXG4gICAgcmV0dXJuIE1hdGguZXhwKHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNmbG9vclxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9mbG9vclxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmZsb29yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Zsb29yfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSgxLjEpLmZsb29yOyAgLy8gMVxyXG4gICAqIG5ldyBOdW0oLTEuMSkuZmxvb3I7IC8vIC0yXHJcbiAgICovXHJcbiAgZ2V0IGZsb29yKCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI2ludGVydmFsXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBldmVyeSA8bnVtYmVyPiBtaWxsaXNlY29uZHMuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGFib3J0cyB0aGUgaW50ZXJ2YWwuIFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbiAoaWYgaXQncyBub3QgYWxyZWFkeSBib3VuZClcclxuICAgKiBpcyB0aGUgb2JqZWN0IHdpdGggdGhlIGFib3J0IG1ldGhvZC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2V0SW50ZXJ2YWxcclxuICAgKiBAZGVzY3JpcHRpb24gQW5hbG9ndWUgb2YgdGhlXHJcbiAgICogW3NldEludGVydmFsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldEludGVydmFsfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgdGltZXMgPSAwO1xyXG4gICAqIG5ldyBOdW0oNTApLmludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgKiAgIGlmICgrK3RpbWVzID09PSAxMCkge1xyXG4gICAqICAgICB0aGlzLmFib3J0KCk7XHJcbiAgICogICB9XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgaW50ZXJ2YWwoZnVuYywgYXJncyA9IFtdKSB7XHJcbiAgICB2YWxpZGF0ZShbZnVuY10sIFsnZnVuY3Rpb24nXSwgJ051bSNpbnRlcnZhbCcpO1xyXG5cclxuICAgIGZ1bmMgPSBuZXcgRnVuYyhmdW5jKS5iaW5kQ29udGV4dCh7IGFib3J0IH0pO1xyXG4gICAgYXJncyA9IHRvQXJyYXkoYXJncyk7XHJcblxyXG4gICAgY29uc3QgbnVtYmVyID0gdGhpcy4kO1xyXG5cclxuICAgIGxldCBhYm9ydGVkO1xyXG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIGludGVydmFsKCkge1xyXG4gICAgICBpZiAoIWFib3J0ZWQpIHtcclxuICAgICAgICBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAoIWFib3J0ZWQpIHtcclxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGludGVydmFsLCBudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgMCk7XHJcblxyXG4gICAgcmV0dXJuIGFib3J0O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFib3J0KCkge1xyXG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNsblxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2dcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5sb2dde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbG9nfS5cclxuICAgKi9cclxuICBnZXQgbG4oKSB7XHJcbiAgICByZXR1cm4gTWF0aC5sb2codGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI2xvZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTnVtYmVyIHRvIGdldCBsb2dhcml0aG0gb2YuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gTG9nYXJpdGhtIG9mIHRoZSBhcmd1bWVudCBudW1iZXIgdG8gdGhlIG51bWJlciBiYXNlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBsb2dhcml0aG0gb2YgdGhlIGFyZ3VtZW50IG51bWJlciB0byB0aGUgbnVtYmVyIGJhc2UuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBOdW0oMikubG9nKDE2KTsgIC8vIDRcclxuICAgKiBuZXcgTnVtKDMpLmxvZygyNDMpOyAvLyA1XHJcbiAgICovXHJcbiAgbG9nKG51bWJlcikge1xyXG4gICAgcmV0dXJuIE1hdGgubG9nKG51bWJlcikgLyBNYXRoLmxvZyh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jbG9nMlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2cyXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGgubG9nMl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2cyfS5cclxuICAgKi9cclxuICBnZXQgbG9nMigpIHtcclxuICAgIHJldHVybiB0aGlzLmxuIC8gbG4yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jbG9nMTBcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbG9nMTBcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5sb2cxMF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2cxMH0uXHJcbiAgICovXHJcbiAgZ2V0IGxvZzEwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG4gLyBsbjEwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jcG93XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3dlciAtIFBvd2VyIHRoZSBudW1iZXIgc2hvdWxkIGJlIHJhaXNlZCB0by5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIHRvIHRoZSA8cG93ZXI+IHBvd2VyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9wb3dcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5wb3dde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcG93fS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSg0KS5wb3coLjUpOyAvLyAyXHJcbiAgICogbmV3IE51bSgzKS5wb3coMik7ICAvLyA5XHJcbiAgICovXHJcbiAgcG93KHBvd2VyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5wb3codGhpcy4kLCBwb3dlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSNyb290XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3dlciAtIFBvd2VyIHRoZSBudW1iZXIgc2hvdWxkIGJlIHJhaXNlZCB0by5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgPHBvd2VyPiByb290IG9mIHRoZSBudW1iZXIuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIG51bWJlci5wb3coMSAvIHBvd2VyKTtcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSg0KS5yb290KDIpOyAgIC8vIDAuNVxyXG4gICAqIG5ldyBOdW0oMjQzKS5yb290KDUpOyAvLyAzXHJcbiAgICovXHJcbiAgcm9vdChwb3dlcikge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KHRoaXMuJCwgMSAvIHBvd2VyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI3JvdW5kXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGgucm91bmRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcm91bmR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDEuMSkuZmxvb3I7ICAvLyAxXHJcbiAgICogbmV3IE51bSgtMS4xKS5mbG9vcjsgLy8gLTFcclxuICAgKiBuZXcgTnVtKDEuNSkuZmxvb3I7ICAvLyAyXHJcbiAgICovXHJcbiAgZ2V0IHJvdW5kKCkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI3NpZ25cclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLnNpZ25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnbn0uXHJcbiAgICovXHJcbiAgZ2V0IHNpZ24oKSB7XHJcbiAgICBjb25zdCBudW1iZXIgPSB0aGlzLiQ7XHJcblxyXG4gICAgaWYgKCFudW1iZXIpIHtcclxuICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVtYmVyID4gMCA/IDEgOiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI3NpblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2FzRGVncmVlcyA9IGZhbHNlXSBJZiBpdCBpcyB0cnV0aHkgdGhlIG51bWJlciBpcyB0cmVhdGVkIGFzIGEgZGVncmVlIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFNpbmUgb2YgdGhlIG51bWJlci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2luXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguc2luXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3Npbn0uXHJcbiAgICovXHJcbiAgc2luKGFzRGVncmVlcykge1xyXG4gICAgcmV0dXJuIE1hdGguc2luKChhc0RlZ3JlZXMgPyB0b1JhZGlhbiA6IDEpICogdGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI3NpbmhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2luaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLnNpbmhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2luaH0uXHJcbiAgICovXHJcbiAgZ2V0IHNpbmgoKSB7XHJcbiAgICBjb25zdCBleHAgPSB0aGlzLmV4cDtcclxuXHJcbiAgICByZXR1cm4gKGV4cCAtIDEgLyBleHApIC8gMjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI3NxXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFRoZSBzcXVhcmUgb2YgdGhlIG51bWJlci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSgyKS5zcTsgIC8vIDRcclxuICAgKiBuZXcgTnVtKC0zKS5zcTsgLy8gOVxyXG4gICAqL1xyXG4gIGdldCBzcSgpIHtcclxuICAgIHJldHVybiB0aGlzLiQgKiB0aGlzLiQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNzcXJ0XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NxcnRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5zcXJ0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NxcnR9LlxyXG4gICAqL1xyXG4gIGdldCBzcXJ0KCkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jdGFuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYXNEZWdyZWVzID0gZmFsc2VdIElmIGl0IGlzIHRydXRoeSB0aGUgbnVtYmVyIGlzIHRyZWF0ZWQgYXMgYSBkZWdyZWUgdmFsdWUuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gVGFuZ2VudCBvZiB0aGUgbnVtYmVyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC50YW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdGFufS5cclxuICAgKi9cclxuICB0YW4oYXNEZWdyZWVzKSB7XHJcbiAgICByZXR1cm4gTWF0aC50YW4oKGFzRGVncmVlcyA/IHRvUmFkaWFuIDogMSkgKiB0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jdGFuaFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW5oXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGgudGFuaF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW5ofS5cclxuICAgKi9cclxuICBnZXQgdGFuaCgpIHtcclxuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2lnbjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBleHAgPSBNYXRoLmV4cCgyICogbnVtYmVyKTtcclxuXHJcbiAgICByZXR1cm4gKGV4cCAtIDEpIC8gKGV4cCArIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jdGltZW91dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBWYWx1ZSB0byBiZSByZXNvbHZlZCBieSB0aGUgcHJvbWlzZS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGNvdWxkIGJlIGFib3J0ZWQuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldFRpbWVvdXRcclxuICAgKiBAZGVzY3JpcHRpb24gUHJvbWlzZS1iYXNlZCBhbmFsb2d1ZSBvZlxyXG4gICAqIFtzZXRUaW1lb3V0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldFRpbWVvdXR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDUwKS50aW1lb3V0KCdyZXNvbHZlZCcpLnRoZW4oKHZhbHVlKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICdyZXNvbHZlZCdcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIGNvbnN0IHByb21pc2UgPSBuZXcgTnVtKDUwKS50aW1lb3V0KCk7XHJcbiAgICogcHJvbWlzZS5hYm9ydCgpO1xyXG4gICAqL1xyXG4gIHRpbWVvdXQodmFsdWUpIHtcclxuICAgIGxldCB0aW1lb3V0O1xyXG4gICAgbGV0IHJlamVjdDtcclxuXHJcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlaikgPT4ge1xyXG4gICAgICByZWplY3QgPSByZWo7XHJcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMuJCwgdmFsdWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcHJvbWlzZS5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcblxyXG4gICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0IHdhcyBhYm9ydGVkJykpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jdG9CYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYmFzZSA9IDEwXSAtIEJhc2UgdGhhdCB0aGUgbnVtYmVyIHNob3VsZCBpbnZlcnRlZCB0by5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyIGluIDxiYXNlPiBiYXNlLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvU3RyaW5nXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW051bWJlciN0b1N0cmluZ117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvU3RyaW5nfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSg0KS50b0Jhc2UoMik7IC8vIDEwMFxyXG4gICAqIG5ldyBOdW0oMykudG9CYXNlKCk7ICAvLyAzXHJcbiAgICovXHJcbiAgdG9CYXNlKGJhc2UgPSAxMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC50b1N0cmluZyhiYXNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI3RvRXhwb25lbnRpYWxcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlciBpbiB0aGUgZXhwb25lbnRpYWwgZm9ybWF0LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvRXhwb25lbnRpYWxcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTnVtYmVyI3RvRXhwb25lbnRpYWxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b0V4cG9uZW50aWFsfS5cclxuICAgKi9cclxuICB0b0V4cG9uZW50aWFsKGZyYWN0aW9uRGlnaXRzKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnRvRXhwb25lbnRpYWwoZnJhY3Rpb25EaWdpdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jdG9GaXhlZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RpZ2l0cyA9IDBdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEZpeGVkLXBvaW50IGZvcm1hdHRlZCBudW1iZXIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9GaXhlZFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtOdW1iZXIjdG9GaXhlZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvRml4ZWR9LlxyXG4gICAqL1xyXG4gIHRvRml4ZWQoZGlnaXRzKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnRvRml4ZWQoZGlnaXRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI3RvUHJlY2lzaW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlY2lzaW9uXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyIHRvIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvUHJlY2lzaW9uXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW051bWJlciN0b1ByZWNpc2lvbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvUHJlY2lzaW9ufS5cclxuICAgKi9cclxuICB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcclxuICAgIHJldHVybiB0aGlzLiQudG9QcmVjaXNpb24ocHJlY2lzaW9uKTtcclxuICB9XHJcblxyXG4gIHZhbHVlT2YoKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuJCk7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKE51bS5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ051bSdcclxufSk7XHJcblxyXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XHJcbiAgY2hlY2s6IGlzTnVtYmVyLFxyXG4gIGNsczogTnVtXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiByYW5kXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydCA9IDBdIC0gU3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW2VuZCA9IDFdIC0gRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMge051bWJlcn0gUmFuZG9tIG51bWJlci5cclxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGluIHRoZSByYW5nZSBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50cy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogcmFuZCgxLCA1KTsgLy8gMi4zMTVcclxuICogcmFuZCgxLCA1KTsgLy8gNC4zNTY3NjNcclxuICovXHJcbmZ1bmN0aW9uIHJhbmQoc3RhcnQgPSAwLCBlbmQgPSAxKSB7XHJcbiAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIE1hdGgucmFuZG9tKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gcmFuZG9tXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAtIFN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIHtJbnRlZ2VyfSBlbmQgLSBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSYW5kb20gaW50ZWdlci5cclxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBudW1iZXIgaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiByYW5kb20oMSwgNSk7IC8vIDNcclxuICogcmFuZG9tKDEsIDUpOyAvLyAxXHJcbiAqL1xyXG5mdW5jdGlvbiByYW5kb20oc3RhcnQsIGVuZCkge1xyXG4gIHZhbGlkYXRlKFtzdGFydCwgZW5kXSwgWydpbnRMaWtlJywgJ2ludExpa2UnXSwgJ3JhbmRvbScpO1xyXG5cclxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIGZpcnN0IScsICdyYW5kb20nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBNYXRoLmZsb29yKHJhbmQoc3RhcnQsIGVuZCArIDEpKTtcclxufVxyXG5cclxuZXhwb3J0IHsgTnVtLCByYW5kLCByYW5kb20gfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgQXJyXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBBcnIgY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgcmFuZG9tIH0gZnJvbSAnLi9OdW0nO1xyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xyXG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7XHJcbiAgaXNBcnJheUxpa2UsIGlzTmFOLCBpc051bWJlciwgaXNTdHJpbmcsXHJcbiAgdG9BcnJheSwgdmFsaWRhdGUsIGl0ZXJhdGUgYXMgaXRlcmF0b3IsIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllc1xyXG59IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge0FycmF5fCp9IEFycmF5TGlrZVxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBBcnJheS1saWtlIHR5cGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBBcnJheUNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGkgLSBJdGVyYXRpb24gaW5kZXguXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBJdGVyYXRlQ2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gaSAtIEl0ZXJhdGlvbiBpbmRleC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIENvbXBhcmVGdW5jdGlvblxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0geCAtIEZpcnN0IHZhbHVlIHRvIGJlIGNvbXBhcmVkLlxyXG4gKiBAcGFyYW0geyp9IHkgLSBTZWNvbmQgdmFsdWUgdG8gYmUgY29tcGFyZWQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBBcnJcclxuICogQGV4dGVuZHMgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXkgPSBbXV0gLSBBbiBhcnJheSB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7QXJyfSBJbnN0YW5jZSBvZiBBcnIuXHJcbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBuZXcgQXJyKFsxLCAyXSk7XHJcbiAqL1xyXG5jbGFzcyBBcnIgZXh0ZW5kcyBTdXBlciB7XHJcbiAgY29uc3RydWN0b3IoYXJyYXkgPSBbXSkge1xyXG4gICAgc3VwZXIodG9BcnJheShhcnJheSBpbnN0YW5jZW9mIEFyciA/IGFycmF5LiQgOiBhcnJheSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciBBcnIjJFxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIE1hZGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI2NvbmNhdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLihBcnJheXxBcnJ8Kil9IHZhbHVlcyAtIEFycmF5cyBvciBhbnkgb3RoZXIgdmFsdWVzIHRvIGNvbmNhdCB0aGUgYXJyYXkgd2l0aC5cclxuICAgKiBAcmV0dXJucyB7QXJyfSBOZXcgaW5zdGFuY2Ugb2YgQXJyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvY29uY2F0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I2NvbmNhdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvY29uY2F0fS5cclxuICAgKi9cclxuICBjb25jYXQoLi4udmFsdWVzKSB7XHJcbiAgICBjb25zdCBhcnJheSA9IHRvQXJyYXkodGhpcy4kLCB0cnVlKTtcclxuXHJcbiAgICBpdGVyYXRvcihhcmd1bWVudHMsICh2YWx1ZSkgPT4ge1xyXG4gICAgICB2YWx1ZSA9IG5ldyBTdXBlcih2YWx1ZSkuJDtcclxuXHJcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgIWlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIGl0ZXJhdG9yKHZhbHVlLCAodmFsdWUpID0+IHtcclxuICAgICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGFycmF5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgQXJyI2ZpcnN0XHJcbiAgICogQHR5cGUgeyp9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBhcnJheS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmZpcnN0OyAvLyAxXHJcbiAgICogbmV3IEFycihbXSkuZmlyc3Q7ICAgICAgICAvLyB1bmRlZmluZWRcclxuICAgKi9cclxuICBnZXQgZmlyc3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjaW5kZXhPZlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gc2VhcmNoLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBhcmd1bWVudC5cclxuICAgKiBAZGVzY3JpcHRpb24gQWxtb3N0IHRoZSBzYW1lIGFzIHtAbGluayBTdXBlciNrZXlPZn0uIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgaWYgdGhlIHZhbHVlIGlzIG5vdCBmb3VuZFxyXG4gICAqIC0xIHJldHVybmVkIGluc3RlYWQgb2YgbnVsbCBhbmQgaWYgZm91bmQgTnVtYmVyKGtleSkgcmV0dXJuZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIDNdKS5pbmRleE9mKDEpOyAgICAgICAvLyAwXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2YoJzEnKTsgICAgIC8vIDBcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuaW5kZXhPZigzKTsgICAgICAgLy8gLTFcclxuICAgKiBuZXcgQXJyKFsxLCAyLCBOYU5dKS5pbmRleE9mKE5hTik7ICAgLy8gMlxyXG4gICAqL1xyXG4gIGluZGV4T2YodmFsdWUpIHtcclxuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5T2YodmFsdWUpO1xyXG5cclxuICAgIHJldHVybiBrZXkgPT09IG51bGwgPyAtMSA6IE51bWJlcihrZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjaW5kZXhPZlN0cmljdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gc2VhcmNoLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBhcmd1bWVudC5cclxuICAgKiBAZGVzY3JpcHRpb24gQWxtb3N0IHRoZSBzYW1lIGFzIHtAbGluayBTdXBlciNrZXlPZlN0cmljdH0uIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgaWYgdGhlIHZhbHVlIGlzIG5vdCBmb3VuZFxyXG4gICAqIC0xIHJldHVybmVkIGluc3RlYWQgb2YgbnVsbCBhbmQgaWYgZm91bmQgTnVtYmVyKGtleSkgcmV0dXJuZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIDNdKS5pbmRleE9mU3RyaWN0KDEpOyAgICAgICAvLyAwXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2ZTdHJpY3QoJzEnKTsgICAgIC8vIC0xXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2ZTdHJpY3QoMyk7ICAgICAgIC8vIC0xXHJcbiAgICogbmV3IEFycihbMSwgMiwgTmFOXSkuaW5kZXhPZlN0cmljdChOYU4pOyAgIC8vIDJcclxuICAgKi9cclxuICBpbmRleE9mU3RyaWN0KHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleU9mU3RyaWN0KHZhbHVlKTtcclxuXHJcbiAgICByZXR1cm4ga2V5ID09PSBudWxsID8gLTEgOiBOdW1iZXIoa2V5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI2pvaW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXBhcmF0b3IgPSAnLCddIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gU3RyaW5nIG9mIGpvaW5lZCBhcnJheS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2pvaW5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbQXJyYXkjam9pbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvam9pbn0uXHJcbiAgICovXHJcbiAgam9pbihzZXBhcmF0b3IpIHtcclxuICAgIHJldHVybiB0aGlzLiQuam9pbi5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIEFyciNsYXN0XHJcbiAgICogQHR5cGUgeyp9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmxhc3Q7IC8vIDNcclxuICAgKiBuZXcgQXJyKFtdKS5sYXN0OyAgICAgICAgLy8gdW5kZWZpbmVkXHJcbiAgICovXHJcbiAgZ2V0IGxhc3QoKSB7XHJcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuJDtcclxuXHJcbiAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIEFyciNsZW5ndGhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2xlbmd0aFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNsZW5ndGhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2xlbmd0aH0uXHJcbiAgICovXHJcbiAgZ2V0IGxlbmd0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLiQubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjcG9wXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGRlbGV0ZWQgZWxlbWVudC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3BvcFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNwb3Bde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3BvcH0uXHJcbiAgICovXHJcbiAgcG9wKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC5wb3AoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3B1c2hcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi4qfSB2YWx1ZXMgU2VlIHRoZSBsaW5rLlxyXG4gICAqIEB0aGlzIHtBcnJ9XHJcbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcHVzaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNwdXNoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wdXNofVxyXG4gICAqIGJlc2lkZXMgcmV0dXJuaW5nIHRoaXMuXHJcbiAgICovXHJcbiAgcHVzaCguLi52YWx1ZXMpIHtcclxuICAgIHRoaXMuJC5wdXNoLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3JhbmRvbVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Kn0gUmFuZG9tIGl0ZW0gb2YgdGhlIGFycmF5LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgcmFuZG9tIGl0ZW1zIG9mIHRoZSBhcnJheS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbMSwgNSwgM10pLnJhbmRvbSgpOyAvLyAzXHJcbiAgICogbmV3IEFycihbMSwgNSwgM10pLnJhbmRvbSgpOyAvLyA1XHJcbiAgICovXHJcbiAgcmFuZG9tKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJFtyYW5kb20oMCwgdGhpcy4kLmxlbmd0aCAtIDEpXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3JldmVyc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Fycn0gQSB3cmFwIG9mIHRoZSByZXZlcnNlZCBhcnJheS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JldmVyc2VcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbQXJyYXkjcmV2ZXJzZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmV2ZXJzZX0uXHJcbiAgICovXHJcbiAgcmV2ZXJzZSgpIHtcclxuICAgIHRoaXMuJC5yZXZlcnNlKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzaGlmdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBkZWxldGVkIGVsZW1lbnQuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zaGlmdFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNzaGlmdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2hpZnR9LlxyXG4gICAqL1xyXG4gIHNoaWZ0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC5zaGlmdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjc2h1ZmZsZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2h1ZmZsaW5nLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzLCA0XSkuc2h1ZmZsZSgpLiQ7IC8vIFs0LCAyLCAzLCAxXVxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIDMsIDRdKS5zaHVmZmxlKCkuJDsgLy8gWzEsIDMsIDQsIDJdXHJcbiAgICovXHJcbiAgc2h1ZmZsZSgpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuJC5sZW5ndGg7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgodmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xyXG4gICAgICBjb25zdCByYW5kb21JbmRleCA9IGluZGV4ICsgTWF0aC5mbG9vcigobGVuZ3RoIC0gaW5kZXgpICogTWF0aC5yYW5kb20oKSk7XHJcblxyXG4gICAgICBhcnJheVtpbmRleF0gPSBhcnJheVtyYW5kb21JbmRleF07XHJcbiAgICAgIGFycmF5W3JhbmRvbUluZGV4XSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzbGljZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2JlZ2luID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQgPSBhcnJheS5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtBcnJ9IEEgd3JhcCBvZiBhIHNsaWNlZCBhcnJheS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3NsaWNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zbGljZX0uXHJcbiAgICovXHJcbiAgc2xpY2UoYmVnaW4sIGVuZCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuJC5zbGljZS5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjc29ydFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0NvbXBhcmVGdW5jdGlvbn0gW2NvbXBhcmVGdW5jdGlvbl0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNzb3J0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0fS5cclxuICAgKi9cclxuICBzb3J0KGNvbXBhcmVGdW5jdGlvbikge1xyXG4gICAgdmFsaWRhdGUoW2NvbXBhcmVGdW5jdGlvbl0sIFsnZnVuY3Rpb258fCEnXSwgJ0FyciNzb3J0Jyk7XHJcblxyXG4gICAgdGhpcy4kLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3NvcnRBc2NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFzY2VuZGluZyBzb3J0aW5nLiBQdXRzIG5vbi1udW1iZXJzIGZpcnN0LCB0aGVuIE5hTnMsIHRoZW4gc29ydGVkIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbTmFOLCAxLCAtNywgJzEwMCcsIDVdKS5zb3J0QXNjKCkuJDsgLy8gWycxMDAnLCBOYU4sIC03LCAxLCA1XVxyXG4gICAqL1xyXG4gIHNvcnRBc2MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zb3J0KGFzYyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzb3J0RGVzY1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVzY2VuZGluZyBzb3J0aW5nLiBQdXRzIHNvcnRlZCB2YWx1ZXMgZmlyc3QsIHRoZW4gTmFOcywgdGhlbiBub24tbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbTmFOLCAxLCAtNywgJzEwMCcsIDVdKS5zb3J0RGVzYygpLiQ7IC8vIFs1LCAxLCAtNywgTmFOLCAnMTAwJ11cclxuICAgKi9cclxuICBzb3J0RGVzYygpIHtcclxuICAgIHJldHVybiB0aGlzLnNvcnQoKHksIHgpID0+IGFzYyh4LCB5KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzcGxpY2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxldGVDb3VudF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHsuLi4qfSBbaXRlbXNdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtBcnJ9IEEgd3JhcCBvZiByZXR1cm4gdmFsdWUgb2YgI3NwbGljZSBjYWxsLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3NwbGljZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlfS5cclxuICAgKi9cclxuICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcykge1xyXG4gICAgcmV0dXJuIG5ldyBBcnIodGhpcy4kLnNwbGljZS5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjc3RyaW5nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENvbmNhdGVuYXRlZCBhcnJheS5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgYXJyYXkuam9pbignJykuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIDNdKS5zdHJpbmcoKTsgLy8gJzEyMydcclxuICAgKi9cclxuICBzdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5qb2luKCcnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3Vuc2hpZnRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3Vuc2hpZnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnR9XHJcbiAgICogYmVzaWRlcyByZXR1cm5pbmcgdGhpcy5cclxuICAgKi9cclxuICB1bnNoaWZ0KC4uLnZhbHVlcykge1xyXG4gICAgdGhpcy4kLnVuc2hpZnQuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhBcnIucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdBcnInXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBhc2NcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB4IC0gRmlyc3QgdmFsdWUgdG8gYmUgY29tcGFyZWQuXHJcbiAqIEBwYXJhbSB7Kn0geSAtIFNlY29uZCB2YWx1ZSB0byBiZSBjb21wYXJlZC5cclxuICogQHJldHVybnMge051bWJlcn0gV2hlcmUgdG8gcHV0IHRoZSBmaXJzdCBlbGVtZW50OiBiZWZvcmUgb3IgYWZ0ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc2MoeCwgeSkge1xyXG4gIGlmICghaXNOdW1iZXIoeCkgJiYgIWlzTnVtYmVyKHkpKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIGlmICghaXNOdW1iZXIoeCkpIHtcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIGlmICghaXNOdW1iZXIoeSkpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTmFOKHgpICYmIGlzTmFOKHkpKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIGlmIChpc05hTih4KSkge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTmFOKHkpKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4IC0geTtcclxufVxyXG5cclxuY29uc3RydWN0b3JzWzFdLnB1c2goe1xyXG4gIGNoZWNrOiBpc0FycmF5TGlrZSxcclxuICBjbHM6IEFyclxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gYXJyYXlcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTGVuZ3RoIG9mIHRoZSBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUNhbGxiYWNrfSBbY2FsbGJhY2tdIC0gSWYgaXQncyBwcmVzZW50IGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uXHJcbiAqIHRoYXQgcmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGlzIHB1c2hlZCB0byB0aGUgbmV3IGFycmF5LlxyXG4gKiBAcmV0dXJucyB7QXJyfSBOZXcgaW5zdGFuY2Ugb2YgQXJyLlxyXG4gKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBuZXcgYXJyYXkgZnJvbSB0aGUgbGVuZ3RoIHVzaW5nIG9wdGlvbmFsIGNhbGxiYWNrLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBhcnJheSgzKS4kOyAgICAgICAgICAgICAgIC8vIFswLCAxLCAyXVxyXG4gKiBhcnJheSgzLCAoaSkgPT4gaSAqIDIpLiQ7IC8vIFswLCAyLCA0XVxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXkobnVtYmVyLCBjYWxsYmFjaykge1xyXG4gIHZhbGlkYXRlKFtudW1iZXIsIGNhbGxiYWNrXSwgW1snaW50TGlrZScsICc+PTAnXSwgJ2Z1bmN0aW9ufHwhJ10sICdhcnJheScpO1xyXG5cclxuICBjb25zdCBhcnJheSA9IFtdO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlcjsgaSsrKSB7XHJcbiAgICBhcnJheS5wdXNoKGNhbGxiYWNrID8gY2FsbGJhY2soaSkgOiBpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgQXJyKGFycmF5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpdGVyYXRlXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAtIE51bWJlciBvZiBpdGVyYXRpb25zLlxyXG4gKiBAcGFyYW0ge0l0ZXJhdGVDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbiB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXguXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZXBsYWNpbmcgZm9yICguLi4pIGNvbnN0cnVjdGlvbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXRlcmF0ZSgpO1xyXG4gKi9cclxuZnVuY3Rpb24gaXRlcmF0ZShudW1iZXIsIGNhbGxiYWNrKSB7XHJcbiAgdmFsaWRhdGUoW251bWJlciwgY2FsbGJhY2tdLCBbWydpbnRMaWtlJywgJz49MCddLCAnZnVuY3Rpb24nXSwgJ2l0ZXJhdGUnKTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xyXG4gICAgY2FsbGJhY2soaSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBBcnIsIGFycmF5LCBpdGVyYXRlIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIEJsb2JPYmplY3RcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEJsb2JPYmplY3QgY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcclxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBpc0FycmF5LCBpc0Z1bmN0aW9uLFxyXG4gIHRvU3RyaW5nVGFnLCBTeW1ib2wsIGRlZmluZVByb3BlcnRpZXNcclxufSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHt7IGJ1ZmZlcjogU3RyaW5nLCBiaW5hcnk6IFN0cmluZywgZGF0YVVSTDogU3RyaW5nLCB0ZXh0OiBTdHJpbmcgfX0gbWV0aG9kc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gTGlzdCBvZiByZWFkIGJsb2IgbWV0aG9kcy5cclxuICovXHJcbmNvbnN0IG1ldGhvZHMgPSB7XHJcbiAgYnVmZmVyOiAnQXJyYXlCdWZmZXInLFxyXG4gIGJpbmFyeTogJ0JpbmFyeVN0cmluZycsXHJcbiAgZGF0YVVSTDogJ0RhdGFVUkwnLFxyXG4gIHRleHQ6ICdUZXh0J1xyXG59O1xyXG5jb25zdCB7IFVSTCB9ID0gZ2xvYmFsO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsoJ2J1ZmZlcid8J2JpbmFyeSd8J2RhdGFVUkwnfCd0ZXh0Jyl9IFJlYWRCbG9iTWV0aG9kXHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEVudW0gdHlwZSBvZiByZWFkIGJsb2IgbWV0aG9kcy5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge0FycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld3xCbG9ifFN0cmluZ30gQmxvYlBhcnRzXHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEFsbG93ZWQgYmxvYiBwYXJ0cy5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIFJlYWRlckV2ZW50TGlzdGVuZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0V2ZW50fSBlIC0gRmlyZWQgZXZlbnQuXHJcbiAqIEBwYXJhbSB7RmlsZVJlYWRlcn0gcmVhZGVyIC0gRmlsZVJlYWRlci5cclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIEJsb2JPYmplY3RcclxuICogQGV4dGVuZHMgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0Jsb2J9IGJsb2IgLSBCbG9iIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtCbG9iT2JqZWN0fSBJbnN0YW5jZSBvZiBCbG9iT2JqZWN0LlxyXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhIGJsb2IuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5ldyBCbG9iT2JqZWN0KG5ldyBCbG9iKFsne1wiZm9vXCI6XCJiYXJcIn0nXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSkpO1xyXG4gKi9cclxuY2xhc3MgQmxvYk9iamVjdCBleHRlbmRzIFN1cGVyIHtcclxuICAvKipcclxuICAgKiBAbWVtYmVyIEJsb2JPYmplY3QjJFxyXG4gICAqIEB0eXBlIHtCbG9ifVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAZGVzY3JpcHRpb24gT3JpZ2luYWwgQmxvYi5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7U3RyaW5nfSBCbG9iT2JqZWN0I2RhdGFVUkxcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBkYXRhVVJMIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBibG9iLlxyXG4gICAqL1xyXG4gIGdldCBkYXRhVVJMKCkge1xyXG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvYk9iamVjdCNyZWFkQXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtSZWFkQmxvYk1ldGhvZH0gbWV0aG9kIC0gTWV0aG9kIHRoYXQgaXMgdXNlZCBmb3IgcmVhZGluZyBmcm9tIGJsb2IuXHJcbiAgICogQHBhcmFtIHtSZWFkZXJFdmVudExpc3RlbmVyfSBbcHJvZ3Jlc3NdIC0gUHJvZ3Jlc3MgbGlzdGVuZXIuXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgdGhhdCBjb3VsZCBiZSBhYm9ydGVkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHJlYWRpbmcgZnJvbSBibG9icy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEJsb2JPYmplY3QobmV3IEJsb2IoWyd7XCJmb29cIjpcImJhclwifSddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSlcclxuICAgKiAgIC5yZWFkQXMoJ3RleHQnKVxyXG4gICAqICAgLnRoZW4oKHZhbHVlKSA9PiB7XHJcbiAgICogICAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJ3tcImZvb1wiOlwiYmFyXCJ9J1xyXG4gICAqICAgfSk7XHJcbiAgICovXHJcbiAgcmVhZEFzKG1ldGhvZCwgcHJvZ3Jlc3MpIHtcclxuICAgIGlmICghbWV0aG9kc1ttZXRob2RdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignMXN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIGZvbGxvd2luZyB2YWx1ZXM6IGJ1ZmZlciwgYmluYXJ5LCBkYXRhVVJMLCB0ZXh0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICBsZXQgdG9SZWplY3Q7XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24ocHJvZ3Jlc3MpKSB7XHJcbiAgICAgIHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBwcm9ncmVzcyhlLCB0aGlzKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0b1JlamVjdCA9IHJlamVjdDtcclxuXHJcbiAgICAgIHJlYWRlci5vbmVycm9yID0gKHsgdGFyZ2V0IH0pID0+IHtcclxuICAgICAgICBpZiAocmVhZGVyKSB7XHJcbiAgICAgICAgICByZWplY3QodGFyZ2V0LmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZWFkZXIub25sb2FkID0gKHsgdGFyZ2V0IH0pID0+IHtcclxuICAgICAgICByZXNvbHZlKHRhcmdldC5yZXN1bHQpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVhZGVyW2ByZWFkQXMkeyBtZXRob2RzW21ldGhvZF0gfWBdKHRoaXMuJCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XHJcbiAgICAgIHRvUmVqZWN0KG5ldyBFcnJvcignUmVhZGluZyB3YXMgYWJvcnRlZCcpKTtcclxuXHJcbiAgICAgIHJlYWRlci5hYm9ydCgpO1xyXG5cclxuICAgICAgcmVhZGVyID0gbnVsbDtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvYk9iamVjdCNzYXZlQXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIE5hbWUgdGhhdCBpcyB1c2VkIGZvciBzYXZpbmcgZmlsZS5cclxuICAgKiBAcmV0dXJucyB7QmxvYk9iamVjdH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHNhdmluZyBibG9icy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEJsb2JPYmplY3QobmV3IEJsb2IoWyd7XCJmb29cIjpcImJhclwifSddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSlcclxuICAgKiAgIC5zYXZlQXMoJ2Jsb2IuanNvbicpO1xyXG4gICAqL1xyXG4gIHNhdmVBcyhuYW1lID0gJ2Rvd25sb2FkJykge1xyXG4gICAgY29uc3QgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG5cclxuICAgIGFuY2hvci5ocmVmID0gdGhpcy5kYXRhVVJMO1xyXG4gICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBuYW1lKTtcclxuICAgIGFuY2hvci5jbGljaygpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhCbG9iT2JqZWN0LnByb3RvdHlwZSwge1xyXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnQmxvYk9iamVjdCdcclxufSk7XHJcblxyXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XHJcbiAgY2hlY2s6IChibG9iKSA9PiAvXihCbG9ifEZpbGUpJC8udGVzdCh0b1N0cmluZ1RhZyhibG9iKSksXHJcbiAgY2xzOiBCbG9iT2JqZWN0XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBibG9iXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsoQmxvYlBhcnRzW118QmxvYlBhcnRzKX0gYmxvYlBhcnRzIC0gQmxvYiBwYXJ0cyB0aGF0IGFyZSBwYXNzZWQgdG9cclxuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iL0Jsb2J9IGNvbnN0cnVjdG9yLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG9cclxuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iL0Jsb2J9IGNvbnN0cnVjdG9yLlxyXG4gKiBAcmV0dXJucyB7QmxvYk9iamVjdH0gTmV3IGluc3RhbmNlIG9mIEJsb2JPYmplY3QuXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYmxvYnMgbm90IGludm9sdmluZyBCbG9iT2JqZWN0IGFuZCBCbG9iIGNvbnN0cnVjdG9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGJsb2IoYmxvYlBhcnRzLCBvcHRpb25zID0ge30pIHtcclxuICBpZiAoIWlzQXJyYXkoYmxvYlBhcnRzKSkge1xyXG4gICAgYmxvYlBhcnRzID0gW2Jsb2JQYXJ0c107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IEJsb2JPYmplY3QobmV3IEJsb2IoYmxvYlBhcnRzLCBvcHRpb25zKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IEJsb2JPYmplY3QsIGJsb2IgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgU3RyXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBTdHIgY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRCB9IGZyb20gJy4vRCc7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycywgcmVnZXhwU3BlY2lhbENoYXJhY3RlcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7XHJcbiAgaXNGdW5jdGlvbiwgaXNOdW1iZXJMaWtlLCBpc09iamVjdCwgaXNTdHJpbmcsXHJcbiAgdmFsaWRhdGUsIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllcywgaXRlcmF0ZVxyXG59IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG5jb25zdCBodG1sU3BlY2lhbHMgPSB7XHJcbiAgJyYnOiAnJmFtcDsnLFxyXG4gICc8JzogJyZsdDsnLFxyXG4gICc+JzogJyZndDsnXHJcbn07XHJcbmNvbnN0IHJlZ2V4cFNwZWNpYWxzUmVnZXhwID0gbmV3IFJlZ0V4cChcclxuICBuZXcgU3VwZXIocmVnZXhwU3BlY2lhbENoYXJhY3RlcnMpXHJcbiAgICAud29yZCgoeCkgPT4gYFxcXFwkeyB4IH18YClcclxuICAgIC5yZXBsYWNlKC9cXHwkLywgJycpLFxyXG4gICdnJ1xyXG4pO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBTdHJcclxuICogQGV4dGVuZHMgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZyA9ICcnXSAtIEEgc3RyaW5nIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtTdHJ9IEluc3RhbmNlIG9mIFN0ci5cclxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IHMgPSBuZXcgTnVtKCcxJyk7XHJcbiAqL1xyXG5jbGFzcyBTdHIgZXh0ZW5kcyBTdXBlciB7XHJcbiAgY29uc3RydWN0b3Ioc3RyaW5nID0gJycpIHtcclxuICAgIHN1cGVyKGAkeyBzdHJpbmcgfWApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciBTdHIjJFxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hbCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI2NhcGl0YWxpemVGaXJzdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBDYXBpdGFsaXplZCBzdHJpbmcuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHN5bWJvbC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignZm9vJykuY2FwaXRhbGl6ZUZpcnN0KCkuJDsgLy8gJ0ZvbydcclxuICAgKi9cclxuICBjYXBpdGFsaXplRmlyc3QoKSB7XHJcbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBTdHIoc3RyaW5nLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjZW5kc1dpdGhcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZyAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uID0gc3RyaW5nLmxlbmd0aF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBhcmd1bWVudCBzdHJpbmcuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI2VuZHNXaXRoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGh9LlxyXG4gICAqL1xyXG4gIGVuZHNXaXRoKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgICBwb3NpdGlvbiA9IHRoaXMuJC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLnNsaWNlKDAsIHBvc2l0aW9uKVxyXG4gICAgICAucmV2ZXJ0KClcclxuICAgICAgLnN0YXJ0c1dpdGgobmV3IFN0cihzZWFyY2hTdHJpbmcpLnJldmVydCgpLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjZXNjYXBlSFRNTFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2RzIGVzY2FwaW5nIFwiJlwiLCBcIjxcIiBhbmQgXCI+XCIgc3ltYm9scy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignXCIxIDwgMlwiICYgXCI3ID4gNFwiIGFyZSB0cnVlIGV4cHJlc3Npb25zLicpLmVzY2FwZUhUTUwoKS4kO1xyXG4gICAqIC8vICdcIjEgJmx0OyAyXCIgJmFtcCBcIjcgJmd0OyAyXCIgYXJlIHRydWUgZXhwcmVzc2lvbnMuJ1xyXG4gICAqL1xyXG4gIGVzY2FwZUhUTUwoKSB7XHJcbiAgICBsZXQgc3RyaW5nID0gdGhpcy4kO1xyXG5cclxuICAgIGl0ZXJhdGUoaHRtbFNwZWNpYWxzLCAoZXNjYXBlZCwgc3ltYm9sKSA9PiB7XHJcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoc3ltYm9sLCAnZycpLCBlc2NhcGVkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgU3RyKHN0cmluZyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNlc2NhcGVSZWdFeHBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGVzY2FwaW5nIFJlZ0V4cCBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJygyMTMuOTggLSBbXSB7fSknKS5lc2NhcGVSZWdFeHAoKS4kOyAvLyAnXFwoMjEzXFwuOTggXFwtIFxcW1xcXSBcXHtcXH1cXCknXHJcbiAgICovXHJcbiAgZXNjYXBlUmVnRXhwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZShyZWdleHBTcGVjaWFsc1JlZ2V4cCwgJ1xcXFwkJicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjaW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgdGhlIHN0cmluZyBhcyBhIHByb3BlcnR5IGluLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBpdCBpcyBpbiB0aGUgb2JqZWN0IG9yIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBzdHJpbmcgaW4gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdhJykuaW4oeyBhOiAxIH0pOyAvLyB0cnVlXHJcbiAgICogbmV3IFN0cigndG9GaXhlZCcpLmluKDEpOyAgLy8gZmFsc2VcclxuICAgKiBuZXcgU3RyKCdhJykuaW4obnVsbCk7ICAgICAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGluKG9iamVjdCkge1xyXG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy4kIGluIG9iamVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI2luZGV4T2ZcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFZhbHVlIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4ID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gRm91bmQgaW5kZXggb3IgLTEuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5kZXhPZlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjaW5kZXhPZl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luZGV4T2Z9LlxyXG4gICAqL1xyXG4gIGluZGV4T2Yoc2VhcmNoVmFsdWUsIGZyb21JbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC5pbmRleE9mLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI2xhc3RJbmRleE9mXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hWYWx1ZSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb21JbmRleCA9IHN0cmluZy5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEZvdW5kIGluZGV4IG9yIC0xLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2xhc3RJbmRleE9mXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNsYXN0SW5kZXhPZl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2xhc3RJbmRleE9mfS5cclxuICAgKi9cclxuICBsYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLmxhc3RJbmRleE9mLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgU3RyI2xlbmd0aFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2xlbmd0aFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjbGVuZ3RoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbGVuZ3RofS5cclxuICAgKi9cclxuICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNtYXRjaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7QXJyfFN1cGVyfSBELVdyYXAgb2YgZm91bmQgbWF0Y2guXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbWF0Y2hcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI21hdGNoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbWF0Y2h9LlxyXG4gICAqL1xyXG4gIG1hdGNoKHJlZ2V4cCkge1xyXG4gICAgcmV0dXJuIEQodGhpcy4kLm1hdGNoLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNyZXBlYXRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSB0aW1lcyAtIFRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNyZXBlYXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCcxMjMnKS5yZXBlYXQoMikuJDsgLy8gJzEyMzEyMydcclxuICAgKiBuZXcgU3RyKCcxMjMnKS5yZXBlYXQoMCkuJDsgLy8gJydcclxuICAgKi9cclxuICByZXBlYXQodGltZXMpIHtcclxuICAgIHZhbGlkYXRlKFt0aW1lc10sIFtbJ2ludExpa2UnLCAnPj0wJ11dLCAnU3RyI3JlcGVhdCcpO1xyXG5cclxuICAgIHRpbWVzID0gK3RpbWVzO1xyXG5cclxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuJDtcclxuXHJcbiAgICBsZXQgcyA9ICcnO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xyXG4gICAgICBzICs9IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFN0cihzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3JlcGxhY2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSByZWdleHAgLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtyZXBsYWNlciA9ICcnXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGxhY2VcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3JlcGxhY2Vde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBsYWNlfVxyXG4gICAqIGJlc2lkZXMgdGhhdCByZXBsYWNlciBoYXMgYSBkZWZhdWx0IHZhbHVlIG9mICcnLlxyXG4gICAqL1xyXG4gIHJlcGxhY2UocmVnZXhwLCByZXBsYWNlciA9ICcnKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQucmVwbGFjZShyZWdleHAsIHJlcGxhY2VyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNyZXBsYWNlU3RyaW5nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBTdHJpbmcgdG8gcmVwbGFjZS5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGxhY2VyID0gJyddIC0gU3RyaW5nIHRvIHJlcGxhY2Ugd2l0aC5cclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdsb2JhbCBzdHJpbmcgcmVwbGFjZWluZy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignMTIzMTIzJykucmVwbGFjZVN0cmluZygnMScsICc0JykuJDsgLy8gJzQyMzQyMydcclxuICAgKiBuZXcgU3RyKCcxMjMxMjMnKS5yZXBsYWNlU3RyaW5nKCcxJykuJDsgICAgICAvLyAnMjMyMydcclxuICAgKi9cclxuICByZXBsYWNlU3RyaW5nKHN0cmluZywgcmVwbGFjZXIgPSAnJykge1xyXG4gICAgc3RyaW5nID0gbmV3IFN1cGVyKHN0cmluZykuJDtcclxuXHJcbiAgICB2YWxpZGF0ZShbc3RyaW5nXSwgWydzdHJpbmcnXSwgJ1N0ciNyZXBsYWNlU3RyaW5nJyk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnNwbGl0KHN0cmluZykuam9pbihyZXBsYWNlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjcmV2ZXJ0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBzdHJpbmcuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcmV2ZXJ0aW5nIGEgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCcxMjM0JykucmV2ZXJ0KCkuJDsgLy8gJzQzMjEnXHJcbiAgICovXHJcbiAgcmV2ZXJ0KCkge1xyXG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy4kO1xyXG4gICAgbGV0IHN0ciA9ICcnO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBzdHJpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgc3RyICs9IHN0cmluZ1tpXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFN0cihzdHIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjc2VhcmNoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gSW5kZXggb2YgdGhlIGZpcnN0IG1hdGNoLCBpZiBmb3VuZCwgYW5kIC0xIGlmIG5vdC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zZWFyY2hcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3NlYXJjaF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NlYXJjaH0uXHJcbiAgICovXHJcbiAgc2VhcmNoKHJlZ2V4cCkge1xyXG4gICAgdmFsaWRhdGUoW3JlZ2V4cF0sIFsncmVnZXhwJ10pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLiQuc2VhcmNoLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3NsaWNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW5TbGljZSA9IDBdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kU2xpY2UgPSBzdHJpbmcubGVuZ3RoXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NsaWNlXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNzbGljZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NsaWNlfS5cclxuICAgKi9cclxuICBzbGljZShiZWdpblNsaWNlLCBlbmRTbGljZSkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnNsaWNlLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNzcGxpdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IFtzZXBhcmF0b3JdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtBcnJ8U3VwZXJ9IEQtV3JhcCBvZiB0aGUgYXJyYXkuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3BsaXRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3NwbGl0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3BsaXR9LlxyXG4gICAqL1xyXG4gIHNwbGl0KHNlcGFyYXRvcikge1xyXG4gICAgcmV0dXJuIEQodGhpcy4kLnNwbGl0LmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNzdGFydHNXaXRoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmcgLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbiA9IDBdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCB0aGUgYXJndW1lbnQgc3RyaW5nLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3N0YXJ0c1dpdGhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRofS5cclxuICAgKi9cclxuICBzdGFydHNXaXRoKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLmluZGV4T2YuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpID09PSBwb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3N1YnN0clxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0ID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZW5ndGggPSBzdHJpbmcubGVuZ3RoXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N1YnN0clxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjc3Vic3RyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyfS5cclxuICAgKi9cclxuICBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnN1YnN0ci5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjc3Vic3RyaW5nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhTdGFydCA9IDBdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhFbmQgPSBzdHJpbmcubGVuZ3RoXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N1YnN0cmluZ1xyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjc3Vic3RyaW5nXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyaW5nfS5cclxuICAgKi9cclxuICBzdWJzdHJpbmcoaW5kZXhTdGFydCwgaW5kZXhFbmQpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5zdWJzdHJpbmcuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RvQ2FtZWxDYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFxzXFwtX1xcLi8gbWFraW5nIHRoZSBzdHJpbmcgY2FtZWwgY2FzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ3NwaW5hbC1jYXNlJykudG9DYW1lbENhc2UoKS4kOyAgLy8gJ3NwaW5hbENhc2UnXHJcbiAgICogbmV3IFN0cignX3NuYWtlX2Nhc2VfJykudG9DYW1lbENhc2UoKS4kOyAvLyAnc25ha2VDYXNlJ1xyXG4gICAqL1xyXG4gIHRvQ2FtZWxDYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodHJpbSh0aGlzLiQpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnLScpXHJcbiAgICAgIC5yZXBsYWNlKC8tW14tXS9nLCAobWF0Y2gpID0+IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCkpXHJcbiAgICAgIC5yZXBsYWNlKC9eW1xcU10vLCAobWF0Y2gpID0+IG1hdGNoLnRvTG93ZXJDYXNlKCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdG9DYXBpdGFsQ2FzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGZvbGxvd2luZyByZWdleHAgL1xcLV9cXC4vIG1ha2luZyB0aGUgc3RyaW5nIGNhcGl0YWwgbGV0dGVyIGNhc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvQ2FwaXRhbENhc2UoKS4kOyAgLy8gJ1NwaW5hbCBDYXNlJ1xyXG4gICAqIG5ldyBTdHIoJ19zbmFrZV9jYXNlXycpLnRvQ2FwaXRhbENhc2UoKS4kOyAvLyAnU25ha2UgQ2FzZSdcclxuICAgKi9cclxuICB0b0NhcGl0YWxDYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodHJpbSh0aGlzLiQpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnICcpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxTXS9nLCAobWF0Y2gpID0+IChcclxuICAgICAgICBtYXRjaC50b0xvd2VyQ2FzZSgpID09PSBtYXRjaCA/IG1hdGNoIDogYCAkeyBtYXRjaCB9YFxyXG4gICAgICApKVxyXG4gICAgICAucmVwbGFjZSgvXFxzW1xcU10vZywgKG1hdGNoKSA9PiBtYXRjaC50b1VwcGVyQ2FzZSgpKVxyXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAgIC5yZXBsYWNlKC9eXFxzLywgJycpXHJcbiAgICAgIC5yZXBsYWNlKC9eW1xcU10vLCAobWF0Y2gpID0+IG1hdGNoLnRvVXBwZXJDYXNlKCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdG9Eb3RDYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFwtX1xcLi8gbWFraW5nIHRoZSBzdHJpbmcgZG90IGNhc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvRG90Q2FzZSgpLiQ7ICAvLyAnc3BpbmFsLmNhc2UnXHJcbiAgICogbmV3IFN0cignX3NuYWtlX2Nhc2VfJykudG9Eb3RDYXNlKCkuJDsgLy8gJ3NuYWtlLmNhc2UnXHJcbiAgICovXHJcbiAgdG9Eb3RDYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodHJpbSh0aGlzLiQpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnLicpXHJcbiAgICAgIC5yZXBsYWNlKC9bXi5dL2csIChtYXRjaCkgPT4gKFxyXG4gICAgICAgIG1hdGNoLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoID8gbWF0Y2ggOiBgLiR7IG1hdGNoIH1gXHJcbiAgICAgICkpXHJcbiAgICAgIC5yZXBsYWNlKC9cXC4rL2csICcuJylcclxuICAgICAgLnJlcGxhY2UoL15cXC4vLCAnJylcclxuICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0b0h5cGhlbkNhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBmb2xsb3dpbmcgcmVnZXhwIC9cXHNcXC1fXFwuLyBtYWtpbmcgdGhlIHN0cmluZyBjYW1lbCBjYXNlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignY2FtZWxDYXNlJykudG9TcGluYWxDYXNlKCkuJDsgICAgLy8gJ2NhbWVsLWNhc2UnXHJcbiAgICogbmV3IFN0cignX3NuYWtlX2Nhc2VfJykudG9TcGluYWxDYXNlKCkuJDsgLy8gJ3NuYWtlLWNhc2UnXHJcbiAgICovXHJcbiAgdG9IeXBoZW5DYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodHJpbSh0aGlzLiQpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnLScpXHJcbiAgICAgIC5yZXBsYWNlKC9bXi1dL2csIChtYXRjaCkgPT4gKFxyXG4gICAgICAgIG1hdGNoLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoID8gbWF0Y2ggOiBgLSR7IG1hdGNoIH1gXHJcbiAgICAgICkpXHJcbiAgICAgIC5yZXBsYWNlKC8tKy9nLCAnLScpXHJcbiAgICAgIC5yZXBsYWNlKC9eLS8sICcnKVxyXG4gICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RvTG93ZXJDYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdG9Mb3dlckNhc2VcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdG9Mb3dlckNhc2V9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdVUFBFUi1DQVNFJykudG9Mb3dlckNhc2UoKS4kOyAgLy8gJ3VwcGVyLWNhc2UnXHJcbiAgICovXHJcbiAgdG9Mb3dlckNhc2UoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQudG9Mb3dlckNhc2UoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0b1NuYWtlQ2FzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGZvbGxvd2luZyByZWdleHAgL1xcc1xcLVxcLi8gbWFraW5nIHRoZSBzdHJpbmcgc3BpbmFsIGNhc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvU25ha2VDYXNlKCkuJDsgLy8gJ3NwaW5hbF9jYXNlJ1xyXG4gICAqIG5ldyBTdHIoJ2NhbWVsQ2FzZScpLnRvU25ha2VDYXNlKCkuJDsgICAvLyAnY2FtZWxfY2FzZSdcclxuICAgKi9cclxuICB0b1NuYWtlQ2FzZSgpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRyaW0odGhpcy4kKVxyXG4gICAgICAucmVwbGFjZSgvW1xcc1xcLV8uXSsvZywgJ18nKVxyXG4gICAgICAucmVwbGFjZSgvW15fXS9nLCAobWF0Y2gpID0+IChcclxuICAgICAgICBtYXRjaC50b0xvd2VyQ2FzZSgpID09PSBtYXRjaCA/IG1hdGNoIDogYF8keyBtYXRjaCB9YFxyXG4gICAgICApKVxyXG4gICAgICAucmVwbGFjZSgvXysvZywgJ18nKVxyXG4gICAgICAucmVwbGFjZSgvXl8vLCAnJylcclxuICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0b1NwYWNlQ2FzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGZvbGxvd2luZyByZWdleHAgL1xcLV9cXC4vIG1ha2luZyB0aGUgc3RyaW5nIHNwYWNlIGNhc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvU3BhY2VDYXNlKCkuJDsgIC8vICdzcGluYWwgY2FzZSdcclxuICAgKiBuZXcgU3RyKCdfc25ha2VfY2FzZV8nKS50b1NwYWNlQ2FzZSgpLiQ7IC8vICdzbmFrZSBjYXNlJ1xyXG4gICAqL1xyXG4gIHRvU3BhY2VDYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodHJpbSh0aGlzLiQpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnICcpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxTXS9nLCAobWF0Y2gpID0+IChcclxuICAgICAgICBtYXRjaC50b0xvd2VyQ2FzZSgpID09PSBtYXRjaCA/IG1hdGNoIDogYCAkeyBtYXRjaCB9YFxyXG4gICAgICApKVxyXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAgIC5yZXBsYWNlKC9eXFxzLywgJycpXHJcbiAgICAgIC50b0xvd2VyQ2FzZSgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdG9VcHBlckNhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90b1VwcGVyQ2FzZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjdG9VcHBlckNhc2Vde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90b1VwcGVyQ2FzZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ2xvd2VyLWNhc2UnKS50b1VwcGVyQ2FzZSgpLiQ7ICAvLyAnTE9XRVItQ0FTRSdcclxuICAgKi9cclxuICB0b1VwcGVyQ2FzZSgpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC50b1VwcGVyQ2FzZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RyaW1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyN0cmltXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbX0uXHJcbiAgICovXHJcbiAgdHJpbSgpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5yZXBsYWNlKC9eW1xcc1xcdWZlZmZcXHUwMGEwXSt8W1xcc1xcdWZlZmZcXHUwMGEwXSskL2csICcnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0cmltTGVmdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW1MZWZ0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyN0cmltTGVmdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW1MZWZ0fS5cclxuICAgKi9cclxuICB0cmltTGVmdCgpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5yZXBsYWNlKC9eW1xcc1xcdWZlZmZcXHUwMGEwXSsvLCAnJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdHJpbVJpZ2h0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbVJpZ2h0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyN0cmltUmlnaHRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltUmlnaHR9LlxyXG4gICAqL1xyXG4gIHRyaW1SaWdodCgpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5yZXBsYWNlKC9bXFxzXFx1ZmVmZlxcdTAwYTBdKyQvLCAnJykpO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhTdHIucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdTdHInXHJcbn0pO1xyXG5cclxuY29uc3RydWN0b3JzWzJdLnB1c2goe1xyXG4gIGNoZWNrOiBpc1N0cmluZyxcclxuICBjbHM6IFN0clxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eW1xcc1xcLV8uXSt8W1xcc1xcLV8uXSskL2csICcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBwYXJzZUpTT05cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2pzb24gPSBudWxsXSAtIFN0cmluZyB0byBwYXJzZS5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbb3B0aW9ucy5udW1iZXJzXSAtIElmIGl0IGlzIG5lZWRlZCB0byBwYXJzZSBudW1iZXItbGlrZSBzdHJpbmdzIGFzIG51bWJlcnMuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbb3B0aW9ucy5kYXRlc10gLSBJZiBpdCBpcyBuZWVkZWQgdG8gcGFyc2UgZGF0ZS1saWtlIHN0cmluZyBhcyBkYXRlcy5cclxuICogRGF0ZS1saWtlIHN0cmluZyBpcyBjb25zaWRlcmVkIHRvIG1hdGNoIF5cXGRcXGRcXGRcXGQtXFxkXFxkLVxcZFxcZFRcXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZFxcZFxcZFo/JFxyXG4gKiBAcGFyYW0ge0pTT05DYWxsYmFja30gW2NhbGxiYWNrXSAtIENhbGxiYWNrIHRoYXQgY2FsbGVkIG9uIGV2ZXJ5IGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMge0RXcmFwfSBELVdyYXAgb2YgZm91bmQgbWF0Y2guXHJcbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHBhcnNpbmcganNvbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogcGFyc2VKU09OKCd7IFwiYVwiOiAxIH0nKS4kOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7IGE6IDEgfVxyXG4gKiBwYXJzZUpTT04oJ3sgXCJhXCI6IFwiMVwiIH0nLCB7IG51bWJlcnM6IHRydWUgfSkuJDsgICAgICAgICAgICAgICAgICAgICAgLy8geyBudW1iZXJzOiB0cnVlIH1cclxuICogcGFyc2VKU09OKCd7IFwiYVwiOiBcIjE5OTktMTItMzFUMjM6NTk6NTkuOTk5WlwiIH0nLCB7IGRhdGVzOiB0cnVlIH0pLiQ7IC8vIHsgYTogRGF0ZSB7Li4ufSB9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUpTT04oanNvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICByZXR1cm4gRChKU09OLnBhcnNlKGpzb24pKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XHJcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IG51bWJlcnMsIGRhdGVzIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgIGlmIChkYXRlcyAmJiAvXlxcZFxcZFxcZFxcZC1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkXFxkXFxkWj8kLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAobnVtYmVycyAmJiBpc051bWJlckxpa2UodmFsdWUpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHZhbHVlO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gRChwYXJzZWQpO1xyXG59XHJcblxyXG5leHBvcnQgeyBTdHIsIHBhcnNlSlNPTiB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL21hcmt1cFRvSlNPTlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBtYXJrdXBUb0pTT04gbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi4vU3VwZXInO1xyXG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4uL1N3aXRjaGVyJztcclxuaW1wb3J0IHsgaHRtbEFsbG93ZWRUYWdTeW1ib2xzLCBodG1sQWxsb3dlZEF0dHJTeW1ib2xzLCB2b2lkRWxlbWVudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmt1cEVsZW1lbnRcclxuICogQHByb3BlcnR5IHsnY29tbWVudCd8J3RleHQnfCdlbGVtZW50J30gdHlwZSAtIFR5cGUgb2YgdGhlIG5vZGUuXHJcbiAqIEBwcm9wZXJ0eSB7TWFya3VwRWxlbWVudH0gcGFyZW50IC0gVHlwZSBvZiB0aGUgbm9kZS5cclxuICogQHByb3BlcnR5IHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gYXR0cnMgLSBOb2RlIGF0dHJpYnV0ZXNcclxuICogQHByb3BlcnR5IHtNYXJrdXBFbGVtZW50W119IGNoaWxkcmVuIC0gTm9kZSBjaGlsZHJlbi5cclxuICovXHJcblxyXG5jb25zdCBzdWJtaXRTdHJpbmcgPSAnUGxlYXNlLCBzdWJtaXQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2R3YXluZWpzL2R3YXluZS9pc3N1ZXMuJztcclxuY29uc3QgTk9ERV9SRUdFWF9TRVQgPSBuZXcgU3VwZXIoe1xyXG4gICd0YWctb3Blbic6IG5ldyBSZWdFeHAoYDwoJHsgaHRtbEFsbG93ZWRUYWdTeW1ib2xzIH0pXFxcXHMqYCwgJ2knKSxcclxuICAndGFnLWNsb3NlJzogY29uc3RydWN0Q2xvc2VUYWdSZWdFeHAoaHRtbEFsbG93ZWRUYWdTeW1ib2xzKSxcclxuICBjb21tZW50OiAvPCEtLSgoPzotW15cXC0+XXxbXlxcLT5dKSg/Oi0/W14tXSkqW14tXT98KS0tPi9cclxufSk7XHJcbmNvbnN0IFRBR19PUEVOX0NMT1NFID0gL14oXFwvPyk+LztcclxuLy8gY29uc3QgQVRUUklCVVRFID0gL14oW15cXHUwMDAwLVxcdTAwMjBcXHNcIic+XFwvPV0rKSg/Olxccyo9XFxzKignW14nXSonfFwiW15cIl0qXCJ8W15cXHNcIidgPD49XSspKT9cXHMqLztcclxuY29uc3QgQVRUUklCVVRFID0gbmV3IFJlZ0V4cChgXigkeyBodG1sQWxsb3dlZEF0dHJTeW1ib2xzIH0pKD86XFxcXHMqPVxcXFxzKignW14nXSonfFwiW15cIl0qXCJ8W15cXFxcc1wiJ1xcYDw+PV0rKSk/XFxcXHMqYCk7XHJcbmNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5jb25zdCBub2RlU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKGVsZW0pID0+IGVsZW0pXHJcbiAgLmNhc2UoJ3RhZy1vcGVuJywgKGVsZW0sIG5vZGUpID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgdmFsdWU6IG5hbWUsXHJcbiAgICAgIHNlbGZDbG9zaW5nXHJcbiAgICB9ID0gbm9kZTtcclxuXHJcbiAgICBub2RlID0ge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBhdHRyczogbmV3IFN1cGVyKG5vZGUuYXR0cnMpLm1hcCgodmFsdWUpID0+IChcclxuICAgICAgICBwYXJzZUNoYXJhY3RlckRhdGEodmFsdWUpXHJcbiAgICAgICkpLiQsXHJcbiAgICAgIHBhcmVudDogZWxlbSxcclxuICAgICAgY2hpbGRyZW46IG5ldyBBcnIoW10pXHJcbiAgICB9O1xyXG5cclxuICAgIGVsZW0uY2hpbGRyZW4ucHVzaChub2RlKTtcclxuXHJcbiAgICBpZiAoIXNlbGZDbG9zaW5nICYmIHZvaWRFbGVtZW50cy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xyXG4gICAgICBlbGVtID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbTtcclxuICB9KVxyXG4gIC5jYXNlKCd0YWctY2xvc2UnLCAoZWxlbSwgbm9kZSkgPT4ge1xyXG4gICAgaWYgKGVsZW0ubmFtZSA9PT0gbm9kZS52YWx1ZSkge1xyXG4gICAgICBlbGVtID0gZWxlbS5wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW07XHJcbiAgfSlcclxuICAuY2FzZShbJ2NvbW1lbnQnLCAndGV4dCddLCAoZWxlbSwgbm9kZSwgY29sbGFwc2VXaGl0ZVNwYWNlLCB0eXBlKSA9PiB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0ge1xyXG4gICAgICBuYW1lOiBgIyR7IHR5cGUgfWAsXHJcbiAgICAgIHBhcmVudDogZWxlbSxcclxuICAgICAgdmFsdWU6IG5vZGUudmFsdWVcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0JyAmJiBlbGVtLm5hbWUgIT09ICdzY3JpcHQnICYmIGVsZW0ubmFtZSAhPT0gJ3N0eWxlJykge1xyXG4gICAgICBlbGVtZW50LnZhbHVlID0gcGFyc2VDaGFyYWN0ZXJEYXRhKGVsZW1lbnQudmFsdWUpO1xyXG5cclxuICAgICAgaWYgKGNvbGxhcHNlV2hpdGVTcGFjZSkge1xyXG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBuZXcgU3RyKGVsZW1lbnQudmFsdWUpLnRyaW0oKS4kO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb2xsYXBzZVdoaXRlU3BhY2UgfHwgIS9eXFxzKiQvLnRlc3QoZWxlbWVudC52YWx1ZSkpIHtcclxuICAgICAgZWxlbS5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtO1xyXG4gIH0pO1xyXG5jb25zdCByYXdUZXh0U3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgZmFsc2UpXHJcbiAgLmNhc2UoWyd0aXRsZScsICd0ZXh0YXJlYScsICdzdHlsZScsICdzY3JpcHQnXSwgdHJ1ZSk7XHJcblxyXG5jbGFzcyBJbnRlcm5hbFBhcnNpbmdFcnJvciB7XHJcbiAgY29uc3RydWN0b3IoaW5kZXgpIHtcclxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFBhcnNpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICB0eXBlID0gJ1BBUlNJTkdfRVJST1InO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIG1hcmt1cFRvSlNPTlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWFya3VwIC0gTWFya3VwIHRvIHBhcnNlIHRvIEpTT04uXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbGxhcHNlV2hpdGVTcGFjZSA9IGZhbHNlXSAtIElmIHRoZSB3aGl0ZXNwYWNlIHNob3VsZCBiZSBjb2xsYXBzZWQuXHJcbiAqIEByZXR1cm5zIHtBcnIuPE1hcmt1cEVsZW1lbnQ+fSBNYXJrdXAgZWxlbWVudHMgYXJyYXkuXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgcGFyc2luZyBodG1sIGFuZCB4bWwgdG8gSlNPTi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IChtYXJrdXAsIGNvbGxhcHNlV2hpdGVTcGFjZSkgPT4ge1xyXG4gIGNvbGxhcHNlV2hpdGVTcGFjZSA9ICEhY29sbGFwc2VXaGl0ZVNwYWNlO1xyXG5cclxuICBjb25zdCBlbGVtZW50cyA9IG5ldyBBcnIoW10pO1xyXG4gIGNvbnN0IHN0YXJ0TWFya3VwID0gbWFya3VwO1xyXG4gIGxldCBmb3VuZDtcclxuICBsZXQgZ2xvYmFsSW5kZXggPSAwO1xyXG4gIGxldCBlbGVtID0ge1xyXG4gICAgbmFtZTogbnVsbCxcclxuICAgIGNoaWxkcmVuOiBlbGVtZW50c1xyXG4gIH07XHJcblxyXG4gIHdoaWxlIChtYXJrdXAubGVuZ3RoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBmb3VuZCA9IGZpbmQobWFya3VwLCBlbGVtKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBJbnRlcm5hbFBhcnNpbmdFcnJvcikpIHtcclxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRFcnJvcigpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKGBQYXJzaW5nIGVycm9yIG5lYXIgaW5kZXggJHsgbmVhclN0cmluZyhzdGFydE1hcmt1cCwgZ2xvYmFsSW5kZXggKyBlcnIuaW5kZXgpIH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIGF0dHJzLFxyXG4gICAgICBzZWxmQ2xvc2luZyxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9ID0gZm91bmQ7XHJcblxyXG4gICAgZ2xvYmFsSW5kZXggKz0gaW5kZXg7XHJcblxyXG4gICAgaWYgKCFpbmRleCkge1xyXG4gICAgICB0aHJvd1VuZXhwZWN0ZWRFcnJvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vZGUgPSB7XHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0eXBlID09PSAndGFnLW9wZW4nKSB7XHJcbiAgICAgIG5vZGUuYXR0cnMgPSBhdHRycztcclxuICAgICAgbm9kZS5zZWxmQ2xvc2luZyA9IHNlbGZDbG9zaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW0gPSBub2RlU3dpdGNoZXIobm9kZS50eXBlLCBbZWxlbSwgbm9kZSwgY29sbGFwc2VXaGl0ZVNwYWNlXSk7XHJcblxyXG4gICAgbWFya3VwID0gbWFya3VwLnNsaWNlKGluZGV4KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50cztcclxuXHJcbiAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkRXJyb3IoKSB7XHJcbiAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKGBVbmV4cGVjdGVkIHBhcnNpbmcgZXJyb3IgbmVhciBpbmRleCAkeyBuZWFyU3RyaW5nKHN0YXJ0TWFya3VwLCBnbG9iYWxJbmRleCkgfS4gJHsgc3VibWl0U3RyaW5nIH1gKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaW5kKG1hcmt1cCwgZWxlbSkge1xyXG4gIGNvbnN0IHsgbmFtZSB9ID0gZWxlbTtcclxuICBsZXQgbWF0Y2hlcztcclxuXHJcbiAgaWYgKHJhd1RleHRTd2l0Y2hlcihuYW1lKSkge1xyXG4gICAgbWF0Y2hlcyA9IG5ldyBTdXBlcih7XHJcbiAgICAgICd0YWctY2xvc2UnOiBtYXJrdXAubWF0Y2goY29uc3RydWN0Q2xvc2VUYWdSZWdFeHAobmFtZSkpXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWF0Y2hlcyA9IE5PREVfUkVHRVhfU0VULm1hcCgocmVnZXgpID0+IChcclxuICAgICAgbWFya3VwLm1hdGNoKHJlZ2V4KVxyXG4gICAgKSk7XHJcbiAgfVxyXG5cclxuICBsZXQgbWF0Y2g7XHJcblxyXG4gIGlmIChcclxuICAgIG1hdGNoID0gbWF0Y2hlcy5maW5kKChtYXRjaCkgPT4gKFxyXG4gICAgICBtYXRjaCAmJiBtYXRjaC5pbmRleCA9PT0gMFxyXG4gICAgKSlcclxuICApIHtcclxuICAgIGNvbnN0IHJldHVybmluZyA9IHtcclxuICAgICAgdHlwZTogbWF0Y2gua2V5LFxyXG4gICAgICBpbmRleDogbWF0Y2gudmFsdWVbMF0ubGVuZ3RoLFxyXG4gICAgICB2YWx1ZTogbWF0Y2gudmFsdWVbMV1cclxuICAgIH07XHJcbiAgICBjb25zdCBhdHRycyA9IHt9O1xyXG5cclxuICAgIGlmIChtYXRjaC5rZXkgPT09ICd0YWctb3BlbicpIHtcclxuICAgICAgY29uc3Qgc3RhcnRNYXJrdXAgPSBtYXJrdXA7XHJcbiAgICAgIGxldCBjbG9zZU1hdGNoO1xyXG5cclxuICAgICAgcmV0dXJuaW5nLnNlbGZDbG9zaW5nID0gZmFsc2U7XHJcbiAgICAgIHJldHVybmluZy5hdHRycyA9IGF0dHJzO1xyXG5cclxuICAgICAgd2hpbGUgKFxyXG4gICAgICAgIChtYXJrdXAgPSBzdGFydE1hcmt1cC5zbGljZShyZXR1cm5pbmcuaW5kZXgpKSAmJlxyXG4gICAgICAgICEoY2xvc2VNYXRjaCA9IG1hcmt1cC5tYXRjaChUQUdfT1BFTl9DTE9TRSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBtYXJrdXAubWF0Y2goQVRUUklCVVRFKTtcclxuXHJcbiAgICAgICAgaWYgKCFhdHRyKSB7XHJcbiAgICAgICAgICByZXR1cm5pbmcuaW5kZXggKz0gMTtcclxuXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF0dHJzW2F0dHJbMV1dID0gKGF0dHJbMl0gfHwgJycpLnJlcGxhY2UoL14oXCJ8Jyl8KFwifCcpJC9nLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuaW5nLmluZGV4ICs9IGF0dHJbMF0ubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2xvc2VNYXRjaCkge1xyXG4gICAgICAgIHJldHVybmluZy5pbmRleCArPSBjbG9zZU1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICByZXR1cm5pbmcuc2VsZkNsb3NpbmcgPSAhIWNsb3NlTWF0Y2hbMV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0dXJuaW5nO1xyXG4gIH1cclxuXHJcbiAgbGV0IHsgdmFsdWU6IGluZGV4IH0gPSBtYXRjaGVzLm1pbigobWF0Y2gpID0+IChcclxuICAgIG1hdGNoID8gbWF0Y2guaW5kZXggOiBOYU5cclxuICApKTtcclxuXHJcbiAgaWYgKGluZGV4ID09PSBJbmZpbml0eSkge1xyXG4gICAgaW5kZXggPSBtYXJrdXAubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgIGluZGV4LFxyXG4gICAgdmFsdWU6IG1hcmt1cC5zbGljZSgwLCBpbmRleClcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbG9zZVRhZ1JlZ0V4cCh0YWdOYW1lKSB7XHJcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYDwvKCR7IHRhZ05hbWUgfSlcXFxccyo+YCwgJ2knKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbmVhclN0cmluZyhtYXJrdXAsIGluZGV4KSB7XHJcbiAgcmV0dXJuIGAkeyBpbmRleCB9ICh+fn4gXCIkeyBtYXJrdXAuc2xpY2UoaW5kZXgsIGluZGV4ICsgMTUpIH1cIiB+fn4sIHRoZSBzdHJpbmcgaXRzZWxmIGlzIFwiJHsgbWFya3VwIH1cIilgO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUNoYXJhY3RlckRhdGEoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8mKFxcdyt8I3g/XFxkKyk7L2csIChtYXRjaCkgPT4ge1xyXG4gICAgZGl2LmlubmVySFRNTCA9IG1hdGNoO1xyXG5cclxuICAgIHJldHVybiBkaXYudGV4dENvbnRlbnQgfHwgZGl2LmlubmVyVGV4dDtcclxuICB9KTtcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBFbGVtXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBFbGVtIGNsYXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IEFyciwgYXJyYXksIGl0ZXJhdGUgYXMgdGltZXMgfSBmcm9tICcuL0Fycic7XHJcbmltcG9ydCB7IGJsb2IgfSBmcm9tICcuL0Jsb2JPYmplY3QnO1xyXG5pbXBvcnQgeyBtZXRob2QgfSBmcm9tICcuL0Z1bmMnO1xyXG5pbXBvcnQgeyBQcm9taXNlIH0gZnJvbSAnLi9Qcm9taXNlJztcclxuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9TdHInO1xyXG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4vU3dpdGNoZXInO1xyXG5pbXBvcnQge1xyXG4gIGNvbnN0cnVjdG9ycywgYXBwbGllZFJlZ0V4cHMsIGh0bWxFbGVtZW50cywgc3ZnRWxlbWVudHMsXHJcbiAgY2FudmFzR2V0TWV0aG9kcywgY2FudmFzUmVzdE1ldGhvZHNcclxufSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7XHJcbiAgaXNBcnJheSwgaXNBcnJheUxpa2UsIGlzRWxlbWVudCwgaXNGdW5jdGlvbixcclxuICBpc0ludGVnZXIsIGlzTmlsLCBpc051bWJlciwgaXNOdWxsLCBpc1N0cmluZyxcclxuICBhc3NpZ24sIGR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzLCBkZWZpbmVQcm9wZXJ0aWVzLCB0b0FycmF5LFxyXG4gIHZhbGlkYXRlLCB0b1N0cmluZ1RhZywgaXRlcmF0ZSwgU3ltYm9sXHJcbn0gZnJvbSAnLi9oZWxwZXJzJztcclxuaW1wb3J0IG1hcmt1cFRvSlNPTiBmcm9tICcuL2hlbHBlcnMvbWFya3VwVG9KU09OJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7U3RyaW5nfSBFbGVtRXZlbnRTdHJpbmdcclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gQSBzdHJpbmcgY29udGFpbmluZyBldmVudHMgc2VwYXJhdGVkIGJ5IGEgY29tbWEgd2l0aCB6ZXJvIG9yIG1vcmUgc3BhY2VzIG9yIGp1c3Qgc3BhY2VzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgRWxlbVZhbHVlQ2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBPbGQgdmFsdWUuXHJcbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEN1cnJlbnQgZWxlbWVudC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggaW4gdGhlIHNldCBvZiB0aGUgZWxlbWVudHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBFbGVtU2V0T2ZDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gY3JlYXRlZCAtIENyZWF0ZWQgZWxlbWVudC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBpdGVyYXRlZCBlbGVtZW50IGluIHRoZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7S2V5fSBrZXkgLSBLZXkgb2YgdGhlIGl0ZXJhdGVkIGVsZW1lbnQgaW4gdGhlIG9iamVjdC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdGhhdCBpcyBpdGVyYXRlZCBvdmVyLlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBDdXJyZW50IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBWYWxpZGF0ZUNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEVsZW1lbnQgdmFsdWUuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEVsZW1lbnQgdG8gdmFsaWRhdGUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBlbGVtZW50LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgQ3R4Q2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ2FudmFzIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgRWxlbUxpc3RlbmVyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtFdmVudH0gZSAtIEZpcmVkIGV2ZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBFbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEVsZW1SZW1vdmVMaXN0ZW5lcnNcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gey4uLkVsZW1FdmVudFN0cmluZ30gZXZlbnRzIC0gSWYgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IHByZXNlbnQgb25seSByZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBzcGVjaWZpZWRcclxuICogYnkgdGhlIGV2ZW50cyBpbiB0aGUgYXJndW1lbnRzLlxyXG4gKi9cclxuXHJcbmNvbnN0IG5hdGl2ZURvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xyXG5jb25zdCBlbXB0eURpdiA9IG5hdGl2ZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5jb25zdCBldmVudFNlcGFyYXRvciA9IC8oLHwgKSAqLztcclxuY29uc3QgdGV4dFByb3BlcnR5ID0gbmV3IFN1cGVyKE5vZGUucHJvdG90eXBlKS5wcm9wZXJ0eURlc2NyaXB0b3IoJ3RleHRDb250ZW50JykgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XHJcbmNvbnN0IGNsYXNzZXMgPSB7fTtcclxuY29uc3QgYXR0cnMgPSB7fTtcclxuY29uc3Qgd2luZG93c0R3YXluZURhdGEgPSBuZXcgQXJyKFtdKTtcclxuY29uc3QgaW5wdXRFbGVtZW50cyA9ICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgZGF0YWxpc3QsIGtleWdlbiwgb3V0cHV0JztcclxuY29uc3QgY2xpY2sgPSBtZXRob2QoJ2NsaWNrJyk7XHJcbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuY29uc3QgeG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xyXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5jb25zdCB4aHRtbE5TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xyXG5jb25zdCB0eXBlU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsIChlbGVtLCB0eXBlKSA9PiB7XHJcbiAgY29uc3QgbnMgPSB0eXBlID09PSAnc3ZnJ1xyXG4gICAgPyBzdmdOU1xyXG4gICAgOiBlbGVtLnByb3AoJ25hbWVzcGFjZVVSSScpIHx8IG5hdGl2ZURvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgfHwgeGh0bWxOUztcclxuXHJcbiAgcmV0dXJuIG5hdGl2ZURvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdHlwZSk7XHJcbn0pXHJcbiAgLmNhc2UoXHJcbiAgICAodHlwZSkgPT4gdHlwZSA9PT0gJyNjb21tZW50JyxcclxuICAgICgpID0+IG5hdGl2ZURvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpXHJcbiAgKVxyXG4gIC5jYXNlKFxyXG4gICAgKHR5cGUpID0+IHR5cGUgPT09ICcjdGV4dCcsXHJcbiAgICAoKSA9PiBuYXRpdmVEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJylcclxuICApO1xyXG5jb25zdCByZWZTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAnaHJlZicpXHJcbiAgLmNhc2UoXHJcbiAgICBbJ2ltZycsICdzY3JpcHQnLCAnaWZyYW1lJywgJ2F1ZGlvJywgJ3ZpZGVvJ10sXHJcbiAgICAnc3JjJ1xyXG4gIClcclxuICAuY2FzZShcclxuICAgICdmb3JtJyxcclxuICAgICdhY3Rpb24nXHJcbiAgKTtcclxuY29uc3QgZmlsdGVyU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsIChzZWxlY3RvcikgPT4gc2VsZWN0b3IpXHJcbiAgLmNhc2UoXHJcbiAgICBpc1N0cmluZyxcclxuICAgIChzZWxlY3RvcikgPT4gKFxyXG4gICAgICAoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpXHJcbiAgICApXHJcbiAgKVxyXG4gIC5jYXNlKFxyXG4gICAgW2lzQXJyYXksIGlzRWxlbV0sXHJcbiAgICAoZWxlbXMpID0+IHtcclxuICAgICAgZWxlbXMgPSBuZXcgQXJyKGVsZW1zKTtcclxuXHJcbiAgICAgIHJldHVybiAoZWxlbSkgPT4gZWxlbXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XHJcbiAgICB9XHJcbiAgKTtcclxuY29uc3QgaW5uZXJTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAwKVxyXG4gIC5jYXNlKCdwYWRkaW5nLWJveCcsIChwYWRkaW5ncykgPT4gcGFkZGluZ3MpXHJcbiAgLmNhc2UoJ2JvcmRlci1ib3gnLCAocGFkZGluZ3MsIGJvcmRlcnMpID0+IHBhZGRpbmdzICsgYm9yZGVycyk7XHJcbmNvbnN0IG91dGVyU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKGJvcmRlcnMsIHBhZGRpbmdzKSA9PiBib3JkZXJzICsgcGFkZGluZ3MpXHJcbiAgLmNhc2UoJ3BhZGRpbmctYm94JywgKGJvcmRlcnMpID0+IGJvcmRlcnMpXHJcbiAgLmNhc2UoJ2JvcmRlci1ib3gnLCAwKTtcclxuY29uc3QgYXR0ck5TU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsIG51bGwpXHJcbiAgLmNhc2UoKGF0dHIpID0+IGF0dHIgPT09ICd4bWxucycgfHwgYXR0ciA9PT0gJ3htbG5zOnhsaW5rJywgKGVsZW0pID0+IChcclxuICAgIGVsZW0ubmFtZSA9PT0gJ3N2ZydcclxuICAgICAgPyB4bWxOU1xyXG4gICAgICA6IG51bGxcclxuICApKVxyXG4gIC5jYXNlKChhdHRyKSA9PiAvXnhsaW5rOlxcdy8udGVzdChhdHRyKSwgKGVsZW0pID0+IChcclxuICAgIGVsZW0uY2xvc2VzdCgnc3ZnJykubGVuZ3RoXHJcbiAgICAgID8geGxpbmtOU1xyXG4gICAgICA6IG51bGxcclxuICApKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgRWxlbVxyXG4gKiBAZXh0ZW5kcyBBcnJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBbZWxlbSA9IFtdXSAtIEFuIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgZWxlbWVudHMgdG8gd3JhcC5cclxuICogQHJldHVybnMge0VsZW19IEluc3RhbmNlIG9mIEVsZW0uXHJcbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFuIGVsZW1lbnRzIHNldC4gQWxzbyBoYXMgYWxsIG1ldGhvZHMgZnJvbSBmcm9tXHJcbiAqIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9LlxyXG4gKiBHZXR0ZXJzIG1ldGhvZHMgcmV0dXJuIHRoZSBzYW1lIGFzIG1ldGhvZHMgZnJvbSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgYW5kIHRoZSByZXN0IHJldHVybiB0aGlzLlxyXG4gKiBXb3JrIGZvciB0aGUgZmlyc3QgY2FudmFzIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XHJcbiAqIG5ldyBFbGVtKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jbHMnKSk7XHJcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NscycpKTtcclxuICovXHJcbmNsYXNzIEVsZW0gZXh0ZW5kcyBBcnIge1xyXG4gIGNvbnN0cnVjdG9yKGVsZW0gPSBbXSkge1xyXG4gICAgc3VwZXIoKCgpID0+IHtcclxuICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtO1xyXG5cclxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGVsZW1lbnQpICYmIChcclxuICAgICAgICBpc1dpbmRvdyhlbGVtZW50KSB8fFxyXG4gICAgICAgIGlzSFRNTERvY3VtZW50KGVsZW1lbnQpIHx8XHJcbiAgICAgICAgaXNEb2N1bWVudEZyYWdtZW50KGVsZW1lbnQpIHx8XHJcbiAgICAgICAgaXNFbGVtZW50KGVsZW1lbnQpIHx8XHJcbiAgICAgICAgaXNDb21tZW50T3JUZXh0KGVsZW1lbnQpIHx8XHJcbiAgICAgICAgaXNTdHlsZVJ1bGUoZWxlbWVudClcclxuICAgICAgKSkge1xyXG4gICAgICAgIGVsZW1lbnQgPSBbZWxlbWVudF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgQXJyKHRvQXJyYXkobmV3IFN1cGVyKGVsZW1lbnQpLiQsIHRydWUpKS5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1zLmluZGV4T2YoZWxlbSkgPT09IC0xICYmIChcclxuICAgICAgICAgIGlzRWxlbWVudChlbGVtKSB8fFxyXG4gICAgICAgICAgaXNXaW5kb3coZWxlbSkgfHxcclxuICAgICAgICAgIGlzSFRNTERvY3VtZW50KGVsZW0pIHx8XHJcbiAgICAgICAgICBpc0RvY3VtZW50RnJhZ21lbnQoZWxlbSkgfHxcclxuICAgICAgICAgIGlzQ29tbWVudE9yVGV4dChlbGVtKSB8fFxyXG4gICAgICAgICAgaXNTdHlsZVJ1bGUoZWxlbSlcclxuICAgICAgICApKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWxlbXMucHVzaChlbGVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0VsZW0oZWxlbSkpIHtcclxuICAgICAgICAgIGVsZW1zLnB1c2guYXBwbHkoZWxlbXMsIGVsZW0uJCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBbXSkuJDtcclxuICAgIH0pKCkpO1xyXG5cclxuICAgIHRoaXMuJCQgPSBlbGVtO1xyXG5cclxuICAgIHRoaXMuZm9yRWFjaChhZGREd2F5bmVEYXRhKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge0FycmF5LjxOb2RlfFdpbmRvdz59IEVsZW0jJFxyXG4gICAgICogQHR5cGUge0FycmF5LjxOb2RlfFdpbmRvdz59XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29uc3RydWN0ZWQgZWxlbWVudCBzZXQuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIgeyp9IEVsZW0jJCRcclxuICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWwgZWxlbWVudCBzZXQuXHJcbiAgICAgKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhZGRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi4oU3RyaW5nfEVsZW18RWxlbWVudHxFbGVtZW50W10pfSBlbGVtZW50cyAtIEVhY2ggYXJndW1lbnQgaXMgYSBzZWxlY3Rvciwgb3IgRWxlbSwgb3IgRWxlbWVudCwgb3IgYXJyYXkgb2YgRWxlbWVudHMuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgbmV3IGVsZW1lbnRzIHRvIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0xLmZpbmQoJy5jbHMxJylcclxuICAgKiAgIC5hZGQoZWxlbTIuZmluZCgnLmNsczInKSlcclxuICAgKiAgIC5oaWRlKCk7XHJcbiAgICovXHJcbiAgYWRkKC4uLmVsZW1lbnRzKSB7XHJcbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGVsZW0pID0+IHtcclxuICAgICAgdG9GaW5kKGVsZW0pLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgICBpZiAodGhpcy5pbmRleE9mKGVsZW0pID09PSAtMSkge1xyXG4gICAgICAgICAgdGhpcy5wdXNoKGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhZGRDbGFzc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gYWRkLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIGNsYXNzZXMgdG8gdGhlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5hZGRDbGFzcygncmVkJywgJ3JvdW5kJyk7XHJcbiAgICovXHJcbiAgYWRkQ2xhc3MoLi4uY2xhc3Nlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCBsaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XHJcblxyXG4gICAgICBpdGVyYXRlKGlzRWxlbWVudChlbGVtKSAmJiBhcmd1bWVudHMsIChjbHMpID0+IGxpc3QuYWRkKGNscykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jYWRkQ29tbWVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRleHQgb2YgY29tbWVudCB0byBhZGQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmQgLSBJZiB0aGUgY29tbWVudCBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgaXQncyBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY29tbWVudCB0byBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYWRkSFRNTCgnPGRpdj4xPC9kaXY+Jyk7XHJcbiAgICovXHJcbiAgYWRkQ29tbWVudCh0ZXh0LCBlbmQgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICBlbGVtLmluc2VydEFkamFjZW50SFRNTChlbmQgPyAnYmVmb3JlZW5kJyA6ICdhZnRlcmJlZ2luJywgYDwhLS0keyB0ZXh0IH0tLT5gKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jYWRkSFRNTFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCAtIEhUTUwgdG8gYWRkLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIEhUTUwgc2hvdWxkIGJlIGluc2VydGVkIHRvIHRoZSBlbmQuIElmIGZhbHNlIGl0J3MgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIEhUTUwgdG8gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmFkZEhUTUwoJzxkaXY+MTwvZGl2PicpO1xyXG4gICAqL1xyXG4gIGFkZEhUTUwoaHRtbCwgZW5kID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgZWxlbS5pbnNlcnRBZGphY2VudEhUTUwoZW5kID8gJ2JlZm9yZWVuZCcgOiAnYWZ0ZXJiZWdpbicsIGh0bWwpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhZGRSdWxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcnVsZS5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciBmb3IgdGhlIHJ1bGVcclxuICAgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBzdHlsZSAtIFN0eWxlIGZvciB0aGUgc2VsZWN0b3IuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY3NzIHN0eWxlcyBpbnRvIHRoZSBmaXJzdCBzdHlsZSB0YWcgaW4gdGhlIHNldC5cclxuICAgKiBOb3RlOiBzdHlsZSBlbGVtZW50IHNob3VsZCBiZSBpbnNpZGUgdGhlIGRvY3VtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBzdHlsZS5hZGRSdWxlKCdpbWctc2l6ZScsICdpbWcuc3F1YXJlJywge1xyXG4gICAqICAgd2lkdGg6ICc0MHB4ICFpbXBvcnRhbnQnLFxyXG4gICAqICAgaGVpZ2h0OiAnNDBweCAhaW1wb3J0YW50J1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIGFkZFJ1bGUobmFtZSwgc2VsZWN0b3IsIHN0eWxlKSB7XHJcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICBjb25zdCB7IHNoZWV0IH0gPSBlbGVtO1xyXG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzaGVldC5jc3NSdWxlcztcclxuICAgICAgICBjb25zdCBydWxlcyA9IG5ldyBTdXBlcihzdHlsZSkud29yZCgodmFsdWUsIHByb3BlcnR5KSA9PiAoXHJcbiAgICAgICAgICBgJHsgbmV3IFN0cihwcm9wZXJ0eSkudG9IeXBoZW5DYXNlKCkgfTogJHsgdmFsdWUgfTtcXG5gXHJcbiAgICAgICAgKSk7XHJcblxyXG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoXHJcbiAgICAgICAgICBgJHsgc2VsZWN0b3IgfSB7JHsgcnVsZXMgJiYgJ1xcbicgfSR7IHJ1bGVzIH19YCxcclxuICAgICAgICAgIGxlbmd0aFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2hlZXQuY3NzUnVsZXNbbGVuZ3RoXS5kd2F5bmVEYXRhID0geyBuYW1lIH07XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhZGRUZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBhZGQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmQgLSBJZiB0aGUgdGV4dCBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgaXQncyBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgdGV4dCB0byBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYWRkVGV4dCgnMTIzJyk7XHJcbiAgICovXHJcbiAgYWRkVGV4dCh0ZXh0LCBlbmQgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIG5ldyBFbGVtKG5hdGl2ZURvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKS5pbnRvKGVsZW0sIGVuZCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhcHBseVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gc3RyaW5ncyAtIFN0cmluZ3MgdG8gYXBwbHkuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgaXMgYSBzaG9ydGhhbmQgZm9yIG1hbnkgb3RoZXIgbWV0aG9kcy5cclxuICAgKiBBbGwgc2hvcnRoYW5kcyBjYW4gYmUgc2VwYXJhdGVkIHdpdGggc3BhY2UgYW5kIHdyaXR0ZW4gd2l0aGluIG9uZSBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYXBwbHkoXHJcbiAgICogICAnI2lkIC5jMSAuYzIgQGJvcmRlcigxcHggc29saWQgYmxhY2spICRkaXNhYmxlZCAkYXR0cihzb21lIHZhbHVlKSAqKENsaWNrIG1lISknXHJcbiAgICogKTtcclxuICAgKiAvLyBzaG9ydGhhbmQgZm9yXHJcbiAgICogLy8gZWxlbVxyXG4gICAqIC8vICAgLmlkKCdpZCcpXHJcbiAgICogLy8gICAuYWRkQ2xhc3MoJ2MxJywgJ2MyJylcclxuICAgKiAvLyAgIC5jc3MoJ2JvcmRlcicsICcxcHggc29saWQgYmxhY2snKVxyXG4gICAqIC8vICAgLmF0dHIoe1xyXG4gICAqIC8vICAgICBhdHRyLCAnc29tZSB2YWx1ZSdcclxuICAgKiAvLyAgICAgZGlzYWJsZWQ6ICcnXHJcbiAgICogLy8gICB9KVxyXG4gICAqIC8vICAgLnRleHQoJ0NsaWNrIG1lIScpO1xyXG4gICAqIC8vIFRoZXJlIGlzIGEgZnVsbCBsaXN0IG9mIHBvc3NpYmxlIHR5cGVzIG9mIHN5bnRheCBiZWxvdy4uLlxyXG4gICAqXHJcbiAgICogZWxlbS5hcHBseSgnI2lkJyk7ICAgICAgICAgICAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uaWQoJ2lkJyk7XHJcbiAgICogZWxlbS5hcHBseSgnLmMxIC5jMicpOyAgICAgICAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uYWRkQ2xhc3MoJ2MxJywgJ2MyJyk7XHJcbiAgICogZWxlbS5hcHBseSgnLS5jMSAtLmMyJyk7ICAgICAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0ucmVtb3ZlQ2xhc3MoJ2MxJywgJ2MyJyk7XHJcbiAgICogZWxlbS5hcHBseSgnLUBmbG9hdCAtQGRpc3BsYXknKTsgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0ucmVtb3ZlQ1NTKCdmbG9hdCcsICdkaXNwbGF5Jyk7XHJcbiAgICogZWxlbS5hcHBseSgnLSRhMSAtJGEyJyk7ICAgICAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0ucmVtb3ZlQXR0cignYTEnLCAnYTInKTtcclxuICAgKiBlbGVtLmFwcGx5KCcqKHNvbWUgdGV4dCknKTsgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS50ZXh0KCdzb21lIHRleHQnKTtcclxuICAgKiBlbGVtLmFwcGx5KCcmKDxkaXY+MTwvZGl2PiknKTsgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5odG1sKCc8ZGl2PjE8L2Rpdj4nKTtcclxuICAgKiBlbGVtLmFwcGx5KCdAZmxvYXQocmlnaHQpJyk7ICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5jc3MoJ2Zsb2F0JywgJ3JpZ2h0Jyk7XHJcbiAgICogZWxlbS5hcHBseSgnQHRyYW5zZm9ybShzY2FsZSg1cHgpKScpOyAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uY3NzKCd0cmFuc2Zvcm0nLCAnc2NhbGUoNXB4KScpO1xyXG4gICAqIGVsZW0uYXBwbHkoJ0BtYXJnaW4oMnB4IDJweCknKTsgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmNzcygnbWFyZ2luJywgJzJweCAycHgnKTtcclxuICAgKiBlbGVtLmFwcGx5KCdAbWFyZ2luTGVmdCgycHgpJyk7ICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5jc3MoJ21hcmdpbkxlZnQnLCAnMnB4IDJweCcpO1xyXG4gICAqIGVsZW0uYXBwbHkoJ0BtYXJnaW4tbGVmdCgycHgpJyk7ICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmNzcygnbWFyZ2luLWxlZnQnLCAnMnB4IDJweCcpO1xyXG4gICAqIGVsZW0uYXBwbHkoJyRhdHRyKHNvbWUgdmFsdWUpJyk7ICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmF0dHIoJ2F0dHInLCAnc29tZSB2YWx1ZScpO1xyXG4gICAqIGVsZW0uYXBwbHkoJyRhdHRyJyk7ICAgICAgICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmF0dHIoJ2F0dHInLCAnJyk7XHJcbiAgICovXHJcbiAgYXBwbHkoLi4uc3RyaW5ncykge1xyXG4gICAgbGV0IGFwcGxpZWQ7XHJcbiAgICBsZXQgc2V0QXBwbGllZDtcclxuICAgIGxldCBjYWxsYmFjaztcclxuICAgIGxldCBuYW1lO1xyXG4gICAgbGV0IG5wMTtcclxuICAgIGxldCBzbGljZTtcclxuXHJcbiAgICBuZXcgU3RyKG5ldyBBcnIoYXJndW1lbnRzKS5qb2luKCcgJykpXHJcbiAgICAgIC5zcGxpdCgvKFxccyspLylcclxuICAgICAgLmZvckVhY2goKHN0cmluZykgPT4ge1xyXG4gICAgICAgIGlmICghYXBwbGllZCkge1xyXG4gICAgICAgICAgbnAxID0gc3RyaW5nLnNsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgY2FsbGJhY2sgPSBhcHBsaWVkUmVnRXhwc1tucDFdO1xyXG4gICAgICAgICAgc2xpY2UgPSAxO1xyXG5cclxuICAgICAgICAgIGlmIChjYWxsYmFjayAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja1tzdHJpbmcuc2xpY2UoMSwgMildO1xyXG4gICAgICAgICAgICBzbGljZSA9IDI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKC9eXFxzKyQvLnRlc3Qoc3RyaW5nKSB8fCAhY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG5hbWUgPSBzdHJpbmcuc2xpY2Uoc2xpY2UpLm1hdGNoKC9eW14oKV0rLyk7XHJcblxyXG4gICAgICAgICAgaWYgKCFuYW1lICYmIChucDEgIT09ICcqJyAmJiBucDEgIT09ICcmJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGFwcGxpZWQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPyBuYW1lWzBdIDogJycsXHJcbiAgICAgICAgICAgIGFyZ3M6IHN0cmluZy5zbGljZShzbGljZSArIChuYW1lID8gbmFtZVswXSA6ICcnKS5sZW5ndGgpLFxyXG4gICAgICAgICAgICBjYWxsYmFja1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBzZXRBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc2V0QXBwbGllZCkge1xyXG4gICAgICAgICAgYXBwbGllZC5hcmdzICs9IHN0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYXBwbGllZC5hcmdzIHx8IC9eXFwoW1xcc1xcU10rXFwpJC8udGVzdChhcHBsaWVkLmFyZ3MpKSB7XHJcbiAgICAgICAgICBhcHBsaWVkLmNhbGxiYWNrKHRoaXMsIGFwcGxpZWQubmFtZSwgYXBwbGllZC5hcmdzLnJlcGxhY2UoL15cXCh8XFwpJC9nLCAnJykpO1xyXG4gICAgICAgICAgYXBwbGllZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRBcHBsaWVkID0gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2F0dHJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZ3xFbGVtVmFsdWVDYWxsYmFjaz59IFthdHRyXSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBnZXQgb3JcclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtVmFsdWVDYWxsYmFja30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xyXG4gICAqIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXHJcbiAgICogQHJldHVybnMge1N1cGVyfFN0cmluZ3xFbGVtfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkLCBELVdyYXAgb2YgYXR0cmlidXRlcyBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XHJcbiAgICogcmV0dXJuZWQsIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XHJcbiAgICogcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5hdHRyKCdhdHRyMScsICd2YWx1ZTEnKTsgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUxJyBhbmQgdGhpcyByZXR1cm5lZFxyXG4gICAqIGVsZW0uYXR0cignYXR0cjEnKTsgICAgICAgICAgIC8vICd2YWx1ZTEnXHJcbiAgICogZWxlbS5hdHRyKHtcclxuICAgKiAgIGF0dHIxOiAndmFsdWUzJywgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjEgc2V0IHRvICd2YWx1ZTMnXHJcbiAgICogICBhdHRyMjogJ3ZhbHVlMicgICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIyIHNldCB0byAndmFsdWUyJ1xyXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcclxuICAgKiBlbGVtLmF0dHIoKS4kOyAgICAgICAgICAgICAgICAvLyB7IGF0dHIxOiAndmFsdWUzJywgYXR0cjI6ICd2YWx1ZTInIH1cclxuICAgKi9cclxuICBhdHRyKGF0dHIsIHZhbHVlKSB7XHJcbiAgICBjb25zdCBlbGVtID0gZ2V0RWxlbSh0aGlzKTtcclxuXHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTdXBlcihlbGVtLmF0dHJpYnV0ZXMpLm9iamVjdCgobywgYXR0cikgPT4ge1xyXG4gICAgICAgIG9bYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcoYXR0cikpIHtcclxuICAgICAgY29uc3QgbnMgPSBhdHRyTlNTd2l0Y2hlcihhdHRyLCBbbmV3IEVsZW0oZWxlbSldKTtcclxuXHJcbiAgICAgIHJldHVybiBpc051bGwobnMpXHJcbiAgICAgICAgPyBlbGVtLmdldEF0dHJpYnV0ZShhdHRyKVxyXG4gICAgICAgIDogZWxlbS5nZXRBdHRyaWJ1dGVOUyhucywgYXR0cik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBhdHRyID0geyBbYXR0cl06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5ldyBTdXBlcihhdHRyKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZShuZXcgRWxlbShlbGVtKS5hdHRyKGtleSksIGVsZW0sIGluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVBdHRyKGtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBucyA9IGF0dHJOU1N3aXRjaGVyKGtleSwgW25ldyBFbGVtKGVsZW0pXSk7XHJcblxyXG4gICAgICAgIGlmIChpc051bGwobnMpKSB7XHJcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGVOUyhucywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2Jsb2JcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zID0ge31dIC0gT3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgaW50byB7QGxpbmsgYmxvYn0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEJsb2JPYmplY3Q+fSBOZXcgaW5zdGFuY2Ugb2YgcHJvbWlzZS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHtAbGluayBCbG9iT2JqZWN0fSBQcm9taXNlLiBXb3JrcyB3aXRoIGltYWdlIG9yIGNhbnZhcyBmaXJzdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBpbWFnZS5ibG9iKCkudGhlbigoYmxvYikgPT4gY29uc29sZS5sb2coYmxvYikpOyAgLy8gQmxvYk9iamVjdFxyXG4gICAqIGNhbnZhcy5ibG9iKCkudGhlbigoYmxvYikgPT4gY29uc29sZS5sb2coYmxvYikpOyAvLyBCbG9iT2JqZWN0XHJcbiAgICovXHJcbiAgYmxvYihvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmZpcnN0KCk7XHJcbiAgICAgIGNvbnN0IHsgbmFtZSB9ID0gZWxlbTtcclxuXHJcbiAgICAgIGlmIChuYW1lICE9PSAnaW1nJyAmJiBuYW1lICE9PSAnY2FudmFzJykge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBpc25cXCd0IGFuIGltYWdlIG9yIGEgY2FudmFzISAoRWxlbSNibG9iKScpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5hbWUgPT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZWxlbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1cclxuICAgICAgICAubG9hZCgpXHJcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGVsZW0uaXNCcm9rZW4oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVGhlIGltYWdlIGlzIGJyb2tlbiEgKEVsZW0jYmxvYiknKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQpLmNhbnZhcygpO1xyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBlbGVtLndpZHRoKCk7XHJcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBlbGVtLmhlaWdodCgpO1xyXG5cclxuICAgICAgICAgIGNhbnZhc1xyXG4gICAgICAgICAgICAud2lkdGgod2lkdGgpXHJcbiAgICAgICAgICAgIC5oZWlnaHQoaGVpZ2h0KVxyXG4gICAgICAgICAgICAuZHJhd0ltYWdlKGVsZW0uJFswXSwgMCwgMCk7XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShjYW52YXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkudGhlbigoY2FudmFzKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMuZGF0YVVSTCgpO1xyXG4gICAgICBjb25zdCBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJMLnNwbGl0KCcsJylbMV0pO1xyXG4gICAgICBjb25zdCBsZW5ndGggPSBieXRlU3RyaW5nLmxlbmd0aDtcclxuICAgICAgY29uc3QgYWIgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcclxuICAgICAgY29uc3QgaWEgPSBuZXcgVWludDhBcnJheShhYik7XHJcblxyXG4gICAgICB0aW1lcyhsZW5ndGgsIChpKSA9PiB7XHJcbiAgICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGJsb2IoYWIsIG9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jYmx1clxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvYmx1clxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtIVE1MRWxlbWVudCNibHVyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvYmx1cn0uXHJcbiAgICovXHJcbiAgYmx1cigpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIGVsZW0uYmx1cigpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjYWxjQ1NTXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwc2V1ZG9dIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93L2dldENvbXB1dGVkU3R5bGVcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbZ2V0Q29tcHV0ZWRTdHlsZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL1dpbmRvdy9nZXRDb21wdXRlZFN0eWxlfS5cclxuICAgKiBSZXR1cm5zIGNvbXB1dGVkIHN0eWxlIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IG9yIHVuZGVmaW5lZC5cclxuICAgKi9cclxuICBjYWxjQ1NTKHBzZXVkbyA9IG51bGwpIHtcclxuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGdldEVsZW0odGhpcyksIHBzZXVkbyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY2hhbmdlUnVsZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAgICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gc3R5bGUgLSBTdHlsZSBmb3IgdGhlIHNlbGVjdG9yLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY2hhbmdpbmcgY3NzIHN0eWxlcyBpbiB0aGUgZmlyc3Qgc3R5bGUgdGFnIGluIHRoZSBzZXQuXHJcbiAgICogTm90ZTogc3R5bGUgZWxlbWVudCBzaG91bGQgYmUgaW5zaWRlIHRoZSBkb2N1bWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogc3R5bGUuY2hhbmdlUnVsZSgnaW1nLXNpemUnLCB7XHJcbiAgICogICB3aWR0aDogJzUwcHggIWltcG9ydGFudCcsXHJcbiAgICogICBoZWlnaHQ6ICc1MHB4ICFpbXBvcnRhbnQnXHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgY2hhbmdlUnVsZShuYW1lLCBzdHlsZSkge1xyXG4gICAgdGhpcy5zb21lKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChnZXROYW1lKGVsZW0pID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogcnVsZSB9ID0gbmV3IEFycihlbGVtLnNoZWV0LmNzc1J1bGVzKS5maW5kKChydWxlKSA9PiBydWxlLmR3YXluZURhdGEgJiYgcnVsZS5kd2F5bmVEYXRhLm5hbWUgPT09IG5hbWUpIHx8IHt9O1xyXG5cclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgbmV3IEVsZW0ocnVsZSkuY3NzKHN0eWxlKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2NoaWxkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xFbGVtfEVsZW1lbnR8RWxlbWVudFtdfSBlbGVtZW50IC0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyIGEgd3JhcCBvZiB0aGUgc2V0IG9mIHRoZSBjaGlsZHJlblxyXG4gICAqIG9mIHRoaXMgaW5kZXggb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQgb3RoZXJ3aXNlIGFuIGVsZW1lbnQgdG8gcHV0IGludG8gdGhpcyBlbGVtZW50LCBhIGNvbGxlY3Rpb25cclxuICAgKiBvciBhIHNlbGVjdG9yIG9mIGl0LlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSB0aGV5IGFyZSBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgYSB3cmFwIG9mIGNoaWxkcmVuIG9yIGluc2VydGVkIGVsZW1lbnRzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xyXG4gICAqIFtOb2RlI2FwcGVuZENoaWxkXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9hcHBlbmRDaGlsZH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGNoaWxkID0gZWxlbS5jaGlsZCgxKTtcclxuICAgKlxyXG4gICAqIGVsZW0uY2hpbGQoZWxlbTIpO1xyXG4gICAqIGVsZW0uY2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xyXG4gICAqIGVsZW0uY2hpbGQoJyNpZCBkaXYuYzEnKTtcclxuICAgKi9cclxuICBjaGlsZChlbGVtZW50LCBlbmQgPSB0cnVlKSB7XHJcbiAgICBpZiAoaXNJbnRlZ2VyKGVsZW1lbnQpICYmIGVsZW1lbnQgPj0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbigpLmVsZW0oZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRvRmluZChlbGVtZW50KS5pbnRvKHRoaXMsIGVuZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY2hpbGRyZW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IEQtV3JhcCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGVsZW1lbnQncyBjaGlsZHJlbi5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgY2hpbGRyZW4gPSBlbGVtLmNoaWxkcmVuKCk7XHJcbiAgICovXHJcbiAgY2hpbGRyZW4oKSB7XHJcbiAgICByZXR1cm4gbmV3IEVsZW0odGhpcy5sZW5ndGggPyB0aGlzLiRbMF0uY2hpbGROb2RlcyA6IFtdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjbGFzc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2Nsc10gLSBJZiBpdCdzIHByZXNlbnQgaXQgaGFzIHRvIGNvbnRhaW4gY2xhc3MgYXR0cmlidXRlIHRvIHNldC5cclxuICAgKiBAcmV0dXJucyB7QXJyfEVsZW19IElmIHRoZSBhcmd1bWVudCBpcyBwcmVzZW50IHRoaXMgcmV0dXJuZWQgb3RoZXJ3aXNlIGEgd3JhcCBvZiB0aGUgY2xhc3NlcyBhcnJheSByZXR1cm5lZC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgY2xhc3Nlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jbGFzcygnYzEgYzInKTsgLy8gY2xhc3Mgc2V0IHRvICdjMSBjMidcclxuICAgKiBlbGVtLmNsYXNzKCkuJDsgICAgICAvLyBbJ2MxJywgJ2MyJ11cclxuICAgKi9cclxuICBjbGFzcyhjbHMpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbmV3IEFycihnZXRFbGVtKHRoaXMpLmNsYXNzTmFtZS5zcGxpdCgnICcpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNscztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY2xpY2tcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2NsaWNrXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0hUTUxFbGVtZW50I2NsaWNrXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvY2xpY2t9LlxyXG4gICAqL1xyXG4gIGNsaWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgZWxlbS5jbGljaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjbG9uZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2RlZXAgPSBmYWxzZV0gLSBTZWUgdGhlZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2Nsb25lTm9kZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtOb2RlI2Nsb25lTm9kZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvY2xvbmVOb2RlfS5cclxuICAgKi9cclxuICBjbG9uZShkZWVwID0gZmFsc2UpIHtcclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgZWxlbXMuYWRkKGVsZW0uY2xvbmVOb2RlKCEhZGVlcCkpO1xyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY2xvc2VzdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0VsZW19IFNldCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50cy5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbRWxlbWVudCNjbG9zZXN0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0fS5cclxuICAgKi9cclxuICBjbG9zZXN0KHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XHJcbiAgICAgIHdoaWxlIChlbGVtKSB7XHJcbiAgICAgICAgaWYgKG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW1zLmFkZChlbGVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgIH1cclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2NvbnRhaW5zXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gZmluZCBvdXQgaWYgaXQncyB3aXRoaW4gdGhlIGZpcnN0IGVsZW1lbnRcclxuICAgKiBpbiB0aGUgc2V0IG9yIGEgc2VsZWN0b3Igb2YgaXQuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgaWYgdGhlIGFyZ3VtZW50IHdpdGhpbiB0aGlzIGVsZW1lbnQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBleHRlbnNpb24gZm9yXHJcbiAgICogW05vZGUjY29udGFpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbnRhaW5zfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbTEuY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcclxuICAgKiBlbGVtLmNvbnRhaW5zKHNlbGVjdG9yKTsgLy8gdHJ1ZXxmYWxzZVxyXG4gICAqL1xyXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQgPSB0b0ZpbmQoZWxlbWVudCk7XHJcblxyXG4gICAgcmV0dXJuIGdldEVsZW0odGhpcykuY29udGFpbnMoZ2V0RWxlbShlbGVtZW50KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXHJcbiAgICogSWYgdHlwZSBpcyBcIiNjb21tZW50XCIgYSBjb21tZW50IG5vZGUgaXMgY3JlYXRlZC5cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zIC0gU3RyaW5ncyB0aGF0IGFyZSBwYXNzZWQgaW50byB7QGxpbmsgRWxlbSNhcHBseX0uXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCBlbGVtZW50cy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBlbGVtZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxyXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgZWxlbWVudCBpcyBqdXN0IGNyZWF0ZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnLCAnI2lkIC5jMSAuYzIgKlNvbWUgdGV4dConKTtcclxuICAgKlxyXG4gICAqIC8vIGFsc28gdGhlcmUgYXJlIHNob3J0aGFuZHMgZm9yIGFsbW9zdCBldmVyeSBIVE1MLWVsZW1lbnRcclxuICAgKiBlbGVtLmRpdigpO1xyXG4gICAqIGVsZW0uaW5wdXQoJyR0eXBlKGNoZWNrYm94KSAkbmFtZShjb3VudHJ5KScpO1xyXG4gICAqL1xyXG4gIGNyZWF0ZSh0eXBlLCAuLi5hcHBsaWVkRXhwcmVzc2lvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBFbGVtKHR5cGVTd2l0Y2hlcih0eXBlLCBbbmV3IEVsZW0oZWxlbSldKSk7XHJcblxyXG4gICAgICBlbGVtZW50LmludG8oZWxlbSk7XHJcblxyXG4gICAgICBlbGVtcy5hZGQoZWxlbWVudC5hcHBseS5hcHBseShlbGVtZW50LCBhcHBsaWVkRXhwcmVzc2lvbnMpKTtcclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZUNvbW1lbnRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBjb21tZW50LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSAtIHdyYXAgb2YgdGhlIGNyZWF0ZWQgY29tbWVudHMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY3JlYXRpbmcgY29tbWVudHMgaW5zaWRlIHRoaXMgZWxlbWVudC5cclxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGNvbW1lbnQgaXMganVzdCBjcmVhdGVkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmNyZWF0ZUNvbW1lbnQoJ2NvbW1lbnQnKTtcclxuICAgKi9cclxuICBjcmVhdGVDb21tZW50KHRleHQpIHtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgICAgIC5jcmVhdGUoJyNjb21tZW50JylcclxuICAgICAgLnRleHQodGV4dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlVGV4dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRleHQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCB0ZXh0IG5vZGVzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIHRleHQgbm9kZXMgaW5zaWRlIHRoaXMgZWxlbWVudC5cclxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIHRleHQgbm9kZSBpcyBqdXN0IGNyZWF0ZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uY3JlYXRlVGV4dCgndGV4dCcpO1xyXG4gICAqL1xyXG4gIGNyZWF0ZVRleHQodGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLmNyZWF0ZSgnI3RleHQnKVxyXG4gICAgICAudGV4dCh0ZXh0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjc3NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZ3xFbGVtVmFsdWVDYWxsYmFjaz59IFtwcm9wZXJ0eV0gLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQgb3JcclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFtwcm9wZXJ0eV06IHZhbHVlLCAuLi4gfSB0byBzZXQgc3R5bGVzLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cclxuICAgKiBAcmV0dXJucyB7U3VwZXJ8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBjc3Mgc3R5bGVzIG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxyXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIHN0eWxlcy4gU3VwcG9ydHMgIWltcG9ydGFudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpOyAvLyBkaXNwbGF5IHNldCB0byAnbm9uZScgYW5kIHRoaXMgcmV0dXJuZWRcclxuICAgKiBlbGVtLmNzcygnZGlzcGxheScpOyAgICAgICAgIC8vICdub25lJ1xyXG4gICAqIGVsZW0uY3NzKHtcclxuICAgKiAgIGRpc3BsYXk6ICdpbmxpbmUnLCAgICAgICAgIC8vIGRpc3BsYXkgc2V0IHRvICdpbmxpbmUnXHJcbiAgICogICBjdXJzb3I6ICdwb2ludGVyJyAgICAgICAgICAvLyBjdXJzb3Igc2V0IHRvICdwb2ludGVyJ1xyXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxyXG4gICAqIGVsZW0uY3NzKCkuJDsgICAgICAgICAgICAgICAgLy8geyBkaXNwbGF5OiAnbm9uZScsIGN1cnNvcjogJ3BvaW50ZXInIH1cclxuICAgKi9cclxuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICBsZXQgc3R5bGUgPSBnZXRFbGVtKHRoaXMpLnN0eWxlO1xyXG5cclxuICAgIGlmIChpc1N0eWxlUnVsZSh0aGlzLiRbMF0pKSB7XHJcbiAgICAgIHN0eWxlID0gdGhpcy4kWzBdLnN0eWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbmV3IFN0cihzdHlsZS5jc3NUZXh0KVxyXG4gICAgICAgIC5zcGxpdCgvOyA/LylcclxuICAgICAgICAub2JqZWN0KChvLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5ID0gdmFsdWUuc3BsaXQoLzogLyk7XHJcblxyXG4gICAgICAgICAgICBvW25ldyBTdHIocHJvcGVydHlbMF0pLnRvQ2FtZWxDYXNlKCkuJF0gPSBwcm9wZXJ0eVsxXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xyXG4gICAgICBwcm9wZXJ0eSA9IG5ldyBTdHIocHJvcGVydHkpLnRvSHlwaGVuQ2FzZSgpLiQ7XHJcblxyXG4gICAgICByZXR1cm4gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgKyAoc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwcm9wZXJ0eSkgPyAnICFpbXBvcnRhbnQnIDogJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkgJiYgIWlzU3R5bGVSdWxlKGVsZW0pKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuZXcgU3VwZXIocHJvcGVydHkpLmZvckVhY2goKHZhbHVlLCBwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvcGVydHkgPSBuZXcgU3RyKHByb3BlcnR5KS50b0h5cGhlbkNhc2UoKS4kO1xyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgIHZhbHVlID0gdmFsdWUobmV3IEVsZW0oZWxlbSkuY3NzKHByb3BlcnR5KSwgZWxlbSwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xyXG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXHJcbiAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgIHZhbHVlLnJlcGxhY2UoLyA/IWltcG9ydGFudCQvLCAnJyksXHJcbiAgICAgICAgICAvIWltcG9ydGFudCQvLnRlc3QodmFsdWUpID8gJ2ltcG9ydGFudCcgOiAnJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY3R4XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxDdHhDYWxsYmFja30gW3Byb3BlcnR5XSAtIElmIHByZXNlbnQgYW5kIG9iamVjdFxyXG4gICAqIGl0J3MgYXNzaWduZWQgdG8gdGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dCwgaWYgZnVuY3Rpb25cclxuICAgKiBpdCdzIGNhbGxlZCB3aXRoIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dCBhcmd1bWVudCwgaWYgc3RyaW5nXHJcbiAgICogdGhlIHZhbHVlIGZyb20gdGhlIHNlY29uZCBhcmd1bWVudCBpcyB1c2VkIGZvciBhc3NpZ25pbmdcclxuICAgKiB0aGlzIHByb3BlcnR5IHRvIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dCBhbmQgaWYgbm90IHByZXNlbnRcclxuICAgKiBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHQgcmV0dXJuZWQuXHJcbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gU2VlIHRoZSBwcm9wZXJ0eSBhcmd1bWVudC5cclxuICAgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfEVsZW19XHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBmaXJzdCBjYW52YXMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY2FudmFzLmN0eDsgLy8gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICovXHJcbiAgY3R4KHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgbGV0IGN0eDtcclxuXHJcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgY3R4ID0gZWxlbS5kd2F5bmVEYXRhLmN0eDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gY3R4O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY3R4KSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Z1bmN0aW9uKHByb3BlcnR5KSkge1xyXG4gICAgICBwcm9wZXJ0eShjdHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhc3NpZ24oY3R4LCBwcm9wZXJ0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZGF0YVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrPn0gW2tleV0gLSBOYW1lIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSAod2l0aG91dCBkYXRhLSBwcmVmaXgpXHJcbiAgICogdG8gZ2V0IG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW2F0dHJOYW1lXTogdmFsdWUsIC4uLiB9IHRvIHNldCBhdHRyaWJ1dGVzLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXHJcbiAgICogQHJldHVybnMge1N1cGVyfFN0cmluZ3xFbGVtfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkLCBELVdyYXAgb2YgZGF0YXNldCBvZiB0aGUgZWxlbWVudCByZXR1cm5lZCxcclxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBkYXRhIGF0dHJpYnV0ZXMuIFNlZVxyXG4gICAqIFtIVE1MRWxlbWVudCNkYXRhc2V0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvZGF0YXNldH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnLCAndmFsdWUnKTsgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkxIHNldCB0byAndmFsdWUxJyBhbmQgdGhpcyByZXR1cm5lZFxyXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnKTsgICAgICAgICAgLy8gJ3ZhbHVlMSdcclxuICAgKiBlbGVtLmRhdGEoe1xyXG4gICAqICAgc29tZUtleTE6ICd2YWx1ZTMnLCAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkxIHNldCB0byAndmFsdWUzJ1xyXG4gICAqICAgc29tZUtleTI6ICd2YWx1ZTInICAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkyIHNldCB0byAndmFsdWUyJ1xyXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxyXG4gICAqIGVsZW0uZGF0YSgpLiQ7ICAgICAgICAgICAgICAgICAgLy8geyBzb21lS2V5MTogJ3ZhbHVlMycsIHNvbWVLZXkyOiAndmFsdWUyJyB9XHJcbiAgICovXHJcbiAgZGF0YShrZXksIHZhbHVlKSB7XHJcbiAgICBjb25zdCBkYXRhc2V0ID0gZ2V0RWxlbSh0aGlzKS5kYXRhc2V0O1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbmV3IFN1cGVyKGRhdGFzZXQpLm9iamVjdCgobywgdmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XHJcbiAgICAgIHJldHVybiBkYXRhc2V0W2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBrZXkgPSB7IFtrZXldOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmICghaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpdGVyYXRlKGtleSwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICBlbGVtLmRhdGFzZXRba2V5XSA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUoZWxlbS5kYXRhc2V0W2tleV0sIGVsZW0sIGluZGV4KSA6IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2RhdGFVUkxcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGUgPSAnaW1hZ2UvcG5nJ10gLSBTZWUgdGhlIGxpbmtcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuY29kZXJPcHRpb25zID0gMC45Ml0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gRGF0YSBVUkwgZm9yIHRoZSBmaXJzdCBjYW52YXMgZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtIVE1MQ2FudmFzRWxlbWVudCN0b0RhdGFVUkxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC90b0RhdGFVUkx9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjYW52YXMuZGF0YVVSTCgpO1xyXG4gICAqL1xyXG4gIGRhdGFVUkwodHlwZSwgZW5jb2Rlck9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4KCk7XHJcblxyXG4gICAgaWYgKCFjdHgpIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdHguY2FudmFzLnRvRGF0YVVSTC5hcHBseShjdHguY2FudmFzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2RlbGV0ZVJ1bGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBydWxlLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVsZXRpbmcgY3NzIHN0eWxlcyBpbiBhIHN0eWxlIHRhZy5cclxuICAgKiBOb3RlOiBzdHlsZSBlbGVtZW50IHNob3VsZCBiZSBpbnNpZGUgdGhlIGRvY3VtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBzdHlsZS5kZWxldGVSdWxlKCdpbWctc2l6ZScpO1xyXG4gICAqL1xyXG4gIGRlbGV0ZVJ1bGUobmFtZSkge1xyXG4gICAgdGhpcy5zb21lKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChnZXROYW1lKGVsZW0pID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IG5ldyBBcnIoZWxlbS5zaGVldC5jc3NSdWxlcykuZmluZCgocnVsZSkgPT4gcnVsZS5kd2F5bmVEYXRhICYmIHJ1bGUuZHdheW5lRGF0YS5uYW1lID09PSBuYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgIGVsZW0uc2hlZXQuZGVsZXRlUnVsZShydWxlLmtleSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNkaXNwYXRjaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudH0gZXZlbnQgLSBFdmVudCBvciBhIHN0cmluZyAobmV3IEV2ZW50KGV2ZW50KSBpcyBjcmVhdGVkKS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50SW5pdCA9IHt9XSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtldmVudEluaXQuYnViYmxlcyA9IHRydWVdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2V2ZW50SW5pdC5jYW5jZWxhYmxlID0gdHJ1ZV0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnQvRXZlbnRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbRXZlbnRUYXJnZXQjZGlzcGF0Y2hFdmVudF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2Rpc3BhdGNoRXZlbnR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmRpc3BhdGNoKCdjbGljaycpO1xyXG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJywgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsbGFibGU6IGZhbHNlIH0pO1xyXG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQsIGV2ZW50SW5pdCA9IHt9LCBkZXRhaWxzID0ge30pIHtcclxuICAgIGNvbnN0IHsgYnViYmxlcyA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlIH0gPSBldmVudEluaXQgfHwge307XHJcbiAgICBsZXQgZmluYWxFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIGlmICghL0V2ZW50JC8udGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmaW5hbEV2ZW50ID0gbmV3IEV2ZW50KGZpbmFsRXZlbnQsIHsgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgZmluYWxFdmVudCA9IG5hdGl2ZURvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG4gICAgICAgIGZpbmFsRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCBidWJibGVzLCBjYW5jZWxhYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXNzaWduKGZpbmFsRXZlbnQsIGRldGFpbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChmaW5hbEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZWxlbVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4ID0gMF0gLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvZiB0aGUgc2V0IHRvIGdldC4gTmVnYXRpdmUgaW5kZXggbWVhbnMgZWxlbS5sZW5ndGggKyBpbmRleC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uZWxlbSgxKTsgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMVxyXG4gICAqIGVsZW0uZWxlbSgpOyAgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMFxyXG4gICAqL1xyXG4gIGVsZW0oaW5kZXggPSAwKSB7XHJcbiAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggKyBpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IEVsZW0odGhpcy4kW2luZGV4XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZmlsdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufEVsZW1lbnRbXXxFbGVtfSBbc2VsZWN0b3IgPSBCb29sZWFuXSAtIElmIGl0J3MgYSBzdHJpbmcgdGhlIG1ldGhvZCBmaWx0ZXJzIGVsZW1lbnRzIHdpdGggdGhlIHNlbGVjdG9yXHJcbiAgICogb3RoZXJ3aXNlIHN1cGVyLmZpbHRlciBpcyBjYWxsZWQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbHRlcmluZyBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5maWx0ZXIoKGVsZW0pID0+IG5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJy5wYXJlbnQnKSk7XHJcbiAgICogZWxlbS5maWx0ZXIoZWxlbXNJbkFycmF5KTtcclxuICAgKiBlbGVtLmZpbHRlcihlbGVtc0luRWxlbSk7XHJcbiAgICogZWxlbS5maWx0ZXIoJy5jaGlsZCcpO1xyXG4gICAqL1xyXG4gIGZpbHRlcihzZWxlY3RvciA9IEJvb2xlYW4pIHtcclxuICAgIHJldHVybiBuZXcgRWxlbShzdXBlci5maWx0ZXIoZmlsdGVyU3dpdGNoZXIoc2VsZWN0b3IpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZmluZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBmaW5kLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfHsga2V5OiBLZXksIHZhbHVlOiAqIH18bnVsbH0gTmV3IGluc3RhbmNlIG9mIEVsZW0gaWYgc2VsZWN0b3IgaXMgYSBzdHJpbmdcclxuICAgKiBvdGhlcndpc2Ugc3VwZXIuZmluZCBpcyBjYWxsZWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0VsZW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXHJcbiAgICovXHJcbiAgZmluZChzZWxlY3Rvcikge1xyXG4gICAgaWYgKCFpc1N0cmluZyhzZWxlY3RvcikpIHtcclxuICAgICAgcmV0dXJuIHN1cGVyLmZpbmQoc2VsZWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgZWxlbXMuYWRkKGZpbmQoc2VsZWN0b3IsIGVsZW0pKTtcclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2ZpcnN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgZWxlbS5lbGVtKDApLlxyXG4gICAqL1xyXG4gIGZpcnN0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbSgwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNmaXJzdENoaWxkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3IgPSBudWxsXSAtIElmIHByZXNlbnQsIGZpbmRzIGZpcnN0IGNoaWxkIGluIGV2ZXJ5IGVsZW0gdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cclxuICAgKiBJZiBub3QsIGZpbmRzIGZpcnN0IGNoaWxkIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIGZpcnN0IGNoaWxkcmVuIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmZpcnN0KCk7ICAgICAgIC8vIGZpbmRzIGZpcnN0IGNoaWxkIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgZWxlbSBzZXRcclxuICAgKiBlbGVtLmZpcnN0KCcuZm9vJyk7IC8vIGZpbmQgZmlyc3QgY2hpbGQgdGhhdCBoYXMgZm9vIGNsYXNzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XHJcbiAgICovXHJcbiAgZmlyc3RDaGlsZChzZWxlY3RvciA9IG51bGwpIHtcclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgY29uc3QgeyB2YWx1ZTogZm91bmQgfSA9IG5ldyBFbGVtKGVsZW0pXHJcbiAgICAgICAgLmNoaWxkcmVuKClcclxuICAgICAgICAuZmluZCgoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB8fCB7fTtcclxuXHJcbiAgICAgIGVsZW1zLmFkZChmb3VuZCk7XHJcbiAgICB9LCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNmb2N1c1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvZm9jdXNcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbSFRNTEVsZW1lbnQjZm9jdXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9mb2N1c30uXHJcbiAgICovXHJcbiAgZm9jdXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICBlbGVtLmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2dldFJ1bGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBydWxlLlxyXG4gICAqIEByZXR1cm5zIHt7IHNlbGVjdG9yOiAoU3RyaW5nfHZvaWQpLCBydWxlczogT2JqZWN0IH19IFNldCBvZiB0aGUgY3NzIHJ1bGVzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgc2V0IG9mIHRoZSBydWxlcyB1bmRlciB0aGUgbmFtZS5cclxuICAgKiBOb3RlOiBzdHlsZSBlbGVtZW50IHNob3VsZCBiZSBpbnNpZGUgdGhlIGRvY3VtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBzdHlsZS5hZGRSdWxlKCdpbWctc2l6ZScsICdpbWcuc3F1YXJlJywge1xyXG4gICAqICAgd2lkdGg6ICc0MHB4JyxcclxuICAgKiAgIGhlaWdodDogJzQwcHgnXHJcbiAgICogfSk7XHJcbiAgICogc3R5bGUuZ2V0UnVsZSgnaW1nLXNpemUnKTtcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICBzZWxlY3RvcjogJ2ltZy5zcXVhcmUnLFxyXG4gICAqIC8vICAgcnVsZXM6IHtcclxuICAgKiAvLyAgICAgd2lkdGg6ICc0MHB4JyxcclxuICAgKiAvLyAgICAgaGVpZ2h0OiAnNDBweCdcclxuICAgKiAvLyAgIH1cclxuICAgKiAvLyB9XHJcbiAgICovXHJcbiAgZ2V0UnVsZShuYW1lKSB7XHJcbiAgICBsZXQgZm91bmQgPSB7XHJcbiAgICAgIHNlbGVjdG9yOiB1bmRlZmluZWQsXHJcbiAgICAgIHJ1bGVzOiB7fVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBydWxlIH0gPSBuZXcgQXJyKGVsZW0uc2hlZXQuY3NzUnVsZXMpLmZpbmQoKHJ1bGUpID0+IHJ1bGUuZHdheW5lRGF0YSAmJiBydWxlLmR3YXluZURhdGEubmFtZSA9PT0gbmFtZSkgfHwge307XHJcblxyXG4gICAgICAgIGlmIChydWxlKSB7XHJcbiAgICAgICAgICBmb3VuZCA9IHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6IHJ1bGUuc2VsZWN0b3JUZXh0LFxyXG4gICAgICAgICAgICBydWxlczogbmV3IEVsZW0ocnVsZSkuY3NzKCkuJFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBmb3VuZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNoYXNBdHRyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgYXR0cmlidXRlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmF0dHIoJ2F0dHInLCAndmFsdWUnKS5oYXNBdHRyKCdhdHRyJyk7IC8vIHRydWVcclxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2F0dHInKS5oYXNBdHRyKCdhdHRyJyk7ICAgIC8vIGZhbHNlXHJcbiAgICovXHJcbiAgaGFzQXR0cihhdHRyKSB7XHJcbiAgICBjb25zdCBlbGVtID0gZ2V0RWxlbSh0aGlzKTtcclxuICAgIGNvbnN0IG5zID0gYXR0ck5TU3dpdGNoZXIoYXR0ciwgW25ldyBFbGVtKGVsZW0pXSk7XHJcblxyXG4gICAgcmV0dXJuIGlzTnVsbChucylcclxuICAgICAgPyBlbGVtLmhhc0F0dHJpYnV0ZShhdHRyKVxyXG4gICAgICA6IGVsZW0uaGFzQXR0cmlidXRlTlMobnMsIGF0dHIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2hhc0NsYXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBOYW1lIG9mIHRoZSBjbGFzcy5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGNsYXNzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcyBvciBub3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgICAgLy8gdHJ1ZVxyXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgLy8gZmFsc2VcclxuICAgKi9cclxuICBoYXNDbGFzcyhjbHMpIHtcclxuICAgIHJldHVybiBnZXRFbGVtKHRoaXMpLmNsYXNzTGlzdC5jb250YWlucyhjbHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2hlaWdodFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp8RWxlbVZhbHVlQ2FsbGJhY2t9IFtoZWlnaHRdIC0gSGVpZ2h0IHRvIHNldC5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgaGVpZ2h0IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXHJcbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyBoZWlnaHRzIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgaGVpZ2h0IGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgaGVpZ2h0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmhlaWdodCgxMjMpO1xyXG4gICAqIGVsZW0uaGVpZ2h0KCk7IC8vIDEyM1xyXG4gICAqL1xyXG4gIGhlaWdodChoZWlnaHQpIHtcclxuICAgIHJldHVybiB0aGlzLnByb3AuYXBwbHkodGhpcywgbmV3IEFycihhcmd1bWVudHMpLnVuc2hpZnQoJ2hlaWdodCcpLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2hpZGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gSGlkZXMgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uaGlkZSgpO1xyXG4gICAqL1xyXG4gIGhpZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcclxuXHJcbiAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5ID0gZWxlbS5jc3MoJ2Rpc3BsYXknKTtcclxuXHJcbiAgICAgIGlmIChjdXJyZW50RGlzcGxheS5pbmRleE9mKCdub25lJykpIHtcclxuICAgICAgICBlbGVtLnByb3AoJ2R3YXluZURhdGEnKS5wcmV2aW91c0Rpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbS5jc3MoJ2Rpc3BsYXknLCAnbm9uZSAhaW1wb3J0YW50Jyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNodG1sXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfCp9IFtodG1sXSAtIEhUTUwgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IEhUTUwuXHJcbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIEhUTUwgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cclxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIEhUTUwgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSBodG1sIGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgSFRNTC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5odG1sKCc8ZGl2PjE8L2Rpdj4nKTtcclxuICAgKiBlbGVtLmh0bWwoKTsgLy8gJzxkaXY+MTwvZGl2PidcclxuICAgKi9cclxuICBodG1sKGh0bWwpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZ2V0RWxlbSh0aGlzKS5pbm5lckhUTUw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIGVsZW0uaW5uZXJIVE1MID0gaXNGdW5jdGlvbihodG1sKSA/IGh0bWwoZWxlbS5pbm5lckhUTUwsIGVsZW0sIGluZGV4KSA6IGh0bWw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2lkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFtpZF0gLSBJZCB0byBzZXQuXHJcbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIGlkIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXHJcbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyBpZHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSBpZCBhcmd1bWVudC5cclxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBpZCBvciBzZXRzIGlkcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5pZCgndW5pcXVlJyk7XHJcbiAgICogZWxlbS5pZCgpOyAvLyAndW5pcXVlJ1xyXG4gICAqL1xyXG4gIGlkKGlkKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGdldEVsZW0odGhpcykuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgZWxlbS5pZCA9IGlkO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge051bWJlcn0gRWxlbSNpbm5lckhlaWdodFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBHZXR0ZXIgZm9yIGZpbmRpbmcgaG93IG11Y2ggaGVpZ2h0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgY2FuIGJlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmNzcyh7XHJcbiAgICogICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgKiAgIGhlaWdodDogJzIwMHB4JyxcclxuICAgKiAgIHBhZGRpbmdUb3A6ICcycHgnLFxyXG4gICAqICAgcGFkZGluZ0JvdHRvbTogJzNweCcsXHJcbiAgICogICBib3JkZXJUb3A6ICcxcHggc29saWQgYmxhY2snLFxyXG4gICAqICAgYm9yZGVyQm90dG9tOiAnNHB4IHNvbGlkIGJsYWNrJ1xyXG4gICAqIH0pLmlubmVySGVpZ2h0OyAvLyAxOTBcclxuICAgKiBlbGVtXHJcbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ2NvbnRlbnQtYm94JylcclxuICAgKiAgIC5pbm5lckhlaWdodDsgLy8gMjAwXHJcbiAgICogZWxlbVxyXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdwYWRkaW5nLWJveCcpXHJcbiAgICogICAuaW5uZXJIZWlnaHQ7IC8vIDE5NVxyXG4gICAqL1xyXG4gIGdldCBpbm5lckhlaWdodCgpIHtcclxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLiRbMF07XHJcblxyXG4gICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XHJcbiAgICAgIHJldHVybiBlbGVtLmlubmVySGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgYm9yZGVyVG9wV2lkdGgsXHJcbiAgICAgIGJvcmRlckJvdHRvbVdpZHRoLFxyXG4gICAgICBib3hTaXppbmcsXHJcbiAgICAgIGhlaWdodCxcclxuICAgICAgcGFkZGluZ1RvcCxcclxuICAgICAgcGFkZGluZ0JvdHRvbVxyXG4gICAgfSA9IHRoaXMuY2FsY0NTUygpO1xyXG4gICAgY29uc3QgYm9yZGVycyA9IHB4KGJvcmRlclRvcFdpZHRoKSArIHB4KGJvcmRlckJvdHRvbVdpZHRoKTtcclxuICAgIGNvbnN0IHBhZGRpbmdzID0gcHgocGFkZGluZ1RvcCkgKyBweChwYWRkaW5nQm90dG9tKTtcclxuXHJcbiAgICByZXR1cm4gcHgoaGVpZ2h0KSAtIGlubmVyU3dpdGNoZXIoYm94U2l6aW5nLCBbcGFkZGluZ3MsIGJvcmRlcnNdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge051bWJlcn0gRWxlbSNpbm5lcldpZHRoXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIEdldHRlciBmb3IgZmluZGluZyBob3cgbXVjaCB3aWR0aCBjb250ZW50IG9mIHRoZSBmaXJzdCBlbGVtZW50IGNhbiBiZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jc3Moe1xyXG4gICAqICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICogICB3aWR0aDogJzIwMHB4JyxcclxuICAgKiAgIHBhZGRpbmdMZWZ0OiAnMnB4JyxcclxuICAgKiAgIHBhZGRpbmdSaWdodDogJzNweCcsXHJcbiAgICogICBib3JkZXJMZWZ0OiAnMXB4IHNvbGlkIGJsYWNrJyxcclxuICAgKiAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkIGJsYWNrJ1xyXG4gICAqIH0pLmlubmVyV2lkdGg7IC8vIDE5MFxyXG4gICAqIGVsZW1cclxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAnY29udGVudC1ib3gnKVxyXG4gICAqICAgLmlubmVyV2lkdGg7IC8vIDIwMFxyXG4gICAqIGVsZW1cclxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAncGFkZGluZy1ib3gnKVxyXG4gICAqICAgLmlubmVyV2lkdGg7IC8vIDE5NVxyXG4gICAqL1xyXG4gIGdldCBpbm5lcldpZHRoKCkge1xyXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuJFswXTtcclxuXHJcbiAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuICAgICAgcmV0dXJuIGVsZW0uaW5uZXJXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGJvcmRlckxlZnRXaWR0aCxcclxuICAgICAgYm9yZGVyUmlnaHRXaWR0aCxcclxuICAgICAgYm94U2l6aW5nLFxyXG4gICAgICBwYWRkaW5nTGVmdCxcclxuICAgICAgcGFkZGluZ1JpZ2h0LFxyXG4gICAgICB3aWR0aFxyXG4gICAgfSA9IHRoaXMuY2FsY0NTUygpO1xyXG4gICAgY29uc3QgYm9yZGVycyA9IHB4KGJvcmRlckxlZnRXaWR0aCkgKyBweChib3JkZXJSaWdodFdpZHRoKTtcclxuICAgIGNvbnN0IHBhZGRpbmdzID0gcHgocGFkZGluZ0xlZnQpICsgcHgocGFkZGluZ1JpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcHgod2lkdGgpIC0gaW5uZXJTd2l0Y2hlcihib3hTaXppbmcsIFtwYWRkaW5ncywgYm9yZGVyc10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEFmdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gaW5zZXJ0IHRoaXMgZWxlbWVudCBhZnRlciBvciBhIHNlbGVjdG9yIG9mIGl0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBhZnRlciB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50LlxyXG4gICAqIFRoZSBlbGVtZW50cyByZW1haW4gaW4gdGhlIHNhbWUgb3JkZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZWxlbTIpO1xyXG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xyXG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoJyNpZCBkaXYuYzEnKTtcclxuICAgKi9cclxuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50ID0gdG9GaW5kKGVsZW1lbnQpLmZpcnN0KCk7XHJcblxyXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKS4kWzBdO1xyXG4gICAgcGFyZW50ID0gcGFyZW50LiRbMF07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNpbnNlcnRCZWZvcmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGJlZm9yZSBvciBhIHNlbGVjdG9yIG9mIGl0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cclxuICAgKiBUaGUgZWxlbWVudHMgcmVtYWluIGluIHRoZSBzYW1lIG9yZGVyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmluc2VydEJlZm9yZShlbGVtMik7XHJcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xyXG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XHJcbiAgICovXHJcbiAgaW5zZXJ0QmVmb3JlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQgPSB0b0ZpbmQoZWxlbWVudCkuZmlyc3QoKTtcclxuXHJcbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcclxuXHJcbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudCA9IGVsZW1lbnQuJFswXTtcclxuICAgIHBhcmVudCA9IHBhcmVudC4kWzBdO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtLCBlbGVtZW50KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2ludG9cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBwdXQgdGhpcyBlbGVtZW50cyBpbnRvIG9yIGEgc2VsZWN0b3Igb2YgaXQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmQgLSBJZiB0aGUgZWxlbWVudHMgc2hvdWxkIGJlIGluc2VydGVkIHRvIHRoZSBlbmQuIElmIGZhbHNlIHRoZXkgYXJlIGluc2VydGVkIHRvIHRoZSBzdGFydC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xyXG4gICAqIFtOb2RlI2FwcGVuZENoaWxkXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9hcHBlbmRDaGlsZH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uaW50byhlbGVtMik7XHJcbiAgICogZWxlbS5pbnRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcclxuICAgKiBlbGVtLmludG8oJyNpZCBkaXYuYzEnKTtcclxuICAgKi9cclxuICBpbnRvKGVsZW1lbnQsIGVuZCA9IHRydWUpIHtcclxuICAgIGVsZW1lbnQgPSB0b0ZpbmQoZWxlbWVudCkuJFswXTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICFlbGVtZW50IHx8XHJcbiAgICAgIGlzV2luZG93KGVsZW1lbnQpIHx8XHJcbiAgICAgIGlzSFRNTERvY3VtZW50KGVsZW1lbnQpIHx8XHJcbiAgICAgIGlzQ29tbWVudE9yVGV4dChlbGVtZW50KVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIC5zbGljZSgpXHJcbiAgICAgICAgLnJldmVyc2UoKVxyXG4gICAgICAgIC5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShlbGVtLCBlbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2lzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxyXG4gICAqIElmIHRoZSBzZWxlY3RvciBpcyB1bmRlZmluZWQgb3IgbnVsbCBhbHdheXMgcmV0dXJucyB0cnVlLiBJZiBpdCdzIG5vdCBmb3Igbm90IGVsZW1lbnRzXHJcbiAgICogZW50cmllcyByZXR1cm5zIGZhbHNlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtFbGVtZW50I21hdGNoZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXN9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmFkZENsYXNzKCdjbHMnKTtcclxuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gdHJ1ZVxyXG4gICAqXHJcbiAgICogZWxlbS5yZW1vdmVDbGFzcygnY2xzJyk7XHJcbiAgICogZWxlbS5pcygnLmNscycpOyAgICAgICAgIC8vIGZhbHNlXHJcbiAgICovXHJcbiAgaXMoc2VsZWN0b3IpIHtcclxuICAgIGlmIChpc051bGwoc2VsZWN0b3IpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVsZW0gPSBnZXRFbGVtKHRoaXMpO1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IChcclxuICAgICAgZWxlbS5tYXRjaGVzIHx8XHJcbiAgICAgIGVsZW0ubWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgIGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgIGVsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgIGVsZW0ubXNNYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgZWxlbS5vTWF0Y2hlc1NlbGVjdG9yXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghaXNFbGVtZW50KHRoaXMuJFswXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwoZWxlbSwgc2VsZWN0b3IpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFNlbGVjdG9yICckeyBzZWxlY3RvciB9JyBpcyBub3QgYSB2YWxpZCBzZWxlY3RvciAoRWxlbSNpcylgKTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNpc0Jyb2tlblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGZpcnN0IGltYWdlIGluIHRoZSBzZXQgaXMgYnJva2VuLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgYnJva2VuLiBOb3QgaW1hZ2UgYW5kIG5vdCBsb2FkZWQgaW1hZ2UgaXMgY29uc2lkZXJlZCBwcm9wZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGltZyA9IGVsZW0uaW1nKCkub24oe1xyXG4gICAqICAgJ2xvYWQnOiBvbmxvYWQsXHJcbiAgICogICAnZXJyb3InOiBvbmxvYWRcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIG9ubG9hZCA9ICgpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKGltZy5pc0Jyb2tlbigpKTsgLy8gdHJ1ZVxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBpbWcucmVmKCcvc29tZS9ub24tZXhpc3RlbnQvc2l0ZS9ub3QtZm91bmQucG5nJyk7XHJcbiAgICovXHJcbiAgaXNCcm9rZW4oKSB7XHJcbiAgICBsZXQgaXNCcm9rZW4gPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdpbWcnKSB7XHJcbiAgICAgICAgaXNCcm9rZW4gPSAhIShlbGVtLmNvbXBsZXRlICYmICghZWxlbS5uYXR1cmFsV2lkdGggfHwgIWVsZW0ubmF0dXJhbEhlaWdodCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGlzQnJva2VuO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2lzV2l0aGluRG9jdW1lbnRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBpcyB3aXRoaW4gdGhlIGRvY3VtZW50IG9yIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGlzIHdpdGhpbiB0aGUgZG9jdW1lbnQgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRWxlbShkb2N1bWVudC5ib2R5KS5pc1dpdGhpbkRvY3VtZW50KCk7ICAvLyB0cnVlXHJcbiAgICogbmV3IEVsZW0oZG9jdW1lbnQpLmRpdigpLmlzV2l0aGluRG9jdW1lbnQoKTsgLy8gZmFsc2VcclxuICAgKi9cclxuICBpc1dpdGhpbkRvY3VtZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmlyc3QoKS5jbG9zZXN0KCdodG1sJykubGVuZ3RoICE9PSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2xhc3RcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBlbGVtLmVsZW0oLTEpLlxyXG4gICAqL1xyXG4gIGxhc3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbGVtKC0xKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNsYXN0Q2hpbGRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RvciA9IG51bGxdIC0gSWYgcHJlc2VudCwgZmluZHMgbGFzdCBjaGlsZCBpbiBldmVyeSBlbGVtIHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXHJcbiAgICogSWYgbm90LCBmaW5kcyBsYXN0IGNoaWxkIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIGxhc3QgY2hpbGRyZW4gb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ubGFzdCgpOyAgICAgICAvLyBmaW5kcyBsYXN0IGNoaWxkIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgZWxlbSBzZXRcclxuICAgKiBlbGVtLmxhc3QoJy5mb28nKTsgLy8gZmluZCBsYXN0IGNoaWxkIHRoYXQgaGFzICdmb28nIGNsYXNzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XHJcbiAgICovXHJcbiAgbGFzdENoaWxkKHNlbGVjdG9yID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCB7IHZhbHVlOiBmb3VuZCB9ID0gbmV3IEVsZW0oZWxlbSlcclxuICAgICAgICAuY2hpbGRyZW4oKVxyXG4gICAgICAgIC5yZXZlcnNlKClcclxuICAgICAgICAuZmluZCgoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB8fCB7fTtcclxuXHJcbiAgICAgIGVsZW1zLmFkZChmb3VuZCk7XHJcbiAgICB9LCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNsb2FkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjx7IHByb3BlcjogRWxlbSwgYnJva2VuOiBFbGVtIH0+fSBQcm9taXNlIHdpdGggYnJva2VuIGFuZCBwcm9wZXIgaW1hZ2VzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBMb2FkcyBlYWNoIGltYWdlIGluIHRoZSBzZXQgYW5kIHB1dHMgaXQgdG8gdGhlIHByb3BlciBvciBicm9rZW4gYXJyYXkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGltYWdlcy5sb2FkKCkudGhlbigoeyBicm9rZW4gfSkgPT4ge1xyXG4gICAqICAgYnJva2VuLmZpbHRlcignaW1nJykucmVmKCcvZmFsbGJhY2sucG5nJyk7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgbG9hZCgpIHtcclxuICAgIGNvbnN0IGltYWdlcyA9IHtcclxuICAgICAgcHJvcGVyOiBuZXcgRWxlbSgpLFxyXG4gICAgICBicm9rZW46IG5ldyBFbGVtKClcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxyXG4gICAgICB0aGlzXHJcbiAgICAgICAgLmZpbHRlcigoZWxlbSkgPT4gZ2V0TmFtZShlbGVtKSA9PT0gJ2ltZycpXHJcbiAgICAgICAgLm1hcCgoZWxlbSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgJGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcclxuXHJcbiAgICAgICAgICBpZiAoZWxlbS5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICBpbWFnZXNbJGVsZW0uaXNCcm9rZW4oKSA/ICdicm9rZW4nIDogJ3Byb3BlciddLnB1c2goZWxlbSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9ICRlbGVtLm9uKHtcclxuICAgICAgICAgICAgICBsb2FkKCkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLnByb3Blci5hZGQoZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBlcnJvcigpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlcy5icm9rZW4uYWRkKGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC4kXHJcbiAgICApLnRoZW4oKCkgPT4gaW1hZ2VzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNtb3ZlQXR0clxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byBtb3ZlIHRvIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWUgPSAnJ10gLSBWYWx1ZSB0byBzZXQgZm9yIHRoZSBhdHRyaWJ1dGUuIElmIG5vdCBzZXQgYXR0cmlidXRlIG9mIHRoZSBwcmV2aW91cyBlbGVtZW50IG9yICcnIHVzZWQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBtb3ZpbmcgYW4gYXR0cmlidXRlIGZyb20gcHJldmlvdXMgZWxlbWVudCB0byB0aGUgbmV4dCBvbmUgKGZpcnN0IGVsZW1lbnQgaW4gdGhpcyBzZXQpLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtMS5tb3ZlQXR0cignYXR0cicsICd2YWx1ZScpOyAgICAgLy8gYXR0cmlidXRlICdhdHRyJyBzZXQgdG8gJ3ZhbHVlJyBvbiBlbGVtMVxyXG4gICAqIGVsZW0yLm1vdmVBdHRyKCdhdHRyJyk7ICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgJ2F0dHInIHJlbW92ZWQgZnJvbSBlbGVtMS4gc2V0IHRvICd2YWx1ZScgb24gZWxlbTJcclxuICAgKiBlbGVtMy5tb3ZlQXR0cignYXR0cicsICduZXcgdmFsdWUnKTsgLy8gYXR0cmlidXRlICdhdHRyJyByZW1vdmVkIGZyb20gZWxlbTIuIHNldCB0byAnbmV3IHZhbHVlJyBvbiBlbGVtM1xyXG4gICAqL1xyXG4gIG1vdmVBdHRyKGF0dHIsIHZhbHVlID0gJycpIHtcclxuICAgIGNvbnN0IHByZXYgPSBhdHRyc1thdHRyXTtcclxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLmVsZW0oKTtcclxuXHJcbiAgICBpZiAocHJldiAmJiBlbGVtLmxlbmd0aCkge1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICB2YWx1ZSA9IHByZXYuYXR0cihhdHRyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJldi5yZW1vdmVBdHRyKGF0dHIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbGVtLmxlbmd0aCkge1xyXG4gICAgICBhdHRyc1thdHRyXSA9IGVsZW0uYXR0cihhdHRyLCB2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jbW92ZUNsYXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBDbGFzcyB0byBtb3ZlIHRvIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgbW92aW5nIGEgY2xhc3MgZnJvbSBwcmV2aW91cyBlbGVtZW50IHRvIHRoZSBuZXh0IG9uZSAoZmlyc3QgZWxlbWVudCBpbiB0aGlzIHNldCkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0xLm1vdmVDbGFzcygnY2xzJyk7IC8vIGNsYXNzICdjbHMnIGFkZGVkIHRvIGVsZW0xXHJcbiAgICogZWxlbTIubW92ZUNsYXNzKCdjbHMnKTsgLy8gY2xhc3MgJ2NscycgcmVtb3ZlZCBmcm9tIGVsZW0xLiBhZGRlZCB0byBlbGVtMVxyXG4gICAqL1xyXG4gIG1vdmVDbGFzcyhjbHMpIHtcclxuICAgIGNvbnN0IHByZXYgPSBjbGFzc2VzW2Nsc107XHJcbiAgICBjb25zdCBlbGVtID0gdGhpcy5lbGVtKCk7XHJcblxyXG4gICAgaWYgKHByZXYgJiYgZWxlbS5sZW5ndGgpIHtcclxuICAgICAgcHJldi5yZW1vdmVDbGFzcyhjbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbGVtLmxlbmd0aCkge1xyXG4gICAgICBjbGFzc2VzW2Nsc10gPSBlbGVtLmFkZENsYXNzKGNscyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEVsZW0jbmFtZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBub2RlTmFtZSAobG93ZXJjYXNlZCkgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZWxlbTEgPSBlbGVtLmNyZWF0ZSgnZGl2Jyk7XHJcbiAgICogZWxlbTEubmFtZSAvLyAnZGl2J1xyXG4gICAqL1xyXG4gIGdldCBuYW1lKCkge1xyXG4gICAgcmV0dXJuIGdldE5hbWUodGhpcy4kWzBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNuZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3IgPSBudWxsXSAtIElmIHByZXNlbnQsIGZpbmRzIG5leHQgZWxlbWVudCB0byBldmVyeSBlbGVtIHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXHJcbiAgICogSWYgbm90LCBmaW5kcyBuZXh0IGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLm5leHQoKTsgICAgICAgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XHJcbiAgICogZWxlbS5uZXh0KCcuZm9vJyk7IC8vIGZpbmRzIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgdGhhdCBoYXMgJ2ZvbycgY2xhc3NcclxuICAgKi9cclxuICBuZXh0KHNlbGVjdG9yID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICAvKiBlc2xpbnQgbm8tY29uZC1hc3NpZ246IDAgKi9cclxuICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgaWYgKG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW1zLmFkZChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI29mZlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLkVsZW1FdmVudFN0cmluZ30gZXZlbnRzIC0gRXZlbnRzIHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZW1vdmVzIGFsbCB0aGUgbGlzdGVuZXJzIGZyb20gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgc3BlY2lmaWVkIGJ5IHRoZSBldmVudHMgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLm9mZignY2xpY2snKTtcclxuICAgKiBlbGVtLm9mZignY2xpY2ssIGlucHV0Jyk7XHJcbiAgICogZWxlbS5vZmYoJ2NsaWNrLCBpbnB1dCcsICdmb2N1cycpO1xyXG4gICAqL1xyXG4gIG9mZiguLi5ldmVudHMpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgY29uc3QgeyBsaXN0ZW5lcnMgfSA9IGVsZW0uZHdheW5lRGF0YTtcclxuXHJcbiAgICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcclxuICAgICAgICBpdGVyYXRlKGV2ZW50LnNwbGl0KGV2ZW50U2VwYXJhdG9yKSwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAobGlzdGVuZXJzW2V2ZW50XSB8fCBuZXcgU3VwZXIoKSkuZm9yRWFjaCgoeyByZW1vdmVMaXN0ZW5lciB9KSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0VsZW1FdmVudFN0cmluZ3xPYmplY3QuPEVsZW1FdmVudFN0cmluZ3xFbGVtTGlzdGVuZXI+fSBldmVudCAtIEVpdGhlciBhIHtAbGluayBFbGVtRXZlbnRTdHJpbmd9IHN0cmluZ1xyXG4gICAqIG9yIGFuIG9iamVjdCB3aXRoIGV2ZW50IGtleXMgKGEga2V5IGlzIGFsc28gRWxlbUV2ZW50U3RyaW5nKSBhbmQgbGlzdGVuZXJzIHZhbHVlcy5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yID0gbnVsbF0gLSBTZWxlY3RvciB0byBmaWx0ZXIgZXZlbnQgdGFyZ2V0cy5cclxuICAgKiBAcGFyYW0ge0VsZW1MaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBtdXN0IGJlIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yXHJcbiAgICogc3BlY2lmaWVkIGV2ZW50KHMpLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtUmVtb3ZlTGlzdGVuZXJzfSBGdW5jdGlvbiB0aGF0IHRha2VzIG9wdGlvbmFsIGV2ZW50IGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxyXG4gICAqIEZvciBkZWJ1Z2dpbmc6IElmIHlvdSBuZWVkIHRvIGtub3cgd2hhdCBsaXN0ZW5lcnMgYXJlIGluIHdvcmsgKGFuZCB3aGF0IHNlbGVjdG9ycyBmaWx0ZXIgdGFyZ2V0cylcclxuICAgKiB5b3UgY2FuIGxvb2sgYXQgdGhlIGJhc2UgcHJvcGVydHkgb2YgdGhlIG9ubHkgZHdheW5lIGxpc3RlbmVyIHRoYXQgbGlzdGVucyBmb3IgdGhlIGV2ZW50XHJcbiAgICogYW5kIGZpbmQgYWxsIHdvcmtpbmcgbGlzdGVuZXJzIGluIGxpc3RlbmVyLmJhc2UuZHdheW5lRGF0YS5saXN0ZW5lcnNbZXZlbnRdLiQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ub24oXHJcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXHJcbiAgICogICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGRhdGFsaXN0LCBrZXlnZW4sIG91dHB1dCcsXHJcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXHJcbiAgICogKTtcclxuICAgKiBlbGVtLm9uKFxyXG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnLFxyXG4gICAqICAgKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKVxyXG4gICAqICk7XHJcbiAgICogZWxlbS5vbihcclxuICAgKiAgIHtcclxuICAgKiAgICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxyXG4gICAqICAgICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcclxuICAgKiAgIH0sXHJcbiAgICogICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGRhdGFsaXN0LCBrZXlnZW4sIG91dHB1dCdcclxuICAgKiApO1xyXG4gICAqXHJcbiAgICogY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZWxlbS5vbih7XHJcbiAgICogICAnY2hhbmdlLCBpbnB1dCc6IChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSksXHJcbiAgICogICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIHJlbW92ZUxpc3RlbmVycygnY2xpY2snKTtcclxuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScpO1xyXG4gICAqIHJlbW92ZUxpc3RlbmVycygnYmx1ciwgY2hhbmdlJywgJ2lucHV0Jyk7XHJcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICovXHJcbiAgb24oZXZlbnQsIHNlbGVjdG9yID0gbnVsbCwgbGlzdGVuZXIpIHtcclxuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IG5ldyBTdXBlcih7fSk7XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XHJcbiAgICAgIGxpc3RlbmVyID0gc2VsZWN0b3I7XHJcbiAgICAgIHNlbGVjdG9yID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNTdHJpbmcoZXZlbnQpKSB7XHJcbiAgICAgIGV2ZW50ID0geyBbZXZlbnRdOiBsaXN0ZW5lciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGV2ZW50ID0gbmV3IFN1cGVyKGV2ZW50KS5vYmplY3QoKGxpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50KSA9PiB7XHJcbiAgICAgIGl0ZXJhdGUoZXZlbnQuc3BsaXQoZXZlbnRTZXBhcmF0b3IpLCAoZXZlbnQpID0+IHtcclxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXI7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmICghaXNFbGVtZW50KGVsZW0pICYmICFpc1dpbmRvdyhlbGVtKSAmJiAhaXNIVE1MRG9jdW1lbnQoZWxlbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHsgbGlzdGVuZXJzIH0gPSAod2luZG93c0R3YXluZURhdGEuZmluZCgoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQgPT09IGVsZW0pIHx8IHt9KS52YWx1ZSB8fCBlbGVtLmR3YXluZURhdGE7XHJcblxyXG4gICAgICBldmVudC5mb3JFYWNoKChsaXN0ZW5lciwgZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCByZW1vdmVFdmVudExpc3RlbmVycyA9IGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdIHx8IG5ldyBTdXBlcih7fSkuZGVmaW5lKCdpbmRleCcsIHtcclxuICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzLnByb3AoJ2luZGV4Jyk7XHJcblxyXG4gICAgICAgIGlmICghcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuaGFzKCdsaXN0ZW5lcicpKSB7XHJcbiAgICAgICAgICBjb25zdCBuZXdMaXN0ZW5lciA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHsgc2VsZWN0b3IsIGxpc3RlbmVyIH0pID0+IHtcclxuICAgICAgICAgICAgICBpZiAobmV3IEVsZW0oZS50YXJnZXQpLmlzKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChlbGVtLCBlLCBlbGVtLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgbmV3TGlzdGVuZXIuYmFzZSA9IGVsZW07XHJcblxyXG4gICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBuZXdMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuZGVmaW5lKCdsaXN0ZW5lcicsIHtcclxuICAgICAgICAgICAgdmFsdWU6IG5ld0xpc3RlbmVyLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGluZGV4KTtcclxuXHJcbiAgICAgICAgICBpZiAoIXJlbW92ZUV2ZW50TGlzdGVuZXJzLmNvdW50KSB7XHJcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMucHJvcCgnbGlzdGVuZXInKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVycy5kZWxldGUoJ2xpc3RlbmVyJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYWxsTGlzdGVuZXJzLnByb3AoZXZlbnQsIChhbGxMaXN0ZW5lcnMucHJvcChldmVudCkgfHwgbmV3IEFycigpKS5wdXNoKHJlbW92ZUxpc3RlbmVyKSk7XHJcblxyXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzLmFzc2lnbih7XHJcbiAgICAgICAgICBpbmRleDogaW5kZXggKyAxLFxyXG4gICAgICAgICAgW2luZGV4XToge1xyXG4gICAgICAgICAgICBzZWxlY3RvcixcclxuICAgICAgICAgICAgbGlzdGVuZXIsXHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGV2ZW50KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgaXRlcmF0ZShhcmd1bWVudHMsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgaXRlcmF0ZShldmVudC5zcGxpdChldmVudFNlcGFyYXRvciksIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYWxsTGlzdGVuZXJzLmhhcyhldmVudCkpIHtcclxuICAgICAgICAgICAgICBhbGxMaXN0ZW5lcnMucHJvcChldmVudCkuZm9yRWFjaCgocmVtb3ZlTGlzdGVuZXIpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xyXG4gICAgICAgICAgICAgIGFsbExpc3RlbmVycy5kZWxldGUoZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhbGxMaXN0ZW5lcnMuZm9yRWFjaCgocmVtb3ZlTGlzdGVuZXJzKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLmZvckVhY2goKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7TnVtYmVyfSBFbGVtI291dGVySGVpZ2h0XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIEdldHRlciBmb3IgZmluZGluZyBob3cgbXVjaCBoZWlnaHQgdGhlIGVsZW1lbnQgYWN0dWFsbHkgaXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uY3NzKHtcclxuICAgKiAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAqICAgaGVpZ2h0OiAnMjAwcHgnLFxyXG4gICAqICAgcGFkZGluZ1RvcDogJzJweCcsXHJcbiAgICogICBwYWRkaW5nQm90dG9tOiAnM3B4JyxcclxuICAgKiAgIGJvcmRlclRvcDogJzFweCBzb2xpZCBibGFjaycsXHJcbiAgICogICBib3JkZXJCb3R0b206ICc0cHggc29saWQgYmxhY2snXHJcbiAgICogICBtYXJnaW5Ub3A6ICcwcHgnLFxyXG4gICAqICAgbWFyZ2luQm90dG9tOiAnNXB4J1xyXG4gICAqIH0pLm91dGVySGVpZ2h0OyAvLyAyMDVcclxuICAgKiBlbGVtXHJcbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ2NvbnRlbnQtYm94JylcclxuICAgKiAgIC5vdXRlckhlaWdodDsgLy8gMjE1XHJcbiAgICogZWxlbVxyXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdwYWRkaW5nLWJveCcpXHJcbiAgICogICAub3V0ZXJIZWlnaHQ7IC8vIDIxMFxyXG4gICAqL1xyXG4gIGdldCBvdXRlckhlaWdodCgpIHtcclxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLiRbMF07XHJcblxyXG4gICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XHJcbiAgICAgIHJldHVybiBlbGVtLm91dGVySGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgYm9yZGVyVG9wV2lkdGgsXHJcbiAgICAgIGJvcmRlckJvdHRvbVdpZHRoLFxyXG4gICAgICBib3hTaXppbmcsXHJcbiAgICAgIGhlaWdodCxcclxuICAgICAgbWFyZ2luVG9wLFxyXG4gICAgICBtYXJnaW5Cb3R0b20sXHJcbiAgICAgIHBhZGRpbmdUb3AsXHJcbiAgICAgIHBhZGRpbmdCb3R0b21cclxuICAgIH0gPSB0aGlzLmNhbGNDU1MoKTtcclxuICAgIGNvbnN0IGJvcmRlcnMgPSBweChib3JkZXJUb3BXaWR0aCkgKyBweChib3JkZXJCb3R0b21XaWR0aCk7XHJcbiAgICBjb25zdCBwYWRkaW5ncyA9IHB4KHBhZGRpbmdUb3ApICsgcHgocGFkZGluZ0JvdHRvbSk7XHJcblxyXG4gICAgcmV0dXJuIHB4KGhlaWdodCkgKyBweChtYXJnaW5Ub3ApICsgcHgobWFyZ2luQm90dG9tKSArIG91dGVyU3dpdGNoZXIoYm94U2l6aW5nLCBbYm9yZGVycywgcGFkZGluZ3NdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge051bWJlcn0gRWxlbSNvdXRlcldpZHRoXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIEdldHRlciBmb3IgZmluZGluZyBob3cgbXVjaCB3aWR0aCB0aGUgZWxlbWVudCBhY3R1YWxseSBpcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jc3Moe1xyXG4gICAqICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICogICB3aWR0aDogJzIwMHB4JyxcclxuICAgKiAgIHBhZGRpbmdMZWZ0OiAnMnB4JyxcclxuICAgKiAgIHBhZGRpbmdSaWdodDogJzNweCcsXHJcbiAgICogICBib3JkZXJMZWZ0OiAnMXB4IHNvbGlkIGJsYWNrJyxcclxuICAgKiAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkIGJsYWNrJ1xyXG4gICAqICAgbWFyZ2luTGVmdDogJzBweCcsXHJcbiAgICogICBtYXJnaW5SaWdodDogJzVweCdcclxuICAgKiB9KS5vdXRlcldpZHRoOyAvLyAyMDVcclxuICAgKiBlbGVtXHJcbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ2NvbnRlbnQtYm94JylcclxuICAgKiAgIC5vdXRlcldpZHRoOyAvLyAyMTVcclxuICAgKiBlbGVtXHJcbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ3BhZGRpbmctYm94JylcclxuICAgKiAgIC5vdXRlcldpZHRoOyAvLyAyMTBcclxuICAgKi9cclxuICBnZXQgb3V0ZXJXaWR0aCgpIHtcclxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLiRbMF07XHJcblxyXG4gICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XHJcbiAgICAgIHJldHVybiBlbGVtLm91dGVyV2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBib3JkZXJMZWZ0V2lkdGgsXHJcbiAgICAgIGJvcmRlclJpZ2h0V2lkdGgsXHJcbiAgICAgIGJveFNpemluZyxcclxuICAgICAgbWFyZ2luTGVmdCxcclxuICAgICAgbWFyZ2luUmlnaHQsXHJcbiAgICAgIHBhZGRpbmdMZWZ0LFxyXG4gICAgICBwYWRkaW5nUmlnaHQsXHJcbiAgICAgIHdpZHRoXHJcbiAgICB9ID0gdGhpcy5jYWxjQ1NTKCk7XHJcbiAgICBjb25zdCBib3JkZXJzID0gcHgoYm9yZGVyTGVmdFdpZHRoKSArIHB4KGJvcmRlclJpZ2h0V2lkdGgpO1xyXG4gICAgY29uc3QgcGFkZGluZ3MgPSBweChwYWRkaW5nTGVmdCkgKyBweChwYWRkaW5nUmlnaHQpO1xyXG5cclxuICAgIHJldHVybiBweCh3aWR0aCkgKyBweChtYXJnaW5MZWZ0KSArIHB4KG1hcmdpblJpZ2h0KSArIG91dGVyU3dpdGNoZXIoYm94U2l6aW5nLCBbYm9yZGVycywgcGFkZGluZ3NdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB3cmFwIG9mIHRoZSBzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKi9cclxuICBwYXJlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiBlbGVtcy5hZGQoZWxlbS5wYXJlbnROb2RlKSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jcGFyZW50VHJlZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgd3JhcCBvZiBhbGwgcGFyZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5wYXJlbnRUcmVlKCk7IC8vIEVsZW1cclxuICAgKi9cclxuICBwYXJlbnRUcmVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIGVsZW1zLmFkZChlbGVtKTtcclxuICAgICAgfVxyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jcHJldlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yID0gbnVsbF0gLSBJZiBwcmVzZW50LCBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGV2ZXJ5IGVsZW0gdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cclxuICAgKiBJZiBub3QsIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5uZXh0KCk7ICAgICAgIC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKiBlbGVtLm5leHQoJy5mb28nKTsgLy8gZmluZHMgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgdGhhdCBoYXMgJ2ZvbycgY2xhc3NcclxuICAgKi9cclxuICBwcmV2KHNlbGVjdG9yID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICAvKiBlc2xpbnQgbm8tY29uZC1hc3NpZ246IDAgKi9cclxuICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtLnByZXZpb3VzU2libGluZykge1xyXG4gICAgICAgIGlmIChuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcikpIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtcy5hZGQoZWxlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNwcm9wXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBFbGVtVmFsdWVDYWxsYmFja3wqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBhc3NpZ25lZCBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtFbGVtVmFsdWVDYWxsYmFja3wqfSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmdcclxuICAgKiB0aGlzIGhhcyB0byBiZSBhbiBhc3NpZ25lZCB2YWx1ZSBpZiBpdCdzIHByZXNlbnQuXHJcbiAgICogQHJldHVybnMge0VsZW18Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3Mgc2V0dGVyIG9yIGEgdmFsdWUgaWYgZ2V0dGVyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBnZXR0ZXIgZm9yIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKiBvciBhIHNldHRlciBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScsIGZhbHNlKTtcclxuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIHByb3AocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xyXG4gICAgICByZXR1cm4gdGhpcy4kWzBdID8gdGhpcy4kWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGl0ZXJhdGUocHJvcGVydHksICh2YWx1ZSwgcHJvcCkgPT4ge1xyXG4gICAgICAgIGVsZW1bcHJvcF0gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKGVsZW1bcHJvcF0sIGVsZW0sIGluZGV4KSA6IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3JlZlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtVmFsdWVDYWxsYmFja30gW2xpbmtdIC0gSWYgaXQncyBwcmVzZW50IGxpbmsgdG8gYSByZXNvdXJjZS5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIHRoZSBsaW5rIGFyZ3VtZW50IGlzbid0IHByZXNlbnQgaXQncyBhIGdldHRlciBvZiB0aGUgJ3NyYycgYXR0cmlidXRlXHJcbiAgICogZm9yIHRoZSBvbmUgb2YgZm9sbG93aW5nIGVsZW1lbnRzOiBpbWcsIHNjcmlwdCwgaWZyYW1lLCBhdWRpbywgdmlkZW87IG9mIHRoZSAnYWN0aW9uJyBhdHRyaWJ1dGVcclxuICAgKiBmb3IgYSBmb3JtIGVsZW1lbnQgYW5kIG9mIHRoZSAnaHJlZicgYXR0cmlidXRlIGZvciB0aGUgcmVzdC4gSWYgaXQncyBwcmVzZW50IGl0J3MgYSBzZXR0ZXJcclxuICAgKiBvZiB0aGUgc2FtZSBhdHRyaWJ1dGUgZm9yIGFsbCB0aGUgZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgcmVzb3VyY2VzIGxpbmtzIGFuZCBzZXR0aW5nIHRoZW0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucmVmKCcvc29tZS9jb29sL2ltYWdlLnBuZycpO1xyXG4gICAqIGVsZW0ucmVmKCk7IC8vICcvc29tZS9jb29sL2ltYWdlLnBuZydcclxuICAgKi9cclxuICByZWYobGluaykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIocmVmU3dpdGNoZXIodGhpcy5uYW1lKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XHJcblxyXG4gICAgICBlbGVtLmF0dHIocmVmU3dpdGNoZXIoZWxlbS5uYW1lKSwgbGluayk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBmcm9tIHRoZSBkb2N1bWVudC5cclxuICAgKiBOb3RlOiBpdCBkb2Vzbid0IHJlbW92ZSB0aGVtIGZyb20gdGhlIHNldCBzbyB3YXRjaCBvdXQgZm9yIHRoZSBtZW1vcnkgbGVha3MuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucmVtb3ZlKCk7XHJcbiAgICovXHJcbiAgcmVtb3ZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XHJcblxyXG4gICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsZW0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVBdHRyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byByZW1vdmUuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucmVtb3ZlQXR0cignZm9vJywgJ2JhcicsICdiYXonKTtcclxuICAgKi9cclxuICByZW1vdmVBdHRyKC4uLmF0dHJpYnV0ZXMpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAoYXR0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5zID0gYXR0ck5TU3dpdGNoZXIoYXR0ciwgW25ldyBFbGVtKGVsZW0pXSk7XHJcblxyXG4gICAgICAgIGlmIChpc051bGwobnMpKSB7XHJcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGVOUyhucywgYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNsYXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byByZW1vdmUuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGNsYXNzZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XHJcbiAgICovXHJcbiAgcmVtb3ZlQ2xhc3MoLi4uY2xhc3Nlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCBsaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XHJcblxyXG4gICAgICBpdGVyYXRlKGlzRWxlbWVudChlbGVtKSAmJiBhcmd1bWVudHMsIChjbHMpID0+IGxpc3QucmVtb3ZlKGNscykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ1NTXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBwcm9wcyAtIENTUyBwcm9wZXJ0aWVzIHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgQ1NTIHByb3BlcnRpZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucmVtb3ZlQ1NTKCdkaXNwbGF5JywgJ3Bvc2l0aW9uJywgJ21hcmdpbicpO1xyXG4gICAqL1xyXG4gIHJlbW92ZUNTUyguLi5wcm9wcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXRlcmF0ZShhcmd1bWVudHMsIChjc3MpID0+IHtcclxuICAgICAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KGNzcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jcmVwbGFjZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHJlcGxhY2UgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxyXG4gICAqIHdpdGggYSBzZXQgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudCAoRWxlbWVudCwgc2V0IG9mIGVsZW1lbnRzIG9yIGEgc2VsZWN0b3Igb2YgdGhlbSkuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cclxuICAgKiBbTm9kZSNyZXBsYWNlQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL3JlcGxhY2VDaGlsZH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucmVwbGFjZShlbGVtMik7XHJcbiAgICogZWxlbS5yZXBsYWNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcclxuICAgKiBlbGVtLnJlcGxhY2UoJyNpZCBkaXYuYzEnKTtcclxuICAgKi9cclxuICByZXBsYWNlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQgPSB0b0ZpbmQoZWxlbWVudCk7XHJcblxyXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5maXJzdCgpLnBhcmVudCgpO1xyXG5cclxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZWxlbSA9IHBhcmVudDtcclxuICAgIGxldCBtZXRob2QgPSAnaW50byc7XHJcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0KCkuZmlyc3QoKS4kWzBdO1xyXG4gICAgY29uc3QgcHJldiA9IHRoaXMucHJldigpLmZpcnN0KCkuJFswXTtcclxuXHJcbiAgICBpZiAobmV4dCkge1xyXG4gICAgICBlbGVtID0gbmV4dDtcclxuICAgICAgbWV0aG9kID0gJ2luc2VydEJlZm9yZSc7XHJcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcclxuICAgICAgZWxlbSA9IHByZXY7XHJcbiAgICAgIG1ldGhvZCA9ICdpbnNlcnRBZnRlcic7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5maXJzdCgpLnJlbW92ZSgpO1xyXG5cclxuICAgIGVsZW1lbnRbbWV0aG9kXShlbGVtKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNzZXRPZlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEhUTUwgZWxlbWVudCB0eXBlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxBcnJheS48Kj59IGl0ZXJhdG9yIC0gQSBudW1iZXIgKGhvdyBtYW55IGVsZW1lbnRzIHRvIGNyZWF0ZSBpbnNpZGUgZWFjaCBlbGVtZW50KSxcclxuICAgKiBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RWxlbVNldE9mQ2FsbGJhY2t9IGNhbGxiYWNrXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgc2V0IG9mIGVsZW1lbnRzIGluc2lkZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBiYXNlZCBvbiBhbiBhcnJheSBvciBhbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHRhYmxlLnNldE9mKCd0cicsIFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXSwgKHJvdywgYXJyYXkpID0+IHtcclxuICAgKiAgIEQocm93KS5zZXRPZigndGQnLCBhcnJheSwgKGNvbCwgbnVtYmVyKSA9PiB7XHJcbiAgICogICAgIEQoY29sKS50ZXh0KG51bWJlcik7XHJcbiAgICogICB9KTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBzZXRPZih0eXBlLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgIHZhbGlkYXRlKHsgMjogY2FsbGJhY2sgfSwgeyAyOiBbJ2Z1bmN0aW9uJ10gfSwgJ0VsZW0jc2V0T2YnKTtcclxuXHJcbiAgICBpdGVyYXRvciA9IG5ldyBTdXBlcihpdGVyYXRvcikuJDtcclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoaXRlcmF0b3IpKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFsaWRhdGUoeyAxOiBpdGVyYXRvciB9LCB7IDE6IFsnaW50TGlrZScsICc+PTAnXSB9LCAnRWxlbSNzZXRPZicpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcybmQgYXJndW1lbnQgbXVzdCBiZSBlaXRoZXIgb3Igbm9uLW5lZ2F0aXZlIGludGVnZXIsIG9yIG9iamVjdCEgKGF0IEVsZW0jc2V0T2YpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZXJhdG9yID0gYXJyYXkoaXRlcmF0b3IpLiQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaXRlcmF0ZShpdGVyYXRvciwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCBjcmVhdGVkID0gbmV3IEVsZW0oZWxlbSkuY3JlYXRlKHR5cGUpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayhjcmVhdGVkLiRbMF0sIHZhbHVlLCBrZXksIGl0ZXJhdG9yLCBlbGVtLCBpbmRleCk7XHJcblxyXG4gICAgICAgIGVsZW1zLmFkZChjcmVhdGVkKTtcclxuICAgICAgfSk7XHJcbiAgICB9LCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNzaG93XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFNob3dzIGFsbCBlbGVtZW50cyBpbiB0aGUgc2V0LlxyXG4gICAqIElmIGFuIGVsZW1lbnQgd2FzIGhpZGRlbiB1c2luZyB7QGxpbmsgRWxlbSNoaWRlfSBwcmV2aW91cyBkaXNwbGF5IGlzIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5zaG93KCk7XHJcbiAgICovXHJcbiAgc2hvdygpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgY29uc3QgeyBkd2F5bmVEYXRhIH0gPSBlbGVtO1xyXG5cclxuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xyXG5cclxuICAgICAgaWYgKGVsZW0uY3NzKCdkaXNwbGF5JykuaW5kZXhPZignbm9uZScpID09PSAwKSB7XHJcbiAgICAgICAgZWxlbS5jc3MoJ2Rpc3BsYXknLCBkd2F5bmVEYXRhLnByZXZpb3VzRGlzcGxheSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGR3YXluZURhdGEucHJldmlvdXNEaXNwbGF5ID0gJyc7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSN0ZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfCp9IFt0ZXh0XSAtIFRleHQgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IHRleHQuXHJcbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHRleHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cclxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIHRleHRzIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgdGV4dCBhcmd1bWVudC5cclxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIHRleHQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0udGV4dCgnMTIzJyk7XHJcbiAgICogZWxlbS50ZXh0KCk7IC8vICcxMjMnXHJcbiAgICovXHJcbiAgdGV4dCh0ZXh0KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvcCh0ZXh0UHJvcGVydHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHR4dCA9IGVsZW1bdGV4dFByb3BlcnR5XTtcclxuXHJcbiAgICAgIG5ldyBFbGVtKGVsZW0pLnByb3AoXHJcbiAgICAgICAgdGV4dFByb3BlcnR5LFxyXG4gICAgICAgIGlzRnVuY3Rpb24odGV4dClcclxuICAgICAgICAgID8gdGV4dCh0eHQsIGVsZW0sIGluZGV4KVxyXG4gICAgICAgICAgOiB0ZXh0XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSN0b2dnbGVBdHRyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gQXR0cmlidXRlIHRvIHRvZ2dsZS5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgYXR0cmlidXRlXHJcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xyXG4gICAqIHRoZSBhdHRyaWJ1dGUgaWYgaXQgZG9lc24ndCBleGlzdCBhbmQgcmVtb3ZlcyBpZiBpdCBkb2VzLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XHJcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJywgc29tZUNvbmRpdGlvbik7XHJcbiAgICovXHJcbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xyXG5cclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIWVsZW0uaGFzQXR0cihhdHRyKSA6IGNvbmRpdGlvbikge1xyXG4gICAgICAgIGVsZW0uYXR0cihhdHRyLCAnJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSN0b2dnbGVBdHRyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBDbGFzcyB0byB0b2dnbGUuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtjb25kaXRpb25dIC0gSWYgcHJlc2VudCBhbmQgdGhlIGNvbmRpdGlvbiBpcyB0cnV0aHkgbWV0aG9kIGFkZHMgdGhlIGNsYXNzXHJcbiAgICogYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgY2xhc3MuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXHJcbiAgICogdGhlIGNsYXNzIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGNsYXNzZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycpO1xyXG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycsIHNvbWVDb25kaXRpb24pO1xyXG4gICAqL1xyXG4gIHRvZ2dsZUNsYXNzKGNscywgY29uZGl0aW9uKSB7XHJcbiAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIXRoaXMuaGFzQ2xhc3MoY2xzKSA6IGNvbmRpdGlvbilcclxuICAgICAgPyB0aGlzLmFkZENsYXNzKGNscylcclxuICAgICAgOiB0aGlzLnJlbW92ZUNsYXNzKGNscyk7XHJcbiAgfVxyXG5cclxuICBnZXQgdG9TdHJpbmdUYWcoKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcodGhpcy4kJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jdXBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGV2ZWwgPSAxXSAtIFdoYXQgbGV2ZWwgdXAgYWxvbmcgdGhlIHRyZWUgc2hvdWxkIGJlIHRoZSBwYXJlbnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgY29sbGVjdGlvbiBvZiBwYXJlbnRzIG9mIGxldmVsICZsdDtsZXZlbCZndDsuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0udXAoKTtcclxuICAgKiBlbGVtLnVwKDIpO1xyXG4gICAqL1xyXG4gIHVwKGxldmVsID0gMSkge1xyXG4gICAgdmFsaWRhdGUoW2xldmVsXSwgW1snaW50TGlrZScsICc+PTAnXV0sICdFbGVtI3VwJyk7XHJcblxyXG4gICAgbGV2ZWwgPSBOdW1iZXIobGV2ZWwpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgbGV0IG4gPSBsZXZlbDtcclxuXHJcbiAgICAgIHdoaWxlIChuLS0gJiYgZWxlbSkge1xyXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1zLmFkZChlbGVtKTtcclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3ZhbGlkYXRlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7VmFsaWRhdGVDYWxsYmFja30gW3ZhbGlkYXRvcl0gLSBJZiBwcmVzZW50LCBmdW5jdGlvbiB0aGF0IHZhbGlkYXRlcyBpbnB1dHMuXHJcbiAgICogQHJldHVybnMge0VsZW18T2JqZWN0LjxTdHJpbmcsIEVycm9yfCo+fG51bGx9XHJcbiAgICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCBwcm92aWRlZCByZXR1cm5zIHRoaXMuIElmIG5vIGFyZ3VtZW50cyBwcm92aWRlZCByZXR1cm5zIGVpdGhlciBhbiBvYmplY3RcclxuICAgKiB3aXRoIGlucHV0IG5hbWVzIGtleXMgYW5kIGVycm9ycyB2YWx1ZXMgb3IgbnVsbCBpZiBubyBlcnJvcnMgZm91bmQuXHJcbiAgICogQGRlc2NyaXB0aW9uIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgcHJvdmlkZWQgYWRkcyBpdCB0byB0aGUgZWxlbWVudCB2YWxpZGF0b3JzIGxpc3QuXHJcbiAgICogSWYgbm8gYXJndW1lbnRzIHByb3ZpZGVkIHZhbGlkYXRlcyBldmVyeSBpbnB1dCBlbGVtZW50IGluIHRoZSBzZXQgd2l0aCBpdHMgb3duIGZ1bmN0aW9ucy5cclxuICAgKiBJZiBhbiBlbGVtZW50IGlzIGEgZm9ybSBpdCB2YWxpZGF0ZXMgYWxsIGlucHV0IGVsZW1lbnRzIGluc2lkZSBpdC4gQWZ0ZXIgdGhlIHZhbGlkYXRpb25cclxuICAgKiBmaXJlcyAndmFsaWRhdGUnIGV2ZW50IHdpdGggJ3ZhbGlkJyBhbmQgJ2Vycm9yJyAoaWYgZm9ybSBpdCdzIGVycm9ycykgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZm9ybS5vbignaW5wdXQgY2hhbmdlJywgJ2lucHV0JywgKHZhbHVlLCBpbnB1dCkgPT4ge1xyXG4gICAqICAgaW5wdXQgPSBEKGlucHV0KTtcclxuICAgKlxyXG4gICAqICAgaWYgKE51bWJlcih2YWx1ZSkgJSAzKSB7XHJcbiAgICogICAgIGlucHV0LmFkZENsYXNzKCdpbnZhbGlkJyk7XHJcbiAgICpcclxuICAgKiAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgc2hvdWxkIGJlIGRpdmlkZWQgYnkgMyEnKTtcclxuICAgKiAgIH1cclxuICAgKlxyXG4gICAqICAgaW5wdXQucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICB2YWxpZGF0ZSh2YWxpZGF0b3IpIHtcclxuICAgIHZhbGlkYXRlKFt2YWxpZGF0b3JdLCBbJ2Z1bmN0aW9ufHwhJ10sICdFbGVtI3ZhbGlkYXRlJyk7XHJcblxyXG4gICAgaWYgKHZhbGlkYXRvcikge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKCh7IGR3YXluZURhdGEgfSkgPT4ge1xyXG4gICAgICAgIGR3YXluZURhdGEudmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVycm9ycyA9IG5ldyBTdXBlcih7IGVycm9yczogbnVsbCB9KTtcclxuXHJcbiAgICB0aGlzXHJcbiAgICAgIC5maWx0ZXIoYCR7IGlucHV0RWxlbWVudHMgfSwgZm9ybWApXHJcbiAgICAgIC5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGlmIChnZXROYW1lKGVsZW0pID09PSAnZm9ybScpIHtcclxuICAgICAgICAgIGxldCBmb3JtRXJyb3JzID0geyBlcnJvcnM6IG51bGwgfTtcclxuICAgICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgRWxlbShlbGVtKTtcclxuICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGZvcm0uZmluZChpbnB1dEVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRvcldyYXAoaW5wdXQsIGluZGV4LCBmb3JtRXJyb3JzKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGVycm9ycy5kZWVwQXNzaWduKGZvcm1FcnJvcnMpO1xyXG5cclxuICAgICAgICAgIGZvcm1FcnJvcnMgPSBmb3JtRXJyb3JzLmVycm9ycztcclxuXHJcbiAgICAgICAgICBmb3JtLmRpc3BhdGNoKCd2YWxpZGF0ZScsIHt9LCB7XHJcbiAgICAgICAgICAgIHZhbGlkOiAhZm9ybUVycm9ycyxcclxuICAgICAgICAgICAgZXJyb3JzOiBmb3JtRXJyb3JzXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RXJyb3IgPSAoZm9ybUVycm9ycyB8fCB7fSlbaW5wdXQubmFtZV07XHJcblxyXG4gICAgICAgICAgICBuZXcgRWxlbShpbnB1dCkuZGlzcGF0Y2goJ3ZhbGlkYXRlJywge30sIHtcclxuICAgICAgICAgICAgICB2YWxpZDogIWlucHV0RXJyb3IsXHJcbiAgICAgICAgICAgICAgZXJyb3I6IGlucHV0RXJyb3IgfHwgbnVsbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGlucHV0RXJyb3IgPSB7IGVycm9yczogbnVsbCB9O1xyXG5cclxuICAgICAgICB2YWxpZGF0b3JXcmFwKGVsZW0sIGluZGV4LCBpbnB1dEVycm9yKTtcclxuICAgICAgICBlcnJvcnMuZGVlcEFzc2lnbihpbnB1dEVycm9yKTtcclxuXHJcbiAgICAgICAgaW5wdXRFcnJvciA9IChpbnB1dEVycm9yLmVycm9ycyB8fCB7fSlbZWxlbS5uYW1lXTtcclxuXHJcbiAgICAgICAgbmV3IEVsZW0oZWxlbSkuZGlzcGF0Y2goJ3ZhbGlkYXRlJywge30sIHtcclxuICAgICAgICAgIHZhbGlkOiAhaW5wdXRFcnJvcixcclxuICAgICAgICAgIGVycm9yOiBpbnB1dEVycm9yIHx8IG51bGxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdG9yV3JhcChpbnB1dCwgaW5kZXgsIGVycm9ycykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChpbnB1dC52YWxpZGl0eSAmJiAhaW5wdXQudmFsaWRpdHkudmFsaWQpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnB1dC52YWxpZGF0aW9uTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dC5kd2F5bmVEYXRhLnZhbGlkYXRvcnMuZm9yRWFjaCgodmFsaWRhdG9yKSA9PiB7XHJcbiAgICAgICAgICB2YWxpZGF0b3IoaW5wdXQudmFsdWUsIGlucHV0LCBpbmRleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIChlcnJvcnMuZXJyb3JzID0gZXJyb3JzLmVycm9ycyB8fCB7fSlbaW5wdXQubmFtZV0gPSBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXJyb3JzLmV2ZXJ5KChlcnJvcikgPT4gaXNOdWxsKGVycm9yKSkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVycm9ycy4kLmVycm9ycztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSN3aWR0aFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp8RWxlbVZhbHVlQ2FsbGJhY2t9IFt3aWR0aF0gLSBXaWR0aCB0byBzZXQuXHJcbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHdpZHRoIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXHJcbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyB3aWR0aHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSB3aWR0aCBhcmd1bWVudC5cclxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIHdpZHRoLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLndpZHRoKDEyMyk7XHJcbiAgICogZWxlbS53aWR0aCgpOyAvLyAxMjNcclxuICAgKi9cclxuICB3aWR0aCh3aWR0aCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvcC5hcHBseSh0aGlzLCBuZXcgQXJyKGFyZ3VtZW50cykudW5zaGlmdCgnd2lkdGgnKS4kKTtcclxuICB9XHJcbn1cclxuXHJcbmRlZmluZVByb3BlcnRpZXMoRWxlbS5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0VsZW0nXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7RWxlbX0gd2luXHJcbiAqIEB0eXBlIHtFbGVtfVxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIHdpbmRvdy5cclxuICovXHJcbmNvbnN0IHdpbiA9IG5ldyBFbGVtKGdsb2JhbCk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtFbGVtfSBkb2NcclxuICogQHR5cGUge0VsZW19XHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuXHJcbiAqL1xyXG5jb25zdCBkb2MgPSBuZXcgRWxlbShuYXRpdmVEb2N1bWVudCk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtFbGVtfSBodG1sXHJcbiAqIEB0eXBlIHtFbGVtfVxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5cclxuICovXHJcbmNvbnN0IGh0bWwgPSBuZXcgRWxlbShuYXRpdmVEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7RWxlbX0gYm9keVxyXG4gKiBAdHlwZSB7RWxlbX1cclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5ib2R5LlxyXG4gKi9cclxuY29uc3QgYm9keSA9IG5ldyBFbGVtKG5hdGl2ZURvY3VtZW50LmJvZHkpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7RWxlbX0gaGVhZFxyXG4gKiBAdHlwZSB7RWxlbX1cclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5oZWFkLlxyXG4gKi9cclxuY29uc3QgaGVhZCA9IG5ldyBFbGVtKG5hdGl2ZURvY3VtZW50LmhlYWQpO1xyXG5cclxuY29uc3QgZWxlbWVudHMgPSBuZXcgQXJyKGh0bWxFbGVtZW50cykuY29uY2F0KHN2Z0VsZW1lbnRzKS4kO1xyXG5jb25zdCBwcm9wcyA9IG5ldyBBcnIoZWxlbWVudHMpLm1hcCgodHlwZSkgPT4gbmV3IFN0cih0eXBlKS50b0NhbWVsQ2FzZSgpLiQpLiQ7XHJcblxyXG5keW5hbWljRGVmaW5lUHJvcGVydGllcyhFbGVtLnByb3RvdHlwZSwgcHJvcHMsIChlbGVtLCBpKSA9PiBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuY3JlYXRlLmFwcGx5KHRoaXMsIG5ldyBBcnIoYXJndW1lbnRzKS51bnNoaWZ0KGVsZW1lbnRzW2ldKS4kKTtcclxufSk7XHJcblxyXG5keW5hbWljRGVmaW5lUHJvcGVydGllcyhFbGVtLnByb3RvdHlwZSwgY2FudmFzR2V0TWV0aG9kcywgKG1ldGhvZCkgPT4gZnVuY3Rpb24gKCkge1xyXG4gIGNvbnN0IGN0eCA9IHRoaXMuY3R4KCk7XHJcblxyXG4gIGlmIChjdHgpIHtcclxuICAgIHJldHVybiBjdHhbbWV0aG9kXS5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzKEVsZW0ucHJvdG90eXBlLCBjYW52YXNSZXN0TWV0aG9kcywgKG1ldGhvZCkgPT4gZnVuY3Rpb24gKCkge1xyXG4gIGNvbnN0IGN0eCA9IHRoaXMuY3R4KCk7XHJcblxyXG4gIGlmIChjdHgpIHtcclxuICAgIGN0eFttZXRob2RdLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gdG9GaW5kXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtfFN0cmluZ30gZWxlbSAtIEVsZW1lbnQsIHNlbGVjdG9yIG9mIEVsZW1lbnRzIG9yIEVsZW0uXHJcbiAqIEByZXR1cm5zIHtFbGVtfSBJbnN0YW5jZSBvZiBFbGVtLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9GaW5kKGVsZW0pIHtcclxuICBpZiAoaXNFbGVtKGVsZW0pKSB7XHJcbiAgICByZXR1cm4gZWxlbTtcclxuICB9XHJcblxyXG4gIGlmIChpc1N0cmluZyhlbGVtKSkge1xyXG4gICAgZWxlbSA9IGZpbmQoZWxlbSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IEVsZW0oZWxlbSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNFbGVtXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIEVsZW0uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgRWxlbS5cclxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIHZhbHVlIGlzIEVsZW0gb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbGVtKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc1dpbmRvd1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBXaW5kb3cuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgV2luZG93LlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgV2luZG93IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzV2luZG93KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1dpbmRvdyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNIVE1MRG9jdW1lbnRcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0J3MgSFRNTERvY3VtZW50LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIEhUTUxEb2N1bWVudC5cclxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIHZhbHVlIGlzIEhUTUxEb2N1bWVudCBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0hUTUxEb2N1bWVudCh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdIVE1MRG9jdW1lbnQnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBhIERvY3VtZW50RnJhZ21lbnQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgYSBEb2N1bWVudEZyYWdtZW50LlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgYSBEb2N1bWVudEZyYWdtZW50IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdEb2N1bWVudEZyYWdtZW50JztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc1N0eWxlUnVsZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBhIHN0eWxlIHJ1bGUuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgYSBzdHlsZSBydWxlLlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgYSBzdHlsZSBydWxlIG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzU3R5bGVSdWxlKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0NTU1N0eWxlUnVsZSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0J3MgQ29tbWVudCBvciBUZXh0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIEhUTUxEb2N1bWVudC5cclxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIHZhbHVlIGlzIENvbW1lbnQgb3IgVGV4dCBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NvbW1lbnRPclRleHQodmFsdWUpIHtcclxuICBjb25zdCB0YWcgPSB0b1N0cmluZ1RhZyh2YWx1ZSk7XHJcblxyXG4gIHJldHVybiB0YWcgPT09ICdDb21tZW50JyB8fCB0YWcgPT09ICdUZXh0JztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBnZXRFbGVtXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEVsZW1lbnQgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgYXJndW1lbnQgb3IgYSBmYWxsYmFjayBpZiBuZWVkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFbGVtKGVsZW0pIHtcclxuICByZXR1cm4gaXNFbGVtZW50KGVsZW0uJFswXSkgPyBlbGVtLiRbMF0gOiBlbXB0eURpdjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBnZXROYW1lXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1dIC0gRWxlbWVudCB3aGljaCBuYW1lIGlzIG5lZWRlZCB0byBrbm93LlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBFbGVtZW50IG5hbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROYW1lKGVsZW0pIHtcclxuICByZXR1cm4gKGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHx8ICcnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGFkZER3YXluZURhdGFcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gRWxlbWVudCB0byBhZGQgZHdheW5lRGF0YSB0by5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGREd2F5bmVEYXRhKGVsZW0pIHtcclxuICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoZWxlbSwgJ2R3YXluZURhdGEnKSAmJiAhaXNXaW5kb3coZWxlbSkpIHtcclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciBFbGVtZW50I2R3YXluZURhdGFcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJldmlvdXNEaXNwbGF5IC0gUGFyYW1ldGVyIHVzZWQgZm9yIGhpZGluZy9zaG93aW5nIGVsZW1lbnRzLlxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPFN0cmluZywgU3VwZXI+fSByZW1vdmVMaXN0ZW5lcnMgLSBQYXJhbWV0ZXIgdXNlZCBmb3IgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbY3R4XSAtIENhbnZhcyByZW5kZXJpbmcgY29udGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyfSB2YWxpZGF0b3JzIC0gVmFsaWRhdG9ycyBhc3NpZ25lZCB0byBlbGVtZW50LlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW0sICdkd2F5bmVEYXRhJywge1xyXG4gICAgICB2YWx1ZToge1xyXG4gICAgICAgIHByZXZpb3VzRGlzcGxheTogJycsXHJcbiAgICAgICAgbGlzdGVuZXJzOiB7fSxcclxuICAgICAgICBjdHg6IGdldE5hbWUoZWxlbSkgPT09ICdjYW52YXMnICYmIGVsZW0uZ2V0Q29udGV4dCgnMmQnKSxcclxuICAgICAgICB2YWxpZGF0b3JzOiBuZXcgQXJyKFtdKVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKGlzV2luZG93KGVsZW0pICYmICF3aW5kb3dzRHdheW5lRGF0YS5zb21lKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudCA9PT0gZWxlbSkpIHtcclxuICAgIHdpbmRvd3NEd2F5bmVEYXRhLnB1c2goe1xyXG4gICAgICBlbGVtZW50OiBlbGVtLFxyXG4gICAgICBsaXN0ZW5lcnM6IHt9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0cnVjdG9yc1syXS5wdXNoKHtcclxuICBjaGVjazogKGVsZW0pID0+IChcclxuICAgIGlzRWxlbWVudChlbGVtKSB8fFxyXG4gICAgaXNXaW5kb3coZWxlbSkgfHxcclxuICAgIGlzSFRNTERvY3VtZW50KGVsZW0pIHx8XHJcbiAgICBpc0NvbW1lbnRPclRleHQoZWxlbSkgfHxcclxuICAgIGlzRG9jdW1lbnRGcmFnbWVudChlbGVtKSB8fFxyXG4gICAgL14oSFRNTENvbGxlY3Rpb258Tm9kZUxpc3QpJC8udGVzdCh0b1N0cmluZ1RhZyhlbGVtKSlcclxuICApLFxyXG4gIGNsczogRWxlbVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZmluZFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2Jhc2UgPSBkb2N1bWVudF0gLSBCYXNlIHRvIGZpbmQgaW4uXHJcbiAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAqIFtEb2N1bWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBiYXNlID0gbmF0aXZlRG9jdW1lbnQpIHtcclxuICByZXR1cm4gbmV3IEVsZW0oXHJcbiAgICBpc0VsZW1lbnQoYmFzZSkgfHwgaXNIVE1MRG9jdW1lbnQoYmFzZSlcclxuICAgICAgPyBiYXNlLnF1ZXJ5U2VsZWN0b3JBbGwoU3RyaW5nKHNlbGVjdG9yKSlcclxuICAgICAgOiBbXVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gcGFyc2VIVE1MXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgLSBIVE1MIHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjb2xsYXBzZVdoaXRlU3BhY2UgPSBmYWxzZV0gLSBJZiB0aGUgd2hpdGVzcGFjZSBzaG91bGQgYmVcclxuICogY29sbGFwc2VkIGR1cmluZyB0aGUgcGFyc2luZy5cclxuICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gKiBAZGVzY3JpcHRpb24gUGFyc2VzIEhUTUwgYW5kIHJldHVybnMgYSB3cmFwIG9mICNkb2N1bWVudC1mcmFnbWVudCBjb250YWluaW5nIHRoZSBjb250ZW50cy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogcGFyc2VIVE1MKCc8ZGl2PjEyMzwvZGl2PicpOyAvLyBFbGVtXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUhUTUwoaHRtbCwgY29sbGFwc2VXaGl0ZVNwYWNlKSB7XHJcbiAgY29uc3QganNvbiA9IG1hcmt1cFRvSlNPTihodG1sLCBjb2xsYXBzZVdoaXRlU3BhY2UpO1xyXG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jLnRlbXBsYXRlKCk7XHJcbiAgY29uc3QgZWxlbSA9IG5ldyBFbGVtKHRlbXBsYXRlLiRbMF0uY29udGVudCk7XHJcblxyXG4gIGpzb24uZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoTm9kZShub2RlKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGF0dHJzLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgcGFyZW50LFxyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IG5vZGU7XHJcblxyXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhcmVudC5lbGVtIHx8IGVsZW07XHJcbiAgICBjb25zdCBlbGVtZW50ID0gcGFyZW50Tm9kZS5jcmVhdGUobmFtZSk7XHJcblxyXG4gICAgbm9kZS5lbGVtID0gZWxlbWVudDtcclxuXHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgZWxlbWVudC50ZXh0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXR0cnMpIHtcclxuICAgICAgZWxlbWVudC5hdHRyKGF0dHJzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmFtZSA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICBub2RlLmVsZW0gPSBuZXcgRWxlbShlbGVtZW50LnByb3AoJ2NvbnRlbnQnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZm9yRWFjaE5vZGUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gbmV3IEVsZW0oZWxlbSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gcHhcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNpemUgLSBTdHJpbmcgY29udGFpbmluZyBwaXhlbHMgdmFsdWUgb3IgYSBudW1iZXIuXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBwaXhlbHMuXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgcGFyc2luZyBwaXhlbCBzdHJpbmdzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBweCgnMHB4Jyk7ICAvLyAwXHJcbiAqIHB4KCc0MnB4Jyk7IC8vIDQyXHJcbiAqL1xyXG5mdW5jdGlvbiBweChzaXplKSB7XHJcbiAgcmV0dXJuIE51bWJlcihTdHJpbmcoc2l6ZSkucmVwbGFjZSgvcHgkLywgJycpKTtcclxufVxyXG5cclxuZXhwb3J0IHsgRWxlbSwgd2luLCBkb2MsIGh0bWwsIGJvZHksIGhlYWQsIGZpbmQsIHBhcnNlSFRNTCwgcHggfTtcclxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREJsb2NrKEJsb2NrKSB7XHJcbiAgY2xhc3MgREJsb2NrIGV4dGVuZHMgQmxvY2sge1xyXG4gICAgc3RhdGljIHRlbXBsYXRlID0gJzxkLWVsZW1lbnRzIHZhbHVlPVwie2VsZW1zfVwiIC8+JztcclxuXHJcbiAgICBlbGVtcyA9IG51bGw7XHJcblxyXG4gICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XHJcbiAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMuJCQucGFyZW50O1xyXG4gICAgICBjb25zdCB7IG5hbWUgfSA9IHRoaXMuYXJncztcclxuICAgICAgbGV0IGZvdW5kO1xyXG5cclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICBmb3VuZCA9IGNoaWxkcmVuLmZpbmQoKHsgbmFtZTogbm9kZU5hbWUgfSkgPT4gbm9kZU5hbWUgPT09IGBkLWJsb2NrLSR7IG5hbWUgfWApO1xyXG5cclxuICAgICAgICBpZiAoZm91bmQgJiYgZm91bmQudmFsdWUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLmVsZW1zID0gZm91bmQudmFsdWUuY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLWJsb2NrJyxcclxuICAgIHZhbHVlOiBEQmxvY2tcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XHJcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi9FbGVtJztcclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XHJcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREVhY2goQmxvY2ssIGNyZWF0ZUJsb2NrKSB7XHJcbiAgY2xhc3MgREVhY2ggZXh0ZW5kcyBCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgIHN1cGVyKG9wdHMpO1xyXG5cclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGFyZ3M6IHtcclxuICAgICAgICAgIGl0ZW06IGl0ZW1OYW1lID0gJyRpdGVtJyxcclxuICAgICAgICAgIGluZGV4OiBpbmRleE5hbWUgPSAnJGluZGV4J1xyXG4gICAgICAgIH1cclxuICAgICAgfSA9IHRoaXM7XHJcblxyXG4gICAgICBhc3NpZ24odGhpcy4kJCwge1xyXG4gICAgICAgIHVpZHM6IG5ldyBTdXBlcih7fSksXHJcbiAgICAgICAgaXRlbXM6IG5ldyBBcnIoW10pLFxyXG4gICAgICAgIFVJRDogU3RyaW5nKHRoaXMuYXJncy51aWQpLFxyXG4gICAgICAgIGl0ZW1OYW1lLFxyXG4gICAgICAgIGluZGV4TmFtZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhZnRlclJlbmRlcigpIHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3RWYWx1ZXModGhpcy5hcmdzLnNldCk7XHJcbiAgICAgIHRoaXMud2F0Y2hBcmdzKCdzZXQnLCAoc2V0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RWYWx1ZXMoc2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0VmFsdWVzKHNldCkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgZWxlbXM6IHtcclxuICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRFbGVtXHJcbiAgICAgICAgfSxcclxuICAgICAgICB1aWRzLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBzY29wZSxcclxuICAgICAgICBpdGVtTmFtZSxcclxuICAgICAgICBpbmRleE5hbWUsXHJcbiAgICAgICAgVUlEXHJcbiAgICAgIH0gPSB0aGlzLiQkO1xyXG4gICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzO1xyXG4gICAgICBjb25zdCAkdWlkcyA9IHVpZHMuJDtcclxuICAgICAgY29uc3QgbmV3S2V5cyA9IHt9O1xyXG4gICAgICBjb25zdCBuZXdVSURzID0ge307XHJcblxyXG4gICAgICBuZXcgU3VwZXIoc2V0KS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHNjb3BlW2l0ZW1OYW1lXSA9IGl0ZW07XHJcbiAgICAgICAgc2NvcGVbaW5kZXhOYW1lXSA9IGluZGV4O1xyXG5cclxuICAgICAgICBjb25zdCB1aWQgPSBwYXJlbnQuJCQuZXZhbHVhdGUoU3RyaW5nKFVJRCksIG51bGwsIG51bGwsIGZhbHNlLCBmYWxzZSwgdGhpcyk7XHJcblxyXG4gICAgICAgIG5ld0tleXNbdWlkXSA9IG5ld0tleXNbdWlkXSB8fCB7fTtcclxuICAgICAgICBuZXdLZXlzW3VpZF1baW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICBuZXdVSURzW2luZGV4XSA9IHVpZDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzY29wZVtpdGVtTmFtZV0gPSBudWxsO1xyXG4gICAgICBzY29wZVtpbmRleE5hbWVdID0gbnVsbDtcclxuXHJcbiAgICAgIHVpZHMuZm9yRWFjaCgoaXRlbXMsIHVpZCkgPT4ge1xyXG4gICAgICAgIGlmICghbmV3S2V5c1t1aWRdKSB7XHJcbiAgICAgICAgICBpdGVtcy5mb3JFYWNoKChJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIEl0ZW0ucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpdGVtcy5zcGxpY2UoT2JqZWN0LmtleXMobmV3S2V5c1t1aWRdKS5sZW5ndGgpLmZvckVhY2goKEl0ZW0pID0+IHtcclxuICAgICAgICAgIEl0ZW0ucmVtb3ZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGV0IGFmdGVyID0gc3RhcnQ7XHJcblxyXG4gICAgICBuZXcgU3VwZXIoc2V0KS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVpZCA9IG5ld1VJRHNbaW5kZXhdO1xyXG4gICAgICAgIGxldCBibG9jaztcclxuXHJcbiAgICAgICAgaWYgKCR1aWRzW3VpZF0gJiYgJHVpZHNbdWlkXS5sZW5ndGgpIHtcclxuICAgICAgICAgIGJsb2NrID0gbmV3S2V5c1t1aWRdW2luZGV4XSA9IHVpZHMuJFt1aWRdLnNoaWZ0KCk7XHJcbiAgICAgICAgICBibG9jay4kJC5zY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XHJcbiAgICAgICAgICBibG9jay4kJC5zY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBibG9jayA9IG5ld0tleXNbdWlkXVtpbmRleF0gPSBjcmVhdGVCbG9jayh7XHJcbiAgICAgICAgICAgIG5vZGU6IHtcclxuICAgICAgICAgICAgICBpdGVtTmFtZSxcclxuICAgICAgICAgICAgICBpbmRleE5hbWUsXHJcbiAgICAgICAgICAgICAgaXRlbSxcclxuICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICBuYW1lOiAnI2QtaXRlbScsXHJcbiAgICAgICAgICAgICAgYmxvY2s6IHBhcmVudCxcclxuICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZnRlcixcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRFbGVtLFxyXG4gICAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcclxuICAgICAgICAgICAgcGFyZW50U2NvcGU6IHBhcmVudFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgIGVuZFxyXG4gICAgICAgIH0gPSBibG9jay4kJC5lbGVtcztcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0LnByZXYoKS4kWzBdICE9PSBhZnRlci4kWzBdKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IGJsb2NrLiQkLmVsZW1zO1xyXG5cclxuICAgICAgICAgIG5ldyBFbGVtKFtcclxuICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGVuZFxyXG4gICAgICAgICAgXSkuaW5zZXJ0QWZ0ZXIoYWZ0ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWZ0ZXIgPSBlbmQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy4kJC51aWRzID0gbmV3IFN1cGVyKG5ld0tleXMpLm1hcCgoaXRlbXMpID0+IChcclxuICAgICAgICBuZXcgU3VwZXIoaXRlbXMpLnZhbHVlcygpXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLWVhY2gnLFxyXG4gICAgdmFsdWU6IERFYWNoXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBBcnIgfSBmcm9tICcuLi9BcnInO1xyXG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vRWxlbSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJERWxlbWVudHMoQmxvY2ssIGNyZWF0ZUJsb2NrKSB7XHJcbiAgY2xhc3MgREVsZW1lbnRzIGV4dGVuZHMgQmxvY2sge1xyXG4gICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XHJcbiAgICAgIHRoaXMud2F0Y2hBcmdzKCd2YWx1ZScsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgICAgbWl4aW5zLFxyXG4gICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcclxuICAgICAgICAgIGVsZW1zOiB7XHJcbiAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICBwYXJlbnRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9ID0gdGhpcy4kJDtcclxuICAgICAgICBsZXQgYWZ0ZXIgPSBzdGFydDtcclxuXHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgIGNoaWxkLnJlbW92ZSh0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBtaXhpbnMuZm9yRWFjaCgobWl4aW4pID0+IHtcclxuICAgICAgICAgIG1peGluLnJlbW92ZSh0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250ZW50LnJlbW92ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLiQkLmNoaWxkcmVuID0gbmV3IEFycihbXSk7XHJcbiAgICAgICAgdGhpcy4kJC5taXhpbnMgPSBuZXcgQXJyKFtdKTtcclxuICAgICAgICB0aGlzLiQkLndhdGNoZXJzVG9SZW1vdmUgPSB3YXRjaGVyc1RvUmVtb3ZlLmZpbHRlcigoeyB3YXRjaGVycywgd2F0Y2hlciwgZm9yREVsZW1lbnRzIH0pID0+IHtcclxuICAgICAgICAgIGlmIChmb3JERWxlbWVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB3YXRjaGVycy5pbmRleE9mKHdhdGNoZXIpO1xyXG5cclxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgd2F0Y2hlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IG5ldyBFbGVtKCk7XHJcblxyXG4gICAgICAgIG5ldyBBcnIodmFsdWUgfHwgW10pLmZvckVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBibG9jayA9IGNyZWF0ZUJsb2NrKHtcclxuICAgICAgICAgICAgbm9kZTogY2hpbGQsXHJcbiAgICAgICAgICAgIGFmdGVyLFxyXG4gICAgICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxyXG4gICAgICAgICAgICBwYXJlbnRTY29wZTogdGhpc1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcclxuICAgICAgICAgICAgY29uc3QgeyBlbGVtcyB9ID0gYmxvY2suJCQ7XHJcblxyXG4gICAgICAgICAgICBhZnRlciA9IGVsZW1zLmVuZDtcclxuXHJcbiAgICAgICAgICAgIG5ld0NvbnRlbnQuYWRkKGVsZW1zLnN0YXJ0LCBlbGVtcy5jb250ZW50LCBlbGVtcy5lbmQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWZ0ZXIgPSBibG9jaztcclxuXHJcbiAgICAgICAgICAgIG5ld0NvbnRlbnQuYWRkKGJsb2NrKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy4kJC5lbGVtcy5jb250ZW50ID0gbmV3Q29udGVudDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtZWxlbWVudHMnLFxyXG4gICAgdmFsdWU6IERFbGVtZW50c1xyXG4gIH07XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRElmKEJsb2NrKSB7XHJcbiAgY2xhc3MgRElmIGV4dGVuZHMgQmxvY2sge1xyXG4gICAgc3RhdGljIHRlbXBsYXRlID0gJzxkLWVsZW1lbnRzIHZhbHVlPVwie2VsZW1zfVwiLz4nO1xyXG5cclxuICAgIGluZGV4ID0gSW5maW5pdHk7XHJcbiAgICBlbGVtcyA9IG51bGw7XHJcbiAgICB2YWx1ZXMgPSB0aGlzLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGkpID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgYXR0cnMsXHJcbiAgICAgICAgY2hpbGRyZW5cclxuICAgICAgfSA9IGNoaWxkO1xyXG4gICAgICBjb25zdCBjb25kID0gdGhpcy5ldmFsdWF0ZUFuZFdhdGNoKG5hbWUgPT09ICdkLWVsc2UnID8gJ3t0cnVlfScgOiBhdHRycy5pZiB8fCAne3RydWV9JywgKG5ld1ZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYgKCEhbmV3VmFsdWUgPT09IHRoaXMudmFsdWVzLiRbaV0pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmFsdWVzLiRbaV0gPSAhIW5ld1ZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoaSA+IHRoaXMuaW5kZXgpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpIDwgdGhpcy5pbmRleCkge1xyXG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XHJcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLnZhbHVlcy5maW5kKEJvb2xlYW4pO1xyXG5cclxuICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZC5rZXk7XHJcbiAgICAgICAgICB0aGlzLmVsZW1zID0gdGhpcy5jaGlsZHJlbi4kW2ZvdW5kLmtleV0uY2hpbGRyZW47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcclxuICAgICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoY29uZCAmJiB0aGlzLmluZGV4ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpO1xyXG4gICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNvbmQ7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1pZicsXHJcbiAgICB2YWx1ZTogRElmXHJcbiAgfTtcclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJESXRlbShCbG9jaykge1xyXG4gIGNsYXNzIERJdGVtIGV4dGVuZHMgQmxvY2sge1xyXG4gICAgc3RhdGljIHRlbXBsYXRlID0gJzxkLWVsZW1lbnRzIHZhbHVlPVwie2NoaWxkcmVufVwiLz4nO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICcjZC1pdGVtJyxcclxuICAgIHZhbHVlOiBESXRlbVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEU3dpdGNoKEJsb2NrKSB7XHJcbiAgY2xhc3MgRFN3aXRjaCBleHRlbmRzIEJsb2NrIHtcclxuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZC1lbGVtZW50cyB2YWx1ZT1cIntlbGVtc31cIi8+JztcclxuXHJcbiAgICBpbmRleCA9IEluZmluaXR5O1xyXG4gICAgZWxlbXMgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgc3VwZXIob3B0cyk7XHJcblxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgYXJncyxcclxuICAgICAgICBhcmdzOiB7IHZhbHVlIH1cclxuICAgICAgfSA9IHRoaXM7XHJcbiAgICAgIGxldCB3YXNEZWZhdWx0O1xyXG5cclxuICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLmNoaWxkcmVuLm9iamVjdCgodmFsdWVzLCBjaGlsZCwgaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBhdHRycyxcclxuICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgfSA9IGNoaWxkO1xyXG5cclxuICAgICAgICBpZiAod2FzRGVmYXVsdCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5hbWUgIT09ICdkLWNhc2UnICYmIG5hbWUgIT09ICdkLWRlZmF1bHQnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcclxuICAgICAgICAgIHdhc0RlZmF1bHQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHZhbDtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdkLWRlZmF1bHQnKSB7XHJcbiAgICAgICAgICB2YWwgPSBhcmdzLnZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YWwgPSB0aGlzLmV2YWx1YXRlQW5kV2F0Y2goYXR0cnMuaWYgfHwgJ3t1bmRlZmluZWR9JywgKG5ld1ZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyh0aGlzLnZhbHVlcy4kW2ldLnZhbHVlLCBuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLiRbaV0udmFsdWUgPSBuZXdWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpID4gdGhpcy5pbmRleCkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy52YWx1ZXMuZmluZCgoeyB2YWx1ZSB9KSA9PiAoXHJcbiAgICAgICAgICAgICAgdGhpcy5lcXVhbHModmFsdWUsIGFyZ3MudmFsdWUpXHJcbiAgICAgICAgICAgICkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGZvdW5kLmtleTtcclxuICAgICAgICAgICAgICB0aGlzLmVsZW1zID0gZm91bmQudmFsdWUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVxdWFscyh2YWwsIHZhbHVlKSAmJiB0aGlzLmluZGV4ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XHJcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZXMucHVzaCh7XHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgICB2YWx1ZTogdmFsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sIG5ldyBBcnIoW10pKTtcclxuICAgIH1cclxuXHJcbiAgICBhZnRlckNvbnN0cnVjdCgpIHtcclxuICAgICAgdGhpcy53YXRjaEFyZ3MoJ3ZhbHVlJywgKG5ld1ZhbHVlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goKHsgbmFtZSwgdmFsdWUsIGNoaWxkcmVuIH0sIGkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHZhbCA9IG5hbWUgPT09ICdkLWRlZmF1bHQnXHJcbiAgICAgICAgICAgID8gbmV3VmFsdWVcclxuICAgICAgICAgICAgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5lcXVhbHModmFsLCBuZXdWYWx1ZSkgJiYgdGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGVxdWFscyh2YWx1ZTEsIHZhbHVlMikge1xyXG4gICAgICByZXR1cm4gbmV3IFN1cGVyKHZhbHVlMSkuZXF1YWxzKHZhbHVlMik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2Qtc3dpdGNoJyxcclxuICAgIHZhbHVlOiBEU3dpdGNoXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBpc05pbCB9IGZyb20gJy4uL2hlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFRleHQoQmxvY2spIHtcclxuICBjbGFzcyBEVGV4dCBleHRlbmRzIEJsb2NrIHtcclxuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZC1lbGVtZW50cyB2YWx1ZT1cIntbeyBuYW1lOiBcXCcjdGV4dFxcJywgdmFsdWU6IHRleHQgfV19XCIvPic7XHJcblxyXG4gICAgdGV4dCA9ICcnO1xyXG5cclxuICAgIGFmdGVyQ29uc3RydWN0KCkge1xyXG4gICAgICB0aGlzLnRleHQgPSBpc05pbCh0aGlzLmFyZ3MudmFsdWUpID8gJycgOiB0aGlzLmFyZ3MudmFsdWU7XHJcblxyXG4gICAgICB0aGlzLndhdGNoQXJncygndmFsdWUnLCAobmV3VmFsdWUpID0+IHtcclxuICAgICAgICB0aGlzLnRleHQgPSBpc05pbChuZXdWYWx1ZSkgPyAnJyA6IG5ld1ZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC10ZXh0JyxcclxuICAgIHZhbHVlOiBEVGV4dFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQXR0cihNaXhpbikge1xyXG4gIGNsYXNzIERBdHRyIGV4dGVuZHMgTWl4aW4ge1xyXG4gICAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcclxuXHJcbiAgICAgIG5ld1ZhbHVlID0gbmV3IFN1cGVyKG5ld1ZhbHVlKS4kO1xyXG5cclxuICAgICAgbmV3IFN1cGVyKG9sZFZhbHVlKS5mb3JFYWNoKCh2YWx1ZSwgcHJvcCkgPT4ge1xyXG4gICAgICAgIGlmICghbmV3VmFsdWVbcHJvcF0pIHtcclxuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cihwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBlbGVtLmF0dHIobmV3VmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLWF0dHInLFxyXG4gICAgdmFsdWU6IERBdHRyXHJcbiAgfTtcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREJpbmQoTWl4aW4pIHtcclxuICBjbGFzcyBEQmluZCBleHRlbmRzIE1peGluIHtcclxuICAgIGFmdGVyVXBkYXRlKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0aGlzLm9mZikge1xyXG4gICAgICAgIHRoaXMub2ZmKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMubWF0Y2hbMF0sIHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1iaW5kJyxcclxuICAgIHZhbHVlOiBEQmluZFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XHJcbmltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nLCBpdGVyYXRlIH0gZnJvbSAnLi4vaGVscGVycyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQ2xhc3MoTWl4aW4pIHtcclxuICBjbGFzcyBEQ2xhc3MgZXh0ZW5kcyBNaXhpbiB7XHJcbiAgICBjbGFzc2VzID0gW107XHJcblxyXG4gICAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGVsZW0sXHJcbiAgICAgICAgY2xhc3Nlc1xyXG4gICAgICB9ID0gdGhpcztcclxuICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IFtdO1xyXG5cclxuICAgICAgbmV3VmFsdWUgPSBuZXcgU3VwZXIobmV3VmFsdWUpLiQ7XHJcblxyXG4gICAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNBcnJheShuZXdWYWx1ZSkpIHtcclxuICAgICAgICBpdGVyYXRlKGNsYXNzZXMsIChjbHMpID0+IHtcclxuICAgICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKGNscykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpdGVyYXRlKG5ld1ZhbHVlLCAoY2xzKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoY2xzKSkge1xyXG4gICAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcclxuICAgICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGl0ZXJhdGUoY2xhc3NlcywgKGNscykgPT4ge1xyXG4gICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCAhbmV3VmFsdWVbY2xzXSkge1xyXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaXRlcmF0ZShuZXdWYWx1ZSwgKHZhbCwgY2xzKSA9PiB7XHJcbiAgICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xyXG4gICAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY2xhc3NlcyA9IG5ld0NsYXNzZXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtY2xhc3MnLFxyXG4gICAgdmFsdWU6IERDbGFzc1xyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi9oZWxwZXJzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRFbGVtKE1peGluKSB7XHJcbiAgY2xhc3MgREVsZW0gZXh0ZW5kcyBNaXhpbiB7XHJcbiAgICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgIHN1cGVyKG9wdHMpO1xyXG5cclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGJsb2NrLFxyXG4gICAgICAgIGVsZW1cclxuICAgICAgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZU9uY2UoKTtcclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlKGVsZW0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIGJsb2NrW3ZhbHVlXSA9IGVsZW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1lbGVtJyxcclxuICAgIHZhbHVlOiBERWxlbVxyXG4gIH07XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREhpZGUoTWl4aW4pIHtcclxuICBjbGFzcyBESGlkZSBleHRlbmRzIE1peGluIHtcclxuICAgIGFmdGVyVXBkYXRlKHZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcclxuXHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIGVsZW0uaGlkZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW0uc2hvdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtaGlkZScsXHJcbiAgICB2YWx1ZTogREhpZGVcclxuICB9O1xyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRPbihNaXhpbikge1xyXG4gIGNsYXNzIERPbiBleHRlbmRzIE1peGluIHtcclxuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgc3VwZXIob3B0cyk7XHJcblxyXG4gICAgICB0aGlzLmVsZW0ub24odGhpcy5tYXRjaFswXSwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZXZhbHVhdGVPbmNlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLW9uJyxcclxuICAgIHZhbHVlOiBET25cclxuICB9O1xyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRTaG93KE1peGluKSB7XHJcbiAgY2xhc3MgRFNob3cgZXh0ZW5kcyBNaXhpbiB7XHJcbiAgICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xyXG4gICAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBlbGVtLnNob3coKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtLmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLXNob3cnLFxyXG4gICAgdmFsdWU6IERTaG93XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRTdHlsZShNaXhpbikge1xyXG4gIGNsYXNzIERTdHlsZSBleHRlbmRzIE1peGluIHtcclxuICAgIGFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XHJcblxyXG4gICAgICBuZXdWYWx1ZSA9IG5ldyBTdXBlcihuZXdWYWx1ZSkuJDtcclxuXHJcbiAgICAgIG5ldyBTdXBlcihvbGRWYWx1ZSkuZm9yRWFjaCgodmFsdWUsIHByb3ApID0+IHtcclxuICAgICAgICBpZiAoIW5ld1ZhbHVlW3Byb3BdKSB7XHJcbiAgICAgICAgICBlbGVtLnJlbW92ZUNTUyhwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBlbGVtLmNzcyhuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2Qtc3R5bGUnLFxyXG4gICAgdmFsdWU6IERTdHlsZVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgaXNOaWwgfSBmcm9tICcuLi9oZWxwZXJzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRUZXh0KE1peGluKSB7XHJcbiAgY2xhc3MgRFRleHQgZXh0ZW5kcyBNaXhpbiB7XHJcbiAgICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xyXG4gICAgICB0aGlzLmVsZW0udGV4dChcclxuICAgICAgICBpc05pbCh2YWx1ZSlcclxuICAgICAgICAgID8gJydcclxuICAgICAgICAgIDogYCR7IHZhbHVlIH1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtdGV4dCcsXHJcbiAgICB2YWx1ZTogRFRleHRcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi4vU3dpdGNoZXInO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5jb25zdCBsaXN0ZW5lclN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsICdpbnB1dCcpXG4gIC5jYXNlKCdmb3JtJywgJ2lucHV0LCBjaGFuZ2UnKVxuICAuY2FzZSgnc2VsZWN0JywgJ2NoYW5nZScpXG4gIC5jYXNlKCdpbnB1dCcsICh0eXBlKSA9PiAoXG4gICAgdHlwZSA9PT0gJ3JhZGlvJ1xuICAgIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICB8fCB0eXBlID09PSAnY29sb3InXG4gICAgfHwgdHlwZSA9PT0gJ2ZpbGUnXG4gICAgICA/ICdjaGFuZ2UnXG4gICAgICA6ICdpbnB1dCdcbiAgKSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRWYWxpZGF0ZShNaXhpbikge1xuICBjbGFzcyBEVmFsaWRhdGUgZXh0ZW5kcyBNaXhpbiB7XG4gICAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICBzdXBlcihvcHRzKTtcblxuICAgICAgY29uc3QgeyBlbGVtIH0gPSB0aGlzO1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gdGhpcy5ldmFsdWF0ZU9uY2UoKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICBlbGVtLnZhbGlkYXRlKHZhbGlkYXRvcik7XG4gICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICBlbGVtLm9uKGxpc3RlbmVyU3dpdGNoZXIoZWxlbS5uYW1lLCBbZWxlbS5wcm9wKCd0eXBlJyldKSwgKCkgPT4ge1xuICAgICAgICAgIGVsZW0udmFsaWRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC12YWxpZGF0ZScsXG4gICAgdmFsdWU6IERWYWxpZGF0ZVxuICB9O1xufVxuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcclxuaW1wb3J0IHsgc3dpdGNoZXIgfSBmcm9tICcuLi9Td2l0Y2hlcic7XHJcbmltcG9ydCB7IGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTmlsIH0gZnJvbSAnLi4vaGVscGVycyc7XHJcblxyXG5jb25zdCBwcm9wU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKHR5cGUsIGVsZW0pID0+IChcclxuICBlbGVtLmhhc0F0dHIoJ2NvbnRlbnRlZGl0YWJsZScpIHx8IGVsZW0uaGFzQXR0cignY29udGVudEVkaXRhYmxlJylcclxuICAgID8gJ3RleHQnXHJcbiAgICA6ICd2YWx1ZSdcclxuKSlcclxuICAuY2FzZSgnc2VsZWN0JywgKHR5cGUsIGVsZW0pID0+IChcclxuICAgIGVsZW0uaGFzQXR0cignbXVsdGlwbGUnKVxyXG4gICAgICA/ICdtdWx0aXBsZS1zZWxlY3QnXHJcbiAgICAgIDogJ3ZhbHVlJ1xyXG4gICkpXHJcbiAgLmNhc2UoJ2lucHV0JywgKHR5cGUpID0+IHtcclxuICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcclxuICAgICAgcmV0dXJuICdmaWxlcyc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xyXG4gICAgICA/ICdjaGVja2VkJ1xyXG4gICAgICA6ICd2YWx1ZSc7XHJcbiAgfSk7XHJcbmNvbnN0IHNldFZhbHVlU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKHZhbHVlKSA9PiB2YWx1ZSlcclxuICAuY2FzZSgnaW5wdXQnLCAodmFsdWUsIHR5cGUsIGlucHV0VmFsdWUpID0+IHtcclxuICAgIGlmICh0eXBlICE9PSAncmFkaW8nICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gaW5wdXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSAhPT0gLTE7XHJcbiAgfSk7XHJcbmNvbnN0IGdldFZhbHVlU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKHZhbHVlKSA9PiB2YWx1ZSlcclxuICAuY2FzZSgnc2VsZWN0JywgKHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlLCB2YWx1ZXMsIGVsZW0sIG9wdGlvbnMpID0+IHtcclxuICAgIGlmICghZWxlbS5oYXNBdHRyKCdtdWx0aXBsZScpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3B0aW9uc1xyXG4gICAgICAub2JqZWN0KCh2YWx1ZXMsIHsgc2VsZWN0ZWQsIHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgdmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xyXG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgW10pXHJcbiAgICAgIC4kO1xyXG4gIH0pXHJcbiAgLmNhc2UoJ2lucHV0JywgKHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlLCB2YWx1ZXMsIGVsZW0sIG9wdGlvbnMsIGluaXQpID0+IHtcclxuICAgIGlmICh0eXBlICE9PSAncmFkaW8nICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgID8gaW5wdXRWYWx1ZVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXZhbHVlICYmIGluaXQpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKSA9PT0gLTFcclxuICAgICAgICAgID8gbmV3IEFycih2YWx1ZXMpLmNvbmNhdChpbnB1dFZhbHVlKS4kXHJcbiAgICAgICAgICA6IHZhbHVlcztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFtpbnB1dFZhbHVlXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzQXJyYXkodmFsdWVzKSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgLi4ubmV3IEFycih2YWx1ZXMpLnNsaWNlKDAsIGluZGV4KS4kLFxyXG4gICAgICAgIC4uLm5ldyBBcnIodmFsdWVzKS5zbGljZShpbmRleCArIDEpLiRcclxuICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG4gIH0pO1xyXG5jb25zdCBsaXN0ZW5lclN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsICdpbnB1dCcpXHJcbiAgLmNhc2UoJ3NlbGVjdCcsICdjaGFuZ2UnKVxyXG4gIC5jYXNlKCdpbnB1dCcsICh0eXBlKSA9PiAoXHJcbiAgICB0eXBlID09PSAncmFkaW8nXHJcbiAgICB8fCB0eXBlID09PSAnY2hlY2tib3gnXHJcbiAgICB8fCB0eXBlID09PSAnY29sb3InXHJcbiAgICB8fCB0eXBlID09PSAnZmlsZSdcclxuICAgICAgPyAnY2hhbmdlJ1xyXG4gICAgICA6ICdpbnB1dCdcclxuICApKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRWYWx1ZShNaXhpbikge1xyXG4gIGNsYXNzIERWYWx1ZSBleHRlbmRzIE1peGluIHtcclxuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgc3VwZXIob3B0cyk7XHJcblxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgJCQ6IHsgX3ZhbHVlIH0sXHJcbiAgICAgICAgYmxvY2ssXHJcbiAgICAgICAgZWxlbSxcclxuICAgICAgICBub2RlXHJcbiAgICAgIH0gPSB0aGlzO1xyXG4gICAgICBjb25zdCBuYW1lID0gZWxlbS5uYW1lO1xyXG4gICAgICBjb25zdCB0eXBlID0gZWxlbS5wcm9wKCd0eXBlJyk7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZU9uY2UoKTtcclxuICAgICAgbGV0IGluaXRpYWxTY29wZVZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMucHJvcCA9IHByb3BTd2l0Y2hlcihuYW1lLCBbdHlwZSwgZWxlbV0pO1xyXG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIHRoaXMub3B0aW9ucyA9IGVsZW0uZmluZCgnb3B0aW9uJyk7XHJcblxyXG4gICAgICBpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgaW5pdGlhbFNjb3BlVmFsdWUgPSBibG9jay4kJC5ldmFsdWF0ZShgeyR7IF92YWx1ZSB9fWAsIChuZXdWYWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgIHRoaXMuc2V0UHJvcChuZXdWYWx1ZSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGluaXRpYWxFbGVtVmFsdWUgPSB0aGlzLmdldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUsIHRydWUpO1xyXG4gICAgICBjb25zdCBpc0luaXRpYWxTY29wZVZhbHVlTnVsbCA9IGlzTmlsKGluaXRpYWxTY29wZVZhbHVlKTtcclxuICAgICAgY29uc3QgaXNDaGVja2JveCA9IHR5cGUgPT09ICdjaGVja2JveCc7XHJcblxyXG4gICAgICBpZiAoaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgfHwgaXNDaGVja2JveCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbEVsZW1WYWx1ZTtcclxuICAgICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XHJcblxyXG4gICAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xyXG4gICAgICAgICAgdGhpcy5zZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBpbml0aWFsU2NvcGVWYWx1ZTtcclxuICAgICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtLm9uKGxpc3RlbmVyU3dpdGNoZXIobmFtZSwgW3R5cGVdKSwgKGUpID0+IHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IG5vZGUpIHtcclxuICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5nZXRQcm9wKHRoaXMuY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZVNjb3BlKCkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgYmxvY2ssXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgY3VycmVudFZhbHVlXHJcbiAgICAgIH0gPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUoY3VycmVudFZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBibG9ja1t2YWx1ZV0gPSBjdXJyZW50VmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRQcm9wKHZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBlbGVtLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgcHJvcCxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIG5vZGUsXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICB9ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChwcm9wID09PSAndGV4dCcpIHtcclxuICAgICAgICBlbGVtLnRleHQodmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKSB7XHJcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcclxuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2Yob3B0aW9uLnZhbHVlKSAhPT0gLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbS5wcm9wKHByb3AsIHNldFZhbHVlU3dpdGNoZXIobmFtZSwgW3ZhbHVlLCB0eXBlLCBub2RlLnZhbHVlXSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UHJvcCh2YWx1ZXMsIGluaXQpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGVsZW0sXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBwcm9wLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgIH0gPSB0aGlzO1xyXG5cclxuICAgICAgcmV0dXJuIHByb3AgPT09ICd0ZXh0J1xyXG4gICAgICAgID8gZWxlbS50ZXh0KClcclxuICAgICAgICA6IGdldFZhbHVlU3dpdGNoZXIobmFtZSwgW2VsZW0ucHJvcChwcm9wKSwgdHlwZSwgbm9kZS52YWx1ZSwgdmFsdWVzLCBlbGVtLCBvcHRpb25zLCBpbml0XSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtdmFsdWUnLFxyXG4gICAgdmFsdWU6IERWYWx1ZVxyXG4gIH07XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgQmxvY2tcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEJsb2NrIGNsYXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFyciB9IGZyb20gJy4vQXJyJztcclxuaW1wb3J0IHsgZG9jLCBFbGVtIH0gZnJvbSAnLi9FbGVtJztcclxuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9TdHInO1xyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xyXG5pbXBvcnQge1xyXG4gIGl0ZXJhdGUsIHZhbGlkYXRlLFxyXG4gIGlzRnVuY3Rpb24sIGlzTmlsLCBpc1VuZGVmaW5lZFxyXG59IGZyb20gJy4vaGVscGVycyc7XHJcbmltcG9ydCAqIGFzIEJsb2NrcyBmcm9tICcuL2Jsb2Nrcyc7XHJcbmltcG9ydCAqIGFzIE1peGlucyBmcm9tICcuL21peGlucyc7XHJcbmltcG9ydCB7IGh0bWxBbGxvd2VkVGFnU3ltYm9scywgaHRtbEFsbG93ZWRBdHRyU3ltYm9scyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IG1hcmt1cFRvSlNPTiBmcm9tICcuL2hlbHBlcnMvbWFya3VwVG9KU09OJztcclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgV2F0Y2hlclxyXG4gKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gTmV3IHZhbHVlLlxyXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgV3JhcHBlclxyXG4gKiBAcGFyYW0ge0Jsb2NrfSBCbG9jayBjbGFzcyB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7QmxvY2t9IE5ldyBCbG9jayBjbGFzcy5cclxuICovXHJcblxyXG5jb25zdCByb290QmxvY2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuY29uc3Qgcm9vdE1peGlucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmNvbnN0IGlzUHJvdG90eXBlT2YgPSB7fS5pc1Byb3RvdHlwZU9mO1xyXG5jb25zdCB0YWdOYW1lID0gbmV3IFJlZ0V4cChgXiR7IGh0bWxBbGxvd2VkVGFnU3ltYm9scyB9JGAsICdpJyk7XHJcbmNvbnN0IGF0dHJOYW1lID0gbmV3IFJlZ0V4cChgXiR7IGh0bWxBbGxvd2VkQXR0clN5bWJvbHMgfSRgKTtcclxuY29uc3QgZXhwcmVzc2lvblJlZ0V4cCA9IC9eXFx7W1xcc1xcU10rXFx9JC87XHJcbmNvbnN0IHsgZG9jdW1lbnQgfSA9IGdsb2JhbDtcclxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5sZXQgb25FdmFsRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgY29uc29sZS5lcnJvcihgRXZhbCBlcnJvciAoZXZhbHVhdGluZyBcIiR7IGVyci5leHByZXNzaW9uIH1cIiBpbiBjb250ZXh0IG9mIGJsb2NrIFwiJHsgZXJyLmJsb2NrLiQkLm5hbWUgfVwiKTpgLCBlcnIpO1xyXG59O1xyXG5sZXQgZXZhbE1vZGU7XHJcbmxldCBnZXR0aW5nO1xyXG5sZXQgY2hhbmdlZDtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgQmxvY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEVsZW1lbnQgb3B0aW9ucy5cclxuICogQHJldHVybnMge0Jsb2NrfSBJbnN0YW5jZSBvZiBCbG9jay5cclxuICogQGRlc2NyaXB0aW9uIENsYXNzIGZvciBkeW5hbWljIHRlbXBsYXRpbmcuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCB7IEQsIEJsb2NrLCBpbml0QXBwLCByZWdpc3RlckJsb2NrIH0gZnJvbSAnZHdheW5lJztcclxuICpcclxuICogY2xhc3MgQXBwIGV4dGVuZHMgQmxvY2sge1xyXG4gKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8SGVsbG8gdGV4dD1cInt0ZXh0fVwiLz4nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKGFyZ3MsIGNoaWxkcmVuKSB7XHJcbiAqICAgICBzdXBlcihhcmdzLCBjaGlsZHJlbik7XHJcbiAqXHJcbiAqICAgICB0aGlzLnRleHQgPSAnd29ybGQgKDApJztcclxuICogICAgIHRoaXMudGltZXMgPSAwO1xyXG4gKlxyXG4gKiAgICAgdGhpcy5zZXRJbnRlcnZhbCgpO1xyXG4gKiAgIH1cclxuICpcclxuICogICBzZXRJbnRlcnZhbCgpIHtcclxuICogICAgIEQoMTAwMCkuaW50ZXJ2YWwoKCkgPT4ge1xyXG4gKiAgICAgICB0aGlzLnRleHQgPSBgd29ybGQgKCR7ICsrdGhpcy50aW1lcyB9KWA7XHJcbiAqICAgICB9KTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogY2xhc3MgSGVsbG8gZXh0ZW5kcyBCbG9jayB7XHJcbiAqICAgc3RhdGljIHRlbXBsYXRlID0gJ0hlbGxvLCA8ZC10ZXh0IHZhbHVlPVwie2FyZ3MudGV4dH1cIi8+ISc7XHJcbiAqIH1cclxuICpcclxuICogQmxvY2suQXBwID0gQXBwO1xyXG4gKiBCbG9jay5IZWxsbyA9IEhlbGxvO1xyXG4gKlxyXG4gKiBpbml0QXBwKCk7XHJcbiAqL1xyXG5jbGFzcyBCbG9jayB7XHJcbiAgc3RhdGljIF9ibG9ja3MgPSBPYmplY3QuY3JlYXRlKHJvb3RCbG9ja3MpO1xyXG4gIHN0YXRpYyBfbWl4aW5zID0gT2JqZWN0LmNyZWF0ZShyb290TWl4aW5zKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gW0Jsb2NrLmNvbGxhcHNlV2hpdGVTcGFjZSA9IHRydWVdXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBJZiB0aGUgd2hpdGVzcGFjZSBiZXR3ZWVuIGh0bWwgZWxlbWVudHMgYW5kXHJcbiAgICogaW4gdGhlIHN0YXJ0IGFuZCB0aGUgZW5kIGluc2lkZSB0aGUgdGFnIHNob3VsZCBiZSBvbWl0dGVkIGR1cmluZyBwYXJzaW5nLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjb2xsYXBzZVdoaXRlU3BhY2UgPSB0cnVlO1xyXG5cclxuICBzdGF0aWMgZ2V0IG9uRXZhbEVycm9yKCkge1xyXG4gICAgcmV0dXJuIG9uRXZhbEVycm9yO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNldCBvbkV2YWxFcnJvcihsaXN0ZW5lcikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XHJcbiAgICAgIG9uRXZhbEVycm9yID0gbGlzdGVuZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvbkV2YWxFcnJvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0QmxvY2tzKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdXBlcih7IC4uLnRoaXMuX2Jsb2NrcyB9KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRNaXhpbnMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN1cGVyKHsgLi4udGhpcy5fbWl4aW5zIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBCbG9jay5yZWdpc3RlclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG9yIG1peGluIG5hbWUuXHJcbiAgICogQHBhcmFtIHtCbG9ja3xNaXhpbn0gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBCbG9jayBvciBNaXhpbi5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgYmxvY2sgb3IgbWl4aW4gaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGlzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyByZWdpc3RlcihuYW1lLCBTdWJjbGFzcykge1xyXG4gICAgY29uc3QgX3RoaXMgPSBuZXcgU3VwZXIodGhpcyk7XHJcblxyXG4gICAgaWYgKCFfdGhpcy5oYXNPd24oJ19ibG9ja3MnKSkge1xyXG4gICAgICBTdWJjbGFzcy5fYmxvY2tzID0gT2JqZWN0LmNyZWF0ZShfdGhpcy5wcm90bygpLiQuX2Jsb2Nrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFfdGhpcy5oYXNPd24oJ19taXhpbnMnKSkge1xyXG4gICAgICBTdWJjbGFzcy5fbWl4aW5zID0gT2JqZWN0LmNyZWF0ZShfdGhpcy5wcm90bygpLiQuX21peGlucyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBfYmxvY2tzLFxyXG4gICAgICBfbWl4aW5zXHJcbiAgICB9ID0gdGhpcztcclxuXHJcbiAgICBpZiAoIWlzSW5zdGFuY2VPZkJsb2NrKFN1YmNsYXNzKSAmJiAhaXNJbnN0YW5jZU9mTWl4aW4oU3ViY2xhc3MpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgY2xhc3MgZG9lcyBub3QgZXh0ZW5kIEJsb2NrIG9yIE1peGluIGFuZCB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5yZWdpc3RlcilgKTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNJbnN0YW5jZU9mQmxvY2soU3ViY2xhc3MpKSB7XHJcbiAgICAgIGlmIChyb290QmxvY2tzW25hbWVdKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBibG9jayBpcyBhIGJ1aWx0LWluIGJsb2NrIHNvIHRoZSBibG9jayB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5yZWdpc3RlcilgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRhZ05hbWUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgTmFtZSBcIiR7IG5hbWUgfVwiIGlzIG5vdCBhbGxvd2VkIGZvciBibG9ja3Mgc28gdGhlIGJsb2NrIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLnJlZ2lzdGVyKWApO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFN1YmNsYXNzLl9odG1sID0gZGVlcENsb25lQ2hpbGRyZW4oXHJcbiAgICAgICAgbWFya3VwVG9KU09OKFxyXG4gICAgICAgICAgYCR7IFN1YmNsYXNzLnRlbXBsYXRlIHx8ICcnIH1gLFxyXG4gICAgICAgICAgU3ViY2xhc3MuY29sbGFwc2VXaGl0ZVNwYWNlXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgX2Jsb2Nrc1tuYW1lXSA9IFN1YmNsYXNzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHJvb3RNaXhpbnNbbmFtZV0pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIG1peGluIGlzIGEgYnVpbHQtaW4gbWl4aW4gc28gdGhlIG1peGluIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLnJlZ2lzdGVyKWApO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghYXR0ck5hbWUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgTmFtZSBcIiR7IG5hbWUgfVwiIGlzIG5vdCBhbGxvd2VkIGZvciBtaXhpbnMgc28gdGhlIG1peGluIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLnJlZ2lzdGVyKWApO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFN1YmNsYXNzLl9tYXRjaCA9IG5ldyBSZWdFeHAoYF4keyBuZXcgU3RyKG5hbWUpLmVzY2FwZVJlZ0V4cCgpLiQgfSg/Oi0oW1xcXFxzXFxcXFNdKykpPyRgKTtcclxuXHJcbiAgICAgIF9taXhpbnNbbmFtZV0gPSBTdWJjbGFzcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge1N0cmluZ30gQmxvY2sudGVtcGxhdGVcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgdGVtcGxhdGUuXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sud3JhcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1dyYXBwZXJ9IGZ1bmMgLSBGdW5jdGlvbiB0aGF0IHJldHVybnMgd3JhcHBlZCBibG9jay5cclxuICAgKiBAcmV0dXJucyB7QmxvY2t9IE5ldyBibG9jay5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBibG9ja3MgaW50byBhbm90aGVyIGJsb2Nrcy5cclxuICAgKiBJdCBpcyBjb25zaWRlcmVkIGJlc3QgcHJhY3RpY2UgdG8ganVzdCBleHRlbmRzIHRoZSBvbGQgYmxvY2sgd2l0aCBhIG5ldyBvbmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdj4xMjM8L2Rpdj4nO1xyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIE15QmxvY2sud3JhcCgoQmxvY2spID0+IHtcclxuICAgKiAgIHJldHVybiBjbGFzcyBleHRlbmRzIEJsb2NrIHtcclxuICAgKiAgICAgc3RhdGljIHRlbXBsYXRlID0gYDxzZWN0aW9uIGNsYXNzPVwid3JhcHBlclwiPiR7IEJsb2NrLnRlbXBsYXRlIH08L3NlY3Rpb24+YDtcclxuICAgKlxyXG4gICAqICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgKiAgICAgICB0aGlzLmFkZGl0aW9uYWxWYXIgPSAnYWRkaXRpb25hbCc7XHJcbiAgICogICAgIH1cclxuICAgKiAgIH07XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgc3RhdGljIHdyYXAoZnVuYykge1xyXG4gICAgdmFsaWRhdGUoW2Z1bmNdLCBbJ2Z1bmN0aW9uJ10pO1xyXG5cclxuICAgIHJldHVybiBmdW5jKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBhcmdzOiBvcmlnaW5hbEFyZ3MsXHJcbiAgICAgIGNoaWxkcmVuLFxyXG4gICAgICBwYXJlbnQsXHJcbiAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICBwYXJlbnRTY29wZVxyXG4gICAgfSA9IG9wdHM7XHJcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gbmV3IEFycihbXSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlciB7QmxvY2t9IEJsb2NrIyRcclxuICAgICAgICogQHR5cGUge0Jsb2NrfVxyXG4gICAgICAgKiBAcHVibGljXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzLlxyXG4gICAgICAgKi9cclxuICAgICAgJDoge1xyXG4gICAgICAgIHZhbHVlOiB0aGlzXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayMkJFxyXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmdzIC0gUHJpdmF0ZSBhcmdzIHNjb3BlLlxyXG4gICAgICAgKiBAcHJvcGVydHkge0Fycn0gY2hpbGRyZW4gLSBDaGlsZCBibG9ja3MuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7QXJyfSBtaXhpbnMgLSBDaGlsZCBtaXhpbnMuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbGVtcyAtIEVsZW1lbnRzIGNvbm5lY3RlZCB0byB0aGUgYmxvY2suXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gZWxlbXMucGFyZW50IC0gUGFyZW50IGVsZW1lbnQuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gZWxlbXMuc3RhcnQgLSBTdGFydCBjb21tZW50IGJsb2NrLlxyXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IGVsZW1zLmVuZCAtIEVuZCBjb21tZW50IGJsb2NrLlxyXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IGVsZW1zLmNvbnRlbnQgLSBDb250ZW50IGVsZW1lbnRzLlxyXG4gICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBldmFsdWF0ZSAtIEV2YWx1YXRlIGZ1bmN0aW9uLlxyXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gZ2xvYmFsIC0gUHJpdmF0ZSBnbG9iYWwgc2NvcGUuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsb2NhbHMgLSBQcml2YXRlIGxvY2FscyBzY29wZS5cclxuICAgICAgICogQHByb3BlcnR5IHtBcnJ9IHdhdGNoZXJzVG9SZW1vdmUgLSBXYXRjaGVycyB0byByZW1vdmUgYmVmb3JlIHJlbW92aW5nIGVsZW1lbnQuXHJcbiAgICAgICAqL1xyXG4gICAgICAkJDoge1xyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRTY29wZSxcclxuICAgICAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICAgICAgbnM6IG5ldyBTdXBlcih0aGlzKS5wcm90bygpLiQuY29uc3RydWN0b3IsXHJcbiAgICAgICAgICBjaGlsZHJlbjogbmV3IEFycihbXSksXHJcbiAgICAgICAgICBtaXhpbnM6IG5ldyBBcnIoW10pLFxyXG4gICAgICAgICAgZWxlbXM6IHtcclxuICAgICAgICAgICAgc3RhcnQ6IGRvYy5jcmVhdGVDb21tZW50KGAgJHsgbmFtZSB9OiBzdGFydCBgKSxcclxuICAgICAgICAgICAgZW5kOiBkb2MuY3JlYXRlQ29tbWVudChgICR7IG5hbWUgfTogZW5kIGApLFxyXG4gICAgICAgICAgICBjb250ZW50OiBuZXcgRWxlbSgpLFxyXG4gICAgICAgICAgICBwYXJlbnRcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxyXG4gICAgICAgICAgZXZhbHVhdGU6IChleHByZXNzaW9uLCBvbkNoYW5nZSwgaW5zdGFuY2UsIGZvckRFbGVtZW50cywgZm9yREl0ZW0sIGZvckRFYWNoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZXhwcmVzc2lvblJlZ0V4cC50ZXN0KGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24gfHwgdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yREVsZW1lbnRzID0gISFmb3JERWxlbWVudHM7XHJcbiAgICAgICAgICAgIGZvckRJdGVtID0gISFmb3JESXRlbTtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSgvXlxce3xcXH0kL2csICcnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gKG5hbWUgPT09ICcjZC1pdGVtJyAmJiAhZm9yREl0ZW0pIHx8IGZvckRFYWNoXHJcbiAgICAgICAgICAgICAgPyAoZm9yREVhY2ggfHwgdGhpcykuJCQuc2NvcGVcclxuICAgICAgICAgICAgICA6IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tbmV3LWZ1bmM6IDAgKi9cclxuICAgICAgICAgICAgY29uc3QgeyB3YXRjaGVyc1RvUmVtb3ZlIH0gPSBpbnN0YW5jZSA/IGluc3RhbmNlLiQkIDoge307XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBuZXcgRnVuY3Rpb24oXHJcbiAgICAgICAgICAgICAgJycsXHJcbiAgICAgICAgICAgICAgJ3dpdGgoZG9jdW1lbnQuRHdheW5lU3RvcmUpeyQkLmV4cHI9ZXZhbChcIiQkLmV4cHI9XCIrJCQuZXhwcik7cmV0dXJuICQkLmV4cHJ9J1xyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcclxuICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICBpZiAob25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGV2YWxNb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGdldHRpbmcgPSBuZXcgQXJyKFtdKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHN0b3JlLiQkLmV4cHIgPSBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgIGRvY3VtZW50LkR3YXluZVN0b3JlID0gc3RvcmU7XHJcblxyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob25FdmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgZXJyLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgICBlcnIuYmxvY2sgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICBvbkV2YWxFcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFdhdGNoZXJzID0gbmV3IEFycihbXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2V0dGluZy5mb3JFYWNoKCh3YXRjaGVycykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc3VsdCA9IGV2YWx1YXRlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHQgIT09IHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3UmVzdWx0LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlckJsb2NrID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvckRFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXJzXHJcbiAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyLm9uUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsV2F0Y2hlcnMuZm9yRWFjaCgod2F0Y2hlckJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICB9ID0gd2F0Y2hlckJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXgxID0gd2F0Y2hlcnNUb1JlbW92ZS5pbmRleE9mKHdhdGNoZXJCbG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleDIgPSB3YXRjaGVycy5pbmRleE9mKHdhdGNoZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleDEgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXJzVG9SZW1vdmUuc3BsaWNlKGluZGV4MSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnMuc3BsaWNlKGluZGV4MiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICBsb2NhbFdhdGNoZXJzLnB1c2god2F0Y2hlckJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZS5wdXNoKHdhdGNoZXJCbG9jayk7XHJcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBldmFsTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZ2V0dGluZyA9IG5ldyBBcnIoW10pO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgc3RvcmUuJCQuZXhwciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnQuRHdheW5lU3RvcmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBhcmdzID0gbmV3IFN1cGVyKG9yaWdpbmFsQXJncykubWFwKCh2YWx1ZSwgYXJnKSA9PiB7XHJcbiAgICAgIGlmIChuYW1lID09PSAnZC1lYWNoJyAmJiAoXHJcbiAgICAgICAgYXJnID09PSAnaXRlbSdcclxuICAgICAgICB8fCBhcmcgPT09ICdpbmRleCdcclxuICAgICAgICB8fCBhcmcgPT09ICd1aWQnXHJcbiAgICAgICkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGZvckRFbGVtZW50cyA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJyAmJiBhcmcgPT09ICd2YWx1ZSc7XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuYXJnc1thcmddID0gdmFsdWU7XHJcbiAgICAgIH0sIHRoaXMsIGZvckRFbGVtZW50cywgZm9yREVsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLm5hbWUgPT09ICcjZC1pdGVtJyk7XHJcbiAgICB9KS4kO1xyXG5cclxuICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgbmV3IEFycihbXSk7XHJcbiAgICB0aGlzLmdsb2JhbCA9IE9iamVjdC5jcmVhdGUoXHJcbiAgICAgIHBhcmVudFNjb3BlXHJcbiAgICAgICAgPyBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLmdsb2JhbClcclxuICAgICAgICA6IG51bGxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy4kJC5lbGVtcy5zdGFydC4kWzBdLkR3YXluZUJsb2NrID0gdGhpcztcclxuICAgIHRoaXMuJCQuZWxlbXMuZW5kLiRbMF0uRHdheW5lQmxvY2sgPSB0aGlzO1xyXG5cclxuICAgIGlmIChwYXJlbnRCbG9jaykge1xyXG4gICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlckNvbnN0cnVjdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGNvbnN0cnVjdGlvbiAoaW5jbHVkaW5nIGFsbCBzY29wZXMpXHJcbiAgICogYnV0IGJlZm9yZSByZW5kZXJpbmcgdGhlIGJsb2NrIGFuZCBpdHMgY2hpbGRyZW4uXHJcbiAgICovXHJcbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyUmVuZGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAgICovXHJcbiAgYWZ0ZXJSZW5kZXIoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyUmVuZGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYmVmb3JlIHRoZSBibG9jayByZW1vdmFsLlxyXG4gICAqL1xyXG4gIGJlZm9yZVJlbW92ZSgpIHt9XHJcblxyXG4gIGV2YWx1YXRlQW5kV2F0Y2goZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudC4kJC5ldmFsdWF0ZShleHByZXNzaW9uLCBjYWxsYmFjaywgdGhpcyk7XHJcbiAgfVxyXG5cclxuICBldmFsdWF0ZU9uY2UoZXhwcmVzc2lvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50LiQkLmV2YWx1YXRlKGV4cHJlc3Npb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBCbG9jayNyZW1vdmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3QgZm9yY2luZyB0aGUgYmxvY2sgdG8gYmUgcmVtb3ZlZC4gQ2FsbHNcclxuICAgKiByZW1vdmUgbWV0aG9kIGZvciBhbGwgb2YgaXRzIGNoaWxkIGJsb2NrcyBhbmQgY2FsbHMgYmVmb3JlUmVtb3ZlIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHJlbW92ZShpc1BhcmVudFNpZ25hbCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBwYXJlbnRCbG9jayxcclxuICAgICAgY2hpbGRyZW4sXHJcbiAgICAgIG1peGlucyxcclxuICAgICAgZWxlbXM6IHtcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGVuZFxyXG4gICAgICB9LFxyXG4gICAgICB3YXRjaGVyc1RvUmVtb3ZlXHJcbiAgICB9ID0gdGhpcy4kJDtcclxuXHJcbiAgICByZW1vdmVXYXRjaGVycyh3YXRjaGVyc1RvUmVtb3ZlKTtcclxuXHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICBjaGlsZC5yZW1vdmUodHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBtaXhpbnMuZm9yRWFjaCgobWl4aW4pID0+IHtcclxuICAgICAgbWl4aW4ucmVtb3ZlKHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlUmVtb3ZlOmAsIGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBwYXJlbnRCbG9jaykge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XHJcblxyXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgcGFyZW50QmxvY2suJCQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5ldyBFbGVtKFtcclxuICAgICAgc3RhcnQsXHJcbiAgICAgIGNvbnRlbnQsXHJcbiAgICAgIGVuZFxyXG4gICAgXSkucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI3dhdGNoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBbYXJnc10gLSBWYXJzIHRvIHdhdGNoIChhcmdzLCBnbG9iYWwgb3IgbG9jYWwpLlxyXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlciAtIENhbGxlZCB3aGVuIHdhdGNoZWQgdmFycyBhcmUgY2hhbmdlZC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3YXRjaGluZyBmb3IgdmFycy4gSWYgbm8gdmFycyBwYXNzZWQgaW4gYXJndW1lbnRzXHJcbiAgICogYWxsIHZhcnMgYXJlIHRvIGJlIHdhdGNoZWQuIE90aGVyd2lzZSBzcGVjaWZpZWQgdmFycyB3aWxsIGJlIHdhdGNoZWQuXHJcbiAgICogV2F0Y2hlcnMgc2hvdWxkIG5vdCBiZSBwdXQgaW5zaWRlIHRoZSBjb25zdHJ1Y3Rvci4gSXQgaXMgY29uc2lkZXJlZCBiZXN0XHJcbiAgICogcHJhY3RpY2UgdG8gZG8gaXQgaW5zaWRlIHRoZSB7QGxpbmsgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3R9IG1ldGhvZC5cclxuICAgKiBOb3RlIHRoYXQgdGhlc2UgZXhwcmVzc2lvbnMgKHZhcnMsIGkuZS4gXCJhcmdzLmFyZ1wiKSBhcmUgbm90IHRvIGJlXHJcbiAgICogZXZhbHVhdGVkIHNvIHlvdSBjYW5ub3QgcHV0IHRoZXJlIHRoaW5ncyBsaWtlIFwiYVtiXVwiIG9yIGFueSBqcyBjb2RlLFxyXG4gICAqIG9ubHkgZXhwcmVzc2lvbnMgbGlrZSBcImFcIiwgXCJiXCIsIFwiYXJncy5hXCIsIFwiYXJncy5iXCIgYW5kIFwiZ2xvYmFsLmFcIiwgXCJnbG9iYWwuYlwiLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xyXG4gICAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXYgLz4nO1xyXG4gICAqXHJcbiAgICogICBhZnRlckNvbnN0cnVjdCgpIHtcclxuICAgKiAgICAgdGhpcy53YXRjaCgnYScsICgpID0+IHt9KTtcclxuICAgKiAgICAgdGhpcy53YXRjaCgnYXJncy5hJywgJ2dsb2JhbC5yJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoKCgpID0+IHt9KTtcclxuICAgKiAgIH1cclxuICAgKiB9XHJcbiAgICovXHJcbiAgd2F0Y2goKSB7XHJcbiAgICBjb25zdCB3YXRjaGVyID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICBpZiAoIWlzRnVuY3Rpb24od2F0Y2hlcikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGZvciAoY29uc3QgZ2xvYmFsIGluIHRoaXMuJCQuZ2xvYmFsKSB7XHJcbiAgICAgICAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xyXG4gICAgICAgIHRoaXMuJCQuZ2xvYmFsW2dsb2JhbF0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpdGVyYXRlKHRoaXMuJCQuYXJncywgKHsgd2F0Y2hlcnMgfSkgPT4ge1xyXG4gICAgICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gaXRlcmF0ZSh0aGlzLiQkLmxvY2FscywgKHsgd2F0Y2hlcnMgfSkgPT4ge1xyXG4gICAgICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXRlcmF0ZShhcmd1bWVudHMsICh2YXJpYWJsZSkgPT4ge1xyXG4gICAgICBpZiAodmFyaWFibGUgPT09IHdhdGNoZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhcmlhYmxlID0gYCR7IHZhcmlhYmxlIH1gO1xyXG5cclxuICAgICAgaWYgKC9eYXJnc1xcLi8udGVzdCh2YXJpYWJsZSkpIHtcclxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnJlcGxhY2UoL15hcmdzXFwuLywgJycpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuJCQuYXJnc1t2YXJpYWJsZV0pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuJCQuYXJnc1t2YXJpYWJsZV0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgvXmdsb2JhbFxcLi8udGVzdCh2YXJpYWJsZSkpIHtcclxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnJlcGxhY2UoL15nbG9iYWxcXC4vLCAnJyk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy4kJC5nbG9iYWxbdmFyaWFibGVdKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiQkLmdsb2JhbFt2YXJpYWJsZV0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy4kJC5sb2NhbHNbdmFyaWFibGVdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLiQkLmxvY2Fsc1t2YXJpYWJsZV0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI3dhdGNoQXJnc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gW2FyZ3NdIC0gQXJncyB0byB3YXRjaC5cclxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IHdhdGNoZXIgLSBDYWxsZWQgd2hlbiB3YXRjaGVkIGFyZ3MgYXJlIGNoYW5nZWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd2F0Y2hpbmcgZm9yIGFyZ3MuIElmIG5vIGFyZ3MgcGFzc2VkIGluIGFyZ3VtZW50c1xyXG4gICAqIGFsbCBhcmdzIGFyZSB0byBiZSB3YXRjaGVkLiBPdGhlcndpc2Ugc3BlY2lmaWVkIGFyZ3Mgd2lsbCBiZSB3YXRjaGVkLlxyXG4gICAqIFdhdGNoZXJzIHNob3VsZCBub3QgYmUgcHV0IGluc2lkZSB0aGUgY29uc3RydWN0b3IuIEl0IGlzIGNvbnNpZGVyZWQgYmVzdFxyXG4gICAqIHByYWN0aWNlIHRvIGRvIGl0IGluc2lkZSB0aGUge0BsaW5rIEJsb2NrI2FmdGVyQ29uc3RydWN0fSBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdiAvPic7XHJcbiAgICpcclxuICAgKiAgIGFmdGVyQ29uc3RydWN0KCkge1xyXG4gICAqICAgICB0aGlzLndhdGNoQXJncygnYScsICgpID0+IHt9KTtcclxuICAgKiAgICAgdGhpcy53YXRjaEFyZ3MoJ2EnLCAnYicsICgpID0+IHt9KTtcclxuICAgKiAgICAgdGhpcy53YXRjaEFyZ3MoKCkgPT4ge30pO1xyXG4gICAqICAgfVxyXG4gICAqIH1cclxuICAgKi9cclxuICB3YXRjaEFyZ3MoKSB7XHJcbiAgICBjb25zdCB3YXRjaGVyID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICBpZiAoIWlzRnVuY3Rpb24od2F0Y2hlcikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCQuYXJncywgKHsgd2F0Y2hlcnMgfSkgPT4ge1xyXG4gICAgICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXRlcmF0ZShhcmd1bWVudHMsIChhcmcpID0+IHtcclxuICAgICAgaWYgKGFyZyA9PT0gd2F0Y2hlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLiQkLmFyZ3NbYXJnXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy4kJC5hcmdzW2FyZ10ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI3dhdGNoR2xvYmFsXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBbZ2xvYmFsc10gLSBHbG9iYWxzIHRvIHdhdGNoLlxyXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlciAtIENhbGxlZCB3aGVuIHdhdGNoZWQgZ2xvYmFscyBhcmUgY2hhbmdlZC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3YXRjaGluZyBmb3IgZ2xvYmFscy4gSWYgbm8gZ2xvYmFscyBwYXNzZWQgaW4gYXJndW1lbnRzXHJcbiAgICogYWxsIGdsb2JhbHMgYXJlIHRvIGJlIHdhdGNoZWQuIE90aGVyd2lzZSBzcGVjaWZpZWQgZ2xvYmFscyB3aWxsIGJlIHdhdGNoZWQuXHJcbiAgICogV2F0Y2hlcnMgc2hvdWxkIG5vdCBiZSBwdXQgaW5zaWRlIHRoZSBjb25zdHJ1Y3Rvci4gSXQgaXMgY29uc2lkZXJlZCBiZXN0XHJcbiAgICogcHJhY3RpY2UgdG8gZG8gaXQgaW5zaWRlIHRoZSB7QGxpbmsgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3R9IG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY2xhc3MgTXlCbG9jayBleHRlbmRzIEJsb2NrIHtcclxuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2IC8+JztcclxuICAgKlxyXG4gICAqICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XHJcbiAgICogICAgIHRoaXMud2F0Y2hHbG9iYWwoJ2EnLCAoKSA9PiB7fSk7XHJcbiAgICogICAgIHRoaXMud2F0Y2hHbG9iYWwoJ2EnLCAnYicsICgpID0+IHt9KTtcclxuICAgKiAgICAgdGhpcy53YXRjaEdsb2JhbCgoKSA9PiB7fSk7XHJcbiAgICogICB9XHJcbiAgICogfVxyXG4gICAqL1xyXG4gIHdhdGNoR2xvYmFscygpIHtcclxuICAgIGNvbnN0IHdhdGNoZXIgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGlmICghaXNGdW5jdGlvbih3YXRjaGVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgZm9yIChjb25zdCBnbG9iYWwgaW4gdGhpcy4kJC5nbG9iYWwpIHtcclxuICAgICAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXHJcbiAgICAgICAgdGhpcy4kJC5nbG9iYWxbZ2xvYmFsXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGdsb2JhbCkgPT4ge1xyXG4gICAgICBpZiAoZ2xvYmFsID09PSB3YXRjaGVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMuJCQuZ2xvYmFsW2dsb2JhbF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJCQuZ2xvYmFsW2dsb2JhbF0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI3dhdGNoTG9jYWxzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBbbG9jYWxzXSAtIExvY2FscyB0byB3YXRjaC5cclxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IHdhdGNoZXIgLSBDYWxsZWQgd2hlbiB3YXRjaGVkIGxvY2FscyBhcmUgY2hhbmdlZC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3YXRjaGluZyBmb3IgbG9jYWxzLiBJZiBubyBsb2NhbHMgcGFzc2VkIGluIGFyZ3VtZW50c1xyXG4gICAqIGFsbCBsb2NhbHMgYXJlIHRvIGJlIHdhdGNoZWQuIE90aGVyd2lzZSBzcGVjaWZpZWQgbG9jYWxzIHdpbGwgYmUgd2F0Y2hlZC5cclxuICAgKiBXYXRjaGVycyBzaG91bGQgbm90IGJlIHB1dCBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yLiBJdCBpcyBjb25zaWRlcmVkIGJlc3RcclxuICAgKiBwcmFjdGljZSB0byBkbyBpdCBpbnNpZGUgdGhlIHtAbGluayBCbG9jayNhZnRlckNvbnN0cnVjdH0gbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xyXG4gICAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXYgLz4nO1xyXG4gICAqXHJcbiAgICogICBhZnRlckNvbnN0cnVjdCgpIHtcclxuICAgKiAgICAgdGhpcy53YXRjaExvY2FscygnYScsICgpID0+IHt9KTtcclxuICAgKiAgICAgdGhpcy53YXRjaExvY2FscygnYScsICdiJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoTG9jYWxzKCgpID0+IHt9KTtcclxuICAgKiAgIH1cclxuICAgKiB9XHJcbiAgICovXHJcbiAgd2F0Y2hMb2NhbHMoKSB7XHJcbiAgICBjb25zdCB3YXRjaGVyID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICBpZiAoIWlzRnVuY3Rpb24od2F0Y2hlcikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCQubG9jYWxzLCAoeyB3YXRjaGVycyB9KSA9PiB7XHJcbiAgICAgICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGxvY2FsKSA9PiB7XHJcbiAgICAgIGlmIChsb2NhbCA9PT0gd2F0Y2hlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLiQkLmxvY2Fsc1tsb2NhbF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJCQubG9jYWxzW2xvY2FsXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyQnVpbHRJbnMoQmxvY2tzLCByb290QmxvY2tzLCBCbG9jayk7XHJcblxyXG5jb25zdCBibG9ja3MgPSBCbG9jay5fYmxvY2tzO1xyXG5cclxuY2xhc3MgTWl4aW4ge1xyXG4gIHN0YXRpYyBldmFsdWF0ZSA9IHRydWU7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIGVsZW0sXHJcbiAgICAgIG1hdGNoLFxyXG4gICAgICBwYXJlbnRCbG9jayxcclxuICAgICAgcGFyZW50U2NvcGVcclxuICAgIH0gPSBvcHRzO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgJCQ6IHtcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIF92YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudFNjb3BlLFxyXG4gICAgICAgICAgcGFyZW50QmxvY2ssXHJcbiAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlOiBuZXcgQXJyKFtdKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5tYXRjaCA9IG5ldyBBcnIobWF0Y2gpLnNsaWNlKDEpLiQ7XHJcbiAgICB0aGlzLmJsb2NrID0gcGFyZW50U2NvcGU7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5ub2RlID0gZWxlbS4kWzBdO1xyXG5cclxuICAgIGlmIChwYXJlbnRCbG9jaykge1xyXG4gICAgICBwYXJlbnRCbG9jay4kJC5taXhpbnMucHVzaCh0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFmdGVyVXBkYXRlKCkge31cclxuXHJcbiAgYmVmb3JlUmVtb3ZlKCkge31cclxuXHJcbiAgZXZhbHVhdGVBbmRXYXRjaChjYWxsYmFjaykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBfdmFsdWUsXHJcbiAgICAgIHBhcmVudFxyXG4gICAgfSA9IHRoaXMuJCQ7XHJcblxyXG4gICAgcmV0dXJuIHBhcmVudC4kJC5ldmFsdWF0ZShfdmFsdWUsIGNhbGxiYWNrLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIGV2YWx1YXRlT25jZSgpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgX3ZhbHVlLFxyXG4gICAgICBwYXJlbnRcclxuICAgIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIHJldHVybiBwYXJlbnQuJCQuZXZhbHVhdGUoX3ZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTWl4aW4jcmVtb3ZlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm90IGZvcmNpbmcgdGhlIG1peGluIHRvIGJlIHJlbW92ZWQuXHJcbiAgICovXHJcbiAgcmVtb3ZlKGlzUGFyZW50U2lnbmFsKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICB3YXRjaGVyc1RvUmVtb3ZlXHJcbiAgICB9ID0gdGhpcy4kJDtcclxuXHJcbiAgICByZW1vdmVXYXRjaGVycyh3YXRjaGVyc1RvUmVtb3ZlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50QmxvY2suJCQubWl4aW5zLmluZGV4T2YodGhpcyk7XHJcblxyXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyQnVpbHRJbnMoTWl4aW5zLCByb290TWl4aW5zLCBNaXhpbik7XHJcblxyXG5jb25zdCBtaXhpbnMgPSBCbG9jay5fbWl4aW5zO1xyXG5cclxuZnVuY3Rpb24gaW5pdEFwcChibG9jaywgbm9kZSkge1xyXG4gIGlmICghYmxvY2tzW2Jsb2NrXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBcIiR7IGJsb2NrIH1cIiBibG9jayBpcyByZWdpc3RlcmVkISAoaW5pdEFwcClgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YXJ0ID0gZG9jLmNyZWF0ZUNvbW1lbnQoJyBkLXJvb3Q6IHN0YXJ0ICcpO1xyXG4gIGNvbnN0IGVuZCA9IGRvYy5jcmVhdGVDb21tZW50KCcgZC1yb290OiBlbmQgJyk7XHJcbiAgY29uc3QgcGFyZW50ID0gbmV3IEVsZW0obm9kZSk7XHJcblxyXG4gIHBhcmVudC5odG1sKCcnKTtcclxuXHJcbiAgbmV3IEVsZW0oW1xyXG4gICAgc3RhcnQsXHJcbiAgICBlbmRcclxuICBdKS5pbnRvKHBhcmVudCk7XHJcblxyXG4gIGNyZWF0ZUJsb2NrKHtcclxuICAgIG5vZGU6IHtcclxuICAgICAgbmFtZTogYmxvY2ssXHJcbiAgICAgIGF0dHJzOiB7fSxcclxuICAgICAgY2hpbGRyZW46IG5ldyBBcnIoW10pXHJcbiAgICB9LFxyXG4gICAgYWZ0ZXI6IHN0YXJ0LFxyXG4gICAgcGFyZW50XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQnVpbHRJbnMoc2V0LCBzY29wZSwgcHJvdG8pIHtcclxuICBpdGVyYXRlKHNldCwgKHJlZ2lzdGVyKSA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9ID0gcmVnaXN0ZXIocHJvdG8sIGNyZWF0ZUJsb2NrKTtcclxuXHJcbiAgICBpZiAocHJvdG8gPT09IEJsb2NrKSB7XHJcbiAgICAgIHZhbHVlLl9odG1sID0gZGVlcENsb25lQ2hpbGRyZW4oXHJcbiAgICAgICAgbWFya3VwVG9KU09OKFxyXG4gICAgICAgICAgYCR7IHZhbHVlLnRlbXBsYXRlIHx8ICcnIH1gLFxyXG4gICAgICAgICAgdmFsdWUuY29sbGFwc2VXaGl0ZVNwYWNlXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUuX21hdGNoID0gbmV3IFJlZ0V4cChgXiR7IG5ldyBTdHIobmFtZSkuZXNjYXBlUmVnRXhwKCkuJCB9KD86LShbXFxcXHNcXFxcU10rKSk/JGApO1xyXG4gICAgfVxyXG5cclxuICAgIHNjb3BlW25hbWVdID0gdmFsdWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHsgbm9kZSwgYWZ0ZXIsIHBhcmVudCwgcGFyZW50QmxvY2ssIHBhcmVudFNjb3BlIH0pIHtcclxuICBwYXJlbnRTY29wZSA9IChub2RlICYmIG5vZGUuYmxvY2spIHx8IHBhcmVudFNjb3BlO1xyXG5cclxuICBjb25zdCBuYW1lID0gKG5vZGUgJiYgbm9kZS5uYW1lKSB8fCAnVW5rbm93bkJsb2NrJztcclxuICBjb25zdCBhcmdzID0gKG5vZGUgJiYgbm9kZS5hdHRycykgfHwge307XHJcbiAgY29uc3QgY2hpbGRyZW4gPSAobm9kZSAmJiBub2RlLmNoaWxkcmVuKSB8fCBuZXcgQXJyKFtdKTtcclxuICBjb25zdCBlbGVtID0gcGFyZW50LnByb3AoJ25hbWVzcGFjZVVSSScpID09PSBzdmdOU1xyXG4gICAgPyBkb2Muc3ZnKClcclxuICAgIDogbmV3IEVsZW0oZG9jLnRlbXBsYXRlKCkuJFswXS5jb250ZW50KTtcclxuICBjb25zdCBsb2NhbEJsb2NrcyA9IHBhcmVudFNjb3BlID8gcGFyZW50U2NvcGUuJCQubnMuX2Jsb2NrcyA6IGJsb2NrcztcclxuICBjb25zdCBsb2NhbE1peGlucyA9IHBhcmVudFNjb3BlID8gcGFyZW50U2NvcGUuJCQubnMuX21peGlucyA6IG1peGlucztcclxuICBsZXQgY29uc3RydWN0b3IgPSBub2RlICYmIG5vZGUubmFtZSAmJiBsb2NhbEJsb2Nrc1tub2RlLm5hbWVdO1xyXG4gIGxldCBkQmxvY2tNYXRjaDtcclxuXHJcbiAgaWYgKCFjaGlsZHJlbi5sZW5ndGggJiYgKChkQmxvY2tNYXRjaCA9IG5hbWUubWF0Y2goL15kLWJsb2NrLShbXFxzXFxTXSspJC8pKSB8fCBuYW1lID09PSAnZC1ibG9jaycpKSB7XHJcbiAgICBjb25zdHJ1Y3RvciA9IGJsb2Nrc1snZC1ibG9jayddO1xyXG4gICAgYXJncy5uYW1lID0gZEJsb2NrTWF0Y2ggPyBkQmxvY2tNYXRjaFsxXSA6ICd7bnVsbH0nO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFjb25zdHJ1Y3Rvcikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB2YWx1ZSxcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBub2RlO1xyXG5cclxuICAgIGlmIChuYW1lID09PSAnI3RleHQnICYmIGV4cHJlc3Npb25SZWdFeHAudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIGNyZWF0ZUJsb2NrKHtcclxuICAgICAgICBub2RlOiB7XHJcbiAgICAgICAgICBuYW1lOiAnZC10ZXh0JyxcclxuICAgICAgICAgIGF0dHJzOiB7IHZhbHVlIH0sXHJcbiAgICAgICAgICBjaGlsZHJlbjogbmV3IEFycihbXSksXHJcbiAgICAgICAgICBibG9jazogcGFyZW50U2NvcGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFmdGVyLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBwYXJlbnRCbG9jayxcclxuICAgICAgICBwYXJlbnRTY29wZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbS5jcmVhdGUobmFtZSk7XHJcbiAgICBjb25zdCBjdXJyZW50TWl4aW5zID0gbmV3IEFycihbXSk7XHJcblxyXG4gICAgY29uc3QgYXR0cnMgPSBuZXcgU3VwZXIoYXJncykub2JqZWN0KChvYmplY3QsIHZhbHVlLCBhdHRyKSA9PiB7XHJcbiAgICAgIGxldCBtYXRjaDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBsb2NhbE1peGlucykge1xyXG4gICAgICAgIGNvbnN0IE1peGluID0gbG9jYWxNaXhpbnNbbmFtZV07XHJcbiAgICAgICAgY29uc3QgbG9jYWxNYXRjaCA9IGF0dHIubWF0Y2goTWl4aW4uX21hdGNoKTtcclxuXHJcbiAgICAgICAgaWYgKGxvY2FsTWF0Y2gpIHtcclxuICAgICAgICAgIG1hdGNoID0ge1xyXG4gICAgICAgICAgICBtYXRjaDogbG9jYWxNYXRjaCxcclxuICAgICAgICAgICAgTWl4aW4sXHJcbiAgICAgICAgICAgIG5hbWVcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjdXJyZW50TWl4aW5zLnB1c2goe1xyXG4gICAgICAgICAgbmFtZTogbWF0Y2gubmFtZSxcclxuICAgICAgICAgIE1peGluOiBtYXRjaC5NaXhpbixcclxuICAgICAgICAgIG1hdGNoOiBtYXRjaC5tYXRjaCxcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgZWxlbTogZWxlbWVudCxcclxuICAgICAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICAgICAgcGFyZW50U2NvcGVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgb2JqZWN0W2F0dHJdID0gJyc7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgb2JqZWN0W2F0dHJdID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGVsZW1lbnQuYXR0cihhdHRyLCB2YWx1ZSk7XHJcbiAgICAgIH0sIHBhcmVudEJsb2NrKTtcclxuICAgIH0pLiQ7XHJcblxyXG4gICAgaWYgKCFpc05pbCh2YWx1ZSkpIHtcclxuICAgICAgZWxlbWVudC50ZXh0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXR0cnMpIHtcclxuICAgICAgZWxlbWVudC5hdHRyKGF0dHJzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWZ0ZXIubGVuZ3RoKSB7XHJcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QWZ0ZXIoYWZ0ZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5pbnRvKHBhcmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWZ0ZXIgPSBuZXcgRWxlbSgpO1xyXG5cclxuICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICB0cmFuc2Zvcm1ESWZDaGlsZHJlbihjaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICBjb25zdCBibG9jayA9IGNyZWF0ZUJsb2NrKHtcclxuICAgICAgICAgIG5vZGU6IGNoaWxkLFxyXG4gICAgICAgICAgYWZ0ZXIsXHJcbiAgICAgICAgICBwYXJlbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICBwYXJlbnRCbG9jayxcclxuICAgICAgICAgIHBhcmVudFNjb3BlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChibG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XHJcbiAgICAgICAgICBhZnRlciA9IGJsb2NrLiQkLmVsZW1zLmVuZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWZ0ZXIgPSBibG9jaztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGN1cnJlbnRNaXhpbnMuZm9yRWFjaCgob3B0cykgPT4ge1xyXG4gICAgICBjcmVhdGVNaXhpbihvcHRzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYmxvY2tJbnN0YW5jZSA9IG5ldyBjb25zdHJ1Y3Rvcih7XHJcbiAgICBuYW1lLFxyXG4gICAgYXJncyxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgcGFyZW50LFxyXG4gICAgcGFyZW50QmxvY2ssXHJcbiAgICBwYXJlbnRTY29wZVxyXG4gIH0pO1xyXG5cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhibG9ja0luc3RhbmNlLCB7XHJcbiAgICBhcmdzOiB7XHJcbiAgICAgIHZhbHVlOiBibG9ja0luc3RhbmNlLmFyZ3NcclxuICAgIH0sXHJcbiAgICBnbG9iYWw6IHtcclxuICAgICAgdmFsdWU6IGJsb2NrSW5zdGFuY2UuZ2xvYmFsXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGxldCBodG1sID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXHJcbiAgICA/IG5ldyBBcnIoYmxvY2tJbnN0YW5jZS5hcmdzLnZhbHVlIHx8IFtdKVxyXG4gICAgOiBkZWVwQ2xvbmVDaGlsZHJlbihjb25zdHJ1Y3Rvci5faHRtbCwgYmxvY2tJbnN0YW5jZSk7XHJcblxyXG4gIGlmIChuYW1lID09PSAnZC1lbGVtZW50cycgJiYgcGFyZW50QmxvY2suJCQubmFtZSA9PT0gJyNkLWl0ZW0nKSB7XHJcbiAgICBodG1sID0gZGVlcENsb25lQ2hpbGRyZW4oaHRtbCwgcGFyZW50QmxvY2spO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qge1xyXG4gICAgJCQsXHJcbiAgICBhcmdzOiBBcmdzLFxyXG4gICAgZ2xvYmFsLFxyXG4gICAgLi4ubG9jYWxzXHJcbiAgfSA9IGJsb2NrSW5zdGFuY2U7XHJcblxyXG4gIGRlbGV0ZSBsb2NhbHMuJDtcclxuICBkZWxldGUgbG9jYWxzLiQkO1xyXG5cclxuICAkJC5hcmdzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKEFyZ3MpO1xyXG4gICQkLmxvY2FscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShsb2NhbHMpO1xyXG4gICQkLmdsb2JhbCA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShnbG9iYWwsICdnbG9iYWwnLCBwYXJlbnRTY29wZSk7XHJcblxyXG4gIGlmIChuYW1lID09PSAnI2QtaXRlbScpIHtcclxuICAgIGNvbnN0IHNjb3BlVmFsdWVzID0ge1xyXG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcclxuICAgICAgW25vZGUuaW5kZXhOYW1lXTogbm9kZS5pbmRleFxyXG4gICAgfTtcclxuICAgIGxldCBwYXJlbnQgPSBibG9ja0luc3RhbmNlO1xyXG4gICAgbGV0IHNjb3BlID0gcGFyZW50U2NvcGU7XHJcbiAgICBsZXQgREl0ZW1Gb3VuZDtcclxuXHJcbiAgICB3aGlsZSAoIURJdGVtRm91bmQgJiYgKHBhcmVudCA9IHBhcmVudC4kJC5wYXJlbnRCbG9jaykpIHtcclxuICAgICAgREl0ZW1Gb3VuZCA9IHBhcmVudC4kJC5uYW1lID09PSAnI2QtaXRlbSc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKERJdGVtRm91bmQpIHtcclxuICAgICAgc2NvcGUgPSBwYXJlbnQuJCQuc2NvcGU7XHJcbiAgICB9XHJcblxyXG4gICAgJCQubnMgPSBwYXJlbnRTY29wZS4kJC5ucztcclxuICAgICQkLnByaXZhdGVTY29wZSA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShzY29wZVZhbHVlcyk7XHJcbiAgICBjb25zdHJ1Y3RQdWJsaWNTY29wZSgkJC5zY29wZSA9IE9iamVjdC5jcmVhdGUoc2NvcGUpLCBzY29wZVZhbHVlcywgJCQucHJpdmF0ZVNjb3BlKTtcclxuICB9XHJcblxyXG4gIGlmIChuYW1lID09PSAnZC1lYWNoJykge1xyXG4gICAgJCQuc2NvcGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKEFyZ3MsIEFyZ3MsICQkLmFyZ3MpO1xyXG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGdsb2JhbCwgZ2xvYmFsLCAkJC5nbG9iYWwpO1xyXG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGJsb2NrSW5zdGFuY2UsIGxvY2FscywgJCQubG9jYWxzKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJDb25zdHJ1Y3QoKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnN0cnVjdDpgLCBlcnIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZWxlbXMgPSBuZXcgRWxlbShbXHJcbiAgICAkJC5lbGVtcy5zdGFydCxcclxuICAgICQkLmVsZW1zLmVuZFxyXG4gIF0pO1xyXG5cclxuICBpZiAoYWZ0ZXIubGVuZ3RoKSB7XHJcbiAgICBlbGVtcy5pbnNlcnRBZnRlcihhZnRlcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVsZW1zLmludG8ocGFyZW50KTtcclxuICB9XHJcblxyXG4gIGFmdGVyID0gJCQuZWxlbXMuc3RhcnQ7XHJcblxyXG4gIHRyYW5zZm9ybURJZkNoaWxkcmVuKGh0bWwpLmZvckVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICBjb25zdCBibG9jayA9IGNyZWF0ZUJsb2NrKHtcclxuICAgICAgbm9kZTogY2hpbGQsXHJcbiAgICAgIGFmdGVyLFxyXG4gICAgICBwYXJlbnQsXHJcbiAgICAgIHBhcmVudEJsb2NrOiBibG9ja0luc3RhbmNlLFxyXG4gICAgICBwYXJlbnRTY29wZVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcclxuICAgICAgY29uc3QgeyBlbGVtcyB9ID0gYmxvY2suJCQ7XHJcblxyXG4gICAgICBhZnRlciA9IGVsZW1zLmVuZDtcclxuXHJcbiAgICAgICQkLmVsZW1zLmNvbnRlbnQuYWRkKGVsZW1zLnN0YXJ0LCBlbGVtcy5jb250ZW50LCBlbGVtcy5lbmQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWZ0ZXIgPSBibG9jaztcclxuXHJcbiAgICAgICQkLmVsZW1zLmNvbnRlbnQuYWRkKGJsb2NrKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJSZW5kZXIoKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclJlbmRlcjpgLCBlcnIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJsb2NrSW5zdGFuY2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU1peGluKHsgbmFtZSwgTWl4aW4sIHZhbHVlLCBtYXRjaCwgZWxlbSwgcGFyZW50QmxvY2ssIHBhcmVudFNjb3BlIH0pIHtcclxuICBjb25zdCBtaXhpbiA9IG5ldyBNaXhpbih7XHJcbiAgICBuYW1lLFxyXG4gICAgdmFsdWUsXHJcbiAgICBtYXRjaCxcclxuICAgIGVsZW0sXHJcbiAgICBwYXJlbnRCbG9jayxcclxuICAgIHBhcmVudFNjb3BlXHJcbiAgfSk7XHJcblxyXG4gIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBtaXhpbi52YWx1ZSA9IG1peGluLmV2YWx1YXRlQW5kV2F0Y2goKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xyXG4gICAgICBtaXhpbi52YWx1ZSA9IG5ld1ZhbHVlO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtaXhpbi5hZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYWZ0ZXJVcGRhdGU6YCwgZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbWl4aW4uYWZ0ZXJVcGRhdGUodmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVlcENsb25lQ2hpbGRyZW4oY2hpbGRyZW4sIGJsb2NrKSB7XHJcbiAgcmV0dXJuIG5ldyBBcnIoY2hpbGRyZW4gfHwgW10pLm1hcCgoY2hpbGQpID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgYXR0cnMsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IGNoaWxkO1xyXG4gICAgY29uc3QgbmV3Q2hpbGQgPSB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBhdHRyczogeyAuLi5hdHRycyB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChibG9jaykge1xyXG4gICAgICBuZXdDaGlsZC5ibG9jayA9IGJsb2NrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICBuZXdDaGlsZC5jaGlsZHJlbiA9IGRlZXBDbG9uZUNoaWxkcmVuKGNoaWxkcmVuLCBibG9jayk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ld0NoaWxkO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1ESWZDaGlsZHJlbihjaGlsZHJlbikge1xyXG4gIHJldHVybiBuZXcgQXJyKGNoaWxkcmVuIHx8IFtdKVxyXG4gICAgLmNvbmNhdCh7fSlcclxuICAgIC5vYmplY3QoKG9iamVjdCwgY2hpbGQpID0+IHtcclxuICAgICAgY29uc3QgeyBuYW1lIH0gPSBjaGlsZDtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGh0bWwsXHJcbiAgICAgICAgaWZFbHNlXHJcbiAgICAgIH0gPSBvYmplY3Q7XHJcblxyXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtZWxzZS1pZicgJiYgbmFtZSAhPT0gJ2QtZWxzZScpIHtcclxuICAgICAgICBpZiAoaWZFbHNlKSB7XHJcbiAgICAgICAgICBodG1sLnB1c2goe1xyXG4gICAgICAgICAgICBuYW1lOiAnZC1pZicsXHJcbiAgICAgICAgICAgIGJsb2NrOiBpZkVsc2UuJFswXS5ibG9jayxcclxuICAgICAgICAgICAgY2hpbGRyZW46IGlmRWxzZVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgb2JqZWN0LmlmRWxzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtaWYnKSB7XHJcbiAgICAgICAgICBvYmplY3QuaWZFbHNlID0gbmV3IEFycihbY2hpbGRdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChuYW1lKSkge1xyXG4gICAgICAgICAgaHRtbC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgKGlmRWxzZSB8fCBodG1sKS5wdXNoKGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdkLWVsc2UnICYmIGlmRWxzZSkge1xyXG4gICAgICAgICAgaHRtbC5wdXNoKHtcclxuICAgICAgICAgICAgbmFtZTogJ2QtaWYnLFxyXG4gICAgICAgICAgICBibG9jazogaWZFbHNlLiRbMF0uYmxvY2ssXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBpZkVsc2VcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIG9iamVjdC5pZkVsc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBodG1sOiBuZXcgQXJyKFtdKSxcclxuICAgICAgaWZFbHNlOiBudWxsXHJcbiAgICB9KS4kLmh0bWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSW5zdGFuY2VPZkJsb2NrKGJsb2NrKSB7XHJcbiAgcmV0dXJuIGlzUHJvdG90eXBlT2YuY2FsbChCbG9jaywgYmxvY2spICYmIGlzUHJvdG90eXBlT2YuY2FsbChCbG9jay5wcm90b3R5cGUsIGJsb2NrLnByb3RvdHlwZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSW5zdGFuY2VPZk1peGluKG1peGluKSB7XHJcbiAgcmV0dXJuIGlzUHJvdG90eXBlT2YuY2FsbChNaXhpbiwgbWl4aW4pICYmIGlzUHJvdG90eXBlT2YuY2FsbChNaXhpbi5wcm90b3R5cGUsIG1peGluLnByb3RvdHlwZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcclxuICB3YXRjaGVyc1RvUmVtb3ZlLmZvckVhY2goKHsgd2F0Y2hlciwgd2F0Y2hlcnMgfSkgPT4ge1xyXG4gICAgY29uc3QgaW5kZXggPSB3YXRjaGVycy5pbmRleE9mKHdhdGNoZXIpO1xyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgd2F0Y2hlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RydWN0UHJpdmF0ZVNjb3BlKG9iamVjdCwgdHlwZSwgcGFyZW50U2NvcGUpIHtcclxuICBsZXQgc2NvcGUgPSB7fTtcclxuXHJcbiAgaWYgKHR5cGUgPT09ICdnbG9iYWwnKSB7XHJcbiAgICBzY29wZSA9IE9iamVjdC5jcmVhdGUoXHJcbiAgICAgIHBhcmVudFNjb3BlXHJcbiAgICAgICAgPyBwYXJlbnRTY29wZS4kJC5nbG9iYWxcclxuICAgICAgICA6IG51bGxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFN1cGVyKG9iamVjdCkub2JqZWN0KChzY29wZSwgdmFsdWUsIGtleSkgPT4ge1xyXG4gICAgc2NvcGVba2V5XSA9IHtcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHdhdGNoZXJzOiB7XHJcbiAgICAgICAgdGVtcDogbmV3IEFycihbXSksXHJcbiAgICAgICAgcGVybTogbmV3IEFycihbXSlcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBzY29wZSkuJDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RydWN0UHVibGljU2NvcGUoc2NvcGUsIHNjb3BlVmFsdWVzLCBwcml2YXRlU2NvcGUpIHtcclxuICBuZXcgU3VwZXIoc2NvcGUpLmRlZmluZShuZXcgU3VwZXIoc2NvcGVWYWx1ZXMpLm1hcCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XHJcbiAgICAgICAgICBpZiAoZ2V0dGluZy5pbmRleE9mKHNjb3BlLndhdGNoZXJzLnRlbXApID09PSAtMSkge1xyXG4gICAgICAgICAgICBnZXR0aW5nLnB1c2goc2NvcGUud2F0Y2hlcnMudGVtcCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gc2NvcGUudmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY2hhbmdlZCkge1xyXG4gICAgICAgICAgY2hhbmdlZCA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgb2xkVGVtcFdhdGNoZXJzID0gc2NvcGUud2F0Y2hlcnMudGVtcC5zbGljZSgpO1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc2NvcGUudmFsdWU7XHJcblxyXG4gICAgICAgIHNjb3BlLndhdGNoZXJzLnRlbXAgPSBuZXcgQXJyKFtdKTtcclxuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICBvbGRUZW1wV2F0Y2hlcnMuZm9yRWFjaCgod2F0Y2hlcikgPT4ge1xyXG4gICAgICAgICAgd2F0Y2hlci5vblJlbW92ZSgpO1xyXG4gICAgICAgICAgd2F0Y2hlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNoYW5nZWQucHVzaCh7XHJcbiAgICAgICAgICBzY29wZSxcclxuICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgdmFsdWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWNoYW5nZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IHdhcyA9IG5ldyBBcnIoW10pO1xyXG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIHNjb3BlLFxyXG4gICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgIG9sZFZhbHVlXHJcbiAgICAgICAgICAgIH0gPSBjaGFuZ2VkW2ldO1xyXG5cclxuICAgICAgICAgICAgc2NvcGUud2F0Y2hlcnMucGVybS5mb3JFYWNoKCh3YXRjaGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB3YXMuaW5kZXhPZih3YXRjaGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgd2FzLnB1c2god2F0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0ub2xkVmFsdWUgPSBvbGRWYWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2hhbmdlZC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY2hhbmdlZCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgd2FzLmZvckVhY2goKHdhdGNoZXIsIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgIG9sZFZhbHVlXHJcbiAgICAgICAgICAgIH0gPSB2YWx1ZXNbaV07XHJcblxyXG4gICAgICAgICAgICB3YXRjaGVyKHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LCAwKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KS4kKTtcclxufVxyXG5cclxuZXhwb3J0IHsgQmxvY2ssIE1peGluLCBpbml0QXBwIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9mb3JtYXRzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRpZmZlcmVudCB0eXBlcyBvZiBmb3JtYXR0aW5nIGZvciB7QGxpbmsgRGF0ZSNmb3JtYXR9LlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi4vU3VwZXInO1xyXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuLi9TdHInO1xyXG5cclxuY29uc3QgemVybyA9IG5ldyBTdHIoJzAnKTtcclxuY29uc3QgZGF5c09mVGhlV2Vla05hbWVzID0gW1xyXG4gICdTdW5kYXknLFxyXG4gICdNb25kYXknLFxyXG4gICdUdWVzZGF5JyxcclxuICAnV2VkbmVzZGF5JyxcclxuICAnVGh1cnNkYXknLFxyXG4gICdGcmlkYXknLFxyXG4gICdTYXR1cmRheSdcclxuXTtcclxuY29uc3QgZGF5c09mVGhlV2Vla0FsaWFzZXMgPSBuZXcgU3VwZXIoZGF5c09mVGhlV2Vla05hbWVzKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5zbGljZSgwLCAzKSkuJDtcclxuY29uc3QgbW9udGhzTmFtZXMgPSBbXHJcbiAgJ0phbnVhcnknLFxyXG4gICdGZWJydWFyeScsXHJcbiAgJ01hcmNoJyxcclxuICAnQXByaWwnLFxyXG4gICdNYXknLFxyXG4gICdKdW5lJyxcclxuICAnSnVsZScsXHJcbiAgJ0F1Z3VzdCcsXHJcbiAgJ1NlcHRlbWJlcicsXHJcbiAgJ09jdG9iZXInLFxyXG4gICdOb3ZlbWJlcicsXHJcbiAgJ0RlY2VtYmVyJ1xyXG5dO1xyXG5jb25zdCBtb250aHNBbGlhc2VzID0gbmV3IFN1cGVyKG1vbnRoc05hbWVzKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5zbGljZSgwLCAzKSkuJDtcclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgbW9kdWxlOmNvbnN0YW50cy9mb3JtYXRzfm1hdGNoQ2FsbGJhY2tcclxuICogQHBhcmFtIHtEYXR9IGRhdGUgLSBELXdyYXAgb2YgYSBkYXRlIHRvIGFwcGx5IGZvcm1hdCB0by5cclxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIE1hdGNoZWQgYXBwbGllZCBleHByZXNzaW9uLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6Y29uc3RhbnRzL2Zvcm1hdHN+Zm9ybWF0RXhwclxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9ybWF0IC0gTWF0Y2hlZCBmb3JtYXQuXHJcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmNvbnN0YW50cy9mb3JtYXRzfm1hdGNoQ2FsbGJhY2t9IG1hdGNoIC0gQ2FsbGJhY2sgaWYgdGhlcmUgd2FzIGEgbWF0Y2guXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHttb2R1bGU6Y29uc3RhbnRzL2Zvcm1hdHN+Zm9ybWF0RXhwcltdfVxyXG4gKiBAZGVzY3JpcHRpb24gQXJyYXkgb2YgZGlmZmVyZW50IGZvcm1hdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBbXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnY2NjJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ2MnKSwgMylcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ2MnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnYycpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdzcycsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gcm91bmQoZGF0ZVt1dGNdKCdzJyksIDIpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdzJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW3V0Y10oJ3MnKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnbW0nLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnbScpLCAyKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnbScsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCdtJylcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ2hoJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ2gnKSwgMilcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ2gnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnaCcpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdkZGRkJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXlzT2ZUaGVXZWVrTmFtZXNbZGF0ZVt1dGNdKCdkdycpXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnZGRkJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXlzT2ZUaGVXZWVrQWxpYXNlc1tkYXRlW3V0Y10oJ2R3JyldXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdkZCcsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gcm91bmQoZGF0ZVt1dGNdKCdkJyksIDIpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdkJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW3V0Y10oJ2QnKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnTU1NTScsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gbW9udGhzTmFtZXNbZGF0ZVt1dGNdKCdNJykgLSAxXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnTU1NJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBtb250aHNBbGlhc2VzW2RhdGVbdXRjXSgnTScpIC0gMV1cclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ01NJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ00nKSwgMilcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ00nLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnTScpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICd5eXl5JyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ3knKSwgNClcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ3l5JyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBTdHJpbmcoZGF0ZVt1dGNdKCd5JykpLnNsaWNlKC0yKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAneScsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCd5JylcclxuICB9XHJcbl07XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIHJvdW5kXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgLSBOdW1iZXIgdG8gcm91bmQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdHMgLSBOdW1iZXIgb2YgdGhlIGRpZ2l0cyBvZiB0aGUgb3V0cHV0LlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgd2l0aCBuZWNlc3NhcnkgYWRkaXRpb25hbCBzdGFydGluZyB6ZXJvZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByb3VuZChudW1iZXIsIGRpZ2l0cykge1xyXG4gIGNvbnN0IHN0cmluZyA9IFN0cmluZyhudW1iZXIpO1xyXG4gIGxldCB6ZXJvZXMgPSBkaWdpdHMgLSBzdHJpbmcubGVuZ3RoO1xyXG5cclxuICB6ZXJvZXMgPSB6ZXJvZXMgPCAwID8gMCA6IHplcm9lcztcclxuXHJcbiAgcmV0dXJuIHplcm8ucmVwZWF0KHplcm9lcykuJCArIHN0cmluZztcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBEYXRcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIERhdCBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xyXG5pbXBvcnQgeyBOdW0gfSBmcm9tICcuL051bSc7XHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4vU3RyJztcclxuaW1wb3J0IHsgc3dpdGNoZXIgfSBmcm9tICcuL1N3aXRjaGVyJztcclxuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgZm9ybWF0cyBmcm9tICcuL2NvbnN0YW50cy9mb3JtYXRzJztcclxuaW1wb3J0IHsgaXNEYXRlLCBpdGVyYXRlLCBTeW1ib2wsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsqfSBEYXRlTGlrZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsnYyd8J3MnfCdtJ3wnaCd8J2QnfCd3J3wnTSd8J3knfSBBZGRQZXJpb2RcclxuICogQHB1YmxpY1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7J2MnfCdzJ3wnbSd8J2gnfCdkJ3wnZHcnfCdNJ3wneSd9IEdldFBlcmlvZFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsnYyd8J3MnfCdtJ3wnaCd8J2QnfCdNJ3wneSd9IE9mT25lUGVyaW9kXHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeydjJ3wncyd8J20nfCdoJ3wnZCd8J00nfCd5J30gU2V0UGVyaW9kXHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeydjY2MnfCdjJ3wnc3MnfCdzJ3wnbW0nfCdtJ3wnaGgnfCdoJ3wnZGRkZCd8J2RkZCd8J2RkJ3wnZCd8J01NTU0nfCdNTU0nfCdNTSd8J00nfCd5eXl5J3wneXknfCd5J30gRm9ybWF0XHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG5jb25zdCBjb2VmZnMgPSB7XHJcbiAgYzogMSxcclxuICBzOiAxMDAwLFxyXG4gIG06IDYwMDAwLFxyXG4gIGg6IDM2MDAwMDAsXHJcbiAgZDogODY0MDAwMDAsXHJcbiAgdzogNjA0ODAwMDAwLFxyXG4gIE06IDI1OTIwMDAwMDAsXHJcbiAgeTogMzE1MzYwMDAwMDBcclxufTtcclxuXHJcbmNvbnN0IGdldFN3aXRjaGVyID0gc3dpdGNoZXIoe1xyXG4gIGM6IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TWlsbGlzZWNvbmRzYF0oKSxcclxuICBzOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfVNlY29uZHNgXSgpLFxyXG4gIG06IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TWludXRlc2BdKCksXHJcbiAgaDogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1Ib3Vyc2BdKCksXHJcbiAgZDogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1EYXRlYF0oKSxcclxuICBkdzogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1EYXlgXSgpLFxyXG4gIE06IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TW9udGhgXSgpICsgMSxcclxuICB5OiAoZGF0ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfUZ1bGxZZWFyYF0oKVxyXG59LCAnZXF1YWxzJywgTmFOKTtcclxuY29uc3Qgc2V0U3dpdGNoZXIgPSBzd2l0Y2hlcih7XHJcbiAgYzogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TWlsbGlzZWNvbmRzYF0odmFsdWUpLFxyXG4gIHM6IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfVNlY29uZHNgXSh2YWx1ZSksXHJcbiAgbTogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TWludXRlc2BdKHZhbHVlKSxcclxuICBoOiAoZGF0ZSwgdmFsdWUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1Ib3Vyc2BdKHZhbHVlKSxcclxuICBkOiAoZGF0ZSwgdmFsdWUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1EYXRlYF0odmFsdWUpLFxyXG4gIE06IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfU1vbnRoYF0odmFsdWUgLSAxKSxcclxuICB5OiAoZGF0ZSwgdmFsdWUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1GdWxsWWVhcmBdKHZhbHVlKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgRGF0XHJcbiAqIEBleHRlbmRzIFN1cGVyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtEYXRlfSBbZGF0ZSA9IG5ldyBEYXRlKCldIC0gQSBkYXRlIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtEYXR9IEluc3RhbmNlIG9mIERhdC5cclxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYSBkYXRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBkYXRlID0gbmV3IERhdChuZXcgRGF0ZSgpKTtcclxuICovXHJcbmNsYXNzIERhdCBleHRlbmRzIFN1cGVyIHtcclxuICBjb25zdHJ1Y3RvcihkYXRlID0gbmV3IERhdGUoKSkge1xyXG4gICAgc3VwZXIoZGF0ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIERhdCMkXHJcbiAgICAgKiBAdHlwZSB7RGF0ZX1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hbCBkYXRlLlxyXG4gICAgICovXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNhZGRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtBZGRQZXJpb2R8T2JqZWN0LjxBZGRQZXJpb2QsIE51bWJlcj59IHdoYXQgLSBXaGF0IHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW251bWJlcl0gLSBOdW1iZXIgb2Ygd2hhdCB0byBhZGQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgcGVyaW9kIHN0cmluZy5cclxuICAgKiBAcmV0dXJucyB7RGF0fSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIGFtb3VudHMgb2YgdGltZSB0byB0aGUgZGF0ZS4gUmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgRGF0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSkuYWRkKCdjJywgMikudG9JU09TdHJpbmcoKTsgICAgICAgICAvLyAnMjAwMC0wMS0wMVQwMDowMDowMC4wMDFaJ1xyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5hZGQoeyBjOiAyLCBkOiA1IH0pLnRvSVNPU3RyaW5nKCk7IC8vICcyMDAwLTAxLTA2VDAwOjAwOjAwLjAwMVonXHJcbiAgICovXHJcbiAgYWRkKHdoYXQsIG51bWJlcikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICB3aGF0ID0geyBbd2hhdF06IG51bWJlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnRpbWUodGhpcy50aW1lKCkgKyBuZXcgU3VwZXIod2hhdCkuc3VtKCh2YWx1ZSwgd2hhdCkgPT4gY29lZmZzW3doYXRdICogdmFsdWUpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2V4cGlyZXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbdmFsdWUgPSB0aGlzXSAtIFZhbHVlIHRvIHJlc29sdmUgYWZ0ZXIgdGhlIGRhdGUgZXhwaXJlcy5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVmaW5pbmcgd2hlbiB0aGUgZGF0ZSBleHBpcmVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KCkuYWRkKCdjJywgNTAwKS5leHBpcmVzKCdFeHBpcmVkJykudGhlbigodmFsdWUpID0+IHtcclxuICAgKiAgIC8vIEFmdGVyIDUwMCBtaWxsaXNlY29uZHNcclxuICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJ0V4cGlyZWQnXHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgZXhwaXJlcyh2YWx1ZSkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHZhbHVlID0gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IE51bSh0aGlzLiQgLSBub3coKSkudGltZW91dCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNmb3JtYXRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIFRlbXBsYXRlIGZvciB0aGUgb3V0cHV0LlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4ID0gJyddIC0gSWYgbmVlZGVkIFthbGwgc3BlY2lhbCBzdHJpbmdzXXtAbGluayBGb3JtYXR9XHJcbiAgICogYXJlIHRyZWF0ZWQgYXMgdGhleSBzaG91bGQgYmUgcHJlZml4IHdpdGggcHJlZml4LlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY3JlYXRpbmcgZm9ybWF0dGVkIG91dHB1dCBiYXNlZCBvbiBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IERhdCgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykuZm9ybWF0KCdTZWNvbmRzOiAkc3MsIG1pbGxpc2Vjb25kczogJGNjYy4nLCAnJCcpO1xyXG4gICAqIC8vICdTZWNvbmRzOiA1OSwgbWlsbGlzZWNvbmRzOiA5OTkuJ1xyXG4gICAqL1xyXG4gIGZvcm1hdChzdHJpbmcsIHByZWZpeCA9ICcnKSB7XHJcbiAgICBzdHJpbmcgPSBuZXcgU3RyKG5ldyBTdXBlcihzdHJpbmcpLiQpO1xyXG4gICAgcHJlZml4ID0gU3RyaW5nKG5ldyBTdXBlcihwcmVmaXgpLiQpO1xyXG5cclxuICAgIGl0ZXJhdGUoZm9ybWF0cywgKGZvcm1hdCkgPT4ge1xyXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZVN0cmluZyhwcmVmaXggKyBmb3JtYXQuZm9ybWF0LCBmb3JtYXQubWF0Y2godGhpcywgJ2dldCcpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzdHJpbmcuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2Zvcm1hdFVUQ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gU2VlIHtAbGluayBEYXQjZm9ybWF0fS5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeCA9ICcnXSAtIFNlZSB7QGxpbmsgRGF0I2Zvcm1hdH0uXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gRm9ybWF0dGVkIHN0cmluZy5cclxuICAgKiBAZGVzY3JpcHRpb24gVVRDIHZlcnNpb24gb2Yge0BsaW5rIERhdCNmb3JtYXR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KCcxOTk5LTA3LTA3VDAzOjA5OjA5LjA5OVonKS5mb3JtYXRVVEMoXHJcbiAgICogICBgXHJcbiAgICogICAgIE1pbGxpc2Vjb25kczogJGNjY3wkYy5cclxuICAgKiAgICAgU2Vjb25kczogICAgICAkc3N8JHMuXHJcbiAgICogICAgIE1pbnV0ZXM6ICAgICAgJG1tfCRtLlxyXG4gICAqICAgICBIb3VyczogICAgICAgICRoaHwkaC5cclxuICAgKiAgICAgRGF5OiAgICAgICAgICAkZGRkZHwkZGRkfCRkZHwkZC5cclxuICAgKiAgICAgTW9udGg6ICAgICAgICAkTU1NTXwkTU1NfCRNTXwkTS5cclxuICAgKiAgICAgWWVhcjogICAgICAgICAkeXl5eXwkeXl8JHkuXHJcbiAgICogICBgLFxyXG4gICAqICAgJyQnXHJcbiAgICogKTtcclxuICAgKiAvLyBNaWxsaXNlY29uZHM6IDA5OXw5OS5cclxuICAgKiAvLyBTZWNvbmRzOiAgICAgIDA5fDkuXHJcbiAgICogLy8gTWludXRlczogICAgICAwOXw5LlxyXG4gICAqIC8vIEhvdXJzOiAgICAgICAgMDN8My5cclxuICAgKiAvLyBEYXk6ICAgICAgICAgIEZyaWRheXxGcml8MDd8Ny5cclxuICAgKiAvLyBNb250aDogICAgICAgIEp1bHl8SnVsfDA3fDcuXHJcbiAgICogLy8gWWVhcjogICAgICAgICAxOTk5fDk5fDE5OTkuXHJcbiAgICovXHJcbiAgZm9ybWF0VVRDKHN0cmluZywgcHJlZml4ID0gJycpIHtcclxuICAgIHN0cmluZyA9IG5ldyBTdHIobmV3IFN1cGVyKHN0cmluZykuJCk7XHJcbiAgICBwcmVmaXggPSBTdHJpbmcobmV3IFN1cGVyKHByZWZpeCkuJCk7XHJcblxyXG4gICAgaXRlcmF0ZShmb3JtYXRzLCAoZm9ybWF0KSA9PiB7XHJcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlU3RyaW5nKHByZWZpeCArIGZvcm1hdC5mb3JtYXQsIGZvcm1hdC5tYXRjaCh0aGlzLCAnZ2V0VVRDJykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN0cmluZy4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjZ2V0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7R2V0UGVyaW9kfSB3aGF0IC0gV2hhdCB0byBnZXQuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIHdoYXQgdG8gZ2V0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgdmFsdWVzIHN1Y2ggYXMgc2Vjb25kcyBvciBtaW51dGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSkuZ2V0KCdzJyk7IC8vIDU5XHJcbiAgICovXHJcbiAgZ2V0KHdoYXQpIHtcclxuICAgIHJldHVybiBnZXRTd2l0Y2hlcih3aGF0LCBbdGhpcy4kLCAnZ2V0J10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjZ2V0VVRDXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7R2V0UGVyaW9kfSB3aGF0IC0gU2VlIHtAbGluayBEYXQjZ2V0fS5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2Ygd2hhdCB0byBnZXQuXHJcbiAgICogQGRlc2NyaXB0aW9uIFVUQyB2ZXJzaW9uIG9mIHtAbGluayBEYXQjZ2V0fS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZGF0ZSA9IG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKTtcclxuICAgKlxyXG4gICAqIGRhdGUuZ2V0VVRDKCdjJyk7ICAvLyA5OTlcclxuICAgKiBkYXRlLmdldFVUQygncycpOyAgLy8gNTlcclxuICAgKiBkYXRlLmdldFVUQygnbScpOyAgLy8gNTlcclxuICAgKiBkYXRlLmdldFVUQygnaCcpOyAgLy8gMjNcclxuICAgKiBkYXRlLmdldFVUQygnZCcpOyAgLy8gMzFcclxuICAgKiBkYXRlLmdldFVUQygnZHcnKTsgLy8gNVxyXG4gICAqIGRhdGUuZ2V0VVRDKCdNJyk7ICAvLyAxMlxyXG4gICAqIGRhdGUuZ2V0VVRDKCd5Jyk7ICAvLyAxOTk5XHJcbiAgICovXHJcbiAgZ2V0VVRDKHdoYXQpIHtcclxuICAgIHJldHVybiBnZXRTd2l0Y2hlcih3aGF0LCBbdGhpcy4kLCAnZ2V0VVRDJ10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjaXNBZnRlclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0RhdGVMaWtlfSBkYXRlIC0gRGF0ZSB0byBiZSBjb21wYXJlZCB0byB0aGlzIGRhdGUuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoaXMgZGF0ZSBpcyBhZnRlciB0aGUgYXJndW1lbnQgb25lLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBGaW5kcyBvdXQgaWYgdGhpcyBkYXRlIGlzIGFmdGVyIHRoZSBhcmd1bWVudCBvbmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNBZnRlcihuZXcgRGF0ZSgzMzQpKTsgLy8gZmFsc2VcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDMzMykpLmlzQWZ0ZXIobmV3IERhdGUoMzMyKSk7IC8vIHRydWVcclxuICAgKi9cclxuICBpc0FmdGVyKGRhdGUpIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZShuZXcgU3VwZXIoZGF0ZSkuJCk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIDwgdGhpcy4kLmdldFRpbWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2lzQmVmb3JlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGF0ZUxpa2V9IGRhdGUgLSBEYXRlIHRvIGJlIGNvbXBhcmVkIHRvIHRoaXMgZGF0ZS5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgYXJndW1lbnQgb25lLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBGaW5kcyBvdXQgaWYgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgYXJndW1lbnQgb25lLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDMzMykpLmlzQmVmb3JlKG5ldyBEYXRlKDMzNCkpOyAvLyB0cnVlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgzMzMpKS5pc0JlZm9yZShuZXcgRGF0ZSgzMzIpKTsgLy8gZmFsc2VcclxuICAgKi9cclxuICBpc0JlZm9yZShkYXRlKSB7XHJcbiAgICBkYXRlID0gbmV3IERhdGUobmV3IFN1cGVyKGRhdGUpLiQpO1xyXG5cclxuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSA+IHRoaXMuJC5nZXRUaW1lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNpc0JldHdlZW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEYXRlTGlrZX0gZGF0ZTEgLSBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAgICogQHBhcmFtIHtEYXRlTGlrZX0gZGF0ZTIgLSBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGlzIGRhdGUgaXMgYWZ0ZXIgZGF0ZTEgYW5kIGJlZm9yZSBkYXRlMi5cclxuICAgKiBAZGVzY3JpcHRpb24gRmluZHMgb3V0IGlmIHRoaXMgZGF0ZSBpcyBhZnRlciBkYXRlMSBhbmQgYmVmb3JlIGRhdGUyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDMzMykpLmlzQmV0d2VlbihuZXcgRGF0ZSgzMzIpLCBuZXcgRGF0ZSgzMzQpKTsgLy8gdHJ1ZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNCZXR3ZWVuKG5ldyBEYXRlKDMzNCksIG5ldyBEYXRlKDMzMikpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGlzQmV0d2VlbihkYXRlMSwgZGF0ZTIpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLiQuZ2V0VGltZSgpO1xyXG5cclxuICAgIGRhdGUxID0gbmV3IERhdGUobmV3IFN1cGVyKGRhdGUxKS4kKTtcclxuICAgIGRhdGUyID0gbmV3IERhdGUobmV3IFN1cGVyKGRhdGUyKS4kKTtcclxuXHJcbiAgICByZXR1cm4gdGltZSA+IGRhdGUxLmdldFRpbWUoKSAmJiB0aW1lIDwgZGF0ZTIuZ2V0VGltZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjaXNJbnZhbGlkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZGF0ZSBpcyBpbnZhbGlkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBkYXRlIGlzIGludmFsaWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJ2EnKSkuaXNJbnZhbGlkKCk7IC8vIHRydWVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDEpKS5pc0ludmFsaWQoKTsgICAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGlzSW52YWxpZCgpIHtcclxuICAgIHJldHVybiB0aGlzLiQudG9TdHJpbmcoKSA9PT0gJ0ludmFsaWQgRGF0ZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNpc1Bhc3NlZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGRhdGUgaXMgcGFzc2VkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBkYXRlIGlzIHBhc3NlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgxKSkuaXNQYXNzZWQoKTsgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGlzUGFzc2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNCZWZvcmUobm93KCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjb2ZPbmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtPZk9uZVBlcmlvZH0gd2hhdCAtIFBlcmlvZCB0byBjaGVjay5cclxuICAgKiBAcGFyYW0ge0RhdGVMaWtlfSBkYXRlIC0gRGF0ZSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdHdvIGRhdGVzIGFyZSBvZiBvbmUgc2Vjb25kLCBtaW51dGUgb3Igc29tZXRoaW5nIGVsc2UuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdHdvIGRhdGVzIGFyZSBvZiBvbmUgc2Vjb25kLCBtaW51dGUgb3Igc29tZXRoaW5nIGVsc2UuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuMDAwWicpKS5vZk9uZSgncycsIG5ldyBEYXRlKDE5OTktMTItMzFUMjM6NTk6NTkuMzMzWicpKTsgLy8gdHJ1ZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuMDAwWicpKS5vZk9uZSgncycsIG5ldyBEYXRlKDE5OTktMTItMzFUMjM6NTk6NTguOTk5WicpKTsgLy8gZmFsc2VcclxuICAgKi9cclxuICBvZk9uZSh3aGF0LCBkYXRlKSB7XHJcbiAgICBpZiAoISh3aGF0IGluIGNvZWZmcykgfHwgd2hhdCA9PT0gJ3cnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBkYXRlID0gbmV3IERhdChuZXcgRGF0ZShkYXRlKSk7XHJcblxyXG4gICAgbGV0IHN0YXJ0ZWQ7XHJcblxyXG4gICAgcmV0dXJuIGl0ZXJhdGUoY29lZmZzLCAoY29lZmYsIHcpID0+IHtcclxuICAgICAgaWYgKHcgPT09IHdoYXQpIHtcclxuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFzdGFydGVkIHx8IHcgPT09ICd3Jykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0YXJ0ZWQgJiYgdGhpcy5nZXQodykgIT09IGRhdGUuZ2V0KHcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KSAhPT0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNzZXRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTZXRQZXJpb2R8T2JqZWN0LjxTZXRQZXJpb2QsIE51bWJlcj59IHdoYXQgLSBXaGF0IHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW251bWJlcl0gLSBOdW1iZXIgb2Ygd2hhdCB0byBzZXQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgcGVyaW9kIHN0cmluZy5cclxuICAgKiBAcmV0dXJucyB7RGF0fSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2V0dGluZyB2YWx1ZXMgc3VjaCBhcyBzZWNvbmRzIG9yIG1pbnV0ZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5zZXQoJ3MnLCA1OCkuZ2V0KCdzJyk7ICAgICAgICAgICAvLyA1OFxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5zZXQoeyBjOiA5OTgsIHM6IDU4IH0pLmdldCgnYycpOyAvLyA5OThcclxuICAgKi9cclxuICBzZXQod2hhdCwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCBkYXRlID0gdGhpcy4kO1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgd2hhdCA9IHsgW3doYXRdOiBudW1iZXIgfTtcclxuICAgIH1cclxuXHJcbiAgICB3aGF0ID0gbmV3IFN1cGVyKHdoYXQpLiQ7XHJcblxyXG4gICAgaXRlcmF0ZSh3aGF0LCAodmFsdWUsIHdoYXQpID0+IHtcclxuICAgICAgc2V0U3dpdGNoZXIod2hhdCwgW2RhdGUsIHZhbHVlLCAnc2V0J10pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNzZXRVVENcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTZXRQZXJpb2R8T2JqZWN0LjxTZXRQZXJpb2QsIE51bWJlcj59IHdoYXQgLSBTZWUge0BsaW5rIERhdCNzZXR9LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyXSAtIFNlZSB7QGxpbmsgRGF0I3NldH0uXHJcbiAgICogQHJldHVybnMge0RhdH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBVVEMgdmVyc2lvbiBvZiB7QGxpbmsgRGF0I3NldH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGRhdGUgPSBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSk7XHJcbiAgICpcclxuICAgKiBkYXRlLnNldFVUQygnY2NjJywgOTk4KS5nZXRVVEMoJ2NjYycpOyAvLyA5OThcclxuICAgKiBkYXRlLnNldFVUQyh7XHJcbiAgICogICBzOiA1OCxcclxuICAgKiAgIG06IDU4LFxyXG4gICAqICAgaDogMjJcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIGRhdGUuZ2V0VVRDKCdzJyk7IC8vIDU4XHJcbiAgICogZGF0ZS5nZXRVVEMoJ20nKTsgLy8gNThcclxuICAgKiBkYXRlLmdldFVUQygnaCcpOyAvLyAyM1xyXG4gICAqL1xyXG4gIHNldFVUQyh3aGF0LCBudW1iZXIpIHtcclxuICAgIGNvbnN0IGRhdGUgPSB0aGlzLiQ7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICB3aGF0ID0geyBbd2hhdF06IG51bWJlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHdoYXQgPSBuZXcgU3VwZXIod2hhdCkuJDtcclxuXHJcbiAgICBpdGVyYXRlKHdoYXQsICh2YWx1ZSwgd2hhdCkgPT4ge1xyXG4gICAgICBzZXRTd2l0Y2hlcih3aGF0LCBbZGF0ZSwgdmFsdWUsICdzZXRVVEMnXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I3NldFVUQ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdIC0gVGltZSB0byBzZXQuXHJcbiAgICogQHJldHVybnMge0RhdHxOdW1iZXJ9IC0gSWYgdGhlIHRpbWUgYXJndW1lbnQgaXMgcHJlc2VudCB0aGlzIGlzIHJldHVybmVkIG90aGVyd2lzZSB0aGUgdGltZSBpcyByZXR1cm5lZC5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgYm90aFxyXG4gICAqIFtEYXRlI2dldFRpbWVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvZ2V0VGltZX0gYW5kXHJcbiAgICogW0RhdGUjc2V0VGltZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRUaW1lfS5cclxuICAgKi9cclxuICB0aW1lKHRpbWUpIHtcclxuICAgIGNvbnN0IGRhdGUgPSB0aGlzLiQ7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgZGF0ZS5zZXRUaW1lKHRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcclxuICB9XHJcblxyXG4gIHRvSVNPU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC50b0lTT1N0cmluZygpO1xyXG4gIH1cclxuXHJcbiAgdG9Mb2NhbGVTdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLiQudG9TdHJpbmcoKTtcclxuICB9XHJcblxyXG4gIHZhbHVlT2YoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnZhbHVlT2YoKTtcclxuICB9XHJcbn1cclxuZGVmaW5lUHJvcGVydGllcyhEYXQucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdEYXQnXHJcbn0pO1xyXG5cclxuY29uc3RydWN0b3JzWzFdLnB1c2goe1xyXG4gIGNoZWNrOiBpc0RhdGUsXHJcbiAgY2xzOiBEYXRcclxufSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIG5vd1xyXG4gKiBAcHVibGljXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9ub3dcclxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAqIFtEYXRlLm5vd117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9ub3d9LlxyXG4gKi9cclxuZnVuY3Rpb24gbm93KCkge1xyXG4gIHJldHVybiBEYXRlLm5vdygpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRhdGVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0RhdGVMaWtlfSBbZGF0ZSA9IG5ldyBEYXRlKCldIC0gRGF0ZS1saWtlIHZhbHVlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBEYXRlIGNvbnN0cnVjdG9yLlxyXG4gKiBAcmV0dXJucyB7RGF0fSBOZXcgaW5zdGFuY2Ugb2YgRGF0LlxyXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgbmV3IERhdChuZXcgRGF0ZShkYXRlKSk7XHJcbiAqL1xyXG5mdW5jdGlvbiBkYXRlKGRhdGUpIHtcclxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBuZXcgRGF0KG5ldyBEYXRlKG5vdygpKSk7XHJcbiAgfVxyXG5cclxuICBkYXRlID0gbmV3IFN1cGVyKGRhdGUpLiQ7XHJcblxyXG4gIHJldHVybiBuZXcgRGF0KG5ldyBEYXRlKGRhdGUpKTtcclxufVxyXG5cclxuZXhwb3J0IHsgRGF0LCBub3csIGRhdGUgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9jb25zdHJ1Y3RVUkxcclxuICogQHByaXZhdGVcclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgY29uc3RydWN0VVJMIG1ldGhvZC5cclxuICovXHJcblxyXG5pbXBvcnQgeyBBcnIgfSBmcm9tICcuLi9BcnInO1xyXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuLi9TdHInO1xyXG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4uL1N3aXRjaGVyJztcclxuaW1wb3J0IHsgaXNBcnJheSwgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL2NoZWNrVHlwZXMnO1xyXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7UmVnRXhwfVxyXG4gKiBAZGVzY3JpcHRpb24gQWJzb2x1dGUgVVJMIHBhdHRlcm4uXHJcbiAqL1xyXG5jb25zdCBhYnNvbHV0ZVVSTFJlZ2V4cCA9IC9eKChbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvfGRhdGE6W2Etel0rXFwvW2Etel0rO2Jhc2U2NCwpL2k7XHJcbmNvbnN0IHF1ZXJ5U3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsICgpID0+IG5ldyBBcnIoW10pKVxyXG4gIC5jYXNlKGlzQXJyYXksIChwcmVmaXgsIHF1ZXJ5KSA9PiB7XHJcbiAgICBsZXQgcXVlcnlQYXJhbXMgPSBuZXcgQXJyKFtdKTtcclxuXHJcbiAgICBpdGVyYXRlKHF1ZXJ5LCAodmFsdWUpID0+IHtcclxuICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb25jYXQocXVlcnlTd2l0Y2hlcih2YWx1ZSwgW2AkeyBwcmVmaXggfVtdYF0pKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBxdWVyeVBhcmFtcy5wdXNoKHtcclxuICAgICAgICBwYXJhbTogYCR7IHByZWZpeCB9W11gLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1zLiQ7XHJcbiAgfSlcclxuICAuY2FzZShpc1BsYWluT2JqZWN0LCAocHJlZml4LCBxdWVyeSkgPT4ge1xyXG4gICAgbGV0IHF1ZXJ5UGFyYW1zID0gbmV3IEFycihbXSk7XHJcblxyXG4gICAgaXRlcmF0ZShxdWVyeSwgKHZhbHVlLCBwYXJhbSkgPT4ge1xyXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBxdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvbmNhdChxdWVyeVN3aXRjaGVyKHZhbHVlLCBbcHJlZml4ID8gYCR7IHByZWZpeCB9WyR7IHBhcmFtIH1dYCA6IHBhcmFtXSkpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHF1ZXJ5UGFyYW1zLnB1c2goe1xyXG4gICAgICAgIHBhcmFtOiBwcmVmaXggPyBgJHsgcHJlZml4IH1bJHsgcGFyYW0gfV1gIDogcGFyYW0sXHJcbiAgICAgICAgdmFsdWU6IGlzT2JqZWN0KHZhbHVlKSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFN0cmluZyh2YWx1ZSlcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcXVlcnlQYXJhbXMuJDtcclxuICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gY29uc3RydWN0VVJMXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlVVJMIC0gQmFzZVVSTCBvZiB0aGUgb3V0cHV0IFVSTC5cclxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIE1haW4gcGFydCBvZiB0aGUgb3V0cHV0IFVSTC5cclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFBhcmFtcyB0byByZXBsYWNlIGluIHRoZSB1cmwgZXhwcmVzc2lvbnMgbGlrZSBcIjpwYXJhbVwiLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnkgLSBPYmplY3Qgd2l0aCBxdWVyeSBwYXJhbXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGFzaCA9ICcnXSAtIFVSTCBoYXNoLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2VuY29kZU9wdGlvbnMgPSB7fV0gLSBJZiB5b3UgbmVlZCB0byBlbmNvZGUgc29tZXRoaW5nLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2VuY29kZU9wdGlvbnMucGFyYW1zID0gdHJ1ZV0gLSBJZiB5b3UgbmVlZCB0byBlbmNvZGUgcGFyYW1zLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2VuY29kZU9wdGlvbnMucXVlcnkgPSB0cnVlXSAtIElmIHlvdSBuZWVkIHRvIGVuY29kZSBxdWVyeSBwYXJhbXMuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbnN0cnVjdGVkIFVSTC5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjb25zdHJ1Y3RpbmcgVVJMIGZyb20gdGhlIGJhc2UgVVJMLCBVUkwsIHBhcmFtcyBhbmQgcXVlcnkgcGFyYW1zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgKGJhc2VVUkwsIHVybCwgcGFyYW1zLCBxdWVyeSwgaGFzaCA9ICcnLCBlbmNvZGVPcHRpb25zID0ge30pID0+IHtcclxuICBjb25zdCB7XHJcbiAgICBwYXJhbXM6IGVuY29kZVBhcmFtcyA9IHRydWUsXHJcbiAgICBxdWVyeTogZW5jb2RlUXVlcnkgPSB0cnVlXHJcbiAgfSA9IGVuY29kZU9wdGlvbnM7XHJcbiAgbGV0IFVSTCA9IGlzQWJzb2x1dGUodXJsKVxyXG4gICAgPyB1cmxcclxuICAgIDogYCR7IFN0cmluZyhiYXNlVVJMKS5yZXBsYWNlKC9cXC8rJC8sICcnKSB9LyR7IFN0cmluZyh1cmwpLnJlcGxhY2UoL15cXC8rLywgJycpIH1gO1xyXG5cclxuICBpdGVyYXRlKHBhcmFtcywgKHZhbHVlLCBwYXJhbSkgPT4ge1xyXG4gICAgVVJMID0gbmV3IFN0cihVUkwpLnJlcGxhY2VTdHJpbmcoYDokeyBwYXJhbSB9YCwgZW5jb2RlKHZhbHVlLCBlbmNvZGVQYXJhbXMpKS4kO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCBxdWVyeVBhcmFtcyA9IHF1ZXJ5U3dpdGNoZXIocXVlcnksIFsnJ10pO1xyXG5cclxuICBpZiAocXVlcnlQYXJhbXMubGVuZ3RoKSB7XHJcbiAgICBVUkwgKz0gKFVSTC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHF1ZXJ5UGFyYW1zXHJcbiAgICAgIC5tYXAoKHsgcGFyYW0sIHZhbHVlIH0pID0+IGAkeyBlbmNvZGUocGFyYW0sIGVuY29kZVF1ZXJ5KSB9PSR7IGVuY29kZSh2YWx1ZSwgZW5jb2RlUXVlcnkpIH1gKVxyXG4gICAgICAuam9pbignJicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGAkeyBVUkwgfSR7IGhhc2ggPyBgIyR7IGhhc2ggfWAgOiAnJyB9YDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNBYnNvbHV0ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVVJMIHRvIGNoZWNrIGlmIGl0IGlzIGFic29sdXRlIG9yIG5vdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBVUkwgaXMgYWJzb2x1dGUgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNBYnNvbHV0ZSh1cmwpIHtcclxuICByZXR1cm4gYWJzb2x1dGVVUkxSZWdleHAudGVzdCh1cmwpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gU3RyaW5nIHRvIGVuY29kZSB1c2luZyBlbmNvZGVVUklDb21wb25lbnQuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFbmNvZGVkIC0gSWYgdGhlIHN0cmluZyBzaG91bGQgYmUgZW5jb2RlZC5cclxuICogQHJldHVybnMge1N0cmluZ30gRW5jb2RlZCBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBpc0VuY29kZWQpIHtcclxuICByZXR1cm4gaXNFbmNvZGVkID8gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykgOiBzdHJpbmc7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9wYXJzZUhlYWRlcnNcclxuICogQHByaXZhdGVcclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgcGFyc2VIZWFkZXJzIG1ldGhvZC5cclxuICovXHJcblxyXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuLi9TdHInO1xyXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gcGFyc2VIZWFkZXJzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdIZWFkZXJzIC0gUmF3IGhlYWRlcnMuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgb2JqZWN0XHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgcGFyc2luZyByYXcgaGVhZGVycy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IChyYXdIZWFkZXJzKSA9PiB7XHJcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xyXG5cclxuICBpdGVyYXRlKChyYXdIZWFkZXJzIHx8ICcnKS5zcGxpdCgnXFxuJyksICh2YWx1ZSkgPT4ge1xyXG4gICAgY29uc3QgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XHJcbiAgICBjb25zdCBrZXkgPSBuZXcgU3RyKHZhbHVlLnN1YnN0cmluZygwLCBpbmRleCkpXHJcbiAgICAgIC50cmltKClcclxuICAgICAgLnRvQ2FtZWxDYXNlKCkuJDtcclxuICAgIGNvbnN0IHZhbCA9IG5ldyBTdHIodmFsdWUuc3Vic3RyaW5nKGluZGV4ICsgMSkpLnRyaW0oKS4kO1xyXG5cclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgaGVhZGVyc1trZXldID0gKGhlYWRlcnNba2V5XSA/IGAkeyBoZWFkZXJzW2tleV0gfSwgYCA6ICcnKSArIHZhbDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGhlYWRlcnM7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvdHJhbnNmb3JtRGF0YVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyB0cmFuc2Zvcm1EYXRhIG1ldGhvZC5cclxuICovXHJcblxyXG5pbXBvcnQgeyBBcnIgfSBmcm9tICcuLi9BcnInO1xyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcclxuaW1wb3J0IHsgaXNPYmplY3QsIHRvU3RyaW5nVGFnIH0gZnJvbSAnLi8nO1xyXG5cclxuY29uc3Qgbm90VG9UcmFuc2Zvcm0gPSBuZXcgQXJyKFsnRm9ybURhdGEnLCAnRmlsZScsICdCbG9iJywgJ0FycmF5QnVmZmVyJywgJ1N0cmluZycsICdOdW1iZXInXSk7XHJcbmNvbnN0IHdpdGhvdXRCb2R5ID0gbmV3IEFycihbJ0RFTEVURScsICdHRVQnLCAnSEVBRCddKTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gdHJhbnNmb3JtRGF0YVxyXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBEYXRhIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gSFRUUCBtZXRob2QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIC0gT2JqZWN0IHdpdGggaGVhZGVycy5cclxuICogQHJldHVybnMgeyp9IC0gVHJhbnNmb3JtZWQgZGF0YS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IChkYXRhLCBtZXRob2QsIGhlYWRlcnMpID0+IHtcclxuICBkYXRhID0gbmV3IFN1cGVyKGRhdGEpLiQ7XHJcblxyXG4gIGlmICh3aXRob3V0Qm9keS5pbmRleE9mU3RyaWN0KG1ldGhvZCkgIT09IC0xKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChpc09iamVjdChkYXRhKSAmJiBub3RUb1RyYW5zZm9ybS5pbmRleE9mU3RyaWN0KHRvU3RyaW5nVGFnKGRhdGEpKSA9PT0gLTEpIHtcclxuICAgIGlmICghaGVhZGVycy5jb250ZW50VHlwZSkge1xyXG4gICAgICBoZWFkZXJzLmNvbnRlbnRUeXBlID0gWydhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFN1cGVyKGRhdGEpLmpzb24oKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkYXRhO1xyXG59O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBGZXRjaFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgRmV0Y2ggY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IEFyciB9IGZyb20gJy4vQXJyJztcclxuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9TdHInO1xyXG5pbXBvcnQge1xyXG4gIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLFxyXG4gIGFzc2lnbiwgU3ltYm9sLCB2YWxpZGF0ZSwgaXRlcmF0ZSwgZGVmaW5lUHJvcGVydGllc1xyXG59IGZyb20gJy4vaGVscGVycyc7XHJcbmltcG9ydCBjb25zdHJ1Y3RVUkwgZnJvbSAnLi9oZWxwZXJzL2NvbnN0cnVjdFVSTCc7XHJcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi9oZWxwZXJzL3BhcnNlSGVhZGVycyc7XHJcbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vaGVscGVycy90cmFuc2Zvcm1EYXRhJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7J2dldCd8J3Bvc3QnfCdkZWxldGUnfCdoZWFkJ3wncHV0J3wncGF0Y2gnfSBGZXRjaE1ldGhvZFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZldGNoQ29uZmlnXHJcbiAqIEBwdWJsaWNcclxuICogQHByb3BlcnR5IHtBcnJheS48QWZ0ZXJNaWRkbGV3YXJlfEZldGNoRXJyb3JBZnRlck1pZGRsZXdhcmU+fSBbYWZ0ZXJdXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYXV0aF1cclxuICogQHByb3BlcnR5IHtTdHJpbmd9IFthdXRoLnVzZXJuYW1lXVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW2F1dGgucGFzc3dvcmRdXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYmFzZVVSTF1cclxuICogQHByb3BlcnR5IHtBcnJheS48QmVmb3JlTWlkZGxld2FyZXxGZXRjaEVycm9yQmVmb3JlTWlkZGxld2FyZT59IFtiZWZvcmVdXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gW2RhdGFdXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZ1tdPn0gW2hlYWRlcnNdXHJcbiAqIEBwcm9wZXJ0eSB7RmV0Y2hNZXRob2R9IFttZXRob2RdXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcGFyYW1zXVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3F1ZXJ5XVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3Jlc3BvbnNlVHlwZV1cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aW1lb3V0XVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3VybF1cclxuICogQHByb3BlcnR5IHtCb29sZWFufSBbd2l0aENyZWRlbnRpYWxzXVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGZXRjaFJlc3BvbnNlXHJcbiAqIEBwdWJsaWNcclxuICogQHByb3BlcnR5IHtGZXRjaENvbmZpZ30gY29uZmlnXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gZGF0YVxyXG4gKiBAcHJvcGVydHkge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBoZWFkZXJzXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGF0dXNcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHN0YXR1c1RleHRcclxuICogQHByb3BlcnR5IHtYTUxIdHRwUmVxdWVzdH0geGhyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEFmdGVyTWlkZGxld2FyZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RmV0Y2hSZXNwb25zZX0gY29uZmlnIC0gRmV0Y2ggcmVzcG9uc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtFcnJvcnwqfSBlcnIgLSBUaHJvd24gZXJyb3IuXHJcbiAqIEBwYXJhbSB7RmV0Y2hSZXNwb25zZX0gY29uZmlnIC0gRmV0Y2ggcmVzcG9uc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEJlZm9yZU1pZGRsZXdhcmVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBjb25maWcgLSBGZXRjaCBjb25maWcuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEVycm9yQmVmb3JlTWlkZGxld2FyZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RXJyb3J8Kn0gZXJyIC0gVGhyb3duIGVycm9yLlxyXG4gKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBjb25maWcgLSBGZXRjaCBjb25maWcuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaENvbmZpZ0Z1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtGZXRjaENvbmZpZ30gY29uZmlnXHJcbiAqL1xyXG5cclxuY29uc3QgZGVmYXVsdHMgPSB7XHJcbiAgYWZ0ZXI6IFtdLFxyXG4gIGF1dGg6IHtcclxuICAgIHVzZXJuYW1lOiAnJyxcclxuICAgIHBhc3N3b3JkOiAnJ1xyXG4gIH0sXHJcbiAgYmFzZVVSTDogZ2xvYmFsLmxvY2F0aW9uLm9yaWdpbixcclxuICBiZWZvcmU6IFtdLFxyXG4gIGRhdGE6IG51bGwsXHJcbiAgaGVhZGVyczoge30sXHJcbiAgbWV0aG9kOiAnZ2V0JyxcclxuICBwYXJhbXM6IHt9LFxyXG4gIHF1ZXJ5OiB7fSxcclxuICByZXNwb25zZVR5cGU6ICcnLFxyXG4gIHRpbWVvdXQ6IDAsXHJcbiAgdXJsOiAnJyxcclxuICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlXHJcbn07XHJcbmNvbnN0IHVwbG9hZE1ldGhvZHMgPSBuZXcgQXJyKFsncG9zdCcsICdwdXQnXSk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIEZldGNoXHJcbiAqIEBleHRlbmRzIEZ1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtGZXRjaENvbmZpZ30gW2NvbmZpZyA9IHt9XSAtIEEgbnVtYmVyIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtGZXRjaH0gSW5zdGFuY2Ugb2YgRmV0Y2guXHJcbiAqIEFuIGluc3RhbmNlIG9mIEZldGNoIGlzIGEgZnVuY3Rpb24gdGhhdCBzaW1wbHkgY2FsbHMgI3JlcXVlc3Qgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXHJcbiAqIEBkZXNjcmlwdGlvbiBDbGFzcyBmb3IgZmV0Y2hpbmcgZGF0YS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgZmV0Y2ggPSBuZXcgRmV0Y2goKTtcclxuICpcclxuICogZmV0Y2goJy9kYXRhJykudGhlbigocmVzKSA9PiB7XHJcbiAqICAgY29uc29sZS5sb2cocmVzKTtcclxuICogfSk7XHJcbiAqL1xyXG5jbGFzcyBGZXRjaCBleHRlbmRzIEZ1bmN0aW9uIHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgcmV0dXJuIGZldGNoLnJlcXVlc3QuYXBwbHkoZmV0Y2gsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29uZiA9IG5ldyBTdXBlcih7fSkuZGVlcEFzc2lnbihkZWZhdWx0cywgY29uZmlnKS4kO1xyXG5cclxuICAgIGlmIChjb25mLmJlZm9yZS5pbmRleE9mKGZldGNoQmVmb3JlTWlkZGxld2FyZSkgPT09IC0xKSB7XHJcbiAgICAgIGNvbmYuYmVmb3JlLnB1c2goZmV0Y2hCZWZvcmVNaWRkbGV3YXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge0ZldGNoQ29uZmlnfSBGZXRjaCMkJFxyXG4gICAgICogQHR5cGUge0ZldGNoQ29uZmlnfVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIEZldGNoIGNvbmZpZy5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZldGNoLCAnJCQnLCB7IHZhbHVlOiBjb25mIH0pO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZldGNoLCBGZXRjaC5wcm90b3R5cGUpO1xyXG5cclxuICAgIHJldHVybiBmZXRjaDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjYWZ0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtGZXRjaEFmdGVyTWlkZGxld2FyZXxGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlfSBtaWRkbGV3YXJlIC0gTWlkZGxld2FyZSB0byBhZGQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFthZnRlckFsbCA9IHRydWVdIC0gQm9vbGVhbiBwYXJhbWV0ZXIgd2hlcmUgdG8gcHV0IHRoZSBtaWRkbGV3YXJlLlxyXG4gICAqIFRydXRoeSBwYXJhbWV0ZXIgc3RhbmRzIGZvciBcInRvIHRoZSBlbmRcIiBhbmQgZmFsc2V5IGZvciBcInRvIHRoZSBiZWdpbm5pbmdcIi5cclxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWlkZGxld2FyZSB0aGF0IGlzIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdC5cclxuICAgKiBJZiB0aGUgbWlkZGxld2FyZSBoYXMgMiBvciBsZXNzIGFyZ3VtZW50cyBpdCdzIHRyZWF0ZWQgYXMgc3VjY2VzcyBtaWRkbGV3YXJlIG90aGVyd2lzZSBhcyBhbiBlcnJvciBvbmUuXHJcbiAgICogSWYgdGhlIG1pZGRsZXdhcmUgcmV0dXJucyBhIHByb21pc2UgaXQgYmVjb21lcyBhIHBhcnQgb2YgdGhlIG1pZGRsZXdhcmUgY2hhaW4uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKClcclxuICAgKiAgIC5hZnRlcigoZXJyLCByZXMpID0+IHtcclxuICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgKlxyXG4gICAqICAgICB0aHJvdyBlcnI7XHJcbiAgICogICB9KVxyXG4gICAqICAgLmFmdGVyKChyZXMpID0+IHtcclxuICAgKiAgICAgcmVzLmpzb24gPSBEKHJlcy5kYXRhKS5wYXJzZUpTT04oKTpcclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG4gIGFmdGVyKG1pZGRsZXdhcmUsIGFmdGVyQWxsID0gdHJ1ZSkge1xyXG4gICAgdmFsaWRhdGUoW21pZGRsZXdhcmVdLCBbJ2Z1bmN0aW9uJ10sICdGZXRjaCNhZnRlcicpO1xyXG5cclxuICAgIGNvbnN0IHsgYWZ0ZXIgfSA9IHRoaXMuJCQ7XHJcblxyXG4gICAgaWYgKGFmdGVyQWxsKSB7XHJcbiAgICAgIGFmdGVyLnB1c2gobWlkZGxld2FyZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZnRlci51bnNoaWZ0KG1pZGRsZXdhcmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGZXRjaCNiZWZvcmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtGZXRjaEJlZm9yZU1pZGRsZXdhcmV8RmV0Y2hFcnJvckJlZm9yZU1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBNaWRkbGV3YXJlIHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2JlZm9yZUFsbCA9IHRydWVdIC0gQm9vbGVhbiBwYXJhbWV0ZXIgd2hlcmUgdG8gcHV0IHRoZSBtaWRkbGV3YXJlLlxyXG4gICAqIFRydXRoeSBwYXJhbWV0ZXIgc3RhbmRzIGZvciBcInRvIHRoZSBiZWdpbm5pbmdcIiBhbmQgZmFsc2V5IGZvciBcInRvIHRoZSBlbmRcIi5cclxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWlkZGxld2FyZSB0aGF0IGlzIGNhbGxlZCBiZWZvcmUgdGhlIHJlcXVlc3QuXHJcbiAgICogSWYgdGhlIG1pZGRsZXdhcmUgaGFzIDIgb3IgbGVzcyBhcmd1bWVudHMgaXQncyB0cmVhdGVkIGFzIHN1Y2Nlc3MgbWlkZGxld2FyZSBvdGhlcndpc2UgYXMgYW4gZXJyb3Igb25lLlxyXG4gICAqIElmIHRoZSBtaWRkbGV3YXJlIHJldHVybnMgYSBwcm9taXNlIGl0IGJlY29tZXMgYSBwYXJ0IG9mIHRoZSBtaWRkbGV3YXJlIGNoYWluLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpXHJcbiAgICogICAuYmVmb3JlKChlcnIsIHJlcSkgPT4ge1xyXG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAqXHJcbiAgICogICAgIHRocm93IGVycjtcclxuICAgKiAgIH0pXHJcbiAgICogICAuYmVmb3JlKChyZXEpID0+IHtcclxuICAgKiAgICAgaWYgKHJlcS51cmwgPT09ICcvdmVyeUxvbmdSZXF1ZXN0Jykge1xyXG4gICAqICAgICAgIHJlcS50aW1lb3V0ID0gMzAwMDA7XHJcbiAgICogICAgIH1cclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG4gIGJlZm9yZShtaWRkbGV3YXJlLCBiZWZvcmVBbGwgPSB0cnVlKSB7XHJcbiAgICB2YWxpZGF0ZShbbWlkZGxld2FyZV0sIFsnZnVuY3Rpb24nXSwgJ0ZldGNoI2JlZm9yZScpO1xyXG5cclxuICAgIGNvbnN0IHsgYmVmb3JlIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmIChiZWZvcmVBbGwpIHtcclxuICAgICAgYmVmb3JlLnVuc2hpZnQobWlkZGxld2FyZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiZWZvcmUucHVzaChtaWRkbGV3YXJlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjY29uZmlnXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZldGNoQ29uZmlnfEZldGNoQ29uZmlnRnVuY3Rpb259IFtwcm9wZXJ0eV0gLSBJZiBpdCdzIGEgZnVuY3Rpb25cclxuICAgKiBpdCdzIGNhbGxlZCB3aXRoIHRoZSBmZXRjaCBjb25maWcgYXJndW1lbnQsIGlmIGl0J3MgYSBzdHJpbmcgdGhlIHZhbHVlIGFyZ3VtZW50XHJcbiAgICogaXMgdXNlZCBmb3IgYXNzaWduaW5nIHRoaXMgcHJvcGVydHkgdG8gdGhlIGZldGNoIGNvbmZpZ1xyXG4gICAqIG90aGVyd2lzZSBpdCdzIGFzc2lnbmVkIHRvIHRoZSBmZXRjaCBjb25maWcuXHJcbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gU2VlIHRoZSBwcm9wZXJ0eSBhcmd1bWVudC5cclxuICAgKiBAcmV0dXJucyB7RmV0Y2h8RmV0Y2hDb25maWd9IElmIHRoZSBhcmd1bWVudCBpcyBwcmVzZW50IHRoaXMgaXMgcmV0dXJuZWQgb3RoZXJ3aXNlIHRoZSBmZXRjaCBjb25maWcgaXMgcmV0dXJuZWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyBjb25maWcuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKCk7XHJcbiAgICpcclxuICAgKiBmZXRjaC5jb25maWcoeyBiYXNlVVJMOiA1MDAwIH0pO1xyXG4gICAqIGZldGNoLmNvbmZpZygpLnRpbWVvdXQ7IC8vIDUwMDBcclxuICAgKlxyXG4gICAqIGZldGNoLmNvbmZpZygoY29uZmlnKSA9PiB7XHJcbiAgICogICBjb25maWcuYmFzZVVSTCArPSAnL2FwaSc7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgY29uZmlnKHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgY29uc3QgY29uZiA9IHRoaXMuJCQ7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBjb25mO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Z1bmN0aW9uKHByb3BlcnR5KSkge1xyXG4gICAgICBwcm9wZXJ0eShjb25mKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmV3IFN1cGVyKGNvbmYpLmRlZXBBc3NpZ24ocHJvcGVydHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGZXRjaCNkZWxldGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt1cmxdIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgZGVsZXRlIHJlcXVlc3RzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRmV0Y2goKS5kZWxldGUoJy9kYXRhJykudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIGRlbGV0ZSh1cmwsIGNvbmZpZyA9IHt9KSB7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgY29uZmlnID0gdXJsO1xyXG4gICAgICB1cmwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwsIGFzc2lnbih7IG1ldGhvZDogJ2RlbGV0ZScgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI2dldFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBnZXQgcmVxdWVzdHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBGZXRjaCgpLmdldCgnL2RhdGEnKS50aGVuKChyZXMpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgZ2V0KHVybCwgY29uZmlnID0ge30pIHtcclxuICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICBjb25maWcgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjaGVhZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBoZWFkIHJlcXVlc3RzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRmV0Y2goKS5oZWFkKCcvZGF0YScpLnRoZW4oKHJlcykgPT4ge1xyXG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBoZWFkKHVybCwgY29uZmlnID0ge30pIHtcclxuICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICBjb25maWcgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAnaGVhZCcgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI2hlYWRlcnNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZ3xTdHJpbmdbXT59IGhlYWRlciAtIEEgaGVhZGVyIHN0cmluZyBvciBhbiBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XHJcbiAgICogeyBbaGVhZGVyXTogW3ZhbHVlMSwgdmFsdWUyLCAuLi5dIH0uXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFt2YWx1ZV0gLSBIZWFkZXIgdmFsdWUuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xyXG4gICAqIHRoaXMgaGFzIHRvIGJlIGEgaGVhZGVyIHZhbHVlIG9yIGFuIGFycmF5IG9mIGhlYWRlciB2YWx1ZXMuXHJcbiAgICogQHJldHVybnMge0ZldGNofSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2V0dGluZyByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKClcclxuICAgKiAgIC5oZWFkZXJzKCdIZWFkZXIxJywgJ1ZhbHVlJylcclxuICAgKiAgIC5oZWFkZXJzKCdIZWFkZXIyJywgWydWYWx1ZTEnLCAnVmFsdWUyJ10pXHJcbiAgICogICAuaGVhZGVycyh7XHJcbiAgICogICAgIEhlYWRlcjM6IFsnVmFsdWUxJywgJ1ZhbHVlMiddXHJcbiAgICogICB9KTtcclxuICAgKi9cclxuICBoZWFkZXJzKGhlYWRlciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gdGhpcy4kJDtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGhlYWRlciA9IHsgW2hlYWRlcl06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgaXRlcmF0ZShoZWFkZXIsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5ID0gaGVhZGVyc1toZWFkZXJdIHx8IFtdO1xyXG4gICAgICBjb25zdCB0b1B1c2ggPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcclxuXHJcbiAgICAgIChoZWFkZXJzW2hlYWRlcl0gPSBhcnJheSkucHVzaC5hcHBseShhcnJheSwgdG9QdXNoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGZXRjaCNpbnN0YW5jZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIE5ldyBjb25maWcgaWYgbmVlZGVkLlxyXG4gICAqIEByZXR1cm5zIHtGZXRjaH0gTmV3IGluc3RhbmNlIG9mIEZldGNoLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBmZXRjaCBpbnN0YW5jZXMgYmFzZWQgb24gYWxyZWFkeSBleGlzdGVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgbWFpbkZldGNoID0gbmV3IEZldGNoKHtcclxuICAgKiAgIGJhc2VVUkw6ICcvL290aGVyLmRvbWFpbi5jb20vYXBpJyxcclxuICAgKiAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZVxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogY29uc3QgbG9uZ0ZldGNoID0gbWFpbkZldGNoLmluc3RhbmNlKHtcclxuICAgKiAgIHRpbWVvdXQ6IDEwMDAwXHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgaW5zdGFuY2UoY29uZmlnID0ge30pIHtcclxuICAgIGNvbnN0IGRhdGFDb25maWcgPSBuZXcgU3VwZXIoY29uZmlnKS5oYXNPd24oJ2RhdGEnKVxyXG4gICAgICA/IHsgZGF0YTogY29uZmlnLmRhdGEgfVxyXG4gICAgICA6IHt9O1xyXG5cclxuICAgIGRlbGV0ZSBjb25maWcuZGF0YTtcclxuXHJcbiAgICBjb25zdCBjb25mID0gbmV3IFN1cGVyKHt9KVxyXG4gICAgICAuZGVlcEFzc2lnbih0aGlzLiQkLCBjb25maWcpXHJcbiAgICAgIC5hc3NpZ24oZGF0YUNvbmZpZylcclxuICAgICAgLiQ7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBGZXRjaChjb25mKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjcGF0Y2hcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt1cmxdIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyIGZvciB1cGxvYWRpbmcgZGF0YS5cclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgaGVhZCByZXF1ZXN0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEZldGNoKCkucGF0Y2goJy9kYXRhJywgeyB1c2VyOiAnSm9obicgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHBhdGNoKHVybCwgZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgIWlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgY29uZmlnID0gZGF0YTtcclxuICAgICAgZGF0YSA9IHVybDtcclxuICAgICAgdXJsID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsLCBhc3NpZ24oeyBtZXRob2Q6ICdwYXRjaCcsIGRhdGEgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI3Bvc3RcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt1cmxdIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyIGZvciB1cGxvYWRpbmcgZGF0YS5cclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgaGVhZCByZXF1ZXN0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEZldGNoKCkucG9zdCgnL2RhdGEnLCB7IHVzZXI6ICdKb2huJyB9KS50aGVuKChyZXMpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgcG9zdCh1cmwsIGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmICFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgIGNvbmZpZyA9IGRhdGE7XHJcbiAgICAgIGRhdGEgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAncG9zdCcsIGRhdGEgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI3B1dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXIgZm9yIHVwbG9hZGluZyBkYXRhLlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBoZWFkIHJlcXVlc3RzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRmV0Y2goKS5wdXQoJy9kYXRhJywgeyB1c2VyOiAnSm9obicgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHB1dCh1cmwsIGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmICFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgIGNvbmZpZyA9IGRhdGE7XHJcbiAgICAgIGRhdGEgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAncHV0JywgZGF0YSB9LCBjb25maWcpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjcmVxdWVzdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBVUkwgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gQWRkaXRpb25hbCBjb25maWcgZm9yIHRoaXMgcGFydGljdWxhciByZXF1ZXN0LlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxGZXRjaFJlc3BvbnNlLCBFcnJvcj59IFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXF1ZXN0IHJlc3BvbnNlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNYWluIGZ1bmN0aW9uIGZvciBtYWtpbmcgcmVxdWVzdHMuIEFsbCByZXF1ZXN0IG1ldGhvZHMgY2FsbCB0aGlzIG1ldGhvZFxyXG4gICAqIGluY2x1ZGluZyB0aGUgZmV0Y2ggaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpO1xyXG4gICAqXHJcbiAgICogZmV0Y2gucmVxdWVzdCgnL2RhdGEnLCB7IHRpbWVvdXQ6IDEwMDAgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogZmV0Y2gucmVxdWVzdCh7IHRpbWVvdXQ6IDEwMDAgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogZmV0Y2gucmVxdWVzdCgpLnRoZW4oKHJlcykgPT4ge1xyXG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICByZXF1ZXN0KHVybCwgY29uZmlnID0ge30pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgIGNvbmZpZyA9IHVybDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhQ29uZmlnID0gbmV3IFN1cGVyKGNvbmZpZykuaGFzT3duKCdkYXRhJylcclxuICAgICAgPyB7IGRhdGE6IGNvbmZpZy5kYXRhIH1cclxuICAgICAgOiB7fTtcclxuICAgIGNvbnN0IHVybENvbmZpZyA9IGlzU3RyaW5nKHVybClcclxuICAgICAgPyB7IHVybCB9XHJcbiAgICAgIDoge307XHJcblxyXG4gICAgZGVsZXRlIGNvbmZpZy5kYXRhO1xyXG5cclxuICAgIGNvbnN0IGNvbmYgPSBuZXcgU3VwZXIodGhpcy4kJClcclxuICAgICAgLmRlZXBDbG9uZSgpXHJcbiAgICAgIC5kZWVwQXNzaWduKHVybENvbmZpZywgY29uZmlnKVxyXG4gICAgICAuYXNzaWduKGRhdGFDb25maWcpXHJcbiAgICAgIC4kO1xyXG5cclxuICAgIGxldCB4aHI7XHJcbiAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5cclxuICAgIGl0ZXJhdGUoY29uZi5iZWZvcmUsIChtaWRkbGV3YXJlKSA9PiB7XHJcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIGlmIChtaWRkbGV3YXJlLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgIHJlc29sdmUobWlkZGxld2FyZShjb25mKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sIChlcnIpID0+IHtcclxuICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZShtaWRkbGV3YXJlKGVyciwgY29uZikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgYWZ0ZXIsXHJcbiAgICAgICAgYXV0aDoge1xyXG4gICAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgICBwYXNzd29yZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIG1ldGhvZCxcclxuICAgICAgICBvbnByb2dyZXNzLFxyXG4gICAgICAgIHJlc3BvbnNlVHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHVybCxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHNcclxuICAgICAgfSA9IGNvbmY7XHJcblxyXG4gICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlLCB1c2VybmFtZSwgcGFzc3dvcmQpO1xyXG5cclxuICAgICAgaXRlcmF0ZShoZWFkZXJzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChvbnByb2dyZXNzKSB7XHJcbiAgICAgICAgaWYgKHVwbG9hZE1ldGhvZHMuaW5kZXhPZlN0cmljdChtZXRob2QpID09PSAtMSkge1xyXG4gICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBvbnByb2dyZXNzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBvbnByb2dyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIGFib3J0ZWQnKTtcclxuXHJcbiAgICAgICAgZXJyb3IudHlwZSA9ICdBQk9SVF9FUlJPUic7XHJcblxyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcblxyXG4gICAgICAgIHhociA9IG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB4aHIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpO1xyXG5cclxuICAgICAgICBlcnJvci50eXBlID0gJ05FVFdPUktfRVJST1InO1xyXG5cclxuICAgICAgICByZWplY3QoZXJyb3IpO1xyXG5cclxuICAgICAgICB4aHIgPSBudWxsO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgeGhyLm9udGltZW91dCA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCB0aW1lIGV4Y2VlZGVkJyk7XHJcblxyXG4gICAgICAgIGVycm9yLnR5cGUgPSAnVElNRU9VVF9FUlJPUic7XHJcblxyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcblxyXG4gICAgICAgIHhociA9IG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICgheGhyIHx8ICF4aHIuc3RhdHVzIHx8IHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcclxuICAgICAgICAgIGNvbmZpZzogY29uZixcclxuICAgICAgICAgIGRhdGE6ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyB4aHIucmVzcG9uc2VUZXh0IDogeGhyLnJlc3BvbnNlLFxyXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSksXHJcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHhoci5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgeGhyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuXHJcbiAgICAgICAgaXRlcmF0ZShhZnRlciwgKG1pZGRsZXdhcmUpID0+IHtcclxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShtaWRkbGV3YXJlKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgIHJlc29sdmUobWlkZGxld2FyZShlcnIsIHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlc29sdmUocHJvbWlzZVxyXG4gICAgICAgICAgLnRoZW4oKCkgPT4gcmVzcG9uc2UpXHJcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGVyci5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICB4aHIudGltZW91dCA9IE51bWJlcih0aW1lb3V0KSB8fCAwO1xyXG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISF3aXRoQ3JlZGVudGlhbHM7XHJcblxyXG4gICAgICB4aHIuc2VuZChkYXRhKTtcclxuICAgIH0pKTtcclxuXHJcbiAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XHJcbiAgICAgIGlmICh4aHIpIHtcclxuICAgICAgICB4aHIuYWJvcnQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhGZXRjaC5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0ZldGNoJ1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZmV0Y2hCZWZvcmVNaWRkbGV3YXJlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IGNvbmZpZ1xyXG4gKiBAZGVzY3JpcHRpb24gQnVpbHQtaW4gYmVmb3JlIG1pZGRsZXdhcmUgZm9yIHVybCwgZGF0YSwgbWV0aG9kLCBoZWFkZXJzIGNvbnN0cnVjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGZldGNoQmVmb3JlTWlkZGxld2FyZShjb25maWcpIHtcclxuICBjb25zdCB7XHJcbiAgICBiYXNlVVJMLFxyXG4gICAgZGF0YSxcclxuICAgIGhlYWRlcnMsXHJcbiAgICBtZXRob2QsXHJcbiAgICBwYXJhbXMsXHJcbiAgICBxdWVyeSxcclxuICAgIHVybFxyXG4gIH0gPSBjb25maWc7XHJcbiAgY29uc3QgTUVUSE9EID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gIGNvbmZpZy5tZXRob2QgPSBNRVRIT0Q7XHJcbiAgY29uZmlnLnVybCA9IGNvbnN0cnVjdFVSTChiYXNlVVJMLCB1cmwsIHBhcmFtcywgcXVlcnkpO1xyXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShkYXRhLCBNRVRIT0QsIGhlYWRlcnMpO1xyXG4gIGNvbmZpZy5oZWFkZXJzID0gbmV3IFN1cGVyKGhlYWRlcnMpLm9iamVjdCgoaGVhZGVycywgdmFsdWVzLCBoZWFkZXIpID0+IHtcclxuICAgIGhlYWRlciA9IG5ldyBTdHIoaGVhZGVyKVxyXG4gICAgICAudG9DYXBpdGFsQ2FzZSgpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJylcclxuICAgICAgLiQ7XHJcblxyXG4gICAgaGVhZGVyc1toZWFkZXJdID0gdmFsdWVzLmpvaW4oJywgJyk7XHJcbiAgfSkuJDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7RmV0Y2h9IGZldGNoXHJcbiAqIEB0eXBlIHtGZXRjaH1cclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRW1wdHkgaW5zdGFuY2Ugb2YgRmV0Y2guXHJcbiAqL1xyXG5jb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpO1xyXG5cclxuZXhwb3J0IHsgRmV0Y2gsIGZldGNoIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvcmVzb2x2ZVVSTFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBPYmplY3QuYXNzaWduLWxpa2UgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XHJcblxyXG5jb25zdCB7IGxvY2F0aW9uIH0gPSBnbG9iYWw7XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZGVjb2RlUXVlcnkpID0+IHtcclxuICBjb25zdCB7XHJcbiAgICBzZWFyY2g6IHF1ZXJ5LFxyXG4gICAgaGFzaFxyXG4gIH0gPSBsb2NhdGlvbjtcclxuICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICBxdWVyeToge30sXHJcbiAgICBoYXNoOiBoYXNoLnJlcGxhY2UoL14jLywgJycpXHJcbiAgfTtcclxuXHJcbiAgaWYgKCFxdWVyeSkge1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIG5ldyBTdHIocXVlcnkucmVwbGFjZSgvXlxcPy8sICcnKSlcclxuICAgIC5zcGxpdCgnJicpXHJcbiAgICAuZm9yRWFjaCgocmF3UGFyYW0pID0+IHtcclxuICAgICAgbGV0IFtwYXJhbSwgdmFsdWUgPSAnJ10gPSByYXdQYXJhbS5zcGxpdCgnPScpO1xyXG5cclxuICAgICAgcGFyYW0gPSBkZWNvZGVRdWVyeSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBwYXJhbTtcclxuICAgICAgdmFsdWUgPSBkZWNvZGVRdWVyeSA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcbiAgICAgIGlmICghL15bXltdKy8udGVzdChwYXJhbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBwYXJhbU5hbWU7XHJcbiAgICAgIGxldCBwYXJhbU9iamVjdCA9IHBhcmFtcy5xdWVyeTtcclxuXHJcbiAgICAgIG5ldyBTdHIocGFyYW0pXHJcbiAgICAgICAgLm1hdGNoKC9eW15bXFxdXSp8XFxbW15bXFxdXSpdL2cpXHJcbiAgICAgICAgLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ1snKSkge1xyXG4gICAgICAgICAgICBwYXJhbU5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcclxuXHJcbiAgICAgICAgICBwYXJhbU9iamVjdCA9IHBhcmFtT2JqZWN0W3BhcmFtTmFtZV0gPSBwYXJhbU9iamVjdFtwYXJhbU5hbWVdIHx8IChuYW1lID8ge30gOiBbXSk7XHJcbiAgICAgICAgICBwYXJhbU5hbWUgPSBuYW1lIHx8IHBhcmFtT2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIHBhcmFtT2JqZWN0W3BhcmFtTmFtZV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICByZXR1cm4gcGFyYW1zO1xyXG59O1xyXG4iLCIvKipcbiAqIEBtb2R1bGUgUm91dGVyXG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBSb3V0ZXIuXG4gKi9cblxuaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi9BcnInO1xuaW1wb3J0IHsgRWxlbSwgd2luIH0gZnJvbSAnLi9FbGVtJztcbmltcG9ydCB7IHNlbGYgfSBmcm9tICcuL0Z1bmMnO1xuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9TdHInO1xuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi9Td2l0Y2hlcic7XG5pbXBvcnQgeyBhc3NpZ24sIGlzTmlsLCBpc1JlZ0V4cCwgaXNTdHJpbmcgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IGNvbnN0cnVjdFVSTCBmcm9tICcuL2hlbHBlcnMvY29uc3RydWN0VVJMJztcbmltcG9ydCByZXNvbHZlVVJMIGZyb20gJy4vaGVscGVycy9yZXNvbHZlVVJMJztcblxuY29uc3QgUm91dGVzID0gbmV3IEFycihbXSk7XG5jb25zdCBjdXJyZW50Um91dGVzID0gbmV3IEFycihbXSk7XG5jb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTdXBlcih7fSk7XG5jb25zdCB7XG4gIGhpc3RvcnksXG4gIGxvY2F0aW9uLFxuICBsb2NhdGlvbjoge1xuICAgIG9yaWdpbixcbiAgICBocmVmXG4gIH1cbn0gPSBnbG9iYWw7XG5sZXQgaW5pdGlhbGl6ZWQ7XG5sZXQgcHVzaGVkO1xubGV0IHdhc1Jvb3Q7XG5sZXQgd2FzRGVmYXVsdDtcbmxldCByb290Um91dGU7XG5sZXQgcmVkaXJlY3RSb3V0ZTtcbmxldCBSZWRpcmVjdFJvdXRlO1xubGV0IGRlZmF1bHRSb3V0ZTtcbmxldCBEZWZhdWx0Um91dGU7XG5sZXQgY3VycmVudFJvdXRlO1xubGV0IGN1cnJlbnRSb3V0ZVBhcmFtcztcblxuY29uc3QgcGF0aFN3aXRjaGVyID0gc3dpdGNoZXIoJ2NhbGwnLCAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignU3RhdGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nLCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciB1bmRlZmluZWQhIChhdCByZWdpc3RlclN0YXRlKScpO1xufSlcbiAgLmNhc2UoaXNSZWdFeHAsIChwYXRoKSA9PiAoe1xuICAgIHBhdGg6IHBhdGguc291cmNlLnJlcGxhY2UoL1xcXFxcXC8vZywgJy8nKSxcbiAgICB1cmw6IHBhdGgsXG4gICAgcGFyYW1zOiB7fVxuICB9KSlcbiAgLmNhc2UoaXNOaWwsICgpID0+ICh7XG4gICAgcGF0aDogJy8nLFxuICAgIHVybDogJy8nLFxuICAgIHBhcmFtczoge31cbiAgfSkpXG4gIC5jYXNlKGlzU3RyaW5nLCAocGF0aCkgPT4ge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiByb3V0ZSBwYXRoIGlzIGEgc3RyaW5nIGl0IG11c3Qgc3RhcnQgd2l0aCBcIi9cIiEgKGF0IHJlZ2lzdGVyU3RhdGUpJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgU3VwZXIoe30pO1xuICAgIGxldCBuZXdVUkwgPSAnJztcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFN0cihwYXRoKVxuICAgICAgLnNsaWNlKDAsIGluZGV4ID09PSAtMSA/IHBhdGgubGVuZ3RoIDogaW5kZXgpXG4gICAgICAucmVwbGFjZSgvXlxcL3xcXC8kL2cpXG4gICAgICAuc3BsaXQoL1xcLy8pXG4gICAgICAubWFwKChwYXJ0LCBpLCBhcnJheSkgPT4ge1xuICAgICAgICBpZiAoIXBhcnQgJiYgYXJyYXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgcm91dGUgcGF0aCBpcyBhIHN0cmluZyBpdCBtdXN0IG5vdCBjb250YWluIFwiLy9cIiBvciBlbmQgd2l0aCBcIi9cIiEgKGF0IG1ha2VSb3V0ZSknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFydC5pbmRleE9mKCc6Jyk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgcm91dGUgcGF0aCBpcyBhIHN0cmluZyByZXNvdXJjZSBwYXJ0IG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIFVSTCBwYXJhbWV0ZXIhIChhdCBtYWtlUm91dGUpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogcGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHJlZ2V4cCA9IC9bXi9dKi9cbiAgICAgICAgfSA9IHJlc29sdmVQYXJhbWV0ZXIoXG4gICAgICAgICAgcGFydC5zbGljZSgxKSxcbiAgICAgICAgICAnVVJMIHBhcmFtZXRlciBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcgb3IgY29udGFpbiBjaGFyYWN0ZXJzIGJlc2lkZXMgXCJhLXpBLVpfJFwiISAoYXQgbWFrZVJvdXRlKScsXG4gICAgICAgICAgJ1VSTCBwYXJhbWV0ZXIgcmVnZXhwIHZhbGlkYXRvciBtdXN0IGJlIHdpdGhpbiBwYXJlbnRoZXNlcyAoZS5nLiA6dXNlcklkKFxcXFxkKykgYW5kIG5vdCBjb250YWluIG9uZXMpISAoYXQgbWFrZVJvdXRlKSdcbiAgICAgICAgKTtcblxuICAgICAgICBwYXJhbXMuJFtuYW1lXSA9IHBhcmFtcy5jb3VudDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdwYXJhbScsXG4gICAgICAgICAgdXJsOiBgOiR7IG5hbWUgfWAsXG4gICAgICAgICAgdmFsdWU6IHJlZ2V4cFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICAgIC53b3JkKCh7IHR5cGUsIHVybCwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBsZXQgbmV3UGF0aDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3BhcmFtJykge1xuICAgICAgICAgIG5ld1BhdGggPSBgKCR7IHZhbHVlLnNvdXJjZS5yZXBsYWNlKC9cXFxcXFwvL2csICcvJykgfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1BhdGggPSBuZXcgU3RyKHZhbHVlKS5lc2NhcGVSZWdFeHAoKS4kO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3VVJMICs9IGAvJHsgdXJsIH1gO1xuXG4gICAgICAgIHJldHVybiBgLyR7IG5ld1BhdGggfWA7XG4gICAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgdXJsOiBuZXdVUkwsXG4gICAgICBwYXJhbXM6IHBhcmFtcy4kXG4gICAgfTtcbiAgfSk7XG5cbmNsYXNzIFJvdXRlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHBhdGggPSAnLycsXG4gICAgICBhYnN0cmFjdCA9IGZhbHNlLFxuICAgICAgcGFyZW50LFxuICAgICAgZGVjb2RlUXVlcnkgPSB0cnVlLFxuICAgICAgZW5jb2RlUXVlcnkgPSB0cnVlLFxuICAgICAgZGVjb2RlUGFyYW1zID0gdHJ1ZSxcbiAgICAgIGVuY29kZVBhcmFtcyA9IHRydWVcbiAgICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCB7XG4gICAgICB1cmw6IHJlbGF0aXZlVVJMLFxuICAgICAgcGF0aDogcmVsYXRpdmVQYXRoLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHBhdGhTd2l0Y2hlcihwYXRoKTtcbiAgICBjb25zdCBxdWVyeSA9IHt9O1xuXG4gICAgbmV3IFN1cGVyKHRoaXMpLmFzc2lnbih7XG4gICAgICBuYW1lLFxuICAgICAgcGFyZW50TmFtZTogcGFyZW50LFxuICAgICAgYWJzdHJhY3Q6ICEhYWJzdHJhY3QsXG4gICAgICBjaGlsZHJlbjogbmV3IEFycihbXSksXG4gICAgICBkZWNvZGVQYXJhbXM6ICEhZGVjb2RlUGFyYW1zLFxuICAgICAgZGVjb2RlUXVlcnk6ICEhZGVjb2RlUXVlcnksXG4gICAgICBlbmNvZGVQYXJhbXM6ICEhZW5jb2RlUGFyYW1zLFxuICAgICAgZW5jb2RlUXVlcnk6ICEhZW5jb2RlUXVlcnksXG4gICAgICBwYXJhbXMsXG4gICAgICBxdWVyeSxcbiAgICAgIHJlbGF0aXZlUGF0aCxcbiAgICAgIHJlbGF0aXZlVVJMXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbmRleCA9IGlzU3RyaW5nKHBhdGgpID8gcGF0aC5pbmRleE9mKCc/JykgOiAtMTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIG5ldyBTdHIocGF0aClcbiAgICAgICAgLnJlcGxhY2UoLyYkLylcbiAgICAgICAgLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgLnNwbGl0KCcmJylcbiAgICAgICAgLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHJlZ2V4cCA9IC9bXFxzXFxTXSovXG4gICAgICAgICAgfSA9IHJlc29sdmVQYXJhbWV0ZXIoXG4gICAgICAgICAgICBwYXJhbSxcbiAgICAgICAgICAgICdRdWVyeSBwYXJhbWV0ZXIgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nIG9yIGNvbnRhaW4gY2hhcmFjdGVycyBiZXNpZGVzIFwiYS16QS1aXyRcIiEgKGF0IG1ha2VSb3V0ZSknLFxuICAgICAgICAgICAgJ1F1ZXJ5IHBhcmFtZXRlciByZWdleHAgdmFsaWRhdG9yIG11c3QgYmUgd2l0aGluIHBhcmVudGhlc2VzIChlLmcuIDp1c2VySWQoXFxcXGQrKSkgYW5kIG5vdCBjb250YWluIHRoZW0hIChhdCBtYWtlUm91dGUpJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBxdWVyeVtuYW1lXSA9IG5ldyBSZWdFeHAoYF4keyByZWdleHAuc291cmNlLnJlcGxhY2UoL1xcXFxcXC8vZywgJy8nKSB9JGApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gZGVmYXVsdFJvdXRlICYmIChcbiAgICAgICAgbmV3IFN1cGVyKHBhcmFtcykuY291bnRcbiAgICAgICAgfHwgbmV3IFN1cGVyKHF1ZXJ5KS5jb3VudFxuICAgICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHJvdXRlIG11c3Qgbm90IGhhdmUgVVJMIG9yIHF1ZXJ5IHBhcmFtcyEgKGF0IG1ha2VSb3V0ZSknKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgYmFzZVJvdXRlID0gbmV3IFJvdXRlKCk7XG5cbmZ1bmN0aW9uIGluaXRSb3V0ZXIoKSB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgUmVkaXJlY3RSb3V0ZSA9IChSb3V0ZXMuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IHJlZGlyZWN0Um91dGUpIHx8IHt9KS52YWx1ZTtcbiAgRGVmYXVsdFJvdXRlID0gKFJvdXRlcy5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gZGVmYXVsdFJvdXRlKSB8fCB7fSkudmFsdWU7XG5cbiAgaWYgKHJlZGlyZWN0Um91dGUgJiYgIVJlZGlyZWN0Um91dGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIHNwZWNpZmllZCBmYWxsYmFjayByb3V0ZSAoXCIkeyByZWRpcmVjdFJvdXRlIH1cIikhIChhdCBpbml0Um91dGVyKWApO1xuICB9XG5cbiAgUm91dGVzXG4gICAgLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSByb3V0ZTtcbiAgICAgIGNvbnN0IFBhcmVudE5hbWUgPSBwYXJlbnROYW1lIHx8IHJvb3RSb3V0ZTtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IHBhcmVudCB9ID0gUm91dGVzLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBQYXJlbnROYW1lKSB8fCB7fTtcblxuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdWNoIHBhcmVudCByb3V0ZSAoXCIkeyBQYXJlbnROYW1lIH1cIikgZm91bmQgZm9yIHRoZSByb3V0ZSAoXCIkeyBuYW1lIH1cIikhIChhdCBpbml0Um91dGVyKWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmVudC5hYnN0cmFjdCAmJiBuYW1lICE9PSByb290Um91dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJlbnQgcm91dGUgbXVzdCBiZSBhYnN0cmFjdCAoZm9yIFwiJHsgbmFtZSB9XCIpISAoYXQgaW5pdFJvdXRlcilgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgIT09IHJvb3RSb3V0ZSkge1xuICAgICAgICByb3V0ZS5wYXJlbnROYW1lID0gUGFyZW50TmFtZTtcbiAgICAgIH1cblxuICAgICAgcm91dGUucGFyZW50ID0gbmFtZSA9PT0gcm9vdFJvdXRlXG4gICAgICAgID8gYmFzZVJvdXRlXG4gICAgICAgIDogcGFyZW50O1xuICAgIH0pXG4gICAgLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhcmFtczogcGFyZW50UGFyYW1zLFxuICAgICAgICAgIHF1ZXJ5OiBwYXJlbnRRdWVyeSxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHJlbGF0aXZlVVJMLFxuICAgICAgICByZWxhdGl2ZVBhdGhcbiAgICAgIH0gPSByb3V0ZTtcbiAgICAgIGxldCBwcm90byA9IHJvdXRlO1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGxldCBuZXdQYXRoID0gcmVsYXRpdmVQYXRoO1xuICAgICAgbGV0IG5ld1VSTCA9ICcnO1xuXG4gICAgICBpZiAoaXNSZWdFeHAocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgcmVnZXhwIHJvdXRlIGNhbm5vdCBiZSBleHRlbmRlZCEgKGF0IGluaXRSb3V0ZXIpJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwcm90byA9IHByb3RvLnBhcmVudCkge1xuICAgICAgICBjb3VudCArPSBuZXcgU3VwZXIocHJvdG8ucGFyYW1zKS5jb3VudDtcbiAgICAgICAgbmV3UGF0aCA9IHByb3RvLnJlbGF0aXZlUGF0aCArIG5ld1BhdGg7XG4gICAgICAgIG5ld1VSTCA9IHByb3RvLnJlbGF0aXZlVVJMICsgbmV3VVJMO1xuXG4gICAgICAgIHByb3RvLmNoaWxkcmVuLnB1c2gocm91dGUpO1xuICAgICAgfVxuXG4gICAgICBuZXdQYXRoID0gbmV3IFJlZ0V4cChgXiR7IG5ld1BhdGgucmVwbGFjZSgvXFwvKy9nLCAnLycpLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nIH0kYCk7XG4gICAgICBuZXdVUkwgPSBpc1JlZ0V4cChyZWxhdGl2ZVVSTClcbiAgICAgICAgPyBuZXdQYXRoXG4gICAgICAgIDogKG5ld1VSTCArIHJlbGF0aXZlVVJMKS5yZXBsYWNlKC9cXC8rL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLyc7XG5cbiAgICAgIG5ldyBTdXBlcihxdWVyeSkucHJvdG8ocGFyZW50UXVlcnkpO1xuICAgICAgbmV3IFN1cGVyKHBhcmFtcylcbiAgICAgICAgLnByb3RvKHBhcmVudFBhcmFtcylcbiAgICAgICAgLmZvckVhY2goKHZhbHVlLCBrZXksIHBhcmFtcykgPT4ge1xuICAgICAgICAgIHBhcmFtc1trZXldICs9IGNvdW50O1xuICAgICAgICB9KTtcblxuICAgICAgaWYgKG5hbWUgPT09IGRlZmF1bHRSb3V0ZSAmJiAoXG4gICAgICAgICAgbmV3IFN1cGVyKHBhcmFtcykuY291bnRcbiAgICAgICAgICB8fCBuZXcgU3VwZXIocXVlcnkpLmNvdW50XG4gICAgICAgICkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHJvdXRlIG11c3Qgbm90IGhhdmUgVVJMIG9yIHF1ZXJ5IHBhcmFtcyEgKGF0IGluaXRSb3V0ZXIpJyk7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlLnVybCA9IG5ld1VSTDtcbiAgICAgIHJvdXRlLnZhbGlkYXRlUGF0aCA9IG5ld1BhdGg7XG4gICAgfSk7XG5cbiAgY2hhbmdlUm91dGUoKTtcblxuICB3aW4ub24oe1xuICAgIHBvcHN0YXRlKCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhyZWYgIT09IGhyZWYpIHtcbiAgICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHB1c2hlZCkge1xuICAgICAgICBjaGFuZ2VSb3V0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xpY2soZSkge1xuICAgICAgY29uc3QgY2xvc2VzdExpbmsgPSBuZXcgRWxlbShlLnRhcmdldCkuY2xvc2VzdCgnYScpO1xuXG4gICAgICBpZiAoY2xvc2VzdExpbmsubGVuZ3RoICYmIGNsb3Nlc3RMaW5rLmF0dHIoJ3RhcmdldCcpICE9PSAnX2JsYW5rJykge1xuICAgICAgICBjb25zdCBwdXNoID0gIWNsb3Nlc3RMaW5rLmhhc0F0dHIoJ3JlcGxhY2UnKTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgZm9yd2FyZChjbG9zZXN0TGluay5hdHRyKCdocmVmJykgfHwgJycsIHB1c2gpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSb3V0ZShvcHRpb25zKSB7XG4gIHJldHVybiAoQmxvY2spID0+IHtcbiAgICBvcHRpb25zID0gYXNzaWduKHt9LCBvcHRpb25zLCBCbG9jay5yb3V0ZXJPcHRpb25zKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXRoLFxuICAgICAgYWJzdHJhY3QsXG4gICAgICByb290LFxuICAgICAgZmFsbGJhY2tUbyxcbiAgICAgIGRlZmF1bHQ6IGlzRGVmYXVsdFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JvdXRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZCAoYXQgbWFrZVJvdXRlKScpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBpZiAod2FzUm9vdCAmJiByb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGNhbid0IGJlIHR3byByb290IHJvdXRlcyAoXCIkeyByb290Um91dGUgfVwiIGFuZCBcIiR7IG5hbWUgfVwiKSEgKGF0IG1ha2VSb3V0ZSlgKTtcbiAgICB9XG5cbiAgICBpZiAod2FzRGVmYXVsdCAmJiBpc0RlZmF1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgY2FuJ3QgYmUgdHdvIGRlZmF1bHQgcm91dGVzIChcIiR7IGRlZmF1bHRSb3V0ZSB9XCIgYW5kIFwiJHsgbmFtZSB9XCIpISAoYXQgbWFrZVJvdXRlKWApO1xuICAgIH1cblxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBtdXN0IGhhdmUgYSBub24tZW1wdHkgc3RyaW5nIFwibmFtZVwiIHByb3BlcnR5ISAoYXQgbWFrZVJvdXRlKScpO1xuICAgIH1cblxuICAgIGlmIChSb3V0ZXMuc29tZSgoeyBuYW1lOiBOYW1lIH0pID0+IE5hbWUgPT09IG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG11c3QgaGF2ZSB1bmlxdWUgXCJuYW1lXCIgcHJvcGVydHkhIChhdCBtYWtlUm91dGUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHdhc1Jvb3QgPSB0cnVlO1xuICAgICAgcm9vdFJvdXRlID0gbmFtZTtcbiAgICAgIG9wdGlvbnMucGFyZW50ID0gbnVsbDtcblxuICAgICAgaWYgKGZhbGxiYWNrVG8pIHtcbiAgICAgICAgcmVkaXJlY3RSb3V0ZSA9IGZhbGxiYWNrVG87XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgd2FzRGVmYXVsdCA9IHRydWU7XG4gICAgICBkZWZhdWx0Um91dGUgPSBuYW1lO1xuXG4gICAgICBpZiAoYWJzdHJhY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHJvdXRlIGNhblxcJ3QgYmUgYWJzdHJhY3QhIChhdCBtYWtlUm91dGUpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1JlZ0V4cChwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgcm91dGUgY2FuXFwndCBoYXZlIGEgcmVnZXhwIHBhdGghIChhdCBtYWtlUm91dGUpJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSBuZXcgUm91dGUob3B0aW9ucyk7XG5cbiAgICBSb3V0ZXMucHVzaChyb3V0ZSk7XG5cbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgbGV0IHJvdXRlTG9hZGVkO1xuXG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgLyogZXNsaW50IHByZWZlci10ZW1wbGF0ZTogMCAqL1xuICAgICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXYnXG4gICAgICAgICsgYCBjbGFzcz1cImR3YXluZS1yb3V0ZSByb3V0ZS0keyBuYW1lIH1cImBcbiAgICAgICAgKyAnIGQtY2xhc3M9XCJ7eyBcXCdhY3RpdmUtcm91dGVcXCc6IF9faXNDdXJyZW50Um91dGVfXyB9fVwiJ1xuICAgICAgICArICcgZC1zaG93PVwie19faXNDdXJyZW50Um91dGVfX31cIidcbiAgICAgICAgKyAnPidcbiAgICAgICAgKyBCbG9jay50ZW1wbGF0ZVxuICAgICAgICArICc8L2Rpdj4nO1xuXG4gICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgaW5pdFJvdXRlcigpO1xuXG4gICAgICAgICAgY29uc3Qgcm91dGVyID0ge1xuICAgICAgICAgICAgYnVpbGRVUkwobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IHJvdXRlIH0gPSBSb3V0ZXMuZmluZCgoeyBuYW1lOiBuIH0pID0+IG4gPT09IG5hbWUpIHx8IHt9O1xuXG4gICAgICAgICAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGFyZSBubyByb3V0ZXMgd2l0aCBuYW1lIFwiJHsgbmFtZSB9XCIhIChhdCByb3V0ZXIuYnVpbGRVUkwpYCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGVuY29kZVBhcmFtcyxcbiAgICAgICAgICAgICAgICBlbmNvZGVRdWVyeVxuICAgICAgICAgICAgICB9ID0gcm91dGU7XG5cbiAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKHVybCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBjYW4gYmUgYnVpbHQgb25seSBmcm9tIHRoZSBzdHJpbmcgVVJMcyEgKGF0IHJvdXRlci5idWlsZFVSTCknKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fSxcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHt9LFxuICAgICAgICAgICAgICAgIGhhc2ggPSAnJ1xuICAgICAgICAgICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gY29uc3RydWN0VVJMKG9yaWdpbiwgdXJsLCBwYXJhbXMsIHF1ZXJ5LCBoYXNoLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zOiBlbmNvZGVQYXJhbXMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGVuY29kZVF1ZXJ5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdvKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgZm9yd2FyZChyb3V0ZXIuYnVpbGRVUkwobmFtZSwgb3B0aW9ucyksIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdvVG9VUkwodXJsKSB7XG4gICAgICAgICAgICAgIGZvcndhcmQodXJsLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdXNoVVJMKHVybCkge1xuICAgICAgICAgICAgICBjaGFuZ2VIaXN0b3J5KHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkaXJlY3QobmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICBmb3J3YXJkKHJvdXRlci5idWlsZFVSTChuYW1lLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkaXJlY3RUb1VSTCh1cmwpIHtcbiAgICAgICAgICAgICAgZm9yd2FyZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcGxhY2VVUkwodXJsKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUhpc3RvcnkodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5nbG9iYWwucm91dGVyID0gcm91dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3JvdXRlckluc3RhbmNlX18gPSByb3V0ZTtcbiAgICAgICAgdGhpcy5fX2lzQ3VycmVudFJvdXRlX18gPSAoXG4gICAgICAgICAgcm91dGUgPT09IGN1cnJlbnRSb3V0ZVxuICAgICAgICAgIHx8IHJvdXRlLmNoaWxkcmVuLmluZGV4T2YoY3VycmVudFJvdXRlKSAhPT0gLTFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hcmdzLnJvdXRlID0gY3VycmVudFJvdXRlUGFyYW1zO1xuXG4gICAgICAgIHJvdXRlTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKG5hbWUsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpc0N1cnJlbnRSb3V0ZSA9IChcbiAgICAgICAgICAgIHJvdXRlID09PSBjdXJyZW50Um91dGVcbiAgICAgICAgICAgIHx8IHJvdXRlLmNoaWxkcmVuLmluZGV4T2YoY3VycmVudFJvdXRlKSAhPT0gLTFcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGlzQ3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICBjYWxsQmVmb3JlTG9hZCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbEJlZm9yZUxlYXZlKHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb3V0ZSA9PT0gY3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFyZ3Mucm91dGUgPSBjdXJyZW50Um91dGVQYXJhbXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fX2lzQ3VycmVudFJvdXRlX18gPSBpc0N1cnJlbnRSb3V0ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pc0N1cnJlbnRSb3V0ZV9fKSB7XG4gICAgICAgICAgY2FsbEJlZm9yZUxvYWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYmVmb3JlUmVtb3ZlKCkge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB1bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIGNhbGxCZWZvcmVMZWF2ZSh0aGlzKTtcbiAgICAgICAgc3VwZXIuYmVmb3JlUmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGxCZWZvcmVMb2FkKHJvdXRlKSB7XG4gICAgICBpZiAocm91dGVMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9jayA9IHtcbiAgICAgICAgJCQ6IHtcbiAgICAgICAgICBjaGlsZHJlbjogbmV3IEFycihbcm91dGVdKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBibG9jay4kJC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIGJlZm9yZUxvYWQoYmxvY2spIHtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBibG9jay5fX3JvdXRlckluc3RhbmNlX187XG5cbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50Um91dGVzLmluZGV4T2YoYmxvY2spO1xuICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFJvdXRlID0gKFxuICAgICAgICAgICAgcm91dGUgPT09IGN1cnJlbnRSb3V0ZVxuICAgICAgICAgICAgfHwgcm91dGUuY2hpbGRyZW4uaW5kZXhPZihjdXJyZW50Um91dGUpICE9PSAtMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xIHx8ICFpc0N1cnJlbnRSb3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRSb3V0ZXMucHVzaChibG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICBtaXhpbnNcbiAgICAgICAgfSA9IGJsb2NrLiQkO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goYmVmb3JlTG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWl4aW5zKSB7XG4gICAgICAgICAgbWl4aW5zLmZvckVhY2goYmVmb3JlTG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2suYmVmb3JlTG9hZFJvdXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJsb2NrLmJlZm9yZUxvYWRSb3V0ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZUxlYXZlOmAsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcm91dGVMb2FkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxCZWZvcmVMZWF2ZShyb3V0ZSkge1xuICAgICAgaWYgKCFyb3V0ZUxvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgICAkJDoge1xuICAgICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyKFtyb3V0ZV0pXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJsb2NrLiQkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gYmVmb3JlTGVhdmUoYmxvY2spIHtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBibG9jay5fX3JvdXRlckluc3RhbmNlX187XG5cbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50Um91dGVzLmluZGV4T2YoYmxvY2spO1xuICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFJvdXRlID0gKFxuICAgICAgICAgICAgcm91dGUgPT09IGN1cnJlbnRSb3V0ZVxuICAgICAgICAgICAgfHwgcm91dGUuY2hpbGRyZW4uaW5kZXhPZihjdXJyZW50Um91dGUpICE9PSAtMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IGlzQ3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFJvdXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgbWl4aW5zXG4gICAgICAgIH0gPSBibG9jay4kJDtcblxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGJlZm9yZUxlYXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICBtaXhpbnMuZm9yRWFjaChiZWZvcmVMZWF2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2suYmVmb3JlTGVhdmVSb3V0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBibG9jay5iZWZvcmVMZWF2ZVJvdXRlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlTGVhdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByb3V0ZUxvYWRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWUsIGNhbGxiYWNrKSB7XG4gIHN1YnNjcmliZXJzLiRbbmFtZV0gPSBjYWxsYmFjaztcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHN1YnNjcmliZXJzLmRlbGV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZCh1cmwsIHB1c2gpIHtcbiAgY2hhbmdlSGlzdG9yeSh1cmwsIHB1c2gpO1xuICBjaGFuZ2VSb3V0ZSgpO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VSb3V0ZSgpIHtcbiAgY29uc3Qgcm91dGUgPSBmaW5kUm91dGVCeVVSTCgpO1xuXG4gIGlmIChyb3V0ZSkge1xuICAgICh7XG4gICAgICByb3V0ZTogY3VycmVudFJvdXRlLFxuICAgICAgLi4uY3VycmVudFJvdXRlUGFyYW1zXG4gICAgfSA9IHJvdXRlKTtcbiAgICBhc3NpZ24oY3VycmVudFJvdXRlUGFyYW1zLCB7XG4gICAgICBuYW1lOiBjdXJyZW50Um91dGUubmFtZSxcbiAgICAgIGhvc3Q6IGxvY2F0aW9uLmhvc3QsXG4gICAgICBob3N0bmFtZTogbG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICBocmVmOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgb3JpZ2luOiBsb2NhdGlvbi5vcmlnaW4sXG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBwb3J0OiBsb2NhdGlvbi5wb3J0LFxuICAgICAgcHJvdG9jb2w6IGxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgc2VhcmNoOiBsb2NhdGlvbi5zZWFyY2hcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVkaXJlY3RSb3V0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB1cmwsXG4gICAgICAgIGVuY29kZVBhcmFtcyxcbiAgICAgICAgZW5jb2RlUXVlcnlcbiAgICAgIH0gPSBSZWRpcmVjdFJvdXRlO1xuXG4gICAgICByZXR1cm4gZm9yd2FyZChjb25zdHJ1Y3RVUkwob3JpZ2luLCB1cmwsIHt9LCB7fSwgJycsIHtcbiAgICAgICAgcGFyYW1zOiBlbmNvZGVQYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiBlbmNvZGVRdWVyeVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSb3V0ZSA9IG51bGw7XG4gICAgY3VycmVudFJvdXRlUGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbn1cblxuZnVuY3Rpb24gZmluZFJvdXRlQnlVUkwoKSB7XG4gIGNvbnN0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nO1xuICBjb25zdCBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2ggfHwgJyc7XG4gIGxldCB1cmxQYXJhbXM7XG5cbiAgUm91dGVzLnNvbWUoKHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlLmFic3RyYWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgdXJsOiByb3V0ZVVSTCxcbiAgICAgIHZhbGlkYXRlUGF0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHF1ZXJ5OiByZXF1aXJlZFF1ZXJ5LFxuICAgICAgZGVjb2RlUGFyYW1zLFxuICAgICAgZGVjb2RlUXVlcnlcbiAgICB9ID0gcm91dGU7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVVJMKGRlY29kZVF1ZXJ5KTtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBTdXBlcihyZXNvbHZlZC5xdWVyeSk7XG4gICAgY29uc3QgZXZlbnR1YWxQYXJhbXMgPSB7fTtcbiAgICBjb25zdCBtYXRjaCA9IChcbiAgICAgIChwYXRobmFtZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJykgK1xuICAgICAgKGlzUmVnRXhwKHJvdXRlVVJMKSA/IHNlYXJjaCA6ICcnKVxuICAgICkubWF0Y2godmFsaWRhdGVQYXRoKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgZm9yIChjb25zdCBwYXJhbSBpbiByZXF1aXJlZFF1ZXJ5KSB7XG4gICAgICBpZiAoIXF1ZXJ5Lmhhc093bihwYXJhbSkgfHwgIXJlcXVpcmVkUXVlcnlbcGFyYW1dLnRlc3QocXVlcnkuJFtwYXJhbV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtYXRjaC5zaGlmdCgpO1xuXG4gICAgZm9yIChjb25zdCBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGV2ZW50dWFsUGFyYW1zW3BhcmFtXSA9IGRlY29kZShtYXRjaFtwYXJhbXNbcGFyYW1dXSwgZGVjb2RlUGFyYW1zKTtcbiAgICB9XG5cbiAgICB1cmxQYXJhbXMgPSB7XG4gICAgICByb3V0ZSxcbiAgICAgIHBhcmFtczogZXZlbnR1YWxQYXJhbXMsXG4gICAgICBxdWVyeTogcXVlcnkuJCxcbiAgICAgIGhhc2g6IHJlc29sdmVkLmhhc2hcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmICh1cmxQYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsUGFyYW1zO1xuICB9XG5cbiAgaWYgKCFkZWZhdWx0Um91dGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdXRlOiBEZWZhdWx0Um91dGUsXG4gICAgcGFyYW1zOiB7fSxcbiAgICAuLi5yZXNvbHZlVVJMKERlZmF1bHRSb3V0ZS5kZWNvZGVRdWVyeSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgZGVjb2RlUGFyYW1zKSB7XG4gIHJldHVybiBkZWNvZGVQYXJhbXNcbiAgICA/IGRlY29kZVVSSUNvbXBvbmVudChzdHJpbmcpXG4gICAgOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZUhpc3RvcnkodXJsLCBwdXNoKSB7XG4gIHRyeSB7XG4gICAgaGlzdG9yeVtwdXNoID8gJ3B1c2hTdGF0ZScgOiAncmVwbGFjZVN0YXRlJ10obnVsbCwgbnVsbCwgdXJsKTtcbiAgICBwdXNoZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2NhdGlvbi5ocmVmID0gdXJsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXJhbWV0ZXIocGFyYW0sIG5hbWVFcnJvck5hbWUsIHZhbHVlRXJyb3JOYW1lKSB7XG4gIGNvbnN0IG5hbWVNYXRjaCA9IHBhcmFtLm1hdGNoKC9eW2Etel8kXSsvaSk7XG5cbiAgaWYgKCFuYW1lTWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZUVycm9yTmFtZSk7XG4gIH1cblxuICBjb25zdCBuYW1lID0gbmFtZU1hdGNoWzBdO1xuICBjb25zdCB2YWx1ZSA9IHBhcmFtLnNsaWNlKG5hbWUubGVuZ3RoKTtcbiAgbGV0IHJlZ2V4cDtcblxuICBpZiAodmFsdWUgJiYgKHZhbHVlLmluZGV4T2YoJygnKSB8fCB2YWx1ZS5pbmRleE9mKCcpJykgIT09IHZhbHVlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlRXJyb3JOYW1lKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSkge1xuICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAodmFsdWUuc2xpY2UoMSwgLTEpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICByZWdleHBcbiAgfTtcbn1cblxuZXhwb3J0IHsgbWFrZVJvdXRlIH07XG4iLCJpbXBvcnQgKiBhcyBzdGF0aWNzIGZyb20gJy4vbGliL2Jyb3dzZXInO1xyXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL2xpYi9oZWxwZXJzL2Fzc2lnbic7XHJcblxyXG5jb25zdCB7IEQgfSA9IHN0YXRpY3M7XHJcblxyXG5hc3NpZ24oRCwgc3RhdGljcyk7XHJcblxyXG5kZWxldGUgRC5EO1xyXG5cclxuZ2xvYmFsLkQgPSBEO1xyXG4iXSwibmFtZXMiOlsid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImFwcGxpZWRSZWdFeHBzIiwiZWxlbSIsImlkIiwiY2xzIiwiYWRkQ2xhc3MiLCJhdHRyIiwidmFsdWUiLCJwcm9wIiwiY3NzIiwibmFtZSIsImh0bWwiLCJ0ZXh0IiwicmVtb3ZlQ2xhc3MiLCJyZW1vdmVBdHRyIiwicmVtb3ZlQ1NTIiwiY2FudmFzR2V0TWV0aG9kcyIsImNhbnZhc1Jlc3RNZXRob2RzIiwiY29uc3RydWN0b3JzIiwiaHRtbEVsZW1lbnRzIiwic3ZnRWxlbWVudHMiLCJ2b2lkRWxlbWVudHMiLCJodG1sQWxsb3dlZFRhZ1N5bWJvbHMiLCJodG1sQWxsb3dlZEF0dHJTeW1ib2xzIiwicmVnZXhwU3BlY2lhbENoYXJhY3RlcnMiLCJ0b1N0cmluZ1RhZyIsIm9iamVjdCIsInRvU3RyaW5nIiwiY2FsbCIsInJlcGxhY2UiLCJpc0FycmF5IiwiaXNBcnJheUxpa2UiLCJpc0Z1bmN0aW9uIiwibGVuZ3RoIiwiaXNJbnRlZ2VyIiwiaXNCb29sZWFuIiwiaXNEYXRlIiwiaXNEYXRlTGlrZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJpc0VsZW1lbnQiLCJ0ZXN0IiwiaXNGaW5pdGUiLCJpc051bWJlciIsIk51bWJlciIsIkluZmluaXR5IiwiaXNJbnRlZ2VyTGlrZSIsInBhcnNlSW50IiwiaXNOdWxsIiwiaXNOaWwiLCJpc051bWJlckxpa2UiLCJpc09iamVjdCIsIk9iamVjdCIsImlzUGxhaW5PYmplY3QiLCJpc1ByaW1pdGl2ZSIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsImlzUmVnRXhwIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwidmFsaWRhdGVDaGVja0V4cHJlc3Npb25zIiwibiIsIlJhbmdlRXJyb3IiLCJ2IiwibWV0aG9kcyIsIlR5cGVFcnJvciIsImEiLCJkIiwiZiIsImkiLCJvIiwiciIsInMiLCJEIiwibGV2ZWxDb25zdHJ1Y3RvcnMiLCJrIiwibGVuIiwiY2hlY2siLCJpdGVyYXRlIiwiY2FsbGJhY2siLCJhcnJheSIsIml0ZXJhdGVkS2V5cyIsIml0ZXJhdGVkIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJhc3NpZ24iLCJ0YXJnZXQiLCJvYmplY3RzIiwiYXJndW1lbnRzIiwic291cmNlIiwiaW5kZXgiLCJkeW5hbWljRGVmaW5lUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eUdlbmVyYXRvciIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydGllcyIsIm1ldGhvZCIsInVuZGVmaW5lZCIsImdldCIsInNldCIsIlN5bWJvbCIsIk1hdGgiLCJyYW5kb20iLCJ0b0FycmF5IiwiY3JlYXRlTmV3QXJyYXkiLCJwdXNoIiwibnVtYmVycyIsInZhbGlkYXRlIiwiYXJncyIsIm9wdGlvbnMiLCJudW1iZXIiLCJjaGVja2VyIiwiZXJyb3IiLCJBbHBoYWJldCIsImFscGhhYmV0IiwiY2hhciIsIkVycm9yIiwiY2hhcnMiLCIkJCIsIndvcmQiLCJrZXlzIiwidG9rZW4iLCJmbG9vciIsInByb3RvdHlwZSIsInN0cmluZyIsInJhbmdlcyIsInNwbGl0IiwicmFuZ2UiLCJzdGFydCIsImNoYXJDb2RlQXQiLCJlbmQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJTd2l0Y2hlciIsImNhc2VzIiwibW9kZSIsImRlZmF1bHRWYWx1ZSIsImV2ZW50dWFsQ2FzZXMiLCJDYXNlIiwiY2FzZSIsInN3aXRjaGVyIiwiZGVmIiwiZGVmYXVsdCIsInJldCIsInZhbCIsImFwcGx5Iiwic2V0UHJvdG90eXBlT2YiLCJGdW5jdGlvbiIsIndoZW4iLCJjb25kaXRpb24iLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJjbG9uZVN3aXRjaGVyIiwiU3VwZXIiLCIkIiwiZGVlcENsb25lIiwiZGVlcCIsImNsb25lIiwiUmVnRXhwIiwibWF0Y2giLCJzdW0iLCJjb3VudCIsImZ1bmMiLCJkZXNjcmlwdG9ycyIsImNyZWF0ZSIsImRlZXBFcXVhbCIsIkJvb2xlYW4iLCJkZWVwRXZlcnkiLCJmaWx0ZXJlZCIsImRlZXBGaWx0ZXIiLCJkZWVwRmluZCIsImRlZXBNYXAiLCJJViIsInRyZWUiLCJkZWVwUmVkdWNlIiwiZGVlcFNvbWUiLCJwcm9wZXJ0eSIsImRlc2NyaXB0b3IiLCJwcm9wcyIsImZyZWV6ZSIsImdldHRlciIsImlzRnJvemVuIiwicmVwbGFjZXIiLCJzcGFjZSIsInVuc2hpZnQiLCJKU09OIiwic3RyaW5naWZ5IiwibWF4IiwibWluIiwib2JqIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImlzQ29udGV4dE9iamVjdCIsInN0YXJ0S2V5Iiwic2V0dGVyIiwicmVkdWNlIiwiZGVlcEFzc2lnbiIsIm8xIiwibzIiLCJzdHJpY3QiLCJsYXN0SW5kZXgiLCJwMSIsInAyIiwibmV3VHJlZSIsImNvbmNhdCIsIm51bCIsInJlc3VsdCIsImRlZXBGb3JFYWNoIiwiZGVlcEZvckVhY2hFbnRyeSIsImRlZXBGcmVlemUiLCJzZWNyZXQiLCJpdGVyYXRvciIsIlByb21pc2UiLCJleGVjdXRvciIsImhpZGRlblN0YXR1cyIsImhpZGRlblZhbHVlIiwib25GdWxmaWxsIiwib25SZWplY3QiLCJyZWFsUHJvbWlzZSIsImhpZGRlblByb21pc2UiLCJzdGF0dXMiLCJoYW5kbGVkIiwicmVzb2x2ZSIsInJlamVjdCIsInByb3h5IiwiZXJyIiwib25VbmhhbmRsZWRSZWplY3Rpb24iLCJvbkVycm9yIiwidGhlbiIsIm9uUmVqZWN0ZWQiLCJvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQiLCJpc0Z1bmMiLCJvbkZ1bGZpbGxlZCIsInByb21pc2UiLCJoYW5kbGUiLCJoYW5kbGVyIiwiaXRlcmFibGUiLCJ0b1Jlc29sdmUiLCJuZXh0IiwiZG9uZSIsImNvbnNvbGUiLCJiaW5kIiwiRnVuYyIsImNhbGxlZCIsImNhbkJlQ2FsbGVkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJzeW5jIiwiY29udGV4dExvY2tlZCIsImNvbnRleHQiLCJtaWRkbGV3YXJlIiwiYWZ0ZXJBbGwiLCJiZWZvcmVBbGwiLCJiaW5kQ29udGV4dCIsImJpbmRBcmdzIiwidGltZXMiLCJzbGljZSIsImxvY2tDb250ZXh0IiwibG9ja0FyZ3MiLCJhcmdzTG9ja2VkIiwibWFyayIsInRpbWUiLCJ0aW1lRW5kIiwidW5iaW5kQ29udGV4dCIsInVuYmluZEFyZ3MiLCJ4Iiwibm9vcCIsInRvUmFkaWFuIiwiUEkiLCJ0b0RlZ3JlZSIsImxuMiIsIkxOMiIsImxuMTAiLCJMTjEwIiwiTnVtIiwidG9EZWdyZWVzIiwiYWNvcyIsImFzaW4iLCJhdGFuIiwiYXNEZWdyZWVzIiwiY29zIiwiYWJvcnQiLCJhYm9ydGVkIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJpbnRlcnZhbCIsImNsZWFyVGltZW91dCIsImxvZyIsInBvd2VyIiwicG93Iiwic2luIiwidGFuIiwicmVqIiwiYmFzZSIsImZyYWN0aW9uRGlnaXRzIiwidG9FeHBvbmVudGlhbCIsImRpZ2l0cyIsInRvRml4ZWQiLCJwcmVjaXNpb24iLCJ0b1ByZWNpc2lvbiIsImFicyIsInNxcnQiLCJjYnJ0IiwiY2VpbCIsImV4cCIsImxuIiwicm91bmQiLCJzaWduIiwicmFuZCIsIkFyciIsInZhbHVlcyIsImtleU9mIiwia2V5T2ZTdHJpY3QiLCJzZXBhcmF0b3IiLCJqb2luIiwicG9wIiwicmV2ZXJzZSIsInNoaWZ0IiwiZm9yRWFjaCIsInJhbmRvbUluZGV4IiwiYmVnaW4iLCJjb21wYXJlRnVuY3Rpb24iLCJzb3J0IiwiYXNjIiwieSIsImRlbGV0ZUNvdW50IiwiaXRlbXMiLCJzcGxpY2UiLCJVUkwiLCJCbG9iT2JqZWN0IiwicHJvZ3Jlc3MiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwidG9SZWplY3QiLCJvbnByb2dyZXNzIiwiZSIsIm9uZXJyb3IiLCJvbmxvYWQiLCJhbmNob3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZGF0YVVSTCIsInNldEF0dHJpYnV0ZSIsImNsaWNrIiwiY3JlYXRlT2JqZWN0VVJMIiwiYmxvYiIsImJsb2JQYXJ0cyIsIkJsb2IiLCJodG1sU3BlY2lhbHMiLCJyZWdleHBTcGVjaWFsc1JlZ2V4cCIsIlN0ciIsInRvVXBwZXJDYXNlIiwic2VhcmNoU3RyaW5nIiwicG9zaXRpb24iLCJyZXZlcnQiLCJzdGFydHNXaXRoIiwiZXNjYXBlZCIsInN5bWJvbCIsInNlYXJjaFZhbHVlIiwiZnJvbUluZGV4IiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwicmVnZXhwIiwic3RyIiwic2VhcmNoIiwiYmVnaW5TbGljZSIsImVuZFNsaWNlIiwic3Vic3RyIiwiaW5kZXhTdGFydCIsImluZGV4RW5kIiwic3Vic3RyaW5nIiwidHJpbSIsInRvTG93ZXJDYXNlIiwicGFyc2VKU09OIiwianNvbiIsInBhcnNlIiwiZGF0ZXMiLCJwYXJzZWQiLCJzdWJtaXRTdHJpbmciLCJOT0RFX1JFR0VYX1NFVCIsImNvbnN0cnVjdENsb3NlVGFnUmVnRXhwIiwiVEFHX09QRU5fQ0xPU0UiLCJBVFRSSUJVVEUiLCJkaXYiLCJub2RlU3dpdGNoZXIiLCJub2RlIiwic2VsZkNsb3NpbmciLCJhdHRycyIsIm1hcCIsInBhcnNlQ2hhcmFjdGVyRGF0YSIsImNoaWxkcmVuIiwicGFyZW50IiwiY29sbGFwc2VXaGl0ZVNwYWNlIiwidHlwZSIsImVsZW1lbnQiLCJyYXdUZXh0U3dpdGNoZXIiLCJJbnRlcm5hbFBhcnNpbmdFcnJvciIsIlBhcnNpbmdFcnJvciIsIm1hcmt1cCIsImVsZW1lbnRzIiwic3RhcnRNYXJrdXAiLCJmb3VuZCIsImdsb2JhbEluZGV4IiwiZmluZCIsIm5lYXJTdHJpbmciLCJ0aHJvd1VuZXhwZWN0ZWRFcnJvciIsIm1hdGNoZXMiLCJyZWdleCIsInJldHVybmluZyIsImNsb3NlTWF0Y2giLCJOYU4iLCJ0YWdOYW1lIiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJuYXRpdmVEb2N1bWVudCIsImVtcHR5RGl2IiwiZXZlbnRTZXBhcmF0b3IiLCJ0ZXh0UHJvcGVydHkiLCJOb2RlIiwicHJvcGVydHlEZXNjcmlwdG9yIiwiY2xhc3NlcyIsIndpbmRvd3NEd2F5bmVEYXRhIiwiaW5wdXRFbGVtZW50cyIsInN2Z05TIiwieG1sTlMiLCJ4bGlua05TIiwieGh0bWxOUyIsInR5cGVTd2l0Y2hlciIsIm5zIiwiZG9jdW1lbnRFbGVtZW50IiwibmFtZXNwYWNlVVJJIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlQ29tbWVudCIsImNyZWF0ZVRleHROb2RlIiwicmVmU3dpdGNoZXIiLCJmaWx0ZXJTd2l0Y2hlciIsInNlbGVjdG9yIiwiRWxlbSIsImlzIiwiaXNFbGVtIiwiZWxlbXMiLCJpbm5lclN3aXRjaGVyIiwicGFkZGluZ3MiLCJib3JkZXJzIiwib3V0ZXJTd2l0Y2hlciIsImF0dHJOU1N3aXRjaGVyIiwiY2xvc2VzdCIsImlzV2luZG93IiwiaXNIVE1MRG9jdW1lbnQiLCJpc0RvY3VtZW50RnJhZ21lbnQiLCJpc0NvbW1lbnRPclRleHQiLCJpc1N0eWxlUnVsZSIsImFkZER3YXluZURhdGEiLCJsaXN0IiwiY2xhc3NMaXN0IiwiYWRkIiwiaW5zZXJ0QWRqYWNlbnRIVE1MIiwic3R5bGUiLCJzb21lIiwiZ2V0TmFtZSIsInNoZWV0IiwiY3NzUnVsZXMiLCJydWxlcyIsInRvSHlwaGVuQ2FzZSIsImluc2VydFJ1bGUiLCJkd2F5bmVEYXRhIiwiaW50byIsInN0cmluZ3MiLCJhcHBsaWVkIiwic2V0QXBwbGllZCIsIm5wMSIsImdldEVsZW0iLCJhdHRyaWJ1dGVzIiwiZ2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsImZpcnN0IiwibG9hZCIsImlzQnJva2VuIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3SW1hZ2UiLCJieXRlU3RyaW5nIiwiYXRvYiIsImFiIiwiQXJyYXlCdWZmZXIiLCJpYSIsIlVpbnQ4QXJyYXkiLCJibHVyIiwicHNldWRvIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInJ1bGUiLCJ0b0ZpbmQiLCJjaGlsZE5vZGVzIiwiY2xhc3NOYW1lIiwiY2xvbmVOb2RlIiwicGFyZW50Tm9kZSIsImNvbnRhaW5zIiwiYXBwbGllZEV4cHJlc3Npb25zIiwiY3NzVGV4dCIsInRvQ2FtZWxDYXNlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiY3R4IiwiZGF0YXNldCIsImVuY29kZXJPcHRpb25zIiwidG9EYXRhVVJMIiwiZGVsZXRlUnVsZSIsImV2ZW50IiwiZXZlbnRJbml0IiwiZGV0YWlscyIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZmluYWxFdmVudCIsIkV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZm9jdXMiLCJzZWxlY3RvclRleHQiLCJoYXNBdHRyaWJ1dGUiLCJoYXNBdHRyaWJ1dGVOUyIsImN1cnJlbnREaXNwbGF5IiwicHJldmlvdXNEaXNwbGF5IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJmaXJzdENoaWxkIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwiY29tcGxldGUiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiaW1hZ2VzIiwiYWxsIiwiZmlsdGVyIiwiJGVsZW0iLCJyZW1vdmVMaXN0ZW5lcnMiLCJvbiIsInByb3BlciIsImJyb2tlbiIsInByZXYiLCJuZXh0U2libGluZyIsImV2ZW50cyIsImxpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJhbGxMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsImRlZmluZSIsImhhcyIsIm5ld0xpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRlbGV0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmV2aW91c1NpYmxpbmciLCJsaW5rIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInJlbW92ZSIsImNyZWF0ZWQiLCJ0eHQiLCJoYXNBdHRyIiwiaGFzQ2xhc3MiLCJsZXZlbCIsInZhbGlkYXRvciIsInZhbGlkYXRvcnMiLCJlcnJvcnMiLCJmb3JtRXJyb3JzIiwiZm9ybSIsImlucHV0cyIsImlucHV0IiwiZGlzcGF0Y2giLCJpbnB1dEVycm9yIiwidmFsaWRhdG9yV3JhcCIsInZhbGlkaXR5IiwidmFsaWQiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsImV2ZXJ5IiwiaW5uZXJIZWlnaHQiLCJjYWxjQ1NTIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJveFNpemluZyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwicHgiLCJpbm5lcldpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0Iiwib3V0ZXJIZWlnaHQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJvdXRlcldpZHRoIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0Iiwid2luIiwiZG9jIiwiYm9keSIsImhlYWQiLCJ0YWciLCJub2RlTmFtZSIsImdldENvbnRleHQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyc2VIVE1MIiwibWFya3VwVG9KU09OIiwidGVtcGxhdGUiLCJjb250ZW50IiwiZm9yRWFjaE5vZGUiLCJzaXplIiwicmVnaXN0ZXJEQmxvY2siLCJCbG9jayIsIkRCbG9jayIsInJlZ2lzdGVyREVhY2giLCJjcmVhdGVCbG9jayIsIkRFYWNoIiwib3B0cyIsIml0ZW0iLCJpdGVtTmFtZSIsImluZGV4TmFtZSIsInVpZCIsImNvbnN0cnVjdFZhbHVlcyIsIndhdGNoQXJncyIsInBhcmVudEVsZW0iLCJ1aWRzIiwic2NvcGUiLCJVSUQiLCIkdWlkcyIsIm5ld0tleXMiLCJuZXdVSURzIiwiZXZhbHVhdGUiLCJJdGVtIiwiYmxvY2siLCJpbnNlcnRBZnRlciIsInJlZ2lzdGVyREVsZW1lbnRzIiwiREVsZW1lbnRzIiwibWl4aW5zIiwid2F0Y2hlcnNUb1JlbW92ZSIsImNoaWxkIiwibWl4aW4iLCJ3YXRjaGVycyIsIndhdGNoZXIiLCJmb3JERWxlbWVudHMiLCJuZXdDb250ZW50IiwicmVnaXN0ZXJESWYiLCJESWYiLCJjb25kIiwiZXZhbHVhdGVBbmRXYXRjaCIsImlmIiwibmV3VmFsdWUiLCJyZWdpc3RlckRJdGVtIiwiREl0ZW0iLCJyZWdpc3RlckRTd2l0Y2giLCJEU3dpdGNoIiwid2FzRGVmYXVsdCIsImVxdWFscyIsInJlZ2lzdGVyRFRleHQiLCJEVGV4dCIsInJlZ2lzdGVyREF0dHIiLCJNaXhpbiIsIkRBdHRyIiwib2xkVmFsdWUiLCJyZWdpc3RlckRCaW5kIiwiREJpbmQiLCJvZmYiLCJyZWdpc3RlckRDbGFzcyIsIkRDbGFzcyIsIm5ld0NsYXNzZXMiLCJyZWdpc3RlckRFbGVtIiwiREVsZW0iLCJldmFsdWF0ZU9uY2UiLCJyZWdpc3RlckRIaWRlIiwiREhpZGUiLCJoaWRlIiwic2hvdyIsInJlZ2lzdGVyRE9uIiwiRE9uIiwicmVnaXN0ZXJEU2hvdyIsIkRTaG93IiwicmVnaXN0ZXJEU3R5bGUiLCJEU3R5bGUiLCJsaXN0ZW5lclN3aXRjaGVyIiwicmVnaXN0ZXJEVmFsaWRhdGUiLCJEVmFsaWRhdGUiLCJwcm9wU3dpdGNoZXIiLCJzZXRWYWx1ZVN3aXRjaGVyIiwiaW5wdXRWYWx1ZSIsImdldFZhbHVlU3dpdGNoZXIiLCJzZWxlY3RlZCIsImluaXQiLCJyZWdpc3RlckRWYWx1ZSIsIkRWYWx1ZSIsIl92YWx1ZSIsImluaXRpYWxTY29wZVZhbHVlIiwiY3VycmVudFZhbHVlIiwic2V0UHJvcCIsImluaXRpYWxFbGVtVmFsdWUiLCJnZXRQcm9wIiwiaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwiLCJpc0NoZWNrYm94IiwiY2hhbmdlU2NvcGUiLCJvcHRpb24iLCJyb290QmxvY2tzIiwicm9vdE1peGlucyIsImlzUHJvdG90eXBlT2YiLCJhdHRyTmFtZSIsImV4cHJlc3Npb25SZWdFeHAiLCJvbkV2YWxFcnJvciIsImV4cHJlc3Npb24iLCJldmFsTW9kZSIsImdldHRpbmciLCJjaGFuZ2VkIiwiX2Jsb2NrcyIsIl9taXhpbnMiLCJTdWJjbGFzcyIsIl90aGlzIiwiaGFzT3duIiwiaXNJbnN0YW5jZU9mQmxvY2siLCJpc0luc3RhbmNlT2ZNaXhpbiIsIndhcm4iLCJfaHRtbCIsImRlZXBDbG9uZUNoaWxkcmVuIiwiX21hdGNoIiwiZXNjYXBlUmVnRXhwIiwib3JpZ2luYWxBcmdzIiwicGFyZW50QmxvY2siLCJwYXJlbnRTY29wZSIsIm9uQ2hhbmdlIiwiaW5zdGFuY2UiLCJmb3JESXRlbSIsImZvckRFYWNoIiwic3RvcmUiLCJleHByIiwiRHdheW5lU3RvcmUiLCJsb2NhbFdhdGNoZXJzIiwibmV3UmVzdWx0Iiwid2F0Y2hlckJsb2NrIiwib25SZW1vdmUiLCJpbmRleDEiLCJpbmRleDIiLCJhcmciLCJEd2F5bmVCbG9jayIsImlzUGFyZW50U2lnbmFsIiwiYmVmb3JlUmVtb3ZlIiwicGVybSIsImxvY2FscyIsInZhcmlhYmxlIiwibG9jYWwiLCJyZWdpc3RlckJ1aWx0SW5zIiwiQmxvY2tzIiwiYmxvY2tzIiwiTWl4aW5zIiwiaW5pdEFwcCIsInJlZ2lzdGVyIiwic3ZnIiwibG9jYWxCbG9ja3MiLCJsb2NhbE1peGlucyIsImRCbG9ja01hdGNoIiwiY3VycmVudE1peGlucyIsImxvY2FsTWF0Y2giLCJibG9ja0luc3RhbmNlIiwiQXJncyIsImNvbnN0cnVjdFByaXZhdGVTY29wZSIsInNjb3BlVmFsdWVzIiwiREl0ZW1Gb3VuZCIsInByaXZhdGVTY29wZSIsImFmdGVyQ29uc3RydWN0IiwiYWZ0ZXJSZW5kZXIiLCJjcmVhdGVNaXhpbiIsImFmdGVyVXBkYXRlIiwibmV3Q2hpbGQiLCJ0cmFuc2Zvcm1ESWZDaGlsZHJlbiIsImlmRWxzZSIsInJlbW92ZVdhdGNoZXJzIiwiY29uc3RydWN0UHVibGljU2NvcGUiLCJ0ZW1wIiwib2xkVGVtcFdhdGNoZXJzIiwid2FzIiwiemVybyIsImRheXNPZlRoZVdlZWtOYW1lcyIsImRheXNPZlRoZVdlZWtBbGlhc2VzIiwibW9udGhzTmFtZXMiLCJtb250aHNBbGlhc2VzIiwiZGF0ZSIsInV0YyIsInplcm9lcyIsInJlcGVhdCIsImNvZWZmcyIsImdldFN3aXRjaGVyIiwic2V0U3dpdGNoZXIiLCJEYXQiLCJ3aGF0Iiwibm93IiwicHJlZml4IiwiZm9ybWF0cyIsImZvcm1hdCIsInJlcGxhY2VTdHJpbmciLCJkYXRlMSIsImRhdGUyIiwiaXNCZWZvcmUiLCJzdGFydGVkIiwiY29lZmYiLCJ3Iiwic2V0VGltZSIsInRvSVNPU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJ2YWx1ZU9mIiwiYWJzb2x1dGVVUkxSZWdleHAiLCJxdWVyeVN3aXRjaGVyIiwicXVlcnkiLCJxdWVyeVBhcmFtcyIsInBhcmFtIiwiYmFzZVVSTCIsInVybCIsInBhcmFtcyIsImhhc2giLCJlbmNvZGVPcHRpb25zIiwiZW5jb2RlUGFyYW1zIiwiZW5jb2RlUXVlcnkiLCJpc0Fic29sdXRlIiwiZW5jb2RlIiwiaXNFbmNvZGVkIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmF3SGVhZGVycyIsImhlYWRlcnMiLCJub3RUb1RyYW5zZm9ybSIsIndpdGhvdXRCb2R5IiwiZGF0YSIsImluZGV4T2ZTdHJpY3QiLCJjb250ZW50VHlwZSIsImRlZmF1bHRzIiwibG9jYXRpb24iLCJvcmlnaW4iLCJ1cGxvYWRNZXRob2RzIiwiRmV0Y2giLCJjb25maWciLCJmZXRjaCIsInJlcXVlc3QiLCJjb25mIiwiZmV0Y2hCZWZvcmVNaWRkbGV3YXJlIiwiaGVhZGVyIiwidG9QdXNoIiwiZGF0YUNvbmZpZyIsInVybENvbmZpZyIsInhociIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicmVzcG9uc2VUeXBlIiwid2l0aENyZWRlbnRpYWxzIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsInVwbG9hZCIsIm9uYWJvcnQiLCJvbnRpbWVvdXQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJwYXJzZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzdGF0dXNUZXh0IiwiY2F0Y2giLCJzZW5kIiwiTUVUSE9EIiwiY29uc3RydWN0VVJMIiwidHJhbnNmb3JtRGF0YSIsInRvQ2FwaXRhbENhc2UiLCJkZWNvZGVRdWVyeSIsInJhd1BhcmFtIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyYW1OYW1lIiwicGFyYW1PYmplY3QiLCJSb3V0ZXMiLCJjdXJyZW50Um91dGVzIiwic3Vic2NyaWJlcnMiLCJoaXN0b3J5IiwiaW5pdGlhbGl6ZWQiLCJwdXNoZWQiLCJ3YXNSb290Iiwicm9vdFJvdXRlIiwicmVkaXJlY3RSb3V0ZSIsIlJlZGlyZWN0Um91dGUiLCJkZWZhdWx0Um91dGUiLCJEZWZhdWx0Um91dGUiLCJjdXJyZW50Um91dGUiLCJjdXJyZW50Um91dGVQYXJhbXMiLCJwYXRoU3dpdGNoZXIiLCJwYXRoIiwibmV3VVJMIiwibmV3UGF0aCIsInBhcnQiLCJyZXNvbHZlUGFyYW1ldGVyIiwiUm91dGUiLCJhYnN0cmFjdCIsImRlY29kZVBhcmFtcyIsInJlbGF0aXZlVVJMIiwicmVsYXRpdmVQYXRoIiwiYmFzZVJvdXRlIiwiaW5pdFJvdXRlciIsInJvdXRlIiwicGFyZW50TmFtZSIsIlBhcmVudE5hbWUiLCJwYXJlbnRQYXJhbXMiLCJwYXJlbnRRdWVyeSIsInZhbGlkYXRlUGF0aCIsImNsb3Nlc3RMaW5rIiwicHJldmVudERlZmF1bHQiLCJtYWtlUm91dGUiLCJyb3V0ZXJPcHRpb25zIiwicm9vdCIsImZhbGxiYWNrVG8iLCJpc0RlZmF1bHQiLCJOYW1lIiwidW5zdWJzY3JpYmUiLCJyb3V0ZUxvYWRlZCIsInJvdXRlciIsImJ1aWxkVVJMIiwiX19yb3V0ZXJJbnN0YW5jZV9fIiwiX19pc0N1cnJlbnRSb3V0ZV9fIiwic3Vic2NyaWJlIiwiaXNDdXJyZW50Um91dGUiLCJjYWxsQmVmb3JlTG9hZCIsImJlZm9yZUxvYWQiLCJiZWZvcmVMb2FkUm91dGUiLCJjYWxsQmVmb3JlTGVhdmUiLCJiZWZvcmVMZWF2ZSIsImJlZm9yZUxlYXZlUm91dGUiLCJmb3J3YXJkIiwiY2hhbmdlUm91dGUiLCJmaW5kUm91dGVCeVVSTCIsImhvc3QiLCJob3N0bmFtZSIsInBhdGhuYW1lIiwicG9ydCIsInByb3RvY29sIiwidXJsUGFyYW1zIiwicm91dGVVUkwiLCJyZXF1aXJlZFF1ZXJ5IiwicmVzb2x2ZWQiLCJyZXNvbHZlVVJMIiwiZXZlbnR1YWxQYXJhbXMiLCJkZWNvZGUiLCJjaGFuZ2VIaXN0b3J5IiwibmFtZUVycm9yTmFtZSIsInZhbHVlRXJyb3JOYW1lIiwibmFtZU1hdGNoIiwic3RhdGljcyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBRUEsZUFBZSxPQUFPQSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxFQUF0STs7QUNGQTs7Ozs7Ozs7Ozs7Ozs7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MUIsTUEvQjBCOzs7Ozs7OztBQXVDMUIsU0F2QzBCOzs7Ozs7OztBQStDMUIsT0EvQzBCOzs7Ozs7OztBQXVEMUIsR0F2RDBCOzs7Ozs7OztBQStEMUIsTUEvRDBCOzs7Ozs7OztBQXVFMUIsS0F2RTBCOzs7Ozs7OztBQStFMUIsS0EvRTBCOzs7Ozs7OztBQXVGMUIsWUF2RjBCOzs7Ozs7OztBQStGMUIsTUEvRjBCOzs7Ozs7OztBQXVHMUIsSUF2RzBCOzs7Ozs7OztBQStHMUIsUUEvRzBCOzs7Ozs7OztBQXVIMUIsUUF2SDBCOzs7Ozs7OztBQStIMUIsU0EvSDBCOzs7Ozs7OztBQXVJMUIsTUF2STBCOzs7Ozs7OztBQStJMUIsTUEvSTBCOzs7Ozs7OztBQXVKMUIsS0F2SjBCOzs7Ozs7OztBQStKMUIsVUEvSjBCOzs7Ozs7OztBQXVLMUIsU0F2SzBCOzs7Ozs7OztBQStLMUIsVUEvSzBCOzs7Ozs7OztBQXVMMUIsSUF2TDBCOzs7Ozs7OztBQStMMUIsS0EvTDBCOzs7Ozs7OztBQXVNMUIsU0F2TTBCOzs7Ozs7OztBQStNMUIsS0EvTTBCOzs7Ozs7OztBQXVOMUIsUUF2TjBCOzs7Ozs7OztBQStOMUIsS0EvTjBCOzs7Ozs7OztBQXVPMUIsSUF2TzBCOzs7Ozs7OztBQStPMUIsSUEvTzBCOzs7Ozs7OztBQXVQMUIsU0F2UDBCOzs7Ozs7OztBQStQMUIsSUEvUDBCOzs7Ozs7OztBQXVRMUIsT0F2UTBCOzs7Ozs7OztBQStRMUIsVUEvUTBCOzs7Ozs7OztBQXVSMUIsWUF2UjBCOzs7Ozs7OztBQStSMUIsUUEvUjBCOzs7Ozs7OztBQXVTMUIsUUF2UzBCOzs7Ozs7OztBQStTMUIsTUEvUzBCOzs7Ozs7OztBQXVUMUIsSUF2VDBCOzs7Ozs7OztBQStUMUIsSUEvVDBCOzs7Ozs7OztBQXVVMUIsSUF2VTBCOzs7Ozs7OztBQStVMUIsSUEvVTBCOzs7Ozs7OztBQXVWMUIsSUF2VjBCOzs7Ozs7OztBQStWMUIsSUEvVjBCOzs7Ozs7OztBQXVXMUIsTUF2VzBCOzs7Ozs7OztBQStXMUIsUUEvVzBCOzs7Ozs7OztB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