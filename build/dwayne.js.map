{"version":3,"names":[],"mappings":"","sources":["dwayne.js"],"sourcesContent":["(function () {\n'use strict';\n\n/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nvar global$1 = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n/**\r\n * @module constants/appliedRegExps\r\n * @private\r\n * @description Exports different types of syntax for {@link Elem#apply}.\r\n */\n\n/**\r\n * @callback matchAppliedExprCallback\r\n * @param {Elem} elem - D-elem of an element to apply expression to.\r\n * @param {String} string - Matched applied name.\r\n * @param {String} arg - Argument within the parentheses.\r\n */\n\n/**\r\n * @type {Object.<String, matchAppliedExprCallback|Object.<String, matchAppliedExprCallback>>}\r\n * @description Object of different types of syntax.\r\n */\n\nvar appliedRegExps = {\n  '#': function _(elem, id) {\n    elem.id(id);\n  },\n  '.': function _(elem, cls) {\n    elem.addClass(cls);\n  },\n  $: function $(elem, attr, value) {\n    elem.attr(attr, value);\n  },\n  '@': function _(elem, prop, value) {\n    elem.css(prop, value);\n  },\n  '&': function _(elem, name, html) {\n    elem.html(html);\n  },\n  '*': function _(elem, name, text) {\n    elem.text(text);\n  },\n\n  '-': {\n    '.': function _(elem, cls) {\n      elem.removeClass(cls);\n    },\n    $: function $(elem, attr) {\n      elem.removeAttr(attr);\n    },\n    '@': function _(elem, prop) {\n      elem.removeCSS(prop);\n    }\n  }\n};\n\n/**\r\n * @module constants/elements\r\n * @private\r\n * @description Exports different canvas methods for {@link Elem} for creating html-elements.\r\n */\n\n/**\r\n * @const\r\n * @type {String[]}\r\n */\nvar canvasGetMethods = [\n/**\r\n * @member {Function} Elem#createImageData\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {ImageData|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createImageData\r\n */\n'createImageData',\n\n/**\r\n * @member {Function} Elem#createLinearGradient\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {CanvasGradient|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createLinearGradient\r\n */\n'createLinearGradient',\n\n/**\r\n * @member {Function} Elem#createPattern\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {CanvasPattern|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createPattern\r\n */\n'createPattern',\n\n/**\r\n * @member {Function} Elem#createRadialGradient\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {CanvasGradient|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createRadialGradient\r\n */\n'createRadialGradient',\n\n/**\r\n * @member {Function} Elem#getImageData\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {ImageData|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getImageData\r\n */\n'getImageData',\n\n/**\r\n * @member {Function} Elem#getLineDash\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Number[]|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getLineDash\r\n */\n'getLineDash',\n\n/**\r\n * @member {Function} Elem#isPointInPath\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Boolean|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInPath\r\n */\n'isPointInPath',\n\n/**\r\n * @member {Function} Elem#isPointInStroke\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Boolean|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInStroke\r\n */\n'isPointInStroke',\n\n/**\r\n * @member {Function} Elem#measureText\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {TextMetrics|void}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/measureText\r\n */\n'measureText'];\n\nvar canvasRestMethods = [\n/**\r\n * @member {Function} Elem#arc\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arc\r\n */\n'arc',\n\n/**\r\n * @member {Function} Elem#arcTo\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arcTo\r\n */\n'arcTo',\n\n/**\r\n * @member {Function} Elem#beginPath\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/beginPath\r\n */\n'beginPath',\n\n/**\r\n * @member {Function} Elem#bezierCurveTo\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo\r\n */\n'bezierCurveTo',\n\n/**\r\n * @member {Function} Elem#clearRect\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clearRect\r\n */\n'clearRect',\n\n/**\r\n * @member {Function} Elem#clip\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clip\r\n */\n'clip',\n\n/**\r\n * @member {Function} Elem#closePath\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/closePath\r\n */\n'closePath',\n\n/**\r\n * @member {Function} Elem#drawFocusIfNeeded\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawFocusIfNeeded\r\n */\n'drawFocusIfNeeded',\n\n/**\r\n * @member {Function} Elem#drawImage\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawImage\r\n */\n'drawImage',\n\n/**\r\n * @member {Function} Elem#ellipse\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/ellipse\r\n */\n'ellipse',\n\n/**\r\n * @member {Function} Elem#fill\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fill\r\n */\n'fill',\n\n/**\r\n * @member {Function} Elem#fillRect\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillRect\r\n */\n'fillRect',\n\n/**\r\n * @member {Function} Elem#fillText\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillText\r\n */\n'fillText',\n\n/**\r\n * @member {Function} Elem#lineTo\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineTo\r\n */\n'lineTo',\n\n/**\r\n * @member {Function} Elem#moveTo\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/moveTo\r\n */\n'moveTo',\n\n/**\r\n * @member {Function} Elem#putImageData\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/putImageData\r\n */\n'putImageData',\n\n/**\r\n * @member {Function} Elem#quadraticCurveTo\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/quadraticCurveTo\r\n */\n'quadraticCurveTo',\n\n/**\r\n * @member {Function} Elem#rect\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rect\r\n */\n'rect',\n\n/**\r\n * @member {Function} Elem#resetTransform\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/resetTransform\r\n */\n'resetTransform',\n\n/**\r\n * @member {Function} Elem#restore\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/restore\r\n */\n'restore',\n\n/**\r\n * @member {Function} Elem#rotate\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rotate\r\n */\n'rotate',\n\n/**\r\n * @member {Function} Elem#save\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/save\r\n */\n'save',\n\n/**\r\n * @member {Function} Elem#scale\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/scale\r\n */\n'scale',\n\n/**\r\n * @member {Function} Elem#setLineDash\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setLineDash\r\n */\n'setLineDash',\n\n/**\r\n * @member {Function} Elem#setTransform\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setTransform\r\n */\n'setTransform',\n\n/**\r\n * @member {Function} Elem#stroke\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/stroke\r\n */\n'stroke',\n\n/**\r\n * @member {Function} Elem#strokeRect\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeRect\r\n */\n'strokeRect',\n\n/**\r\n * @member {Function} Elem#strokeText\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeText\r\n */\n'strokeText',\n\n/**\r\n * @member {Function} Elem#transform\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/transform\r\n */\n'transform',\n\n/**\r\n * @member {Function} Elem#translate\r\n * @type {Function}\r\n * @param {...*} args\r\n * @returns {Elem}\r\n * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/translate\r\n */\n'translate'];\n\n/**\r\n * @module constants/constructors\r\n * @private\r\n * @description Exports constructors levels.\r\n */\n\n/**\r\n * @const\r\n * @type {Array[]}\r\n */\nvar constructors = [[], [], []];\n\n/**\r\n * @module constants/elements\r\n * @private\r\n * @description Exports methods for {@link Elem} for creating html-elements.\r\n */\n\n/**\r\n * @const\r\n * @type {String[]}\r\n */\nvar htmlElements = [\n/**\r\n * @member {Function} Elem#a\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'a',\n\n/**\r\n * @member {Function} Elem#abbr\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'abbr',\n\n/**\r\n * @member {Function} Elem#address\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'address',\n\n/**\r\n * @member {Function} Elem#area\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'area',\n\n/**\r\n * @member {Function} Elem#article\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'article',\n\n/**\r\n * @member {Function} Elem#audio\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'audio',\n\n/**\r\n * @member {Function} Elem#b\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'b',\n\n/**\r\n * @member {Function} Elem#base\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'base',\n\n/**\r\n * @member {Function} Elem#bdi\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'bdi',\n\n/**\r\n * @member {Function} Elem#bdo\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'bdo',\n\n/**\r\n * @member {Function} Elem#blockquote\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'blockquote',\n\n/**\r\n * @member {Function} Elem#body\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'body',\n\n/**\r\n * @member {Function} Elem#br\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'br',\n\n/**\r\n * @member {Function} Elem#button\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'button',\n\n/**\r\n * @member {Function} Elem#canvas\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'canvas',\n\n/**\r\n * @member {Function} Elem#caption\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'caption',\n\n/**\r\n * @member {Function} Elem#cite\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'cite',\n\n/**\r\n * @member {Function} Elem#code\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'code',\n\n/**\r\n * @member {Function} Elem#col\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'col',\n\n/**\r\n * @member {Function} Elem#colgroup\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'colgroup',\n\n/**\r\n * @member {Function} Elem#content\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'content',\n\n/**\r\n * @member {Function} Elem#datalist\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'datalist',\n\n/**\r\n * @member {Function} Elem#dd\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'dd',\n\n/**\r\n * @member {Function} Elem#del\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'del',\n\n/**\r\n * @member {Function} Elem#details\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'details',\n\n/**\r\n * @member {Function} Elem#dfn\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'dfn',\n\n/**\r\n * @member {Function} Elem#dialog\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'dialog',\n\n/**\r\n * @member {Function} Elem#div\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'div',\n\n/**\r\n * @member {Function} Elem#dl\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'dl',\n\n/**\r\n * @member {Function} Elem#dt\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'dt',\n\n/**\r\n * @member {Function} Elem#element\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'element',\n\n/**\r\n * @member {Function} Elem#em\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'em',\n\n/**\r\n * @member {Function} Elem#embed\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'embed',\n\n/**\r\n * @member {Function} Elem#fieldset\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'fieldset',\n\n/**\r\n * @member {Function} Elem#figcaption\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'figcaption',\n\n/**\r\n * @member {Function} Elem#figure\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'figure',\n\n/**\r\n * @member {Function} Elem#footer\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'footer',\n\n/**\r\n * @member {Function} Elem#form\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'form',\n\n/**\r\n * @member {Function} Elem#h1\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'h1',\n\n/**\r\n * @member {Function} Elem#h2\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'h2',\n\n/**\r\n * @member {Function} Elem#h3\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'h3',\n\n/**\r\n * @member {Function} Elem#h4\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'h4',\n\n/**\r\n * @member {Function} Elem#h5\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'h5',\n\n/**\r\n * @member {Function} Elem#h6\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'h6',\n\n/**\r\n * @member {Function} Elem#head\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'head',\n\n/**\r\n * @member {Function} Elem#header\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'header',\n\n/**\r\n * @member {Function} Elem#hgroup\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'hgroup',\n\n/**\r\n * @member {Function} Elem#hr\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'hr',\n\n/**\r\n * @member {Function} Elem#i\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'i',\n\n/**\r\n * @member {Function} Elem#iframe\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'iframe',\n\n/**\r\n * @member {Function} Elem#img\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'img',\n\n/**\r\n * @member {Function} Elem#input\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'input',\n\n/**\r\n * @member {Function} Elem#ins\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'ins',\n\n/**\r\n * @member {Function} Elem#kbd\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'kbd',\n\n/**\r\n * @member {Function} Elem#label\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'label',\n\n/**\r\n * @member {Function} Elem#legend\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'legend',\n\n/**\r\n * @member {Function} Elem#li\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'li',\n\n/**\r\n * @member {Function} Elem#link\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'link',\n\n/**\r\n * @member {Function} Elem#main\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'main',\n\n/**\r\n * @member {Function} Elem#mark\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'mark',\n\n/**\r\n * @member {Function} Elem#menu\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'menu',\n\n/**\r\n * @member {Function} Elem#menuitem\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'menuitem',\n\n/**\r\n * @member {Function} Elem#meta\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'meta',\n\n/**\r\n * @member {Function} Elem#meter\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'meter',\n\n/**\r\n * @member {Function} Elem#nav\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'nav',\n\n/**\r\n * @member {Function} Elem#noscript\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'noscript',\n\n/**\r\n * @member {Function} Elem#ol\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'ol',\n\n/**\r\n * @member {Function} Elem#optgroup\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'optgroup',\n\n/**\r\n * @member {Function} Elem#option\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'option',\n\n/**\r\n * @member {Function} Elem#output\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'output',\n\n/**\r\n * @member {Function} Elem#p\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'p',\n\n/**\r\n * @member {Function} Elem#param\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'param',\n\n/**\r\n * @member {Function} Elem#pre\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'pre',\n\n/**\r\n * @member {Function} Elem#progress\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'progress',\n\n/**\r\n * @member {Function} Elem#q\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'q',\n\n/**\r\n * @member {Function} Elem#rp\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'rp',\n\n/**\r\n * @member {Function} Elem#rt\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'rt',\n\n/**\r\n * @member {Function} Elem#rtc\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'rtc',\n\n/**\r\n * @member {Function} Elem#ruby\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'ruby',\n\n/**\r\n * @member {Function} Elem#s\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n's',\n\n/**\r\n * @member {Function} Elem#samp\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'samp',\n\n/**\r\n * @member {Function} Elem#script\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'script',\n\n/**\r\n * @member {Function} Elem#section\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'section',\n\n/**\r\n * @member {Function} Elem#select\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'select',\n\n/**\r\n * @member {Function} Elem#shadow\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'shadow',\n\n/**\r\n * @member {Function} Elem#small\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'small',\n\n/**\r\n * @member {Function} Elem#source\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'source',\n\n/**\r\n * @member {Function} Elem#span\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'span',\n\n/**\r\n * @member {Function} Elem#strong\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'strong',\n\n/**\r\n * @member {Function} Elem#style\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'style',\n\n/**\r\n * @member {Function} Elem#sub\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'sub',\n\n/**\r\n * @member {Function} Elem#summary\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'summary',\n\n/**\r\n * @member {Function} Elem#sup\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'sup',\n\n/**\r\n * @member {Function} Elem#table\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'table',\n\n/**\r\n * @member {Function} Elem#tbody\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'tbody',\n\n/**\r\n * @member {Function} Elem#td\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'td',\n\n/**\r\n * @member {Function} Elem#template\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'template',\n\n/**\r\n * @member {Function} Elem#textarea\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'textarea',\n\n/**\r\n * @member {Function} Elem#tfoot\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'tfoot',\n\n/**\r\n * @member {Function} Elem#th\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'th',\n\n/**\r\n * @member {Function} Elem#thead\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'thead',\n\n/**\r\n * @member {Function} Elem#time\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'time',\n\n/**\r\n * @member {Function} Elem#title\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'title',\n\n/**\r\n * @member {Function} Elem#tr\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'tr',\n\n/**\r\n * @member {Function} Elem#track\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'track',\n\n/**\r\n * @member {Function} Elem#u\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'u',\n\n/**\r\n * @member {Function} Elem#ul\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'ul',\n\n/**\r\n * @member {Function} Elem#var\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'var',\n\n/**\r\n * @member {Function} Elem#video\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'video',\n\n/**\r\n * @member {Function} Elem#wbr\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'wbr'];\n\nvar svgElements = [\n/**\r\n * @member {Function} Elem#altGlyph\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'altGlyph',\n\n/**\r\n * @member {Function} Elem#altGlyphDef\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'altGlyphDef',\n\n/**\r\n * @member {Function} Elem#altGlyphItem\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'altGlyphItem',\n\n/**\r\n * @member {Function} Elem#animate\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'animate',\n\n/**\r\n * @member {Function} Elem#animateColor\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'animateColor',\n\n/**\r\n * @member {Function} Elem#animateMotion\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'animateMotion',\n\n/**\r\n * @member {Function} Elem#animateTransform\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'animateTransform',\n\n/**\r\n * @member {Function} Elem#circle\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'circle',\n\n/**\r\n * @member {Function} Elem#clipPath\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'clipPath',\n\n/**\r\n * @member {Function} Elem#colorProfile\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'color-profile',\n\n/**\r\n * @member {Function} Elem#cursor\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'cursor',\n\n/**\r\n * @member {Function} Elem#defs\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'defs',\n\n/**\r\n * @member {Function} Elem#desc\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'desc',\n\n/**\r\n * @member {Function} Elem#discard\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'discard',\n\n/**\r\n * @member {Function} Elem#ellipse\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'ellipse',\n\n/**\r\n * @member {Function} Elem#feBlend\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feBlend',\n\n/**\r\n * @member {Function} Elem#feColorMatrix\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feColorMatrix',\n\n/**\r\n * @member {Function} Elem#feComponentTransfer\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feComponentTransfer',\n\n/**\r\n * @member {Function} Elem#feComposite\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feComposite',\n\n/**\r\n * @member {Function} Elem#feConvolveMatrix\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feConvolveMatrix',\n\n/**\r\n * @member {Function} Elem#feDiffuseLighting\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feDiffuseLighting',\n\n/**\r\n * @member {Function} Elem#feDisplacementMap\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feDisplacementMap',\n\n/**\r\n * @member {Function} Elem#feDistantLight\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feDistantLight',\n\n/**\r\n * @member {Function} Elem#feDropShadow\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feDropShadow',\n\n/**\r\n * @member {Function} Elem#feFlood\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feFlood',\n\n/**\r\n * @member {Function} Elem#feFuncA\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feFuncA',\n\n/**\r\n * @member {Function} Elem#feFuncB\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feFuncB',\n\n/**\r\n * @member {Function} Elem#feFuncG\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feFuncG',\n\n/**\r\n * @member {Function} Elem#feFuncR\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feFuncR',\n\n/**\r\n * @member {Function} Elem#feGaussianBlur\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feGaussianBlur',\n\n/**\r\n * @member {Function} Elem#feImage\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feImage',\n\n/**\r\n * @member {Function} Elem#feMerge\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feMerge',\n\n/**\r\n * @member {Function} Elem#feMergeNode\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feMergeNode',\n\n/**\r\n * @member {Function} Elem#feMorphology\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feMorphology',\n\n/**\r\n * @member {Function} Elem#feOffset\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feOffset',\n\n/**\r\n * @member {Function} Elem#fePointLight\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'fePointLight',\n\n/**\r\n * @member {Function} Elem#feSpecularLighting\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feSpecularLighting',\n\n/**\r\n * @member {Function} Elem#feSpotLight\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feSpotLight',\n\n/**\r\n * @member {Function} Elem#feTile\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feTile',\n\n/**\r\n * @member {Function} Elem#feTurbulence\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'feTurbulence',\n\n/**\r\n * @member {Function} Elem#font\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'font',\n\n/**\r\n * @member {Function} Elem#fontFace\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'font-face',\n\n/**\r\n * @member {Function} Elem#fontFaceFormat\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'font-face-format',\n\n/**\r\n * @member {Function} Elem#fontFaceName\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'font-face-name',\n\n/**\r\n * @member {Function} Elem#fontFaceSrc\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'font-face-src',\n\n/**\r\n * @member {Function} Elem#fontFaceUri\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'font-face-uri',\n\n/**\r\n * @member {Function} Elem#foreignObject\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'foreignObject',\n\n/**\r\n * @member {Function} Elem#g\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'g',\n\n/**\r\n * @member {Function} Elem#glyph\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'glyph',\n\n/**\r\n * @member {Function} Elem#glyphRef\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'glyphRef',\n\n/**\r\n * @member {Function} Elem#hatch\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'hatch',\n\n/**\r\n * @member {Function} Elem#hatchpath\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'hatchpath',\n\n/**\r\n * @member {Function} Elem#hkern\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'hkern',\n\n/**\r\n * @member {Function} Elem#image\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'image',\n\n/**\r\n * @member {Function} Elem#line\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'line',\n\n/**\r\n * @member {Function} Elem#linearGradient\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'linearGradient',\n\n/**\r\n * @member {Function} Elem#marker\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'marker',\n\n/**\r\n * @member {Function} Elem#mask\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'mask',\n\n/**\r\n * @member {Function} Elem#mesh\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'mesh',\n\n/**\r\n * @member {Function} Elem#meshgradient\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'meshgradient',\n\n/**\r\n * @member {Function} Elem#meshpatch\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'meshpatch',\n\n/**\r\n * @member {Function} Elem#meshrow\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'meshrow',\n\n/**\r\n * @member {Function} Elem#metadata\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'metadata',\n\n/**\r\n * @member {Function} Elem#missingGlyph\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'missing-glyph',\n\n/**\r\n * @member {Function} Elem#mpath\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'mpath',\n\n/**\r\n * @member {Function} Elem#path\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'path',\n\n/**\r\n * @member {Function} Elem#pattern\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'pattern',\n\n/**\r\n * @member {Function} Elem#polygon\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'polygon',\n\n/**\r\n * @member {Function} Elem#polyline\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'polyline',\n\n/**\r\n * @member {Function} Elem#radialGradient\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'radialGradient',\n\n/**\r\n * @member {Function} Elem#rect\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'rect',\n\n/**\r\n * @member {Function} Elem#set\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'set',\n\n/**\r\n * @member {Function} Elem#solidcolor\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'solidcolor',\n\n/**\r\n * @member {Function} Elem#stop\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'stop',\n\n/**\r\n * @member {Function} Elem#style\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'style',\n\n/**\r\n * @member {Function} Elem#svg\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'svg',\n\n/**\r\n * @member {Function} Elem#switch\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'switch',\n\n/**\r\n * @member {Function} Elem#symbol\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'symbol',\n\n/**\r\n * @member {Function} Elem#textPath\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'textPath',\n\n/**\r\n * @member {Function} Elem#tref\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'tref',\n\n/**\r\n * @member {Function} Elem#tspan\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'tspan',\n\n/**\r\n * @member {Function} Elem#unknown\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'unknown',\n\n/**\r\n * @member {Function} Elem#use\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'use',\n\n/**\r\n * @member {Function} Elem#view\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'view',\n\n/**\r\n * @member {Function} Elem#vkern\r\n * @type {Function}\r\n * @param {...String} appliedExpressions\r\n * @returns {Elem}\r\n */\n'vkern'];\n\nvar voidElements = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\nvar htmlAllowedTagSymbols = '[a-z][a-z\\\\d\\\\-_.:!@#\\\\$%\\\\^&*()\\\\[\\\\]{}\\\\\\\\=\\'\"]*';\nvar htmlAllowedAttrSymbols = '[^\\\\u0000-\\\\u0020\\\\s\"\\'>/=]+';\n\n/**\r\n * @module constants/regexpSpecialCharacters\r\n * @private\r\n * @description Exports special characters for RegExp.\r\n */\n\n/**\r\n * @const\r\n * @name module:constants/regexpSpecialCharacters~regexpSpecialCharacters\r\n * @type {String[]}\r\n */\nvar regexpSpecialCharacters = ['.', '+', '*', '?', '(', ')', '[', ']', '{', '}', '<', '>', '^', '$', '!', '=', ':', '-', '|', ',', '\\\\'];\n\n/**\r\n * @module helpers/toStringTag\r\n * @private\r\n * @description Exports toStringTag method.\r\n */\n\n/**\r\n * @function toStringTag\r\n * @param {*} object - Object to get toStringTag of.\r\n * @returns {String} Cut string.\r\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\r\n */\nfunction toStringTag(object) {\n  return {}.toString.call(object).replace(/^\\[object |]$/g, '');\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/**\r\n * @module helpers/checkTypes\r\n * @private\r\n * @mixin\r\n * @description Exports is<Type> methods.\r\n */\n\n/**\r\n * @function isArray\r\n * @public\r\n * @param {*} value - Value to check if it is an array.\r\n * @returns {Boolean} If the argument is an array or not.\r\n * \r\n * @example\r\n * isArray([]);                             // true\r\n * isArray(0);                              // true\r\n * isArray(document.querySelectorAll('*')); // false\r\n */\nfunction isArray(value) {\n  return toStringTag(value) === 'Array';\n}\n\n/**\r\n * @function isArrayLike\r\n * @public\r\n * @param {*} value - Value to check if it is array-like.\r\n * @returns {Boolean} If the argument is array-like or not.\r\n * @description Basically returns if the argument has non-negative integer \"length\" property and isn't a function.\r\n * \r\n * @example\r\n * isArrayLike([]);                             // true\r\n * isArrayLike('');                             // true\r\n * isArrayLike(() => {});                       // false\r\n * isArrayLike(document.querySelectorAll('*')); // true\r\n */\nfunction isArrayLike(value) {\n  if (!value || isFunction(value)) {\n    return false;\n  }\n\n  var length = value.length;\n\n  return isInteger(length) && length >= 0;\n}\n\n/**\r\n * @function isBoolean\r\n * @public\r\n * @param {*} value - Value to check if it is a boolean.\r\n * @returns {Boolean} If the argument is a boolean or not.\r\n * \r\n * @example\r\n * isBoolean(true);               // true\r\n * isBoolean(new Boolean(false)); // true\r\n * isBoolean(null);               // false\r\n */\nfunction isBoolean(value) {\n  return toStringTag(value) === 'Boolean';\n}\n\n/**\r\n * @function isDate\r\n * @public\r\n * @param {*} value - Value to check if it is a date.\r\n * @returns {Boolean} If the argument is a date or not.\r\n * \r\n * @example\r\n * isDate(new Date());                 // true\r\n * isDate('1999-12-31T23:59:59.999Z'); // false\r\n */\nfunction isDate(value) {\n  return toStringTag(value) === 'Date';\n}\n\n/**\r\n * @function isDateLike\r\n * @public\r\n * @param {*} value - Value to check if it is date-like.\r\n * @returns {Boolean} If the argument is date-like or not.\r\n * @description Basically returns if new Date(argument) is not invalid date.\r\n * \r\n * @example\r\n * isDateLike(new Date());                 // true\r\n * isDateLike('1999-12-31T23:59:59.999Z'); // true\r\n * isDateLike(0);                          // true\r\n */\nfunction isDateLike(value) {\n  value = new Date(value);\n\n  return !isNaN(value.getTime());\n}\n\n/**\r\n * @function isElement\r\n * @public\r\n * @param {*} value - Value to check if it is an element.\r\n * @returns {Boolean} If the argument is element or not.\r\n *\r\n * @example\r\n * isElement(document.querySelector('html')); // true\r\n */\nfunction isElement(value) {\n  return (/Element$/.test(toStringTag(value))\n  );\n}\n\n/**\r\n * @function isFinite\r\n * @public\r\n * @param {*} value - Value to check if it is finite.\r\n * @returns {Boolean} If the argument is finite or not.\r\n * \r\n * @example\r\n * isFinite(0);        // true\r\n * isFinite('0');      // false\r\n * isFinite(Infinity); // false\r\n * isFinite(NaN);      // false\r\n */\nfunction isFinite(value) {\n  if (!isNumber(value)) {\n    return false;\n  }\n\n  value = Number(value);\n\n  return !isNaN(value) && value !== Infinity && value !== -Infinity;\n}\n\n/**\r\n * @function isFunction\r\n * @public\r\n * @param {*} value - Value to check if it is a function.\r\n * @returns {Boolean} If the argument is a function or not.\r\n * \r\n * @example\r\n * isFunction(() => {});            // true\r\n * \r\n * const func = () => {};\r\n * Object.setPrototypeOf(func, {});\r\n * isFunction(func);                // true\r\n */\nfunction isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\r\n * @function isInteger\r\n * @public\r\n * @param {*} value - Value to check if it is an integer.\r\n * @returns {Boolean} If the argument is an integer or not.\r\n *\r\n * @example\r\n * isInteger(0);             // true\r\n * isInteger(0.1);           // false\r\n * isInteger(new Number(0)); // true\r\n * isInteger('0');           // false\r\n * isInteger(Infinity);      // false\r\n * isInteger(NaN);           // false\r\n */\nfunction isInteger(value) {\n  return isNumber(value) && value % 1 === 0;\n}\n\n/**\r\n * @function isIntegerLike\r\n * @public\r\n * @param {*} value - Value to check if it is integer-like.\r\n * @returns {Boolean} If the argument is integer-like or not.\r\n *\r\n * @example\r\n * isIntegerLike(0);             // true\r\n * isIntegerLike(new Number(0)); // true\r\n * isIntegerLike(0.1);           // false\r\n * isIntegerLike('0');           // true\r\n */\nfunction isIntegerLike(value) {\n  value = parseInt(Number(value));\n\n  return !!(value || value === 0);\n}\n\n/**\r\n * @function isNaN\r\n * @public\r\n * @param {*} value - Value to check if it is NaN.\r\n * @returns {Boolean} If the argument is NaN or not.\r\n *\r\n * @example\r\n * isNaN(0);               // false\r\n * isNaN('NaN');           // false\r\n * isNaN(NaN);             // true\r\n * isNaN(new Number(NaN)); // true\r\n */\nfunction isNaN(value) {\n  if (!isNumber(value)) {\n    return false;\n  }\n\n  value = Number(value);\n\n  return value !== value;\n}\n\n/**\r\n * @function isNull\r\n * @public\r\n * @param {*} value - Value to check if it is null.\r\n * @returns {Boolean} If the argument is null or not.\r\n *\r\n * @example\r\n * isNull(null);      // true\r\n * isNull(undefined); // false\r\n */\nfunction isNull(value) {\n  return value === null;\n}\n\n/**\r\n * @function isNil\r\n * @public\r\n * @param {*} value - Value to check if it is null or undefined.\r\n * @returns {Boolean} If the argument is null or undefined or not.\r\n *\r\n * @example\r\n * isNil(null);      // true\r\n * isNil(undefined); // true\r\n * isNil(false);     // false\r\n */\nfunction isNil(value) {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\r\n * @function isNumber\r\n * @public\r\n * @param {*} value - Value to check if it is a number.\r\n * @returns {Boolean} If the argument is a number or not.\r\n *\r\n * @example\r\n * isNumber(0);             // true\r\n * isNumber(new Number(0)); // true\r\n * isNumber(NaN);           // true\r\n * isNumber('0');           // false\r\n */\nfunction isNumber(value) {\n  return toStringTag(value) === 'Number';\n}\n\n/**\r\n * @function isNumberLike\r\n * @public\r\n * @param {*} value - Value to check if it is number-like.\r\n * @returns {Boolean} If the argument is number-like or not.\r\n *\r\n * @example\r\n * isNumberLike(0);          // true\r\n * isNumberLike('0');        // true\r\n * isNumberLike('Infinity'); // true\r\n * isNumberLike('NaN');      // true\r\n * isNumberLike(NaN);        // true\r\n */\nfunction isNumberLike(value) {\n  if (isNaN(value) || value === 'NaN') {\n    return true;\n  }\n\n  value = Number(value);\n\n  return !!(value || value === 0);\n}\n\n/**\r\n * @function isObject\r\n * @public\r\n * @param {*} value - Value to check if it is an object.\r\n * @returns {Boolean} If the argument is an object or not.\r\n *\r\n * @example\r\n * isObject({});   // true\r\n * isObject(1);    // false\r\n * isObject(null); // false\r\n */\nfunction isObject(value) {\n  return !!value && (toStringTag(value) === 'Object' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || value instanceof Object);\n}\n\n/**\r\n * @function isPlainObject\r\n * @public\r\n * @param {*} value - Value to check if it is a plain object.\r\n * @returns {Boolean} If the argument is a plain object or not.\r\n *\r\n * @example\r\n * const obj = {};\r\n *\r\n * ifPlainObject(obj); // true\r\n *\r\n * Object.setPrototypeOf(object, null);\r\n *\r\n * ifPlainObject(obj); // true\r\n *\r\n * Object.setPrototypeOf(object, {});\r\n *\r\n * ifPlainObject(obj); // false\r\n */\nfunction isPlainObject(value) {\n  if (isPrimitive(value)) {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n\n  if (isNull(proto)) {\n    return true;\n  }\n\n  var constructor = proto.constructor;\n\n  return isFunction(constructor) && constructor instanceof constructor && isNull(Object.getPrototypeOf(proto));\n}\n\n/**\r\n * @function isPrimitive\r\n * @public\r\n * @param {*} value - Value to check if it is primitive.\r\n * @returns {Boolean} If the argument is primitive or not.\r\n *\r\n * @example\r\n * isPrimitive(1);             // true\r\n * isPrimitive({});            // false\r\n * isPrimitive('');            // true\r\n * isPrimitive(new Number(0)); // false\r\n * isPrimitive(true);          // true\r\n * isPrimitive(Symbol('foo')); // true\r\n * isPrimitive(null);          // true\r\n * isPrimitive(undefined);     // true\r\n */\nfunction isPrimitive(value) {\n  return isNull(value) || /^(number|string|boolean|symbol|undefined)$/.test(typeof value === 'undefined' ? 'undefined' : _typeof(value));\n}\n\n/**\r\n * @function isRegExp\r\n * @public\r\n * @param {*} value - Value to check if it is a regular expression.\r\n * @returns {Boolean} If the argument is a regular expression or not.\r\n *\r\n * @example\r\n * isRegExp(/foo/);             // true\r\n * isRegExp('/foo/');           // false\r\n * isRegExp(new RegExp('foo')); // true\r\n */\nfunction isRegExp(value) {\n  return toStringTag(value) === 'RegExp';\n}\n\n/**\r\n * @function isString\r\n * @public\r\n * @param {*} value - Value to check if it is a string.\r\n * @returns {Boolean} If the argument is a string or not.\r\n *\r\n * @example\r\n * isString('0');             // true\r\n * isString(new String('0')); // true\r\n */\nfunction isString(value) {\n  return toStringTag(value) === 'String';\n}\n\n/**\r\n * @function isSymbol\r\n * @public\r\n * @param {*} value - Value to check if it is a symbol.\r\n * @returns {Boolean} If the argument is a symbol or not.\r\n *\r\n * @example\r\n * isSymbol(Symbol('1')); // true\r\n */\nfunction isSymbol(value) {\n  return toStringTag(value) === 'Symbol';\n}\n\n/**\r\n * @function isUndefined\r\n * @public\r\n * @param {*} value - Value to check if it is undefined.\r\n * @returns {Boolean} If the argument is undefined or not.\r\n *\r\n * @example\r\n * isUndefined(null);      // false\r\n * isUndefined(undefined); // true\r\n */\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n\n/**\r\n * @module constants/validateCheckExpressions\r\n * @private\r\n * @description Exports different types of validate expressions for {@link module:helpers/validate}.\r\n */\n\n/**\r\n * @callback checkValidityCallback\r\n * @private\r\n * @param {*} value - Value to check.\r\n */\n\n/**\r\n * @typedef {Object} validateExpr\r\n * @private\r\n * @property {String} text - Text of the thrown error.\r\n * @property {Error} error - Type of the thrown error.\r\n * @property {checkValidityCallback} check - Callback for checking value.\r\n */\n\n/**\r\n * @type {validateExpr[]}\r\n * @private\r\n * @description Object of different types of validation.\r\n */\nvar validateCheckExpressions = {\n  '>0': {\n    check: function check(n) {\n      return n > 0;\n    },\n    text: '$n argument must be positive!',\n    error: RangeError\n  },\n  '>=0': {\n    check: function check(n) {\n      return n >= 0;\n    },\n    text: '$n argument must be non-negative!',\n    error: RangeError\n  },\n  '<0': {\n    check: function check(n) {\n      return n < 0;\n    },\n    text: '$n argument must be negative!',\n    error: RangeError\n  },\n  '<=0': {\n    check: function check(n) {\n      return n <= 0;\n    },\n    text: '$n argument must be non-positive!',\n    error: RangeError\n  },\n  '!!': {\n    check: function check(v) {\n      return !isNil(v);\n    },\n    text: '$n argument must be not null or undefined!',\n    error: TypeError\n  },\n  array: {\n    check: isArray,\n    text: '$n argument must be an array!',\n    error: TypeError\n  },\n  'array||!': {\n    check: function check(a) {\n      return isArray(a) || isNil(a);\n    },\n    text: '$n argument must be an array, or undefined, or null!',\n    error: TypeError\n  },\n  arrayLike: {\n    check: isArrayLike,\n    text: '$n argument must be array-like!',\n    error: TypeError\n  },\n  'arrayLike||!': {\n    check: function check(a) {\n      return isArrayLike(a) || isNil(a);\n    },\n    text: '$n argument must be array-like, or undefined, or null!',\n    error: TypeError\n  },\n  date: {\n    check: isDate,\n    text: '$n argument must be a date!',\n    error: TypeError\n  },\n  'date||!': {\n    check: function check(d) {\n      return isDate(d) || isNil(d);\n    },\n    text: '$n argument must be a date, or undefined, or null!',\n    error: TypeError\n  },\n  dateLike: {\n    check: isDateLike,\n    text: '$n argument must be date-like!',\n    error: TypeError\n  },\n  'dateLike||!': {\n    check: function check(d) {\n      return isDateLike(d) || isNil(d);\n    },\n    text: '$n argument must be date-like, or undefined, or null!',\n    error: TypeError\n  },\n  function: {\n    check: isFunction,\n    text: '$n argument must be a function!',\n    error: TypeError\n  },\n  'function||!': {\n    check: function check(f) {\n      return isFunction(f) || isNil(f);\n    },\n    text: '$n argument must be a function, or undefined, or null!',\n    error: TypeError\n  },\n  int: {\n    check: isInteger,\n    text: '$n argument must be an integer!',\n    error: TypeError\n  },\n  'int||!': {\n    check: function check(i) {\n      return isInteger(i) || isNil(i);\n    },\n    text: '$n argument must be an integer, or undefined, or null!',\n    error: TypeError\n  },\n  intLike: {\n    check: isIntegerLike,\n    text: '$n argument must be integer-like!',\n    error: TypeError\n  },\n  'intLike||!': {\n    check: function check(i) {\n      return isIntegerLike(i) || isNil(i);\n    },\n    text: '$n argument must be integer-like, or undefined, or null!',\n    error: TypeError\n  },\n  number: {\n    check: isNumber,\n    text: '$n argument must be a number!',\n    error: TypeError\n  },\n  'number||!': {\n    check: function check(n) {\n      return isNumber(n) || isNil(n);\n    },\n    text: '$n argument must be a number, or undefined, or null!',\n    error: TypeError\n  },\n  numberLike: {\n    check: isNumberLike,\n    text: '$n argument must be number-like!',\n    error: TypeError\n  },\n  'numberLike||!': {\n    check: function check(n) {\n      return isNumberLike(n) || isNil(n);\n    },\n    text: '$n argument must be number-like, or undefined, or null!',\n    error: TypeError\n  },\n  object: {\n    check: isObject,\n    text: '$n argument must be an object!',\n    error: TypeError\n  },\n  'object||!': {\n    check: function check(o) {\n      return isObject(o) || isNil(o);\n    },\n    text: '$n argument must be an object, or undefined, or null!',\n    error: TypeError\n  },\n  regexp: {\n    check: isRegExp,\n    text: '$n argument must be a regular expression!',\n    error: TypeError\n  },\n  'regexp||!': {\n    check: function check(r) {\n      return isRegExp(r) || isNil(r);\n    },\n    text: '$n argument must be a regular expression, or undefined, or null!',\n    error: TypeError\n  },\n  string: {\n    check: isString,\n    text: '$n argument must be a string!',\n    error: TypeError\n  },\n  'string||!': {\n    check: function check(s) {\n      return isString(s) || isNil(s);\n    },\n    text: '$n argument must be a string, or undefined, or null!',\n    error: TypeError\n  }\n};\n\n/**\r\n * @module D\r\n * @private\r\n * @description Exports D function.\r\n */\n\n/**\r\n * @function D\r\n * @public\r\n * @param {*} [value] - Any value.\r\n * @returns {DWrap} Wrap of the argument.\r\n * @description Function for creating a D-wrap of an object.\r\n *\r\n * @example\r\n * D({});            // Super\r\n * D(() => {});      // Func\r\n * D([]);            // Arr\r\n * D(1);             // Num\r\n * D('1');           // Str\r\n * D(new Date());    // Dat\r\n * D(document.body); // Elem\r\n */\nfunction D$1(value) {\n  for (var i = constructors.length - 1; i >= 0; i--) {\n    var levelConstructors = constructors[i];\n\n    for (var k = 0, len = levelConstructors.length; k < len; k++) {\n      var _constructor = levelConstructors[k];\n\n      if (value instanceof _constructor.cls) {\n        return value;\n      }\n\n      if (_constructor.check(value)) {\n        return new _constructor.cls(value);\n      }\n    }\n  }\n}\n\n/**\r\n * @module helpers/iterate\r\n * @private\r\n * @description Exports iterate method.\r\n */\n\n/**\r\n * @callback IterationCallback\r\n * @param {*} value - Iteration value.\r\n * @param {String|Number} key - Iteration key.\r\n * @param {*} object - Initial iterable object.\r\n */\n\n/**\r\n * @function iterate\r\n * @param {(Object|Array|null|undefined)} object - Value to iterate over.\r\n * @param {IterationCallback} callback - Callback that is called on every iteration.\r\n * @returns {*} If callback returns not undefined then iterate returns this value.\r\n * @description Function for iterating over all types of values.\r\n */\nfunction iterate(object, callback) {\n  var array = isArrayLike(object);\n  var iteratedKeys = {};\n\n  var iterated = 0;\n\n  for (var key in object) {\n    if ({}.hasOwnProperty.call(iteratedKeys, key)) {\n      continue;\n    }\n\n    iteratedKeys[key] = true;\n\n    if ({}.hasOwnProperty.call(object, key)) {\n      if (array && iterated++ >= object.length) {\n        break;\n      }\n\n      var value = callback(object[key], array ? Number(key) : key, object);\n\n      if (!isUndefined(value)) {\n        return value;\n      }\n    }\n  }\n}\n\n/**\r\n * @module helpers/assign\r\n * @private\r\n * @description Exports Object.assign-like method.\r\n */\n\n/**\r\n * @const\r\n * @function assign\r\n * @param {Object} target - Object to assign rest of arguments to.\r\n * @param {...Object} objects - Objects that are assigned to the target.\r\n * @returns {Object} Target.\r\n */\nfunction assign$1(target) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  iterate(arguments, function (source, index) {\n    if (index) {\n      iterate(source, function (value, key) {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\n/**\r\n * @module helpers/defineProperty\r\n * @private\r\n * @description Exports defineProperty and dynamicDefineProperties methods.\r\n */\n\n/**\r\n * @callback propertyGeneratorCallback\r\n * @param {String} name - Name of the property.\r\n * @param {Number} i - Index of the array.\r\n * @returns {*} Generated property.\r\n */\n\n/**\r\n * @function dynamicDefineProperties\r\n * @param {Object} target - Object to define properties for.\r\n * @param {Array} properties - Object which keys are properties.\r\n * @param {propertyGeneratorCallback} propertyGenerator - Callback for every property.\r\n * @returns {void}\r\n * @description Function for dynamic creating properties based on name of the method.\r\n */\nfunction dynamicDefineProperties(target, properties, propertyGenerator) {\n  iterate(properties, function (name, i) {\n    Object.defineProperty(target, name, {\n      value: propertyGenerator(name, i),\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\r\n * @function defineProperties\r\n * @param {Object} target - Target to define properties for.\r\n * @param {Object} properties - Object with properties needed to be assign to the target.\r\n * @returns {void}\r\n * @description Function for defining properties of an object.\r\n */\nfunction defineProperties(target, properties) {\n  iterate(properties, function (method, name) {\n    if (/^get /.test(name)) {\n      Object.defineProperty(target, name.replace(/^get /, ''), {\n        get: method,\n        set: undefined,\n        enumerable: false,\n        configurable: true\n      });\n\n      return;\n    }\n\n    if (/^set /.test(name)) {\n      Object.defineProperty(target, name.replace(/^set /, ''), {\n        set: method,\n        get: undefined,\n        enumerable: false,\n        configurable: true\n      });\n\n      return;\n    }\n\n    if (/^get\\/set /.test(name)) {\n      Object.defineProperty(target, name.replace(/^get\\/set /, ''), {\n        get: method.get,\n        set: method.set,\n        enumerable: false,\n        configurable: true\n      });\n\n      return;\n    }\n\n    if (name !== 'Symbol.toStringTag') {\n      Object.defineProperty(target, name, {\n        value: method,\n        writable: true,\n        enumerable: false,\n        configurable: true\n      });\n    }\n  });\n}\n\n/**\r\n * @module helpers/Symbol\r\n * @private\r\n * @description Exports Symbol class.\r\n */\n\nvar _Symbol = global$1.Symbol || {\n  toStringTag: 'Symbol.toStringTag',\n  iterator: Math.random().toString(36)\n};\n\n/**\r\n * @module helpers/toArray\r\n * @private\r\n * @description Exports toArray method.\r\n */\n\n/**\r\n * @function toArray\r\n * @param {*} value - Any value.\r\n * @param {Boolean} [createNewArray = false] - If it is needed to create new array.\r\n * @returns {Array} Create array.\r\n * @description Function for creating an array of any value.\r\n */\nfunction toArray$1(value, createNewArray) {\n  if (isArray(value) && !createNewArray) {\n    return value;\n  }\n\n  var array = [];\n\n  if (isArrayLike(value) && !isString(value)) {\n    iterate(value, function (value) {\n      array.push(value);\n    });\n  } else {\n    array.push(value);\n  }\n\n  return array;\n}\n\n/**\r\n * @module helpers/validate\r\n * @private\r\n * @description Exports validate method.\r\n */\n\nvar numbers = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th'];\n\n/**\r\n * @function validate\r\n * @private\r\n * @param {Object} args - Arguments of function.\r\n * @param {Object} options - Object with validate parameters.\r\n * @param {String} [name] - Name of the function what called validate.\r\n * @returns {void}\r\n * @description Function for checking arguments of other functions.\r\n */\nfunction validate$1(args, options, name) {\n  iterate(options, function (array, number) {\n    if (!isArray(array)) {\n      array = [array];\n    }\n\n    iterate(array, function (checker) {\n      checker = validateCheckExpressions[checker];\n\n      if (!checker.check(args[number])) {\n        throw new checker.error(checker.text.replace('$n', numbers[number]) + (name ? ' (at ' + name + ')' : ''));\n      }\n    });\n  });\n}\n\n/**\r\n * @module Alphabet\r\n * @private\r\n * @mixin\r\n * @description Exports Alphabet class.\r\n */\n\n/**\r\n * @typedef {String} Char\r\n * @public\r\n * @description A string of one char.\r\n */\n\n/**\r\n * @class Alphabet\r\n * @public\r\n * @param {ArrayLike} alphabet - Alphabet to wrap.\r\n * @returns {Alphabet} Instance of Alphabet.\r\n * @description Class for alphabet manipulations: add, delete symbols, generate a token from an alphabet,\r\n * check if an alphabet contains a word.\r\n *\r\n * @example\r\n * new Alphabet(['a', 'b', 'c']);\r\n */\n\nvar Alphabet = function () {\n  function Alphabet() {\n    var alphabet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, Alphabet);\n\n    var a = {};\n\n    for (var i = 0, length = alphabet.length; i < length; i++) {\n      var char = alphabet[i];\n\n      if (!check$1(char)) {\n        throw new Error('Each element of an array must be a single char! (in Alphabet)');\n      }\n\n      a[char] = char;\n    }\n\n    /**\r\n     * @member {Object} Alphabet#$$\r\n     * @public\r\n     * @description The alphabet.\r\n     */\n    Object.defineProperty(this, '$$', { value: a });\n  }\n\n  /**\r\n   * @method Alphabet#add\r\n   * @public\r\n   * @param {...Char} chars - Chars to add.\r\n   * @returns {Alphabet} Returns this.\r\n   * @description Method for adding new letters to the alphabet.\r\n   *\r\n   * @example\r\n   * const alphabet = new Alphabet(['a', 'b', 'c']);\r\n   *\r\n   * alphabet.add('d', 'e');\r\n   *\r\n   * alphabet.get().$; // ['a', 'b', 'c', 'd', 'e']\r\n   */\n\n\n  createClass(Alphabet, [{\n    key: 'add',\n    value: function add() {\n      for (var _len = arguments.length, chars = Array(_len), _key = 0; _key < _len; _key++) {\n        chars[_key] = arguments[_key];\n      }\n\n      for (var i = 0, length = chars.length; i < length; i++) {\n        var char = chars[i];\n\n        if (!check$1(char)) {\n          throw new Error('Each argument must be a single char! (in Alphabet#add)');\n        }\n\n        this.$$[char] = char;\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Alphabet#contains\r\n     * @public\r\n     * @param {String} word - Word to check if it is in the alphabet or not.\r\n     * @returns {Boolean} If the word in the alphabet or not.\r\n     * @description Method that returns if a word is in alphabet or not.\r\n     *\r\n     * @example\r\n     * const alphabet = new Alphabet(['f', 'b', 'o', 'a', 'r']);\r\n     *\r\n     * alphabet.contains('foo'); // true\r\n     * alphabet.contains('bar'); // true\r\n     * alphabet.contains('baz'); // false\r\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(word) {\n      validate$1([word], ['string'], 'Alphabet#contains');\n\n      var alphabet = this.$$;\n\n      for (var i = 0, length = word.length; i < length; i++) {\n        if (!alphabet[word[i]]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\r\n     * @method Alphabet#delete\r\n     * @public\r\n     * @param {...Char} chars - Chars to delete.\r\n     * @returns {Alphabet} Returns this.\r\n     * @description Method for deleting letters from the alphabet.\r\n     *\r\n     * @example\r\n     * const alphabet = new Alphabet(['a', 'b', 'c', 'd']);\r\n     *\r\n     * alphabet.delete('a');\r\n     *\r\n     * alphabet.get().$; // ['b', 'c', 'd']\r\n     *\r\n     * alphabet.delete('b', 'd');\r\n     *\r\n     * alphabet.get().$; // ['c']\r\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      for (var _len2 = arguments.length, chars = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        chars[_key2] = arguments[_key2];\n      }\n\n      for (var i = 0, length = chars.length; i < length; i++) {\n        var char = chars[i];\n\n        if (!check$1(char)) {\n          throw new Error('Each argument must be a single char! (in Alphabet#delete)');\n        }\n\n        delete this.$$[char];\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Alphabet#get\r\n     * @returns {Array} Wrap of an array of alphabet letters.\r\n     * @description Method for getting array of alphabet letters.\r\n     *\r\n     * @example\r\n     * new Alphabet(['a', 'b', 'c']).get().$; // ['a', 'b', 'c']\r\n     */\n\n  }, {\n    key: 'get',\n    value: function get() {\n      return Object.keys(this.$$);\n    }\n\n    /**\r\n     * @method Alphabet#token\r\n     * @public\r\n     * @param {Number} length - Token length.\r\n     * @returns {String} Token.\r\n     * @description Method for generating random token with given length.\r\n     *\r\n     * @example\r\n     * new Alphabet(['a', 'b', 'c']).token(4); // 'abcb'\r\n     */\n\n  }, {\n    key: 'token',\n    value: function token(length) {\n      validate$1([length], [['intLike', '>0']], 'Alphabet#token');\n\n      var alphabet = Object.keys(this.$$);\n      var len = alphabet.length;\n      var token = '';\n\n      for (var i = 0; i < length; i++) {\n        token += alphabet[Math.floor(Math.random() * len)];\n      }\n\n      return token;\n    }\n  }]);\n  return Alphabet;\n}();\n\ndefineProperties(Alphabet.prototype, defineProperty({}, _Symbol.toStringTag, 'Alphabet'));\n\nfunction check$1(char) {\n  return isString(char) && char.length === 1;\n}\n\n/**\r\n * @function alphabet\r\n * @public\r\n * @param {String} string - String to generate an alphabet from.\r\n * @returns {Alphabet} New instance of Alphabet.\r\n * @description Function for creating an alphabet from a string that has format like this:\r\n * '&lt;char1&gt;-&lt;char2&gt; &lt;char3&gt;-&lt;char4&gt;'\r\n *\r\n * @example\r\n * const a1 = alphabet('a-c 1-3');\r\n * const a2 = alphabet('5-5f-g');\r\n *\r\n * a1.get().$; // ['1', '2', '3', 'a', 'b', 'c']\r\n * a2.get().$; // ['5', 'f', 'g']\r\n */\nfunction alphabet(string) {\n  validate$1([string], ['string']);\n\n  var ranges = string.split(/([\\s\\S]-+[\\s\\S])?/g);\n  var length = ranges.length;\n  var alphabet = [];\n\n  for (var i = 0; i < length; i++) {\n    var range = ranges[i];\n\n    if (!range || range === ' ') {\n      continue;\n    }\n\n    if (/-/.test(range) && !/[\\s\\S]-+[\\s\\S]/.test(range)) {\n      throw new Error('Wrong part of the string (' + range + ')! (in alphabet)');\n    }\n\n    if (/-/.test(range)) {\n      var start = range.charCodeAt(0);\n      var end = range.charCodeAt(2);\n\n      if (start > end) {\n        throw new Error('Start of the range must be before its end! (in alphabet)');\n      }\n\n      for (var k = 0, len = end - start + 1; k < len; k++) {\n        alphabet.push(String.fromCharCode(start + k));\n      }\n\n      continue;\n    }\n\n    if (range.length === 1) {\n      alphabet.push(range);\n    }\n  }\n\n  return new Alphabet(alphabet);\n}\n\n/**\r\n * @module Switcher\r\n * @private\r\n * @mixin\r\n * @description Exports Switcher class.\r\n */\n\n/**\r\n * @typedef {'boolean'|'equals'|'strictEquals'|'call'} SwitcherMode\r\n * @public\r\n * @description Enum type of switcher modes.\r\n */\n\n/**\r\n * @callback SwitcherCallCallback\r\n * @public\r\n * @param {*} value - Switcher value.\r\n * @returns {Boolean|*} On what the callback returns depends if the case is a match (truthy for the match).\r\n */\n\n/**\r\n * @callback SwitcherMatchCallback\r\n * @public\r\n * @param {...*} args - Arguments from the second argument that switcher was called with.\r\n * @param {*} value - Switcher value.\r\n * @param {*} matched - Switcher matched case.\r\n */\n\n/**\r\n * @class Switcher\r\n * @public\r\n * @param {Object} [cases = {}] - Object of cases.\r\n * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.\r\n * @param {*} [defaultValue] - Switcher default value.\r\n * @returns {Switcher} - Instance of Switcher.\r\n * @description Switcher class for creating functions working similar to switch (value) {} construction,\r\n * but with the value assignment. Switcher instance is a function that accepts a value argument and an optional\r\n * args argument. Args with additional switcher value and matched case\r\n * are passed into the function of the matched case (if it is a function).\r\n *\r\n * @example\r\n * const switcher = new Switcher();\r\n * const switcher = new Switcher({\r\n *   case1: 'value1',\r\n *   case2: 'value2'\r\n * });\r\n * const switcher = new Switcher('strictEquals');\r\n * const switcher = new Switcher({\r\n *   case1: 'value1',\r\n *   case2: 'value2'\r\n * }, 'strictEquals');\r\n * const switcher = new Switcher('strictEquals', 'defaultValue');\r\n * const switcher = new Switcher({\r\n *   case1: 'value1',\r\n *   case2: 'value2'\r\n * }, 'strictEquals', 'defaultValue');\r\n *\r\n * // See [switcher]{@link switcher} examples for more information.\r\n */\n\nvar Switcher = function (_Function) {\n  inherits(Switcher, _Function);\n\n  function Switcher() {\n    var cases = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'equals';\n\n    var _ret;\n\n    var defaultValue = arguments[2];\n    classCallCheck(this, Switcher);\n\n    var _this = possibleConstructorReturn(this, (Switcher.__proto__ || Object.getPrototypeOf(Switcher)).call(this));\n\n    if (isString(cases)) {\n      if (!isUndefined(arguments[1])) {\n        defaultValue = mode;\n      }\n\n      mode = cases;\n      cases = {};\n    }\n\n    var eventualCases = [];\n\n    iterate(cases, function (value, Case) {\n      eventualCases.push({ case: Case, value: value });\n    });\n\n    function switcher(value) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var _switcher$$$ = switcher.$$,\n          mode = _switcher$$$.mode,\n          def = _switcher$$$.default,\n          cases = _switcher$$$.cases;\n\n\n      var ret = iterate(cases, function (_ref) {\n        var val = _ref.value,\n            Case = _ref.case;\n\n        if (mode === 'boolean' && Case ||\n        /* eslint eqeqeq: 0 */\n        mode === 'equals' && Case == value || mode === 'strictEquals' && Case === value || mode === 'call' && Case(value)) {\n          return { case: Case, value: val };\n        }\n      });\n\n      if (isUndefined(ret)) {\n        ret = { value: def };\n      }\n\n      if (!isFunction(ret.value)) {\n        return ret.value;\n      }\n\n      args = toArray$1(args, true);\n      args.push(value, ret.case);\n\n      return ret.value.apply(null, args);\n    }\n\n    /**\r\n     * @member Switcher#$$\r\n     * @type {Object}\r\n     * @protected\r\n     * @property {Array} cases - Array of cases.\r\n     * @property {SwitcherMode} mode - Switcher mode.\r\n     * @property {*} default - Switcher default value.\r\n     * @description Config parameters.\r\n     */\n    Object.defineProperty(switcher, '$$', {\n      value: {\n        cases: eventualCases,\n        mode: mode,\n        default: defaultValue\n      }\n    });\n    Object.setPrototypeOf(switcher, Switcher.prototype);\n\n    return _ret = switcher, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\r\n   * @method Switcher#case\r\n   * @public\r\n   * @param {*|SwitcherCallCallback|Array.<*|SwitcherCallCallback>} cases - Case or an array of cases.\r\n   * @param {*|SwitcherMatchCallback} value - Value that has to be assigned or a function\r\n   * that is called with switcher value, if it's the case.\r\n   * @returns {Switcher} Returns this.\r\n   * @description Method for defining new cases.\r\n   *\r\n   * @example\r\n   * const sw = new Switcher()\r\n   *   .case(1, 'one')\r\n   *   .case(2, 'two');\r\n   *\r\n   * sw(1); // 'one'\r\n   * sw(2); // 'two'\r\n   */\n\n\n  createClass(Switcher, [{\n    key: 'case',\n    value: function _case(cases, value) {\n      var _this2 = this;\n\n      if (!isArray(cases)) {\n        cases = [cases];\n      }\n\n      iterate(cases, function (Case) {\n        _this2.$$.cases.push({ case: Case, value: value });\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Switcher#default\r\n     * @public\r\n     * @param {*} def - New default value.\r\n     * @returns {Switcher} Returns this.\r\n     * @description Method for redefining default switcher value.\r\n     *\r\n     * @example\r\n     * const sw = new Switcher()\r\n     *   .case(1, 'one')\r\n     *   .default('three');\r\n     *\r\n     * sw(1); // 'one'\r\n     * sw(2); // 'three'\r\n     */\n\n  }, {\n    key: 'default',\n    value: function _default(def) {\n      this.$$.default = def;\n\n      return this;\n    }\n\n    /**\r\n     * @method Switcher#mode\r\n     * @public\r\n     * @param {SwitcherMode} mode - New switcher mode.\r\n     * @returns {Switcher} Returns this.\r\n     * @description Method for redefining switcher mode.\r\n     *\r\n     * @example\r\n     * const sw = new Switcher()\r\n     *   .mode('strictEquals')\r\n     *   .case(1, 'number')\r\n     *   .case('1', 'string');\r\n     *\r\n     * sw(1);   // 'number'\r\n     * sw('1'); // 'string'\r\n     */\n\n  }, {\n    key: 'mode',\n    value: function mode(_mode) {\n      this.$$.mode = _mode;\n\n      return this;\n    }\n  }]);\n  return Switcher;\n}(Function);\n\ndefineProperties(Switcher.prototype, defineProperty({}, _Symbol.toStringTag, 'Switcher'));\n\n/**\r\n * @function switcher\r\n * @public\r\n * @param {Object} [cases = {}] - Object of cases.\r\n * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.\r\n * @param {*} [defaultValue] - Switcher default value.\r\n * @returns {Switcher} New instance of Switcher.\r\n * @description Simple wrap of [new Switcher(...)]{@link Switcher}.\r\n * \r\n * @example\r\n * const sw = switcher({\r\n *   1: 'foo',\r\n *   2: 'bar'\r\n * });\r\n * sw(1); // 'foo'\r\n * sw(2); // 'bar'\r\n * sw(3); // undefined\r\n * \r\n * @example\r\n * const sw = switcher()\r\n *   .case([1, 2], 'foo')\r\n *   .case(3, 'bar');\r\n *   \r\n * sw(1); // 'foo'\r\n * sw(2); // 'foo'\r\n * sw(3); // 'bar'\r\n * \r\n * @example\r\n * const sw = switcher('call')\r\n *   .case(isArray, 'array')\r\n *   .case(isString, 'string')\r\n *   .case(isNumber, 'number')\r\n *   .default('rest');\r\n *   \r\n * sw([]);    // 'array'\r\n * sw('foo'); // 'string'\r\n * sw(123);   // 'number'\r\n * sw({});    // 'rest'\r\n * \r\n * @example\r\n * const sw = switcher({\r\n *   1: (value) => {\r\n *     console.log(value + 1);\r\n *   },\r\n *   2: () => {\r\n *     console.log(value - 1);\r\n *   }\r\n * });\r\n * \r\n * sw(1); // 2\r\n * sw(2); // 1\r\n * \r\n * @example\r\n * const sw = switcher({\r\n *   first: (array) => array[0],\r\n *   last: (array) => array[array.length - 1]\r\n * }, 'equals', (array, index) => array[index]);\r\n * const array = [1, 2, 3, 4];\r\n * \r\n * sw('first', [array]); // 1\r\n * sw('last', [array]);  // 4\r\n * sw(1, [array]);       // 2\r\n * sw(2, [array]);       // 3\r\n */\nfunction switcher(cases, mode, defaultValue) {\n  return new (Function.prototype.bind.apply(Switcher, [null].concat(Array.prototype.slice.call(arguments))))();\n}\n\n/**\r\n * @function when\r\n * @public\r\n * @param {Boolean|*} condition - Condition used for returning the proper value.\r\n * @param {*} value1 - Value if the condition is truthy.\r\n * @param {*} value2 - Value if the condition is falsey.\r\n * @returns {*} value1 or value2.\r\n * @description Synonym for\r\n * [ternary operator]{@link https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Operators/Conditional_Operator}.\r\n * \r\n * @example\r\n * when(true, 'true', 'false'); // 'true'\r\n */\nfunction when(condition, value1, value2) {\n  return condition ? value1 : value2;\n}\n\n/**\r\n * @module Super\r\n * @private\r\n * @mixin\r\n * @description Exports Super class.\r\n */\n\n/**\r\n * @typedef {Super|Arr|Func|Elem|Str|Num|Dat|BlobObject} DWrap\r\n * @public\r\n * @description Any kind of D-Wrap.\r\n */\n\n/**\r\n * @typedef {String|Number|null} Key\r\n * @public\r\n * @description Key type used in many methods.\r\n */\n\n/**\r\n * @typedef {TreeElement[]} Tree\r\n * @public\r\n */\n\n/**\r\n * @typedef {Object} TreeElement\r\n * @public\r\n * @property {Key} key - Tree element key.\r\n * @property {*} value - Tree element value.\r\n * @description {@link Tree} element.\r\n */\n\n/**\r\n * @callback DeepIterationCallback\r\n * @public\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n * @param {Tree} tree - Tree of { key, value } elements.\r\n */\n\n/**\r\n * @callback DeepReduceCallback\r\n * @public\r\n * @param {*} previousValue - Previous value.\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n * @param {Tree} tree - Tree of { key, value } elements.\r\n */\n\n/**\r\n * @callback IterationCallback\r\n * @public\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n */\n\n/**\r\n * @callback JSONCallback\r\n * @public\r\n * @param {String|null} key - Current value.\r\n * @param {*} value - Current key.\r\n * @param {Object} object - Iteration object.\r\n */\n\n/**\r\n * @callback ObjectCallback\r\n * @public\r\n * @param {Object} newObject - The new object.\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n */\n\n/**\r\n * @callback ReduceCallback\r\n * @public\r\n * @param {*} previousValue - Previous value.\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n */\n\n/**\r\n * @callback SuperMethod\r\n * @public\r\n * @this {DWrap}\r\n */\n\nvar cloneSwitcher = switcher('call', function (object) {\n  return object;\n}).case(function (object) {\n  return new Super(object) === object;\n}, function (object) {\n  return new (Object.getPrototypeOf(object).constructor)(new Super(object.$).deepClone().$);\n}).case(isElement, function (object, deep) {\n  return object.clone(deep);\n}).case(isDate, function (object) {\n  return new Date(object);\n}).case(isRegExp, function (object) {\n  return new RegExp(object.source, object.toString().match(/[gimuy]*$/)[0]);\n}).case(isArray, function () {\n  return [];\n}).case(isPlainObject, function () {\n  return {};\n});\n\n/**\r\n * @class Super\r\n * @public\r\n * @param {*} [object] - An object to wrap.\r\n * @returns {DWrap} Instance of Super.\r\n * @description Wrap of any value. And there is no way to create a nested wrap.\r\n *\r\n * @example\r\n * new Super({}); // Super\r\n */\n\nvar Super = function () {\n  function Super(object) {\n    classCallCheck(this, Super);\n\n    if (object instanceof Super) {\n      return object;\n    }\n\n    /**\r\n     * @member Super#$\r\n     * @type {*}\r\n     * @public\r\n     * @description Wrapped object.\r\n     */\n    Object.defineProperty(this, '$', { value: object });\n  }\n\n  /**\r\n   * @method Super.addStaticProperties\r\n   * @public\r\n   * @param {String|Object} property - Either a string of a property or an object\r\n   * with properties keys and values values.\r\n   * @param {Object} [value] - If a property parameter is a string this has to be a property value.\r\n   * @returns {this} Returns this.\r\n   * @description Sets static properties for DWrap constructors.\r\n   *\r\n   * @example\r\n   * Super.addStaticProperties('cool', 42);\r\n   * Super.addStaticProperties('superCool', 42*42);\r\n   */\n\n\n  createClass(Super, [{\n    key: 'assign',\n\n\n    /**\r\n     * @method Super#assign\r\n     * @public\r\n     * @param {...(Object|Super|*)} objects - Objects to be assigned to the object.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Synonym for\r\n     * [Object.assign]\r\n     * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2 }).assign({ a: 3 }, { c: 3, d: 4 }, { d: 5 }).$; // { a: 3, b: 2, c: 3, d: 5 }\r\n     */\n    value: function assign() {\n      for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n        objects[_key] = arguments[_key];\n      }\n\n      var object = this.$;\n\n      iterate(object && arguments, function (o) {\n        iterate(new Super(o).$, function (value, key) {\n          object[key] = value;\n        });\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#average\r\n     * @public\r\n     * @param {IterationCallback} [callback = null] - Callback that is passed to {@link Super#sum}.\r\n     * @returns {Number} Average value.\r\n     * @description Synonym for object.sum(callback) / object.count.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).average();                         // 2\r\n     * new Super({ a: 1, b: 2, c: 5 }).average((value) => value * value); // 10\r\n     */\n\n  }, {\n    key: 'average',\n    value: function average() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      validate$1([callback], ['function||!'], 'Super#average');\n\n      return this.sum(callback) / this.count;\n    }\n\n    /**\r\n     * @method Super#call\r\n     * @public\r\n     * @param {SuperMethod} func - Function to be called with this context.\r\n     * @param {...*} args - Arguments to be called with.\r\n     * @returns {*} Return of function call.\r\n     * @description Synonym for func.call(DObject, ...args);\r\n     *\r\n     * @example\r\n     * new Super({ a: 1 }).call(function (b, c) {\r\n     *   return this.a + b + c;\r\n     * }, 2, 3); // 6\r\n     */\n\n  }, {\n    key: 'call',\n    value: function call(func) {\n      validate$1([func], ['function'], 'Super#call');\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return func.apply(this, args);\n    }\n\n    /**\r\n     * @method Super#clone\r\n     * @returns {DWrap} New object.\r\n     * @description Method assigns properties of the object to an empty one and returns the new one.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2 } }).clone().$; // { a: 1, b: { c: 2 } }\r\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var object = this.$;\n      var clone = cloneSwitcher(object, [object, false]);\n\n      if (clone !== object) {\n        iterate(object, function (value, key) {\n          clone[key] = value;\n        });\n      }\n\n      return new this.constructor(clone);\n    }\n\n    /**\r\n     * @member Super#count\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description Returns number of own enumerable keys of the object.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2 }).count; // 2\r\n     */\n\n  }, {\n    key: 'create',\n\n\n    /**\r\n     * @method Super#create\r\n     * @public\r\n     * @param {Object} [descriptors] - Descriptors passed to Object.create.\r\n     * @returns {DWrap} New instance of D-Wrap.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\r\n     * @description Synonym for\r\n     * [Object.create]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create}.\r\n     *\r\n     * @example\r\n     * new Super({}).create({\r\n     *   a: {\r\n     *     value: 1,\r\n     *     enumerable: false,\r\n     *     writable: true,\r\n     *     configurable: false\r\n     *   }\r\n     * }).$; // { a: 1 }\r\n     */\n    value: function create(descriptors) {\n      return D$1(isPrimitive(this.$) ? undefined : Object.create(this.$, descriptors));\n    }\n\n    /**\r\n     * @method Super#deepAssign\r\n     * @public\r\n     * @param {...*} objects - Objects to be assigned to the object.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Deep analogue of {@link Super#assign}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1 }).deepAssign(\r\n     *   {\r\n     *     b: {\r\n     *       c: 2\r\n     *     }\r\n     *   },\r\n     *   {\r\n     *     a: {\r\n     *       b: 1\r\n     *     }\r\n     *   },\r\n     *   {\r\n     *     a: {\r\n     *       c: {\r\n     *         d: 1\r\n     *       }\r\n     *     },\r\n     *     b: 2\r\n     *   },\r\n     *   null\r\n     * });\r\n     * // {\r\n     * //   a: {\r\n     * //     b: 1,\r\n     * //     c: {\r\n     * //       d: 1\r\n     * //     }\r\n     * //   },\r\n     * //   b: 2,\r\n     * // }\r\n     */\n\n  }, {\n    key: 'deepAssign',\n    value: function deepAssign() {\n      for (var _len3 = arguments.length, objects = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        objects[_key3] = arguments[_key3];\n      }\n\n      var object = this.$;\n\n      if (isPrimitive(object)) {\n        return this;\n      }\n\n      iterate(arguments, function (o) {\n        _deepAssign(object, o);\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#deepClone\r\n     * @public\r\n     * @returns {DWrap} New instance of DWrap.\r\n     * @description Deep cloning method. Clones plain objects, arrays, regular expressions and elements, the rest stays the same.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: [2, 3], c: { d: 4 } }).deepClone().$;\r\n     * // {\r\n     * //   a: 1,\r\n     * //   b: [2, 3],\r\n     * //   c: { d: 4 }\r\n     * // }\r\n     */\n\n  }, {\n    key: 'deepClone',\n    value: function deepClone() {\n      return new this.constructor(_deepClone(this.$));\n    }\n\n    /**\r\n     * @method Super#deepEquals\r\n     * @public\r\n     * @param {*} [object] - Object to compare to.\r\n     * @returns {Boolean} - If the objects are deep equal or not.\r\n     * @description Method for deep comparison of two objects.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1 }).deepEquals({ a: '1' }); // true\r\n     * new Super(/1/).deepEquals(/1/);             // true\r\n     */\n\n  }, {\n    key: 'deepEquals',\n    value: function deepEquals() {\n      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return deepEqual(this.$, object, false);\n    }\n\n    /**\r\n     * @method Super#deepEvery\r\n     * @public\r\n     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy iteration goes on and if falsey it stops.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {Boolean} If all the callback calls returned truthy value.\r\n     * @description Returns boolean if all the callback calls returned truthy value.\r\n     * Otherwise false. Deep analogue of {@link Super#every}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepEvery((value) => value < 4); // true\r\n     * new Super({ a: {}, b: {}, c: {} }).deepEvery(() => false);              // true\r\n     */\n\n  }, {\n    key: 'deepEvery',\n    value: function deepEvery(callback, n) {\n      if (arguments.length === 1 && !isFunction(callback)) {\n        n = callback;\n        callback = Boolean;\n      } else if (arguments.length === 1) {\n        n = Infinity;\n      } else if (!arguments.length) {\n        n = Infinity;\n        callback = Boolean;\n      }\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepEvery');\n\n      n = Number(n);\n\n      return _deepEvery(this.$, callback, n, [{ key: null, value: this.$ }]);\n    }\n\n    /**\r\n     * @method Super#deepFilter\r\n     * @public\r\n     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy the element is included and if falsey it's excluded.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {DWrap} New D-Wrap of filtered object.\r\n     * @description Returns filtered by the callback object. Deep analogue of {@link Super#filter}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value%2).$;     // { a: 1, b: { d: 3 } }\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value === 1).$; // { a: 1 }\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value > 3).$;   // {}\r\n     */\n\n  }, {\n    key: 'deepFilter',\n    value: function deepFilter(callback, n) {\n      if (arguments.length === 1 && !isFunction(callback)) {\n        n = callback;\n        callback = Boolean;\n      } else if (arguments.length === 1) {\n        n = Infinity;\n      } else if (!arguments.length) {\n        n = Infinity;\n        callback = Boolean;\n      }\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFilter');\n\n      var filtered = _deepFilter(this.$, callback, n, [{ key: null, value: this.$ }]);\n\n      return D$1(isNil(filtered) ? filtered : filtered || {});\n    }\n\n    /**\r\n     * @method Super#deepFind\r\n     * @public\r\n     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy iteration stops and if falsey it continues.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {Tree|null} Tree of { key, value } if something found and null if not.\r\n     * @description Returns tree of the elements if something found and null if nothing found.\r\n     * Deep analogue of {@link Super#find}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFind((value) => value === 2);\r\n     * // [\r\n     * //   { key: 'c', value: 2 },\r\n     * //   { key: 'b', value: { c: 2, d: 3 } },\r\n     * //   { key: null, value: <initial object> }\r\n     * // ]\r\n     */\n\n  }, {\n    key: 'deepFind',\n    value: function deepFind(callback, n) {\n      if (arguments.length === 1 && !isFunction(callback)) {\n        n = callback;\n        callback = Boolean;\n      } else if (arguments.length === 1) {\n        n = Infinity;\n      } else if (!arguments.length) {\n        n = Infinity;\n        callback = Boolean;\n      }\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFind');\n\n      return _deepFind(this.$, callback, n, [{ key: null, value: this.$ }]);\n    }\n\n    /**\r\n     * @method Super#deepForEach\r\n     * @public\r\n     * @param {DeepIterationCallback} callback - Called on each iteration.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;\r\n     * // { a: 1, b: { c: 4, d: 9 } }\r\n     */\n\n  }, {\n    key: 'deepForEach',\n    value: function deepForEach(callback) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');\n\n      n = Number(n);\n\n      _deepForEach(this.$, callback, n, [{ key: null, value: this.$ }]);\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#deepForEach\r\n     * @public\r\n     * @param {DeepIterationCallback} callback - Called on each iteration.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.\r\n     * Unlike {@link Super#deepForEach} the callback is called on every value of every object inside\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;\r\n     * // { a: 1, b: { c: 4, d: 9 } }\r\n     */\n\n  }, {\n    key: 'deepForEachEntry',\n    value: function deepForEachEntry(callback) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');\n\n      n = Number(n);\n\n      _deepForEachEntry(this.$, callback, n, [{ key: null, value: this.$ }]);\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#deepFreeze\r\n     * @public\r\n     * @returns {DWrap} Returns this.\r\n     * @description Deep analogue of {@link Super#freeze}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFreeze(); // Super\r\n     */\n\n  }, {\n    key: 'deepFreeze',\n    value: function deepFreeze() {\n      _deepFreeze(this.$);\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#deepMap\r\n     * @public\r\n     * @param {DeepIterationCallback} callback - Called on each iteration.\r\n     * Return value is used for creating a new object.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {DWrap} D-Wrap of the new object.\r\n     * @description Returns a wrap of a new object using the callback. Deep analogue of {@link Super#map}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepMap((value) => value * value).$;\r\n     * // { a: 1, b: { c: 4, d: 9 } }\r\n     */\n\n  }, {\n    key: 'deepMap',\n    value: function deepMap(callback) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepMap');\n\n      n = Number(n);\n\n      return D$1(_deepMap(this.$, callback, n, [{ key: null, value: this.$ }]));\n    }\n\n    /**\r\n     * @method Super#deepReduce\r\n     * @public\r\n     * @param {DeepReduceCallback} callback - Called on each iteration.\r\n     * Return value is passed to the next callback call.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @param {*} [IV = <first value>|undefined] - Initial value.\r\n     * @returns {*} Modified IV.\r\n     * @description Returns modified IV. Deep analogue of {@link Super#reduce}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepReduce((sum, value) => sum + value * value, Infinity, 0); // 14\r\n     */\n\n  }, {\n    key: 'deepReduce',\n    value: function deepReduce(callback) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n      var IV = arguments[2];\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepReduce');\n\n      n = Number(n);\n\n      var object = this.$;\n      var tree = [{ key: null, value: this.$ }];\n\n      if (arguments.length < 3) {\n        return _deepReduce(object, callback, n, false, undefined, tree).IV;\n      }\n\n      return _deepReduce(object, callback, n, false, { IV: IV }, tree).IV;\n    }\n\n    /**\r\n     * @method Super#deepSome\r\n     * @public\r\n     * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy iteration stops and if falsey it continues.\r\n     * @param {Number} [n = Infinity] - Iteration depth.\r\n     * @returns {Boolean} If all the callback calls returned truthy value.\r\n     * @description Returns true if some of the callback calls returned truthy value.\r\n     * Otherwise false. Deep analogue of {@link Super#some}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: { c: 2, d: 3 } }).deepSome((value) => value > 4); // false\r\n     * new Super({ a: {}, b: {}, c: {} }).deepSome(() => true);               // false\r\n     */\n\n  }, {\n    key: 'deepSome',\n    value: function deepSome(callback, n) {\n      if (arguments.length === 1 && !isFunction(callback)) {\n        n = callback;\n        callback = Boolean;\n      } else if (arguments.length === 1) {\n        n = Infinity;\n      } else if (!arguments.length) {\n        n = Infinity;\n        callback = Boolean;\n      }\n\n      validate$1([callback, n], ['function', ['numberLike', '>0']], 'Super#deepSome');\n\n      n = Number(n);\n\n      return _deepSome(this.$, callback, n, [{ key: null, value: this.$ }]);\n    }\n\n    /**\r\n     * @method Super#deepStrictEquals\r\n     * @public\r\n     * @param {*} [object] - Object to compare to.\r\n     * @returns {Boolean} - If the objects are deep strict equal or not.\r\n     * @description Method for deep strict comparison of two objects.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1 }).deepStrictEquals({ a: '1' }); // false\r\n     * new Super(/1/).deepStrictEquals(/1/);             // true\r\n     */\n\n  }, {\n    key: 'deepStrictEquals',\n    value: function deepStrictEquals() {\n      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return deepEqual(this.$, object, true);\n    }\n\n    /**\r\n     * @method Super#define\r\n     * @param {String|Object} property - Either a string of a property or a descriptors object.\r\n     * @param {Object} [descriptor] - If a property parameter is a string this has to be a property descriptor.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Synonym for both\r\n     * [Object.defineProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty}\r\n     * and\r\n     * [Object.defineProperties]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties}.\r\n     *\r\n     * @example\r\n     * new Super({}).define('a', {\r\n     *   value: 1,\r\n     *   enumerable: false,\r\n     *   writable: true,\r\n     *   configurable: false\r\n     * }).$; // { a: 1 }\r\n     * new Super({}).define({\r\n     *   a: {\r\n     *     value: 1,\r\n     *     enumerable: false,\r\n     *     writable: true,\r\n     *     configurable: false\r\n     *   }\r\n     * }).$; // { a: 1 }\r\n     */\n\n  }, {\n    key: 'define',\n    value: function define(property, descriptor) {\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, descriptor);\n      }\n\n      property = new Super(property).$;\n\n      if (isObject(this.$)) {\n        Object.defineProperties(this.$, property);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#delete\r\n     * @public\r\n     * @param {...String} props - List of properties to delete.\r\n     * @returns {DWrap} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete\r\n     * @description Synonym for multiple\r\n     * [\"delete\" operator]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).delete('c', 'a').$; // { b: 2 }\r\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      var object = this.$;\n\n      for (var _len4 = arguments.length, props = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        props[_key4] = arguments[_key4];\n      }\n\n      iterate(object && props, function (property) {\n        delete object[property];\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#equals\r\n     * @public\r\n     * @param {*} [object] - Object to compare.\r\n     * @returns {Boolean} If the objects are equal or not.\r\n     * @description Returns true if objects are equal using '==' operator and false if not. NaNs are considered to be equal.\r\n     *\r\n     * @example\r\n     * new Super(3).equals('3');   // true\r\n     * new Super(NaN).equals(NaN); // true\r\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(object) {\n      var o = this.$;\n\n      object = new Super(object).$;\n\n      /* eslint eqeqeq: 0 */\n      return o == object || isNaN(o) && isNaN(object);\n    }\n\n    /**\r\n     * @method Super#every\r\n     * @public\r\n     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy iteration goes on and if falsey it stops.\r\n     * @returns {Boolean} If all the callback calls returned truthy value.\r\n     * @description Returns boolean if all the callback calls returned truthy value.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).every((value) => value < 4); // true\r\n     * new Super({}).every(() => false);                            // true\r\n     */\n\n  }, {\n    key: 'every',\n    value: function every() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;\n\n      validate$1([callback], ['function'], 'Super#every');\n\n      return iterate(this.$, function (value, key, object) {\n        if (!callback(value, key, object)) {\n          return false;\n        }\n      }) !== false;\n    }\n\n    /**\r\n     * @method Super#filter\r\n     * @public\r\n     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy the element is included and if falsey it's excluded.\r\n     * @returns {DWrap} New D-Wrap of filtered object.\r\n     * @description Returns filtered by the callback object.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).filter((value) => value%2).$; // { a: 1, c: 3 }\r\n     * new Super(null).filter((value) => value%2).$;                 // null\r\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;\n\n      validate$1([callback], ['function'], 'Super#filter');\n\n      var object = this.$;\n      var array = isArrayLike(object);\n\n      /* eslint no-nested-ternary: 0 */\n      var o = array ? [] : isNil(object) ? object : {};\n\n      iterate(object, function (value, key) {\n        if (callback(value, key, object)) {\n          if (array) {\n            o.push(value);\n          } else {\n            o[key] = value;\n          }\n        }\n      });\n\n      return D$1(o);\n    }\n\n    /**\r\n     * @method Super#find\r\n     * @public\r\n     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy iteration stops and if falsey it continues.\r\n     * @returns {{ key: Key, value: * }|null} { key, value } if found and null if not.\r\n     * @description Returns found { key, value } if something found and null if nothing found.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).find((value) => value === 2); // { key: 'b', value: 2 }\r\n     * new Super([1, 2, 3]).find((value) => value === 2);            // { key: 1, value: 2 }\r\n     */\n\n  }, {\n    key: 'find',\n    value: function find(callback) {\n      validate$1([callback], ['function'], 'Super#find');\n\n      return iterate(this.$, function (value, key, object) {\n        if (callback(value, key, object)) {\n          return { key: key, value: value };\n        }\n      }) || null;\n    }\n\n    /**\r\n     * @method Super#forEach\r\n     * @public\r\n     * @param {IterationCallback} callback - Called on each iteration.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Method for iterating over any object.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).forEach((value, key, object) => {\r\n     *   object[key] = value * value;\r\n     * }).$; // { a: 1, b: { c: 4, d: 5 } }\r\n     */\n\n  }, {\n    key: 'forEach',\n    value: function forEach(callback) {\n      validate$1([callback], ['function'], 'Super#forEach');\n\n      iterate(this.$, function (value, key, object) {\n        callback(value, key, object);\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#freeze\r\n     * @public\r\n     * @returns {DWrap} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\r\n     * @description Synonym for\r\n     * [Object.freeze]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).freeze(); // Super\r\n     */\n\n  }, {\n    key: 'freeze',\n    value: function freeze() {\n      Object.freeze(this.$);\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#get\r\n     * @public\r\n     * @param {String|Object.<String, Function>} property - Either a string of a property or a getters object.\r\n     * @param {Function} [getter] - If a property parameter is a string this has to be a getter function.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Method for defining getters.\r\n     *\r\n     * @example\r\n     * const object1 = new Super({}).get('a', () => 1).$;\r\n     * object1.a; // 1\r\n     *\r\n     * const object2 = new Super({}).get({\r\n     *   a: () => 2\r\n     * }).$;\r\n     * object2.a; // 2\r\n     */\n\n  }, {\n    key: 'get',\n    value: function get(property, getter) {\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, getter);\n      }\n\n      var object = this.$;\n\n      iterate(isObject(object) && new Super(property).$, function (getter, property) {\n        Object.defineProperty(object, property, { get: getter });\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#has\r\n     * @public\r\n     * @param {String|*} key - Property to check.\r\n     * @returns {Boolean} Returns true if the object has the key and false if not.\r\n     * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in\r\n     * @description Synonym for\r\n     * [\"in\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).has('b'); // true\r\n     */\n\n  }, {\n    key: 'has',\n    value: function has(key) {\n      var object = this.$;\n\n      if (!isObject(object)) {\n        return false;\n      }\n\n      return key in object;\n    }\n\n    /**\r\n     * @method Super#hasOwn\r\n     * @public\r\n     * @param {String|*} key - Property to check.\r\n     * @returns {Boolean} Returns true if the object has its own key and false if not.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\r\n     * @description Synonym for\r\n     * [Object#hasOwnProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).hasOwn('b');              // true\r\n     * new Super({ a: 1, b: 2, c: 3 }).hasOwn('hasOwnProperty'); // false\r\n     */\n\n  }, {\n    key: 'hasOwn',\n    value: function hasOwn(key) {\n      var object = this.$;\n\n      if (!isObject(object)) {\n        return false;\n      }\n\n      return {}.hasOwnProperty.call(object, key);\n    }\n\n    /**\r\n     * @method Super#instanceof\r\n     * @public\r\n     * @param {Function} constructor - Constructor to check.\r\n     * @returns {Boolean} If the object is an instance of constructor.\r\n     * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof\r\n     * @description Synonym for\r\n     * [\"instanceof\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}.\r\n     */\n\n  }, {\n    key: 'instanceof',\n    value: function _instanceof(constructor) {\n      return this.$ instanceof constructor;\n    }\n\n    /**\r\n     * @method Super#isFrozen\r\n     * @public\r\n     * @returns {Boolean} If the object is frozen.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\r\n     * @description Synonym for\r\n     * [Object.isFrozen]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen}.\r\n     *\r\n     * @example\r\n     * new Super({}).freeze().isFrozen(); // true\r\n     */\n\n  }, {\n    key: 'isFrozen',\n    value: function isFrozen() {\n      return Object.isFrozen(this.$);\n    }\n\n    /**\r\n     * @method Super#json\r\n     * @public\r\n     * @param {JSONCallback|String[]} [replacer] - See the link.\r\n     * @param {String|Number} [space] - See the link.\r\n     * @returns {String} JSON string.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\r\n     * @description Synonym for\r\n     * [JSON.stringify]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).json(); // '{\"a\":1,\"b\":2,\"c\":3}'\r\n     * new Super({ a: 1, b: 2, c: 3 }).json('    ');\r\n     * // {\r\n     * //     \"a\": 1,\r\n     * //     \"b\": 2,\r\n     * //     \"c\": 3\r\n     * // }\r\n     * new Super({ a: 1, b: 2, c: 3 }).json((key, value) => {\r\n     *   if (typeof value === 'number') {\r\n     *     return value%2 ? key + value0 : undefined;\r\n     *   }\r\n     *\r\n     *   return value;\r\n     * }, 2);\r\n     * // {\r\n     * //   \"a\": \"a1\",\r\n     * //   \"c\": \"c3\"\r\n     * // }\r\n     */\n\n  }, {\n    key: 'json',\n    value: function json(replacer, space) {\n      if (arguments.length === 1 && !isFunction(replacer) && !isArray(replacer)) {\n        [].unshift.call(arguments, null);\n      }\n\n      [].unshift.call(arguments, this.$);\n\n      return JSON.stringify.apply(JSON, arguments);\n    }\n\n    /**\r\n     * @method Super#keyOf\r\n     * @public\r\n     * @param {*} value - Value to find.\r\n     * @returns {String|Number|null} A key or an index if found and null if not.\r\n     * @description Method for finding equal to the argument value in the object. NaNs are considered to be equal.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).keyOf(2);   // 'b'\r\n     * new Super({ a: 1, b: 2, c: 3 }).keyOf('2'); // 'b'\r\n     */\n\n  }, {\n    key: 'keyOf',\n    value: function keyOf(value) {\n      var key = iterate(this.$, function (val, key) {\n        if (val == value || isNaN(val) && isNaN(value)) {\n          return key;\n        }\n      });\n\n      return isUndefined(key) ? null : key;\n    }\n\n    /**\r\n     * @method Super#keyOfStrict\r\n     * @public\r\n     * @param {*} value - Value to find.\r\n     * @returns {String|Number|null} A key or an index if found and null if not.\r\n     * @description Method for finding strict equal to the argument value in the object. NaNs are considered to be equal.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict(2);   // 'b'\r\n     * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict('2'); // 'b'\r\n     */\n\n  }, {\n    key: 'keyOfStrict',\n    value: function keyOfStrict(value) {\n      var key = iterate(this.$, function (val, key) {\n        if (val === value || isNaN(val) && isNaN(value)) {\n          return key;\n        }\n      });\n\n      return isUndefined(key) ? null : key;\n    }\n\n    /**\r\n     * @method Super#keys\r\n     * @public\r\n     * @returns {DWrap} A wrap of the keys array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\r\n     * @description Synonym for\r\n     * [Object.keys]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).keys().$; // ['a', 'b', 'c']\r\n     * new Super(null).keys().$;                 // []\r\n     */\n\n  }, {\n    key: 'keys',\n    value: function keys() {\n      var object = this.$;\n\n      return D$1(isObject(object) ? Object.keys(object) : []);\n    }\n\n    /**\r\n     * @method Super#map\r\n     * @public\r\n     * @param {IterationCallback} callback - Called on each iteration.\r\n     * Return value is used for creating a new object.\r\n     * @returns {DWrap} D-Wrap of the new object.\r\n     * @description Returns a wrap of a new object using the callback.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).map((value) => value * 2).$; // { a: 2, b: 4, c: 6 }\r\n     * new Super(null).map((value) => value * 2).$;                 // null\r\n     */\n\n  }, {\n    key: 'map',\n    value: function map(callback) {\n      validate$1([callback], ['function'], 'Super#map');\n\n      var object = this.$;\n      var o = isArrayLike(object) ? [] : isNull(object) ? null : {};\n\n      iterate(object, function (value, key) {\n        o[key] = callback(value, key, object);\n      });\n\n      return D$1(o);\n    }\n\n    /**\r\n     * @method Super#max\r\n     * @public\r\n     * @param {IterationCallback} callback - Called on each iteration.\r\n     * Return value is used for comparison with the previous max value.\r\n     * @returns {{key: Key, value: Number}} Object with max value and key of the max value.\r\n     * @description Method for finding max value in the object.\r\n     * If no callback is present comparison is between values of the object.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).max();                     // { key: 'c', value: 3 }\r\n     * new Super({ a: 1, b: 2, c: 3 }).max((value) => 4 - value); // { key: 'a', value: 3 }\r\n     * new Super({ a: 'a', b: 'b', c: 'c' }).max();               // { key: null, value: -Infinity }\r\n     */\n\n  }, {\n    key: 'max',\n    value: function max() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      validate$1([callback], ['function||!'], 'Super#max');\n\n      return this.object(function (max, value, key, object) {\n        var val = Number(callback ? callback(value, key, object) : value);\n\n        if (val > max.value) {\n          max.key = key;\n          max.value = val;\n        }\n      }, { key: null, value: -Infinity }).$;\n    }\n\n    /**\r\n     * @method Super#min\r\n     * @public\r\n     * @param {IterationCallback} callback - Called on each iteration.\r\n     * Return value is used for comparison with the previous min value.\r\n     * @returns {{key: Key, value: Number}} Object with min value and key of the min value.\r\n     * @description Method for finding min value in the object.\r\n     * If no callback is present comparison is between values of the object.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).min();                     // { key: 'a', value: 1 }\r\n     * new Super({ a: 1, b: 2, c: 3 }).min((value) => 4 - value); // { key: 'c', value: 1 }\r\n     * new Super({ a: 'a', b: 'b', c: 'c' }).min();               // { key: null, value: Infinity }\r\n     */\n\n  }, {\n    key: 'min',\n    value: function min() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      validate$1([callback], ['function||!'], 'Super#min');\n\n      return this.object(function (min, value, key, object) {\n        var val = Number(callback ? callback(value, key, object) : value);\n\n        if (val < min.value) {\n          min.key = key;\n          min.value = val;\n        }\n      }, { key: null, value: Infinity }).$;\n    }\n\n    /**\r\n     * @method Super#object\r\n     * @public\r\n     * @param {ObjectCallback} callback - Called on each iteration.\r\n     * @param {Object|*} [object = {}] - Object that is passed to the callback.\r\n     * @returns {DWrap} Wrap of the new object.\r\n     * @description Type of {@link Super#reduce}.\r\n     * The object is passed as an argument into the callback. The output is this object.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2 }).object((object, value, key) => {\r\n     *   object[key] = value;\r\n     *   object[key + key] = value * 2;\r\n     * }).$; // { a: 1, aa: 2, b: 2, bb: 4 }\r\n     */\n\n  }, {\n    key: 'object',\n    value: function object(callback) {\n      var _object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      validate$1([callback], ['function'], 'Super#object');\n\n      iterate(this.$, function (value, key, obj) {\n        callback(_object, value, key, obj);\n      });\n\n      return D$1(_object);\n    }\n\n    /**\r\n     * @method Super#prop\r\n     * @public\r\n     * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\r\n     * @param {*} [value] - If a property parameter is a string\r\n     * this has to be an assigned value if it's present.\r\n     * @returns {DWrap|*} Returns this if it's a setter or a value if getter.\r\n     * @description Method for getting and setting properties.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).prop('a');              // 1\r\n     * new Super({ a: 1, b: 2, c: 3 }).prop('a', 7).$;         // { a: 7, b: 2, c: 3 }\r\n     * new Super({ a: 1, b: 2, c: 3 }).prop({ a: 7, b: 8 }).$; // { a: 7, b: 8, c: 3 }\r\n     */\n\n  }, {\n    key: 'prop',\n    value: function prop(property, value) {\n      if (arguments.length <= 1 && isString(property)) {\n        return this.$ ? this.$[property] : undefined;\n      }\n\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, value);\n      }\n\n      return this.assign(property);\n    }\n\n    /**\r\n     * @method Super#propertyDescriptor\r\n     * @public\r\n     * @param {String} property - Property of the object.\r\n     * @returns {Object|undefined} Property descriptor.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\r\n     * @descriptor Synonym for\r\n     * [Object.getOwnPropertyDescriptor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1 }).propertyDescriptor('a');\r\n     * // {\r\n     * //   value: 1,\r\n     * //   enumerable: true,\r\n     * //   writable: true,\r\n     * //   configurable: true\r\n     * // }\r\n     */\n\n  }, {\n    key: 'propertyDescriptor',\n    value: function propertyDescriptor(property) {\n      var object = this.$;\n\n      return isObject(object) ? Object.getOwnPropertyDescriptor(object, property) : undefined;\n    }\n\n    /**\r\n     * @method Super#propertyNames\r\n     * @public\r\n     * @returns {DWrap} D-Wrap of the names array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\r\n     * @descriptor Synonym for\r\n     * [Object.getOwnPropertyNames]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames}.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2 }).define('c', { value: 3 }).$; // ['a', 'b', 'c']\r\n     */\n\n  }, {\n    key: 'propertyNames',\n    value: function propertyNames() {\n      var object = this.$;\n\n      return D$1(isObject(object) ? Object.getOwnPropertyNames(object) : []);\n    }\n\n    /**\r\n     * @method Super#propertySymbols\r\n     * @public\r\n     * @returns {DWrap} D-Wrap of the names array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\r\n     * @descriptor Synonym for\r\n     * [Object.getOwnPropertySymbols]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols}.\r\n     *\r\n     * @example\r\n     * new Super({ [Symbol('foo')]: 1 }).define(Symbol('bar'), { value: 2 }).$; // [Symbol('foo'), Symbol('bar')]\r\n     */\n\n  }, {\n    key: 'propertySymbols',\n    value: function propertySymbols() {\n      var object = this.$;\n\n      return D$1(isObject(object) ? Object.getOwnPropertySymbols(object) : []);\n    }\n\n    /**\r\n     * @method Super#proto\r\n     * @public\r\n     * @param {*} [proto] - If it's present it's set as a prototype to the object.\r\n     * @returns {DWrap} In getter mode returns wrap of the prototype and in setter mode returns this.\r\n     * @description Synonym for both\r\n     * [Object.getPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf}\r\n     * and\r\n     * [Object.setPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf}.\r\n     */\n\n  }, {\n    key: 'proto',\n    value: function proto(_proto) {\n      var object = this.$;\n      var isContextObject = !isNil(object);\n\n      if (arguments.length) {\n        if (isContextObject && (isObject(_proto) || isNull(_proto))) {\n          Object.setPrototypeOf(object, _proto);\n        }\n\n        return this;\n      }\n\n      return isContextObject ? new Super(Object.getPrototypeOf(object)) : new Super();\n    }\n\n    /**\r\n     * @method Super#reduce\r\n     * @public\r\n     * @param {ReduceCallback} callback - Called on each iteration.\r\n     * Return value is passed to the next callback call.\r\n     * @param {*} [IV = <first value>|undefined] - Initial value.\r\n     * @returns {*} Modified IV.\r\n     * @description Returns modified IV. If the second argument is not present first value in the object is taken\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).reduce((sum, value) => sum + value * value, 0); // 14\r\n     */\n\n  }, {\n    key: 'reduce',\n    value: function reduce(callback, IV) {\n      validate$1([callback], ['function'], 'Super#reduce');\n\n      var object = this.$;\n\n      var startKey = void 0;\n\n      if (arguments.length === 1) {\n        iterate(object, function (value, key) {\n          startKey = key;\n          IV = value;\n\n          return true;\n        });\n      }\n\n      iterate(object, function (value, key) {\n        if (key !== startKey) {\n          IV = callback(IV, value, key, object);\n        }\n      });\n\n      return IV;\n    }\n\n    /**\r\n     * @method Super#set\r\n     * @public\r\n     * @param {String|Object.<String, Function>} property - Either a string of a property or a setters object.\r\n     * @param {Function} [setter] - If a property parameter is a string this has to be a setter function.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Method for defining setters.\r\n     *\r\n     * @example\r\n     * const object = new Super({})\r\n     *   .get('public', function () {\r\n     *     return this._private;\r\n     *   })\r\n     *   .set('public', function (value) {\r\n     *     if (typeof value === 'number') {\r\n     *       this._private = value;\r\n     *     }\r\n     *   });\r\n     * object.prop('public', '1').$; // { public: undefined }\r\n     * object.prop('public', 1).$;   // { public: 1, _private: 1 }\r\n     *\r\n     * new Super({}).set({\r\n     *   public(value) {\r\n     *     if (typeof value === 'number') {\r\n     *       this._private = value;\r\n     *     }\r\n     *   }\r\n     * });\r\n     */\n\n  }, {\n    key: 'set',\n    value: function set(property, setter) {\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, setter);\n      }\n\n      var object = this.$;\n\n      iterate(isObject(object) && new Super(property).$, function (setter, property) {\n        Object.defineProperty(object, property, { set: setter });\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#some\r\n     * @public\r\n     * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n     * If returns truthy iteration stops and if falsey it continues.\r\n     * @returns {Boolean} If all the callback calls returned truthy value.\r\n     * @description Returns true if some of the callback calls returned truthy value. Otherwise false.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).some((value) => value > 4); // false\r\n     * new Super({}).some(() => true);                             // false\r\n     */\n\n  }, {\n    key: 'some',\n    value: function some() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;\n\n      validate$1([callback], ['function'], 'Super#some');\n\n      return iterate(this.$, function (value, key, object) {\n        if (callback(value, key, object)) {\n          return true;\n        }\n      }) || false;\n    }\n\n    /**\r\n     * @method Super#strictEquals\r\n     * @public\r\n     * @param {*} [object] - Object to compare.\r\n     * @returns {Boolean} If the objects are equal or not.\r\n     * @description Returns true if objects are equal using '===' operator and false if not.\r\n     * NaNs are considered to be strict equal.\r\n     *\r\n     * @example\r\n     * new Super(3).strictEquals('3');   // false\r\n     * new Super(NaN).strictEquals(NaN); // true\r\n     */\n\n  }, {\n    key: 'strictEquals',\n    value: function strictEquals(object) {\n      var o = this.$;\n\n      object = new Super(object).$;\n\n      return o === object || isNaN(o) && isNaN(object);\n    }\n\n    /**\r\n     * @method Super#sum\r\n     * @public\r\n     * @param {IterationCallback} [callback = null] - Called on each iteration.\r\n     * @returns {Number} Sum.\r\n     * @description Type of {@link Super#reduce}.\r\n     * If the callback is present it's used for summing. If not the value is used.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).sum();                         // 6\r\n     * new Super({ a: 1, b: 2, c: 3 }).sum((value) => value * value); // 14\r\n     */\n\n  }, {\n    key: 'sum',\n    value: function sum() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      validate$1([callback], ['function||!'], 'Super#sum');\n\n      return this.reduce(function (sum, value, key, object) {\n        return sum + Number(callback ? callback(value, key, object) : value);\n      }, 0);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.$;\n    }\n\n    /**\r\n     * @member Super#toStringTag\r\n     * @type {String}\r\n     * @public\r\n     * @readonly\r\n     * @description Returns toString tag of the object.\r\n     *\r\n     * @example\r\n     * new Super({}).toStringTag; // 'Object'\r\n     * new Super([]).toStringTag; // 'Array'\r\n     * new Super(1).toStringTag;  // 'Number'\r\n     */\n\n  }, {\n    key: 'value',\n\n\n    /**\r\n     * @method Super#value\r\n     * @public\r\n     * @param {String|Object.<String, *>} property - Either a string of a property or a values object.\r\n     * @param {Object.<String, *>} [value] - If a property parameter is a string this has to be a value to be set.\r\n     * @returns {DWrap} Returns this.\r\n     * @description Method for defining non-enumerable, non-writable, non-configurable values.\r\n     * Synonym for object.define(property, { value: value }).\r\n     *\r\n     * @example\r\n     * new Super({}).value('a', 1).$; // { a: 1 }\r\n     * new Super({}).value({\r\n     *   a: 1\r\n     * }).$;                          // { a: 1 }\r\n     */\n    value: function value(property, _value) {\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, _value);\n      }\n\n      var object = this.$;\n\n      iterate(isObject(object) && new Super(property).$, function (value, property) {\n        Object.defineProperty(object, property, { value: value });\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Super#values\r\n     * @public\r\n     * @returns {DWrap} A wrap of the values array.\r\n     * @description Returns D-Wrap of the values array.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).values().$; // [1, 2, 3]\r\n     * new Super(null).values().$;                 // []\r\n     */\n\n  }, {\n    key: 'values',\n    value: function values() {\n      var array = [];\n\n      iterate(this.$, function (value) {\n        array.push(value);\n      });\n\n      return D$1(array);\n    }\n\n    /**\r\n     * @method Super#word\r\n     * @public\r\n     * @param {IterationCallback} callback - Called on each iteration.\r\n     * @returns {String} Concatenated string.\r\n     * @description Type of {@link Super#reduce}.\r\n     * If the callback is present it's used for concatenating. If not the value is used.\r\n     *\r\n     * @example\r\n     * new Super({ a: 1, b: 2, c: 3 }).word();                         // '123'\r\n     * new Super({ a: 1, b: 2, c: 3 }).word((value) => value + value); // '112233'\r\n     */\n\n  }, {\n    key: 'word',\n    value: function word() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      validate$1([callback], ['function||!'], 'Super#word');\n\n      return this.reduce(function (word, value, key, object) {\n        return word + String(callback ? callback(value, key, object) : value);\n      }, '');\n    }\n  }, {\n    key: 'count',\n    get: function get() {\n      var object = this.$;\n\n      if (!isObject(object)) {\n        return 0;\n      }\n\n      return isArrayLike(object) ? object.length : Object.keys(object).length;\n    }\n  }, {\n    key: 'toStringTag',\n    get: function get() {\n      return toStringTag(this.$);\n    }\n\n    /**\r\n     * @member Super#type\r\n     * @type {String}\r\n     * @public\r\n     * @readonly\r\n     * @description Synonym for\r\n     * [\"typeof\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}..\r\n     *\r\n     * @example\r\n     * new Super({}).type;   // 'object'\r\n     * new Super(1).type;    // 'number'\r\n     * new Super('1').type;  // 'string'\r\n     * new Super(true).type; // 'boolean'\r\n     */\n\n  }, {\n    key: 'type',\n    get: function get() {\n      return _typeof(this.$);\n    }\n  }], [{\n    key: 'addStaticProperties',\n    value: function addStaticProperties(property, value) {\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, value);\n      }\n\n      defineProperties(this, property);\n\n      return this;\n    }\n\n    /**\r\n     * @method Super.addInstanceProperties\r\n     * @public\r\n     * @param {String|Object} property - Either a string of a property or an object\r\n     * with properties keys and values values.\r\n     * @param {Object} [value] - If a property parameter is a string this has to be a property value.\r\n     * @returns {this} Returns this.\r\n     * @description Sets static properties for DWrap prototypes.\r\n     *\r\n     * @example\r\n     * Super.addInstanceProperties('cool', 42);\r\n     * Super.addInstanceProperties('superCool', 42*42);\r\n     */\n\n  }, {\n    key: 'addInstanceProperties',\n    value: function addInstanceProperties(property, value) {\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, value);\n      }\n\n      defineProperties(this.prototype, property);\n\n      return this;\n    }\n  }]);\n  return Super;\n}();\n\ndefineProperties(Super.prototype, defineProperty({}, _Symbol.toStringTag, 'Super'));\n\n/**\r\n * @function deepAssign\r\n * @private\r\n * @param {*} target - Object to assign properties to.\r\n * @param {*} object - Object to assign properties from.\r\n * @returns {void}\r\n */\nfunction _deepAssign(target, object) {\n  iterate(object, function (value, key) {\n    if (isPrimitive(target[key]) || !{}.hasOwnProperty.call(target, key)) {\n      target[key] = _deepClone(value);\n\n      return;\n    }\n\n    if (!isPrimitive(target[key])) {\n      _deepAssign(target[key], value);\n    }\n  });\n}\n\n/**\r\n * @function deepClone\r\n * @private\r\n * @param {*} object - Object to clone.\r\n * @description Does the deep cloning.\r\n */\nfunction _deepClone(object) {\n  var clone = cloneSwitcher(object, [object, true]);\n\n  if (clone !== object) {\n    iterate(object, function (value, key) {\n      clone[key] = _deepClone(value);\n    });\n  }\n\n  return clone;\n}\n\n/**\r\n * @function deepEqual\r\n * @private\r\n * @param {*} o1 - First object to compare.\r\n * @param {*} o2 - Second object to compare.\r\n * @param {Boolean} strict - If comparison should be strict or not.\r\n * @returns {Boolean} - If the object are deep equal or not.\r\n */\nfunction deepEqual(o1, o2, strict) {\n  if (o1 === o2) {\n    return true;\n  }\n\n  if (isNaN(o1) && isNaN(o2) && isPrimitive(o1) && isPrimitive(o2)) {\n    return true;\n  }\n\n  if (isNaN(o1) || isNaN(o2)) {\n    return false;\n  }\n\n  if (isPrimitive(o1) || isPrimitive(o2)) {\n    return strict ? o1 === o2 : o1 == o2;\n  }\n\n  if (isDate(o1) && isDate(o2)) {\n    return o1.getTime() === o2.getTime();\n  }\n\n  if (isDate(o1) || isDate(o2)) {\n    return false;\n  }\n\n  if (isRegExp(o1) && isRegExp(o2)) {\n    return o1.source === o2.source && o1.toString().match(/[gimuy]*$/)[0] === o2.toString().match(/[gimuy]*$/)[0] && o1.lastIndex === o2.lastIndex;\n  }\n\n  if (isRegExp(o1) || isRegExp(o2)) {\n    return false;\n  }\n\n  if (!isPlainObject(o1) && !isArray(o1) || !isPlainObject(o2) && !isArray(o2)) {\n    return false;\n  }\n\n  var p1 = Object.getPrototypeOf(o1);\n  var p2 = Object.getPrototypeOf(o1);\n\n  if (Object.keys(o1).length !== Object.keys(o2).length) {\n    return false;\n  }\n\n  if (p1 && p2 && toStringTag(p1.constructor) !== toStringTag(p2.constructor)) {\n    return false;\n  }\n\n  return iterate(o1, function (value, key) {\n    if (!(key in o2) || !deepEqual(value, o2[key], strict)) {\n      return false;\n    }\n  }) !== false;\n}\n\n/**\r\n * @function deepEvery\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the iteration goes on and if not it stops.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {Boolean} - If all the callback calls returned truthy value.\r\n */\nfunction _deepEvery(object, callback, n, tree) {\n  var end = n === 1;\n\n  return iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    if (end || isPrimitive(value) ? !callback(value, key, object, newTree) : !_deepEvery(value, callback, n - 1, newTree)) {\n      return false;\n    }\n  }) !== false;\n}\n\n/**\r\n * @function deepFilter\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the element is included in the output and if not it's excluded.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {*} Filtered object.\r\n */\nfunction _deepFilter(object, callback, n, tree) {\n  var array = isArrayLike(object);\n  var nul = isNil(object);\n  var o = array ? [] : nul ? object : {};\n  var end = n === 1;\n\n  iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    if ((end || isPrimitive(value)) && callback(value, key, object, newTree)) {\n      if (array) {\n        o.push(value);\n      } else {\n        o[key] = value;\n      }\n\n      return;\n    }\n\n    if (!end) {\n      var filtered = _deepFilter(value, callback, n - 1, newTree);\n\n      if (filtered) {\n        if (array) {\n          o.push(filtered);\n        } else {\n          o[key] = filtered;\n        }\n      }\n    }\n  });\n\n  if (array) {\n    return o.length ? o : undefined;\n  }\n\n  if (!nul) {\n    return Object.keys(o).length ? o : undefined;\n  }\n\n  return o;\n}\n\n/**\r\n * @function deepFind\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the iteration stops and if not it continues.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {Tree|null} - If found the whole tree is returned and if not it's null what's returned.\r\n */\nfunction _deepFind(object, callback, n, tree) {\n  var end = n === 1;\n\n  return iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    if (end || isPrimitive(value)) {\n      if (callback(value, key, object, newTree)) {\n        return newTree;\n      }\n\n      return;\n    }\n\n    var result = _deepFind(value, callback, n - 1, newTree);\n\n    if (result) {\n      return result;\n    }\n  }) || null;\n}\n\n/**\r\n * @function deepForEach\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {void}\r\n */\nfunction _deepForEach(object, callback, n, tree) {\n  var end = n === 1;\n\n  iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    if (end || isPrimitive(value)) {\n      callback(value, key, object, newTree);\n    } else {\n      _deepForEach(value, callback, n - 1, newTree);\n    }\n  });\n}\n\n/**\r\n * @function deepForEachEntry\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {void}\r\n */\nfunction _deepForEachEntry(object, callback, n, tree) {\n  var end = n === 1;\n\n  iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    callback(value, key, object, newTree);\n\n    if (!end && !isPrimitive(value)) {\n      _deepForEachEntry(value, callback, n - 1, newTree);\n    }\n  });\n}\n\n/**\r\n * @function deepFreeze\r\n * @private\r\n * @param {*} object - Object to freeze.\r\n * @returns {void}\r\n */\nfunction _deepFreeze(object) {\n  Object.freeze(object);\n  iterate(object, _deepFreeze);\n}\n\n/**\r\n * @function deepMap\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * Returned value is used to create to new object.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {*} New object.\r\n */\nfunction _deepMap(object, callback, n, tree) {\n  var o = isArrayLike(object) ? [] : isNil(object) ? object : {};\n  var end = n === 1;\n\n  iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    o[key] = end || isPrimitive(value) ? callback(value, key, object, newTree) : _deepMap(value, callback, n - 1, newTree);\n  });\n\n  return o;\n}\n\n/**\r\n * @function deepReduce\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepReduceCallback} callback - Callback that is called on every element.\r\n * Returned value is used to create to new object.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Boolean} start - If callback was called already or not.\r\n * @param {{ IV: * }|undefined} IV - If callback was called already or not.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {{ IV: * }} Transformed IV.\r\n */\nfunction _deepReduce(object, callback, n, start, IV, tree) {\n  var end = n === 1;\n\n  iterate(object, function (value, key, object) {\n    if (!IV && (end || isPrimitive(value)) && !start) {\n      IV = { IV: value };\n      start = true;\n\n      return;\n    }\n\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    IV = end || isPrimitive(value) ? { IV: callback(IV.IV, value, key, object, newTree) } : _deepReduce(value, callback, n - 1, start, IV, newTree);\n  });\n\n  return IV;\n}\n\n/**\r\n * @function deepSome\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the iteration stops and if not it continues.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {Boolean} - If some of the callback calls returned truthy value.\r\n */\nfunction _deepSome(object, callback, n, tree) {\n  var end = n === 1;\n\n  return iterate(object, function (value, key, object) {\n    var newTree = [{ key: key, value: value }].concat(tree);\n\n    if (end || isPrimitive(value) ? callback(value, key, object, newTree) : _deepSome(value, callback, n - 1, newTree)) {\n      return true;\n    }\n  }) || false;\n}\n\nconstructors[0].push({\n  check: function check() {\n    return true;\n  },\n  cls: Super\n});\n\n/**\r\n * @module Arr\r\n * @private\r\n * @mixin\r\n * @description Exports Arr class.\r\n */\n\n/**\r\n * @typedef {Array|*} ArrayLike\r\n * @public\r\n * @description Array-like type.\r\n */\n\n/**\r\n * @callback ArrayCallback\r\n * @public\r\n * @param {Number} i - Iteration index.\r\n */\n\n/**\r\n * @callback IterateCallback\r\n * @public\r\n * @param {Number} i - Iteration index.\r\n */\n\n/**\r\n * @callback CompareFunction\r\n * @public\r\n * @param {*} x - First value to be compared.\r\n * @param {*} y - Second value to be compared.\r\n */\n\n/**\r\n * @class Arr\r\n * @extends Super\r\n * @public\r\n * @param {Array} [array = []] - An array to wrap.\r\n * @returns {Arr} Instance of Arr.\r\n * @description Wrap of an array.\r\n *\r\n * @example\r\n * new Arr([1, 2]);\r\n */\n\nvar Arr = function (_Super) {\n  inherits(Arr, _Super);\n\n  function Arr() {\n    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, Arr);\n    return possibleConstructorReturn(this, (Arr.__proto__ || Object.getPrototypeOf(Arr)).call(this, toArray$1(array instanceof Arr ? array.$ : array)));\n\n    /**\r\n     * @member Arr#$\r\n     * @type {Array}\r\n     * @public\r\n     * @description Made array.\r\n     */\n  }\n\n  /**\r\n   * @method Arr#concat\r\n   * @public\r\n   * @param {...(Array|Arr|*)} values - Arrays or any other values to concat the array with.\r\n   * @returns {Arr} New instance of Arr.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\r\n   * @description Synonym for\r\n   * [Array#concat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat}.\r\n   */\n\n\n  createClass(Arr, [{\n    key: 'concat',\n    value: function concat() {\n      for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      var array = toArray$1(this.$, true);\n\n      iterate(arguments, function (value) {\n        value = new Super(value).$;\n\n        if (isArrayLike(value) && !isString(value)) {\n          iterate(value, function (value) {\n            array.push(value);\n          });\n\n          return;\n        }\n\n        array.push(value);\n      });\n\n      return new this.constructor(array);\n    }\n\n    /**\r\n     * @member Arr#first\r\n     * @type {*}\r\n     * @public\r\n     * @readonly\r\n     * @description Returns the first element of the array.\r\n     *\r\n     * @example\r\n     * new Arr([1, 2, 3]).first; // 1\r\n     * new Arr([]).first;        // undefined\r\n     */\n\n  }, {\n    key: 'indexOf',\n\n\n    /**\r\n     * @method Arr#indexOf\r\n     * @public\r\n     * @param {*} value - Value to search.\r\n     * @returns {Number} Index of the argument.\r\n     * @description Almost the same as {@link Super#keyOf}. The difference is that if the value is not found\r\n     * -1 returned instead of null and if found Number(key) returned.\r\n     *\r\n     * @example\r\n     * new Arr([1, 2, 3]).indexOf(1);       // 0\r\n     * new Arr([1, 2, 3]).indexOf('1');     // 0\r\n     * new Arr([1, 2, 3]).indexOf(3);       // -1\r\n     * new Arr([1, 2, NaN]).indexOf(NaN);   // 2\r\n     */\n    value: function indexOf(value) {\n      var key = this.keyOf(value);\n\n      return key === null ? -1 : Number(key);\n    }\n\n    /**\r\n     * @method Arr#indexOfStrict\r\n     * @public\r\n     * @param {*} value - Value to search.\r\n     * @returns {Number} Index of the argument.\r\n     * @description Almost the same as {@link Super#keyOfStrict}. The difference is that if the value is not found\r\n     * -1 returned instead of null and if found Number(key) returned.\r\n     *\r\n     * @example\r\n     * new Arr([1, 2, 3]).indexOfStrict(1);       // 0\r\n     * new Arr([1, 2, 3]).indexOfStrict('1');     // -1\r\n     * new Arr([1, 2, 3]).indexOfStrict(3);       // -1\r\n     * new Arr([1, 2, NaN]).indexOfStrict(NaN);   // 2\r\n     */\n\n  }, {\n    key: 'indexOfStrict',\n    value: function indexOfStrict(value) {\n      var key = this.keyOfStrict(value);\n\n      return key === null ? -1 : Number(key);\n    }\n\n    /**\r\n     * @method Arr#join\r\n     * @public\r\n     * @param {String} [separator = ','] - See the link.\r\n     * @returns {String} - String of joined array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join\r\n     * @description Synonym for\r\n     * [Array#join]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join}.\r\n     */\n\n  }, {\n    key: 'join',\n    value: function join(separator) {\n      return this.$.join.apply(this.$, arguments);\n    }\n\n    /**\r\n     * @member Arr#last\r\n     * @type {*}\r\n     * @public\r\n     * @readonly\r\n     * @description The last element of the array.\r\n     *\r\n     * @example\r\n     * new Arr([1, 2, 3]).last; // 3\r\n     * new Arr([]).last;        // undefined\r\n     */\n\n  }, {\n    key: 'pop',\n\n\n    /**\r\n     * @method Arr#pop\r\n     * @public\r\n     * @returns {*} Returns deleted element.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop\r\n     * @description Synonym for\r\n     * [Array#pop]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop}.\r\n     */\n    value: function pop() {\n      return this.$.pop();\n    }\n\n    /**\r\n     * @method Arr#push\r\n     * @public\r\n     * @param {...*} values See the link.\r\n     * @this {Arr}\r\n     * @returns {Arr} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push\r\n     * @description Synonym for\r\n     * [Array#push]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push}\r\n     * besides returning this.\r\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n\n      this.$.push.apply(this.$, arguments);\n\n      return this;\n    }\n\n    /**\r\n     * @method Arr#reverse\r\n     * @public\r\n     * @returns {Arr} A wrap of the reversed array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\r\n     * @description Synonym for\r\n     * [Array#reverse]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}.\r\n     */\n\n  }, {\n    key: 'reverse',\n    value: function reverse() {\n      this.$.reverse();\n\n      return this;\n    }\n\n    /**\r\n     * @method Arr#shift\r\n     * @public\r\n     * @returns {*} Returns deleted element.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift\r\n     * @description Synonym for\r\n     * [Array#shift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift}.\r\n     */\n\n  }, {\n    key: 'shift',\n    value: function shift() {\n      return this.$.shift();\n    }\n\n    /**\r\n     * @method Arr#shuffle\r\n     * @public\r\n     * @returns {Arr} Returns this.\r\n     * @description Method for shuffling.\r\n     *\r\n     * @example\r\n     * new Arr([1, 2, 3, 4]).shuffle().$; // [4, 2, 3, 1]\r\n     * new Arr([1, 2, 3, 4]).shuffle().$; // [1, 3, 4, 2]\r\n     */\n\n  }, {\n    key: 'shuffle',\n    value: function shuffle() {\n      var length = this.$.length;\n\n      return this.forEach(function (value, index, array) {\n        var randomIndex = index + Math.floor((length - index) * Math.random());\n\n        array[index] = array[randomIndex];\n        array[randomIndex] = value;\n      });\n    }\n\n    /**\r\n     * @method Arr#slice\r\n     * @public\r\n     * @param {Number} [begin = 0] - See the link.\r\n     * @param {Number} [end = array.length] - See the link.\r\n     * @returns {Arr} A wrap of a sliced array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\r\n     * @description Synonym for\r\n     * [Array#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}.\r\n     */\n\n  }, {\n    key: 'slice',\n    value: function slice(begin, end) {\n      return new this.constructor(this.$.slice.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Arr#sort\r\n     * @public\r\n     * @param {CompareFunction} [compareFunction] - See the link.\r\n     * @returns {Arr} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n     * @description Synonym for\r\n     * [Array#sort]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}.\r\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(compareFunction) {\n      validate$1([compareFunction], ['function||!'], 'Arr#sort');\n\n      this.$.sort(compareFunction);\n\n      return this;\n    }\n\n    /**\r\n     * @method Arr#sortAsc\r\n     * @public\r\n     * @returns {Arr} Returns this.\r\n     * @description Method for ascending sorting. Puts non-numbers first, then NaNs, then sorted values.\r\n     *\r\n     * @example\r\n     * new Arr([NaN, 1, -7, '100', 5]).sortAsc().$; // ['100', NaN, -7, 1, 5]\r\n     */\n\n  }, {\n    key: 'sortAsc',\n    value: function sortAsc() {\n      return this.sort(asc);\n    }\n\n    /**\r\n     * @method Arr#sortDesc\r\n     * @public\r\n     * @returns {Arr} Returns this.\r\n     * @description Method for descending sorting. Puts sorted values first, then NaNs, then non-numbers.\r\n     *\r\n     * @example\r\n     * new Arr([NaN, 1, -7, '100', 5]).sortDesc().$; // [5, 1, -7, NaN, '100']\r\n     */\n\n  }, {\n    key: 'sortDesc',\n    value: function sortDesc() {\n      return this.sort(function (y, x) {\n        return asc(x, y);\n      });\n    }\n\n    /**\r\n     * @method Arr#splice\r\n     * @public\r\n     * @param {Number} [start] - See the link.\r\n     * @param {Number} [deleteCount] - See the link.\r\n     * @param {...*} [items] - See the link.\r\n     * @returns {Arr} A wrap of return value of #splice call.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\r\n     * @description Synonym for\r\n     * [Array#splice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}.\r\n     */\n\n  }, {\n    key: 'splice',\n    value: function splice(start, deleteCount) {\n      for (var _len3 = arguments.length, items = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        items[_key3 - 2] = arguments[_key3];\n      }\n\n      return new Arr(this.$.splice.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Arr#string\r\n     * @public\r\n     * @returns {String} Concatenated array.\r\n     * @description Synonym for array.join('').\r\n     *\r\n     * @example\r\n     * new Arr([1, 2, 3]).string(); // '123'\r\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      return this.join('');\n    }\n\n    /**\r\n     * @method Arr#unshift\r\n     * @public\r\n     * @param {...*} [values] - See the link.\r\n     * @returns {Arr} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\r\n     * @description Synonym for\r\n     * [Array#unshift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}\r\n     * besides returning this.\r\n     */\n\n  }, {\n    key: 'unshift',\n    value: function unshift() {\n      for (var _len4 = arguments.length, values = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n\n      this.$.unshift.apply(this.$, arguments);\n\n      return this;\n    }\n  }, {\n    key: 'first',\n    get: function get() {\n      return this.$[0];\n    }\n  }, {\n    key: 'last',\n    get: function get() {\n      var array = this.$;\n\n      return array[array.length - 1];\n    }\n\n    /**\r\n     * @member Arr#length\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length\r\n     * @description Synonym for\r\n     * [Array#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length}.\r\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.$.length;\n    }\n  }]);\n  return Arr;\n}(Super);\n\ndefineProperties(Arr.prototype, defineProperty({}, _Symbol.toStringTag, 'Arr'));\n\n/**\r\n * @function asc\r\n * @private\r\n * @param {*} x - First value to be compared.\r\n * @param {*} y - Second value to be compared.\r\n * @returns {Number} Where to put the first element: before or after.\r\n */\nfunction asc(x, y) {\n  if (!isNumber(x) && !isNumber(y)) {\n    return 0;\n  }\n\n  if (!isNumber(x)) {\n    return -1;\n  }\n\n  if (!isNumber(y)) {\n    return 1;\n  }\n\n  if (isNaN(x) && isNaN(y)) {\n    return 0;\n  }\n\n  if (isNaN(x)) {\n    return -1;\n  }\n\n  if (isNaN(y)) {\n    return 1;\n  }\n\n  return x - y;\n}\n\nconstructors[1].push({\n  check: isArrayLike,\n  cls: Arr\n});\n\n/**\r\n * @function array\r\n * @public\r\n * @param {Number} number - Length of the array.\r\n * @param {ArrayCallback} [callback] - If it's present it has to be a function\r\n * that returns the element that is pushed to the new array.\r\n * @returns {Arr} New instance of Arr.\r\n * @description Method for creating new array from the length using optional callback.\r\n *\r\n * @example\r\n * array(3).$;               // [0, 1, 2]\r\n * array(3, (i) => i * 2).$; // [0, 2, 4]\r\n */\nfunction array(number, callback) {\n  validate$1([number, callback], [['intLike', '>=0'], 'function||!'], 'array');\n\n  var array = [];\n\n  for (var i = 0; i < number; i++) {\n    array.push(callback ? callback(i) : i);\n  }\n\n  return new Arr(array);\n}\n\n/**\r\n * @function iterate\r\n * @public\r\n * @param {Number} number - Number of iterations.\r\n * @param {IterateCallback} callback - Callback that is called on each iteration with the iteration index.\r\n * @returns {void}\r\n * @description Method for replacing for (...) construction.\r\n *\r\n * @example\r\n * iterate();\r\n */\nfunction iterate$1(number, callback) {\n  validate$1([number, callback], [['intLike', '>=0'], 'function'], 'iterate');\n\n  for (var i = 0; i < number; i++) {\n    callback(i);\n  }\n}\n\n/**\r\n * @module Promise\r\n * @private\r\n * @mixin\r\n * @description Exports Promise class.\r\n */\n\n/**\r\n * @callback onFulfilledOrRejected\r\n * @public\r\n * @param {*} value - Promise value.\r\n * @param {Boolean} success - If the previous promise is fulfilled it's true and false if rejected.\r\n */\n\n/**\r\n * @callback onRejected\r\n * @public\r\n * @param {Error|*} err - Promise error.\r\n */\n\n/**\r\n * @callback onFulfilled\r\n * @public\r\n * @param {*} value - Promise value.\r\n */\n\nvar secret = {};\nvar iterator = _Symbol.iterator;\n\n/**\r\n * @class Promise\r\n * @public\r\n * @param {Function} executor - Function that takes two arguments: resolve and reject functions.\r\n * Call the resolve function when you need to fulfill the promise and call the reject one\r\n * when you need to reject it.\r\n * @returns {Promise} Instance of Promise.\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n * @description Class with almost identical API to\r\n * [ES6 Promise]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.\r\n * There is a couple differences: set Promise.onError to a function with which you want to\r\n * subscribe to a promise error and set Promise.onUnhandledRejection to a function with which\r\n * you want to subscribe to an unhandled error\r\n * (defaults to console.error.bind(console, '%s %o', 'Uncaught (in promise)')).\r\n */\n\nvar Promise$1 = function () {\n  function Promise(executor) {\n    classCallCheck(this, Promise);\n\n    if (!isFunction(executor)) {\n      throw new TypeError('Promise resolver ' + {}.toString.call(executor) + ' is not a function');\n    }\n\n    var hiddenStatus = void 0;\n    var hiddenValue = void 0;\n\n    var onFulfill = [];\n    var onReject = [];\n    var realPromise = this;\n    var hiddenPromise = {\n      handled: false,\n      get status() {\n        return hiddenStatus;\n      },\n      set status(value) {\n        hiddenStatus = value;\n        realPromise.status = value;\n      },\n      get value() {\n        return hiddenValue;\n      },\n      set value(val) {\n        hiddenValue = val;\n        realPromise.value = val;\n      }\n    };\n\n    hiddenPromise.status = 'pending';\n    hiddenPromise.value = undefined;\n\n    /**\r\n     * @typedef {Object} hiddenPromise\r\n     * @private\r\n     * @property {Boolean|Object} handled - If the promise is handled or not.\r\n     * @property {'pending'|'fulfilled'|'rejected'} status - Status of the promise.\r\n     * @property {*} value - Value of the promise.\r\n     */\n\n    /**\r\n     * @member {Function} hiddenPromise#handle\r\n     * @private\r\n     * @param {('reject'|'resolve')} event - Type of the event to handle.\r\n     * @param {Function} handler - Handler itself.\r\n     * @param {Function} resolve - Resolve function.\r\n     * @param {Function} reject - Reject function.\r\n     * @param {Object} secret - Secret.\r\n     * @description Private method for handling promises.\r\n     */\n\n    /**\r\n     * @member {hiddenPromise} Promise#$$\r\n     * @protected\r\n     */\n    defineProperties(this.$$ = {}, {\n      'get/set handled': {\n        get: function get() {\n          return hiddenPromise.handled;\n        },\n        set: function set(key) {\n          if (key === secret) {\n            hiddenPromise.handled = true;\n          }\n        }\n      },\n      handle: function handle(status, f, resolve, reject, key) {\n        if (key === secret) {\n          var proxy = isFunction(f) ? function (value) {\n            try {\n              resolve(f(value));\n            } catch (err) {\n              reject(err);\n            }\n          } : null;\n\n          if (status === 'resolve') {\n            onFulfill.push(proxy || function (value) {\n              return resolve(value);\n            });\n          } else if (status === 'reject') {\n            onReject.push(proxy || function (err) {\n              return reject(err);\n            });\n          }\n        }\n      },\n      'get status': function getStatus() {\n        return hiddenPromise.status;\n      },\n      'get value': function getValue() {\n        return hiddenPromise.value;\n      }\n    });\n\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n\n    function reject(err) {\n      if (hiddenPromise.status === 'pending') {\n        (function () {\n          hiddenPromise.status = 'rejected';\n          hiddenPromise.value = err;\n\n          for (var i = 0, length = onReject.length; i < length; i++) {\n            hiddenPromise.handled = true;\n\n            onReject[i](err);\n          }\n\n          var onUnhandledRejection = Promise.onUnhandledRejection,\n              onError = Promise.onError;\n\n\n          if (isFunction(onError)) {\n            onError(err);\n          }\n\n          setTimeout(function () {\n            if (!hiddenPromise.handled && isFunction(onUnhandledRejection)) {\n              onUnhandledRejection(err);\n            }\n          }, 1);\n        })();\n      }\n    }\n\n    function resolve(value) {\n      if (hiddenPromise.status === 'pending') {\n        if (value && isFunction(value.then)) {\n          return value.then(function (value) {\n            resolve(value);\n          }, function (err) {\n            reject(err);\n          });\n        }\n\n        hiddenPromise.status = 'fulfilled';\n        hiddenPromise.value = value;\n\n        for (var i = 0, length = onFulfill.length; i < length; i++) {\n          hiddenPromise.handled = true;\n\n          onFulfill[i](value);\n        }\n      }\n    }\n  }\n\n  /**\r\n   * @method Promise.all\r\n   * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises\r\n   * or any values.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\r\n   */\n\n\n  createClass(Promise, [{\n    key: 'abort',\n    value: function abort() {}\n\n    /**\r\n     * @method Promise#catch\r\n     * @param {onRejected} onRejected - onRejected callback.\r\n     * @returns {Promise} New instance of Promise.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\r\n     */\n\n  }, {\n    key: 'catch',\n    value: function _catch(onRejected) {\n      return this.then(null, onRejected);\n    }\n\n    /**\r\n     * @method Promise#finally\r\n     * @public\r\n     * @param {onFulfilledOrRejected} onFulfilledOrRejected - onFulfilledOrRejected callback.\r\n     * @returns {Promise}\r\n     * @description Method for catching both fulfilled and rejected promises.\r\n     *\r\n     * @example\r\n     * spinner.show();\r\n     * fetchData()\r\n     *   .then((data) => {\r\n     *     // do something with data\r\n     *   })\r\n     *   .catch((err) => {\r\n     *     // handle error somehow\r\n     *   })\r\n     *   .finally(() => {\r\n     *     spinner.hide();\r\n     *   });\r\n     */\n\n  }, {\n    key: 'finally',\n    value: function _finally(onFulfilledOrRejected) {\n      var isFunc = isFunction(onFulfilledOrRejected);\n\n      return this.then(function (value) {\n        return Promise.resolve(isFunc ? onFulfilledOrRejected(value, true) : 0).then(function () {\n          return value;\n        });\n      }, function (err) {\n        return Promise.resolve(isFunc ? onFulfilledOrRejected(err, false) : 0).then(function () {\n          return Promise.reject(err);\n        });\n      });\n    }\n\n    /**\r\n     * @method Promise#then\r\n     * @param {onFulfilled} [onFulfilled] - onFulfilled callback.\r\n     * @param {onRejected} [onRejected] - onRejected callback.\r\n     * @returns {Promise} New instance of Promise.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\r\n     */\n\n  }, {\n    key: 'then',\n    value: function then(onFulfilled, onRejected) {\n      var promise = this.$$;\n\n      if (promise.status === 'pending') {\n        return new Promise(function (resolve, reject) {\n          promise.handle('reject', onRejected, resolve, reject, secret);\n          promise.handle('resolve', onFulfilled, resolve, reject, secret);\n        });\n      }\n\n      promise.handled = secret;\n\n      var value = promise.value;\n\n\n      var method = void 0;\n      var handler = void 0;\n\n      if (promise.status === 'fulfilled') {\n        method = 'resolve';\n        handler = onFulfilled;\n      } else {\n        method = 'reject';\n        handler = onRejected;\n      }\n\n      if (!isFunction(handler)) {\n        return Promise[method](value);\n      }\n\n      try {\n        return Promise.resolve(handler(value));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n  }], [{\n    key: 'all',\n    value: function all(iterable) {\n      var array = [];\n\n      var toResolve = 0;\n\n      if (iterable[iterator]) {\n        iterable = iterable[iterator]();\n\n        return new Promise(function (resolve, reject) {\n          var next = void 0;\n          var i = 0;\n\n          var _loop = function _loop() {\n            var promise = Promise.resolve(next.value);\n\n            toResolve++;\n\n            (function (i) {\n              promise.then(function (value) {\n                toResolve--;\n                array[i] = value;\n\n                setTimeout(function () {\n                  if (next.done && !toResolve) {\n                    resolve(array);\n                  }\n                }, 1);\n              }, reject);\n            })(i++);\n          };\n\n          while (!(next = iterable.next()).done) {\n            _loop();\n          }\n\n          if (!i) {\n            return Promise.resolve([]);\n          }\n        });\n      }\n\n      var length = iterable.length;\n\n      if (!length) {\n        return Promise.resolve([]);\n      }\n\n      toResolve = length;\n\n      return new Promise(function (resolve, reject) {\n        var _loop2 = function _loop2(i) {\n          var promise = Promise.resolve(iterable[i]);\n\n          promise.then(function (value) {\n            toResolve--;\n            array[i] = value;\n\n            if (!toResolve) {\n              resolve(array);\n            }\n          }, reject);\n        };\n\n        for (var i = 0; i < length; i++) {\n          _loop2(i);\n        }\n      });\n    }\n\n    /**\r\n     * @method Promise.race\r\n     * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises\r\n     * or any values.\r\n     * @returns {Promise} New instance of Promise.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\r\n     */\n\n  }, {\n    key: 'race',\n    value: function race(iterable) {\n      if (iterable[iterator]) {\n        iterable = iterable[iterator]();\n\n        return new Promise(function (resolve, reject) {\n          var next = void 0;\n\n          while (!(next = iterable.next()).done) {\n            next.value.then(resolve, reject);\n          }\n        });\n      }\n\n      return new Promise(function (resolve, reject) {\n        for (var i = 0, length = iterable.length; i < length; i++) {\n          iterable[i].then(resolve, reject);\n        }\n      });\n    }\n\n    /**\r\n     * @method Promise.reject\r\n     * @param {*} value - Value to reject.\r\n     * @returns {Promise} New instance of Promise.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\r\n     */\n\n  }, {\n    key: 'reject',\n    value: function reject(value) {\n      return new Promise(function (resolve, reject) {\n        reject(value);\n      });\n    }\n\n    /**\r\n     * @method Promise.resolve\r\n     * @param {Promise|Thenable|*} value - Promise, thenable or any value to resolve.\r\n     * @returns {Promise} New instance of Promise.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\r\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(value) {\n      if (value && isFunction(value.then)) {\n        return value;\n      }\n\n      return new Promise(function (resolve) {\n        resolve(value);\n      });\n    }\n  }]);\n  return Promise;\n}();\n\nPromise$1.onError = null;\nPromise$1.onUnhandledRejection = console.error.bind(console, '%s %o', 'Uncaught (in promise)');\n\n\ndefineProperties(Promise$1.prototype, defineProperty({}, _Symbol.toStringTag, 'Promise'));\n\n/**\r\n * @module BlobObject\r\n * @private\r\n * @mixin\r\n * @description Exports BlobObject class.\r\n */\n\n/**\r\n * @typedef {{ buffer: String, binary: String, dataURL: String, text: String }} methods\r\n * @private\r\n * @description List of read blob methods.\r\n */\nvar methods = {\n  buffer: 'ArrayBuffer',\n  binary: 'BinaryString',\n  dataURL: 'DataURL',\n  text: 'Text'\n};\nvar _global = global$1;\nvar URL = _global.URL;\n\n/**\r\n * @typedef {('buffer'|'binary'|'dataURL'|'text')} ReadBlobMethod\r\n * @public\r\n * @description Enum type of read blob methods.\r\n */\n\n/**\r\n * @typedef {ArrayBuffer|ArrayBufferView|Blob|String} BlobParts\r\n * @public\r\n * @description Allowed blob parts.\r\n */\n\n/**\r\n * @callback ReaderEventListener\r\n * @public\r\n * @param {Event} e - Fired event.\r\n * @param {FileReader} reader - FileReader.\r\n */\n\n/**\r\n * @class BlobObject\r\n * @extends Super\r\n * @public\r\n * @param {Blob} blob - Blob to wrap.\r\n * @returns {BlobObject} Instance of BlobObject.\r\n * @description Wrap of a blob.\r\n *\r\n * @example\r\n * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }));\r\n */\n\nvar BlobObject = function (_Super) {\n  inherits(BlobObject, _Super);\n\n  function BlobObject() {\n    classCallCheck(this, BlobObject);\n    return possibleConstructorReturn(this, (BlobObject.__proto__ || Object.getPrototypeOf(BlobObject)).apply(this, arguments));\n  }\n\n  createClass(BlobObject, [{\n    key: 'readAs',\n\n\n    /**\r\n     * @method BlobObject#readAs\r\n     * @public\r\n     * @param {ReadBlobMethod} method - Method that is used for reading from blob.\r\n     * @param {ReaderEventListener} [progress] - Progress listener.\r\n     * @returns {Promise} Promise that could be aborted.\r\n     * @description Method for reading from blobs.\r\n     *\r\n     * @example\r\n     * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }))\r\n     *   .readAs('text')\r\n     *   .then((value) => {\r\n     *     console.log(value); // '{\"foo\":\"bar\"}'\r\n     *   });\r\n     */\n    value: function readAs(method, progress) {\n      var _this2 = this;\n\n      if (!methods[method]) {\n        throw new Error('1st argument must be one of following values: buffer, binary, dataURL, text');\n      }\n\n      var reader = new FileReader();\n      var toReject = void 0;\n\n      if (isFunction(progress)) {\n        reader.onprogress = function (e) {\n          progress(e, this);\n        };\n      }\n\n      var promise = new Promise$1(function (resolve, reject) {\n        toReject = reject;\n\n        reader.onerror = function (_ref) {\n          var target = _ref.target;\n\n          if (reader) {\n            reject(target.error);\n          }\n        };\n\n        reader.onload = function (_ref2) {\n          var target = _ref2.target;\n\n          resolve(target.result);\n        };\n\n        reader['readAs' + methods[method]](_this2.$);\n      });\n\n      promise.abort = function abort() {\n        toReject(new Error('Reading was aborted'));\n\n        reader.abort();\n\n        reader = null;\n\n        return this;\n      };\n\n      return promise;\n    }\n\n    /**\r\n     * @method BlobObject#saveAs\r\n     * @public\r\n     * @param {String} [name] - Name that is used for saving file.\r\n     * @returns {BlobObject} Returns this.\r\n     * @description Method for saving blobs.\r\n     *\r\n     * @example\r\n     * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }))\r\n     *   .saveAs('blob.json');\r\n     */\n\n  }, {\n    key: 'saveAs',\n    value: function saveAs() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'download';\n\n      var anchor = document.createElement('a');\n\n      anchor.href = this.dataURL;\n      anchor.setAttribute('download', name);\n      anchor.click();\n\n      return this;\n    }\n  }, {\n    key: 'dataURL',\n\n    /**\r\n     * @member BlobObject#$\r\n     * @type {Blob}\r\n     * @public\r\n     * @description Original Blob.\r\n     */\n\n    /**\r\n     * @member {String} BlobObject#dataURL\r\n     * @type {String}\r\n     * @public\r\n     * @readonly\r\n     * @description Returns dataURL representation of the blob.\r\n     */\n    get: function get() {\n      return URL.createObjectURL(this.$);\n    }\n  }]);\n  return BlobObject;\n}(Super);\n\ndefineProperties(BlobObject.prototype, defineProperty({}, _Symbol.toStringTag, 'BlobObject'));\n\nconstructors[1].push({\n  check: function check(blob) {\n    return (/^(Blob|File)$/.test(toStringTag(blob))\n    );\n  },\n  cls: BlobObject\n});\n\n/**\r\n * @function blob\r\n * @public\r\n * @param {(BlobParts[]|BlobParts)} blobParts - Blob parts that are passed to\r\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.\r\n * @param {Object} [options] - Options that are passed to\r\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.\r\n * @returns {BlobObject} New instance of BlobObject.\r\n * @description Function for creating blobs not involving BlobObject and Blob constructors.\r\n */\nfunction blob$1(blobParts) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(blobParts)) {\n    blobParts = [blobParts];\n  }\n\n  return new BlobObject(new Blob(blobParts, options));\n}\n\n/**\r\n * @module Func\r\n * @private\r\n * @mixin\r\n * @description Exports Func class.\r\n */\n\n/**\r\n * @callback BeforeMiddleware\r\n * @param {Array} args - Previous arguments.\r\n * @param {Func} func - This function.\r\n * @returns {Array} - New arguments.\r\n */\n\n/**\r\n * @callback AfterMiddleware\r\n * @param {*} returnValue - Previous return value.\r\n * @param {Func} func - This function.\r\n * @returns {*} - New return value.\r\n */\n\n/**\r\n * @class Func\r\n * @extends Super\r\n * @public\r\n * @param {Function} [func = function () {}] - Function to wrap.\r\n * @returns {Func} Instance of Func.\r\n * @description A wrap of a function.\r\n *\r\n * @example\r\n * const func = new Func(Math.max);\r\n *\r\n * func(1, 4, -2, 5); // 5\r\n */\n\nvar Func = function (_Super) {\n  inherits(Func, _Super);\n\n  function Func() {\n    var _ret;\n\n    var func = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    classCallCheck(this, Func);\n\n    var _this = possibleConstructorReturn(this, (Func.__proto__ || Object.getPrototypeOf(Func)).call(this));\n\n    function proxy() {\n      var _this2 = this,\n          _arguments = arguments;\n\n      if (++proxy.$$.called < proxy.$$.canBeCalled) {\n        var _ret2 = function () {\n          var _proxy$$$ = proxy.$$,\n              before = _proxy$$$.before,\n              after = _proxy$$$.after,\n              sync = _proxy$$$.sync,\n              contextLocked = _proxy$$$.contextLocked;\n          var _proxy$$$2 = proxy.$$,\n              context = _proxy$$$2.context,\n              args = _proxy$$$2.args;\n\n          var ret = void 0;\n\n          context = contextLocked ? context : context || _this2;\n          args = args.concat(toArray$1(_arguments));\n\n          if (sync) {\n            iterate(before, function (middleware) {\n              args = middleware.call(context, toArray$1(args), proxy);\n            });\n\n            ret = func.apply(context, toArray$1(args));\n\n            iterate(after, function (middleware) {\n              ret = middleware.call(context, ret, proxy);\n            });\n\n            return {\n              v: ret\n            };\n          }\n\n          var promise = Promise$1.resolve(args);\n\n          iterate(before, function (middleware) {\n            promise = promise.then(function (args) {\n              return middleware.call(context, toArray$1(args), proxy);\n            });\n          });\n\n          promise = promise.then(function (args) {\n            return func.apply(context, toArray$1(args));\n          });\n\n          iterate(after, function (middleware) {\n            promise = promise.then(function (ret) {\n              return middleware.call(context, ret, proxy);\n            });\n          });\n\n          return {\n            v: promise\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      }\n    }\n\n    /**\r\n     * @member {Object} Func#$$\r\n     * @type {Object}\r\n     * @protected\r\n     * @property {Array} after - After middleware array.\r\n     * @property {Array} args - Locked and bound arguments.\r\n     * @property {Array} argsLocked - Locked arguments.\r\n     * @property {Array} before - Before middleware array.\r\n     * @property {Number} called - How many times the function was called.\r\n     * @property {Number} canBeCalled - How many times the function can be actually called.\r\n     * @property {*} context - Locked or bound context.\r\n     * @property {Boolean} contextLocked - Is context locked or not.\r\n     * @property {Boolean} sync - Is function synchronous or not.\r\n     * @description Config parameters.\r\n     */\n    Object.defineProperty(proxy, '$$', {\n      value: {\n        after: [],\n        args: [],\n        argsLocked: [],\n        before: [],\n        called: 0,\n        canBeCalled: Infinity,\n        context: null,\n        contextLocked: false,\n        sync: true\n      }\n    });\n\n    /**\r\n     * @member {Function} Func#$\r\n     * @type {Function}\r\n     * @public\r\n     * @description Original function.\r\n     */\n    Object.defineProperty(proxy, '$', { value: func });\n    Object.setPrototypeOf(proxy, Func.prototype);\n\n    return _ret = proxy, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\r\n   * @method Func#after\r\n   * @public\r\n   * @param {AfterMiddleware} middleware - After middleware.\r\n   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put middleware.\r\n   * Truthy parameter stands for \"to the end\" and falsey for \"to the beginning\".\r\n   * @returns {Func} Returns this.\r\n   * @description Adds after middleware.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1)\r\n   *   .after((result) => result * result);\r\n   *\r\n   * func(4);  // 25\r\n   * func(-4); // 9\r\n   */\n\n\n  createClass(Func, [{\n    key: 'after',\n    value: function after(middleware) {\n      var afterAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      validate$1([middleware], ['function'], 'Func#after');\n\n      var after = this.$$.after;\n\n\n      if (afterAll) {\n        after.push(middleware);\n      } else {\n        after.unshift(middleware);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#apply\r\n     * @public\r\n     * @param {*} [context] - Context to call with.\r\n     * @param {(Array|Arguments)} [args] - Arguments to call with.\r\n     * @returns {*} Return of function call.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\r\n     * @description Synonym for\r\n     * [Function#apply]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply}.\r\n     */\n\n  }, {\n    key: 'apply',\n    value: function apply(context, args) {\n      return function () {}.apply.apply(this, arguments);\n    }\n\n    /**\r\n     * @method Func#async\r\n     * @public\r\n     * @param {Boolean|*} [condition] - If the function should be synchronous or not.\r\n     * @returns {Func} Returns this.\r\n     * @description If the function should be synchronous or not.\r\n     *\r\n     * @example\r\n     * const func = new Func((a) => a + 1).async();\r\n     *\r\n     * func(4).then((result) => {\r\n     *   console.log(result); // 5\r\n     * });\r\n     */\n\n  }, {\n    key: 'async',\n    value: function async() {\n      var condition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this.$$.sync = !condition;\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#before\r\n     * @public\r\n     * @param {BeforeMiddleware} middleware - Before middleware.\r\n     * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put middleware.\r\n     * Truthy parameter stands for \"to the beginning\" and falsey for \"to the end\".\r\n     * @returns {Func} Returns this.\r\n     * @description Adds before middleware.\r\n     *\r\n     * @example\r\n     * const func = new Func((a) => a + 1)\r\n     *   .before(([arg]) => [arg * arg]);\r\n     *\r\n     * func(4); // 17\r\n     * func(3); // 10\r\n     */\n\n  }, {\n    key: 'before',\n    value: function before(middleware) {\n      var beforeAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      validate$1([middleware], ['function'], 'Func#before');\n\n      var before = this.$$.before;\n\n\n      if (beforeAll) {\n        before.unshift(middleware);\n      } else {\n        before.push(middleware);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#bind\r\n     * @public\r\n     * @param {*} context - Context to bind.\r\n     * @param {...(Array|Arguments|*)} args - Arguments to bind.\r\n     * @returns {Func} Returns this.\r\n     * @description Composition of {@link Func#bindContext} and {@link Func#bindArgs}.\r\n     *\r\n     * @example\r\n     * const func = new Func(function (a, b) {\r\n     *   return this.a + a + b;\r\n     * }).bind({ a: 2 }, 1);\r\n     *\r\n     * func(1); // 4\r\n     * func(3); // 6\r\n     */\n\n  }, {\n    key: 'bind',\n    value: function bind(context) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return this.bindContext(context).bindArgs(args);\n    }\n\n    /**\r\n     * @method Func#bindArgs\r\n     * @public\r\n     * @param {(Array|Arguments)} args - Arguments to bind.\r\n     * @returns {Func} Returns this.\r\n     * @description Binds arguments in addition to already locked and bound ones.\r\n     *\r\n     * @example\r\n     * const func = new Func((...args) => {\r\n     *   let sum = 0;\r\n     *\r\n     *   for (let i = 0; i < args.length; i++) {\r\n     *     sum += args[i];\r\n     *   }\r\n     *\r\n     *   return sum;\r\n     * });\r\n     *\r\n     * func(1, 2, 3); // 6\r\n     *\r\n     * func.bindArgs([4]);\r\n     *\r\n     * func(1, 2, 3); // 10\r\n     *\r\n     * func.bindArgs([5]);\r\n     *\r\n     * func(1, 2, 3); // 15\r\n     */\n\n  }, {\n    key: 'bindArgs',\n    value: function bindArgs(args) {\n      var func = this.$$;\n\n      func.args = func.args.concat(toArray$1(args));\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#bindContext\r\n     * @public\r\n     * @param {*} context - Context to bind.\r\n     * @returns {Func} Returns this.\r\n     * @description Bind new context if it's not already locked.\r\n     *\r\n     * @example\r\n     * const func = new Func(function () {\r\n     *   return this.a;\r\n     * }).bindContext({ a: 1 });\r\n     *\r\n     * func(); // 1\r\n     *\r\n     * func.bindContext({ a: 2 });\r\n     *\r\n     * func(); // 2\r\n     */\n\n  }, {\n    key: 'bindContext',\n    value: function bindContext(context) {\n      var func = this.$$;\n\n      if (!func.contextLocked) {\n        func.context = context;\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#call\r\n     * @public\r\n     * @param {*} [context] - Context to call with.\r\n     * @param {...*} [args] - Arguments to call with.\r\n     * @returns {*} Return of function call.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call\r\n     * @description Synonym for\r\n     * [Function#call]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call}.\r\n     */\n\n  }, {\n    key: 'call',\n    value: function call(context) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return function () {}.call.apply(this, arguments);\n    }\n\n    /**\r\n     * @member {Number} Func#called\r\n     * @public\r\n     * @readonly\r\n     * @description Returns how many times the function was called.\r\n     *\r\n     * @example\r\n     * const func = new Func((a) => a + 1);\r\n     *\r\n     * func();\r\n     * func();\r\n     *\r\n     * func.called // 2\r\n     */\n\n  }, {\n    key: 'canBeCalled',\n\n\n    /**\r\n     * @method Func#canBeCalled\r\n     * @public\r\n     * @param {Number} times - Number of maximum times the function is called (middlewares are also taken for a count).\r\n     * @returns {Func} Returns this.\r\n     * @description Method for limiting call times of function.\r\n     *\r\n     * @example\r\n     * const func = new Func((a) => a + 1)\r\n     *   .canBeCalled(1);\r\n     *\r\n     * func(1); // 2\r\n     * func(1); // undefined\r\n     */\n    value: function canBeCalled(times) {\n      this.$$.canBeCalled = times;\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#limitArgsTo\r\n     * @public\r\n     * @param {Number} number - Number of arguments to limit to.\r\n     * @returns {Func} Returns this.\r\n     * @description Built-in before middleware for limiting number of arguments\r\n     * that is put to the end of before middlewares.\r\n     *\r\n     * @example\r\n     * const func = new Func((a, b) => [a, b]);\r\n     *\r\n     * func(1, 2); // [1, 2]\r\n     *\r\n     * func.limitArgsTo(1);\r\n     *\r\n     * func(1, 2); // [1, undefined]\r\n     */\n\n  }, {\n    key: 'limitArgsTo',\n    value: function limitArgsTo(number) {\n      return this.before(function (args) {\n        return args.slice(0, number);\n      }, false);\n    }\n\n    /**\r\n     * @method Func#lock\r\n     * @public\r\n     * @param {*} context - Context to lock.\r\n     * @param {(Array|Arguments|*)} args - Arguments to lock.\r\n     * @returns {Func} Returns this.\r\n     * @description Composition of {@link Func#lockContext} and {@link Func#lockArgs}.\r\n     *\r\n     * @example\r\n     * const func = new Func(function (a, b) {\r\n     *   return this.a + a + b;\r\n     * }).lock({ a: 2 }, [1]);\r\n     *\r\n     * func(1); // 4\r\n     * func(3); // 6\r\n     */\n\n  }, {\n    key: 'lock',\n    value: function lock(context, args) {\n      return this.lockContext(context).lockArgs(args);\n    }\n\n    /**\r\n     * @method Func#lockArgs\r\n     * @public\r\n     * @param {(Array|Arguments|*)} args - Arguments to lock.\r\n     * @returns {Func} Returns this.\r\n     * @description Erases bound arguments and adds new arguments to already locked ones.\r\n     *\r\n     * @example\r\n     * const func = new Func((...args) => {\r\n     *   let sum = 0;\r\n     *\r\n     *   for (let i = 0; i < args.length; i++) {\r\n     *     sum += args[i];\r\n     *   }\r\n     *\r\n     *   return sum;\r\n     * });\r\n     *\r\n     * func(1, 2, 3); // 6\r\n     *\r\n     * func.lockArgs([4]);\r\n     *\r\n     * func(1, 2, 3); // 10\r\n     *\r\n     * func.bindArgs([6, 7]);\r\n     * func.lockArgs([5]);\r\n     *\r\n     * func(1, 2, 3); // 15\r\n     */\n\n  }, {\n    key: 'lockArgs',\n    value: function lockArgs(args) {\n      var func = this.$$;\n\n      func.args = func.argsLocked = func.argsLocked.concat(toArray$1(args));\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#lockContext\r\n     * @public\r\n     * @param {*} context - Context to lock.\r\n     * @returns {Func} Returns this.\r\n     * @description Locks context if it's not already locked.\r\n     *\r\n     * @example\r\n     * const func = new Func(function () {\r\n     *   return this.a;\r\n     * }).lockContext({ a: 1 });\r\n     *\r\n     * func(); // 1\r\n     *\r\n     * func.lockContext({ a: 2 });\r\n     *\r\n     * func(); // 1\r\n     */\n\n  }, {\n    key: 'lockContext',\n    value: function lockContext(context) {\n      var func = this.$$;\n\n      if (!func.contextLocked) {\n        func.context = context;\n        func.contextLocked = true;\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#timing\r\n     * @public\r\n     * @param {String} mark - Argument that is passed to console.time() and console.timeEnd().\r\n     * By default name of the original function, or if it's not present, 'anonymous' is used.\r\n     * @returns {Func} Returns this.\r\n     * @description Built-in before and after middlewares for noting calling time.\r\n     * In case of asynchronous functions it notes time between calling function and resolving or rejecting the result.\r\n     *\r\n     * @example\r\n     * const func = new Func((a) => a + 1)\r\n     *   .timing('plus 1');\r\n     *\r\n     * func(2); // plus 1: 0.010ms\r\n     *\r\n     * const async = new Func(() => new Promise(() => {\r\n     *     setTimeout(resolve, 1000);\r\n     *   }))\r\n     *   .async()\r\n     *   .timing();\r\n     *\r\n     * async();\r\n     * // After 1 second...\r\n     * // anonymous: 1000.010ms\r\n     */\n\n  }, {\n    key: 'timing',\n    value: function timing(mark) {\n      mark = arguments.length ? String(mark) : this.$.name || 'anonymous';\n\n      this.before(function (args) {\n        console.time(mark);\n\n        return args;\n      }, false);\n\n      this.after(function (ret) {\n        console.timeEnd(mark);\n\n        return ret;\n      }, false);\n\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return function () {}.toString.call(this.$);\n    }\n\n    /**\r\n     * @method Func#unbind\r\n     * @public\r\n     * @returns {Func} Returns this.\r\n     * @description Composition of {@link Func#unbindContext} and {@link Func#unbindArgs}.\r\n     *\r\n     * @example\r\n     * const func = new Func(function (a) {\r\n     *   return this.foo + ' & ' +  a;\r\n     * }).bind({ foo: 2 }, 1);\r\n     *\r\n     * func(); // '2 & 1'\r\n     *\r\n     * func.unbind();\r\n     *\r\n     * func(); // 'undefined & undefined'\r\n     */\n\n  }, {\n    key: 'unbind',\n    value: function unbind() {\n      return this.unbindContext().unbindArgs();\n    }\n\n    /**\r\n     * @method Func#unbindArgs\r\n     * @public\r\n     * @returns {Func} Returns this.\r\n     * @description Erases all bound arguments.\r\n     *\r\n     * @example\r\n     * const func = new Func((...args) => {\r\n     *   let sum = 0;\r\n     *\r\n     *   for (let i = 0; i < args.length; i++) {\r\n     *     sum += args[i];\r\n     *   }\r\n     *\r\n     *   return sum;\r\n     * }).bindArgs([4, 5]);\r\n     *\r\n     * func(1, 2, 3); // 15\r\n     *\r\n     * func.unbindArgs();\r\n     *\r\n     * func(1, 2, 3); // 6\r\n     */\n\n  }, {\n    key: 'unbindArgs',\n    value: function unbindArgs() {\n      var func = this.$$;\n\n      func.args = func.argsLocked;\n\n      return this;\n    }\n\n    /**\r\n     * @method Func#unbindContext\r\n     * @public\r\n     * @returns {Func} Returns this.\r\n     * @description Erases context if it's not locked.\r\n     *\r\n     * @example\r\n     * const func = new Func(function () {\r\n     *   return this.foo;\r\n     * }).bindContext({ foo: 1 });\r\n     *\r\n     * func(); // 1\r\n     *\r\n     * func.unbindArgs();\r\n     *\r\n     * func(); // undefined\r\n     */\n\n  }, {\n    key: 'unbindContext',\n    value: function unbindContext() {\n      var func = this.$$;\n\n      if (!func.contextLocked) {\n        func.context = null;\n      }\n\n      return this;\n    }\n  }, {\n    key: 'called',\n    get: function get() {\n      return this.$$.called;\n    }\n  }]);\n  return Func;\n}(Super);\n\ndefineProperties(Func.prototype, defineProperty({}, _Symbol.toStringTag, 'Func'));\n\nconstructors[1].push({\n  check: isFunction,\n  cls: Func\n});\n\n/**\r\n * @function method\r\n * @public\r\n * @param {String} method - Method to call.\r\n * @param {(Array|Arguments|*)} args - Arguments to call the method with.\r\n * @returns {Function} Function that calls stated method with given arguments.\r\n * @description Function that returns the function\r\n * that calls stated method of its first argument with given arguments.\r\n *\r\n * @example\r\n * [1.2345, 2.789, 3.14].map(method('toFixed', [2])); // ['1.23', '2.79', '3.14']\r\n */\nfunction method(method) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  return function (x) {\n    return x[method].apply(x, toArray$1(args));\n  };\n}\n\n/**\r\n * @function noop\r\n * @public\r\n * @returns {void}\r\n * @description Empty function.\r\n */\nfunction noop() {}\n\n/**\r\n * @function prop\r\n * @public\r\n * @param {String} prop - Property to return.\r\n * @returns {Function} Function that returns given property of its first argument.\r\n * @description Function that return the function that returns given property of its first argument.\r\n *\r\n * @example\r\n * ['foo', '12', '7890'].map(prop('length')); // [3, 2, 4]\r\n */\nfunction prop$1(prop) {\n  return function (_ref) {\n    var value = _ref[prop];\n    return value;\n  };\n}\n\n/**\r\n * @function self\r\n * @public\r\n * @returns {*} First argument itself.\r\n * @description Function that returns the first argument.\r\n *\r\n * @example\r\n * [1, 2].map(self);                     // [1, 2]\r\n * [1, 3, NaN, 0, 7, null].filter(self); // [1, 3, 7]\r\n */\nfunction self$1() {\n  return arguments[0];\n}\n\n/**\r\n * @module Str\r\n * @private\r\n * @mixin\r\n * @description Exports Str class.\r\n */\n\nvar htmlSpecials = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;'\n};\nvar regexpSpecialsRegexp = new RegExp(new Super(regexpSpecialCharacters).word(function (x) {\n  return '\\\\' + x + '|';\n}).replace(/\\|$/, ''), 'g');\n\n/**\r\n * @class Str\r\n * @extends Super\r\n * @public\r\n * @param {String} [string = ''] - A string to wrap.\r\n * @returns {Str} Instance of Str.\r\n * @description Wrap of a string.\r\n *\r\n * @example\r\n * const s = new Num('1');\r\n */\n\nvar Str = function (_Super) {\n  inherits(Str, _Super);\n\n  function Str() {\n    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    classCallCheck(this, Str);\n    return possibleConstructorReturn(this, (Str.__proto__ || Object.getPrototypeOf(Str)).call(this, '' + string));\n\n    /**\r\n     * @member Str#$\r\n     * @type {String}\r\n     * @public\r\n     * @description Original string.\r\n     */\n  }\n\n  /**\r\n   * @method Str#capitalizeFirst\r\n   * @public\r\n   * @returns {Str} Capitalized string.\r\n   * @description Method capitalizing the first symbol.\r\n   *\r\n   * @example\r\n   * new Str('foo').capitalizeFirst().$; // 'Foo'\r\n   */\n\n\n  createClass(Str, [{\n    key: 'capitalizeFirst',\n    value: function capitalizeFirst() {\n      var string = this.$;\n\n      return new Str(string.slice(0, 1).toUpperCase() + string.slice(1));\n    }\n\n    /**\r\n     * @method Str#endsWith\r\n     * @public\r\n     * @param {String} searchString - See the link.\r\n     * @param {Number} [position = string.length] - See the link.\r\n     * @returns {Boolean} If the string ends with the argument string.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\r\n     * @description Synonym for\r\n     * [String#endsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith}.\r\n     */\n\n  }, {\n    key: 'endsWith',\n    value: function endsWith(searchString, position) {\n      if (arguments.length < 2) {\n        position = this.$.length;\n      }\n\n      return this.slice(0, position).revert().startsWith(new Str(searchString).revert().$);\n    }\n\n    /**\r\n     * @method Str#escapeHTML\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Methods escaping \"&\", \"<\" and \">\" symbols.\r\n     *\r\n     * @example\r\n     * new Str('\"1 < 2\" & \"7 > 4\" are true expressions.').escapeHTML().$;\r\n     * // '\"1 &lt; 2\" &amp \"7 &gt; 2\" are true expressions.'\r\n     */\n\n  }, {\n    key: 'escapeHTML',\n    value: function escapeHTML() {\n      var string = this.$;\n\n      iterate(htmlSpecials, function (escaped, symbol) {\n        string = string.replace(new RegExp(symbol, 'g'), escaped);\n      });\n\n      return new Str(string);\n    }\n\n    /**\r\n     * @method Str#escapeRegExp\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Method escaping RegExp special characters.\r\n     *\r\n     * @example\r\n     * new Str('(213.98 - [] {})').escapeRegExp().$; // '\\(213\\.98 \\- \\[\\] \\{\\}\\)'\r\n     */\n\n  }, {\n    key: 'escapeRegExp',\n    value: function escapeRegExp() {\n      return this.replace(regexpSpecialsRegexp, '\\\\$&');\n    }\n\n    /**\r\n     * @method Str#in\r\n     * @public\r\n     * @param {*} object - Object to check the string as a property in.\r\n     * @returns {Boolean} If it is in the object or not.\r\n     * @description Returns string in object.\r\n     *\r\n     * @example\r\n     * new Str('a').in({ a: 1 }); // true\r\n     * new Str('toFixed').in(1);  // false\r\n     * new Str('a').in(null);     // false\r\n     */\n\n  }, {\n    key: 'in',\n    value: function _in(object) {\n      if (!isObject(object)) {\n        return false;\n      }\n\n      return this.$ in object;\n    }\n\n    /**\r\n     * @method Str#indexOf\r\n     * @public\r\n     * @param {String} searchValue - See the link.\r\n     * @param {Number} [fromIndex = 0] - See the link.\r\n     * @returns {Number} Found index or -1.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\r\n     * @description Synonym for\r\n     * [String#indexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf}.\r\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(searchValue, fromIndex) {\n      return this.$.indexOf.apply(this.$, arguments);\n    }\n\n    /**\r\n     * @method Str#lastIndexOf\r\n     * @public\r\n     * @param {String} searchValue - See the link.\r\n     * @param {Number} [fromIndex = string.length] - See the link.\r\n     * @returns {Number} Found index or -1.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf\r\n     * @description Synonym for\r\n     * [String#lastIndexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf}.\r\n     */\n\n  }, {\n    key: 'lastIndexOf',\n    value: function lastIndexOf(searchValue, fromIndex) {\n      return this.$.lastIndexOf.apply(this.$, arguments);\n    }\n\n    /**\r\n     * @member Str#length\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length\r\n     * @description Synonym for\r\n     * [String#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length}.\r\n     */\n\n  }, {\n    key: 'match',\n\n\n    /**\r\n     * @method Str#match\r\n     * @public\r\n     * @returns {Arr|Super} D-Wrap of found match.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match\r\n     * @description Synonym for\r\n     * [String#match]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match}.\r\n     */\n    value: function match(regexp) {\n      return D$1(this.$.match.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Str#repeat\r\n     * @public\r\n     * @param {Integer} times - Times to repeat the string.\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\r\n     * @description Synonym for\r\n     * [String#repeat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat}.\r\n     *\r\n     * @example\r\n     * new Str('123').repeat(2).$; // '123123'\r\n     * new Str('123').repeat(0).$; // ''\r\n     */\n\n  }, {\n    key: 'repeat',\n    value: function repeat(times) {\n      validate$1([times], [['intLike', '>=0']], 'Str#repeat');\n\n      times = +times;\n\n      var string = this.$;\n\n      var s = '';\n\n      for (var i = 0; i < times; i++) {\n        s += string;\n      }\n\n      return new Str(s);\n    }\n\n    /**\r\n     * @method Str#replace\r\n     * @public\r\n     * @param {RegExp|String} regexp - See the link.\r\n     * @param {String|Function} [replacer = ''] - See the link.\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace\r\n     * @description Synonym for\r\n     * [String#replace]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace}\r\n     * besides that replacer has a default value of ''.\r\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(regexp) {\n      var replacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      return new Str(this.$.replace(regexp, replacer));\n    }\n\n    /**\r\n     * @method Str#replaceString\r\n     * @public\r\n     * @param {String} string - String to replace.\r\n     * @param {String} [replacer = ''] - String to replace with.\r\n     * @returns {Str} New instance of Str.\r\n     * @description Method for global string replaceing.\r\n     *\r\n     * @example\r\n     * new Str('123123').replaceString('1', '4').$; // '423423'\r\n     * new Str('123123').replaceString('1').$;      // '2323'\r\n     */\n\n  }, {\n    key: 'replaceString',\n    value: function replaceString(string) {\n      var replacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      string = new Super(string).$;\n\n      validate$1([string], ['string'], 'Str#replaceString');\n\n      return new Str(this.$.split(string).join(replacer));\n    }\n\n    /**\r\n     * @method Str#revert\r\n     * @public\r\n     * @returns {Str} New instance of string.\r\n     * @description Method for reverting a string.\r\n     *\r\n     * @example\r\n     * new Str('1234').revert().$; // '4321'\r\n     */\n\n  }, {\n    key: 'revert',\n    value: function revert() {\n      var string = this.$;\n      var str = '';\n\n      for (var i = string.length - 1; i >= 0; i--) {\n        str += string[i];\n      }\n\n      return new Str(str);\n    }\n\n    /**\r\n     * @method Str#search\r\n     * @public\r\n     * @param {RegExp} regexp - See the link.\r\n     * @returns {Number} Index of the first match, if found, and -1 if not.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search\r\n     * @description Synonym for\r\n     * [String#search]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search}.\r\n     */\n\n  }, {\n    key: 'search',\n    value: function search(regexp) {\n      validate$1([regexp], ['regexp']);\n\n      return this.$.search.apply(this.$, arguments);\n    }\n\n    /**\r\n     * @method Str#slice\r\n     * @public\r\n     * @param {Number} [beginSlice = 0] - See the link.\r\n     * @param {Number} [endSlice = string.length] - See the link.\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice\r\n     * @description Synonym for\r\n     * [String#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice}.\r\n     */\n\n  }, {\n    key: 'slice',\n    value: function slice(beginSlice, endSlice) {\n      return new Str(this.$.slice.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Str#split\r\n     * @public\r\n     * @param {RegExp|String} [separator] - See the link.\r\n     * @returns {Arr|Super} D-Wrap of the array.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split\r\n     * @description Synonym for\r\n     * [String#split]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split}.\r\n     */\n\n  }, {\n    key: 'split',\n    value: function split(separator) {\n      return D$1(this.$.split.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Str#startsWith\r\n     * @public\r\n     * @param {String} searchString - See the link.\r\n     * @param {Number} [position = 0] - See the link.\r\n     * @returns {Boolean} If the string ends with the argument string.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\r\n     * @description Synonym for\r\n     * [String#startsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith}.\r\n     */\n\n  }, {\n    key: 'startsWith',\n    value: function startsWith(searchString) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      return this.$.indexOf.apply(this.$, arguments) === position;\n    }\n\n    /**\r\n     * @method Str#substr\r\n     * @public\r\n     * @param {Number} [start = 0] - See the link.\r\n     * @param {Number} [length = string.length] - See the link.\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr\r\n     * @description Synonym for\r\n     * [String#substr]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr}.\r\n     */\n\n  }, {\n    key: 'substr',\n    value: function substr(start, length) {\n      return new Str(this.$.substr.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Str#substring\r\n     * @public\r\n     * @param {Number} [indexStart = 0] - See the link.\r\n     * @param {Number} [indexEnd = string.length] - See the link.\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring\r\n     * @description Synonym for\r\n     * [String#substring]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring}.\r\n     */\n\n  }, {\n    key: 'substring',\n    value: function substring(indexStart, indexEnd) {\n      return new Str(this.$.substring.apply(this.$, arguments));\n    }\n\n    /**\r\n     * @method Str#toCamelCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Removes following regexp /\\s\\-_\\./ making the string camel cased.\r\n     *\r\n     * @example\r\n     * new Str('spinal-case').toCamelCase().$;  // 'spinalCase'\r\n     * new Str('_snake_case_').toCamelCase().$; // 'snakeCase'\r\n     */\n\n  }, {\n    key: 'toCamelCase',\n    value: function toCamelCase() {\n      return new Str(trim(this.$).replace(/[\\s\\-_.]+/g, '-').replace(/-[^-]/g, function (match) {\n        return match[1].toUpperCase();\n      }).replace(/^[\\S]/, function (match) {\n        return match.toLowerCase();\n      }));\n    }\n\n    /**\r\n     * @method Str#toCapitalCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Removes following regexp /\\-_\\./ making the string capital letter cased.\r\n     *\r\n     * @example\r\n     * new Str('spinal-case').toCapitalCase().$;  // 'Spinal Case'\r\n     * new Str('_snake_case_').toCapitalCase().$; // 'Snake Case'\r\n     */\n\n  }, {\n    key: 'toCapitalCase',\n    value: function toCapitalCase() {\n      return new Str(trim(this.$).replace(/[\\s\\-_.]+/g, ' ').replace(/[\\S]/g, function (match) {\n        return match.toLowerCase() === match ? match : ' ' + match;\n      }).replace(/\\s[\\S]/g, function (match) {\n        return match.toUpperCase();\n      }).replace(/\\s+/g, ' ').replace(/^\\s/, '').replace(/^[\\S]/, function (match) {\n        return match.toUpperCase();\n      }));\n    }\n\n    /**\r\n     * @method Str#toDotCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Removes following regexp /\\-_\\./ making the string dot cased.\r\n     *\r\n     * @example\r\n     * new Str('spinal-case').toDotCase().$;  // 'spinal.case'\r\n     * new Str('_snake_case_').toDotCase().$; // 'snake.case'\r\n     */\n\n  }, {\n    key: 'toDotCase',\n    value: function toDotCase() {\n      return new Str(trim(this.$).replace(/[\\s\\-_.]+/g, '.').replace(/[^.]/g, function (match) {\n        return match.toLowerCase() === match ? match : '.' + match;\n      }).replace(/\\.+/g, '.').replace(/^\\./, '').toLowerCase());\n    }\n\n    /**\r\n     * @method Str#toHyphenCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Removes following regexp /\\s\\-_\\./ making the string camel cased.\r\n     *\r\n     * @example\r\n     * new Str('camelCase').toSpinalCase().$;    // 'camel-case'\r\n     * new Str('_snake_case_').toSpinalCase().$; // 'snake-case'\r\n     */\n\n  }, {\n    key: 'toHyphenCase',\n    value: function toHyphenCase() {\n      return new Str(trim(this.$).replace(/[\\s\\-_.]+/g, '-').replace(/[^-]/g, function (match) {\n        return match.toLowerCase() === match ? match : '-' + match;\n      }).replace(/-+/g, '-').replace(/^-/, '').toLowerCase());\n    }\n\n    /**\r\n     * @method Str#toLowerCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase\r\n     * @description Synonym for\r\n     * [String#toLowerCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase}.\r\n     *\r\n     * @example\r\n     * new Str('UPPER-CASE').toLowerCase().$;  // 'upper-case'\r\n     */\n\n  }, {\n    key: 'toLowerCase',\n    value: function toLowerCase() {\n      return new Str(this.$.toLowerCase());\n    }\n\n    /**\r\n     * @method Str#toSnakeCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Removes following regexp /\\s\\-\\./ making the string spinal cased.\r\n     *\r\n     * @example\r\n     * new Str('spinal-case').toSnakeCase().$; // 'spinal_case'\r\n     * new Str('camelCase').toSnakeCase().$;   // 'camel_case'\r\n     */\n\n  }, {\n    key: 'toSnakeCase',\n    value: function toSnakeCase() {\n      return new Str(trim(this.$).replace(/[\\s\\-_.]+/g, '_').replace(/[^_]/g, function (match) {\n        return match.toLowerCase() === match ? match : '_' + match;\n      }).replace(/_+/g, '_').replace(/^_/, '').toLowerCase());\n    }\n\n    /**\r\n     * @method Str#toSpaceCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @description Removes following regexp /\\-_\\./ making the string space cased.\r\n     *\r\n     * @example\r\n     * new Str('spinal-case').toSpaceCase().$;  // 'spinal case'\r\n     * new Str('_snake_case_').toSpaceCase().$; // 'snake case'\r\n     */\n\n  }, {\n    key: 'toSpaceCase',\n    value: function toSpaceCase() {\n      return new Str(trim(this.$).replace(/[\\s\\-_.]+/g, ' ').replace(/[\\S]/g, function (match) {\n        return match.toLowerCase() === match ? match : ' ' + match;\n      }).replace(/\\s+/g, ' ').replace(/^\\s/, '').toLowerCase());\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.$;\n    }\n\n    /**\r\n     * @method Str#toUpperCase\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase\r\n     * @description Synonym for\r\n     * [String#toUpperCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase}.\r\n     *\r\n     * @example\r\n     * new Str('lower-case').toUpperCase().$;  // 'LOWER-CASE'\r\n     */\n\n  }, {\n    key: 'toUpperCase',\n    value: function toUpperCase() {\n      return new Str(this.$.toUpperCase());\n    }\n\n    /**\r\n     * @method Str#trim\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim\r\n     * @description Synonym for\r\n     * [String#trim]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim}.\r\n     */\n\n  }, {\n    key: 'trim',\n    value: function trim() {\n      return new Str(this.$.replace(/^[\\s\\ufeff\\u00a0]+|[\\s\\ufeff\\u00a0]+$/g, ''));\n    }\n\n    /**\r\n     * @method Str#trimLeft\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft\r\n     * @description Synonym for\r\n     * [String#trimLeft]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft}.\r\n     */\n\n  }, {\n    key: 'trimLeft',\n    value: function trimLeft() {\n      return new Str(this.$.replace(/^[\\s\\ufeff\\u00a0]+/, ''));\n    }\n\n    /**\r\n     * @method Str#trimRight\r\n     * @public\r\n     * @returns {Str} New instance of Str.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight\r\n     * @description Synonym for\r\n     * [String#trimRight]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight}.\r\n     */\n\n  }, {\n    key: 'trimRight',\n    value: function trimRight() {\n      return new Str(this.$.replace(/[\\s\\ufeff\\u00a0]+$/, ''));\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.$.length;\n    }\n  }]);\n  return Str;\n}(Super);\n\ndefineProperties(Str.prototype, defineProperty({}, _Symbol.toStringTag, 'Str'));\n\nconstructors[2].push({\n  check: isString,\n  cls: Str\n});\n\nfunction trim(string) {\n  return string.replace(/^[\\s\\-_.]+|[\\s\\-_.]+$/g, '');\n}\n\n/**\r\n * @function parseJSON\r\n * @public\r\n * @param {String} [json = null] - String to parse.\r\n * @param {Object} [options] - Options.\r\n * @param {Boolean|*} [options.numbers] - If it is needed to parse number-like strings as numbers.\r\n * @param {Boolean|*} [options.dates] - If it is needed to parse date-like string as dates.\r\n * Date-like string is considered to match ^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ?$\r\n * @param {JSONCallback} [callback] - Callback that called on every iteration.\r\n * @returns {DWrap} D-Wrap of found match.\r\n * @description Method for parsing json.\r\n *\r\n * @example\r\n * parseJSON('{ \"a\": 1 }').$;                                           // { a: 1 }\r\n * parseJSON('{ \"a\": \"1\" }', { numbers: true }).$;                      // { numbers: true }\r\n * parseJSON('{ \"a\": \"1999-12-31T23:59:59.999Z\" }', { dates: true }).$; // { a: Date {...} }\r\n */\nfunction parseJSON() {\n  var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var callback = arguments[2];\n\n  if (arguments.length <= 1) {\n    return D$1(JSON.parse(json));\n  }\n\n  if (isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n\n  var _options = options,\n      numbers = _options.numbers,\n      dates = _options.dates;\n\n  var parsed = JSON.parse(json, function (key, value) {\n    if (dates && /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ?$/.test(value)) {\n      value = new Date(value);\n    } else if (numbers && isNumberLike(value) && isString(value)) {\n      value = Number(value);\n    }\n\n    return callback ? callback.apply(this, arguments) : value;\n  });\n\n  return D$1(parsed);\n}\n\n/**\r\n * @module helpers/markupToJSON\r\n * @private\r\n * @description Exports markupToJSON method.\r\n */\n\n/**\r\n * @typedef {Object} MarkupElement\r\n * @property {'comment'|'text'|'element'} type - Type of the node.\r\n * @property {MarkupElement} parent - Type of the node.\r\n * @property {Object.<String, String>} attrs - Node attributes\r\n * @property {MarkupElement[]} children - Node children.\r\n */\n\nvar submitString = 'Please, submit an issue at https://github.com/dwaynejs/dwayne/issues.';\nvar NODE_REGEX_SET = new Super({\n  'tag-open': new RegExp('<(' + htmlAllowedTagSymbols + ')\\\\s*', 'i'),\n  'tag-close': constructCloseTagRegExp(htmlAllowedTagSymbols),\n  comment: /<!--((?:-[^\\->]|[^\\->])(?:-?[^-])*[^-]?|)-->/\n});\nvar TAG_OPEN_CLOSE = /^(\\/?)>/;\n// const ATTRIBUTE = /^([^\\u0000-\\u0020\\s\"'>\\/=]+)(?:\\s*=\\s*('[^']*'|\"[^\"]*\"|[^\\s\"'`<>=]+))?\\s*/;\nvar ATTRIBUTE = new RegExp('^(' + htmlAllowedAttrSymbols + ')(?:\\\\s*=\\\\s*(\\'[^\\']*\\'|\"[^\"]*\"|[^\\\\s\"\\'`<>=]+))?\\\\s*');\nvar div = document.createElement('div');\nvar nodeSwitcher = switcher('strictEquals', function (elem) {\n  return elem;\n}).case('tag-open', function (elem, node) {\n  var _node = node,\n      name = _node.value,\n      selfClosing = _node.selfClosing;\n\n\n  node = {\n    name: name,\n    attrs: new Super(node.attrs).map(function (value) {\n      return parseCharacterData(value);\n    }).$,\n    parent: elem,\n    children: new Arr([])\n  };\n\n  elem.children.push(node);\n\n  if (!selfClosing && voidElements.indexOf(name) === -1) {\n    elem = node;\n  }\n\n  return elem;\n}).case('tag-close', function (elem, node) {\n  if (elem.name === node.value) {\n    elem = elem.parent;\n  }\n\n  return elem;\n}).case(['comment', 'text'], function (elem, node, collapseWhiteSpace, type) {\n  var element = {\n    name: '#' + type,\n    parent: elem,\n    value: node.value\n  };\n\n  if (type === 'text' && elem.name !== 'script' && elem.name !== 'style') {\n    element.value = parseCharacterData(element.value);\n\n    if (collapseWhiteSpace) {\n      element.value = new Str(element.value).trim().$;\n    }\n  }\n\n  if (!collapseWhiteSpace || !/^\\s*$/.test(element.value)) {\n    elem.children.push(element);\n  }\n\n  return elem;\n});\nvar rawTextSwitcher = switcher('strictEquals', false).case(['title', 'textarea', 'style', 'script'], true);\n\nvar InternalParsingError = function InternalParsingError(index) {\n  classCallCheck(this, InternalParsingError);\n\n  this.index = index;\n};\n\nvar ParsingError = function (_Error) {\n  inherits(ParsingError, _Error);\n\n  function ParsingError() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParsingError);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParsingError.__proto__ || Object.getPrototypeOf(ParsingError)).call.apply(_ref, [this].concat(args))), _this), _this.type = 'PARSING_ERROR', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  return ParsingError;\n}(Error);\n\n/**\r\n * @function markupToJSON\r\n * @private\r\n * @param {String} markup - Markup to parse to JSON.\r\n * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be collapsed.\r\n * @returns {Arr.<MarkupElement>} Markup elements array.\r\n * @description Function for parsing html and xml to JSON.\r\n */\n\n\nvar markupToJSON = (function (markup, collapseWhiteSpace) {\n  collapseWhiteSpace = !!collapseWhiteSpace;\n\n  var elements = new Arr([]);\n  var startMarkup = markup;\n  var found = void 0;\n  var globalIndex = 0;\n  var elem = {\n    name: null,\n    children: elements\n  };\n\n  while (markup.length) {\n    try {\n      found = find$1(markup, elem);\n    } catch (err) {\n      if (!(err instanceof InternalParsingError)) {\n        throwUnexpectedError();\n      }\n\n      throw new ParsingError('Parsing error near index ' + nearString(startMarkup, globalIndex + err.index));\n    }\n\n    var _found = found,\n        type = _found.type,\n        attrs = _found.attrs,\n        selfClosing = _found.selfClosing,\n        index = _found.index,\n        value = _found.value;\n\n\n    globalIndex += index;\n\n    if (!index) {\n      throwUnexpectedError();\n    }\n\n    var node = {\n      type: type,\n      value: value\n    };\n\n    if (type === 'tag-open') {\n      node.attrs = attrs;\n      node.selfClosing = selfClosing;\n    }\n\n    elem = nodeSwitcher(node.type, [elem, node, collapseWhiteSpace]);\n\n    markup = markup.slice(index);\n  }\n\n  return elements;\n\n  function throwUnexpectedError() {\n    throw new ParsingError('Unexpected parsing error near index ' + nearString(startMarkup, globalIndex) + '. ' + submitString);\n  }\n});\n\nfunction find$1(markup, elem) {\n  var name = elem.name;\n\n  var matches = void 0;\n\n  if (rawTextSwitcher(name)) {\n    matches = new Super({\n      'tag-close': markup.match(constructCloseTagRegExp(name))\n    });\n  } else {\n    matches = NODE_REGEX_SET.map(function (regex) {\n      return markup.match(regex);\n    });\n  }\n\n  var match = void 0;\n\n  if (match = matches.find(function (match) {\n    return match && match.index === 0;\n  })) {\n    var returning = {\n      type: match.key,\n      index: match.value[0].length,\n      value: match.value[1]\n    };\n    var attrs = {};\n\n    if (match.key === 'tag-open') {\n      var startMarkup = markup;\n      var closeMatch = void 0;\n\n      returning.selfClosing = false;\n      returning.attrs = attrs;\n\n      while ((markup = startMarkup.slice(returning.index)) && !(closeMatch = markup.match(TAG_OPEN_CLOSE))) {\n        var attr = markup.match(ATTRIBUTE);\n\n        if (!attr) {\n          returning.index += 1;\n\n          continue;\n        }\n\n        attrs[attr[1]] = (attr[2] || '').replace(/^(\"|')|(\"|')$/g, '');\n        returning.index += attr[0].length;\n      }\n\n      if (closeMatch) {\n        returning.index += closeMatch[0].length;\n        returning.selfClosing = !!closeMatch[1];\n      }\n    }\n\n    return returning;\n  }\n\n  var _matches$min = matches.min(function (match) {\n    return match ? match.index : NaN;\n  }),\n      index = _matches$min.value;\n\n  if (index === Infinity) {\n    index = markup.length;\n  }\n\n  return {\n    type: 'text',\n    index: index,\n    value: markup.slice(0, index)\n  };\n}\n\nfunction constructCloseTagRegExp(tagName) {\n  return new RegExp('</(' + tagName + ')\\\\s*>', 'i');\n}\n\nfunction nearString(markup, index) {\n  return index + ' (~~~ \"' + markup.slice(index, index + 15) + '\" ~~~, the string itself is \"' + markup + '\")';\n}\n\nfunction parseCharacterData(string) {\n  return string.replace(/&(\\w+|#x?\\d+);/g, function (match) {\n    div.innerHTML = match;\n\n    return div.textContent || div.innerText;\n  });\n}\n\n/**\r\n * @module Elem\r\n * @private\r\n * @mixin\r\n * @description Exports Elem class.\r\n */\n\n/**\r\n * @typedef {String} ElemEventString\r\n * @public\r\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\r\n */\n\n/**\r\n * @callback ElemValueCallback\r\n * @public\r\n * @param {String} value - Old value.\r\n * @param {Elem} elem - Current element.\r\n * @param {Number} index - Index in the set of the elements.\r\n */\n\n/**\r\n * @callback ElemSetOfCallback\r\n * @public\r\n * @param {Element} created - Created element.\r\n * @param {*} value - Value of the iterated element in the object.\r\n * @param {Key} key - Key of the iterated element in the object.\r\n * @param {*} object - Object that is iterated over.\r\n * @param {Element} elem - Current element.\r\n * @param {Number} index - Index of the current element.\r\n */\n\n/**\r\n * @callback ValidateCallback\r\n * @public\r\n * @param {*} value - Element value.\r\n * @param {Element} elem - Element to validate.\r\n * @param {Number} index - Index of the element.\r\n */\n\n/**\r\n * @callback CtxCallback\r\n * @public\r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context.\r\n */\n\n/**\r\n * @callback ElemListener\r\n * @public\r\n * @param {Event} e - Fired event.\r\n * @param {Element} elem - Element on which the listener was called.\r\n * @param {Number} index - Index of the element on which the listener was called.\r\n */\n\n/**\r\n * @callback ElemRemoveListeners\r\n * @public\r\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\r\n * by the events in the arguments.\r\n */\n\nvar nativeDocument = global$1.document;\nvar emptyDiv = nativeDocument.createElement('div');\nvar eventSeparator = /(,| ) */;\nvar textProperty = new Super(Node.prototype).propertyDescriptor('textContent') ? 'textContent' : 'innerText';\nvar classes = {};\nvar attrs = {};\nvar windowsDwayneData = new Arr([]);\nvar inputElements = 'input, select, textarea, datalist, keygen, output';\nvar click$1 = method('click');\nvar svgNS$1 = 'http://www.w3.org/2000/svg';\nvar xmlNS = 'http://www.w3.org/2000/xmlns/';\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xhtmlNS = 'http://www.w3.org/1999/xhtml';\nvar typeSwitcher = switcher('call', function (elem, type) {\n  var ns = type === 'svg' ? svgNS$1 : elem.prop('namespaceURI') || nativeDocument.documentElement.namespaceURI || xhtmlNS;\n\n  return nativeDocument.createElementNS(ns, type);\n}).case(function (type) {\n  return type === '#comment';\n}, function () {\n  return nativeDocument.createComment('');\n}).case(function (type) {\n  return type === '#text';\n}, function () {\n  return nativeDocument.createTextNode('');\n});\nvar refSwitcher = switcher('strictEquals', 'href').case(['img', 'script', 'iframe', 'audio', 'video'], 'src').case('form', 'action');\nvar filterSwitcher = switcher('call', function (selector) {\n  return selector;\n}).case(isString, function (selector) {\n  return function (elem) {\n    return new Elem(elem).is(selector);\n  };\n}).case([isArray, isElem], function (elems) {\n  elems = new Arr(elems);\n\n  return function (elem) {\n    return elems.indexOf(elem) !== -1;\n  };\n});\nvar innerSwitcher = switcher('strictEquals', 0).case('padding-box', function (paddings) {\n  return paddings;\n}).case('border-box', function (paddings, borders) {\n  return paddings + borders;\n});\nvar outerSwitcher = switcher('strictEquals', function (borders, paddings) {\n  return borders + paddings;\n}).case('padding-box', function (borders) {\n  return borders;\n}).case('border-box', 0);\nvar attrNSSwitcher = switcher('call', null).case(function (attr) {\n  return attr === 'xmlns' || attr === 'xmlns:xlink';\n}, function (elem) {\n  return elem.name === 'svg' ? xmlNS : null;\n}).case(function (attr) {\n  return (/^xlink:\\w/.test(attr)\n  );\n}, function (elem) {\n  return elem.closest('svg').length ? xlinkNS : null;\n});\n\n/**\r\n * @class Elem\r\n * @extends Arr\r\n * @public\r\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\r\n * @returns {Elem} Instance of Elem.\r\n * @description Wrap of an elements set. Also has all methods from from\r\n * [CanvasRenderingContext2D]{@link https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D}.\r\n * Getters methods return the same as methods from CanvasRenderingContext2D and the rest return this.\r\n * Work for the first canvas element in the set.\r\n *\r\n * @example\r\n * new Elem(document.body);\r\n * new Elem(document.querySelectorAll('.cls'));\r\n * new Elem(document.getElementsByClassName('cls'));\r\n */\n\nvar Elem = function (_Arr) {\n  inherits(Elem, _Arr);\n\n  function Elem() {\n    var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, Elem);\n\n    var _this = possibleConstructorReturn(this, (Elem.__proto__ || Object.getPrototypeOf(Elem)).call(this, function () {\n      var element = elem;\n\n      if (isArrayLike(element) && (isWindow(element) || isHTMLDocument(element) || isDocumentFragment(element) || isElement(element) || isCommentOrText(element) || isStyleRule(element))) {\n        element = [element];\n      }\n\n      return new Arr(toArray$1(new Super(element).$, true)).object(function (elems, elem) {\n        if (elems.indexOf(elem) === -1 && (isElement(elem) || isWindow(elem) || isHTMLDocument(elem) || isDocumentFragment(elem) || isCommentOrText(elem) || isStyleRule(elem))) {\n          return elems.push(elem);\n        }\n\n        if (isElem(elem)) {\n          elems.push.apply(elems, elem.$);\n        }\n      }, []).$;\n    }()));\n\n    _this.$$ = elem;\n\n    _this.forEach(addDwayneData);\n\n    /**\r\n     * @member {Array.<Node|Window>} Elem#$\r\n     * @type {Array.<Node|Window>}\r\n     * @public\r\n     * @description Constructed element set.\r\n     */\n\n    /**\r\n     * @member {*} Elem#$$\r\n     * @type {*}\r\n     * @public\r\n     * @description Initial element set.\r\n     */\n    return _this;\n  }\n\n  /**\r\n   * @method Elem#add\r\n   * @public\r\n   * @param {...(String|Elem|Element|Element[])} elements - Each argument is a selector, or Elem, or Element, or array of Elements.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding new elements to the set.\r\n   *\r\n   * @example\r\n   * elem1.find('.cls1')\r\n   *   .add(elem2.find('.cls2'))\r\n   *   .hide();\r\n   */\n\n\n  createClass(Elem, [{\n    key: 'add',\n    value: function add() {\n      var _this2 = this;\n\n      for (var _len = arguments.length, elements = Array(_len), _key = 0; _key < _len; _key++) {\n        elements[_key] = arguments[_key];\n      }\n\n      iterate(arguments, function (elem) {\n        toFind(elem).forEach(function (elem) {\n          if (_this2.indexOf(elem) === -1) {\n            _this2.push(elem);\n          }\n        });\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#addClass\r\n     * @public\r\n     * @param {...String} classes - Classes to add.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for adding classes to the all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.addClass('red', 'round');\r\n     */\n\n  }, {\n    key: 'addClass',\n    value: function addClass() {\n      var _arguments = arguments;\n\n      for (var _len2 = arguments.length, classes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        classes[_key2] = arguments[_key2];\n      }\n\n      return this.forEach(function (elem) {\n        var list = elem.classList;\n\n        iterate(isElement(elem) && _arguments, function (cls) {\n          return list.add(cls);\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#addComment\r\n     * @public\r\n     * @param {String} text - Text of comment to add.\r\n     * @param {Boolean} end - If the comment should be inserted to the end. If false it's inserted to the start.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for adding comment to all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.addHTML('<div>1</div>');\r\n     */\n\n  }, {\n    key: 'addComment',\n    value: function addComment(text) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', '<!--' + text + '-->');\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#addHTML\r\n     * @public\r\n     * @param {String} html - HTML to add.\r\n     * @param {Boolean} end - If the HTML should be inserted to the end. If false it's inserted to the start.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for adding HTML to all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.addHTML('<div>1</div>');\r\n     */\n\n  }, {\n    key: 'addHTML',\n    value: function addHTML(html) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', html);\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#addRule\r\n     * @public\r\n     * @param {String} name - Name of the rule.\r\n     * @param {String} selector - Selector for the rule\r\n     * @param {Object.<String, String>} style - Style for the selector.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for adding css styles into the first style tag in the set.\r\n     * Note: style element should be inside the document.\r\n     *\r\n     * @example\r\n     * style.addRule('img-size', 'img.square', {\r\n     *   width: '40px !important',\r\n     *   height: '40px !important'\r\n     * });\r\n     */\n\n  }, {\n    key: 'addRule',\n    value: function addRule(name, selector, style) {\n      this.some(function (elem) {\n        if (getName(elem) === 'style') {\n          var sheet = elem.sheet;\n          var length = sheet.cssRules.length;\n\n          var rules = new Super(style).word(function (value, property) {\n            return new Str(property).toHyphenCase() + ': ' + value + ';\\n';\n          });\n\n          sheet.insertRule(selector + ' {' + (rules && '\\n') + rules + '}', length);\n          sheet.cssRules[length].dwayneData = { name: name };\n\n          return true;\n        }\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#addText\r\n     * @public\r\n     * @param {String} text - Text to add.\r\n     * @param {Boolean} end - If the text should be inserted to the end. If false it's inserted to the start.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for adding text to all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.addText('123');\r\n     */\n\n  }, {\n    key: 'addText',\n    value: function addText(text) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return this.forEach(function (elem) {\n        new Elem(nativeDocument.createTextNode(text)).into(elem, end);\n      });\n    }\n\n    /**\r\n     * @method Elem#apply\r\n     * @public\r\n     * @param {...String} strings - Strings to apply.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method that is a shorthand for many other methods.\r\n     * All shorthands can be separated with space and written within one string.\r\n     *\r\n     * @example\r\n     * elem.apply(\r\n     *   '#id .c1 .c2 @border(1px solid black) $disabled $attr(some value) *(Click me!)'\r\n     * );\r\n     * // shorthand for\r\n     * // elem\r\n     * //   .id('id')\r\n     * //   .addClass('c1', 'c2')\r\n     * //   .css('border', '1px solid black')\r\n     * //   .attr({\r\n     * //     attr, 'some value'\r\n     * //     disabled: ''\r\n     * //   })\r\n     * //   .text('Click me!');\r\n     * // There is a full list of possible types of syntax below...\r\n     *\r\n     * elem.apply('#id');                    // shorthand for elem.id('id');\r\n     * elem.apply('.c1 .c2');                // shorthand for elem.addClass('c1', 'c2');\r\n     * elem.apply('-.c1 -.c2');              // shorthand for elem.removeClass('c1', 'c2');\r\n     * elem.apply('-@float -@display');      // shorthand for elem.removeCSS('float', 'display');\r\n     * elem.apply('-$a1 -$a2');              // shorthand for elem.removeAttr('a1', 'a2');\r\n     * elem.apply('*(some text)');           // shorthand for elem.text('some text');\r\n     * elem.apply('&(<div>1</div>)');        // shorthand for elem.html('<div>1</div>');\r\n     * elem.apply('@float(right)');          // shorthand for elem.css('float', 'right');\r\n     * elem.apply('@transform(scale(5px))'); // shorthand for elem.css('transform', 'scale(5px)');\r\n     * elem.apply('@margin(2px 2px)');       // shorthand for elem.css('margin', '2px 2px');\r\n     * elem.apply('@marginLeft(2px)');       // shorthand for elem.css('marginLeft', '2px 2px');\r\n     * elem.apply('@margin-left(2px)');      // shorthand for elem.css('margin-left', '2px 2px');\r\n     * elem.apply('$attr(some value)');      // shorthand for elem.attr('attr', 'some value');\r\n     * elem.apply('$attr');                  // shorthand for elem.attr('attr', '');\r\n     */\n\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var _this3 = this;\n\n      for (var _len3 = arguments.length, strings = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        strings[_key3] = arguments[_key3];\n      }\n\n      var applied = void 0;\n      var setApplied = void 0;\n      var callback = void 0;\n      var name = void 0;\n      var np1 = void 0;\n      var slice = void 0;\n\n      new Str(new Arr(arguments).join(' ')).split(/(\\s+)/).forEach(function (string) {\n        if (!applied) {\n          np1 = string.slice(0, 1);\n          callback = appliedRegExps[np1];\n          slice = 1;\n\n          if (callback && !isFunction(callback)) {\n            callback = callback[string.slice(1, 2)];\n            slice = 2;\n          }\n\n          if (/^\\s+$/.test(string) || !callback) {\n            return;\n          }\n\n          name = string.slice(slice).match(/^[^()]+/);\n\n          if (!name && np1 !== '*' && np1 !== '&') {\n            return;\n          }\n\n          applied = {\n            name: name ? name[0] : '',\n            args: string.slice(slice + (name ? name[0] : '').length),\n            callback: callback\n          };\n\n          setApplied = true;\n        }\n\n        if (!setApplied) {\n          applied.args += string;\n        }\n\n        if (!applied.args || /^\\([\\s\\S]+\\)$/.test(applied.args)) {\n          applied.callback(_this3, applied.name, applied.args.replace(/^\\(|\\)$/g, ''));\n          applied = null;\n        }\n\n        setApplied = false;\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#attr\r\n     * @public\r\n     * @param {String|Object.<String, String|ElemValueCallback>} [attr] - Name of the attribute to get or\r\n     * an object of the format { [attrName]: value, ... } to set attributes.\r\n     * @param {String|ElemValueCallback} [value] - If the first argument is a string\r\n     * it should be a value to set for that attribute.\r\n     * @returns {Super|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\r\n     * returned, if 1 string argument is passed the value of the attribute of the first element in the set\r\n     * returned otherwise returns this.\r\n     * @description Method for getting/setting attributes.\r\n     *\r\n     * @example\r\n     * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\r\n     * elem.attr('attr1');           // 'value1'\r\n     * elem.attr({\r\n     *   attr1: 'value3',            // attribute attr1 set to 'value3'\r\n     *   attr2: 'value2'             // attribute attr2 set to 'value2'\r\n     * });                           // this returned\r\n     * elem.attr().$;                // { attr1: 'value3', attr2: 'value2' }\r\n     */\n\n  }, {\n    key: 'attr',\n    value: function attr(_attr, value) {\n      var elem = getElem(this);\n\n      if (!arguments.length) {\n        return new Super(elem.attributes).object(function (o, attr) {\n          o[attr.name] = attr.value;\n        });\n      }\n\n      if (arguments.length <= 1 && isString(_attr)) {\n        var ns = attrNSSwitcher(_attr, [new Elem(elem)]);\n\n        return isNull(ns) ? elem.getAttribute(_attr) : elem.getAttributeNS(ns, _attr);\n      }\n\n      if (arguments.length >= 2) {\n        _attr = defineProperty({}, _attr, value);\n      }\n\n      return this.forEach(function (elem, index) {\n        if (!isElement(elem)) {\n          return;\n        }\n\n        new Super(_attr).forEach(function (value, key) {\n          value = isFunction(value) ? value(new Elem(elem).attr(key), elem, index) : value;\n\n          if (isNil(value)) {\n            return new Elem(elem).removeAttr(key);\n          }\n\n          var ns = attrNSSwitcher(key, [new Elem(elem)]);\n\n          if (isNull(ns)) {\n            elem.setAttribute(key, value);\n          } else {\n            elem.setAttributeNS(ns, key, value);\n          }\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#blob\r\n     * @public\r\n     * @param {Object} [options = {}] - Options that are passed into {@link blob}.\r\n     * @returns {Promise.<BlobObject>} New instance of promise.\r\n     * @description Returns a {@link BlobObject} Promise. Works with image or canvas first element.\r\n     *\r\n     * @example\r\n     * image.blob().then((blob) => console.log(blob));  // BlobObject\r\n     * canvas.blob().then((blob) => console.log(blob)); // BlobObject\r\n     */\n\n  }, {\n    key: 'blob',\n    value: function blob() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return new Promise$1(function (resolve, reject) {\n        var elem = _this4.first();\n        var name = elem.name;\n\n\n        if (name !== 'img' && name !== 'canvas') {\n          reject(new Error('First element in the set isn\\'t an image or a canvas! (Elem#blob)'));\n        }\n\n        if (name === 'canvas') {\n          return resolve(elem);\n        }\n\n        elem.load().then(function () {\n          if (elem.isBroken()) {\n            return reject(new Error('The image is broken! (Elem#blob)'));\n          }\n\n          var canvas = new Elem(nativeDocument).canvas();\n          var width = elem.width();\n          var height = elem.height();\n\n          canvas.width(width).height(height).drawImage(elem.$[0], 0, 0);\n\n          resolve(canvas);\n        });\n      }).then(function (canvas) {\n        var dataURL = canvas.dataURL();\n        var byteString = atob(dataURL.split(',')[1]);\n        var length = byteString.length;\n        var ab = new ArrayBuffer(length);\n        var ia = new Uint8Array(ab);\n\n        iterate$1(length, function (i) {\n          ia[i] = byteString.charCodeAt(i);\n        });\n\n        return blob$1(ab, options);\n      });\n    }\n\n    /**\r\n     * @method Elem#blur\r\n     * @returns {Elem} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur\r\n     * @description Synonym for\r\n     * [HTMLElement#blur]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur}.\r\n     */\n\n  }, {\n    key: 'blur',\n    value: function blur() {\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.blur();\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#calcCSS\r\n     * @param {String} [pseudo] - See the link.\r\n     * @returns {CSSStyleDeclaration} See the link.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle\r\n     * @description Synonym for\r\n     * [getComputedStyle]{@link https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle}.\r\n     * Returns computed style for the first element in the set or undefined.\r\n     */\n\n  }, {\n    key: 'calcCSS',\n    value: function calcCSS() {\n      var pseudo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return getComputedStyle(getElem(this), pseudo);\n    }\n\n    /**\r\n     * @method Elem#changeRule\r\n     * @public\r\n     * @param {String} name - Name of the rule.\r\n     * @param {Object.<String, String>} style - Style for the selector.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for changing css styles in the first style tag in the set.\r\n     * Note: style element should be inside the document.\r\n     *\r\n     * @example\r\n     * style.changeRule('img-size', {\r\n     *   width: '50px !important',\r\n     *   height: '50px !important'\r\n     * });\r\n     */\n\n  }, {\n    key: 'changeRule',\n    value: function changeRule(name, style) {\n      this.some(function (elem) {\n        if (getName(elem) === 'style') {\n          var _ref = new Arr(elem.sheet.cssRules).find(function (rule) {\n            return rule.dwayneData && rule.dwayneData.name === name;\n          }) || {},\n              rule = _ref.value;\n\n          if (rule) {\n            new Elem(rule).css(style);\n\n            return true;\n          }\n        }\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#child\r\n     * @public\r\n     * @param {Number|String|Elem|Element|Element[]} element - If the argument is a number a wrap of the set of the children\r\n     * of this index of each element in the set returned otherwise an element to put into this element, a collection\r\n     * or a selector of it.\r\n     * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\r\n     * @returns {Elem} Returns a wrap of children or inserted elements.\r\n     * @description Method is similar to\r\n     * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\r\n     *\r\n     * @example\r\n     * const child = elem.child(1);\r\n     *\r\n     * elem.child(elem2);\r\n     * elem.child(document.getElementById('id'));\r\n     * elem.child('#id div.c1');\r\n     */\n\n  }, {\n    key: 'child',\n    value: function child(element) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (isInteger(element) && element >= 0) {\n        return this.children().elem(element);\n      }\n\n      return toFind(element).into(this, end);\n    }\n\n    /**\r\n     * @method Elem#children\r\n     * @public\r\n     * @returns {Elem} D-Wrap of the children of the first element in the set.\r\n     * @description Method for getting element's children.\r\n     *\r\n     * @example\r\n     * const children = elem.children();\r\n     */\n\n  }, {\n    key: 'children',\n    value: function children() {\n      return new Elem(this.length ? this.$[0].childNodes : []);\n    }\n\n    /**\r\n     * @method Elem#class\r\n     * @public\r\n     * @param {String} [cls] - If it's present it has to contain class attribute to set.\r\n     * @returns {Arr|Elem} If the argument is present this returned otherwise a wrap of the classes array returned.\r\n     * @description Method for getting/setting classes.\r\n     *\r\n     * @example\r\n     * elem.class('c1 c2'); // class set to 'c1 c2'\r\n     * elem.class().$;      // ['c1', 'c2']\r\n     */\n\n  }, {\n    key: 'class',\n    value: function _class(cls) {\n      if (!arguments.length) {\n        return new Arr(getElem(this).className.split(' '));\n      }\n\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.className = cls;\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#click\r\n     * @returns {Elem} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click\r\n     * @description Synonym for\r\n     * [HTMLElement#click]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click}.\r\n     */\n\n  }, {\n    key: 'click',\n    value: function click$1() {\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.click();\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#clone\r\n     * @public\r\n     * @param {Boolean|*} [deep = false] - See thee link.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode\r\n     * @description Synonym for\r\n     * [Node#cloneNode]{@link https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode}.\r\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      return this.object(function (elems, elem) {\n        elems.add(elem.cloneNode(!!deep));\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#closest\r\n     * @public\r\n     * @param {String} selector - See the link.\r\n     * @returns {Elem} Set of the closest elements.\r\n     * @description Synonym for\r\n     * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\r\n     */\n\n  }, {\n    key: 'closest',\n    value: function closest(selector) {\n      return this.object(function (elems, elem) {\n        while (elem) {\n          if (new Elem(elem).is(selector)) {\n            return elems.add(elem);\n          }\n\n          elem = elem.parentNode;\n        }\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#contains\r\n     * @public\r\n     * @param {String|Elem|Element} element - Element to find out if it's within the first element\r\n     * in the set or a selector of it.\r\n     * @returns {Boolean} Returns if the argument within this element.\r\n     * @description Method is extension for\r\n     * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\r\n     *\r\n     * @example\r\n     * elem1.contains(elem2);   // true|false\r\n     * elem.contains(selector); // true|false\r\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(element) {\n      element = toFind(element);\n\n      return getElem(this).contains(getElem(element));\n    }\n\n    /**\r\n     * @method Elem#create\r\n     * @public\r\n     * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\r\n     * If type is \"#comment\" a comment node is created.\r\n     * @param {...String} appliedExpressions - Strings that are passed into {@link Elem#apply}.\r\n     * @returns {Elem} New instance of Elem - wrap of the created elements.\r\n     * @description Method for creating elements inside this element.\r\n     * If this element is not an Element the element is just created.\r\n     *\r\n     * @example\r\n     * elem.create('div', '#id .c1 .c2 *Some text*');\r\n     *\r\n     * // also there are shorthands for almost every HTML-element\r\n     * elem.div();\r\n     * elem.input('$type(checkbox) $name(country)');\r\n     */\n\n  }, {\n    key: 'create',\n    value: function create(type) {\n      for (var _len4 = arguments.length, appliedExpressions = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        appliedExpressions[_key4 - 1] = arguments[_key4];\n      }\n\n      return this.object(function (elems, elem) {\n        var element = new Elem(typeSwitcher(type, [new Elem(elem)]));\n\n        element.into(elem);\n\n        elems.add(element.apply.apply(element, appliedExpressions));\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#createComment\r\n     * @public\r\n     * @param {String} text - Text of the comment.\r\n     * @returns {Elem} New instance of Elem - wrap of the created comments.\r\n     * @description Method for creating comments inside this element.\r\n     * If this element is not an Element the comment is just created.\r\n     *\r\n     * @example\r\n     * elem.createComment('comment');\r\n     */\n\n  }, {\n    key: 'createComment',\n    value: function createComment(text) {\n      return this.create('#comment').text(text);\n    }\n\n    /**\r\n     * @method Elem#createText\r\n     * @public\r\n     * @param {String} text - Text.\r\n     * @returns {Elem} New instance of Elem - wrap of the created text nodes.\r\n     * @description Method for creating text nodes inside this element.\r\n     * If this element is not an Element the text node is just created.\r\n     *\r\n     * @example\r\n     * elem.createText('text');\r\n     */\n\n  }, {\n    key: 'createText',\n    value: function createText(text) {\n      return this.create('#text').text(text);\n    }\n\n    /**\r\n     * @method Elem#css\r\n     * @public\r\n     * @param {String|Object.<String, String|ElemValueCallback>} [property] - Name of the property to get or\r\n     * an object of the format { [property]: value, ... } to set styles.\r\n     * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that property.\r\n     * @returns {Super|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\r\n     * if 1 string argument is passed the value of the property returned otherwise returns this.\r\n     * @description Method for getting/setting styles. Supports !important.\r\n     *\r\n     * @example\r\n     * elem.css('display', 'none'); // display set to 'none' and this returned\r\n     * elem.css('display');         // 'none'\r\n     * elem.css({\r\n     *   display: 'inline',         // display set to 'inline'\r\n     *   cursor: 'pointer'          // cursor set to 'pointer'\r\n     * });                          // this returned\r\n     * elem.css().$;                // { display: 'none', cursor: 'pointer' }\r\n     */\n\n  }, {\n    key: 'css',\n    value: function css(property, value) {\n      var style = getElem(this).style;\n\n      if (isStyleRule(this.$[0])) {\n        style = this.$[0].style;\n      }\n\n      if (!arguments.length) {\n        return new Str(style.cssText).split(/; ?/).object(function (o, value) {\n          if (value) {\n            property = value.split(/: /);\n\n            o[new Str(property[0]).toCamelCase().$] = property[1];\n          }\n        });\n      }\n\n      if (arguments.length <= 1 && isString(property)) {\n        property = new Str(property).toHyphenCase().$;\n\n        return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n      }\n\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, value);\n      }\n\n      return this.forEach(function (elem, index) {\n        if (!isElement(elem) && !isStyleRule(elem)) {\n          return;\n        }\n\n        new Super(property).forEach(function (value, property) {\n          property = new Str(property).toHyphenCase().$;\n\n          if (isFunction(value)) {\n            value = value(new Elem(elem).css(property), elem, index);\n          }\n\n          elem.style.removeProperty(property);\n          elem.style.setProperty(property, value.replace(/ ?!important$/, ''), /!important$/.test(value) ? 'important' : '');\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#ctx\r\n     * @public\r\n     * @param {String|Object|CtxCallback} [property] - If present and object\r\n     * it's assigned to the canvas rendering context, if function\r\n     * it's called with canvas rendering context argument, if string\r\n     * the value from the second argument is used for assigning\r\n     * this property to canvas rendering context and if not present\r\n     * canvas rendering context returned.\r\n     * @param {*} [value] - See the property argument.\r\n     * @returns {CanvasRenderingContext2D|Elem}\r\n     * @description Rendering context of the first canvas in the set.\r\n     *\r\n     * @example\r\n     * canvas.ctx; // CanvasRenderingContext2D\r\n     */\n\n  }, {\n    key: 'ctx',\n    value: function ctx(property, value) {\n      var ctx = void 0;\n\n      this.some(function (elem) {\n        if (getName(elem) === 'canvas') {\n          ctx = elem.dwayneData.ctx;\n\n          return true;\n        }\n      });\n\n      if (!arguments.length) {\n        return ctx;\n      }\n\n      if (!ctx) {\n        return this;\n      }\n\n      if (isFunction(property)) {\n        property(ctx);\n      } else {\n        if (arguments.length >= 2) {\n          property = defineProperty({}, property, value);\n        }\n\n        assign$1(ctx, property);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#data\r\n     * @public\r\n     * @param {String|Object.<String, String|ElemValueCallback>} [key] - Name of the data attribute (without data- prefix)\r\n     * to get or an object of the format { [attrName]: value, ... } to set attributes.\r\n     * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that attribute.\r\n     * @returns {Super|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\r\n     * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\r\n     * @description Method for getting/setting data attributes. See\r\n     * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\r\n     *\r\n     * @example\r\n     * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\r\n     * elem.data('someKey1');          // 'value1'\r\n     * elem.data({\r\n     *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\r\n     *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\r\n     * });                             // this returned\r\n     * elem.data().$;                  // { someKey1: 'value3', someKey2: 'value2' }\r\n     */\n\n  }, {\n    key: 'data',\n    value: function data(key, value) {\n      var dataset = getElem(this).dataset;\n\n      if (!arguments.length) {\n        return new Super(dataset).object(function (o, value, key) {\n          o[key] = value;\n        });\n      }\n\n      if (arguments.length === 1 && isString(key)) {\n        return dataset[key];\n      }\n\n      if (arguments.length >= 2) {\n        key = defineProperty({}, key, value);\n      }\n\n      return this.forEach(function (elem, index) {\n        if (!isElement(elem)) {\n          return;\n        }\n\n        iterate(key, function (value, key) {\n          elem.dataset[key] = isFunction(value) ? value(elem.dataset[key], elem, index) : value;\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#dataURL\r\n     * @param {String} [type = 'image/png'] - See the link\r\n     * @param {Number} [encoderOptions = 0.92] - See the link.\r\n     * @returns {String} Data URL for the first canvas element in the set.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL\r\n     * @description Synonym for\r\n     * [HTMLCanvasElement#toDataURL]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL}.\r\n     *\r\n     * @example\r\n     * canvas.dataURL();\r\n     */\n\n  }, {\n    key: 'dataURL',\n    value: function dataURL(type, encoderOptions) {\n      var ctx = this.ctx();\n\n      if (!ctx) {\n        return '';\n      }\n\n      return ctx.canvas.toDataURL.apply(ctx.canvas, arguments);\n    }\n\n    /**\r\n     * @method Elem#deleteRule\r\n     * @public\r\n     * @param {String} name - Name of the rule.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for deleting css styles in a style tag.\r\n     * Note: style element should be inside the document.\r\n     *\r\n     * @example\r\n     * style.deleteRule('img-size');\r\n     */\n\n  }, {\n    key: 'deleteRule',\n    value: function deleteRule(name) {\n      this.some(function (elem) {\n        if (getName(elem) === 'style') {\n          var rule = new Arr(elem.sheet.cssRules).find(function (rule) {\n            return rule.dwayneData && rule.dwayneData.name === name;\n          });\n\n          if (rule) {\n            elem.sheet.deleteRule(rule.key);\n\n            return true;\n          }\n        }\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#dispatch\r\n     * @public\r\n     * @param {String|Event} event - Event or a string (new Event(event) is created).\r\n     * @param {Object} [eventInit = {}] - See the link.\r\n     * @param {Boolean} [eventInit.bubbles = true] - See the link.\r\n     * @param {Boolean} [eventInit.cancelable = true] - See the link.\r\n     * @param {Object} [details = {}] - Object that is assigned to the event.\r\n     * @returns {Elem} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\r\n     * @description Synonym for\r\n     * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\r\n     *\r\n     * @example\r\n     * elem.dispatch('click');\r\n     * elem.dispatch('click', { bubbles: false, cancellable: false });\r\n     * elem.dispatch(new CustomEvent('custom-event'));\r\n     */\n\n  }, {\n    key: 'dispatch',\n    value: function dispatch(event) {\n      var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _ref2 = eventInit || {},\n          _ref2$bubbles = _ref2.bubbles,\n          bubbles = _ref2$bubbles === undefined ? true : _ref2$bubbles,\n          _ref2$cancelable = _ref2.cancelable,\n          cancelable = _ref2$cancelable === undefined ? true : _ref2$cancelable;\n\n      var finalEvent = event;\n\n      if (!/Event$/.test(toStringTag(finalEvent))) {\n        try {\n          finalEvent = new Event(finalEvent, { bubbles: bubbles, cancelable: cancelable });\n        } catch (err) {\n          finalEvent = nativeDocument.createEvent('Event');\n          finalEvent.initEvent(event, bubbles, cancelable);\n        }\n\n        assign$1(finalEvent, details);\n      }\n\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.dispatchEvent(finalEvent);\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#elem\r\n     * @public\r\n     * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\r\n     * @returns {Elem} New instance of Elem.\r\n     *\r\n     * @example\r\n     * elem.elem(1); // a wrap of the element in the set that has index 1\r\n     * elem.elem();  // a wrap of the element in the set that has index 0\r\n     */\n\n  }, {\n    key: 'elem',\n    value: function elem() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (index < 0) {\n        index = this.length + index;\n      }\n\n      return new Elem(this.$[index]);\n    }\n\n    /**\r\n     * @method Elem#filter\r\n     * @public\r\n     * @param {String|Function|Element[]|Elem} [selector = Boolean] - If it's a string the method filters elements with the selector\r\n     * otherwise super.filter is called.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Method for filtering elements.\r\n     *\r\n     * @example\r\n     * elem.filter((elem) => new Elem(elem).closest('.parent'));\r\n     * elem.filter(elemsInArray);\r\n     * elem.filter(elemsInElem);\r\n     * elem.filter('.child');\r\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Boolean;\n\n      return new Elem(get$1(Elem.prototype.__proto__ || Object.getPrototypeOf(Elem.prototype), 'filter', this).call(this, filterSwitcher(selector)));\n    }\n\n    /**\r\n     * @method Elem#find\r\n     * @public\r\n     * @param {String|Function} selector - Selector to find.\r\n     * @returns {Elem|{ key: Key, value: * }|null} New instance of Elem if selector is a string\r\n     * otherwise super.find is called.\r\n     * @description Synonym for\r\n     * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\r\n     */\n\n  }, {\n    key: 'find',\n    value: function find(selector) {\n      if (!isString(selector)) {\n        return get$1(Elem.prototype.__proto__ || Object.getPrototypeOf(Elem.prototype), 'find', this).call(this, selector);\n      }\n\n      return this.object(function (elems, elem) {\n        elems.add(_find(selector, elem));\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#first\r\n     * @public\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Synonym for elem.elem(0).\r\n     */\n\n  }, {\n    key: 'first',\n    value: function first() {\n      return this.elem(0);\n    }\n\n    /**\r\n     * @method Elem#firstChild\r\n     * @public\r\n     * @param {String} [selector = null] - If present, finds first child in every elem that matches the selector.\r\n     * If not, finds first child of each element in the set.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Method for finding first children of each element in the set.\r\n     *\r\n     * @example\r\n     * elem.first();       // finds first child of each element in the elem set\r\n     * elem.first('.foo'); // find first child that has foo class of each element in the set\r\n     */\n\n  }, {\n    key: 'firstChild',\n    value: function firstChild() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return this.object(function (elems, elem) {\n        var _ref3 = new Elem(elem).children().find(function (elem) {\n          return new Elem(elem).is(selector);\n        }) || {},\n            found = _ref3.value;\n\n        elems.add(found);\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#focus\r\n     * @returns {Elem} Returns this.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus\r\n     * @description Synonym for\r\n     * [HTMLElement#focus]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus}.\r\n     */\n\n  }, {\n    key: 'focus',\n    value: function focus() {\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.focus();\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#getRule\r\n     * @public\r\n     * @param {String} name - Name of the rule.\r\n     * @returns {{ selector: (String|void), rules: Object }} Set of the css rules.\r\n     * @description Method for getting set of the rules under the name.\r\n     * Note: style element should be inside the document.\r\n     *\r\n     * @example\r\n     * style.addRule('img-size', 'img.square', {\r\n     *   width: '40px',\r\n     *   height: '40px'\r\n     * });\r\n     * style.getRule('img-size');\r\n     * // {\r\n     * //   selector: 'img.square',\r\n     * //   rules: {\r\n     * //     width: '40px',\r\n     * //     height: '40px'\r\n     * //   }\r\n     * // }\r\n     */\n\n  }, {\n    key: 'getRule',\n    value: function getRule(name) {\n      var found = {\n        selector: undefined,\n        rules: {}\n      };\n\n      this.some(function (elem) {\n        if (getName(elem) === 'style') {\n          var _ref4 = new Arr(elem.sheet.cssRules).find(function (rule) {\n            return rule.dwayneData && rule.dwayneData.name === name;\n          }) || {},\n              rule = _ref4.value;\n\n          if (rule) {\n            found = {\n              selector: rule.selectorText,\n              rules: new Elem(rule).css().$\n            };\n\n            return true;\n          }\n        }\n      });\n\n      return found;\n    }\n\n    /**\r\n     * @method Elem#hasAttr\r\n     * @public\r\n     * @param {String} attr - Name of the attribute.\r\n     * @returns {Boolean} If the first element in the set has the attribute.\r\n     * @description Method that returns if the first element in the set has the attribute or not.\r\n     *\r\n     * @example\r\n     * elem.attr('attr', 'value').hasAttr('attr'); // true\r\n     * elem.removeAttr('attr').hasAttr('attr');    // false\r\n     */\n\n  }, {\n    key: 'hasAttr',\n    value: function hasAttr(attr) {\n      var elem = getElem(this);\n      var ns = attrNSSwitcher(attr, [new Elem(elem)]);\n\n      return isNull(ns) ? elem.hasAttribute(attr) : elem.hasAttributeNS(ns, attr);\n    }\n\n    /**\r\n     * @method Elem#hasClass\r\n     * @public\r\n     * @param {String} cls - Name of the class.\r\n     * @returns {Boolean} If the first element in the set has the class.\r\n     * @description Method that returns if the first element in the set has the class or not.\r\n     *\r\n     * @example\r\n     * elem.addClass('cls').hasClass('cls');    // true\r\n     * elem.removeClass('cls').hasClass('cls'); // false\r\n     */\n\n  }, {\n    key: 'hasClass',\n    value: function hasClass(cls) {\n      return getElem(this).classList.contains(cls);\n    }\n\n    /**\r\n     * @method Elem#height\r\n     * @public\r\n     * @param {*|ElemValueCallback} [height] - Height to set.\r\n     * @returns {Elem|String} If no arguments passed height of the first element in the set returned.\r\n     * Otherwise all elements heights in the set are set to the height argument.\r\n     * @description Gets or sets height.\r\n     *\r\n     * @example\r\n     * elem.height(123);\r\n     * elem.height(); // 123\r\n     */\n\n  }, {\n    key: 'height',\n    value: function height(_height) {\n      return this.prop.apply(this, new Arr(arguments).unshift('height').$);\n    }\n\n    /**\r\n     * @method Elem#hide\r\n     * @public\r\n     * @returns {Elem} Returns this.\r\n     * @description Hides all elements in the set.\r\n     *\r\n     * @example\r\n     * elem.hide();\r\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide() {\n      return this.forEach(function (elem) {\n        elem = new Elem(elem);\n\n        var currentDisplay = elem.css('display');\n\n        if (currentDisplay.indexOf('none')) {\n          elem.prop('dwayneData').previousDisplay = currentDisplay;\n        }\n\n        elem.css('display', 'none !important');\n      });\n    }\n\n    /**\r\n     * @method Elem#html\r\n     * @public\r\n     * @param {String|ElemValueCallback|*} [html] - HTML to write instead of current HTML.\r\n     * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\r\n     * Otherwise all elements HTML in the set are set to the html argument.\r\n     * @description Gets or sets HTML.\r\n     *\r\n     * @example\r\n     * elem.html('<div>1</div>');\r\n     * elem.html(); // '<div>1</div>'\r\n     */\n\n  }, {\n    key: 'html',\n    value: function html(_html) {\n      if (!arguments.length) {\n        return getElem(this).innerHTML;\n      }\n\n      return this.forEach(function (elem, index) {\n        if (isElement(elem)) {\n          elem.innerHTML = isFunction(_html) ? _html(elem.innerHTML, elem, index) : _html;\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#id\r\n     * @public\r\n     * @param {String|*} [id] - Id to set.\r\n     * @returns {Elem|String} If no arguments passed id of the first element in the set returned.\r\n     * Otherwise all elements ids in the set are set to the id argument.\r\n     * @description Gets id or sets ids.\r\n     *\r\n     * @example\r\n     * elem.id('unique');\r\n     * elem.id(); // 'unique'\r\n     */\n\n  }, {\n    key: 'id',\n    value: function id(_id) {\n      if (!arguments.length) {\n        return getElem(this).id;\n      }\n\n      return this.forEach(function (elem) {\n        if (isElement(elem)) {\n          elem.id = _id;\n        }\n      });\n    }\n\n    /**\r\n     * @member {Number} Elem#innerHeight\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description Getter for finding how much height content of the first element can be.\r\n     *\r\n     * @example\r\n     * elem.css({\r\n     *   boxSizing: 'border-box',\r\n     *   height: '200px',\r\n     *   paddingTop: '2px',\r\n     *   paddingBottom: '3px',\r\n     *   borderTop: '1px solid black',\r\n     *   borderBottom: '4px solid black'\r\n     * }).innerHeight; // 190\r\n     * elem\r\n     *   .css('box-sizing', 'content-box')\r\n     *   .innerHeight; // 200\r\n     * elem\r\n     *   .css('box-sizing', 'padding-box')\r\n     *   .innerHeight; // 195\r\n     */\n\n  }, {\n    key: 'insertAfter',\n\n\n    /**\r\n     * @method Elem#insertAfter\r\n     * @public\r\n     * @param {String|Elem|Element} element - Element to insert this element after or a selector of it.\r\n     * @returns {Elem} Returns this.\r\n     * @description Puts the elements from the set after the element specified by the argument.\r\n     * The elements remain in the same order.\r\n     *\r\n     * @example\r\n     * elem.insertAfter(elem2);\r\n     * elem.insertAfter(document.getElementById('id'));\r\n     * elem.insertAfter('#id div.c1');\r\n     */\n    value: function insertAfter(element) {\n      element = toFind(element).first();\n\n      var parent = element.parent();\n\n      if (!parent.length) {\n        return this;\n      }\n\n      element = element.next().$[0];\n      parent = parent.$[0];\n\n      return this.forEach(function (elem) {\n        if (element) {\n          parent.insertBefore(elem, element);\n        } else {\n          parent.appendChild(elem);\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#insertBefore\r\n     * @public\r\n     * @param {String|Elem|Element} element - Element to insert this element before or a selector of it.\r\n     * @returns {Elem} Returns this.\r\n     * @description Puts the elements from the set before the element specified by the argument.\r\n     * The elements remain in the same order.\r\n     *\r\n     * @example\r\n     * elem.insertBefore(elem2);\r\n     * elem.insertBefore(document.getElementById('id'));\r\n     * elem.insertBefore('#id div.c1');\r\n     */\n\n  }, {\n    key: 'insertBefore',\n    value: function insertBefore(element) {\n      element = toFind(element).first();\n\n      var parent = element.parent();\n\n      if (!parent.length) {\n        return this;\n      }\n\n      element = element.$[0];\n      parent = parent.$[0];\n\n      return this.forEach(function (elem) {\n        parent.insertBefore(elem, element);\n      });\n    }\n\n    /**\r\n     * @method Elem#into\r\n     * @public\r\n     * @param {String|Elem|Element} element - Element to put this elements into or a selector of it.\r\n     * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method is similar to\r\n     * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\r\n     *\r\n     * @example\r\n     * elem.into(elem2);\r\n     * elem.into(document.getElementById('id'));\r\n     * elem.into('#id div.c1');\r\n     */\n\n  }, {\n    key: 'into',\n    value: function into(element) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      element = toFind(element).$[0];\n\n      if (!element || isWindow(element) || isHTMLDocument(element) || isCommentOrText(element)) {\n        return this;\n      }\n\n      if (!end && element.firstChild) {\n        return this.slice().reverse().forEach(function (elem) {\n          element.insertBefore(elem, element.firstChild);\n        });\n      }\n\n      return this.forEach(function (elem) {\n        element.appendChild(elem);\n      });\n    }\n\n    /**\r\n     * @method Elem#is\r\n     * @public\r\n     * @param {String} selector\r\n     * @returns {Boolean} If the first element in the set matches the selector.\r\n     * If the selector is undefined or null always returns true. If it's not for not elements\r\n     * entries returns false.\r\n     * @description Synonym for\r\n     * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\r\n     *\r\n     * @example\r\n     * elem.addClass('cls');\r\n     * elem.is('.cls');         // true\r\n     *\r\n     * elem.removeClass('cls');\r\n     * elem.is('.cls');         // false\r\n     */\n\n  }, {\n    key: 'is',\n    value: function is(selector) {\n      if (isNull(selector)) {\n        return true;\n      }\n\n      var elem = getElem(this);\n      var matches = elem.matches || elem.matchesSelector || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector || elem.oMatchesSelector;\n\n      if (!isElement(this.$[0])) {\n        return false;\n      }\n\n      try {\n        return matches.call(elem, selector);\n      } catch (err) {\n        console.error('Selector \\'' + selector + '\\' is not a valid selector (Elem#is)');\n\n        return false;\n      }\n    }\n\n    /**\r\n     * @method Elem#isBroken\r\n     * @public\r\n     * @returns {Boolean} If the first image in the set is broken.\r\n     * @description Returns if the first element in the set is broken. Not image and not loaded image is considered proper.\r\n     *\r\n     * @example\r\n     * const img = elem.img().on({\r\n     *   'load': onload,\r\n     *   'error': onload\r\n     * });\r\n     *\r\n     * onload = () => {\r\n     *   console.log(img.isBroken()); // true\r\n     * };\r\n     *\r\n     * img.ref('/some/non-existent/site/not-found.png');\r\n     */\n\n  }, {\n    key: 'isBroken',\n    value: function isBroken() {\n      var isBroken = false;\n\n      this.some(function (elem) {\n        if (getName(elem) === 'img') {\n          isBroken = !!(elem.complete && (!elem.naturalWidth || !elem.naturalHeight));\n\n          return true;\n        }\n      });\n\n      return isBroken;\n    }\n\n    /**\r\n     * @method Elem#isWithinDocument\r\n     * @public\r\n     * @returns {Boolean} Returns if the first element in the set is within the document or not.\r\n     * @description Returns if the first element in the set is within the document or not.\r\n     *\r\n     * @example\r\n     * new Elem(document.body).isWithinDocument();  // true\r\n     * new Elem(document).div().isWithinDocument(); // false\r\n     */\n\n  }, {\n    key: 'isWithinDocument',\n    value: function isWithinDocument() {\n      return this.first().closest('html').length !== 0;\n    }\n\n    /**\r\n     * @method Elem#last\r\n     * @public\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Synonym for elem.elem(-1).\r\n     */\n\n  }, {\n    key: 'last',\n    value: function last() {\n      return this.elem(-1);\n    }\n\n    /**\r\n     * @method Elem#lastChild\r\n     * @public\r\n     * @param {String} [selector = null] - If present, finds last child in every elem that matches the selector.\r\n     * If not, finds last child of each element in the set.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Method for finding last children of each element in the set.\r\n     *\r\n     * @example\r\n     * elem.last();       // finds last child of each element in the elem set\r\n     * elem.last('.foo'); // find last child that has 'foo' class of each element in the set\r\n     */\n\n  }, {\n    key: 'lastChild',\n    value: function lastChild() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return this.object(function (elems, elem) {\n        var _ref5 = new Elem(elem).children().reverse().find(function (elem) {\n          return new Elem(elem).is(selector);\n        }) || {},\n            found = _ref5.value;\n\n        elems.add(found);\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#load\r\n     * @public\r\n     * @returns {Promise.<{ proper: Elem, broken: Elem }>} Promise with broken and proper images.\r\n     * @description Loads each image in the set and puts it to the proper or broken array.\r\n     *\r\n     * @example\r\n     * images.load().then(({ broken }) => {\r\n     *   broken.filter('img').ref('/fallback.png');\r\n     * });\r\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var images = {\n        proper: new Elem(),\n        broken: new Elem()\n      };\n\n      return Promise$1.all(this.filter(function (elem) {\n        return getName(elem) === 'img';\n      }).map(function (elem) {\n        var $elem = new Elem(elem);\n\n        if (elem.complete) {\n          images[$elem.isBroken() ? 'broken' : 'proper'].push(elem);\n\n          return;\n        }\n\n        return new Promise$1(function (resolve) {\n          var removeListeners = $elem.on({\n            load: function load() {\n              images.proper.add(elem);\n\n              removeListeners();\n              resolve();\n            },\n            error: function error() {\n              images.broken.add(elem);\n\n              removeListeners();\n              resolve();\n            }\n          });\n        });\n      }).$).then(function () {\n        return images;\n      });\n    }\n\n    /**\r\n     * @method Elem#moveAttr\r\n     * @public\r\n     * @param {String} attr - Attribute to move to the first element.\r\n     * @param {String} [value = ''] - Value to set for the attribute. If not set attribute of the previous element or '' used.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for moving an attribute from previous element to the next one (first element in this set).\r\n     *\r\n     * @example\r\n     * elem1.moveAttr('attr', 'value');     // attribute 'attr' set to 'value' on elem1\r\n     * elem2.moveAttr('attr');              // attribute 'attr' removed from elem1. set to 'value' on elem2\r\n     * elem3.moveAttr('attr', 'new value'); // attribute 'attr' removed from elem2. set to 'new value' on elem3\r\n     */\n\n  }, {\n    key: 'moveAttr',\n    value: function moveAttr(attr) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      var prev = attrs[attr];\n      var elem = this.elem();\n\n      if (prev && elem.length) {\n        if (arguments.length < 2) {\n          value = prev.attr(attr);\n        }\n\n        prev.removeAttr(attr);\n      }\n\n      if (elem.length) {\n        attrs[attr] = elem.attr(attr, value);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Elem#moveClass\r\n     * @public\r\n     * @param {String} cls - Class to move to the first element.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for moving a class from previous element to the next one (first element in this set).\r\n     *\r\n     * @example\r\n     * elem1.moveClass('cls'); // class 'cls' added to elem1\r\n     * elem2.moveClass('cls'); // class 'cls' removed from elem1. added to elem1\r\n     */\n\n  }, {\n    key: 'moveClass',\n    value: function moveClass(cls) {\n      var prev = classes[cls];\n      var elem = this.elem();\n\n      if (prev && elem.length) {\n        prev.removeClass(cls);\n      }\n\n      if (elem.length) {\n        classes[cls] = elem.addClass(cls);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @member {String} Elem#name\r\n     * @type {String}\r\n     * @public\r\n     * @readonly\r\n     * @description nodeName (lowercased) of the first element in the set.\r\n     *\r\n     * @example\r\n     * const elem1 = elem.create('div');\r\n     * elem1.name // 'div'\r\n     */\n\n  }, {\n    key: 'next',\n\n\n    /**\r\n     * @method Elem#next\r\n     * @public\r\n     * @param {String} [selector = null] - If present, finds next element to every elem that matches the selector.\r\n     * If not, finds next element to each element in the set.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Method for finding next element to each element in the set.\r\n     *\r\n     * @example\r\n     * elem.next();       // finds next element to each element in the set\r\n     * elem.next('.foo'); // finds next element to each element that has 'foo' class\r\n     */\n    value: function next() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return this.object(function (elems, elem) {\n        /* eslint no-cond-assign: 0 */\n        while (elem = elem.nextSibling) {\n          if (new Elem(elem).is(selector)) {\n            return elems.add(elem);\n          }\n        }\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#off\r\n     * @public\r\n     * @param {...ElemEventString} events - Events to remove.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method that removes all the listeners from each element in the set specified by the events arguments.\r\n     *\r\n     * @example\r\n     * elem.off('click');\r\n     * elem.off('click, input');\r\n     * elem.off('click, input', 'focus');\r\n     */\n\n  }, {\n    key: 'off',\n    value: function off() {\n      var _arguments2 = arguments;\n\n      for (var _len5 = arguments.length, events = Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {\n        events[_key6] = arguments[_key6];\n      }\n\n      return this.forEach(function (elem) {\n        var listeners = elem.dwayneData.listeners;\n\n\n        iterate(_arguments2, function (event) {\n          iterate(event.split(eventSeparator), function (event) {\n            (listeners[event] || new Super()).forEach(function (_ref6) {\n              var removeListener = _ref6.removeListener;\n              return removeListener();\n            });\n          });\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#on\r\n     * @public\r\n     * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\r\n     * or an object with event keys (a key is also ElemEventString) and listeners values.\r\n     * @param {String} [selector = null] - Selector to filter event targets.\r\n     * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\r\n     * specified event(s).\r\n     * @returns {ElemRemoveListeners} Function that takes optional event argument.\r\n     * @description Adds event listeners for all the elements in the set.\r\n     * For debugging: If you need to know what listeners are in work (and what selectors filter targets)\r\n     * you can look at the base property of the only dwayne listener that listens for the event\r\n     * and find all working listeners in listener.base.dwayneData.listeners[event].$.\r\n     *\r\n     * @example\r\n     * elem.on(\r\n     *   'change, input',\r\n     *   'input, select, textarea, datalist, keygen, output',\r\n     *   (e, elem, index) => console.log(elem.value)\r\n     * );\r\n     * elem.on(\r\n     *   'change, input',\r\n     *   (e, elem, index) => console.log(elem.value)\r\n     * );\r\n     * elem.on(\r\n     *   {\r\n     *     'change, input': (e, elem, index) => console.log(elem.value),\r\n     *     'blur': () => console.log('blur')\r\n     *   },\r\n     *   'input, select, textarea, datalist, keygen, output'\r\n     * );\r\n     *\r\n     * const removeListeners = elem.on({\r\n     *   'change, input': (e, elem, index) => console.log(elem.value),\r\n     *   'blur': () => console.log('blur')\r\n     * });\r\n     *\r\n     * removeListeners('click');\r\n     * removeListeners('blur, change');\r\n     * removeListeners('blur, change', 'input');\r\n     * removeListeners();\r\n     */\n\n  }, {\n    key: 'on',\n    value: function on(event) {\n      var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var listener = arguments[2];\n\n      var allListeners = new Super({});\n\n      if (isFunction(selector)) {\n        listener = selector;\n        selector = null;\n      }\n\n      if (isString(event)) {\n        event = defineProperty({}, event, listener);\n      }\n\n      event = new Super(event).object(function (listeners, listener, event) {\n        iterate(event.split(eventSeparator), function (event) {\n          listeners[event] = listener;\n        });\n      });\n\n      this.forEach(function (elem) {\n        if (!isElement(elem) && !isWindow(elem) && !isHTMLDocument(elem)) {\n          return;\n        }\n\n        var _ref7 = (windowsDwayneData.find(function (_ref8) {\n          var element = _ref8.element;\n          return element === elem;\n        }) || {}).value || elem.dwayneData,\n            listeners = _ref7.listeners;\n\n        event.forEach(function (listener, event) {\n          var removeEventListeners = listeners[event] = listeners[event] || new Super({}).define('index', {\n            value: 0,\n            configurable: true,\n            writable: true\n          });\n          var index = removeEventListeners.prop('index');\n\n          if (!removeEventListeners.has('listener')) {\n            var newListener = function newListener(e) {\n              removeEventListeners.forEach(function (_ref9) {\n                var selector = _ref9.selector,\n                    listener = _ref9.listener;\n\n                if (new Elem(e.target).is(selector)) {\n                  listener.call(elem, e, elem, index);\n                }\n              });\n            };\n\n            newListener.base = elem;\n\n            elem.addEventListener(event, newListener, false);\n            removeEventListeners.define('listener', {\n              value: newListener,\n              configurable: true,\n              writable: true\n            });\n          }\n\n          var removeListener = function removeListener() {\n            removeEventListeners.delete(index);\n\n            if (!removeEventListeners.count) {\n              elem.removeEventListener(event, removeEventListeners.prop('listener'), false);\n              removeEventListeners.delete('listener');\n            }\n          };\n\n          allListeners.prop(event, (allListeners.prop(event) || new Arr()).push(removeListener));\n\n          removeEventListeners.assign(defineProperty({\n            index: index + 1\n          }, index, {\n            selector: selector,\n            listener: listener,\n            removeListener: removeListener\n          }));\n        });\n      });\n\n      return function removeEventListeners(event) {\n        if (arguments.length) {\n          iterate(arguments, function (event) {\n            iterate(event.split(eventSeparator), function (event) {\n              if (allListeners.has(event)) {\n                allListeners.prop(event).forEach(function (removeListener) {\n                  return removeListener();\n                });\n                allListeners.delete(event);\n              }\n            });\n          });\n\n          return;\n        }\n\n        allListeners.forEach(function (removeListeners) {\n          removeListeners.forEach(function (removeListener) {\n            return removeListener();\n          });\n        });\n      };\n    }\n\n    /**\r\n     * @member {Number} Elem#outerHeight\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description Getter for finding how much height the element actually is.\r\n     *\r\n     * @example\r\n     * elem.css({\r\n     *   boxSizing: 'border-box',\r\n     *   height: '200px',\r\n     *   paddingTop: '2px',\r\n     *   paddingBottom: '3px',\r\n     *   borderTop: '1px solid black',\r\n     *   borderBottom: '4px solid black'\r\n     *   marginTop: '0px',\r\n     *   marginBottom: '5px'\r\n     * }).outerHeight; // 205\r\n     * elem\r\n     *   .css('box-sizing', 'content-box')\r\n     *   .outerHeight; // 215\r\n     * elem\r\n     *   .css('box-sizing', 'padding-box')\r\n     *   .outerHeight; // 210\r\n     */\n\n  }, {\n    key: 'parent',\n\n\n    /**\r\n     * @method Elem#parent\r\n     * @public\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Method returns wrap of the set of the parent elements of each element in the set.\r\n     */\n    value: function parent() {\n      return this.object(function (elems, elem) {\n        return elems.add(elem.parentNode);\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#parentTree\r\n     * @public\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Returns wrap of all parents of each element in the set.\r\n     *\r\n     * @example\r\n     * elem.parentTree(); // Elem\r\n     */\n\n  }, {\n    key: 'parentTree',\n    value: function parentTree() {\n      return this.object(function (elems, elem) {\n        while (elem = elem.parentNode) {\n          elems.add(elem);\n        }\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#prev\r\n     * @public\r\n     * @param {String} [selector = null] - If present, finds previous element to every elem that matches the selector.\r\n     * If not, finds previous element to each element in the set.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Method for finding previous element to each element in the set.\r\n     *\r\n     * @example\r\n     * elem.next();       // finds previous element to each element in the set\r\n     * elem.next('.foo'); // finds previous element to each element that has 'foo' class\r\n     */\n\n  }, {\n    key: 'prev',\n    value: function prev() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      return this.object(function (elems, elem) {\n        /* eslint no-cond-assign: 0 */\n        while (elem = elem.previousSibling) {\n          if (new Elem(elem).is(selector)) {\n            return elems.add(elem);\n          }\n        }\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#prop\r\n     * @public\r\n     * @param {String|Object.<String, ElemValueCallback|*>} property - Either a string of a property or an assigned object.\r\n     * @param {ElemValueCallback|*} [value] - If a property parameter is a string\r\n     * this has to be an assigned value if it's present.\r\n     * @returns {Elem|*} Returns this if it's setter or a value if getter.\r\n     * @description Method that is either a property getter for the first element in the set\r\n     * or a setter for every element in the set.\r\n     *\r\n     * @example\r\n     * elem.prop('draggable', false);\r\n     * elem.prop('draggable'); // false\r\n     */\n\n  }, {\n    key: 'prop',\n    value: function prop(property, value) {\n      if (arguments.length <= 1 && isString(property)) {\n        return this.$[0] ? this.$[0][property] : undefined;\n      }\n\n      if (arguments.length >= 2) {\n        property = defineProperty({}, property, value);\n      }\n\n      return this.forEach(function (elem, index) {\n        iterate(property, function (value, prop$$1) {\n          elem[prop$$1] = isFunction(value) ? value(elem[prop$$1], elem, index) : value;\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#ref\r\n     * @public\r\n     * @param {String|ElemValueCallback} [link] - If it's present link to a resource.\r\n     * @returns {Elem|String} If the link argument isn't present it's a getter of the 'src' attribute\r\n     * for the one of following elements: img, script, iframe, audio, video; of the 'action' attribute\r\n     * for a form element and of the 'href' attribute for the rest. If it's present it's a setter\r\n     * of the same attribute for all the element in the set.\r\n     * @description Method for getting resources links and setting them.\r\n     *\r\n     * @example\r\n     * elem.ref('/some/cool/image.png');\r\n     * elem.ref(); // '/some/cool/image.png'\r\n     */\n\n  }, {\n    key: 'ref',\n    value: function ref(link) {\n      if (!arguments.length) {\n        return this.attr(refSwitcher(this.name));\n      }\n\n      return this.forEach(function (elem) {\n        elem = new Elem(elem);\n\n        elem.attr(refSwitcher(elem.name), link);\n      });\n    }\n\n    /**\r\n     * @method Elem#remove\r\n     * @public\r\n     * @returns {Elem} Returns this.\r\n     * @description Removes all the elements from the set from the document.\r\n     * Note: it doesn't remove them from the set so watch out for the memory leaks.\r\n     *\r\n     * @example\r\n     * elem.remove();\r\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove() {\n      return this.forEach(function (elem) {\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.removeChild(elem);\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#removeAttr\r\n     * @public\r\n     * @param {...String} attributes - Attributes to remove.\r\n     * @returns {Elem} Returns this.\r\n     * @description Removes all the attributes from arguments from all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.removeAttr('foo', 'bar', 'baz');\r\n     */\n\n  }, {\n    key: 'removeAttr',\n    value: function removeAttr() {\n      var _arguments3 = arguments;\n\n      for (var _len6 = arguments.length, attributes = Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {\n        attributes[_key7] = arguments[_key7];\n      }\n\n      return this.forEach(function (elem) {\n        if (!isElement(elem)) {\n          return;\n        }\n\n        iterate(_arguments3, function (attr) {\n          var ns = attrNSSwitcher(attr, [new Elem(elem)]);\n\n          if (isNull(ns)) {\n            elem.removeAttribute(attr);\n          } else {\n            elem.removeAttributeNS(ns, attr);\n          }\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#removeClass\r\n     * @public\r\n     * @param {...String} classes - Classes to remove.\r\n     * @returns {Elem} Returns this.\r\n     * @description Removes all the classes from arguments from all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.removeClass('foo', 'bar', 'baz');\r\n     */\n\n  }, {\n    key: 'removeClass',\n    value: function removeClass() {\n      var _arguments4 = arguments;\n\n      for (var _len7 = arguments.length, classes = Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {\n        classes[_key8] = arguments[_key8];\n      }\n\n      return this.forEach(function (elem) {\n        var list = elem.classList;\n\n        iterate(isElement(elem) && _arguments4, function (cls) {\n          return list.remove(cls);\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#removeCSS\r\n     * @public\r\n     * @param {...String} props - CSS properties to remove.\r\n     * @returns {Elem} Returns this.\r\n     * @description Removes all the CSS properties from arguments from all the elements in the set.\r\n     *\r\n     * @example\r\n     * elem.removeCSS('display', 'position', 'margin');\r\n     */\n\n  }, {\n    key: 'removeCSS',\n    value: function removeCSS() {\n      var _arguments5 = arguments;\n\n      for (var _len8 = arguments.length, props = Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {\n        props[_key9] = arguments[_key9];\n      }\n\n      return this.forEach(function (elem) {\n        if (!isElement(elem)) {\n          return;\n        }\n\n        iterate(_arguments5, function (css) {\n          elem.style.removeProperty(css);\n        });\n      });\n    }\n\n    /**\r\n     * @method Elem#replace\r\n     * @public\r\n     * @param {String|Elem|Element} element - Element to replace the first element in the set\r\n     * with a set of elements specified by the argument (Element, set of elements or a selector of them).\r\n     * @returns {Elem} Returns this.\r\n     * @description Method is similar to\r\n     * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\r\n     *\r\n     * @example\r\n     * elem.replace(elem2);\r\n     * elem.replace(document.getElementById('id'));\r\n     * elem.replace('#id div.c1');\r\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(element) {\n      element = toFind(element);\n\n      var parent = this.first().parent();\n\n      if (!parent.length) {\n        return this;\n      }\n\n      var elem = parent;\n      var method$$1 = 'into';\n      var next = this.next().first().$[0];\n      var prev = this.prev().first().$[0];\n\n      if (next) {\n        elem = next;\n        method$$1 = 'insertBefore';\n      } else if (prev) {\n        elem = prev;\n        method$$1 = 'insertAfter';\n      }\n\n      this.first().remove();\n\n      element[method$$1](elem);\n    }\n\n    /**\r\n     * @method Elem#setOf\r\n     * @public\r\n     * @param {String} type - HTML element type.\r\n     * @param {Number|Object|Array.<*>} iterator - A number (how many elements to create inside each element),\r\n     * an object or an array to iterate over.\r\n     * @param {ElemSetOfCallback} callback\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Function for creating set of elements inside each element in the set based on an array or an object.\r\n     *\r\n     * @example\r\n     * table.setOf('tr', [[1, 2], [3, 4], [5, 6]], (row, array) => {\r\n     *   D(row).setOf('td', array, (col, number) => {\r\n     *     D(col).text(number);\r\n     *   });\r\n     * });\r\n     */\n\n  }, {\n    key: 'setOf',\n    value: function setOf(type, iterator, callback) {\n      validate$1({ 2: callback }, { 2: ['function'] }, 'Elem#setOf');\n\n      iterator = new Super(iterator).$;\n\n      if (isNumber(iterator)) {\n        try {\n          validate$1({ 1: iterator }, { 1: ['intLike', '>=0'] }, 'Elem#setOf');\n        } catch (e) {\n          throw new Error('2nd argument must be either or non-negative integer, or object! (at Elem#setOf)');\n        }\n\n        iterator = array(iterator).$;\n      }\n\n      return this.object(function (elems, elem, index) {\n        iterate(iterator, function (value, key) {\n          var created = new Elem(elem).create(type);\n\n          callback(created.$[0], value, key, iterator, elem, index);\n\n          elems.add(created);\n        });\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#show\r\n     * @public\r\n     * @returns {Elem} Returns this.\r\n     * @description Shows all elements in the set.\r\n     * If an element was hidden using {@link Elem#hide} previous display is set.\r\n     *\r\n     * @example\r\n     * elem.show();\r\n     */\n\n  }, {\n    key: 'show',\n    value: function show() {\n      return this.forEach(function (elem) {\n        var _elem = elem,\n            dwayneData = _elem.dwayneData;\n\n\n        elem = new Elem(elem);\n\n        if (elem.css('display').indexOf('none') === 0) {\n          elem.css('display', dwayneData.previousDisplay);\n        }\n\n        dwayneData.previousDisplay = '';\n      });\n    }\n\n    /**\r\n     * @method Elem#text\r\n     * @public\r\n     * @param {String|ElemValueCallback|*} [text] - Text to write instead of current text.\r\n     * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\r\n     * Otherwise all elements texts in the set are set to the text argument.\r\n     * @description Gets or sets text.\r\n     *\r\n     * @example\r\n     * elem.text('123');\r\n     * elem.text(); // '123'\r\n     */\n\n  }, {\n    key: 'text',\n    value: function text(_text) {\n      if (!arguments.length) {\n        return this.prop(textProperty);\n      }\n\n      return this.forEach(function (elem, index) {\n        var txt = elem[textProperty];\n\n        new Elem(elem).prop(textProperty, isFunction(_text) ? _text(txt, elem, index) : _text);\n      });\n    }\n\n    /**\r\n     * @method Elem#toggleAttr\r\n     * @public\r\n     * @param {String} attr - Attribute to toggle.\r\n     * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\r\n     * with the '' value and if falsey method removes the attribute. If not present method adds\r\n     * the attribute if it doesn't exist and removes if it does.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for toggling attributes.\r\n     *\r\n     * @example\r\n     * elem.toggleAttr('attr');\r\n     * elem.toggleAttr('attr', someCondition);\r\n     */\n\n  }, {\n    key: 'toggleAttr',\n    value: function toggleAttr(attr, condition) {\n      var _arguments6 = arguments;\n\n      return this.forEach(function (elem) {\n        elem = new Elem(elem);\n\n        if (_arguments6.length < 2 ? !elem.hasAttr(attr) : condition) {\n          elem.attr(attr, '');\n        } else {\n          elem.removeAttr(attr);\n        }\n      });\n    }\n\n    /**\r\n     * @method Elem#toggleAttr\r\n     * @public\r\n     * @param {String} cls - Class to toggle.\r\n     * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\r\n     * and if falsey method removes the class. If not present method adds\r\n     * the class if it doesn't exist and removes if it does.\r\n     * @returns {Elem} Returns this.\r\n     * @description Method for toggling classes.\r\n     *\r\n     * @example\r\n     * elem.toggleClass('cls');\r\n     * elem.toggleClass('cls', someCondition);\r\n     */\n\n  }, {\n    key: 'toggleClass',\n    value: function toggleClass(cls, condition) {\n      return (arguments.length < 2 ? !this.hasClass(cls) : condition) ? this.addClass(cls) : this.removeClass(cls);\n    }\n  }, {\n    key: 'up',\n\n\n    /**\r\n     * @method Elem#up\r\n     * @public\r\n     * @param {Integer} [level = 1] - What level up along the tree should be the parent.\r\n     * @returns {Elem} New instance of Elem.\r\n     * @description Creates a collection of parents of level &lt;level&gt;.\r\n     *\r\n     * @example\r\n     * elem.up();\r\n     * elem.up(2);\r\n     */\n    value: function up() {\n      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      validate$1([level], [['intLike', '>=0']], 'Elem#up');\n\n      level = Number(level);\n\n      return this.object(function (elems, elem) {\n        var n = level;\n\n        while (n-- && elem) {\n          elem = elem.parentNode;\n        }\n\n        elems.add(elem);\n      }, new Elem());\n    }\n\n    /**\r\n     * @method Elem#validate\r\n     * @public\r\n     * @param {ValidateCallback} [validator] - If present, function that validates inputs.\r\n     * @returns {Elem|Object.<String, Error|*>|null}\r\n     * If a callback argument provided returns this. If no arguments provided returns either an object\r\n     * with input names keys and errors values or null if no errors found.\r\n     * @description If a callback argument provided adds it to the element validators list.\r\n     * If no arguments provided validates every input element in the set with its own functions.\r\n     * If an element is a form it validates all input elements inside it. After the validation\r\n     * fires 'validate' event with 'valid' and 'error' (if form it's errors) properties.\r\n     *\r\n     * @example\r\n     * form.on('input change', 'input', (value, input) => {\r\n     *   input = D(input);\r\n     *\r\n     *   if (Number(value) % 3) {\r\n     *     input.addClass('invalid');\r\n     *\r\n     *     throw new Error('The value should be divided by 3!');\r\n     *   }\r\n     *\r\n     *   input.removeClass('invalid');\r\n     * });\r\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(validator) {\n      validate$1([validator], ['function||!'], 'Elem#validate');\n\n      if (validator) {\n        return this.forEach(function (_ref10) {\n          var dwayneData = _ref10.dwayneData;\n\n          dwayneData.validators.push(validator);\n        });\n      }\n\n      var errors = new Super({ errors: null });\n\n      this.filter(inputElements + ', form').forEach(function (elem, index) {\n        if (getName(elem) === 'form') {\n          var _ret = function () {\n            var formErrors = { errors: null };\n            var form = new Elem(elem);\n            var inputs = form.find(inputElements);\n\n            inputs.forEach(function (input, index) {\n              validatorWrap(input, index, formErrors);\n            });\n\n            errors.deepAssign(formErrors);\n\n            formErrors = formErrors.errors;\n\n            form.dispatch('validate', {}, {\n              valid: !formErrors,\n              errors: formErrors\n            });\n\n            return {\n              v: inputs.forEach(function (input) {\n                var inputError = (formErrors || {})[input.name];\n\n                new Elem(input).dispatch('validate', {}, {\n                  valid: !inputError,\n                  error: inputError || null\n                });\n              })\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n\n        var inputError = { errors: null };\n\n        validatorWrap(elem, index, inputError);\n        errors.deepAssign(inputError);\n\n        inputError = (inputError.errors || {})[elem.name];\n\n        new Elem(elem).dispatch('validate', {}, {\n          valid: !inputError,\n          error: inputError || null\n        });\n      });\n\n      function validatorWrap(input, index, errors) {\n        try {\n          if (input.validity && !input.validity.valid) {\n            throw new Error(input.validationMessage);\n          }\n\n          input.dwayneData.validators.forEach(function (validator) {\n            validator(input.value, input, index);\n          });\n        } catch (err) {\n          (errors.errors = errors.errors || {})[input.name] = err;\n        }\n      }\n\n      if (errors.every(function (error) {\n        return isNull(error);\n      })) {\n        return null;\n      }\n\n      return errors.$.errors;\n    }\n\n    /**\r\n     * @method Elem#width\r\n     * @public\r\n     * @param {*|ElemValueCallback} [width] - Width to set.\r\n     * @returns {Elem|String} If no arguments passed width of the first element in the set returned.\r\n     * Otherwise all elements widths in the set are set to the width argument.\r\n     * @description Gets or sets width.\r\n     *\r\n     * @example\r\n     * elem.width(123);\r\n     * elem.width(); // 123\r\n     */\n\n  }, {\n    key: 'width',\n    value: function width(_width) {\n      return this.prop.apply(this, new Arr(arguments).unshift('width').$);\n    }\n  }, {\n    key: 'innerHeight',\n    get: function get() {\n      var elem = this.$[0];\n\n      if (isWindow(elem)) {\n        return elem.innerHeight;\n      }\n\n      var _calcCSS = this.calcCSS(),\n          borderTopWidth = _calcCSS.borderTopWidth,\n          borderBottomWidth = _calcCSS.borderBottomWidth,\n          boxSizing = _calcCSS.boxSizing,\n          height = _calcCSS.height,\n          paddingTop = _calcCSS.paddingTop,\n          paddingBottom = _calcCSS.paddingBottom;\n\n      var borders = px(borderTopWidth) + px(borderBottomWidth);\n      var paddings = px(paddingTop) + px(paddingBottom);\n\n      return px(height) - innerSwitcher(boxSizing, [paddings, borders]);\n    }\n\n    /**\r\n     * @member {Number} Elem#innerWidth\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description Getter for finding how much width content of the first element can be.\r\n     *\r\n     * @example\r\n     * elem.css({\r\n     *   boxSizing: 'border-box',\r\n     *   width: '200px',\r\n     *   paddingLeft: '2px',\r\n     *   paddingRight: '3px',\r\n     *   borderLeft: '1px solid black',\r\n     *   borderRight: '4px solid black'\r\n     * }).innerWidth; // 190\r\n     * elem\r\n     *   .css('box-sizing', 'content-box')\r\n     *   .innerWidth; // 200\r\n     * elem\r\n     *   .css('box-sizing', 'padding-box')\r\n     *   .innerWidth; // 195\r\n     */\n\n  }, {\n    key: 'innerWidth',\n    get: function get() {\n      var elem = this.$[0];\n\n      if (isWindow(elem)) {\n        return elem.innerWidth;\n      }\n\n      var _calcCSS2 = this.calcCSS(),\n          borderLeftWidth = _calcCSS2.borderLeftWidth,\n          borderRightWidth = _calcCSS2.borderRightWidth,\n          boxSizing = _calcCSS2.boxSizing,\n          paddingLeft = _calcCSS2.paddingLeft,\n          paddingRight = _calcCSS2.paddingRight,\n          width = _calcCSS2.width;\n\n      var borders = px(borderLeftWidth) + px(borderRightWidth);\n      var paddings = px(paddingLeft) + px(paddingRight);\n\n      return px(width) - innerSwitcher(boxSizing, [paddings, borders]);\n    }\n  }, {\n    key: 'name',\n    get: function get() {\n      return getName(this.$[0]);\n    }\n  }, {\n    key: 'outerHeight',\n    get: function get() {\n      var elem = this.$[0];\n\n      if (isWindow(elem)) {\n        return elem.outerHeight;\n      }\n\n      var _calcCSS3 = this.calcCSS(),\n          borderTopWidth = _calcCSS3.borderTopWidth,\n          borderBottomWidth = _calcCSS3.borderBottomWidth,\n          boxSizing = _calcCSS3.boxSizing,\n          height = _calcCSS3.height,\n          marginTop = _calcCSS3.marginTop,\n          marginBottom = _calcCSS3.marginBottom,\n          paddingTop = _calcCSS3.paddingTop,\n          paddingBottom = _calcCSS3.paddingBottom;\n\n      var borders = px(borderTopWidth) + px(borderBottomWidth);\n      var paddings = px(paddingTop) + px(paddingBottom);\n\n      return px(height) + px(marginTop) + px(marginBottom) + outerSwitcher(boxSizing, [borders, paddings]);\n    }\n\n    /**\r\n     * @member {Number} Elem#outerWidth\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description Getter for finding how much width the element actually is.\r\n     *\r\n     * @example\r\n     * elem.css({\r\n     *   boxSizing: 'border-box',\r\n     *   width: '200px',\r\n     *   paddingLeft: '2px',\r\n     *   paddingRight: '3px',\r\n     *   borderLeft: '1px solid black',\r\n     *   borderRight: '4px solid black'\r\n     *   marginLeft: '0px',\r\n     *   marginRight: '5px'\r\n     * }).outerWidth; // 205\r\n     * elem\r\n     *   .css('box-sizing', 'content-box')\r\n     *   .outerWidth; // 215\r\n     * elem\r\n     *   .css('box-sizing', 'padding-box')\r\n     *   .outerWidth; // 210\r\n     */\n\n  }, {\n    key: 'outerWidth',\n    get: function get() {\n      var elem = this.$[0];\n\n      if (isWindow(elem)) {\n        return elem.outerWidth;\n      }\n\n      var _calcCSS4 = this.calcCSS(),\n          borderLeftWidth = _calcCSS4.borderLeftWidth,\n          borderRightWidth = _calcCSS4.borderRightWidth,\n          boxSizing = _calcCSS4.boxSizing,\n          marginLeft = _calcCSS4.marginLeft,\n          marginRight = _calcCSS4.marginRight,\n          paddingLeft = _calcCSS4.paddingLeft,\n          paddingRight = _calcCSS4.paddingRight,\n          width = _calcCSS4.width;\n\n      var borders = px(borderLeftWidth) + px(borderRightWidth);\n      var paddings = px(paddingLeft) + px(paddingRight);\n\n      return px(width) + px(marginLeft) + px(marginRight) + outerSwitcher(boxSizing, [borders, paddings]);\n    }\n  }, {\n    key: 'toStringTag',\n    get: function get() {\n      return toStringTag(this.$$);\n    }\n  }]);\n  return Elem;\n}(Arr);\n\ndefineProperties(Elem.prototype, defineProperty({}, _Symbol.toStringTag, 'Elem'));\n\n/**\r\n * @const {Elem} win\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of window.\r\n */\nvar win = new Elem(global$1);\n\n/**\r\n * @const {Elem} doc\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.\r\n */\nvar doc = new Elem(nativeDocument);\n\n/**\r\n * @const {Elem} html\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.documentElement.\r\n */\nvar html = new Elem(nativeDocument.documentElement);\n\n/**\r\n * @const {Elem} body\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.body.\r\n */\nvar body = new Elem(nativeDocument.body);\n\n/**\r\n * @const {Elem} head\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.head.\r\n */\nvar head$1 = new Elem(nativeDocument.head);\n\nvar elements = new Arr(htmlElements).concat(svgElements).$;\nvar props = new Arr(elements).map(function (type) {\n  return new Str(type).toCamelCase().$;\n}).$;\n\ndynamicDefineProperties(Elem.prototype, props, function (elem, i) {\n  return function () {\n    return this.create.apply(this, new Arr(arguments).unshift(elements[i]).$);\n  };\n});\n\ndynamicDefineProperties(Elem.prototype, canvasGetMethods, function (method$$1) {\n  return function () {\n    var ctx = this.ctx();\n\n    if (ctx) {\n      return ctx[method$$1].apply(ctx, arguments);\n    }\n  };\n});\n\ndynamicDefineProperties(Elem.prototype, canvasRestMethods, function (method$$1) {\n  return function () {\n    var ctx = this.ctx();\n\n    if (ctx) {\n      ctx[method$$1].apply(ctx, arguments);\n    }\n\n    return this;\n  };\n});\n\n/**\r\n * @function toFind\r\n * @private\r\n * @param {Element|Elem|String} elem - Element, selector of Elements or Elem.\r\n * @returns {Elem} Instance of Elem.\r\n */\nfunction toFind(elem) {\n  if (isElem(elem)) {\n    return elem;\n  }\n\n  if (isString(elem)) {\n    elem = _find(elem);\n  }\n\n  return new Elem(elem);\n}\n\n/**\r\n * @function isElem\r\n * @private\r\n * @param {*} value - Value to check if it's Elem.\r\n * @returns {Boolean} If the value is Elem.\r\n * @description Returns if the value is Elem or not.\r\n */\nfunction isElem(value) {\n  return value instanceof Elem;\n}\n\n/**\r\n * @function isWindow\r\n * @private\r\n * @param {*} value - Value to check if it's Window.\r\n * @returns {Boolean} If the value is Window.\r\n * @description Returns if the value is Window or not.\r\n */\nfunction isWindow(value) {\n  return toStringTag(value) === 'Window';\n}\n\n/**\r\n * @function isHTMLDocument\r\n * @private\r\n * @param {*} value - Value to check if it's HTMLDocument.\r\n * @returns {Boolean} If the value is HTMLDocument.\r\n * @description Returns if the value is HTMLDocument or not.\r\n */\nfunction isHTMLDocument(value) {\n  return toStringTag(value) === 'HTMLDocument';\n}\n\n/**\r\n * @function isDocumentFragment\r\n * @private\r\n * @param {*} value - Value to check if it's a DocumentFragment.\r\n * @returns {Boolean} If the value is a DocumentFragment.\r\n * @description Returns if the value is a DocumentFragment or not.\r\n */\nfunction isDocumentFragment(value) {\n  return toStringTag(value) === 'DocumentFragment';\n}\n\n/**\r\n * @function isStyleRule\r\n * @private\r\n * @param {*} value - Value to check if it's a style rule.\r\n * @returns {Boolean} If the value is a style rule.\r\n * @description Returns if the value is a style rule or not.\r\n */\nfunction isStyleRule(value) {\n  return toStringTag(value) === 'CSSStyleRule';\n}\n\n/**\r\n * @function\r\n * @private\r\n * @param {*} value - Value to check if it's Comment or Text.\r\n * @returns {Boolean} If the value is HTMLDocument.\r\n * @description Returns if the value is Comment or Text or not.\r\n */\nfunction isCommentOrText(value) {\n  var tag = toStringTag(value);\n\n  return tag === 'Comment' || tag === 'Text';\n}\n\n/**\r\n * @function getElem\r\n * @private\r\n * @param {Elem} elem - Element to check.\r\n * @returns {Element} The argument or a fallback if needed.\r\n */\nfunction getElem(elem) {\n  return isElement(elem.$[0]) ? elem.$[0] : emptyDiv;\n}\n\n/**\r\n * @function getName\r\n * @private\r\n * @param {Element} [elem] - Element which name is needed to know.\r\n * @returns {String} Element name.\r\n */\nfunction getName(elem) {\n  return elem && elem.nodeName && elem.nodeName.toLowerCase() || '';\n}\n\n/**\r\n * @function addDwayneData\r\n * @private\r\n * @param {Element} elem - Element to add dwayneData to.\r\n * @returns {void}\r\n */\nfunction addDwayneData(elem) {\n  if (!{}.hasOwnProperty.call(elem, 'dwayneData') && !isWindow(elem)) {\n    /**\r\n     * @member Element#dwayneData\r\n     * @type {Object}\r\n     * @protected\r\n     * @property {String} previousDisplay - Parameter used for hiding/showing elements.\r\n     * @property {Object.<String, Super>} removeListeners - Parameter used for remove event listeners.\r\n     * @property {CanvasRenderingContext2D} [ctx] - Canvas rendering context.\r\n     * @property {Arr} validators - Validators assigned to element.\r\n     * @description D data.\r\n     */\n    Object.defineProperty(elem, 'dwayneData', {\n      value: {\n        previousDisplay: '',\n        listeners: {},\n        ctx: getName(elem) === 'canvas' && elem.getContext('2d'),\n        validators: new Arr([])\n      }\n    });\n  } else if (isWindow(elem) && !windowsDwayneData.some(function (_ref11) {\n    var element = _ref11.element;\n    return element === elem;\n  })) {\n    windowsDwayneData.push({\n      element: elem,\n      listeners: {}\n    });\n  }\n}\n\nconstructors[2].push({\n  check: function check(elem) {\n    return isElement(elem) || isWindow(elem) || isHTMLDocument(elem) || isCommentOrText(elem) || isDocumentFragment(elem) || /^(HTMLCollection|NodeList)$/.test(toStringTag(elem));\n  },\n  cls: Elem\n});\n\n/**\r\n * @function find\r\n * @public\r\n * @param {String} selector - Selector to find.\r\n * @param {Element} [base = document] - Base to find in.\r\n * @returns {Elem} New instance of Elem.\r\n * @description Synonym for\r\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\r\n */\nfunction _find(selector) {\n  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nativeDocument;\n\n  return new Elem(isElement(base) || isHTMLDocument(base) ? base.querySelectorAll(String(selector)) : []);\n}\n\n/**\r\n * @function parseHTML\r\n * @public\r\n * @param {String} html - HTML to parse.\r\n * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be\r\n * collapsed during the parsing.\r\n * @returns {Elem} New instance of Elem.\r\n * @description Parses HTML and returns a wrap of #document-fragment containing the contents.\r\n *\r\n * @example\r\n * parseHTML('<div>123</div>'); // Elem\r\n */\nfunction parseHTML(html, collapseWhiteSpace) {\n  var json = markupToJSON(html, collapseWhiteSpace);\n  var template = doc.template();\n  var elem = new Elem(template.$[0].content);\n\n  json.forEach(function forEachNode(node) {\n    var name = node.name,\n        attrs = node.attrs,\n        value = node.value,\n        parent = node.parent,\n        children = node.children;\n\n\n    var parentNode = parent.elem || elem;\n    var element = parentNode.create(name);\n\n    node.elem = element;\n\n    if (value) {\n      element.text(value);\n    }\n\n    if (attrs) {\n      element.attr(attrs);\n    }\n\n    if (name === 'template') {\n      node.elem = new Elem(element.prop('content'));\n    }\n\n    if (children) {\n      children.forEach(forEachNode);\n    }\n  });\n\n  return new Elem(elem);\n}\n\n/**\r\n * @function px\r\n * @public\r\n * @param {String|Number} size - String containing pixels value or a number.\r\n * @returns {Number} Number of pixels.\r\n * @description Function for parsing pixel strings.\r\n *\r\n * @example\r\n * px('0px');  // 0\r\n * px('42px'); // 42\r\n */\nfunction px(size) {\n  return Number(String(size).replace(/px$/, ''));\n}\n\nfunction registerDBlock(Block) {\n  var DBlock = function (_Block) {\n    inherits(DBlock, _Block);\n\n    function DBlock() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      classCallCheck(this, DBlock);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DBlock.__proto__ || Object.getPrototypeOf(DBlock)).call.apply(_ref, [this].concat(args))), _this), _this.elems = null, _temp), possibleConstructorReturn(_this, _ret);\n    }\n\n    createClass(DBlock, [{\n      key: 'afterConstruct',\n      value: function afterConstruct() {\n        var children = this.$$.parent.children;\n        var name = this.args.name;\n\n        var found = void 0;\n\n        if (name) {\n          found = children.find(function (_ref2) {\n            var nodeName = _ref2.name;\n            return nodeName === 'd-block-' + name;\n          });\n\n          if (found && found.value.children.length) {\n            this.elems = found.value.children;\n          }\n        } else {\n          this.elems = children;\n        }\n      }\n    }]);\n    return DBlock;\n  }(Block);\n\n  DBlock.template = '<d-elements value=\"{elems}\" />';\n\n\n  return {\n    name: 'd-block',\n    value: DBlock\n  };\n}\n\nfunction registerDEach(Block, createBlock) {\n  var DEach = function (_Block) {\n    inherits(DEach, _Block);\n\n    function DEach(opts) {\n      classCallCheck(this, DEach);\n\n      var _this = possibleConstructorReturn(this, (DEach.__proto__ || Object.getPrototypeOf(DEach)).call(this, opts));\n\n      var _this$args = _this.args,\n          _this$args$item = _this$args.item,\n          itemName = _this$args$item === undefined ? '$item' : _this$args$item,\n          _this$args$index = _this$args.index,\n          indexName = _this$args$index === undefined ? '$index' : _this$args$index;\n\n\n      assign$1(_this.$$, {\n        uids: new Super({}),\n        items: new Arr([]),\n        UID: String(_this.args.uid),\n        itemName: itemName,\n        indexName: indexName\n      });\n      return _this;\n    }\n\n    createClass(DEach, [{\n      key: 'afterRender',\n      value: function afterRender() {\n        var _this2 = this;\n\n        this.constructValues(this.args.set);\n        this.watchArgs('set', function (set$$1) {\n          _this2.constructValues(set$$1);\n        });\n      }\n    }, {\n      key: 'constructValues',\n      value: function constructValues(set$$1) {\n        var _this3 = this;\n\n        var _$$ = this.$$,\n            _$$$elems = _$$.elems,\n            start = _$$$elems.start,\n            parentElem = _$$$elems.parent,\n            uids = _$$.uids,\n            parent = _$$.parent,\n            scope = _$$.scope,\n            itemName = _$$.itemName,\n            indexName = _$$.indexName,\n            UID = _$$.UID;\n        var children = this.children;\n\n        var $uids = uids.$;\n        var newKeys = {};\n        var newUIDs = {};\n\n        new Super(set$$1).forEach(function (item, index) {\n          scope[itemName] = item;\n          scope[indexName] = index;\n\n          var uid = parent.$$.evaluate(String(UID), null, null, false, false, _this3);\n\n          newKeys[uid] = newKeys[uid] || {};\n          newKeys[uid][index] = true;\n          newUIDs[index] = uid;\n        });\n\n        scope[itemName] = null;\n        scope[indexName] = null;\n\n        uids.forEach(function (items, uid) {\n          if (!newKeys[uid]) {\n            items.forEach(function (Item) {\n              Item.remove();\n            });\n\n            return;\n          }\n\n          items.splice(Object.keys(newKeys[uid]).length).forEach(function (Item) {\n            Item.remove();\n          });\n        });\n\n        var after = start;\n\n        new Super(set$$1).forEach(function (item, index) {\n          var uid = newUIDs[index];\n          var block = void 0;\n\n          if ($uids[uid] && $uids[uid].length) {\n            block = newKeys[uid][index] = uids.$[uid].shift();\n            block.$$.scope[indexName] = index;\n            block.$$.scope[itemName] = item;\n          } else {\n            block = newKeys[uid][index] = createBlock({\n              node: {\n                itemName: itemName,\n                indexName: indexName,\n                item: item,\n                index: index,\n                name: '#d-item',\n                block: parent,\n                children: children\n              },\n              after: after,\n              parent: parentElem,\n              parentBlock: _this3,\n              parentScope: parent\n            });\n          }\n\n          var _block$$$$elems = block.$$.elems,\n              start = _block$$$$elems.start,\n              end = _block$$$$elems.end;\n\n\n          if (start.prev().$[0] !== after.$[0]) {\n            var content = block.$$.elems.content;\n\n\n            new Elem([start, content, end]).insertAfter(after);\n          }\n\n          after = end;\n        });\n\n        this.$$.uids = new Super(newKeys).map(function (items) {\n          return new Super(items).values();\n        });\n      }\n    }]);\n    return DEach;\n  }(Block);\n\n  return {\n    name: 'd-each',\n    value: DEach\n  };\n}\n\nfunction registerDElements(Block, createBlock) {\n  var DElements = function (_Block) {\n    inherits(DElements, _Block);\n\n    function DElements() {\n      classCallCheck(this, DElements);\n      return possibleConstructorReturn(this, (DElements.__proto__ || Object.getPrototypeOf(DElements)).apply(this, arguments));\n    }\n\n    createClass(DElements, [{\n      key: 'afterConstruct',\n      value: function afterConstruct() {\n        var _this2 = this;\n\n        this.watchArgs('value', function (value) {\n          var _$$ = _this2.$$,\n              children = _$$.children,\n              mixins = _$$.mixins,\n              watchersToRemove = _$$.watchersToRemove,\n              _$$$elems = _$$.elems,\n              start = _$$$elems.start,\n              content = _$$$elems.content,\n              parent = _$$$elems.parent;\n\n          var after = start;\n\n          children.forEach(function (child) {\n            child.remove(true);\n          });\n          mixins.forEach(function (mixin) {\n            mixin.remove(true);\n          });\n          content.remove();\n\n          _this2.$$.children = new Arr([]);\n          _this2.$$.mixins = new Arr([]);\n          _this2.$$.watchersToRemove = watchersToRemove.filter(function (_ref) {\n            var watchers = _ref.watchers,\n                watcher = _ref.watcher,\n                forDElements = _ref.forDElements;\n\n            if (forDElements) {\n              return true;\n            }\n\n            var index = watchers.indexOf(watcher);\n\n            if (index !== -1) {\n              watchers.splice(index, 1);\n            }\n          });\n\n          var newContent = new Elem();\n\n          new Arr(value || []).forEach(function (child) {\n            var block = createBlock({\n              node: child,\n              after: after,\n              parent: parent,\n              parentBlock: _this2,\n              parentScope: _this2\n            });\n\n            if (block instanceof Block) {\n              var elems = block.$$.elems;\n\n\n              after = elems.end;\n\n              newContent.add(elems.start, elems.content, elems.end);\n            } else {\n              after = block;\n\n              newContent.add(block);\n            }\n          });\n\n          _this2.$$.elems.content = newContent;\n        });\n      }\n    }]);\n    return DElements;\n  }(Block);\n\n  return {\n    name: 'd-elements',\n    value: DElements\n  };\n}\n\nfunction registerDIf(Block) {\n  var DIf = function (_Block) {\n    inherits(DIf, _Block);\n\n    function DIf() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      classCallCheck(this, DIf);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DIf.__proto__ || Object.getPrototypeOf(DIf)).call.apply(_ref, [this].concat(args))), _this), _this.index = Infinity, _this.elems = null, _this.values = _this.children.map(function (child, i) {\n        var name = child.name,\n            attrs = child.attrs,\n            children = child.children;\n\n        var cond = _this.evaluateAndWatch(name === 'd-else' ? '{true}' : attrs.if || '{true}', function (newValue) {\n          if (!!newValue === _this.values.$[i]) {\n            return;\n          }\n\n          _this.values.$[i] = !!newValue;\n\n          if (i > _this.index) {\n            return;\n          }\n\n          if (i < _this.index) {\n            _this.index = i;\n            _this.elems = children;\n\n            return;\n          }\n\n          var found = _this.values.find(Boolean);\n\n          if (found) {\n            _this.index = found.key;\n            _this.elems = _this.children.$[found.key].children;\n          } else {\n            _this.index = Infinity;\n            _this.elems = null;\n          }\n        });\n\n        if (cond && _this.index === Infinity) {\n          _this.index = i;\n          _this.elems = children;\n        }\n\n        return cond;\n      }), _temp), possibleConstructorReturn(_this, _ret);\n    }\n\n    return DIf;\n  }(Block);\n\n  DIf.template = '<d-elements value=\"{elems}\"/>';\n\n\n  return {\n    name: 'd-if',\n    value: DIf\n  };\n}\n\nfunction registerDItem(Block) {\n  var DItem = function (_Block) {\n    inherits(DItem, _Block);\n\n    function DItem() {\n      classCallCheck(this, DItem);\n      return possibleConstructorReturn(this, (DItem.__proto__ || Object.getPrototypeOf(DItem)).apply(this, arguments));\n    }\n\n    return DItem;\n  }(Block);\n\n  DItem.template = '<d-elements value=\"{children}\"/>';\n\n\n  return {\n    name: '#d-item',\n    value: DItem\n  };\n}\n\nfunction registerDSwitch(Block) {\n  var DSwitch = function (_Block) {\n    inherits(DSwitch, _Block);\n\n    function DSwitch(opts) {\n      classCallCheck(this, DSwitch);\n\n      var _this = possibleConstructorReturn(this, (DSwitch.__proto__ || Object.getPrototypeOf(DSwitch)).call(this, opts));\n\n      _this.index = Infinity;\n      _this.elems = null;\n      var args = _this.args,\n          value = _this.args.value;\n\n      var wasDefault = void 0;\n\n      _this.values = _this.children.object(function (values, child, i) {\n        var name = child.name,\n            attrs = child.attrs,\n            children = child.children;\n\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (name !== 'd-case' && name !== 'd-default') {\n          return;\n        }\n\n        if (name === 'd-default') {\n          wasDefault = true;\n        }\n\n        var val = void 0;\n\n        if (name === 'd-default') {\n          val = args.value;\n        } else {\n          val = _this.evaluateAndWatch(attrs.if || '{undefined}', function (newValue) {\n            if (_this.equals(_this.values.$[i].value, newValue)) {\n              return;\n            }\n\n            _this.values.$[i].value = newValue;\n\n            if (i > _this.index) {\n              return;\n            }\n\n            if (i < _this.index) {\n              _this.index = i;\n              _this.elems = children;\n\n              return;\n            }\n\n            var found = _this.values.find(function (_ref) {\n              var value = _ref.value;\n              return _this.equals(value, args.value);\n            });\n\n            if (found) {\n              _this.index = found.key;\n              _this.elems = found.value.children;\n            } else {\n              _this.index = Infinity;\n              _this.elems = null;\n            }\n          });\n        }\n\n        if (_this.equals(val, value) && _this.index === Infinity) {\n          _this.index = i;\n          _this.elems = children;\n        }\n\n        values.push({\n          name: name,\n          children: children,\n          value: val\n        });\n      }, new Arr([]));\n      return _this;\n    }\n\n    createClass(DSwitch, [{\n      key: 'afterConstruct',\n      value: function afterConstruct() {\n        var _this2 = this;\n\n        this.watchArgs('value', function (newValue) {\n          _this2.index = Infinity;\n          _this2.values.forEach(function (_ref2, i) {\n            var name = _ref2.name,\n                value = _ref2.value,\n                children = _ref2.children;\n\n            var val = name === 'd-default' ? newValue : value;\n\n            if (_this2.equals(val, newValue) && _this2.index === Infinity) {\n              _this2.index = i;\n              _this2.elems = children;\n            }\n          });\n        });\n      }\n    }, {\n      key: 'equals',\n      value: function equals(value1, value2) {\n        return new Super(value1).equals(value2);\n      }\n    }]);\n    return DSwitch;\n  }(Block);\n\n  DSwitch.template = '<d-elements value=\"{elems}\"/>';\n\n\n  return {\n    name: 'd-switch',\n    value: DSwitch\n  };\n}\n\nfunction registerDText(Block) {\n  var DText = function (_Block) {\n    inherits(DText, _Block);\n\n    function DText() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      classCallCheck(this, DText);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DText.__proto__ || Object.getPrototypeOf(DText)).call.apply(_ref, [this].concat(args))), _this), _this.text = '', _temp), possibleConstructorReturn(_this, _ret);\n    }\n\n    createClass(DText, [{\n      key: 'afterConstruct',\n      value: function afterConstruct() {\n        var _this2 = this;\n\n        this.text = isNil(this.args.value) ? '' : this.args.value;\n\n        this.watchArgs('value', function (newValue) {\n          _this2.text = isNil(newValue) ? '' : newValue;\n        });\n      }\n    }]);\n    return DText;\n  }(Block);\n\n  DText.template = '<d-elements value=\"{[{ name: \\'#text\\', value: text }]}\"/>';\n\n\n  return {\n    name: 'd-text',\n    value: DText\n  };\n}\n\n\n\nvar Blocks = Object.freeze({\n\tregisterDBlock: registerDBlock,\n\tregisterDEach: registerDEach,\n\tregisterDElements: registerDElements,\n\tregisterDIf: registerDIf,\n\tregisterDItem: registerDItem,\n\tregisterDSwitch: registerDSwitch,\n\tregisterDText: registerDText\n});\n\nfunction registerDAttr(Mixin) {\n  var DAttr = function (_Mixin) {\n    inherits(DAttr, _Mixin);\n\n    function DAttr() {\n      classCallCheck(this, DAttr);\n      return possibleConstructorReturn(this, (DAttr.__proto__ || Object.getPrototypeOf(DAttr)).apply(this, arguments));\n    }\n\n    createClass(DAttr, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(newValue, oldValue) {\n        var elem = this.elem;\n\n\n        newValue = new Super(newValue).$;\n\n        new Super(oldValue).forEach(function (value, prop) {\n          if (!newValue[prop]) {\n            elem.removeAttr(prop);\n          }\n        });\n        elem.attr(newValue);\n      }\n    }]);\n    return DAttr;\n  }(Mixin);\n\n  return {\n    name: 'd-attr',\n    value: DAttr\n  };\n}\n\nfunction registerDBind(Mixin) {\n  var DBind = function (_Mixin) {\n    inherits(DBind, _Mixin);\n\n    function DBind() {\n      classCallCheck(this, DBind);\n      return possibleConstructorReturn(this, (DBind.__proto__ || Object.getPrototypeOf(DBind)).apply(this, arguments));\n    }\n\n    createClass(DBind, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(value) {\n        if (this.off) {\n          this.off();\n        }\n\n        if (!isFunction(value)) {\n          return;\n        }\n\n        this.off = this.elem.on(this.match[0], value);\n      }\n    }]);\n    return DBind;\n  }(Mixin);\n\n  return {\n    name: 'd-bind',\n    value: DBind\n  };\n}\n\nfunction registerDClass(Mixin) {\n  var DClass = function (_Mixin) {\n    inherits(DClass, _Mixin);\n\n    function DClass() {\n      classCallCheck(this, DClass);\n      return possibleConstructorReturn(this, (DClass.__proto__ || Object.getPrototypeOf(DClass)).apply(this, arguments));\n    }\n\n    createClass(DClass, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(newValue, oldValue) {\n        var elem = this.elem;\n\n\n        newValue = new Super(newValue).$;\n        oldValue = new Super(oldValue).$;\n\n        if (isArray(newValue)) {\n          iterate(oldValue, function (cls) {\n            if (isString(cls) && !newValue[cls]) {\n              elem.removeClass(cls);\n            }\n          });\n          iterate(newValue, function (cls) {\n            if (isString(cls)) {\n              elem.addClass(cls);\n            }\n          });\n        } else if (isString(newValue)) {\n          elem.class(newValue);\n        } else if (isObject(newValue)) {\n          iterate(oldValue, function (val, cls) {\n            if (val && !newValue[cls]) {\n              elem.removeClass(cls);\n            }\n          });\n          iterate(newValue, function (val, cls) {\n            if (val) {\n              elem.addClass(cls);\n            }\n          });\n        } else if (isString(oldValue)) {\n          elem.class('');\n        } else if (isArray(oldValue)) {\n          iterate(oldValue, function (cls) {\n            if (isString(cls)) {\n              elem.removeClass(cls);\n            }\n          });\n        } else if (isObject(oldValue)) {\n          iterate(oldValue, function (val, cls) {\n            if (val) {\n              elem.removeClass(cls);\n            }\n          });\n        }\n      }\n    }]);\n    return DClass;\n  }(Mixin);\n\n  return {\n    name: 'd-class',\n    value: DClass\n  };\n}\n\nfunction registerDElem(Mixin) {\n  var DElem = function (_Mixin) {\n    inherits(DElem, _Mixin);\n\n    function DElem() {\n      classCallCheck(this, DElem);\n      return possibleConstructorReturn(this, (DElem.__proto__ || Object.getPrototypeOf(DElem)).apply(this, arguments));\n    }\n\n    createClass(DElem, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(newValue, oldValue) {\n        var parent = this.$$.parent;\n\n\n        if (newValue !== oldValue && isString(oldValue)) {\n          delete parent[oldValue];\n        }\n\n        if (isString(newValue)) {\n          parent[newValue] = this.elem;\n        }\n      }\n    }]);\n    return DElem;\n  }(Mixin);\n\n  return {\n    name: 'd-elem',\n    value: DElem\n  };\n}\n\nfunction registerDHide(Mixin) {\n  var DHide = function (_Mixin) {\n    inherits(DHide, _Mixin);\n\n    function DHide() {\n      classCallCheck(this, DHide);\n      return possibleConstructorReturn(this, (DHide.__proto__ || Object.getPrototypeOf(DHide)).apply(this, arguments));\n    }\n\n    createClass(DHide, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(value) {\n        var elem = this.elem;\n\n\n        if (value) {\n          elem.hide();\n        } else {\n          elem.show();\n        }\n      }\n    }]);\n    return DHide;\n  }(Mixin);\n\n  return {\n    name: 'd-hide',\n    value: DHide\n  };\n}\n\nfunction registerDOn(Mixin) {\n  var DOn = function (_Mixin) {\n    inherits(DOn, _Mixin);\n\n    function DOn(opts) {\n      classCallCheck(this, DOn);\n\n      var _this = possibleConstructorReturn(this, (DOn.__proto__ || Object.getPrototypeOf(DOn)).call(this, opts));\n\n      _this.elem.on(_this.match[0], function () {\n        _this.evaluateOnce();\n      });\n      return _this;\n    }\n\n    return DOn;\n  }(Mixin);\n\n  DOn.evaluate = false;\n\n\n  return {\n    name: 'd-on',\n    value: DOn\n  };\n}\n\nfunction registerDShow(Mixin) {\n  var DShow = function (_Mixin) {\n    inherits(DShow, _Mixin);\n\n    function DShow() {\n      classCallCheck(this, DShow);\n      return possibleConstructorReturn(this, (DShow.__proto__ || Object.getPrototypeOf(DShow)).apply(this, arguments));\n    }\n\n    createClass(DShow, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(value) {\n        var elem = this.elem;\n\n\n        if (value) {\n          elem.show();\n        } else {\n          elem.hide();\n        }\n      }\n    }]);\n    return DShow;\n  }(Mixin);\n\n  return {\n    name: 'd-show',\n    value: DShow\n  };\n}\n\nfunction registerDStyle(Mixin) {\n  var DStyle = function (_Mixin) {\n    inherits(DStyle, _Mixin);\n\n    function DStyle() {\n      classCallCheck(this, DStyle);\n      return possibleConstructorReturn(this, (DStyle.__proto__ || Object.getPrototypeOf(DStyle)).apply(this, arguments));\n    }\n\n    createClass(DStyle, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(newValue, oldValue) {\n        var elem = this.elem;\n\n\n        newValue = new Super(newValue).$;\n\n        new Super(oldValue).forEach(function (value, prop) {\n          if (!newValue[prop]) {\n            elem.removeCSS(prop);\n          }\n        });\n        elem.css(newValue);\n      }\n    }]);\n    return DStyle;\n  }(Mixin);\n\n  return {\n    name: 'd-style',\n    value: DStyle\n  };\n}\n\nfunction registerDText$1(Mixin) {\n  var DText = function (_Mixin) {\n    inherits(DText, _Mixin);\n\n    function DText() {\n      classCallCheck(this, DText);\n      return possibleConstructorReturn(this, (DText.__proto__ || Object.getPrototypeOf(DText)).apply(this, arguments));\n    }\n\n    createClass(DText, [{\n      key: 'afterUpdate',\n      value: function afterUpdate(value) {\n        this.elem.text(isNil(value) ? '' : '' + value);\n      }\n    }]);\n    return DText;\n  }(Mixin);\n\n  return {\n    name: 'd-text',\n    value: DText\n  };\n}\n\nfunction registerDValidate(Mixin) {\n  var DValidate = function (_Mixin) {\n    inherits(DValidate, _Mixin);\n\n    function DValidate(opts) {\n      classCallCheck(this, DValidate);\n\n      var _this = possibleConstructorReturn(this, (DValidate.__proto__ || Object.getPrototypeOf(DValidate)).call(this, opts));\n\n      var elem = _this.elem;\n\n      var validator = _this.evaluateOnce();\n\n      if (isFunction(validator)) {\n        elem.validate(validator);\n      }\n      return _this;\n    }\n\n    return DValidate;\n  }(Mixin);\n\n  DValidate.evaluate = false;\n\n\n  return {\n    name: 'd-validate',\n    value: DValidate\n  };\n}\n\nvar propSwitcher = switcher('strictEquals', function (type, elem) {\n  return elem.hasAttr('contenteditable') || elem.hasAttr('contentEditable') ? 'text' : 'value';\n}).case('input', function (type) {\n  if (type === 'file') {\n    return 'files';\n  }\n\n  return type === 'radio' || type === 'checkbox' ? 'checked' : 'value';\n});\nvar setValueSwitcher = switcher('strictEquals', function (value) {\n  return value;\n}).case('input', function (value, type, inputValue) {\n  if (type !== 'radio' && type !== 'checkbox') {\n    return value;\n  }\n\n  if (type === 'radio') {\n    return value === inputValue;\n  }\n\n  return value.indexOf(inputValue) !== -1;\n});\nvar getValueSwitcher = switcher('strictEquals', function (value) {\n  return value;\n}).case('input', function (value, type, inputValue, values) {\n  if (type !== 'radio' && type !== 'checkbox') {\n    return value;\n  }\n\n  if (type === 'radio') {\n    return value ? inputValue : null;\n  }\n\n  if (value) {\n    if (values) {\n      return values.indexOf(inputValue) === -1 ? new Arr(values).concat(inputValue).$ : values;\n    }\n\n    return [inputValue];\n  }\n\n  if (!isArray(values)) {\n    return [];\n  }\n\n  var index = values.indexOf(inputValue);\n\n  if (index !== -1) {\n    return [].concat(toConsumableArray(new Arr(values).slice(0, index).$), toConsumableArray(new Arr(values).slice(index + 1).$));\n  }\n\n  return values;\n});\nvar listenerSwitcher = switcher('strictEquals', 'input').case('select', 'change').case('input', function (type) {\n  return type === 'radio' || type === 'checkbox' || type === 'color' || type === 'file' ? 'change' : 'input';\n});\n\nfunction registerDValue(Mixin) {\n  var DValue = function (_Mixin) {\n    inherits(DValue, _Mixin);\n\n    function DValue(opts) {\n      classCallCheck(this, DValue);\n\n      var _this = possibleConstructorReturn(this, (DValue.__proto__ || Object.getPrototypeOf(DValue)).call(this, opts));\n\n      var _this$$$ = _this.$$,\n          _value = _this$$$._value,\n          parent = _this$$$.parent,\n          elem = _this.elem;\n\n      var type = elem.prop('type');\n\n      _this.prop = propSwitcher(elem.name, [type, elem]);\n      _this.type = type;\n\n      var initialScopeValue = parent.$$.evaluate('{' + _value + '}', function (newValue) {\n        _this.setProp(newValue);\n      }, _this);\n      var initialElemValue = _this.getProp(initialScopeValue);\n\n      if (isNil(initialScopeValue) || type === 'checkbox') {\n        parent[_value] = initialElemValue;\n      } else {\n        _this.setProp(initialScopeValue);\n      }\n\n      elem.on(listenerSwitcher(elem.name, [type]), function (e) {\n        if (e.target === elem.$[0]) {\n          parent[_value] = _this.getProp(parent[_value]);\n        }\n      });\n      return _this;\n    }\n\n    createClass(DValue, [{\n      key: 'setProp',\n      value: function setProp(value) {\n        var elem = this.elem,\n            prop = this.prop,\n            type = this.type;\n\n\n        if (prop === 'text') {\n          elem.text(value);\n        } else {\n          elem.prop(prop, setValueSwitcher(elem.name, [value, type, elem.$[0].value]));\n        }\n      }\n    }, {\n      key: 'getProp',\n      value: function getProp(values) {\n        var elem = this.elem,\n            prop = this.prop,\n            type = this.type;\n\n\n        return prop === 'text' ? elem.text() : getValueSwitcher(elem.name, [elem.prop(prop), type, elem.$[0].value, values]);\n      }\n    }]);\n    return DValue;\n  }(Mixin);\n\n  DValue.evaluate = false;\n\n\n  return {\n    name: 'd-value',\n    value: DValue\n  };\n}\n\n\n\nvar Mixins = Object.freeze({\n\tregisterDAttr: registerDAttr,\n\tregisterDBind: registerDBind,\n\tregisterDClass: registerDClass,\n\tregisterDElem: registerDElem,\n\tregisterDHide: registerDHide,\n\tregisterDOn: registerDOn,\n\tregisterDShow: registerDShow,\n\tregisterDStyle: registerDStyle,\n\tregisterDText: registerDText$1,\n\tregisterDValidate: registerDValidate,\n\tregisterDValue: registerDValue\n});\n\n/**\r\n * @module Block\r\n * @private\r\n * @mixin\r\n * @description Exports Block class.\r\n */\n\n/**\r\n * @callback Watcher\r\n * @param {*} newValue - New value.\r\n * @param {*} oldValue - Old value.\r\n */\n\nvar blocks = Object.create(null);\nvar mixins = Object.create(null);\nvar isPrototypeOf = {}.isPrototypeOf;\nvar tagName = new RegExp('^' + htmlAllowedTagSymbols + '$', 'i');\nvar attrName = new RegExp('^' + htmlAllowedAttrSymbols + '$');\nvar expressionRegExp = /^\\{[\\s\\S]+\\}$/;\nvar _global$1 = global$1;\nvar document$1 = _global$1.document;\n\nvar svgNS = 'http://www.w3.org/2000/svg';\nvar onEvalError = void 0;\nvar evalMode = void 0;\nvar getting = void 0;\n\n/**\r\n * @class Block\r\n * @public\r\n * @param {Object} opts - Element options.\r\n * @returns {Block} Instance of Block.\r\n * @description Class for dynamic templating.\r\n *\r\n * @example\r\n * import { D, Block, initApp, registerBlock } from 'dwayne';\r\n *\r\n * class App extends Block {\r\n *   static template = '<Hello text=\"{text}\"/>';\r\n *\r\n *   constructor(args, children) {\r\n *     super(args, children);\r\n *\r\n *     this.text = 'world (0)';\r\n *     this.times = 0;\r\n *\r\n *     this.setInterval();\r\n *   }\r\n *\r\n *   setInterval() {\r\n *     D(1000).interval(() => {\r\n *       this.text = `world (${ ++this.times })`;\r\n *     });\r\n *   }\r\n * }\r\n *\r\n * class Hello extends Block {\r\n *   static template = 'Hello, <d-text value=\"{args.text}\"/>!';\r\n * }\r\n *\r\n * Block.App = App;\r\n * Block.Hello = Hello;\r\n *\r\n * initApp();\r\n */\n\nvar Block = function () {\n  createClass(Block, null, [{\n    key: 'onEvalError',\n\n    /**\r\n     * @member {Boolean} [Block.collapseWhiteSpace = true]\r\n     * @type {Boolean}\r\n     * @public\r\n     * @description If the whitespace between html elements and\r\n     * in the start and the end inside the tag should be omitted during parsing.\r\n     */\n    get: function get() {\n      return onEvalError;\n    }\n\n    /**\r\n     * @member {Object} [Block.defaultArgs = true]\r\n     * @type {Object}\r\n     * @public\r\n     * @description Provide default args if that args may not appear in the args\r\n     * (using \"d-rest\") but you use them in your template and want them to be watched.\r\n     */\n    ,\n    set: function set(listener) {\n      if (isFunction(listener)) {\n        onEvalError = listener;\n      } else {\n        onEvalError = null;\n      }\n    }\n  }]);\n\n  function Block(opts) {\n    var _this = this;\n\n    classCallCheck(this, Block);\n    var name = opts.name,\n        originalArgs = opts.args,\n        children = opts.children,\n        block = opts.block,\n        parent = opts.parent,\n        parentBlock = opts.parentBlock,\n        parentScope = opts.parentScope;\n\n    var watchersToRemove = new Arr([]);\n\n    Object.defineProperties(this, {\n      /**\r\n       * @member {Block} Block#$\r\n       * @type {Block}\r\n       * @public\r\n       * @description This.\r\n       */\n      $: {\n        value: this\n      },\n\n      /**\r\n       * @member {Object} Block#$$\r\n       * @type {Object}\r\n       * @protected\r\n       * @property {Object} args - Private args scope.\r\n       * @property {Arr} children - Child blocks.\r\n       * @property {Arr} mixins - Child mixins.\r\n       * @property {Object} elems - Elements connected to the block.\r\n       * @property {Elem} elems.parent - Parent element.\r\n       * @property {Elem} elems.start - Start comment block.\r\n       * @property {Elem} elems.end - End comment block.\r\n       * @property {Elem} elems.content - Content elements.\r\n       * @property {Function} evaluate - Evaluate function.\r\n       * @property {Object} global - Private global scope.\r\n       * @property {Object} locals - Private locals scope.\r\n       * @property {Arr} watchersToRemove - Watchers to remove before removing element.\r\n       */\n      $$: {\n        value: {\n          name: name,\n          parent: parentScope,\n          parentBlock: parentBlock,\n          children: new Arr([]),\n          mixins: new Arr([]),\n          Block: block,\n          elems: {\n            start: doc.createComment(' ' + name + ': start '),\n            end: doc.createComment(' ' + name + ': end '),\n            content: new Elem(),\n            parent: parent\n          },\n          watchersToRemove: watchersToRemove,\n          evaluate: function evaluate(expression, onChange, instance, forDElements, forDItem, forDEach) {\n            if (!expressionRegExp.test(expression)) {\n              return expression;\n            }\n\n            forDElements = !!forDElements;\n            forDItem = !!forDItem;\n            expression = expression.replace(/^\\{|\\}$/g, '');\n\n            var store = name === '#d-item' && !forDItem || forDEach ? (forDEach || _this).$$.scope : _this;\n\n            /* eslint no-new-func: 0 */\n\n            var _ref = instance ? instance.$$ : {},\n                watchersToRemove = _ref.watchersToRemove;\n\n            var func = new Function('', 'with(document.DwayneStore){$$.expr=eval(\"$$.expr=\"+$$.expr);return $$.expr}');\n\n            return evaluate.call(_this);\n\n            function evaluate() {\n              var _this2 = this;\n\n              var result = void 0;\n\n              if (onChange) {\n                evalMode = true;\n                getting = new Arr([]);\n              }\n\n              store.$$.expr = expression;\n              document$1.DwayneStore = store;\n\n              try {\n                result = func();\n              } catch (err) {\n                if (onEvalError) {\n                  onEvalError(err);\n                }\n              }\n\n              if (onChange) {\n                (function () {\n                  var localWatchers = new Arr([]);\n\n                  getting.forEach(function (watchers) {\n                    var watcher = function watcher() {\n                      var newResult = evaluate.call(_this2);\n\n                      if (newResult !== result) {\n                        onChange(newResult, result);\n                      }\n                    };\n                    var watcherBlock = {\n                      forDElements: forDElements,\n                      watcher: watcher,\n                      watchers: watchers\n                    };\n\n                    watcher.onRemove = function () {\n                      localWatchers.forEach(function (watcherBlock) {\n                        var localWatcher = watcherBlock.watcher,\n                            watchers = watcherBlock.watchers;\n\n                        var index1 = watchersToRemove.indexOf(watcherBlock);\n\n                        if (index1 !== -1) {\n                          watchersToRemove.splice(index1, 1);\n                        }\n\n                        if (watcher !== localWatcher) {\n                          var index2 = watchers.indexOf(watcher);\n\n                          if (index2 !== -1) {\n                            watchers.splice(index2, 1);\n                          }\n                        }\n                      });\n                    };\n\n                    localWatchers.push(watcherBlock);\n                    watchersToRemove.push(watcherBlock);\n                    watchers.push(watcher);\n                  });\n\n                  evalMode = false;\n                  getting = new Arr([]);\n                })();\n              }\n\n              store.$$.expr = null;\n              document$1.DwayneStore = null;\n\n              return result;\n            }\n          }\n        }\n      }\n    });\n\n    var args = new Super(originalArgs).map(function (value, arg) {\n      if (name === 'd-each' && (arg === 'item' || arg === 'index' || arg === 'uid')) {\n        return value;\n      }\n\n      var forDElements = name === 'd-elements' && arg === 'value';\n\n      return parentScope.$$.evaluate(value, function (value) {\n        _this.args[arg] = value;\n      }, _this, forDElements, forDElements && parentBlock.$$.name === '#d-item');\n    }).$;\n\n    this.args = args;\n    this.children = children || new Arr([]);\n    this.global = Object.create(parentScope ? Object.create(parentScope.global) : null);\n\n    this.$$.elems.start.$[0].DwayneBlock = this;\n    this.$$.elems.end.$[0].DwayneBlock = this;\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  createClass(Block, [{\n    key: 'afterConstruct',\n    value: function afterConstruct() {}\n  }, {\n    key: 'afterRender',\n    value: function afterRender() {}\n  }, {\n    key: 'beforeRemove',\n    value: function beforeRemove() {}\n  }, {\n    key: 'evaluateAndWatch',\n    value: function evaluateAndWatch(expression, callback) {\n      return this.$$.parent.$$.evaluate(expression, callback, this);\n    }\n  }, {\n    key: 'evaluateOnce',\n    value: function evaluateOnce(expression) {\n      return this.$$.parent.$$.evaluate(expression);\n    }\n\n    /**\r\n     * @method Block#remove\r\n     * @public\r\n     * @description Method fot forcing the block to be removed. Calls\r\n     * remove method for all of its child blocks and calls beforeRemove function.\r\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(isParentSignal) {\n      var _$$ = this.$$,\n          parentBlock = _$$.parentBlock,\n          children = _$$.children,\n          mixins = _$$.mixins,\n          _$$$elems = _$$.elems,\n          start = _$$$elems.start,\n          content = _$$$elems.content,\n          end = _$$$elems.end,\n          watchersToRemove = _$$.watchersToRemove;\n\n\n      removeWatchers(watchersToRemove);\n\n      children.forEach(function (child) {\n        child.remove(true);\n      });\n\n      mixins.forEach(function (mixin) {\n        mixin.remove(true);\n      });\n\n      try {\n        this.beforeRemove();\n      } catch (err) {\n        console.error('Uncaught error in beforeRemove:', err);\n      }\n\n      if (!isParentSignal && parentBlock) {\n        var index = parentBlock.$$.children.indexOf(this);\n\n        if (index !== -1) {\n          parentBlock.$$.children.splice(index, 1);\n        }\n      }\n\n      new Elem([start, content, end]).remove();\n    }\n\n    /**\r\n     * @method Block#watchArgs\r\n     * @public\r\n     * @param {String} arg - Arg to watch.\r\n     * @param {Watcher} watcher - Called when watched arg is changed.\r\n     */\n\n  }, {\n    key: 'watchArgs',\n    value: function watchArgs(arg, watcher) {\n      validate$1([arg, watcher], ['string', 'function'], 'Block#watchArgs');\n\n      if (!this.$$.args[arg]) {\n        constructPublicScope(this.args, defineProperty({}, arg, this.args[arg]), this.$$.args);\n      }\n\n      this.$$.args[arg].watchers.perm.push(watcher);\n    }\n\n    /**\r\n     * @method Block#watchGlobal\r\n     * @public\r\n     * @param {String} global - Global variable to watch.\r\n     * @param {Watcher} watcher - Called when watched global is changed.\r\n     */\n\n  }, {\n    key: 'watchGlobal',\n    value: function watchGlobal(global, watcher) {\n      validate$1([global, watcher], ['string', 'function'], 'Block#watchArgs');\n\n      if (!this.$$.global[global]) {\n        constructPublicScope(this.global, defineProperty({}, global, this.global[global]), this.$$.global);\n      }\n\n      this.$$.global[global].watchers.perm.push(watcher);\n    }\n\n    /**\r\n     * @method Block#watchLocals\r\n     * @public\r\n     * @param {String} local - Local variable to watch.\r\n     * @param {Watcher} watcher - Called when watched local is changed.\r\n     */\n\n  }, {\n    key: 'watchLocals',\n    value: function watchLocals(local, watcher) {\n      validate$1([local, watcher], ['string', 'function'], 'Block#watchLocals');\n\n      if (!this.$$.locals[local]) {\n        constructPublicScope(this, defineProperty({}, local, this[local]), this.$$.locals);\n      }\n\n      this.$$.locals[local].watchers.perm.push(watcher);\n    }\n  }]);\n  return Block;\n}();\n\nBlock.collapseWhiteSpace = true;\nBlock.defaultArgs = {};\n\n\nregisterBuiltIns(Blocks, Block);\n\nvar Mixin = function () {\n  function Mixin(opts) {\n    var _this3 = this;\n\n    classCallCheck(this, Mixin);\n    var value = opts.value,\n        elem = opts.elem,\n        match = opts.match,\n        parentBlock = opts.parentBlock,\n        parentScope = opts.parentScope;\n\n\n    Object.defineProperties(this, {\n      $$: {\n        value: {\n          _value: value,\n          parent: parentScope,\n          parentBlock: parentBlock,\n          watchersToRemove: new Arr([])\n        }\n      }\n    });\n\n    this.match = new Arr(match).slice(1).$;\n    this.elem = elem;\n\n    if (new Super(this).proto().$.constructor.evaluate) {\n      this.value = this.evaluateAndWatch(function (newValue, oldValue) {\n        _this3.value = newValue;\n\n        try {\n          _this3.afterUpdate(newValue, oldValue);\n        } catch (err) {\n          console.error('Uncaught error in ' + name + '#onUpdate:', err);\n        }\n      });\n\n      this.afterUpdate(this.value);\n    }\n\n    if (parentBlock) {\n      parentBlock.$$.mixins.push(this);\n    }\n  }\n\n  createClass(Mixin, [{\n    key: 'afterUpdate',\n    value: function afterUpdate() {}\n  }, {\n    key: 'beforeRemove',\n    value: function beforeRemove() {}\n  }, {\n    key: 'evaluateAndWatch',\n    value: function evaluateAndWatch(callback) {\n      var _$$2 = this.$$,\n          _value = _$$2._value,\n          parent = _$$2.parent;\n\n\n      return parent.$$.evaluate(_value, callback, this);\n    }\n  }, {\n    key: 'evaluateOnce',\n    value: function evaluateOnce() {\n      var _$$3 = this.$$,\n          _value = _$$3._value,\n          parent = _$$3.parent;\n\n\n      return parent.$$.evaluate(_value);\n    }\n\n    /**\r\n     * @method Mixin#remove\r\n     * @public\r\n     * @description Method fot forcing the mixin to be removed.\r\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(isParentSignal) {\n      var _$$4 = this.$$,\n          parentBlock = _$$4.parentBlock,\n          watchersToRemove = _$$4.watchersToRemove;\n\n\n      removeWatchers(watchersToRemove);\n\n      try {\n        this.beforeRemove();\n      } catch (err) {\n        console.error('Uncaught error in beforeRemove:', err);\n      }\n\n      if (!isParentSignal && parentBlock) {\n        var index = parentBlock.$$.mixins.indexOf(this);\n\n        if (index !== -1) {\n          parentBlock.$$.mixins.splice(index, 1);\n        }\n      }\n    }\n  }]);\n  return Mixin;\n}();\n\nMixin.evaluate = true;\n\n\nregisterBuiltIns(Mixins, Mixin);\n\nfunction initApp() {\n  var root = _find('d-root').first();\n\n  if (!root.length) {\n    throw new Error('No d-root element is found! (initApp)');\n  }\n\n  registerBlocks(Block, blocks);\n\n  iterate(Mixin, function (Mixin, name) {\n    if (name === 'evaluate') {\n      return;\n    }\n\n    if (!isFunction(Mixin)) {\n      console.warn('The \"' + name + '\" mixin is not a function and will not be registered (initApp)');\n\n      return;\n    }\n\n    if (!attrName.test(name)) {\n      console.warn('Name \"' + name + '\" is not allowed for mixins so the mixin will not be registered (initApp)');\n\n      return;\n    }\n\n    if (!isInstanceOfMixin(Mixin)) {\n      console.warn('The \"' + name + '\" mixin does not extend Mixin and will not be registered (initApp)');\n\n      return;\n    }\n\n    mixins[name] = Mixin;\n\n    defineProperties(Mixin, {\n      _match: new RegExp('^' + name + '(?:-([\\\\s\\\\S]+))?$')\n    });\n  });\n\n  var block = root.attr('block');\n\n  if (!blocks[block]) {\n    throw new Error('No \"' + block + '\" block is registered! (initApp)');\n  }\n\n  var replacement = doc.createComment(' d-root: start ');\n  var parent = root.parent();\n\n  replacement.add(doc.createComment(' d-root: end '));\n\n  root.replace(replacement);\n\n  createBlock({\n    node: {\n      name: block,\n      attrs: {},\n      children: new Arr([])\n    },\n    after: replacement.first(),\n    parent: parent\n  });\n}\n\nfunction registerBlocks(Block, blocks) {\n  iterate(Block, function (Block, name) {\n    if (name === 'collapseWhiteSpace' || name === 'defaultArgs' || name === 'template') {\n      return;\n    }\n\n    if (!isFunction(Block)) {\n      console.warn('The \"' + name + '\" block is not a function and will not be registered (initApp)');\n\n      return;\n    }\n\n    if (!tagName.test(name) && name !== '#d-item') {\n      console.warn('Name \"' + name + '\" is not allowed for blocks so the block will not be registered (initApp)');\n\n      return;\n    }\n\n    if (!isInstanceOfBlock(Block)) {\n      console.warn('The \"' + name + '\" block does not extend Block and will not be registered (initApp)');\n\n      return;\n    }\n\n    var children = Object.create(blocks);\n\n    blocks[name] = {\n      block: Block,\n      html: deepCloneChildren(markupToJSON('' + (Block.template || ''), Block.collapseWhiteSpace)),\n      children: children\n    };\n\n    registerBlocks(Block, children);\n  });\n}\n\nfunction registerBuiltIns(set$$1, proto) {\n  iterate(set$$1, function (register) {\n    var _register = register(proto, createBlock),\n        name = _register.name,\n        value = _register.value;\n\n    Object.defineProperty(proto, name, {\n      value: value,\n      enumerable: true\n    });\n  });\n}\n\nfunction createBlock(_ref2) {\n  var node = _ref2.node,\n      after = _ref2.after,\n      parent = _ref2.parent,\n      parentBlock = _ref2.parentBlock,\n      parentScope = _ref2.parentScope;\n\n  parentScope = node && node.block || parentScope;\n\n  var name = node && node.name || 'UnknownBlock';\n  var args = node && node.attrs || {};\n  var children = node && node.children || new Arr([]);\n  var elem = parent.prop('namespaceURI') === svgNS ? doc.svg() : new Elem(doc.template().$[0].content);\n  var localBlocks = parentScope ? parentScope.$$.Block.children : blocks;\n  var constructor = node && node.name && localBlocks[node.name] ? localBlocks[node.name].block : null;\n  var dBlockMatch = void 0;\n\n  if (!children.length && (dBlockMatch = name.match(/^d-block-([\\s\\S]+)$/) || name === 'd-block')) {\n    constructor = blocks['d-block'];\n\n    args.name = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  if (!constructor) {\n    var _ret2 = function () {\n      var value = node.value,\n          children = node.children;\n\n\n      if (name === '#text' && expressionRegExp.test(value)) {\n        return {\n          v: createBlock({\n            node: {\n              name: 'd-text',\n              attrs: { value: value },\n              children: new Arr([]),\n              block: parentScope\n            },\n            after: after,\n            parent: parent,\n            parentBlock: parentBlock,\n            parentScope: parentScope\n          })\n        };\n      }\n\n      var element = elem.create(name);\n      var currentMixins = new Arr([]);\n\n      var attrs = new Super(args).object(function (object, value, attr) {\n        var match = iterate(mixins, function (Mixin, name) {\n          var match = attr.match(Mixin._match);\n\n          if (match) {\n            return {\n              match: match,\n              name: name\n            };\n          }\n        });\n\n        if (match) {\n          currentMixins.push({\n            name: match.name,\n            match: match.match,\n            value: value,\n            elem: element,\n            parentBlock: parentBlock,\n            parentScope: parentScope\n          });\n\n          return;\n        }\n\n        object[attr] = parentScope.$$.evaluate(value, function (value) {\n          element.attr(attr, value);\n        }, parentBlock);\n      }).$;\n\n      if (!isNil(value)) {\n        element.text(value);\n      }\n\n      if (attrs) {\n        element.attr(attrs);\n      }\n\n      if (after.length) {\n        element.insertAfter(after);\n      } else {\n        element.into(parent);\n      }\n\n      after = new Elem();\n\n      if (children) {\n        transformDIfChildren(children).forEach(function (child) {\n          var block = createBlock({\n            node: child,\n            after: after,\n            parent: element,\n            parentBlock: parentBlock,\n            parentScope: parentScope\n          });\n\n          if (block instanceof Block) {\n            after = block.$$.elems.end;\n          } else {\n            after = block;\n          }\n        });\n      }\n\n      currentMixins.forEach(function (opts) {\n        createMixin(opts);\n      });\n\n      return {\n        v: element\n      };\n    }();\n\n    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n  }\n\n  var block = node && node.name ? localBlocks[node.name] : null;\n  var blockInstance = new constructor({\n    name: name,\n    args: args,\n    children: children,\n    block: block,\n    parent: parent,\n    parentBlock: parentBlock,\n    parentScope: parentScope\n  });\n\n  Object.defineProperties(blockInstance, {\n    args: {\n      value: blockInstance.args\n    },\n    global: {\n      value: blockInstance.global\n    }\n  });\n\n  var html$$1 = name === 'd-elements' ? new Arr(blockInstance.args.value || []) : deepCloneChildren(block.html, blockInstance);\n\n  if (name === 'd-elements' && parentBlock.$$.name === '#d-item') {\n    html$$1 = deepCloneChildren(html$$1, parentBlock);\n  }\n\n  var $$ = blockInstance.$$,\n      Args = blockInstance.args,\n      global = blockInstance.global,\n      locals = objectWithoutProperties(blockInstance, ['$$', 'args', 'global']);\n\n  var eventualArgs = _extends({}, constructor.defaultArgs, Args);\n\n  delete locals.$;\n  delete locals.$$;\n\n  $$.args = constructPrivateScope(eventualArgs);\n  $$.locals = constructPrivateScope(locals);\n  $$.global = constructPrivateScope(global, 'global', parentScope);\n\n  if (name === '#d-item') {\n    var _scopeValues;\n\n    var scopeValues = (_scopeValues = {}, defineProperty(_scopeValues, node.itemName, node.item), defineProperty(_scopeValues, node.indexName, node.index), _scopeValues);\n    var _parent = blockInstance;\n    var scope = parentScope;\n    var DItemFound = void 0;\n\n    while (!DItemFound && (_parent = _parent.$$.parentBlock)) {\n      DItemFound = _parent.$$.name === '#d-item';\n    }\n\n    if (DItemFound) {\n      scope = _parent.$$.scope;\n    }\n\n    $$.Block = parentScope.$$.Block;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = Object.create(scope), scopeValues, $$.privateScope);\n  }\n\n  if (name === 'd-each') {\n    $$.scope = Object.create(parentScope);\n  }\n\n  constructPublicScope(Args, eventualArgs, $$.args);\n  constructPublicScope(global, global, $$.global);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error('Uncaught error in ' + name + '#afterConstruct:', err);\n  }\n\n  var elems = new Elem([$$.elems.start, $$.elems.end]);\n\n  if (after.length) {\n    elems.insertAfter(after);\n  } else {\n    elems.into(parent);\n  }\n\n  after = $$.elems.start;\n\n  // console.log(blockInstance);\n\n  transformDIfChildren(html$$1).forEach(function (child) {\n    var block = createBlock({\n      node: child,\n      after: after,\n      parent: parent,\n      parentBlock: blockInstance,\n      parentScope: parentScope\n    });\n\n    if (block instanceof Block) {\n      var _elems = block.$$.elems;\n\n\n      after = _elems.end;\n\n      $$.elems.content.add(_elems.start, _elems.content, _elems.end);\n    } else {\n      after = block;\n\n      $$.elems.content.add(block);\n    }\n  });\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error('Uncaught error in ' + name + '#afterRender:', err);\n  }\n\n  return blockInstance;\n}\n\nfunction createMixin(_ref3) {\n  var name = _ref3.name,\n      value = _ref3.value,\n      match = _ref3.match,\n      elem = _ref3.elem,\n      parentBlock = _ref3.parentBlock,\n      parentScope = _ref3.parentScope;\n\n  var Mixin = mixins[name];\n\n  new Mixin({\n    value: value,\n    match: match,\n    elem: elem,\n    parentBlock: parentBlock,\n    parentScope: parentScope\n  });\n}\n\nfunction deepCloneChildren(children, block) {\n  return new Arr(children || []).map(function (child) {\n    var name = child.name,\n        attrs = child.attrs,\n        value = child.value,\n        children = child.children;\n\n    var newChild = {\n      name: name,\n      value: value,\n      attrs: _extends({}, attrs)\n    };\n\n    if (block) {\n      newChild.block = block;\n    }\n\n    if (children) {\n      newChild.children = deepCloneChildren(children, block);\n    }\n\n    return newChild;\n  });\n}\n\nfunction transformDIfChildren(children) {\n  return new Arr(children || []).concat({}).object(function (object, child) {\n    var name = child.name;\n    var html$$1 = object.html,\n        ifElse = object.ifElse;\n\n\n    if (name !== 'd-else-if' && name !== 'd-else') {\n      if (ifElse) {\n        html$$1.push({\n          name: 'd-if',\n          block: ifElse.$[0].block,\n          children: ifElse\n        });\n\n        object.ifElse = null;\n      }\n\n      if (name === 'd-if') {\n        object.ifElse = new Arr([child]);\n      } else if (!isUndefined(name)) {\n        html$$1.push(child);\n      }\n    } else {\n      (ifElse || html$$1).push(child);\n\n      if (name === 'd-else' && ifElse) {\n        html$$1.push({\n          name: 'd-if',\n          block: ifElse.$[0].block,\n          children: ifElse\n        });\n\n        object.ifElse = null;\n      }\n    }\n  }, {\n    html: new Arr([]),\n    ifElse: null\n  }).$.html;\n}\n\nfunction isInstanceOfBlock(block) {\n  return isPrototypeOf.call(Block, block) && isPrototypeOf.call(Block.prototype, block.prototype);\n}\n\nfunction isInstanceOfMixin(mixin) {\n  return isPrototypeOf.call(Mixin, mixin) && isPrototypeOf.call(Mixin.prototype, mixin.prototype);\n}\n\nfunction removeWatchers(watchersToRemove) {\n  watchersToRemove.forEach(function (_ref4) {\n    var watcher = _ref4.watcher,\n        watchers = _ref4.watchers;\n\n    var index = watchers.indexOf(watcher);\n\n    if (index !== -1) {\n      watchers.splice(index, 1);\n    }\n  });\n}\n\nfunction constructPrivateScope(object, type, parentScope) {\n  var scope = {};\n\n  if (type === 'global') {\n    scope = Object.create(parentScope ? parentScope.$$.global : null);\n  }\n\n  return new Super(object).object(function (scope, value, key) {\n    scope[key] = {\n      value: value,\n      watchers: {\n        temp: new Arr([]),\n        perm: new Arr([])\n      }\n    };\n  }, scope).$;\n}\n\nfunction constructPublicScope(scope, scopeValues, privateScope) {\n  new Super(scope).define(new Super(scopeValues).map(function (value, key) {\n    var scope = privateScope[key];\n\n    return {\n      get: function get() {\n        if (evalMode) {\n          if (getting.indexOf(scope.watchers.temp) === -1) {\n            getting.push(scope.watchers.temp);\n          }\n        }\n\n        return scope.value;\n      },\n      set: function set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        var oldTempWatchers = scope.watchers.temp;\n        var oldValue = scope.value;\n\n        scope.watchers.temp = new Arr([]);\n        scope.value = value;\n\n        oldTempWatchers.forEach(function (watcher) {\n          watcher.onRemove();\n          watcher();\n        });\n        scope.watchers.perm.forEach(function (watcher) {\n          watcher(value, oldValue);\n        });\n      }\n    };\n  }).$);\n}\n\nfunction wrap(Block) {\n  var middlewares = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  return new Arr(middlewares).reduce(function (Block, middleware) {\n    if (!isFunction(middleware)) {\n      return Block;\n    }\n\n    var block = middleware(Block);\n\n    return isInstanceOfBlock(block) ? block : Block;\n  }, Block);\n}\n\n/**\r\n * @module Num\r\n * @private\r\n * @mixin\r\n * @description Exports Num class.\r\n */\n\nvar toRadian = Math.PI / 180;\nvar toDegree = 180 / Math.PI;\nvar ln2 = Math.LN2;\nvar ln10 = Math.LN10;\n\n/**\r\n * @class Num\r\n * @extends Super\r\n * @public\r\n * @param {Number} [number = 0] - A number to wrap.\r\n * @returns {Num} Instance of Num.\r\n * @description Wrap of a number.\r\n *\r\n * @example\r\n * const num = new Num(1);\r\n */\n\nvar Num = function (_Super) {\n  inherits(Num, _Super);\n\n  function Num() {\n    var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    classCallCheck(this, Num);\n    return possibleConstructorReturn(this, (Num.__proto__ || Object.getPrototypeOf(Num)).call(this, +number));\n\n    /**\r\n     * @member Num#$\r\n     * @type {Number}\r\n     * @public\r\n     * @description Original number.\r\n     */\n  }\n\n  /**\r\n   * @member Num#abs\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs\r\n   * @description Synonym for\r\n   * [Math.abs]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs}.\r\n   *\r\n   * @example\r\n   * new Num(1).abs;  // 1\r\n   * new Num(-1).abs; // 1\r\n   */\n\n\n  createClass(Num, [{\n    key: 'acos',\n\n\n    /**\r\n     * @method Num#acos\r\n     * @public\r\n     * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\r\n     * @returns {Number} Arccosine of the number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos\r\n     * @description Synonym for\r\n     * [Math.acos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos}.\r\n     */\n    value: function acos(toDegrees) {\n      return (toDegrees ? toDegree : 1) * Math.acos(this.$);\n    }\n\n    /**\r\n     * @member Num#acosh\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\r\n     * @description Synonym for\r\n     * [Math.acosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh}.\r\n     */\n\n  }, {\n    key: 'asin',\n\n\n    /**\r\n     * @method Num#asin\r\n     * @public\r\n     * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\r\n     * @returns {Number} Arcsine of the number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin\r\n     * @description Synonym for\r\n     * [Math.asin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin}.\r\n     */\n    value: function asin(toDegrees) {\n      return (toDegrees ? toDegree : 1) * Math.asin(this.$);\n    }\n\n    /**\r\n     * @method Num#atan\r\n     * @public\r\n     * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\r\n     * @returns {Number} Arcsine of the number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan\r\n     * @description Synonym for\r\n     * [Math.atan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan}.\r\n     */\n\n  }, {\n    key: 'atan',\n    value: function atan(toDegrees) {\n      return (toDegrees ? toDegree : 1) * Math.atan(this.$);\n    }\n\n    /**\r\n     * @member Num#atanh\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\r\n     * @description Synonym for\r\n     * [Math.atanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh}.\r\n     */\n\n  }, {\n    key: 'cos',\n\n\n    /**\r\n     * @method Num#cos\r\n     * @public\r\n     * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\r\n     * @returns {Number} Cosine of the number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos\r\n     * @description Synonym for\r\n     * [Math.cos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos}.\r\n     */\n    value: function cos(asDegrees) {\n      return Math.cos((asDegrees ? toRadian : 1) * this.$);\n    }\n\n    /**\r\n     * @member Num#cosh\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\r\n     * @description Synonym for\r\n     * [Math.cosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh}.\r\n     */\n\n  }, {\n    key: 'interval',\n\n\n    /**\r\n     * @method Num#interval\r\n     * @public\r\n     * @param {Function} func - Function that is called every <number> milliseconds.\r\n     * @param {Array} [args] - Arguments passed to the function.\r\n     * @returns {Function} Function that aborts the interval. The context of the function (if it's not already bound)\r\n     * is the object with the abort method.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/setInterval\r\n     * @description Analogue of the\r\n     * [setInterval]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setInterval}.\r\n     *\r\n     * @example\r\n     * const times = 0;\r\n     * new Num(50).interval(function () {\r\n     *   if (++times === 10) {\r\n     *     this.abort();\r\n     *   }\r\n     * });\r\n     */\n    value: function interval(func) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      validate$1([func], ['function'], 'Num#interval');\n\n      func = new Func(func).bindContext({ abort: abort });\n      args = toArray$1(args);\n\n      var number = this.$;\n\n      var aborted = void 0;\n      var timeout = setTimeout(function interval() {\n        if (!aborted) {\n          func.apply(null, args);\n\n          if (!aborted) {\n            timeout = setTimeout(interval, number);\n          }\n        }\n      }, 0);\n\n      return abort;\n\n      function abort() {\n        aborted = true;\n\n        return clearTimeout(timeout);\n      }\n    }\n\n    /**\r\n     * @member Num#ln\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log\r\n     * @description Synonym for\r\n     * [Math.log]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log}.\r\n     */\n\n  }, {\n    key: 'log',\n\n\n    /**\r\n     * @method Num#log\r\n     * @public\r\n     * @param {Number} number - Number to get logarithm of.\r\n     * @returns {Number} Logarithm of the argument number to the number base.\r\n     * @description Returns the logarithm of the argument number to the number base.\r\n     *\r\n     * @example\r\n     * new Num(2).log(16);  // 4\r\n     * new Num(3).log(243); // 5\r\n     */\n    value: function log(number) {\n      return Math.log(number) / Math.log(this.$);\n    }\n\n    /**\r\n     * @member Num#log2\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2\r\n     * @description Synonym for\r\n     * [Math.log2]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2}.\r\n     */\n\n  }, {\n    key: 'pow',\n\n\n    /**\r\n     * @method Num#pow\r\n     * @public\r\n     * @param {Number} power - Power the number should be raised to.\r\n     * @returns {Number} The number to the <power> power.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow\r\n     * @description Synonym for\r\n     * [Math.pow]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow}.\r\n     *\r\n     * @example\r\n     * new Num(4).pow(.5); // 2\r\n     * new Num(3).pow(2);  // 9\r\n     */\n    value: function pow(power) {\n      return Math.pow(this.$, power);\n    }\n\n    /**\r\n     * @method Num#root\r\n     * @public\r\n     * @param {Number} power - Power the number should be raised to.\r\n     * @returns {Number} The <power> root of the number.\r\n     * @description Synonym for number.pow(1 / power);\r\n     *\r\n     * @example\r\n     * new Num(4).root(2);   // 0.5\r\n     * new Num(243).root(5); // 3\r\n     */\n\n  }, {\n    key: 'root',\n    value: function root(power) {\n      return Math.pow(this.$, 1 / power);\n    }\n\n    /**\r\n     * @member Num#round\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round\r\n     * @description Synonym for\r\n     * [Math.round]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round}.\r\n     *\r\n     * @example\r\n     * new Num(1.1).floor;  // 1\r\n     * new Num(-1.1).floor; // -1\r\n     * new Num(1.5).floor;  // 2\r\n     */\n\n  }, {\n    key: 'sin',\n\n\n    /**\r\n     * @method Num#sin\r\n     * @public\r\n     * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\r\n     * @returns {Number} Sine of the number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin\r\n     * @description Synonym for\r\n     * [Math.sin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin}.\r\n     */\n    value: function sin(asDegrees) {\n      return Math.sin((asDegrees ? toRadian : 1) * this.$);\n    }\n\n    /**\r\n     * @member Num#sinh\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\r\n     * @description Synonym for\r\n     * [Math.sinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh}.\r\n     */\n\n  }, {\n    key: 'tan',\n\n\n    /**\r\n     * @method Num#tan\r\n     * @public\r\n     * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\r\n     * @returns {Number} Tangent of the number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan\r\n     * @description Synonym for\r\n     * [Math.tan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan}.\r\n     */\n    value: function tan(asDegrees) {\n      return Math.tan((asDegrees ? toRadian : 1) * this.$);\n    }\n\n    /**\r\n     * @member Num#tanh\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\r\n     * @description Synonym for\r\n     * [Math.tanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh}.\r\n     */\n\n  }, {\n    key: 'timeout',\n\n\n    /**\r\n     * @method Num#timeout\r\n     * @public\r\n     * @param {*} [value] - Value to be resolved by the promise.\r\n     * @returns {Promise} Promise that could be aborted.\r\n     * @see https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout\r\n     * @description Promise-based analogue of\r\n     * [setTimeout]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout}.\r\n     *\r\n     * @example\r\n     * new Num(50).timeout('resolved').then((value) => {\r\n     *   console.log(value); // 'resolved'\r\n     * });\r\n     *\r\n     * const promise = new Num(50).timeout();\r\n     * promise.abort();\r\n     */\n    value: function timeout(value) {\n      var _this2 = this;\n\n      var timeout = void 0;\n      var reject = void 0;\n\n      var promise = new Promise$1(function (resolve, rej) {\n        reject = rej;\n        timeout = setTimeout(resolve, _this2.$, value);\n      });\n\n      promise.abort = function abort() {\n        clearTimeout(timeout);\n\n        reject(new Error('Timeout was aborted'));\n\n        return this;\n      };\n\n      return promise;\n    }\n\n    /**\r\n     * @method Num#toBase\r\n     * @public\r\n     * @param {Number} [base = 10] - Base that the number should inverted to.\r\n     * @returns {String} A string representation of the number in <base> base.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\r\n     * @description Synonym for\r\n     * [Number#toString]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString}.\r\n     *\r\n     * @example\r\n     * new Num(4).toBase(2); // 100\r\n     * new Num(3).toBase();  // 3\r\n     */\n\n  }, {\n    key: 'toBase',\n    value: function toBase() {\n      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n\n      return this.$.toString(base);\n    }\n\n    /**\r\n     * @method Num#toExponential\r\n     * @public\r\n     * @param {Number} [fractionDigits] - See the link.\r\n     * @returns {String} A string representation of the number in the exponential format.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential\r\n     * @description Synonym for\r\n     * [Number#toExponential]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential}.\r\n     */\n\n  }, {\n    key: 'toExponential',\n    value: function toExponential(fractionDigits) {\n      return this.$.toExponential(fractionDigits);\n    }\n\n    /**\r\n     * @method Num#toFixed\r\n     * @public\r\n     * @param {Number} [digits = 0] - See the link.\r\n     * @returns {String} Fixed-point formatted number.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\r\n     * @description Synonym for\r\n     * [Number#toFixed]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed}.\r\n     */\n\n  }, {\n    key: 'toFixed',\n    value: function toFixed(digits) {\n      return this.$.toFixed(digits);\n    }\n\n    /**\r\n     * @method Num#toPrecision\r\n     * @public\r\n     * @param {Number} [precision] - See the link.\r\n     * @returns {String} A string representation of the number to the specified precision.\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision\r\n     * @description Synonym for\r\n     * [Number#toPrecision]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision}.\r\n     */\n\n  }, {\n    key: 'toPrecision',\n    value: function toPrecision(precision) {\n      return this.$.toPrecision(precision);\n    }\n  }, {\n    key: 'valueOf',\n    value: function valueOf() {\n      return Number(this.$);\n    }\n  }, {\n    key: 'abs',\n    get: function get() {\n      return Math.abs(this.$);\n    }\n  }, {\n    key: 'acosh',\n    get: function get() {\n      var number = this.$;\n\n      return Math.log(number + Math.sqrt(number * number - 1));\n    }\n\n    /**\r\n     * @member Num#asinh\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\r\n     * @description Synonym for\r\n     * [Math.asinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh}.\r\n     */\n\n  }, {\n    key: 'asinh',\n    get: function get() {\n      var number = this.$;\n\n      return Math.log(number + Math.sqrt(number * number + 1));\n    }\n  }, {\n    key: 'atanh',\n    get: function get() {\n      var number = this.$;\n\n      return Math.log((1 + number) / (1 - number)) / 2;\n    }\n\n    /**\r\n     * @member Num#cbrt\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt\r\n     * @description Synonym for\r\n     * [Math.cbrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt}.\r\n     */\n\n  }, {\n    key: 'cbrt',\n    get: function get() {\n      var cbrt = Math.pow(Math.abs(this.$), 1 / 3);\n\n      return this.$ > 0 ? cbrt : -cbrt;\n    }\n\n    /**\r\n     * @member Num#ceil\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil\r\n     * @description Synonym for\r\n     * [Math.ceil]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil}.\r\n     *\r\n     * @example\r\n     * new Num(1.1).ceil;  // 2\r\n     * new Num(-1.1).ceil; // -1\r\n     */\n\n  }, {\n    key: 'ceil',\n    get: function get() {\n      return Math.ceil(this.$);\n    }\n  }, {\n    key: 'cosh',\n    get: function get() {\n      var exp = this.exp;\n\n      return (exp + 1 / exp) / 2;\n    }\n\n    /**\r\n     * @member Num#cube\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description Cube of the number.\r\n     *\r\n     * @example\r\n     * new Num(2).cube;  // 8\r\n     * new Num(-3).ceil; // -27\r\n     */\n\n  }, {\n    key: 'cube',\n    get: function get() {\n      return this.$ * this.$ * this.$;\n    }\n\n    /**\r\n     * @member Num#exp\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp\r\n     * @description Synonym for\r\n     * [Math.exp]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp}.\r\n     */\n\n  }, {\n    key: 'exp',\n    get: function get() {\n      return Math.exp(this.$);\n    }\n\n    /**\r\n     * @member Num#floor\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor\r\n     * @description Synonym for\r\n     * [Math.floor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor}.\r\n     *\r\n     * @example\r\n     * new Num(1.1).floor;  // 1\r\n     * new Num(-1.1).floor; // -2\r\n     */\n\n  }, {\n    key: 'floor',\n    get: function get() {\n      return Math.floor(this.$);\n    }\n  }, {\n    key: 'ln',\n    get: function get() {\n      return Math.log(this.$);\n    }\n  }, {\n    key: 'log2',\n    get: function get() {\n      return this.ln / ln2;\n    }\n\n    /**\r\n     * @member Num#log10\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\r\n     * @description Synonym for\r\n     * [Math.log10]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10}.\r\n     */\n\n  }, {\n    key: 'log10',\n    get: function get() {\n      return this.ln / ln10;\n    }\n  }, {\n    key: 'round',\n    get: function get() {\n      return Math.round(this.$);\n    }\n\n    /**\r\n     * @member Num#sign\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n     * @description Synonym for\r\n     * [Math.sign]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign}.\r\n     */\n\n  }, {\n    key: 'sign',\n    get: function get() {\n      var number = this.$;\n\n      if (!number) {\n        return number;\n      }\n\n      return number > 0 ? 1 : -1;\n    }\n  }, {\n    key: 'sinh',\n    get: function get() {\n      var exp = this.exp;\n\n      return (exp - 1 / exp) / 2;\n    }\n\n    /**\r\n     * @member Num#sq\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @description The square of the number.\r\n     *\r\n     * @example\r\n     * new Num(2).sq;  // 4\r\n     * new Num(-3).sq; // 9\r\n     */\n\n  }, {\n    key: 'sq',\n    get: function get() {\n      return this.$ * this.$;\n    }\n\n    /**\r\n     * @member Num#sqrt\r\n     * @type {Number}\r\n     * @public\r\n     * @readonly\r\n     * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt\r\n     * @description Synonym for\r\n     * [Math.sqrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt}.\r\n     */\n\n  }, {\n    key: 'sqrt',\n    get: function get() {\n      return Math.sqrt(this.$);\n    }\n  }, {\n    key: 'tanh',\n    get: function get() {\n      var number = this.$;\n\n      if (!isFinite(number)) {\n        return this.sign;\n      }\n\n      var exp = Math.exp(2 * number);\n\n      return (exp - 1) / (exp + 1);\n    }\n  }]);\n  return Num;\n}(Super);\n\ndefineProperties(Num.prototype, defineProperty({}, _Symbol.toStringTag, 'Num'));\n\nconstructors[1].push({\n  check: isNumber,\n  cls: Num\n});\n\n/**\r\n * @function rand\r\n * @public\r\n * @param {Number} [start = 0] - Start of the range.\r\n * @param {Number} [end = 1] - End of the range.\r\n * @returns {Number} Random number.\r\n * @description Returns a random number in the range specified by the arguments.\r\n *\r\n * @example\r\n * rand(1, 5); // 2.315\r\n * rand(1, 5); // 4.356763\r\n */\nfunction rand() {\n  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  return start + (end - start) * Math.random();\n}\n\n/**\r\n * @function random\r\n * @public\r\n * @param {Integer} start - Start of the range.\r\n * @param {Integer} end - End of the range.\r\n * @returns {Number} Random integer.\r\n * @description Returns a random integer number in the range specified by the arguments.\r\n *\r\n * @example\r\n * random(1, 5); // 3\r\n * random(1, 5); // 1\r\n */\nfunction random(start, end) {\n  validate$1([start, end], ['intLike', 'intLike'], 'random');\n\n  if (end <= start) {\n    throw new Error('The second argument must be greater than the first!', 'random');\n  }\n\n  return Math.floor(rand(start, end + 1));\n}\n\n/**\r\n * @module constants/formats\r\n * @private\r\n * @description Exports different types of formatting for {@link Date#format}.\r\n */\n\nvar zero = new Str('0');\nvar daysOfTheWeekNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nvar daysOfTheWeekAliases = new Super(daysOfTheWeekNames).map(function (value) {\n  return value.slice(0, 3);\n}).$;\nvar monthsNames = ['January', 'February', 'March', 'April', 'May', 'June', 'Jule', 'August', 'September', 'October', 'November', 'December'];\nvar monthsAliases = new Super(monthsNames).map(function (value) {\n  return value.slice(0, 3);\n}).$;\n\n/**\r\n * @callback module:constants/formats~matchCallback\r\n * @param {Dat} date - D-wrap of a date to apply format to.\r\n * @param {String} string - Matched applied expression.\r\n */\n\n/**\r\n * @typedef {Object} module:constants/formats~formatExpr\r\n * @property {String} format - Matched format.\r\n * @property {module:constants/formats~matchCallback} match - Callback if there was a match.\r\n */\n\n/**\r\n * @type {module:constants/formats~formatExpr[]}\r\n * @description Array of different formats.\r\n */\nvar formats = [{\n  format: 'ccc',\n  match: function match(date, utc) {\n    return round(date[utc]('c'), 3);\n  }\n}, {\n  format: 'c',\n  match: function match(date, utc) {\n    return date[utc]('c');\n  }\n}, {\n  format: 'ss',\n  match: function match(date, utc) {\n    return round(date[utc]('s'), 2);\n  }\n}, {\n  format: 's',\n  match: function match(date, utc) {\n    return date[utc]('s');\n  }\n}, {\n  format: 'mm',\n  match: function match(date, utc) {\n    return round(date[utc]('m'), 2);\n  }\n}, {\n  format: 'm',\n  match: function match(date, utc) {\n    return date[utc]('m');\n  }\n}, {\n  format: 'hh',\n  match: function match(date, utc) {\n    return round(date[utc]('h'), 2);\n  }\n}, {\n  format: 'h',\n  match: function match(date, utc) {\n    return date[utc]('h');\n  }\n}, {\n  format: 'dddd',\n  match: function match(date, utc) {\n    return daysOfTheWeekNames[date[utc]('dw')];\n  }\n}, {\n  format: 'ddd',\n  match: function match(date, utc) {\n    return daysOfTheWeekAliases[date[utc]('dw')];\n  }\n}, {\n  format: 'dd',\n  match: function match(date, utc) {\n    return round(date[utc]('d'), 2);\n  }\n}, {\n  format: 'd',\n  match: function match(date, utc) {\n    return date[utc]('d');\n  }\n}, {\n  format: 'MMMM',\n  match: function match(date, utc) {\n    return monthsNames[date[utc]('M') - 1];\n  }\n}, {\n  format: 'MMM',\n  match: function match(date, utc) {\n    return monthsAliases[date[utc]('M') - 1];\n  }\n}, {\n  format: 'MM',\n  match: function match(date, utc) {\n    return round(date[utc]('M'), 2);\n  }\n}, {\n  format: 'M',\n  match: function match(date, utc) {\n    return date[utc]('M');\n  }\n}, {\n  format: 'yyyy',\n  match: function match(date, utc) {\n    return round(date[utc]('y'), 4);\n  }\n}, {\n  format: 'yy',\n  match: function match(date, utc) {\n    return String(date[utc]('y')).slice(-2);\n  }\n}, {\n  format: 'y',\n  match: function match(date, utc) {\n    return date[utc]('y');\n  }\n}];\n\n/**\r\n * @function round\r\n * @private\r\n * @param {Number} number - Number to round.\r\n * @param {Number} digits - Number of the digits of the output.\r\n * @returns {String} String with necessary additional starting zeroes.\r\n */\nfunction round(number, digits) {\n  var string = String(number);\n  var zeroes = digits - string.length;\n\n  zeroes = zeroes < 0 ? 0 : zeroes;\n\n  return zero.repeat(zeroes).$ + string;\n}\n\n/**\r\n * @module Dat\r\n * @private\r\n * @mixin\r\n * @description Exports Dat class.\r\n */\n\n/**\r\n * @typedef {*} DateLike\r\n * @public\r\n */\n\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} AddPeriod\r\n * @public\r\n */\n\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'dw'|'M'|'y'} GetPeriod\r\n * @public\r\n */\n\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} OfOnePeriod\r\n * @public\r\n */\n\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} SetPeriod\r\n * @public\r\n */\n\n/**\r\n * @typedef {'ccc'|'c'|'ss'|'s'|'mm'|'m'|'hh'|'h'|'dddd'|'ddd'|'dd'|'d'|'MMMM'|'MMM'|'MM'|'M'|'yyyy'|'yy'|'y'} Format\r\n * @public\r\n */\n\nvar coeffs = {\n  c: 1,\n  s: 1000,\n  m: 60000,\n  h: 3600000,\n  d: 86400000,\n  w: 604800000,\n  M: 2592000000,\n  y: 31536000000\n};\n\nvar getSwitcher = switcher({\n  c: function c(date, utc) {\n    return date[utc + 'Milliseconds']();\n  },\n  s: function s(date, utc) {\n    return date[utc + 'Seconds']();\n  },\n  m: function m(date, utc) {\n    return date[utc + 'Minutes']();\n  },\n  h: function h(date, utc) {\n    return date[utc + 'Hours']();\n  },\n  d: function d(date, utc) {\n    return date[utc + 'Date']();\n  },\n  dw: function dw(date, utc) {\n    return date[utc + 'Day']();\n  },\n  M: function M(date, utc) {\n    return date[utc + 'Month']() + 1;\n  },\n  y: function y(date, utc) {\n    return date[utc + 'FullYear']();\n  }\n}, 'equals', NaN);\nvar setSwitcher = switcher({\n  c: function c(date, value, utc) {\n    return date[utc + 'Milliseconds'](value);\n  },\n  s: function s(date, value, utc) {\n    return date[utc + 'Seconds'](value);\n  },\n  m: function m(date, value, utc) {\n    return date[utc + 'Minutes'](value);\n  },\n  h: function h(date, value, utc) {\n    return date[utc + 'Hours'](value);\n  },\n  d: function d(date, value, utc) {\n    return date[utc + 'Date'](value);\n  },\n  M: function M(date, value, utc) {\n    return date[utc + 'Month'](value - 1);\n  },\n  y: function y(date, value, utc) {\n    return date[utc + 'FullYear'](value);\n  }\n});\n\n/**\r\n * @class Dat\r\n * @extends Super\r\n * @public\r\n * @param {Date} [date = new Date()] - A date to wrap.\r\n * @returns {Dat} Instance of Dat.\r\n * @description Wrap of a date.\r\n *\r\n * @example\r\n * const date = new Dat(new Date());\r\n */\n\nvar Dat = function (_Super) {\n  inherits(Dat, _Super);\n\n  function Dat() {\n    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n    classCallCheck(this, Dat);\n    return possibleConstructorReturn(this, (Dat.__proto__ || Object.getPrototypeOf(Dat)).call(this, date));\n\n    /**\r\n     * @member Dat#$\r\n     * @type {Date}\r\n     * @public\r\n     * @description Original date.\r\n     */\n  }\n\n  /**\r\n   * @method Dat#add\r\n   * @public\r\n   * @param {AddPeriod|Object.<AddPeriod, Number>} what - What to add.\r\n   * @param {Number} [number] - Number of what to add if the first argument is a period string.\r\n   * @returns {Dat} Returns this.\r\n   * @description Method for adding amounts of time to the date. Returns new instance of Dat.\r\n   *\r\n   * @example\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add('c', 2).toISOString();         // '2000-01-01T00:00:00.001Z'\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add({ c: 2, d: 5 }).toISOString(); // '2000-01-06T00:00:00.001Z'\r\n   */\n\n\n  createClass(Dat, [{\n    key: 'add',\n    value: function add(what, number) {\n      if (arguments.length >= 2) {\n        what = defineProperty({}, what, number);\n      }\n\n      return this.time(this.time() + new Super(what).sum(function (value, what) {\n        return coeffs[what] * value;\n      }));\n    }\n\n    /**\r\n     * @method Dat#expires\r\n     * @public\r\n     * @param {*} [value = this] - Value to resolve after the date expires.\r\n     * @returns {Promise} New instance of Promise.\r\n     * @description Method for defining when the date expires.\r\n     *\r\n     * @example\r\n     * new Dat().add('c', 500).expires('Expired').then((value) => {\r\n     *   // After 500 milliseconds\r\n     *   console.log(value); // 'Expired'\r\n     * });\r\n     */\n\n  }, {\n    key: 'expires',\n    value: function expires(value) {\n      if (!arguments.length) {\n        value = this;\n      }\n\n      return new Num(this.$ - now()).timeout(value);\n    }\n\n    /**\r\n     * @method Dat#format\r\n     * @public\r\n     * @param {String} string - Template for the output.\r\n     * @param {String} [prefix = ''] - If needed [all special strings]{@link Format}\r\n     * are treated as they should be prefix with prefix.\r\n     * @returns {String} Formatted string.\r\n     * @description Method for creating formatted output based on a string.\r\n     *\r\n     * @example\r\n     * new Dat('1999-12-31T23:59:59.999Z').format('Seconds: $ss, milliseconds: $ccc.', '$');\r\n     * // 'Seconds: 59, milliseconds: 999.'\r\n     */\n\n  }, {\n    key: 'format',\n    value: function format(string) {\n      var _this2 = this;\n\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      string = new Str(new Super(string).$);\n      prefix = String(new Super(prefix).$);\n\n      iterate(formats, function (format) {\n        string = string.replaceString(prefix + format.format, format.match(_this2, 'get'));\n      });\n\n      return string.$;\n    }\n\n    /**\r\n     * @method Dat#formatUTC\r\n     * @public\r\n     * @param {String} string - See {@link Dat#format}.\r\n     * @param {String} [prefix = ''] - See {@link Dat#format}.\r\n     * @returns {String} Formatted string.\r\n     * @description UTC version of {@link Dat#format}.\r\n     *\r\n     * @example\r\n     * new Dat('1999-07-07T03:09:09.099Z').formatUTC(\r\n     *   `\r\n     *     Milliseconds: $ccc|$c.\r\n     *     Seconds:      $ss|$s.\r\n     *     Minutes:      $mm|$m.\r\n     *     Hours:        $hh|$h.\r\n     *     Day:          $dddd|$ddd|$dd|$d.\r\n     *     Month:        $MMMM|$MMM|$MM|$M.\r\n     *     Year:         $yyyy|$yy|$y.\r\n     *   `,\r\n     *   '$'\r\n     * );\r\n     * // Milliseconds: 099|99.\r\n     * // Seconds:      09|9.\r\n     * // Minutes:      09|9.\r\n     * // Hours:        03|3.\r\n     * // Day:          Friday|Fri|07|7.\r\n     * // Month:        July|Jul|07|7.\r\n     * // Year:         1999|99|1999.\r\n     */\n\n  }, {\n    key: 'formatUTC',\n    value: function formatUTC(string) {\n      var _this3 = this;\n\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      string = new Str(new Super(string).$);\n      prefix = String(new Super(prefix).$);\n\n      iterate(formats, function (format) {\n        string = string.replaceString(prefix + format.format, format.match(_this3, 'getUTC'));\n      });\n\n      return string.$;\n    }\n\n    /**\r\n     * @method Dat#get\r\n     * @public\r\n     * @param {GetPeriod} what - What to get.\r\n     * @returns {Number} Number of what to get.\r\n     * @description Method for getting values such as seconds or minutes.\r\n     *\r\n     * @example\r\n     * new Dat(new Date('1999-12-31T23:59:59.999Z')).get('s'); // 59\r\n     */\n\n  }, {\n    key: 'get',\n    value: function get(what) {\n      return getSwitcher(what, [this.$, 'get']);\n    }\n\n    /**\r\n     * @method Dat#getUTC\r\n     * @public\r\n     * @param {GetPeriod} what - See {@link Dat#get}.\r\n     * @returns {Number} Number of what to get.\r\n     * @description UTC version of {@link Dat#get}.\r\n     *\r\n     * @example\r\n     * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));\r\n     *\r\n     * date.getUTC('c');  // 999\r\n     * date.getUTC('s');  // 59\r\n     * date.getUTC('m');  // 59\r\n     * date.getUTC('h');  // 23\r\n     * date.getUTC('d');  // 31\r\n     * date.getUTC('dw'); // 5\r\n     * date.getUTC('M');  // 12\r\n     * date.getUTC('y');  // 1999\r\n     */\n\n  }, {\n    key: 'getUTC',\n    value: function getUTC(what) {\n      return getSwitcher(what, [this.$, 'getUTC']);\n    }\n\n    /**\r\n     * @method Dat#isAfter\r\n     * @public\r\n     * @param {DateLike} date - Date to be compared to this date.\r\n     * @returns {Boolean} If this date is after the argument one.\r\n     * @description Finds out if this date is after the argument one.\r\n     *\r\n     * @example\r\n     * new Dat(new Date(333)).isAfter(new Date(334)); // false\r\n     * new Dat(new Date(333)).isAfter(new Date(332)); // true\r\n     */\n\n  }, {\n    key: 'isAfter',\n    value: function isAfter(date) {\n      date = new Date(new Super(date).$);\n\n      return date.getTime() < this.$.getTime();\n    }\n\n    /**\r\n     * @method Dat#isBefore\r\n     * @public\r\n     * @param {DateLike} date - Date to be compared to this date.\r\n     * @returns {Boolean} If this date is before the argument one.\r\n     * @description Finds out if this date is before the argument one.\r\n     *\r\n     * @example\r\n     * new Dat(new Date(333)).isBefore(new Date(334)); // true\r\n     * new Dat(new Date(333)).isBefore(new Date(332)); // false\r\n     */\n\n  }, {\n    key: 'isBefore',\n    value: function isBefore(date) {\n      date = new Date(new Super(date).$);\n\n      return date.getTime() > this.$.getTime();\n    }\n\n    /**\r\n     * @method Dat#isBetween\r\n     * @public\r\n     * @param {DateLike} date1 - Start of the range.\r\n     * @param {DateLike} date2 - End of the range.\r\n     * @returns {Boolean} If this date is after date1 and before date2.\r\n     * @description Finds out if this date is after date1 and before date2.\r\n     *\r\n     * @example\r\n     * new Dat(new Date(333)).isBetween(new Date(332), new Date(334)); // true\r\n     * new Dat(new Date(333)).isBetween(new Date(334), new Date(332)); // false\r\n     */\n\n  }, {\n    key: 'isBetween',\n    value: function isBetween(date1, date2) {\n      var time = this.$.getTime();\n\n      date1 = new Date(new Super(date1).$);\n      date2 = new Date(new Super(date2).$);\n\n      return time > date1.getTime() && time < date2.getTime();\n    }\n\n    /**\r\n     * @method Dat#isInvalid\r\n     * @public\r\n     * @returns {Boolean} If the date is invalid.\r\n     * @description Returns if the date is invalid.\r\n     *\r\n     * @example\r\n     * new Dat(new Date('a')).isInvalid(); // true\r\n     * new Dat(new Date(1)).isInvalid();   // false\r\n     */\n\n  }, {\n    key: 'isInvalid',\n    value: function isInvalid() {\n      return this.$.toString() === 'Invalid Date';\n    }\n\n    /**\r\n     * @method Dat#isPassed\r\n     * @public\r\n     * @returns {Boolean} If the date is passed.\r\n     * @description Returns if the date is passed.\r\n     *\r\n     * @example\r\n     * new Dat(new Date(1)).isPassed(); // true\r\n     */\n\n  }, {\n    key: 'isPassed',\n    value: function isPassed() {\n      return this.isBefore(now());\n    }\n\n    /**\r\n     * @method Dat#ofOne\r\n     * @public\r\n     * @param {OfOnePeriod} what - Period to check.\r\n     * @param {DateLike} date - Date to check.\r\n     * @returns {Boolean} If two dates are of one second, minute or something else.\r\n     * @description Returns if two dates are of one second, minute or something else.\r\n     *\r\n     * @example\r\n     * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:59.333Z')); // true\r\n     * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:58.999Z')); // false\r\n     */\n\n  }, {\n    key: 'ofOne',\n    value: function ofOne(what, date) {\n      var _this4 = this;\n\n      if (!(what in coeffs) || what === 'w') {\n        return false;\n      }\n\n      date = new Dat(new Date(date));\n\n      var started = void 0;\n\n      return iterate(coeffs, function (coeff, w) {\n        if (w === what) {\n          started = true;\n        }\n\n        if (!started || w === 'w') {\n          return;\n        }\n\n        if (started && _this4.get(w) !== date.get(w)) {\n          return false;\n        }\n      }) !== false;\n    }\n\n    /**\r\n     * @method Dat#set\r\n     * @public\r\n     * @param {SetPeriod|Object.<SetPeriod, Number>} what - What to add.\r\n     * @param {Number} [number] - Number of what to set if the first argument is a period string.\r\n     * @returns {Dat} Returns this.\r\n     * @description Method for setting values such as seconds or minutes.\r\n     *\r\n     * @example\r\n     * new Dat(new Date('1999-12-31T23:59:59.999Z')).set('s', 58).get('s');           // 58\r\n     * new Dat(new Date('1999-12-31T23:59:59.999Z')).set({ c: 998, s: 58 }).get('c'); // 998\r\n     */\n\n  }, {\n    key: 'set',\n    value: function set(what, number) {\n      var date = this.$;\n\n      if (arguments.length >= 2) {\n        what = defineProperty({}, what, number);\n      }\n\n      what = new Super(what).$;\n\n      iterate(what, function (value, what) {\n        setSwitcher(what, [date, value, 'set']);\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Dat#setUTC\r\n     * @public\r\n     * @param {SetPeriod|Object.<SetPeriod, Number>} what - See {@link Dat#set}.\r\n     * @param {Number} [number] - See {@link Dat#set}.\r\n     * @returns {Dat} Returns this.\r\n     * @description UTC version of {@link Dat#set}.\r\n     *\r\n     * @example\r\n     * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));\r\n     *\r\n     * date.setUTC('ccc', 998).getUTC('ccc'); // 998\r\n     * date.setUTC({\r\n     *   s: 58,\r\n     *   m: 58,\r\n     *   h: 22\r\n     * });\r\n     *\r\n     * date.getUTC('s'); // 58\r\n     * date.getUTC('m'); // 58\r\n     * date.getUTC('h'); // 23\r\n     */\n\n  }, {\n    key: 'setUTC',\n    value: function setUTC(what, number) {\n      var date = this.$;\n\n      if (arguments.length >= 2) {\n        what = defineProperty({}, what, number);\n      }\n\n      what = new Super(what).$;\n\n      iterate(what, function (value, what) {\n        setSwitcher(what, [date, value, 'setUTC']);\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Dat#setUTC\r\n     * @public\r\n     * @param {Number} [time] - Time to set.\r\n     * @returns {Dat|Number} - If the time argument is present this is returned otherwise the time is returned.\r\n     * @description Synonym for both\r\n     * [Date#getTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime} and\r\n     * [Date#setTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime}.\r\n     */\n\n  }, {\n    key: 'time',\n    value: function time(_time) {\n      var date = this.$;\n\n      if (arguments.length) {\n        date.setTime(_time);\n      }\n\n      return date.getTime();\n    }\n  }, {\n    key: 'toISOString',\n    value: function toISOString() {\n      return this.$.toISOString();\n    }\n  }, {\n    key: 'toLocaleString',\n    value: function toLocaleString() {\n      return this.$.toLocaleString();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.$.toString();\n    }\n  }, {\n    key: 'valueOf',\n    value: function valueOf() {\n      return this.$.valueOf();\n    }\n  }]);\n  return Dat;\n}(Super);\n\ndefineProperties(Dat.prototype, defineProperty({}, _Symbol.toStringTag, 'Dat'));\n\nconstructors[1].push({\n  check: isDate,\n  cls: Dat\n});\n\n/**\r\n * @function now\r\n * @public\r\n * @returns {Number} Number of milliseconds.\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now\r\n * @description Synonym for\r\n * [Date.now]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now}.\r\n */\nfunction now() {\n  return Date.now();\n}\n\n/**\r\n * @function date\r\n * @public\r\n * @param {DateLike} [date = new Date()] - Date-like value that is passed to the Date constructor.\r\n * @returns {Dat} New instance of Dat.\r\n * @description Synonym for new Dat(new Date(date));\r\n */\nfunction date(date) {\n  if (!arguments.length) {\n    return new Dat(new Date(now()));\n  }\n\n  date = new Super(date).$;\n\n  return new Dat(new Date(date));\n}\n\n/**\r\n * @module helpers/constructURL\r\n * @private\r\n * @description Exports constructURL method.\r\n */\n\n/**\r\n * @type {RegExp}\r\n * @description Absolute URL pattern.\r\n */\nvar absoluteURLRegexp = /^(([a-z][a-z\\d+\\-.]*:)?\\/\\/|data:[a-z]+\\/[a-z]+;base64,)/i;\nvar querySwitcher = switcher('call', function () {\n  return new Arr([]);\n}).case(isArray, function (prefix, query) {\n  var queryParams = new Arr([]);\n\n  iterate(query, function (value) {\n    if (isPlainObject(value) || isArray(value)) {\n      queryParams = queryParams.concat(querySwitcher(value, [prefix + '[]']));\n\n      return;\n    }\n\n    queryParams.push({\n      param: prefix + '[]',\n      value: value\n    });\n  });\n\n  return queryParams.$;\n}).case(isPlainObject, function (prefix, query) {\n  var queryParams = new Arr([]);\n\n  iterate(query, function (value, param) {\n    if (isPlainObject(value) || isArray(value)) {\n      queryParams = queryParams.concat(querySwitcher(value, [prefix ? prefix + '[' + param + ']' : param]));\n\n      return;\n    }\n\n    queryParams.push({\n      param: prefix ? prefix + '[' + param + ']' : param,\n      value: isObject(value) ? JSON.stringify(value) : String(value)\n    });\n  });\n\n  return queryParams.$;\n});\n\n/**\r\n * @function constructURL\r\n * @param {String} baseURL - BaseURL of the output URL.\r\n * @param {String} url - Main part of the output URL.\r\n * @param {Object} params - Params to replace in the url expressions like \":param\".\r\n * @param {Object} query - Object with query params.\r\n * @param {Object} [hash = ''] - URL hash.\r\n * @param {Object} [encodeOptions = {}] - If you need to encode something.\r\n * @param {Object} [encodeOptions.params = true] - If you need to encode params.\r\n * @param {Object} [encodeOptions.query = true] - If you need to encode query params.\r\n * @returns {String} Constructed URL.\r\n * @description Function for constructing URL from the base URL, URL, params and query params.\r\n */\nvar constructURL = (function (baseURL, url, params, query) {\n  var hash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  var encodeOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var _encodeOptions$params = encodeOptions.params,\n      encodeParams = _encodeOptions$params === undefined ? true : _encodeOptions$params,\n      _encodeOptions$query = encodeOptions.query,\n      encodeQuery = _encodeOptions$query === undefined ? true : _encodeOptions$query;\n\n  var URL = isAbsolute(url) ? url : String(baseURL).replace(/\\/+$/, '') + '/' + String(url).replace(/^\\/+/, '');\n\n  iterate(params, function (value, param) {\n    URL = new Str(URL).replaceString(':' + param, encode(value, encodeParams)).$;\n  });\n\n  var queryParams = querySwitcher(query, ['']);\n\n  if (queryParams.length) {\n    URL += (URL.indexOf('?') === -1 ? '?' : '&') + queryParams.map(function (_ref) {\n      var param = _ref.param,\n          value = _ref.value;\n      return encode(param, encodeQuery) + '=' + encode(value, encodeQuery);\n    }).join('&');\n  }\n\n  return '' + URL + (hash ? '#' + hash : '');\n});\n\n/**\r\n * @function isAbsolute\r\n * @param {String} url - URL to check if it is absolute or not.\r\n * @returns {Boolean} If the argument URL is absolute or not.\r\n */\nfunction isAbsolute(url) {\n  return absoluteURLRegexp.test(url);\n}\n\n/**\r\n * @function encode\r\n * @param {String} string - String to encode using encodeURIComponent.\r\n * @param {Boolean} isEncoded - If the string should be encoded.\r\n * @returns {String} Encoded string.\r\n */\nfunction encode(string, isEncoded) {\n  return isEncoded ? encodeURIComponent(string) : string;\n}\n\n/**\r\n * @module helpers/parseHeaders\r\n * @private\r\n * @description Exports parseHeaders method.\r\n */\n\n/**\r\n * @function parseHeaders\r\n * @param {String} rawHeaders - Raw headers.\r\n * @returns {Object} Headers object\r\n * @description Function for parsing raw headers.\r\n */\nvar parseHeaders = (function (rawHeaders) {\n  var headers = {};\n\n  iterate((rawHeaders || '').split('\\n'), function (value) {\n    var index = value.indexOf(':');\n    var key = new Str(value.substring(0, index)).trim().toCamelCase().$;\n    var val = new Str(value.substring(index + 1)).trim().$;\n\n    if (key) {\n      headers[key] = (headers[key] ? headers[key] + ', ' : '') + val;\n    }\n  });\n\n  return headers;\n});\n\n/**\r\n * @module helpers/transformData\r\n * @private\r\n * @description Exports transformData method.\r\n */\n\nvar notToTransform = new Arr(['FormData', 'File', 'Blob', 'ArrayBuffer', 'String', 'Number']);\nvar withoutBody = new Arr(['DELETE', 'GET', 'HEAD']);\n\n/**\r\n * @function transformData\r\n * @param {*} data - Data to transform\r\n * @param {String} method - HTTP method.\r\n * @param {Object} headers - Object with headers.\r\n * @returns {*} - Transformed data.\r\n */\nvar transformData = (function (data, method, headers) {\n  data = new Super(data).$;\n\n  if (withoutBody.indexOfStrict(method) !== -1) {\n    return null;\n  }\n\n  if (isObject(data) && notToTransform.indexOfStrict(toStringTag(data)) === -1) {\n    if (!headers.contentType) {\n      headers.contentType = ['application/json;charset=utf-8'];\n    }\n\n    return new Super(data).json();\n  }\n\n  return data;\n});\n\n/**\r\n * @module Fetch\r\n * @private\r\n * @mixin\r\n * @description Exports Fetch class.\r\n */\n\n/**\r\n * @typedef {'get'|'post'|'delete'|'head'|'put'|'patch'} FetchMethod\r\n * @public\r\n */\n\n/**\r\n * @typedef {Object} FetchConfig\r\n * @public\r\n * @property {Array.<AfterMiddleware|FetchErrorAfterMiddleware>} [after]\r\n * @property {Object} [auth]\r\n * @property {String} [auth.username]\r\n * @property {String} [auth.password]\r\n * @property {String} [baseURL]\r\n * @property {Array.<BeforeMiddleware|FetchErrorBeforeMiddleware>} [before]\r\n * @property {*} [data]\r\n * @property {Object.<String, String[]>} [headers]\r\n * @property {FetchMethod} [method]\r\n * @property {Object} [params]\r\n * @property {Object} [query]\r\n * @property {String} [responseType]\r\n * @property {Number} [timeout]\r\n * @property {String} [url]\r\n * @property {Boolean} [withCredentials]\r\n */\n\n/**\r\n * @typedef {Object} FetchResponse\r\n * @public\r\n * @property {FetchConfig} config\r\n * @property {*} data\r\n * @property {Object.<String, String>} headers\r\n * @property {Number} status\r\n * @property {String} statusText\r\n * @property {XMLHttpRequest} xhr\r\n */\n\n/**\r\n * @callback FetchAfterMiddleware\r\n * @public\r\n * @param {FetchResponse} config - Fetch response.\r\n */\n\n/**\r\n * @callback FetchErrorAfterMiddleware\r\n * @public\r\n * @param {Error|*} err - Thrown error.\r\n * @param {FetchResponse} config - Fetch response.\r\n */\n\n/**\r\n * @callback FetchBeforeMiddleware\r\n * @public\r\n * @param {FetchConfig} config - Fetch config.\r\n */\n\n/**\r\n * @callback FetchErrorBeforeMiddleware\r\n * @public\r\n * @param {Error|*} err - Thrown error.\r\n * @param {FetchConfig} config - Fetch config.\r\n */\n\n/**\r\n * @callback FetchConfigFunction\r\n * @public\r\n * @param {FetchConfig} config\r\n */\n\nvar defaults$1 = {\n  after: [],\n  auth: {\n    username: '',\n    password: ''\n  },\n  baseURL: global$1.location.origin,\n  before: [],\n  data: null,\n  headers: {},\n  method: 'get',\n  params: {},\n  query: {},\n  responseType: '',\n  timeout: 0,\n  url: '',\n  withCredentials: false\n};\nvar uploadMethods = new Arr(['post', 'put']);\n\n/**\r\n * @class Fetch\r\n * @extends Function\r\n * @public\r\n * @param {FetchConfig} [config = {}] - A number to wrap.\r\n * @returns {Fetch} Instance of Fetch.\r\n * An instance of Fetch is a function that simply calls #request with the same arguments.\r\n * @description Class for fetching data.\r\n *\r\n * @example\r\n * const fetch = new Fetch();\r\n *\r\n * fetch('/data').then((res) => {\r\n *   console.log(res);\r\n * });\r\n */\n\nvar Fetch = function (_Function) {\n  inherits(Fetch, _Function);\n\n  function Fetch() {\n    var _ret;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, Fetch);\n\n    var _this = possibleConstructorReturn(this, (Fetch.__proto__ || Object.getPrototypeOf(Fetch)).call(this));\n\n    function fetch() {\n      return fetch.request.apply(fetch, arguments);\n    }\n\n    var conf = new Super({}).deepAssign(defaults$1, config).$;\n\n    if (conf.before.indexOf(fetchBeforeMiddleware) === -1) {\n      conf.before.push(fetchBeforeMiddleware);\n    }\n\n    /**\r\n     * @member {FetchConfig} Fetch#$$\r\n     * @type {FetchConfig}\r\n     * @public\r\n     * @description Fetch config.\r\n     */\n    Object.defineProperty(fetch, '$$', { value: conf });\n    Object.setPrototypeOf(fetch, Fetch.prototype);\n\n    return _ret = fetch, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\r\n   * @method Fetch#after\r\n   * @public\r\n   * @param {FetchAfterMiddleware|FetchErrorAfterMiddleware} middleware - Middleware to add.\r\n   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put the middleware.\r\n   * Truthy parameter stands for \"to the end\" and falsey for \"to the beginning\".\r\n   * @returns {Fetch} Returns this.\r\n   * @description Middleware that is called after the request.\r\n   * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.\r\n   * If the middleware returns a promise it becomes a part of the middleware chain.\r\n   *\r\n   * @example\r\n   * const fetch = new Fetch()\r\n   *   .after((err, res) => {\r\n   *     console.log(err);\r\n   *\r\n   *     throw err;\r\n   *   })\r\n   *   .after((res) => {\r\n   *     res.json = D(res.data).parseJSON():\r\n   *   });\r\n   */\n\n\n  createClass(Fetch, [{\n    key: 'after',\n    value: function after(middleware) {\n      var afterAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      validate$1([middleware], ['function'], 'Fetch#after');\n\n      var after = this.$$.after;\n\n\n      if (afterAll) {\n        after.push(middleware);\n      } else {\n        after.unshift(middleware);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Fetch#before\r\n     * @public\r\n     * @param {FetchBeforeMiddleware|FetchErrorBeforeMiddleware} middleware - Middleware to add.\r\n     * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put the middleware.\r\n     * Truthy parameter stands for \"to the beginning\" and falsey for \"to the end\".\r\n     * @returns {Fetch} Returns this.\r\n     * @description Middleware that is called before the request.\r\n     * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.\r\n     * If the middleware returns a promise it becomes a part of the middleware chain.\r\n     *\r\n     * @example\r\n     * const fetch = new Fetch()\r\n     *   .before((err, req) => {\r\n     *     console.log(err);\r\n     *\r\n     *     throw err;\r\n     *   })\r\n     *   .before((req) => {\r\n     *     if (req.url === '/veryLongRequest') {\r\n     *       req.timeout = 30000;\r\n     *     }\r\n     *   });\r\n     */\n\n  }, {\n    key: 'before',\n    value: function before(middleware) {\n      var beforeAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      validate$1([middleware], ['function'], 'Fetch#before');\n\n      var before = this.$$.before;\n\n\n      if (beforeAll) {\n        before.unshift(middleware);\n      } else {\n        before.push(middleware);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Fetch#config\r\n     * @public\r\n     * @param {String|FetchConfig|FetchConfigFunction} [property] - If it's a function\r\n     * it's called with the fetch config argument, if it's a string the value argument\r\n     * is used for assigning this property to the fetch config\r\n     * otherwise it's assigned to the fetch config.\r\n     * @param {*} [value] - See the property argument.\r\n     * @returns {Fetch|FetchConfig} If the argument is present this is returned otherwise the fetch config is returned.\r\n     * @description Method for getting and setting config.\r\n     *\r\n     * @example\r\n     * const fetch = new Fetch();\r\n     *\r\n     * fetch.config({ baseURL: 5000 });\r\n     * fetch.config().timeout; // 5000\r\n     *\r\n     * fetch.config((config) => {\r\n     *   config.baseURL += '/api';\r\n     * });\r\n     */\n\n  }, {\n    key: 'config',\n    value: function config(property, value) {\n      var conf = this.$$;\n\n      if (!arguments.length) {\n        return conf;\n      }\n\n      if (isFunction(property)) {\n        property(conf);\n      } else {\n        if (arguments.length >= 2) {\n          property = defineProperty({}, property, value);\n        }\n\n        new Super(conf).deepAssign(property);\n      }\n\n      return this;\n    }\n\n    /**\r\n     * @method Fetch#delete\r\n     * @public\r\n     * @param {String} [url] - See {@link Fetch#request}.\r\n     * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n     * @description Shorthand for #request for delete requests.\r\n     *\r\n     * @example\r\n     * new Fetch().delete('/data').then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete(url) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!isString(url)) {\n        config = url;\n        url = undefined;\n      }\n\n      return this.request(url, assign$1({ method: 'delete' }, config));\n    }\n\n    /**\r\n     * @method Fetch#get\r\n     * @public\r\n     * @param {String} [url] - See {@link Fetch#request}.\r\n     * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n     * @description Shorthand for #request for get requests.\r\n     *\r\n     * @example\r\n     * new Fetch().get('/data').then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'get',\n    value: function get(url) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!isString(url)) {\n        config = url;\n        url = undefined;\n      }\n\n      return this.request(url, assign$1({ method: 'get' }, config));\n    }\n\n    /**\r\n     * @method Fetch#head\r\n     * @public\r\n     * @param {String} [url] - See {@link Fetch#request}.\r\n     * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n     * @description Shorthand for #request for head requests.\r\n     *\r\n     * @example\r\n     * new Fetch().head('/data').then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'head',\n    value: function head(url) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!isString(url)) {\n        config = url;\n        url = undefined;\n      }\n\n      return this.request(url, assign$1({ method: 'head' }, config));\n    }\n\n    /**\r\n     * @method Fetch#headers\r\n     * @public\r\n     * @param {String|Object.<String, String|String[]>} header - A header string or an object of the following format:\r\n     * { [header]: [value1, value2, ...] }.\r\n     * @param {String|String[]} [value] - Header value. If the first argument is a string\r\n     * this has to be a header value or an array of header values.\r\n     * @returns {Fetch} Returns this.\r\n     * @description Method for setting request headers.\r\n     *\r\n     * @example\r\n     * const fetch = new Fetch()\r\n     *   .headers('Header1', 'Value')\r\n     *   .headers('Header2', ['Value1', 'Value2'])\r\n     *   .headers({\r\n     *     Header3: ['Value1', 'Value2']\r\n     *   });\r\n     */\n\n  }, {\n    key: 'headers',\n    value: function headers(header, value) {\n      var headers = this.$$.headers;\n\n\n      if (arguments.length >= 2) {\n        header = defineProperty({}, header, value);\n      }\n\n      iterate(header, function (value, header) {\n        var array$$1 = headers[header] || [];\n        var toPush = isArray(value) ? value : [value];\n\n        (headers[header] = array$$1).push.apply(array$$1, toPush);\n      });\n\n      return this;\n    }\n\n    /**\r\n     * @method Fetch#instance\r\n     * @public\r\n     * @param {FetchConfig} [config] - New config if needed.\r\n     * @returns {Fetch} New instance of Fetch.\r\n     * @description Method for creating new fetch instances based on already existent.\r\n     *\r\n     * @example\r\n     * const mainFetch = new Fetch({\r\n     *   baseURL: '//other.domain.com/api',\r\n     *   withCredentials: true\r\n     * });\r\n     *\r\n     * const longFetch = mainFetch.instance({\r\n     *   timeout: 10000\r\n     * });\r\n     */\n\n  }, {\n    key: 'instance',\n    value: function instance() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var dataConfig = new Super(config).hasOwn('data') ? { data: config.data } : {};\n\n      delete config.data;\n\n      var conf = new Super({}).deepAssign(this.$$, config).assign(dataConfig).$;\n\n      return new Fetch(conf);\n    }\n\n    /**\r\n     * @method Fetch#patch\r\n     * @public\r\n     * @param {String} [url] - See {@link Fetch#request}.\r\n     * @param {*} [data] - Additional parameter for uploading data.\r\n     * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n     * @description Shorthand for #request for head requests.\r\n     *\r\n     * @example\r\n     * new Fetch().patch('/data', { user: 'John' }).then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(url) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (arguments.length && !isString(url)) {\n        config = data;\n        data = url;\n        url = undefined;\n      }\n\n      return this.request(url, assign$1({ method: 'patch', data: data }, config));\n    }\n\n    /**\r\n     * @method Fetch#post\r\n     * @public\r\n     * @param {String} [url] - See {@link Fetch#request}.\r\n     * @param {*} [data] - Additional parameter for uploading data.\r\n     * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n     * @description Shorthand for #request for head requests.\r\n     *\r\n     * @example\r\n     * new Fetch().post('/data', { user: 'John' }).then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'post',\n    value: function post(url) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (arguments.length && !isString(url)) {\n        config = data;\n        data = url;\n        url = undefined;\n      }\n\n      return this.request(url, assign$1({ method: 'post', data: data }, config));\n    }\n\n    /**\r\n     * @method Fetch#put\r\n     * @public\r\n     * @param {String} [url] - See {@link Fetch#request}.\r\n     * @param {*} [data] - Additional parameter for uploading data.\r\n     * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n     * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n     * @description Shorthand for #request for head requests.\r\n     *\r\n     * @example\r\n     * new Fetch().put('/data', { user: 'John' }).then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'put',\n    value: function put(url) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (arguments.length && !isString(url)) {\n        config = data;\n        data = url;\n        url = undefined;\n      }\n\n      return this.request(url, assign$1({ method: 'put', data: data }, config));\n    }\n\n    /**\r\n     * @method Fetch#request\r\n     * @public\r\n     * @param {String} [url] - URL for the request.\r\n     * @param {FetchConfig} [config] - Additional config for this particular request.\r\n     * @returns {Promise.<FetchResponse, Error>} Promise that is resolved with the request response.\r\n     * @description Main function for making requests. All request methods call this method\r\n     * including the fetch instance itself.\r\n     *\r\n     * @example\r\n     * const fetch = new Fetch();\r\n     *\r\n     * fetch.request('/data', { timeout: 1000 }).then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     *\r\n     * fetch.request({ timeout: 1000 }).then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     *\r\n     * fetch.request().then((res) => {\r\n     *   console.log(res);\r\n     * });\r\n     */\n\n  }, {\n    key: 'request',\n    value: function request(url) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (arguments.length === 1 && !isString(url)) {\n        config = url;\n      }\n\n      var dataConfig = new Super(config).hasOwn('data') ? { data: config.data } : {};\n      var urlConfig = isString(url) ? { url: url } : {};\n\n      delete config.data;\n\n      var conf = new Super(this.$$).deepClone().deepAssign(urlConfig, config).assign(dataConfig).$;\n\n      var xhr = void 0;\n      var promise = Promise$1.resolve();\n\n      iterate(conf.before, function (middleware) {\n        promise = promise.then(function () {\n          if (middleware.length >= 2) {\n            return Promise$1.resolve();\n          }\n\n          return new Promise$1(function (resolve) {\n            resolve(middleware(conf));\n          });\n        }, function (err) {\n          if (middleware.length < 2) {\n            return Promise$1.reject(err);\n          }\n\n          return new Promise$1(function (resolve) {\n            resolve(middleware(err, conf));\n          });\n        });\n      });\n\n      promise = promise.then(function () {\n        return new Promise$1(function (resolve, reject) {\n          var after = conf.after,\n              _conf$auth = conf.auth,\n              username = _conf$auth.username,\n              password = _conf$auth.password,\n              data = conf.data,\n              headers = conf.headers,\n              method = conf.method,\n              onprogress = conf.onprogress,\n              responseType = conf.responseType,\n              timeout = conf.timeout,\n              url = conf.url,\n              withCredentials = conf.withCredentials;\n\n\n          xhr = new XMLHttpRequest();\n\n          xhr.open(method, url, true, username, password);\n\n          iterate(headers, function (value, header) {\n            xhr.setRequestHeader(header, value);\n          });\n\n          if (onprogress) {\n            if (uploadMethods.indexOfStrict(method) === -1) {\n              xhr.onprogress = onprogress;\n            } else {\n              xhr.upload.onprogress = onprogress;\n            }\n          }\n\n          xhr.onabort = function () {\n            reject(new Error('Request was aborted'));\n\n            xhr = null;\n          };\n\n          xhr.onerror = function () {\n            reject(new Error('Network error'));\n\n            xhr = null;\n          };\n\n          xhr.ontimeout = function () {\n            reject(new Error('Request time exceeded'));\n\n            xhr = null;\n          };\n\n          xhr.onreadystatechange = function () {\n            if (!xhr || !xhr.status || xhr.readyState !== 4) {\n              return;\n            }\n\n            var response = {\n              config: conf,\n              data: !responseType || responseType === 'text' ? xhr.responseText : xhr.response,\n              headers: parseHeaders(xhr.getAllResponseHeaders()),\n              status: xhr.status === 1223 ? 204 : xhr.status,\n              statusText: xhr.status === 1223 ? 'No Content' : xhr.statusText,\n              xhr: xhr\n            };\n\n            var promise = Promise$1.resolve();\n\n            iterate(after, function (middleware) {\n              promise = promise.then(function () {\n                if (middleware.length >= 2) {\n                  return Promise$1.resolve();\n                }\n\n                return new Promise$1(function (resolve) {\n                  resolve(middleware(response));\n                });\n              }, function (err) {\n                if (middleware.length < 2) {\n                  return Promise$1.reject(err);\n                }\n\n                return new Promise$1(function (resolve) {\n                  resolve(middleware(err, response));\n                });\n              });\n            });\n\n            resolve(promise.then(function () {\n              return response;\n            }).catch(function (err) {\n              try {\n                err.response = response;\n              } catch (e) {\n                throw err;\n              }\n\n              throw err;\n            }));\n          };\n\n          xhr.responseType = responseType;\n          xhr.timeout = Number(timeout) || 0;\n          xhr.withCredentials = !!withCredentials;\n\n          xhr.send(data);\n        });\n      });\n\n      promise.abort = function abort() {\n        if (xhr) {\n          xhr.abort();\n        }\n\n        return this;\n      };\n\n      return promise;\n    }\n  }]);\n  return Fetch;\n}(Function);\n\ndefineProperties(Fetch.prototype, defineProperty({}, _Symbol.toStringTag, 'Fetch'));\n\n/**\r\n * @function fetchBeforeMiddleware\r\n * @private\r\n * @param {FetchConfig} config\r\n * @description Built-in before middleware for url, data, method, headers construction.\r\n */\nfunction fetchBeforeMiddleware(config) {\n  var baseURL = config.baseURL,\n      data = config.data,\n      headers = config.headers,\n      method = config.method,\n      params = config.params,\n      query = config.query,\n      url = config.url;\n\n  var METHOD = method.toUpperCase();\n\n  config.method = METHOD;\n  config.url = constructURL(baseURL, url, params, query);\n  config.data = transformData(data, METHOD, headers);\n  config.headers = new Super(headers).object(function (headers, values, header) {\n    header = new Str(header).toCapitalCase().replace(/\\s+/g, '-').$;\n\n    headers[header] = values.join(', ');\n  }).$;\n}\n\n/**\r\n * @const {Fetch} fetch\r\n * @type {Fetch}\r\n * @public\r\n * @description Empty instance of Fetch.\r\n */\nvar fetch = new Fetch();\n\n/**\r\n * @module helpers/resolveURL\r\n * @private\r\n * @description Exports Object.assign-like method.\r\n */\n\nvar _global$3 = global$1;\nvar location$1 = _global$3.location;\n\n\nvar resolveURL = (function (decodeQuery) {\n  var query = location$1.search,\n      hash = location$1.hash;\n\n  var params = {\n    query: {},\n    hash: hash.replace(/^#/, '')\n  };\n\n  if (!query) {\n    return params;\n  }\n\n  new Str(query.replace(/^\\?/, '')).split('&').forEach(function (rawParam) {\n    var _rawParam$split = rawParam.split('='),\n        _rawParam$split2 = slicedToArray(_rawParam$split, 2),\n        param = _rawParam$split2[0],\n        _rawParam$split2$ = _rawParam$split2[1],\n        value = _rawParam$split2$ === undefined ? '' : _rawParam$split2$;\n\n    param = decodeQuery ? decodeURIComponent(param) : param;\n    value = decodeQuery ? decodeURIComponent(value) : value;\n\n    if (!/^[^[]+/.test(param)) {\n      return;\n    }\n\n    var paramName = void 0;\n    var paramObject = params.query;\n\n    new Str(param).match(/^[^[\\]]*|\\[[^[\\]]*]/g).forEach(function (name) {\n      if (name.indexOf('[')) {\n        paramName = name;\n\n        return;\n      }\n\n      name = name.slice(1, -1);\n\n      paramObject = paramObject[paramName] = paramObject[paramName] || (name ? {} : []);\n      paramName = name || paramObject.length;\n    });\n\n    paramObject[paramName] = value;\n  });\n\n  return params;\n});\n\n/**\r\n * @module Router\r\n * @private\r\n * @mixin\r\n * @description Exports Router.\r\n */\n\nvar Routes = new Arr([]);\nvar subscribers = new Super({});\nvar _global$2 = global$1;\nvar history = _global$2.history;\nvar location = _global$2.location;\nvar _global$location = _global$2.location;\nvar origin = _global$location.origin;\nvar href = _global$location.href;\n\nvar initialized = void 0;\nvar pushed = void 0;\nvar wasRoot = void 0;\nvar wasDefault = void 0;\nvar rootRoute = void 0;\nvar redirectRoute = void 0;\nvar RedirectRoute = void 0;\nvar defaultRoute = void 0;\nvar DefaultRoute = void 0;\nvar currentRoute = void 0;\nvar currentRouteParams = void 0;\n\nvar pathSwitcher = switcher('call', function () {\n  throw new Error('State path must be a string, a regular expression or undefined! (at registerState)');\n}).case(isRegExp, function (path) {\n  return {\n    path: path.source.replace(/\\\\\\//g, '/'),\n    url: path,\n    params: {}\n  };\n}).case(isNil, function () {\n  return {\n    path: '/',\n    url: '/',\n    params: {}\n  };\n}).case(isString, function (path) {\n  if (path.indexOf('/')) {\n    throw new Error('If route path is a string it must start with \"/\"! (at registerState)');\n  }\n\n  var index = path.indexOf('?');\n  var params = new Super({});\n  var newURL = '';\n  var newPath = new Str(path).slice(0, index === -1 ? path.length : index).replace(/^\\/|\\/$/g).split(/\\//).map(function (part, i, array$$1) {\n    if (!part && array$$1.length > 1) {\n      throw new Error('If route path is a string it must not contain \"//\" or end with \"/\"! (at makeRoute)');\n    }\n\n    var index = part.indexOf(':');\n\n    if (index > 0) {\n      throw new Error('If route path is a string resource part must be either a string or an URL parameter! (at makeRoute)');\n    }\n\n    if (index === -1) {\n      return {\n        url: part,\n        value: part\n      };\n    }\n\n    var _resolveParameter = resolveParameter(part.slice(1), 'URL parameter must not be an empty string or contain characters besides \"a-zA-Z_$\"! (at makeRoute)', 'URL parameter regexp validator must be within parentheses (e.g. :userId(\\\\d+) and not contain ones)! (at makeRoute)'),\n        name = _resolveParameter.name,\n        _resolveParameter$reg = _resolveParameter.regexp,\n        regexp = _resolveParameter$reg === undefined ? /[^/]*/ : _resolveParameter$reg;\n\n    params.$[name] = params.count;\n\n    return {\n      type: 'param',\n      url: ':' + name,\n      value: regexp\n    };\n  }).word(function (_ref) {\n    var type = _ref.type,\n        url = _ref.url,\n        value = _ref.value;\n\n    var newPath = void 0;\n\n    if (type === 'param') {\n      newPath = '(' + value.source.replace(/\\\\\\//g, '/') + ')';\n    } else {\n      newPath = new Str(value).escapeRegExp().$;\n    }\n\n    newURL += '/' + url;\n\n    return '/' + newPath;\n  });\n\n  return {\n    path: newPath,\n    url: newURL,\n    params: params.$\n  };\n});\n\nvar Route = function Route(options) {\n  classCallCheck(this, Route);\n\n  options = options || {};\n\n  var _ref2 = options || {},\n      name = _ref2.name,\n      _ref2$path = _ref2.path,\n      path = _ref2$path === undefined ? '/' : _ref2$path,\n      _ref2$abstract = _ref2.abstract,\n      abstract = _ref2$abstract === undefined ? false : _ref2$abstract,\n      parent = _ref2.parent,\n      _ref2$decodeQuery = _ref2.decodeQuery,\n      decodeQuery = _ref2$decodeQuery === undefined ? true : _ref2$decodeQuery,\n      _ref2$encodeQuery = _ref2.encodeQuery,\n      encodeQuery = _ref2$encodeQuery === undefined ? true : _ref2$encodeQuery,\n      _ref2$decodeParams = _ref2.decodeParams,\n      decodeParams = _ref2$decodeParams === undefined ? true : _ref2$decodeParams,\n      _ref2$encodeParams = _ref2.encodeParams,\n      encodeParams = _ref2$encodeParams === undefined ? true : _ref2$encodeParams;\n\n  var _pathSwitcher = pathSwitcher(path),\n      relativeURL = _pathSwitcher.url,\n      relativePath = _pathSwitcher.path,\n      params = _pathSwitcher.params;\n\n  var query = {};\n\n  new Super(this).assign({\n    name: name,\n    parentName: parent,\n    abstract: !!abstract,\n    children: new Arr([]),\n    decodeParams: !!decodeParams,\n    decodeQuery: !!decodeQuery,\n    encodeParams: !!encodeParams,\n    encodeQuery: !!encodeQuery,\n    params: params,\n    query: query,\n    relativePath: relativePath,\n    relativeURL: relativeURL\n  });\n\n  var index = isString(path) ? path.indexOf('?') : -1;\n\n  if (index !== -1) {\n    new Str(path).replace(/&$/).slice(index + 1).split('&').forEach(function (param) {\n      var _resolveParameter2 = resolveParameter(param, 'Query parameter must not be an empty string or contain characters besides \"a-zA-Z_$\"! (at makeRoute)', 'Query parameter regexp validator must be within parentheses (e.g. :userId(\\\\d+)) and not contain them! (at makeRoute)'),\n          name = _resolveParameter2.name,\n          _resolveParameter2$re = _resolveParameter2.regexp,\n          regexp = _resolveParameter2$re === undefined ? /[\\s\\S]*/ : _resolveParameter2$re;\n\n      query[name] = new RegExp('^' + regexp.source.replace(/\\\\\\//g, '/') + '$');\n    });\n  }\n\n  if (name === defaultRoute && (new Super(params).count || new Super(query).count)) {\n    throw new Error('Default route must not have URL or query params! (at makeRoute)');\n  }\n};\n\nvar baseRoute = new Route();\n\nfunction initRouter() {\n  if (initialized) {\n    return;\n  }\n\n  initialized = true;\n  RedirectRoute = (Routes.find(function (_ref3) {\n    var name = _ref3.name;\n    return name === redirectRoute;\n  }) || {}).value;\n  DefaultRoute = (Routes.find(function (_ref4) {\n    var name = _ref4.name;\n    return name === defaultRoute;\n  }) || {}).value;\n\n  if (redirectRoute && !RedirectRoute) {\n    throw new Error('There is no specified fallback route (\"' + redirectRoute + '\")! (at initRouter)');\n  }\n\n  Routes.forEach(function (route) {\n    var parentName = route.parentName,\n        name = route.name;\n\n    var ParentName = parentName || rootRoute;\n\n    var _ref5 = Routes.find(function (_ref6) {\n      var name = _ref6.name;\n      return name === ParentName;\n    }) || {},\n        parent = _ref5.value;\n\n    if (!parent) {\n      throw new Error('No such parent route (\"' + ParentName + '\") found for the route (\"' + name + '\")! (at initRouter)');\n    }\n\n    if (!parent.abstract && name !== rootRoute) {\n      throw new Error('Parent route must be abstract (for \"' + name + '\")! (at initRouter)');\n    }\n\n    if (name !== rootRoute) {\n      route.parentName = ParentName;\n    }\n\n    route.parent = name === rootRoute ? baseRoute : parent;\n  }).forEach(function (route) {\n    var name = route.name,\n        _route$parent = route.parent,\n        parentParams = _route$parent.params,\n        parentQuery = _route$parent.query,\n        path = _route$parent.path,\n        params = route.params,\n        query = route.query,\n        relativeURL = route.relativeURL,\n        relativePath = route.relativePath;\n\n    var proto = route;\n    var count = 0;\n    var newPath = relativePath;\n    var newURL = '';\n\n    if (isRegExp(path)) {\n      throw new Error('URL regexp route cannot be extended! (at initRouter)');\n    }\n\n    while (proto = proto.parent) {\n      count += new Super(proto.params).count;\n      newPath = proto.relativePath + newPath;\n      newURL = proto.relativeURL + newURL;\n\n      proto.children.push(route);\n    }\n\n    newPath = new RegExp('^' + (newPath.replace(/\\/+/g, '/').replace(/\\/$/, '') || '/') + '$');\n    newURL = isRegExp(relativeURL) ? newPath : (newURL + relativeURL).replace(/\\/+/g, '/').replace(/\\/$/, '') || '/';\n\n    new Super(query).proto(parentQuery);\n    new Super(params).proto(parentParams).forEach(function (value, key, params) {\n      params[key] += count;\n    });\n\n    if (name === defaultRoute && (new Super(params).count || new Super(query).count)) {\n      throw new Error('Default route must not have URL or query params! (at initRouter)');\n    }\n\n    route.url = newURL;\n    route.validatePath = newPath;\n  });\n\n  changeRoute();\n\n  win.on({\n    popstate: function popstate() {\n      if (location.href !== href) {\n        pushed = true;\n      }\n\n      if (pushed) {\n        changeRoute();\n      }\n    },\n    click: function click(e) {\n      var closestLink = new Elem(e.target).closest('a');\n\n      if (closestLink.length && closestLink.attr('target') !== '_blank') {\n        e.preventDefault();\n\n        forward(closestLink.attr('href') || '', true);\n      }\n    }\n  });\n}\n\nfunction makeRoute(options) {\n  var _ref7 = options || {},\n      name = _ref7.name,\n      path = _ref7.path,\n      abstract = _ref7.abstract,\n      root = _ref7.root,\n      fallbackTo = _ref7.fallbackTo,\n      isDefault = _ref7.default;\n\n  if (initialized) {\n    console.warn('Router was already initialized (at makeRoute)');\n\n    return self$1;\n  }\n\n  if (wasRoot && root) {\n    throw new Error('There can\\'t be two root routes (\"' + rootRoute + '\" and \"' + name + '\")! (at makeRoute)');\n  }\n\n  if (wasDefault && isDefault) {\n    throw new Error('There can\\'t be two default routes (\"' + defaultRoute + '\" and \"' + name + '\")! (at makeRoute)');\n  }\n\n  if (!name) {\n    throw new Error('State must have a non-empty string \"name\" property! (at makeRoute)');\n  }\n\n  if (Routes.some(function (_ref8) {\n    var Name = _ref8.name;\n    return Name === name;\n  })) {\n    throw new Error('State must have unique \"name\" property! (at makeRoute)');\n  }\n\n  if (root) {\n    wasRoot = true;\n    rootRoute = name;\n    options.parent = null;\n\n    if (fallbackTo) {\n      redirectRoute = fallbackTo;\n    }\n  }\n\n  if (isDefault) {\n    wasDefault = true;\n    defaultRoute = name;\n\n    if (abstract) {\n      throw new Error('Default route can\\'t be abstract! (at makeRoute)');\n    }\n\n    if (isRegExp(path)) {\n      throw new Error('Default route can\\'t have a regexp path! (at makeRoute)');\n    }\n  }\n\n  var route = new Route(options);\n\n  Routes.push(route);\n\n  var unsubscribe = void 0;\n  var routeLoaded = void 0;\n\n  return function (Block) {\n    var _class, _temp;\n\n    return _temp = _class = function (_Block) {\n      inherits(_class, _Block);\n\n      function _class(opts) {\n        classCallCheck(this, _class);\n\n        var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, opts));\n\n        if (root) {\n          (function () {\n            initRouter();\n\n            var router = {\n              buildURL: function buildURL(name) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                var _ref9 = Routes.find(function (_ref10) {\n                  var n = _ref10.name;\n                  return n === name;\n                }) || {},\n                    route = _ref9.value;\n\n                if (!route) {\n                  throw new Error('There are no routes with name \"' + name + '\"! (at router.buildURL)');\n                }\n\n                var url = route.url,\n                    encodeParams = route.encodeParams,\n                    encodeQuery = route.encodeQuery;\n\n\n                if (isRegExp(url)) {\n                  throw new Error('URL can be built only from the string URLs! (at router.buildURL)');\n                }\n\n                var _options$params = options.params,\n                    params = _options$params === undefined ? {} : _options$params,\n                    _options$query = options.query,\n                    query = _options$query === undefined ? {} : _options$query,\n                    _options$hash = options.hash,\n                    hash = _options$hash === undefined ? '' : _options$hash;\n\n\n                return constructURL(origin, url, params, query, hash, {\n                  params: encodeParams,\n                  query: encodeQuery\n                });\n              },\n              go: function go(name, options) {\n                forward(router.buildURL(name, options), true);\n              },\n              goToURL: function goToURL(url) {\n                forward(url, true);\n              },\n              pushURL: function pushURL(url) {\n                changeHistory(url, true);\n              },\n              redirect: function redirect(name, options) {\n                forward(router.buildURL(name, options));\n              },\n              redirectToURL: function redirectToURL(url) {\n                forward(url);\n              },\n              replaceURL: function replaceURL(url) {\n                changeHistory(url);\n              }\n            };\n\n            _this.global.router = router;\n          })();\n        }\n\n        _this.__isCurrentRoute__ = route === currentRoute || route.children.indexOf(currentRoute) !== -1;\n        _this.args.route = currentRouteParams;\n\n        routeLoaded = false;\n        unsubscribe = subscribe(name, function () {\n          var isCurrentRoute = route === currentRoute || route.children.indexOf(currentRoute) !== -1;\n\n          if (isCurrentRoute) {\n            callBeforeLoad(_this);\n          } else {\n            callBeforeLeave(_this);\n          }\n\n          _this.args.route = currentRouteParams;\n          _this.__isCurrentRoute__ = isCurrentRoute;\n        });\n\n        if (_this.__isCurrentRoute__) {\n          callBeforeLoad(_this);\n        }\n        return _this;\n      }\n\n      createClass(_class, [{\n        key: 'beforeRemove',\n        value: function beforeRemove() {\n          unsubscribe();\n          unsubscribe = null;\n          callBeforeLeave(this);\n        }\n      }]);\n      return _class;\n    }(Block), _class.template = '<div class=\"route-' + name + '\" d-show=\"{__isCurrentRoute__}\">' + Block.template + '</div>', _temp;\n  };\n\n  function callBeforeLoad(route) {\n    if (route.beforeLoadRoute && !routeLoaded) {\n      try {\n        route.beforeLoadRoute();\n      } catch (err) {\n        console.error('Uncaught error in ' + name + '#beforeLeave:', err);\n      }\n    }\n\n    routeLoaded = true;\n  }\n\n  function callBeforeLeave(route) {\n    if (route.beforeLeaveRoute && routeLoaded) {\n      try {\n        route.beforeLeaveRoute();\n      } catch (err) {\n        console.error('Uncaught error in ' + name + '#beforeLeave:', err);\n      }\n    }\n\n    routeLoaded = false;\n  }\n}\n\nfunction subscribe(name, callback) {\n  subscribers.$[name] = callback;\n\n  return function () {\n    subscribers.delete(name);\n  };\n}\n\nfunction forward(url, push) {\n  changeHistory(url, push);\n  changeRoute();\n}\n\nfunction changeRoute() {\n  var route = findRouteByURL();\n\n  if (route) {\n    var _route = route;\n    currentRoute = _route.route;\n    currentRouteParams = objectWithoutProperties(_route, ['route']);\n\n    assign$1(currentRouteParams, {\n      name: currentRoute.name,\n      host: location.host,\n      hostname: location.hostname,\n      href: location.href,\n      origin: location.origin,\n      pathname: location.pathname,\n      port: location.port,\n      protocol: location.protocol,\n      search: location.search\n    });\n  } else {\n    if (redirectRoute) {\n      var _RedirectRoute = RedirectRoute,\n          url = _RedirectRoute.url,\n          encodeParams = _RedirectRoute.encodeParams,\n          encodeQuery = _RedirectRoute.encodeQuery;\n\n\n      return forward(constructURL(origin, url, {}, {}, '', {\n        params: encodeParams,\n        query: encodeQuery\n      }));\n    }\n\n    currentRoute = null;\n    currentRouteParams = null;\n  }\n\n  subscribers.forEach(function (callback) {\n    return callback();\n  });\n}\n\nfunction findRouteByURL() {\n  var pathname = location.pathname || '/';\n  var search = location.search || '';\n  var urlParams = void 0;\n\n  Routes.some(function (route) {\n    if (route.abstract) {\n      return;\n    }\n\n    var routeURL = route.url,\n        validatePath = route.validatePath,\n        params = route.params,\n        requiredQuery = route.query,\n        decodeParams = route.decodeParams,\n        decodeQuery = route.decodeQuery;\n\n    var resolved = resolveURL(decodeQuery);\n    var query = new Super(resolved.query);\n    var eventualParams = {};\n    var match = ((pathname.replace(/\\/$/, '') || '/') + (isRegExp(routeURL) ? search : '')).match(validatePath);\n\n    if (!match) {\n      return;\n    }\n\n    /* eslint guard-for-in: 0 */\n    for (var param in requiredQuery) {\n      if (!query.hasOwn(param) || !requiredQuery[param].test(query.$[param])) {\n        return;\n      }\n    }\n\n    match.shift();\n\n    for (var _param in params) {\n      eventualParams[_param] = decode(match[params[_param]], decodeParams);\n    }\n\n    urlParams = {\n      route: route,\n      params: eventualParams,\n      query: query.$,\n      hash: resolved.hash\n    };\n\n    return true;\n  });\n\n  if (urlParams) {\n    return urlParams;\n  }\n\n  if (!defaultRoute) {\n    return;\n  }\n\n  return _extends({\n    route: DefaultRoute,\n    params: {}\n  }, resolveURL(DefaultRoute.decodeQuery));\n}\n\nfunction decode(string, decodeParams) {\n  return decodeParams ? decodeURIComponent(string) : string;\n}\n\nfunction changeHistory(url, push) {\n  try {\n    history[push ? 'pushState' : 'replaceState'](null, null, url);\n    pushed = true;\n  } catch (err) {\n    location.href = url;\n  }\n}\n\nfunction resolveParameter(param, nameErrorName, valueErrorName) {\n  var nameMatch = param.match(/^[a-z_$]+/i);\n\n  if (!nameMatch) {\n    throw new Error(nameErrorName);\n  }\n\n  var name = nameMatch[0];\n  var value = param.slice(name.length);\n  var regexp = void 0;\n\n  if (value && (value.indexOf('(') || value.indexOf(')') !== value.length - 1)) {\n    throw new Error(valueErrorName);\n  }\n\n  if (value) {\n    regexp = new RegExp(value.slice(1, -1));\n  }\n\n  return {\n    name: name,\n    regexp: regexp\n  };\n}\n\n\n\nvar statics = Object.freeze({\n\tD: D$1,\n\tisArray: isArray,\n\tisArrayLike: isArrayLike,\n\tisBoolean: isBoolean,\n\tisDate: isDate,\n\tisDateLike: isDateLike,\n\tisElement: isElement,\n\tisFinite: isFinite,\n\tisFunction: isFunction,\n\tisInteger: isInteger,\n\tisIntegerLike: isIntegerLike,\n\tisNaN: isNaN,\n\tisNull: isNull,\n\tisNil: isNil,\n\tisNumber: isNumber,\n\tisNumberLike: isNumberLike,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\tisPrimitive: isPrimitive,\n\tisRegExp: isRegExp,\n\tisString: isString,\n\tisSymbol: isSymbol,\n\tisUndefined: isUndefined,\n\tAlphabet: Alphabet,\n\talphabet: alphabet,\n\tArr: Arr,\n\tarray: array,\n\titerate: iterate$1,\n\tBlobObject: BlobObject,\n\tblob: blob$1,\n\tBlock: Block,\n\tMixin: Mixin,\n\tinitApp: initApp,\n\twrap: wrap,\n\tDat: Dat,\n\tnow: now,\n\tdate: date,\n\tElem: Elem,\n\twin: win,\n\tdoc: doc,\n\thtml: html,\n\tbody: body,\n\thead: head$1,\n\tfind: _find,\n\tparseHTML: parseHTML,\n\tpx: px,\n\tFetch: Fetch,\n\tfetch: fetch,\n\tFunc: Func,\n\tmethod: method,\n\tnoop: noop,\n\tprop: prop$1,\n\tself: self$1,\n\tNum: Num,\n\trand: rand,\n\trandom: random,\n\tPromise: Promise$1,\n\tmakeRoute: makeRoute,\n\tStr: Str,\n\tparseJSON: parseJSON,\n\tSuper: Super,\n\tSwitcher: Switcher,\n\tswitcher: switcher,\n\twhen: when\n});\n\nvar D$$1 = D$1;\n\n\nassign$1(D$$1, statics);\n\ndelete D$$1.D;\n\nglobal$1.D = D$$1;\n\n}());\n"],"file":"dwayne.js"}