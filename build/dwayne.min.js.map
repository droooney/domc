{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/toStringTag.js","../src/utils/is.js","../src/utils/escapeRegex.js","../src/utils/noop.js","../src/utils/toCase.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/isElem.js","../src/helpers/Elem/isElementsCollection.js","../src/helpers/Elem/isHTMLDocument.js","../src/helpers/Elem/isValidNode.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/constructMixinRegex.js","../src/helpers/Block/mixinMatch.js","../src/helpers/Block/transformRestAttrs.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/createMixin.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/remove.js","../src/helpers/Block/watchForAll.js","../src/helpers/Block/wrap.js","../src/initApp.js","../src/blocks/d-switch.js","../src/mixins/d-style.js","../src/mixins/d-value.js","../src/insertTemplates.js","../src/removeApp.js","../src/global.js","../src/utils/objectStatics.js","../src/constants.js","../src/Elem.js","../src/Mixin.js","../src/Block.js","../src/blocks/d-block.js","../src/blocks/d-item.js","../src/blocks/d-each.js","../src/blocks/d-elements.js","../src/blocks/d-if.js","../src/mixins/d-attr.js","../src/mixins/d-bind.js","../src/mixins/d-class.js","../src/mixins/d-elem.js","../src/mixins/d-hide.js","../src/mixins/d-node.js","../src/mixins/d-on.js","../src/mixins/d-show.js","../src/helpers/Block/registerBuiltins.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","import { iterateArray } from './array';\n\nconst {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  iterateArray(arguments, (source, index) => {\n    if (index) {\n      iterateObject(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\n/**\n * @function defineProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining properties of an object.\n */\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineFrozenProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining frozen properties of an object.\n */\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","import { definePrototypeProperties } from './defineProperty';\n\nconst { Symbol } = global;\nconst { toString } = {};\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(object, tag) {\n  if (Symbol && Symbol.toStringTag) {\n    definePrototypeProperties(object.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","/**\n * @module helpers/checkTypes\n * @private\n * @mixin\n * @description Exports is<Type> methods.\n */\n\nimport { toStringTag } from './toStringTag';\n\n/**\n * @function isArray\n * @public\n * @param {*} value - Value to check if it is an array.\n * @returns {Boolean} If the argument is an array or not.\n * \n * @example\n * isArray([]);                             // true\n * isArray(0);                              // true\n * isArray(document.querySelectorAll('*')); // false\n */\nexport const { isArray } = Array;\n\n/**\n * @function isFunction\n * @public\n * @param {*} value - Value to check if it is a function.\n * @returns {Boolean} If the argument is a function or not.\n * \n * @example\n * isFunction(() => {});            // true\n * \n * const func = () => {};\n * Object.setPrototypeOf(func, {});\n * isFunction(func);                // true\n */\nexport function isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\n * @function isNil\n * @public\n * @param {*} value - Value to check if it is null or undefined.\n * @returns {Boolean} If the argument is null or undefined or not.\n *\n * @example\n * isNil(null);      // true\n * isNil(undefined); // true\n * isNil(false);     // false\n */\nexport function isNil(value) {\n  /* eslint eqeqeq: 0 */\n  return value == null;\n}\n\n/**\n * @function isString\n * @public\n * @param {*} value - Value to check if it is a string.\n * @returns {Boolean} If the argument is a string or not.\n *\n * @example\n * isString('0');             // true\n * isString(new String('0')); // true\n */\nexport function isString(value) {\n  return toStringTag(value) === 'String';\n}\n","const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\nconst regexpSpecialsRegexp = new RegExp(\n  regexpSpecialCharacters\n    .map((s) => `\\\\${ s }`)\n    .join('|'),\n  'g'\n);\n\nexport function escapeRegex(string) {\n  return string.replace(regexpSpecialsRegexp, '\\\\$&');\n}\n","export function noop() {}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_FIND_REGEX = /^xlink:\\w/;\nconst X_LINK_ATTR_REPLACE_REGEX = /^xlink:/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst Null = {\n  ns: null\n};\n\nexport function getAttrNS(attr, elem) {\n  const isXmlNs = attr === 'xmlns';\n\n  if (isXmlNs || attr === 'xmlns:xlink') {\n    if (elem.nodeName !== 'SVG') {\n      return Null;\n    }\n\n    return {\n      ns: XML_NS,\n      name: isXmlNs\n        ? 'xmlns'\n        : 'xlink'\n    };\n  }\n\n  if (X_LINK_ATTR_FIND_REGEX.test(attr)) {\n    if (!new Elem(elem).closest('svg').length) {\n      return Null;\n    }\n\n    return {\n      ns: X_LINK_NS,\n      name: attr.replace(X_LINK_ATTR_REPLACE_REGEX, '')\n    };\n  }\n\n  return Null;\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { Elem } from '../../Elem';\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { isElem } from './isElem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n","import { toStringTag } from '../../utils';\n\nexport function isHTMLDocument(value) {\n  return toStringTag(value) === 'HTMLDocument';\n}\n","import { toStringTag } from '../../utils';\n\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || tag === 'HTMLDocument'\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './isElem';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\nimport { document } from './constants';\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, keys } from '../../utils';\n\nexport function calculateArgs(args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  /* eslint guard-for-in: 0 */\n  for (const arg in args) {\n    argsObject[arg] = args[arg];\n  }\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { escapeRegex } from '../../utils';\n\nexport function constructMixinRegex(name) {\n  return new RegExp(`^${ escapeRegex(name) }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n","const COMMA_REGEX = /,/;\n\nexport function mixinMatch(mixins, attr) {\n  let match;\n\n  /* eslint guard-for-in: 0 */\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (argsMatch === '') {\n        args = [];\n      } else if (argsMatch) {\n        args = argsMatch.split(COMMA_REGEX);\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n\n  return match;\n}\n","import { collectFromObject, assign } from '../../utils';\nimport { D_REST_REGEX } from '../../constants';\nimport { mixinMatch } from './mixinMatch';\n\nexport function transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return collectFromObject(attrs, (eventualAttrs, value, attr) => {\n    if (D_REST_REGEX.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  });\n}\n\nexport function transformRestArgs(args) {\n  return collectFromObject(args, addArgs);\n}\n\nfunction addArgs(args, value, arg) {\n  if (D_REST_REGEX.test(arg)) {\n    assign(args, transformRestArgs(value));\n  } else {\n    args[arg] = value;\n  }\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","export function createMixin({\n  name, Mixin, dynamic,\n  value, args, comment, elem,\n  parentBlock, parentScope, parentTemplate\n}) {\n  const mixin = new Mixin({\n    name,\n    value,\n    dynamic,\n    args,\n    comment,\n    elem,\n    parentBlock,\n    parentScope,\n    parentTemplate\n  });\n\n  if (Mixin.evaluate) {\n    const value = mixin.value = mixin.evaluate((newValue, oldValue) => {\n      mixin.value = newValue;\n\n      try {\n        mixin.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    });\n\n    mixin.afterUpdate(value);\n  }\n\n  return mixin;\n}\n","import { iterateObject, iterateArray } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\nimport { createMixin } from './createMixin';\n\nexport function calculateAttrs(attrs, attrsObject, elem, firstTime) {\n  iterateObject(attrsObject, ({ type, value }, attr) => {\n    if (!attrs[attr]) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = [];\n\n  /* eslint guard-for-in: 0 */\n  for (const attr in attrs) {\n    const {\n      type,\n      dynamic,\n      value,\n      opts\n    } = attrs[attr];\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        const mixin = prevValue;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n        }\n\n        mixin.$$.isDynamic = dynamic;\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(value, (newValue) => {\n            const {\n              type,\n              dynamic\n            } = attrs[attr];\n\n            if (type === 'mixin' && !dynamic) {\n              executeMixinWatchers(mixin, newValue);\n            }\n          }, mixin);\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        }\n\n        nextValue = mixin;\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = createMixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(value, (newValue) => {\n              const {\n                type,\n                dynamic\n              } = attrs[attr];\n\n              if (type === 'mixin' && !dynamic) {\n                executeMixinWatchers(mixin, newValue);\n              }\n            }, mixin);\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  }\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, (buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: {\n        temp: [],\n        perm: []\n      }\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher.onRemove();\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { Scope } from '../../constants';\nimport { removeTempWatcher } from './removeWatcher';\n\nlet changed;\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n    const { watchers } = scope;\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (Scope.evalMode) {\n          if (Scope.gettingVars.indexOf(watchers.temp) === -1) {\n            Scope.gettingVars.push(watchers.temp);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        if (!changed) {\n          changed = [];\n        }\n\n        const oldTempWatchers = watchers.temp.slice();\n        const oldValue = scope.value;\n\n        watchers.temp = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n        changed.push({\n          scope,\n          oldValue,\n          value\n        });\n\n        setTimeout(() => {\n          if (!changed) {\n            return;\n          }\n\n          const was = [];\n          const values = [];\n\n          for (let i = changed.length - 1; i >= 0; i--) {\n            const {\n              scope,\n              value,\n              oldValue\n            } = changed[i];\n\n            iterateArray(scope.watchers.perm, (watcher) => {\n              const index = was.indexOf(watcher);\n\n              if (index === -1) {\n                was.push(watcher);\n                values.push({\n                  value,\n                  oldValue\n                });\n              } else {\n                values[index].oldValue = oldValue;\n              }\n            });\n\n            changed.splice(i, 1);\n          }\n\n          changed = null;\n\n          iterateArray(was, (watcher, i) => {\n            const {\n              value,\n              oldValue\n            } = values[i];\n\n            watcher(value, oldValue);\n          });\n        }, 0);\n      }\n    };\n  }));\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil\n} from '../../utils';\nimport { Elem } from '../../Elem';\nimport {\n  SVG_NS, D_REST_REGEX\n} from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { transformRestAttrs } from './transformRestAttrs';\nimport { calculateAttrs } from './calculateAttrs';\nimport { mixinMatch } from './mixinMatch';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { Block } from '../../Block';\n\nconst NAMED_D_BLOCK_REGEX = /^d-block:([\\s\\S]+)$/;\n\nexport function createBlock({ node, Constructor, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = new Elem(parentElem[0].ownerDocument);\n  const elem = parentElem[0].namespaceURI === SVG_NS\n    ? doc.create('svg')\n    : doc;\n  const localBlocks = parentTemplate ? parentTemplate.$$.ns._blocks : Block._blocks;\n  const localMixins = parentTemplate ? parentTemplate.$$.ns._mixins : Block._mixins;\n  let children = node.children = node.children || [];\n  let args = node.attrs = node.attrs || {};\n  let name = node.name || 'UnknownBlock';\n  let constructor = Constructor || (node.name && localBlocks[node.name]);\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n  let dBlockChildren;\n  let dElementsName;\n  let dElementsConstructor;\n\n  if (name === 'd-block' && args.name) {\n    name = 'd-elements';\n    constructor = localBlocks[name];\n    dElementsName = args.name;\n    dBlockArgs = except(args, 'name');\n    dBlockChildren = children;\n    children = [];\n    args = {};\n  } else if (name === 'd-block' && args.Constructor) {\n    name = 'UnknownBlock';\n    constructor = localBlocks[name];\n    dElementsConstructor = args.Constructor;\n    dBlockArgs = except(args, 'Constructor');\n    dBlockChildren = children;\n    children = [];\n    args = {};\n  } else if ((dBlockMatch = name.match(NAMED_D_BLOCK_REGEX)) || name === 'd-block') {\n    constructor = Block._blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const {\n      value,\n      children\n    } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = create(null);\n    let attrs = create(null);\n    let wasDRest;\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    iterateObject(args, (value, attr) => {\n      const isDRest = D_REST_REGEX.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? create(attrs)\n        : attrs;\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          setTimeout(() => {\n            iterateObject(localAttrs, cleanProperty);\n            assign(localAttrs, transformRestAttrs(\n              value, localMixins, mixinDefaultOpts\n            ));\n            calculateAttrs(attrs, currentAttrs, element, false);\n          }, 0);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    const createMixins = calculateAttrs(attrs, currentAttrs, element, true);\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        element.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      element.text(`${ text }`);\n    }\n\n    if (children) {\n      const parentElem = name === 'template'\n        ? new Elem(element[0].content)\n        : element;\n      let prevBlock;\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }\n\n    const isParentBlock = parent instanceof Block;\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    createMixins();\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  if (dElementsName) {\n    node = {\n      attrs: dBlockArgs,\n      children: dBlockChildren\n    };\n    node.name = parentScope.$$.evaluate(dElementsName, (newName) => {\n      node.name = newName;\n\n      Args.value = [node];\n    }, blockInstance, true);\n\n    Args.value = [node];\n    Args.parentScope = parentScope;\n    Args.parentTemplate = parentTemplate;\n  }\n\n  if (dElementsConstructor) {\n    node = {\n      name,\n      attrs: dBlockArgs,\n      children: dBlockChildren\n    };\n\n    Args.Constructor = parentScope.$$.evaluate(dElementsConstructor, (newConstructor) => {\n      Args.Constructor = newConstructor;\n      Args.value = [node];\n    }, blockInstance, true);\n    Args.value = [node];\n    Args.parentScope = parentScope;\n    Args.parentTemplate = parentTemplate;\n  }\n\n  const html = name === 'd-elements'\n    ? Args.value || []\n    : constructor._html;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  if (name === 'd-each') {\n    $$.scope = create(parentScope.$$.name === '#d-item' ? parentScope.$$.scope : parentScope, {\n      [Args.item || '$item']: {\n        value: null,\n        writable: true\n      },\n      [Args.index || '$index']: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { iterateObject } from '../../utils';\n\nexport function watchForAllLocals(block, watcher) {\n  iterateObject(block.$$.locals, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n\nexport function watchForAllGlobals(block, watcher) {\n  const {\n    globals,\n    watchersToRemove\n  } = block.$$;\n\n  for (const glob in globals) {\n    /* eslint guard-for-in: 0 */\n    const watchers = globals[glob].watchers.perm;\n\n    watchers.push(watcher);\n    watchersToRemove.push({\n      watcher,\n      watchers\n    });\n  }\n}\n\nexport function watchForAllArgs(block, watcher) {\n  iterateObject(block.$$.args, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n","import { isArray, isString } from './utils';\nimport { createBlock } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\nexport function initApp(html, container) {\n  const parentElem = new Elem(container).elem(0);\n\n  if (!parentElem.length) {\n    throw new Error('No valid element to insert the app into was given! (initApp)');\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    throw new Error('There already exists a Dwayne app inside the given element! (initApp)');\n  }\n\n  if (isString(html)) {\n    html = {\n      vars: [],\n      value: [{\n        name: html\n      }]\n    };\n  }\n\n  if (isArray(html)) {\n    html = {\n      vars: [],\n      value: html\n    };\n  }\n\n  class RootBlock extends Block {\n    static _vars = html.vars;\n    static _html = html.value\n  }\n\n  const block = createBlock({\n    node: {\n      name: '#RootBlock'\n    },\n    Constructor: RootBlock,\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', block)\n    .attr('dwayne-root', '');\n}\n","import { findInArray, iterateArray, noop } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-switch'] = class DSwitch extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren = [],\n        parentScope\n      },\n      args,\n      args: { value }\n    } = this;\n\n    this.values = htmlChildren.map((child, i) => {\n      const {\n        name,\n        attrs = [],\n        children\n      } = child;\n      let val = attrs.if || noop;\n\n      if (name === 'd-default') {\n        val = value;\n      } else {\n        val = parentScope.$$.evaluate(val, (newValue) => {\n          if (equals(this.values[i].value, newValue)) {\n            return;\n          }\n\n          this.values[i].value = newValue;\n\n          if (i > this.index) {\n            return;\n          }\n\n          if (i < this.index) {\n            this.index = i;\n            this.elems = children;\n\n            return;\n          }\n\n          const found = findInArray(this.values, ({ value }) => (\n            equals(value, args.value)\n          ));\n\n          if (found) {\n            this.index = found.key;\n            this.elems = found.value.children;\n          } else {\n            this.index = Infinity;\n            this.elems = null;\n          }\n        }, this);\n      }\n\n      if (equals(val, value) && this.index === Infinity) {\n        this.index = i;\n        this.elems = children;\n      }\n\n      return {\n        name,\n        children,\n        value: val\n      };\n    });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, () => {\n      const {\n        value: newValue\n      } = this.args;\n\n      this.index = Infinity;\n\n      iterateArray(this.values, ({ name, value, children }, i) => {\n        const val = name === 'd-default'\n          ? newValue\n          : value;\n\n        if (equals(val, newValue) && this.index === Infinity) {\n          this.index = i;\n          this.elems = children;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n};\n\nfunction equals(value1, value2) {\n  return value1 === value2;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /\\s*;\\s*/;\nconst CSS_STYLE_SEPARATOR_REGEX = /\\s*:\\s*/;\n\nrootMixins['d-style'] = class DStyle extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean)\n          .map(constructStyleFromString),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      css\n    } = this;\n\n    elem.removeCSS.apply(elem, keys(css));\n  }\n};\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n\nfunction constructStyleFromString(style) {\n  const split = style.split(CSS_STYLE_SEPARATOR_REGEX);\n\n  return [\n    split[0].trim(),\n    split[1].trim()\n  ];\n}\n","import {\n  isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-value'] = class DValue extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.find('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      this.value = args[0];\n    }\n\n    if (!isFunction(this.value)) {\n      initialScopeValue = this.scope.$$.evaluate((scope) => scope[this.value], (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue, false);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), changeScope);\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove() {\n    this.offElemListener();\n    this.offFormListener();\n  }\n};\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      values = values || [];\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        return values.indexOf(inputValue) === -1\n          ? values.concat(inputValue)\n          : values;\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n","import {\n  toObjectKeys,\n  assign, keys, create\n} from './utils';\n\nexport function insertTemplates(template, templates) {\n  const {\n    vars,\n    value\n  } = template;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n  iterateAndChangeChildren(value);\n\n  function iterateAndChangeChildren(nodes = []) {\n    for (let i = 0; i < nodes.length; i++) {\n      const {\n        name,\n        value,\n        children\n      } = nodes[i];\n\n      if (name === '#comment') {\n        const trimmed = value.trim();\n\n        if (newTemplates[trimmed]) {\n          const newTemplate = newTemplates[trimmed].value;\n\n          nodes.splice(i, 1, ...newTemplate);\n          assign(newVars, toObjectKeys(newTemplates[trimmed].vars));\n\n          i += newTemplate.length - 1;\n        }\n      } else {\n        iterateAndChangeChildren(children);\n      }\n    }\n  }\n\n  vars.length = 0;\n  vars.push(...keys(newVars));\n\n  return template;\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\nexport function removeApp(container) {\n  const elem = new Elem(container).elem(0);\n\n  if (!elem.length) {\n    throw new Error('No valid element to remove the app from was given! (removeApp)');\n  }\n\n  container = elem[0];\n\n  const { DwayneRootBlock } = container;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    throw new Error('No app registered inside the given element! (removeApp)');\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete container.DwayneRootBlock;\n}\n","/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint no-proto: 0 */\n  target.__proto__ = proto;\n});\n","import { create } from './utils/objectStatics';\n\nexport const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const D_REST_REGEX = /^d-rest(?:#|$)/;\n\nexport const rootBlocks = create(null);\nexport const rootMixins = create(null);\nexport const Scope = {\n  evalMode: false,\n  gettingVars: []\n};\nexport const {\n  document = {}\n} = global;\n","import {\n  isNil, isString, assign,\n  definePrototypeProperties, defineProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, toStringTag,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isHTMLDocument, isValidNode,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback ElemMethod\n * @public\n * @this Elem\n */\n\nconst { Symbol } = global;\nconst EVENT_SEPARATOR_REGEX = /(?:,| ) */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst EVENT_REGEX = /Event$/;\nconst XHTML_NS = 'http://www.w3.org/1999/xhtml';\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array.<Element|Node>\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  /**\n   * @method Elem.addMethods\n   * @public\n   * @param {String|Object.<String, ElemMethod>} methodName - Name of the method or object of\n   * method names and methods.\n   * @param {ElemMethod} [method] - If the first argument is a string this should be the method itself.\n   * @returns {typeof Elem}\n   */\n  static addMethods(methodName, method) {\n    if (arguments.length >= 2) {\n      methodName = { [methodName]: method };\n    }\n\n    definePrototypeProperties(this.prototype, methodName);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add() {\n    const elems = this.slice();\n\n    iterateArray(arguments, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromArray(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const {\n        ns,\n        name\n      } = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, name)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const { ns } = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isHTMLDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        const ns = type === 'svg'\n          ? SVG_NS\n          : elem.namespaceURI || document.documentElement.namespaceURI || XHTML_NS;\n\n        el = document.createElementNS(ns, type);\n      }\n\n      add(new Elem(el).into(elem));\n    });\n  }\n\n  /**\n   * @method Elem#createComment\n   * @public\n   * @param {String} text - Text of the comment.\n   * @returns {Elem} New instance of Elem - wrap of the created comments.\n   * @description Method for creating comments inside this element.\n   * If this element is not an Element the comment is just created.\n   *\n   * @example\n   * elem.createComment('comment');\n   */\n  createComment(text) {\n    return this\n      .create('#comment')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#createText\n   * @public\n   * @param {String} text - Text.\n   * @returns {Elem} New instance of Elem - wrap of the created text nodes.\n   * @description Method for creating text nodes inside this element.\n   * If this element is not an Element the text node is just created.\n   *\n   * @example\n   * elem.createText('text');\n   */\n  createText(text) {\n    return this\n      .create('#text')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details;\n    let finalEvent = event;\n\n    if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n      try {\n        finalEvent = new Event(finalEvent, { bubbles, cancelable });\n        assign(finalEvent, realDetails);\n      } catch (err) {}\n    }\n\n    return this.forEach((elem) => {\n      if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n        const document = isHTMLDocument(elem)\n          ? elem\n          : elem.ownerDocument;\n\n        finalEvent = document.createEvent('Event');\n        finalEvent.initEvent(event, bubbles, cancelable);\n\n        assign(finalEvent, realDetails);\n      }\n\n      elem.dispatchEvent(finalEvent);\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback} [filterFn = Boolean] - Filter function\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filterFn = Boolean) {\n    return this.collect((add, elem, index) => {\n      if (filterFn(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const { ns } = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (\n      !element\n      || isHTMLDocument(element)\n    ) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = (\n      elem.matches\n      || elem.matchesSelector\n      || elem.webkitMatchesSelector\n      || elem.mozMatchesSelector\n      || elem.msMatchesSelector\n      || elem.oMatchesSelector\n    );\n\n    return elem::matches(selector);\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   'input, select, textarea, datalist, keygen, output',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   {\n   *     'change, input': (e, elem, index) => console.log(elem.value),\n   *     'blur': () => console.log('blur')\n   *   },\n   *   'input, select, textarea, datalist, keygen, output'\n   * );\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (attr) => {\n        const { ns } = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      classList.toggle(cls, arguments.length < 2 ? !classList.contains(cls) : condition);\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\n\nif (Symbol && Symbol.species) {\n  defineProperties(Elem, {\n    [Symbol.species]: {\n      get() {\n        return Array;\n      }\n    }\n  });\n}\n\nexport { Elem };\n","import {\n  defineFrozenProperties,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\nclass Mixin {\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n\n    defineFrozenProperties(this, {\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {String} [Mixin#comment]\n     * @type {String}\n     * @public\n     */\n    this.comment = comment;\n\n    /**\n     * @member {Block} [Mixin#parentBlock]\n     * @type {Block}\n     * @public\n     */\n    this.parentBlock = parentBlock;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    parentBlock.$$.mixins.push(this);\n  }\n\n  afterUpdate() {}\n\n  beforeRemove() {}\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, isArray,\n  setToStringTag, hasOwnProperty,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  constructMixinRegex, isInstanceOf,\n  removeWatchers, removeWithParentSignal, cleanProperty,\n  transformRestArgs, calculateArgs, wrapBlock,\n  watchForAllArgs, watchForAllGlobals, watchForAllLocals\n} from './helpers/Block';\nimport {\n  D_REST_REGEX, Scope,\n  rootBlocks, rootMixins\n} from './constants';\nimport { initApp } from './initApp';\nimport { Mixin } from './Mixin';\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {String} expression - Expression which has been evaluated with the error.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback VarsWatcher\n * @public\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {Mixin} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {typeof Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {typeof Mixin} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\n/**\n * @callback RemoveHook\n * @public\n */\n\nconst blockHooks = [];\nconst mixinHooks = [];\nconst TAG_NAME_REGEX = /^[a-z][a-z\\d\\-_.:!@#$%^&*()[\\]{}='\"\\\\]*$/i;\nconst ATTR_NAME_REGEX = /^[^\\u0000-\\u0020\\s'\">/=]+$/;\nconst WATCHED_ARG_PREFIX_REGEX = /^args\\./;\nconst WATCHED_GLOBAL_PREFIX_REGEX = /^globals\\./;\nconst afterElem = new Elem();\nconst rootVars = [];\nconst rootTemplate = [];\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Element options.\n * @returns {Block} Instance of Block.\n * @description Class for dynamic templating.\n *\n * @example\n * import { D, Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/>';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world (0)';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     D(1000).interval(() => {\n *       this.text = `world (${ ++this.times })`;\n *     });\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', 'Hello, {args.text}!');\n *\n * initApp(html`<App/>`, document.getElementById('root'));\n */\nclass Block {\n  /**\n   * @member {Object.<String, typeof Block>} Block._blocks\n   * @type {Object.<String, typeof Block>}\n   * @protected\n   * @description Block namespace blocks.\n   */\n  static _blocks = create(rootBlocks);\n\n  /**\n   * @member {Object.<String, typeof Mixin>} Block._mixins\n   * @type {Object.<String, typeof Mixin>}\n   * @protected\n   * @description Block namespace mixins.\n   */\n  static _mixins = create(rootMixins);\n\n  /**\n   * @member {String[]} Block._vars\n   * @type {String[]}\n   * @protected\n   * @description Block used local vars.\n   */\n  static _vars = rootVars;\n\n  /**\n   * @member {Object[]} Block._html\n   * @type {Object[]}\n   * @protected\n   * @description Block template.\n   */\n  static _html = rootTemplate;\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {Object} [Block.template = { vars: [], value: [] }]\n   * @type {Object}\n   * @public\n   * @description Block template.\n   */\n  static template = {\n    vars: [],\n    value: []\n  };\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.original || err.expression }\" in context of block \"${ err.block.$$.name }\"):`, err);\n  }\n\n  /**\n   * @method Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterBlock(hook) {\n    blockHooks.push(hook);\n\n    return () => {\n      removeArrayElem(blockHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   */\n  static beforeRegisterMixin(hook) {\n    mixinHooks.push(hook);\n\n    return () => {\n      removeArrayElem(mixinHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Template|typeof Block} Subclass - Subclass of Block or template string of it.\n   * @returns {typeof Block|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        static template = constructor.template;\n\n        constructor(opts) {\n          super(opts);\n          this::constructor(opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass)) {\n      Subclass = class extends Block {\n        static template = {\n          vars: [],\n          value: Subclass\n        };\n      };\n    }\n\n    if (!isFunction(Subclass) && Subclass.vars && Subclass.value) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      console.warn(`Block must be a template (array or an object from an html loader), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (rootBlocks[name]) {\n      console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!TAG_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_blocks')) {\n      this._blocks = create(getProto(this)._blocks);\n    }\n\n    if (!hasOwnProperty(this, 'defaultLocals')) {\n      this.defaultLocals = {};\n    }\n\n    if (!hasOwnProperty(this, 'defaultArgs')) {\n      this.defaultArgs = create(null);\n    }\n\n    try {\n      Subclass = blockHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Block, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterBlock\" hook:', err);\n    }\n\n    if (isArray(Subclass.template)) {\n      Subclass.template = {\n        vars: [],\n        value: Subclass.template\n      };\n    }\n\n    const {\n      vars,\n      value\n    } = Subclass.template;\n\n    Subclass._html = value;\n    Subclass._vars = vars;\n    Subclass._blocks = hasOwnProperty(Subclass, '_blocks')\n      ? Subclass._blocks\n      : create(this._blocks);\n    Subclass._mixins = hasOwnProperty(Subclass, '_mixins')\n      ? Subclass._mixins\n      : create(this._mixins);\n\n    if (hasOwnProperty(Subclass, 'defaultArgs')) {\n      setProto(Subclass.defaultArgs, null);\n    }\n\n    this._blocks[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.get\n   * @public\n   * @param {String} name - Block name.\n   * @returns {typeof Block|undefined} Returns registered Block with specified name.\n   */\n  static get(name) {\n    return this._blocks[name];\n  }\n\n  /**\n   * @method Block.getMixin\n   * @public\n   * @param {String} name - Mixin name.\n   * @returns {typeof Mixin|undefined} Returns registered Mixin with specified name.\n   */\n  static getMixin(name) {\n    return this._mixins[name];\n  }\n\n  /**\n   * @method Block.init\n   * @public\n   * @param {Elem|Element} [container] - Container of the app.\n   * @returns {void}\n   * @description Method for initializing app.\n   */\n  static init(container) {\n    initApp(htmlScopeless`<d-block Constructor=\"{this}\"/>`, container);\n  }\n\n  /**\n   * @method Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {typeof Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {typeof Mixin|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          this::afterUpdate(newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin or is not an afterUpdate function, so it will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (rootMixins[name]) {\n      console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!ATTR_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_mixins')) {\n      this._mixins = create(getProto(this)._mixins);\n    }\n\n    try {\n      Subclass = mixinHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Mixin, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterMixin\" hook:', err);\n    }\n\n    Subclass._match = constructMixinRegex(name);\n\n    this._mixins[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const constructor = getProto(this).constructor;\n    const childrenBlocks = [];\n    const mixins = [];\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Block} Block#$\n       * @type {Block}\n       * @public\n       * @description This.\n       */\n      $: this,\n\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} args - Private args scope.\n       * @property {Object[]} htmlChildren - Block html children.\n       * @property {Block[]} children - Child blocks.\n       * @property {Mixin[]} mixins - Child mixins.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Elem} content - Content elements.\n       * @property {Function} evaluate - Evaluate function.\n       * @property {Object} globals - Private globals scope.\n       * @property {Object} locals - Private locals scope.\n       * @property {Object[]} watchersToRemove - Watchers to remove before removing element.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlocks: [],\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        htmlChildren: children,\n        children: childrenBlocks,\n        mixins,\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forDElements, forDItem, forDEach) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = (name === '#d-item' && !forDItem) || forDEach\n            ? (forDEach || this).$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : {};\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              Scope.evalMode = true;\n              Scope.gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.expression = func;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error('Uncaught error in Block.onEvalError:', e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(Scope.gettingVars, (watchers) => {\n                const watcher = () => {\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                watcher.onRemove = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              Scope.evalMode = false;\n              Scope.gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(mixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered) {\n            try {\n              this.afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterContentChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor._vars, (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    let args = create(constructor.defaultArgs || null);\n    let wasDRest;\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isDRest = D_REST_REGEX.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? create(args)\n        : args;\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, transformRestArgs(value));\n          calculateArgs(args, argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return assign(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      if (name !== 'd-each' || arg !== 'uid') {\n        value = parentScope.$$.evaluate(value, (value) => {\n          localArgs[arg] = value;\n          calculateArgs(args, argsObject);\n        }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n      }\n\n      localArgs[arg] = value;\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getChildBlocks\n   * @public\n   * @returns {Block[]}\n   * @description Returns child blocks.\n   */\n  getChildBlocks() {\n    return this.$$.blocks.slice();\n  }\n\n  /**\n   * @method Block#getChildBlocks\n   * @public\n   * @returns {Mixin[]}\n   * @description Returns child mixins.\n   */\n  getChildMixins() {\n    return this.$$.mixins.slice();\n  }\n\n  /**\n   * @method Block#getChildren\n   * @public\n   * @returns {Object[]}\n   * @description Returns Block HTML children.\n   */\n  getChildren() {\n    return this.$$.htmlChildren;\n  }\n\n  /**\n   * @method Block#getConstructor\n   * @public\n   * @returns {typeof Block}\n   * @description Returns Block constructor.\n   */\n  getConstructor() {\n    return this.$$.ns;\n  }\n\n  /**\n   * @method Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#getParentBlock\n   * @public\n   * @returns {Block|void}\n   * @description Returns parent block.\n   */\n  getParentBlock() {\n    return this.$$.parentBlock;\n  }\n\n  /**\n   * @method Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @method Block#getParentScope\n   * @public\n   * @returns {Block|void}\n   * @description Returns parent scope.\n   */\n  getParentScope() {\n    return this.$$.parentScope;\n  }\n\n  /**\n   * @method Block#getParentTemplate\n   * @public\n   * @returns {Block|void}\n   * @description Returns parent template.\n   */\n  getParentTemplate() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  toString() {\n    return this.$$.name;\n  }\n\n  /**\n   * @method Block#watch\n   * @public\n   * @param {...('args'|'globals'|String)} [vars] - Vars to watch (args, globals or locals).\n   * If no specified all locals, args and globals are to be watched.\n   * If the 'args' string all args are to be watched.\n   * If the 'globals' string all globals are to be watched.\n   * @param {VarsWatcher} watcher - Called when watched vars are changed.\n   * @description Method for watching for vars. If no vars passed in arguments\n   * all vars are to be watched. If the 'args' string is in the arguments all args are to be watched.\n   * If the 'globals' string is in the arguments all globals are to be watched.\n   * Otherwise specified vars will be watched.\n   * Watchers should not be put inside the constructor. It is considered best\n   * practice to do it inside the {@link Block#afterConstruct} method.\n   * Note that these expressions (vars, i.e. \"args.arg\") are not to be\n   * evaluated so you cannot put there things like \"a[b]\" or any js code,\n   * only expressions like \"a\", \"b\", \"args.a\", \"args.b\" and \"globals.a\", \"globals.b\".\n   * Also note that if there are more than one var that are changed at once (synchronously)\n   * the watcher is called only once.\n   * Note that the watcher is executed right away because in most cases\n   * this behaviour is very convenient.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div />';\n   *\n   *   afterConstruct() {\n   *     this.watch('a', () => {});\n   *     this.watch('args.a', 'globals.r', () => {});\n   *     this.watch(() => {});\n   *   }\n   * }\n   */\n  watch(...vars) {\n    const oldWatcher = arguments[arguments.length - 1];\n\n    if (!isFunction(oldWatcher)) {\n      console.warn(`The last argument (watcher) wasn't specified (${ this.$$.name }#watch)`);\n\n      return;\n    }\n\n    const watcher = () => {\n      oldWatcher();\n    };\n\n    if (arguments.length === 1) {\n      watchForAllLocals(this, watcher);\n      watchForAllArgs(this, watcher);\n      watchForAllGlobals(this, watcher);\n\n      oldWatcher();\n\n      return;\n    }\n\n    iterateArray(arguments, (variable) => {\n      if (variable === oldWatcher) {\n        return;\n      }\n\n      variable = `${ variable }`;\n\n      if (variable === '$') {\n        return watchForAllLocals(this, watcher);\n      }\n\n      if (variable === 'args') {\n        return watchForAllArgs(this, watcher);\n      }\n\n      if (variable === 'globals') {\n        return watchForAllGlobals(this, watcher);\n      }\n\n      if (WATCHED_ARG_PREFIX_REGEX.test(variable)) {\n        variable = variable.replace(WATCHED_ARG_PREFIX_REGEX, '');\n\n        if (!this.$$.args[variable]) {\n          return;\n        }\n\n        this.$$.args[variable].watchers.perm.push(watcher);\n\n        return;\n      }\n\n      if (WATCHED_GLOBAL_PREFIX_REGEX.test(variable)) {\n        variable = variable.replace(WATCHED_GLOBAL_PREFIX_REGEX, '');\n\n        if (!this.$$.globals[variable]) {\n          return;\n        }\n\n        const { watchers } = this.$$.globals[variable];\n\n        watchers.perm.push(watcher);\n        this.$$.watchersToRemove.push({\n          watcher,\n          watchers\n        });\n\n        return;\n      }\n\n      if (!this.$$.locals[variable]) {\n        return;\n      }\n\n      this.$$.locals[variable].watchers.perm.push(watcher);\n    });\n\n    oldWatcher();\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block };\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nclass DBlock extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{ParentScope}\"\n      parentTemplate=\"{ParentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    const {\n      parentScope: {\n        $$: {\n          parentScope: parentParentScope,\n          parentTemplate: parentParentTemplate,\n          htmlChildren: children\n        }\n      },\n      htmlChildren: ownChildren,\n      parentTemplate,\n      dBlockName\n    } = this.$$;\n    let found;\n\n    if (ownChildren.length) {\n      return;\n    }\n\n    this.ParentScope = parentParentScope;\n    this.ParentTemplate = parentParentTemplate;\n\n    if (dBlockName) {\n      found = findInArray(children, ({ name: nodeName }) => nodeName === `d-block:${ dBlockName }`);\n\n      if (!found) {\n        let parent = this;\n\n        /* eslint no-empty: 0 */\n        while (\n          (parent = parent.$$.parentScope)\n          && !(found = findInArray(parent.$$.dBlocks, ({ $$: { dBlockName: DBlockName } }) => DBlockName === dBlockName))\n          && parent.$$.parentScope.$$.name === '#d-item'\n        ) {}\n\n        if (found) {\n          this.ParentScope = parent;\n          this.ParentTemplate = parentTemplate;\n          found.value = {\n            children: found.value.$$.htmlChildren\n          };\n        }\n      }\n\n      this.elems = found && found.value.children.length\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = children;\n    }\n  }\n}\n\nrootBlocks['d-block'] = DBlock;\n\nexport { DBlock };\n","import { Block } from '../Block';\n\nconst template = html`\n  <d-elements\n    value=\"{$$.htmlChildren}\"\n    parentScope=\"{this}\"\n    parentTemplate=\"{$$.parentTemplate}\"\n  />\n`;\n\nclass DItem extends Block {\n  static template = template;\n  static _vars = template.vars;\n  static _html = template.value;\n}\n\nexport { DItem };\n","import {\n  assign, iterateArray, iterateObject,\n  isArray, isFunction\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\nimport { DItem } from './d-item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nrootBlocks['d-each'] = class DEach extends Block {\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item: itemName = '$item',\n        index: indexName = '$index'\n      }\n    } = this;\n\n    assign(this.$$, {\n      itemsByUIDs: {},\n      UID: this.args.uid || undefined,\n      itemName,\n      indexName\n    });\n  }\n\n  afterRender() {\n    this.evaluate(watchArgs, this.renderSet);\n    this.renderSet();\n  }\n\n  renderSet = () => {\n    const {\n      htmlChildren,\n      itemsByUIDs,\n      parentScope,\n      parentElem,\n      parentTemplate,\n      scope,\n      itemName,\n      indexName,\n      UID\n    } = this.$$;\n    const {\n      args: { sortBy }\n    } = this;\n    const newItemsByUIDs = {};\n    const newUIDsCounter = {};\n    const newUIDs = {};\n    let {\n      set,\n      filterBy\n    } = this.args;\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      scope[itemName] = item;\n      scope[indexName] = index;\n\n      const uid = parentScope.$$.evaluate(UID, null, null, false, false, this);\n\n      newUIDsCounter[uid] = (newUIDsCounter[uid] || 0) + 1;\n      newUIDs[index] = uid;\n    });\n\n    scope[itemName] = null;\n    scope[indexName] = null;\n\n    iterateObject(itemsByUIDs, (items, uid) => {\n      if (!newUIDsCounter[uid]) {\n        iterateArray(items, remove);\n\n        return;\n      }\n\n      iterateArray(items.splice(newUIDsCounter[uid]), remove);\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (itemsByUIDs[uid] && itemsByUIDs[uid].length) {\n        block = itemsByUIDs[uid].shift();\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        if (block.$$.prevBlock !== prevBlock && prevBlock) {\n          prevBlock.$$.insertAfterIt(block.$$.content, true);\n        }\n      } else {\n        block = createBlock({\n          node: {\n            itemName,\n            indexName,\n            item,\n            index,\n            name: '#d-item',\n            children: htmlChildren\n          },\n          Constructor: DItem,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      (newItemsByUIDs[uid] = newItemsByUIDs[uid] || []).push(block);\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.$$.itemsByUIDs = newItemsByUIDs;\n  };\n};\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-elements'] = class DElements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      Constructor,\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, () => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n      const { value } = this.args;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n        if (forDElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          Constructor,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }, this, true);\n  }\n};\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nrootBlocks['d-if'] = class DIf extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      parentScope,\n      htmlChildren\n    } = this.$$;\n    let index = Infinity;\n    const values = htmlChildren.map((child, i) => {\n      const {\n        name,\n        attrs = {},\n        children\n      } = child;\n      let cond = attrs.if;\n\n      if (name !== 'd-else' && cond) {\n        cond = parentScope.$$.evaluate(cond, (newValue) => {\n          if (!!newValue === values[i]) {\n            return;\n          }\n\n          values[i] = !!newValue;\n\n          if (i > index) {\n            return;\n          }\n\n          if (i < index) {\n            index = i;\n            this.elems = children;\n\n            return;\n          }\n\n          const found = findInArray(values, Boolean);\n\n          if (found) {\n            index = found.key;\n            this.elems = htmlChildren[found.key].children;\n          } else {\n            index = Infinity;\n            this.elems = null;\n          }\n        }, this);\n      } else {\n        cond = true;\n      }\n\n      if (cond && index === Infinity) {\n        index = i;\n        this.elems = children;\n      }\n\n      return !!cond;\n    });\n  }\n};\n","import { collectFromObject, iterateObject, keys } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-attr'] = class DAttr extends Mixin {\n  attrs = {};\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      attrs\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (attrs, attr) => {\n        attrs[attr] = newValue;\n      });\n    }\n\n    iterateObject(attrs, (value, prop) => {\n      if (!(prop in newValue)) {\n        elem.removeAttr(prop);\n      }\n    });\n    elem.attr(newValue);\n\n    this.attrs = newValue;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      attrs\n    } = this;\n\n    elem.removeAttr.apply(elem, keys(attrs));\n  }\n};\n\n","import { isFunction, noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-bind'] = class DBind extends Mixin {\n  off = noop;\n\n  afterUpdate(value) {\n    this.off();\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove() {\n    this.off();\n  }\n};\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nrootMixins['d-class'] = class DClass extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      classes\n    } = this;\n\n    elem.removeClass.apply(elem, classes);\n  }\n};\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-elem'] = class DElem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nclass DHide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove() {\n    this.elem.show();\n  }\n}\n\nrootMixins['d-hide'] = DHide;\n\nexport { DHide };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-node'] = class DNode extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n};\n","import { noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-on'] = class DOn extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove() {\n    this.off();\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-show'] = class DShow extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove() {\n    this.elem.show();\n  }\n};\n","import { iterateObject } from '../../utils';\nimport { rootBlocks, rootMixins } from '../../constants';\nimport { constructMixinRegex } from './constructMixinRegex';\n\niterateObject(rootBlocks, (Block) => {\n  Block._vars = Block.template.vars;\n  Block._html = Block.template.value;\n});\n\niterateObject(rootMixins, (Mixin, name) => {\n  Mixin._match = constructMixinRegex(name);\n});\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\nimport { document } from './constants';\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","assign","target","arguments","source","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","toStringTag","toString","setToStringTag","tag","Symbol","prototype","isFunction","isNil","isString","escapeRegex","string","replace","regexpSpecialsRegexp","noop","toCamelCase","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","isXmlNs","nodeName","Null","XML_NS","X_LINK_ATTR_FIND_REGEX","test","Elem","closest","X_LINK_NS","X_LINK_ATTR_REPLACE_REGEX","hide","ownerDocument","addClass","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isHTMLDocument","isValidNode","ELEMENT_REGEX","remove","parent","removeChild","show","removeClass","toElem","selector","base","document","querySelectorAll","String","calculateArgs","args","argsObject","keys","arg","undefined","cleanProperty","constructMixinRegex","RegExp","mixinMatch","mixins","Mixin","localMatch","_match","argsMatch","COMMA_REGEX","transformRestAttrs","mixinDefaultOpts","eventualAttrs","D_REST_REGEX","transformRestArgs","addArgs","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","createMixin","dynamic","comment","parentBlock","parentScope","parentTemplate","evaluate","newValue","afterUpdate","err","error","calculateAttrs","attrsObject","firstTime","type","removeAttr","opts","nextType","nextDynamic","nextValue","prevType","prevValue","isDynamic","evaluated","buildMixin","firstValue","push","constructPrivateScope","scope","globals","removeTempWatcher","onRemove","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","Scope","evalMode","gettingVars","temp","changed","oldTempWatchers","was","values","perm","createBlock","node","Constructor","parentElem","prevBlock","doc","namespaceURI","SVG_NS","localBlocks","ns","_blocks","Block","localMixins","_mixins","children","constructor","dBlockMatch","dBlockName","dBlockArgs","dBlockChildren","dElementsName","dElementsConstructor","NAMED_D_BLOCK_REGEX","blockInstance","element","currentAttrs","wasDRest","isDRest","localAttrs","restAttrs","createMixins","content","child","isParentBlock","insertAfterIt","insertAfter","addContent","insertInStartOfIt","into","Args","locals","newName","newConstructor","html","_html","itemName","item","indexName","afterConstruct","isRendered","afterRender","isInstanceOf","Class","Subclass","isPrototypeOf","removeWithParentSignal","watchForAllLocals","block","watchForAllGlobals","glob","watchForAllArgs","wrapBlock","wrapper","returnValue","wrapMixin","initApp","container","Error","RootBlock","_vars","equals","value1","value2","constructStyleFromString","style","CSS_STYLE_SEPARATOR_REGEX","trim","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","options","init","isMultiple","addValue","concat","getListenerName","selected","insertTemplates","template","templates","iterateAndChangeChildren","nodes","trimmed","newTemplates","newTemplate","newVars","removeApp","DwayneRootBlock","window","global","self","defineProperties","Object","Array","regexpSpecialCharacters","map","s","join","getProto","getPrototypeOf","setProto","setPrototypeOf","proto","__proto__","rootBlocks","rootMixins","CSS_IMPORTANT_REGEX","EVENT_REGEX","emptyCollection","_this","includes","methodName","method","this","elems","forEach","list","classList","cls","attributes","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","elements","cb","contains","el","isText","createTextNode","createComment","documentElement","createElementNS","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","event","details","bubbles","cancelable","realDetails","finalEvent","Event","createEvent","initEvent","dispatchEvent","filterFn","Boolean","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","first","prev","babelHelpers.get","apply","textContent","condition","_arguments5","toggle","_arguments6","species","_value","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","blockHooks","mixinHooks","TAG_NAME_REGEX","ATTR_NAME_REGEX","WATCHED_ARG_PREFIX_REGEX","WATCHED_GLOBAL_PREFIX_REGEX","afterElem","rootVars","rootTemplate","originalArgs","childrenBlocks","func","onChange","targetBlock","forDElements","forDItem","forDEach","onChangeFlag","result","expression","original","onEvalError","e","localWatchers","newResult","watcherBlock","removeContent","_this8","newContent","afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","filter","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","warn","currentReturnValue","blocks","htmlChildren","oldWatcher","_this9","DBlock","parentParentScope","parentParentTemplate","ownChildren","found","ParentScope","ParentTemplate","dBlocks","DItem","watchArgs","uid","renderSet","_this2","itemsByUIDs","UID","sortBy","newItemsByUIDs","newUIDsCounter","newUIDs","set","filterBy","isArr","iterate","sort","items","shift","Infinity","cond","if","val","off","on","classes","newClasses","DHide","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"yBAAO,SAASA,GAAiBC,EAAOC,MAAUC,sEACnCF,EAAO,SAACG,EAAOC,KACjBF,EAAcC,EAAOC,EAAOJ,KAGhCE,EAGT,QAAgBG,GAAYL,EAAOC,OAC5B,GAAIK,GAAI,EAAGC,EAASP,EAAMO,OAAQD,EAAIC,EAAQD,IAAK,IAChDH,GAAQH,EAAMM,MAEhBL,EAASE,EAAOG,EAAGN,cAEdM,YAOb,QAAgBE,GAAaR,EAAOC,OAC7B,GAAIK,GAAI,EAAGC,EAASP,EAAMO,OAAQD,EAAIC,EAAQD,MACxCN,EAAMM,GAAIA,EAAGN,GAI1B,QAAgBS,GAAgBT,EAAOU,MAC/BN,GAAQJ,EAAMW,QAAQD,IAEb,IAAXN,KACIQ,OAAOR,EAAO,GAIxB,QAAgBS,GAAab,SACpBD,GAAiBC,EAAOc,GAGjC,QAASA,GAAOC,EAAMC,KACfA,IAAY,ECjCnB,QAAgBC,GAAOC,YACRC,UAAW,SAACC,EAAQhB,GAC3BA,KACYgB,EAAQ,SAACjB,EAAOkB,KACrBA,GAAOlB,MAKbe,EAGT,QAAgBI,GAAkBC,EAAQtB,MAAUC,sEACpCqB,EAAQ,SAACpB,EAAOkB,KACnBnB,EAAcC,EAAOkB,EAAKE,KAG9BrB,EAGT,QAAgBsB,GAAOD,MACfE,MACAC,EAAmBC,kBAAM,YAEjBJ,EAAQ,SAACpB,EAAOkB,IACA,IAAxBK,EAAMf,QAAQU,OACNA,GAAOlB,KAIdsB,EAGT,QAAgBG,GAAeL,EAAQF,SACtBQ,WAAIR,GAGrB,QAAgBS,GAAcP,EAAQtB,OAC/B,GAAMoB,KAAOE,GACZK,EAAeL,EAAQF,MAChBE,EAAOF,GAAMA,EAAKE,GAKjC,QAAgBQ,GAAUR,EAAQtB,MAC1BwB,eAEQF,EAAQ,SAACpB,EAAOkB,KAClBA,GAAOpB,EAASE,EAAOkB,EAAKE,KAGjCE,UChDOO,GAA0Bd,EAAQe,KAClCA,EAAY,SAAC9B,EAAO+B,UACzBC,eAAejB,EAAQgB,qBAElB,cACE,gBACE,MAYpB,QAAgBE,GAAuBlB,EAAQe,KAC/BA,EAAY,SAAC9B,EAAO+B,UACzBC,eAAejB,EAAQgB,qBAElB,cACE,gBACE,MCxBpB,QAAgBG,GAAYd,SACXe,YAAWX,MAAM,GAAI,GAGtC,QAAgBY,GAAehB,EAAQiB,GACjCC,IAAUA,GAAOJ,eACOd,EAAOmB,gBAC9BD,GAAOJ,YAAcG,ICI5B,QAagBG,GAAWxC,SACK,aAAvBkC,EAAYlC,IAA0C,kBAAVA,GAcrD,QAAgByC,GAAMzC,SAEJ,OAATA,EAaT,QAAgB0C,GAAS1C,SACO,WAAvBkC,EAAYlC,GC3CrB,QAAgB2C,GAAYC,SACnBA,GAAOC,QAAQC,GAAsB,QCxBvC,QAASC,MCGhB,QAAgBC,GAAYhD,SACnBA,GAAM6C,QAAQI,GAAqBC,GAG5C,QAAgBC,GAAanD,SACpBA,GAAM6C,QAAQO,GAAyBC,GAGhD,QAASH,GAAWI,SACXA,GAAM,GAAGC,cAGlB,QAASF,GAAUC,aACLA,EAAM,GAAGE,cChBhB,QAASC,GAAQC,EAAOC,KACvBA,EAAK5B,MAAQ4B,EAAK3D,MCG1B,QAAgB4D,GAAWC,EAAK7D,MAC1BA,EAAO,IACH8D,GAAW9D,EAAM+D,MAAMC,MAEzBhB,EAAYc,EAAS,KAAOA,EAAS,ICRtC,QAASG,GAAYC,EAAMlE,EAAOkB,KAClCA,GAAOlB,ECDP,QAASmE,GAAQC,EAAK7D,KACvBA,EAAK8D,aCDJ,QAASC,GAAUF,EAAK7D,KACzBA,EAAKgE,YCDJ,QAASC,GAAQJ,EAAK7D,KACvBA,EAAKkE,iBCCJ,QAASC,GAAoBC,GACpBA,EAAKC,cAAeC,IAExBzE,UAKP0E,OAAO,SACPC,KAAK,KAAMF,IACXG,SAAUH,iCCFf,QAAgBI,GAAUtB,EAAMpD,MACxB2E,GAAmB,UAATvB,QAEZuB,IAAoB,gBAATvB,EACS,QAAlBpD,EAAK4E,SACAC,OAIHC,QACEH,EACF,QACA,SAIJI,GAAuBC,KAAK5B,IACzB,GAAI6B,IAAKjF,GAAMkF,QAAQ,OAAOrF,WAK7BsF,QACE/B,EAAKd,QAAQ8C,GAA2B,KAI3CP,GCjCF,QAASQ,GAAKrF,KACC,GAAIiF,IAAKjF,EAAKsF,cAAclB,UAC5Ca,IAAKjF,GAAMuF,SAASjB,ICJnB,QAASkB,GAAO/F,SACdA,aAAiBwF,ICE1B,QAAgBQ,GAAqBhG,SAEjCiG,IAAsBV,KAAKrD,EAAYlC,KACpC+F,EAAO/F,IACPkG,GAAQlG,GCPR,QAASmG,GAAenG,SACC,iBAAvBkC,EAAYlC,GCCrB,QAAgBoG,GAAYpG,MACpBqC,GAAMH,EAAYlC,SAGtBqG,IAAcd,KAAKlD,IACR,iBAARA,GACQ,SAARA,GACQ,qBAARA,GACQ,YAARA,ECZA,QAASiE,GAAO/F,MACfgG,GAAShG,EAAKgE,UAEhBgC,MACKC,YAAYjG,GCDhB,QAASkG,GAAKlG,MACfiF,IAAKjF,GAAMmG,YAAY7B,ICDtB,QAAS8B,GAAOpG,SACdwF,GAAOxF,GACVA,EACA,GAAIiF,IAAKjF,GCMf,QAAgBqE,GAAKgC,MAAUC,0DAAOC,SAC7B,IAAItB,IAAKqB,EAAKE,iBAAiBC,OAAOJ,KCXxC,QAASK,GAAcC,EAAMC,KACrBC,GAAKD,GAAa,SAACE,GACxBA,IAAOH,OACAG,OAAOC,UAKjB,GAAMD,KAAOH,KACLG,GAAOH,EAAKG,GCXpB,QAASE,GAAcvH,EAAOqH,EAAKjG,SACjCA,GAAOiG,GCCT,QAASG,GAAoBzF,SAC3B,IAAI0F,YAAY9E,EAAYZ,6CCDrC,QAAgB2F,GAAWC,EAAQhE,MAC7BL,cAGC,GAAMvB,KAAQ4F,GAAQ,IACnBC,GAAQD,EAAO5F,GACf8F,EAAalE,EAAKL,MAAMsE,EAAME,WAEhCD,EAAY,IACRE,GAAYF,EAAW,GACzBX,QAEc,MAAda,OAEOA,MACFA,EAAUhE,MAAMiE,uBAKdH,EAAW,gCASnBvE,GC3BF,QAAS2E,GAAmBvE,EAAOiE,EAAQO,SACzC/G,GAAkBuC,EAAO,SAACyE,EAAenI,EAAO2D,MACjDyE,GAAa7C,KAAK5B,SACb7C,GAAOqH,EAAeF,EAAmBjI,EAAO2H,EAAQO,OAG3D5E,GAAQoE,EAAWC,EAAQhE,MAE7BL,gBACYK,SACN,iBACG,oBAGJL,EACA4E,eAQKvE,SACN,kBAMZ,QAAgB0E,GAAkBnB,SACzB/F,GAAkB+F,EAAMoB,GAGjC,QAASA,GAAQpB,EAAMlH,EAAOqH,GACxBe,GAAa7C,KAAK8B,KACbH,EAAMmB,EAAkBrI,MAE1BqH,GAAOrH,ECxCT,QAASuI,GAAqBC,EAAOxI,MACpCyI,GAAWD,EAAME,GAAG1I,QAEpB0I,GAAG1I,MAAQA,IAEJwI,EAAME,GAAGC,SAAU,SAACC,KACvB5I,EAAOyI,KCRZ,QAASI,SACd9G,KAAAA,KAAM6F,IAAAA,MAAOkB,IAAAA,QACb9I,IAAAA,MAAOkH,IAAAA,KAAM6B,IAAAA,QAASxI,IAAAA,KACtByI,IAAAA,YAAaC,IAAAA,YAAaC,IAAAA,eAEpBV,EAAQ,GAAIZ,uGAYdA,EAAMuB,SAAU,IACZnJ,GAAQwI,EAAMxI,MAAQwI,EAAMW,SAAS,SAACC,EAAUX,KAC9CzI,MAAQoJ,QAGNC,YAAYD,EAAUX,GAC5B,MAAOa,WACCC,2BAA4BxH,kBAAsBuH,QAIxDD,YAAYrJ,SAGbwI,GC3BF,QAASgB,GAAe9F,EAAO+F,EAAalJ,EAAMmJ,KACzCD,EAAa,WAAkB9F,MAAfgG,KAAAA,KAAM3J,IAAAA,KAC7B0D,GAAMC,KACI,SAATgG,IACGC,WAAWjG,KAEV+E,GAAGpC,eAGJmD,GAAY9F,SAIjBgE,UAGD,GAAMhE,KAAQD,aAARC,SAMLD,EAAMC,GAJRgG,IAAAA,KACAb,IAAAA,QACA9I,IAAAA,MACA6J,IAAAA,KAEEC,SACAC,SACAC,YAEAP,EAAY9F,GAAO,OAIjB8F,EAAY9F,GAFRsG,IAANN,KACOO,IAAPlK,SAGW,SAAT2J,EACe,UAAbM,KACQvB,GAAGpC,SAGX4D,IAAclK,KACX2D,KAAKA,EAAM3D,KAGNA,MACP,IACCwI,GAAQ0B,KAEG,SAAbD,KACGL,WAAWjG,KAGZ+E,GAAGyB,UAAYrB,EAEjBA,IACmBN,EAAOxI,OACvB,KAAKwI,EAAME,GAAG0B,WAAaP,EAAKjC,MAAMuB,SAAU,IAC/CC,GAAWZ,EAAME,GAAGO,YAAYP,GAAGS,SAASnJ,EAAO,SAACoJ,SAIpD1F,EAAMC,GAFRgG,IAAAA,KACAb,IAAAA,OAGW,WAATa,GAAqBb,KACFN,EAAOY,IAE7BZ,KAEGE,GAAG0B,WAAY,IAEA5B,EAAOY,KAGlBZ,IAGHmB,IACGb,MACT,IACQ,SAATa,IACGhG,KAAKA,EAAM3D,KAEJA,MACP,IACCqK,GAAa,aACZvB,QAAUA,KAETN,GAAQK,EAAYgB,OAErBf,GAAWe,EAAKjC,MAAMuB,SAAU,IAEjCF,GAEEY,EAFFZ,YACAjJ,EACE6J,EADF7J,MAEIsK,EAAarB,EAAYP,GAAGS,SAASnJ,EAAO,SAACoJ,SAI7C1F,EAAMC,GAFRgG,IAAAA,KACAb,IAAAA,OAGW,WAATa,GAAqBb,KACFN,EAAOY,IAE7BZ,KAEGE,GAAG0B,WAAY,IACf1B,GAAG1I,MAAQsK,WAGP9B,uCAODA,IAKTkB,KACKa,KAAKF,SAMLV,IACGb,IAGJnF,SACJmG,UACGC,QACFC,IArHArG,MAyHP+F,QACK,cACQ/B,EAAQ,SAAC0C,SAIhBA,IAFF1G,IAAAA,KACAkG,IAAAA,OAGUlG,GAAQkG,KCnJrB,QAASW,GAAsBpJ,EAAQuI,EAAMV,MAC9CwB,YAES,YAATd,MACM7E,GACNmE,EACIA,EAAYP,GAAGgC,QACf,OAIDvJ,EAAkBC,EAAQ,SAACqJ,EAAOzK,EAAOkB,KACxCA,yCAOLuJ,GCnBE,QAASE,IAAkB/B,KACxBgC,eAIV,QAAgBC,IAAeC,KAChBA,EAAkBC,IAGjC,QAASA,UAAgBnC,KAAAA,YAASD,SACNC,GCN5B,QAAgBoC,IAAqBP,EAAOQ,EAAaC,MACtCT,EAAO7I,EAAUqJ,EAAa,SAACjL,EAAOkB,MAC/CuJ,GAAQS,EAAahK,GACnByH,EAAa8B,EAAb9B,8BAGQ,cACF,uBAENwC,IAAMC,WAC0C,IAA9CD,GAAME,YAAY7K,QAAQmI,EAAS2C,UAC/BD,YAAYd,KAAK5B,EAAS2C,MAI7Bb,EAAMzK,oBAEXA,MACEA,IAAUyK,EAAMzK,OAIfuL,eAICC,GAAkB7C,EAAS2C,KAAK9J,QAChCiH,EAAWgC,EAAMzK,QAEdsL,UACHtL,MAAQA,IAEDwL,EAAiBb,OACtBJ,8CAMG,cACJgB,QAOA,GAHCE,MACAC,KAEGvL,EAAIoL,GAAQnL,OAAS,EAAGD,GAAK,EAAGA,cAAhCA,SAKHoL,GAAQpL,GAHVsK,IAAAA,MACAzK,IAAAA,MACAyI,IAAAA,WAGWgC,EAAM9B,SAASgD,KAAM,SAAC/C,MAC3B3I,GAAQwL,EAAIjL,QAAQoI,IAEX,IAAX3I,KACEsK,KAAK3B,KACF2B,8BAKAtK,GAAOwI,SAAWA,OAIrBhI,OAAON,EAAG,IArBXA,MAwBC,OAEGsL,EAAK,SAAC7C,EAASzI,SAItBuL,EAAOvL,OAFTH,QACAyI,cAKH,SCpEX,QAAgBmD,UAAcC,KAAAA,KAAMC,IAAAA,YAAavF,IAAAA,OAAQwF,IAAAA,WAAY/C,IAAAA,YAAaC,IAAAA,YAAaC,IAAAA,eAAgB8C,IAAAA,UACvGC,EAAM,GAAIzG,IAAKuG,EAAW,GAAGlG,eAC7BtF,EAAOwL,EAAW,GAAGG,eAAiBC,GACxCF,EAAInH,OAAO,OACXmH,EACEG,EAAclD,EAAiBA,EAAeR,GAAG2D,GAAGC,QAAUC,GAAMD,QACpEE,EAActD,EAAiBA,EAAeR,GAAG2D,GAAGI,QAAUF,GAAME,QACtEC,EAAWb,EAAKa,SAAWb,EAAKa,aAChCxF,EAAO2E,EAAKnI,MAAQmI,EAAKnI,UACzB3B,EAAO8J,EAAK9J,MAAQ,eACpB4K,EAAcb,GAAgBD,EAAK9J,MAAQqK,EAAYP,EAAK9J,MAC5D6K,SACAC,SACAC,SACAC,SACAC,SACAC,QAES,aAATlL,GAAsBmF,EAAKnF,QACtB,eACOqK,EAAYrK,KACVmF,EAAKnF,OACRV,EAAO6F,EAAM,UACTwF,aAGC,YAAT3K,GAAsBmF,EAAK4E,eAC7B,iBACOM,EAAYrK,KACHmF,EAAK4E,cACfzK,EAAO6F,EAAM,iBACTwF,eAGPE,EAAc7K,EAAKuB,MAAM4J,MAAkC,YAATnL,OAC9CwK,GAAMD,QAAQ,aACfM,EAAcA,EAAY,GAAK,SAG1CO,aAEAR,QAEgB,GAAIA,2HAYpB,MAAOrD,WACCC,+BAAgCxH,MAAUuH,KACpC,SAIbqD,EAAa,OAIZd,EAFF7L,IAAAA,MACA0M,IAAAA,SAGIU,EAAU7M,EAAKuE,OAAO/C,GACtBsL,EAAevI,GAAO,MACxBpB,EAAQoB,GAAO,MACfwI,SACEpF,QACEkF,kDAMMlG,EAAM,SAAClH,EAAO2D,MACpB4J,GAAUnF,GAAa7C,KAAK5B,GAC5B6J,EAAaD,GAAWD,EAC1BxI,GAAOpB,GACPA,OAEI8J,EAEJD,EAAS,IACLE,GAAYxE,EAAYP,GAAGS,SAASnJ,EAAO,SAACA,cACrC,aACKwN,EAAYjG,KACnBiG,EAAYvF,EACjBjI,EAAOwM,EAAatE,MAEPxE,EAAO2J,EAAcD,GAAS,IAC5C,IACFpE,aAEQ,EAEJlI,EAAO0M,EAAYvF,EACxBwF,EAAWjB,EAAatE,OAItB5E,GAAQoE,EAAW8E,EAAa7I,SAE3B,EAEPL,gBACSK,SACH,iBACG,oBAGJL,EACA4E,eAQEvE,SACH,aACCsF,EAAYP,GAAGS,SAASnJ,EAAO,SAACA,KAC1B2D,SACH,kBAGOD,EAAO2J,EAAcD,GAAS,IAC5CpE,SAID0E,GAAelE,EAAe9F,EAAO2J,EAAcD,GAAS,MAErD,aAATrL,KACMiD,KAAKhF,GAGF,UAAT+B,EAAkB,IAChBiD,GAAOiE,EAAYP,GAAGS,SAASnJ,EAAO,SAACA,GACrCyC,EAAMzC,OACA,MAGFgF,QAAShF,IAChBgJ,EAECvG,GAAMuC,OACD,MAGDA,QAASA,MAGf0H,EAAU,IACNX,GAAsB,aAAThK,EACf,GAAIyD,IAAK4H,EAAQ,GAAGO,SACpBP,EACApB,WAESU,EAAU,SAACkB,KACVhC,SACJgC,SACE7B,+EAUR8B,GAAgBtH,YAAkBgG,UAEpCP,aAAqBO,MACb7D,GAAGoF,cAAcV,GAAS,GAC3BpB,KACD+B,YAAY/B,GAEhB6B,KACKnF,GAAGsF,WAAWZ,IAEdS,IACFnF,GAAGuF,kBAAkBb,GAAS,KAE7Bc,KAAKnC,GAAY,OAKpBqB,QAQLD,EAJFzE,IAAAA,GACMyF,IAANjH,KACAwD,IAAAA,QACG0D,+BAGDpB,cAEOF,WACGC,KAEPhL,KAAOkH,EAAYP,GAAGS,SAAS6D,EAAe,SAACqB,KAC7CtM,KAAOsM,IAEPrO,OAAS6L,IACbsB,GAAe,KAEbnN,OAAS6L,KACT5C,YAAcA,IACdC,eAAiBA,GAGpB+D,oBAGOH,WACGC,KAGPjB,YAAc7C,EAAYP,GAAGS,SAAS8D,EAAsB,SAACqB,KAC3DxC,YAAcwC,IACdtO,OAAS6L,IACbsB,GAAe,KACbnN,OAAS6L,KACT5C,YAAcA,IACdC,eAAiBA,MAGlBqF,GAAgB,eAATxM,EACToM,EAAKnO,UACL2M,EAAY6B,WAEbtH,KAAOsD,EAAsB2D,KAC7BC,OAAS5D,EAAsB4D,KAC/B1D,QAAUF,EAAsBE,EAAS,UAAWzB,GAE1C,YAATlH,EAAoB,OAChBkJ,cACHY,EAAK4C,SAAW5C,EAAK6C,WACrB7C,EAAK8C,UAAY9C,EAAK5L,UAEnBwK,GAAgC,YAAxBxB,EAAYP,GAAG3G,KACzBkH,EAAYP,GAAG+B,MACfxB,IAEDoD,GAAKpD,EAAYP,GAAG2D,KACpBnB,aAAeV,EAAsBS,OACnBvC,EAAG+B,MAAQ3F,GAAO2F,IAAQQ,GAAavC,EAAGwC,iBAGpD,WAATnJ,EAAmB,UAClB0I,MAAQ3F,GAA+B,YAAxBmE,EAAYP,GAAG3G,KAAqBkH,EAAYP,GAAG+B,MAAQxB,eAC1EkF,EAAKO,MAAQ,eACL,eACG,UAEXP,EAAKlO,OAAS,gBACN,eACG,YAKKkO,EAAMA,EAAMzF,EAAGxB,SACfwD,EAASA,EAAShC,EAAGgC,YACrByC,EAAeiB,EAAQ1F,EAAG0F,cAG/BQ,iBACd,MAAOtF,WACCC,2BAA4BxH,qBAAyBuH,SAGnDhC,KACW,eAATvF,EACVoM,EAAKlF,YACLkE,IACsB,eAATpL,EACboM,EAAKjF,eACLiE,IAESoB,EAAM,SAACX,KACNhC,SACJgC,SACET,2BAEKA,mDAOHzE,GAAGmG,YAAa,QAGdC,cACd,MAAOxF,WACCC,2BAA4BxH,kBAAsBuH,SAGrD6D,GCtUT,QAAgB4B,IAAaC,EAAOC,eACpBC,WAAcD,SAAmB1M,UAAW2M,WAAcD,EAAS1M,WCH5E,QAAS4M,IAAuBvB,KAC/BlF,GAAGpC,QAAO,GAGlB,QAAgBA,IAAOsH,KACflF,GAAGpC,SCHJ,QAAS8I,IAAkBC,EAAOzG,KACzByG,EAAM3G,GAAG0F,OAAQ,cAAGzF,SACvBgD,KAAKpB,KAAK3B,KAIvB,QAAgB0G,IAAmBD,EAAOzG,SAIpCyG,EAAM3G,GAFRgC,IAAAA,QACAI,IAAAA,qBAGG,GAAMyE,KAAQ7E,GAAS,IAEpB/B,GAAW+B,EAAQ6E,GAAM5G,SAASgD,OAE/BpB,KAAK3B,KACG2B,8BAOrB,QAAgBiF,IAAgBH,EAAOzG,KACvByG,EAAM3G,GAAGxB,KAAM,cAAGyB,SACrBgD,KAAKpB,KAAK3B,KCxBhB,QAAS6G,IAAUJ,EAAOK,MACzBC,GAAcD,EAAQL,SAErBN,IAAaxC,GAAOoD,GACvBA,EACAN,EAGN,QAAgBO,IAAUpH,EAAOkH,MACzBC,GAAcD,EAAQlH,SAErBuG,IAAanH,GAAO+H,GACvBA,EACAnH,ECZC,QAASqH,IAAQtB,EAAMuB,MACtB/D,GAAa,GAAIvG,IAAKsK,GAAWvP,KAAK,OAEvCwL,EAAW3L,YACR,IAAI2P,OAAM,mEAGdhE,EAAWhH,KAAK,wBACZ,IAAIgL,OAAM,wEAGdrN,GAAS6L,6BAIDA,MAKRrI,GAAQqI,sBAGDA,OAILyB,uIAAkBzD,MACf0D,MAAQ1B,EAAK3N,OACb4N,MAAQD,EAAKvO,SAGhBqP,GAAQzD,eAEJ,0BAEKoE,SACLjE,mBAKPhH,KAAK,kBAAmBsK,GACxB1L,KAAK,cAAe,IC+DzB,QAASuM,IAAOC,EAAQC,SACfD,KAAWC,ECxDpB,QAASxM,IAAWC,EAAK6K,YACDA,KAAf3J,OAAM/E,SAET+E,GAAQ/E,EAGd,QAASqQ,IAAyBC,MAC1BvM,GAAQuM,EAAMvM,MAAMwM,WAGxBxM,EAAM,GAAGyM,OACTzM,EAAM,GAAGyM,QC8Db,QAASC,IAAQ1O,EAAM4H,EAAMpJ,UACnBwB,OACD,eACIxB,GAAKmQ,QAAQ,YAChB,kBACA,YAGD,cACU,SAAT/G,EACK,QAGO,UAATA,GAA6B,aAATA,EACvB,UACA,sBAIGpJ,GAAKmQ,QAAQ,mBAChB,OACA,SAKV,QAASC,IAAmB5O,EAAM/B,EAAO2J,EAAMiH,MAChC,UAAT7O,QACK/B,MAGH6Q,GAAmB,UAATlH,QAEXkH,IAAoB,aAATlH,EAITkH,EACH7Q,IAAU4Q,GACqB,IAA/B5Q,EAAMQ,QAAQoQ,GALT5Q,EAQX,QAAS8Q,IAAmB/O,EAAM/B,EAAO2J,EAAMiH,EAAYlF,EAAQqF,EAASC,EAAMC,UACxElP,OACD,eACEkP,GAIErR,EAAiBmR,EAASG,OAHxBlR,MAMN,WACU,UAAT2J,GAA6B,aAATA,QACf3J,MAGI,UAAT2J,QACK3J,GACH4Q,EACA,UAGGlF,OAEJ1L,GAASgR,QACLtF,MAGL1L,SACqC,IAAhC0L,EAAOlL,QAAQoQ,GAClBlF,EAAOyF,OAAOP,GACdlF,KAGAzL,GAAQyL,EAAOlL,QAAQoQ,UAEd,IAAX3Q,eAEGyL,EAAOlK,MAAM,EAAGvB,OAChByL,EAAOlK,MAAMvB,EAAQ,KAIrByL,gBAIA1L,IAKb,QAASoR,IAAgBrP,EAAM4H,UACrB5H,OACD,eACI,aAGJ,cAEQ,UAAT4H,GACY,aAATA,GACS,UAATA,GACS,SAATA,EAED,SACA,6BAIG,SAKb,QAASuH,IAASxF,QAAU2F,KAAAA,SAAUrR,IAAAA,KAChCqR,KAAuC,IAA3B3F,EAAOlL,QAAQR,MACtBuK,KAAKvK,GClPT,QAASsR,IAAgBC,EAAUC,WAW/BC,SACF,GAD2BC,6DACvBvR,EAAI,EAAGA,EAAIuR,EAAMtR,OAAQD,IAAK,OAKjCuR,EAAMvR,GAHR4B,IAAAA,KACA/B,IAAAA,MACA0M,IAAAA,YAGW,aAAT3K,EAAqB,IACjB4P,GAAU3R,EAAMwQ,UAElBoB,EAAaD,GAAU,IACnBE,GAAcD,EAAaD,GAAS3R,QAEpCS,gBAAON,EAAG,aAAM0R,OACfC,EAASpR,EAAakR,EAAaD,GAAS/Q,UAE9CiR,EAAYzR,OAAS,UAGHsM,OA7B7B9L,GAEE2Q,EAFF3Q,KACAZ,EACEuR,EADFvR,MAEI4R,EAAe9M,GAAO,MACtBgN,EAAUpR,EAAaE,YAEtBgR,EAAcJ,KACIxR,KA2BpBI,OAAS,IACTmK,gBAAQnD,GAAK0K,KAEXP,ECzCF,QAASQ,IAAUjC,MAClBvP,GAAO,GAAIiF,IAAKsK,GAAWvP,KAAK,OAEjCA,EAAKH,YACF,IAAI2P,OAAM,oEAGNxP,EAAK,SAEWuP,EAApBkC,IAAAA,qBAEFA,YAA2BzF,UACzB,IAAIwD,OAAM,6DAGFrH,GAAGpC,WACdsD,WAAW,qBAETkG,GAAUkC,gBCnBnB,OAAiC,mBAAXC,QAAyBA,OAA2B,mBAAXC,QAAyBA,OAAyB,mBAATC,MAAuBA,c9CC7GzQ,MAAhBD,eAEMD,MAAAA,MCIO4Q,GAAqBC,OAArBD,ggECPIF,GAAX5P,MAAAA,aACAH,MAAAA,SCiBO+D,GAAYoM,MAAZpM,QCpBTqM,IACJ,IACA,IAAK,IAAK,IACV,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IACA,IACA,IACA,IACA,IACA,IACA,MAEIzP,GAAuB,GAAI2E,QAC/B8K,GACGC,IAAI,SAACC,cAAYA,IACjBC,KAAK,KACR,K2CnBA5N,GAGEuN,OAHFvN,OACAsC,GAEEiL,OAFFjL,KACgBuL,GACdN,OADFO,eAGWC,GAAWR,OAAOS,gBAAmB,SAAC/R,EAAQgS,KAElDC,UAAYD,GzCRf9P,GAAsB,UACtBG,GAA0B,SEC1BY,GAAiC,KwCA1Ba,GAAa,oBACbsH,GAAS,6BACT/D,GAAe,iBAEf6K,GAAanO,GAAO,MACpBoO,GAAapO,GAAO,MACpBqG,cACD,qBAKR+G,SADFpL,SAAAA,qBlCXIxB,GAAyB,YACzBK,GAA4B,UAC5BN,GAAS,gCACTK,GAAY,+BACZN,OACA,MGJAa,GAAwB,8BEDxBI,GAAgB,c8BmDH6L,GAAX5P,MAAAA,OAGF6Q,GAAsB,gBACtBC,GAAc,SAEdC,MAeA7N,+BAmBQjF,0DAAO8S,sFAGZrN,GAAqBzF,QAChBA,SAGKiF,EAAKjD,aAEPhC,EAAM,SAACA,GACbyF,EAAqBzF,QAChBA,MAGGA,EAAM,SAACA,IACb+S,EAAKC,SAAShT,IAAS6F,EAAY7F,MACjCgK,KAAKhK,oEA1BAiT,EAAYC,SACxBzS,WAAUZ,QAAU,YACNoT,EAAaC,MAGLC,KAAKnR,UAAWiR,GAEnCE,8CAsCDC,GAAQD,KAAKlS,iBAENR,UAAW,SAACT,GAClByF,EAAqBzF,QAChBA,MAGGA,EAAM,SAACA,IACboT,EAAMJ,SAAShT,IAAS6F,EAAY7F,MACjCgK,KAAKhK,OAKVoT,2DAcAD,MAAKE,QAAQ,SAACrT,MACbsT,GAAOtT,EAAKuT,cAEM,SAACC,SAAQF,GAAKzP,IAAI2P,oCAyBzCpQ,EAAM3D,MACHO,GAAOmT,KAAK,OAEb1S,UAAUZ,aACRG,GAIEX,EAAiBW,EAAKyT,WAAYvQ,SAGvCzC,UAAUZ,QAAU,GAAKsC,EAASiB,GAAO,KACtCpD,QACI,YAML0E,EAAUtB,EAAMpD,GAFlB8L,IAAAA,GACAtK,IAAAA,WAGKsK,GACH9L,EAAK0T,eAAe5H,EAAItK,GACxBxB,EAAK2T,aAAavQ,SAGpB3C,WAAUZ,QAAU,YACZuD,EAAO3D,IAGZ0T,KAAKE,QAAQ,SAACrT,KACLoD,EAAM,SAAC3D,EAAOkB,MACtBuB,EAAMzC,KAAoB,IAAVA,QACX,IAAIwF,GAAKjF,GAAMqJ,WAAW1I,MAGjB,IAAVlB,EAAiB,GAAKA,QAEfiF,EAAU/D,EAAKX,GAAtB8L,IAAAA,EAEJA,KACG8H,eAAe9H,EAAInL,EAAKlB,KAExBoU,aAAalT,EAAKlB,gDAgBtB,IAAIwF,GAAKkO,KAAKtT,OAASsT,KAAK,GAAGW,+CAWhCzN,SACC8M,MAAKY,QAAQ,SAAClQ,EAAK7D,QACjBA,GAAM,IACP,GAAIiF,GAAKjF,GAAMgU,GAAG3N,SACbxC,GAAI7D,KAGNA,EAAKgE,8CAKVzE,cACA0U,KACAC,EAAOD,EAASjK,UAATiK,eAERZ,QAAQ,SAACrT,EAAMN,KACTwU,EAAIlU,EAAMN,OAGd,GAAIuF,GAAKgP,oCAcTpH,MACD7G,GAASmN,KAAK,GACd9F,EAAQjH,EAAOyG,GAAS,YAEtB7G,IAAWqH,IAEfrH,EAAOmO,SAAS9G,kCAefjE,SACE+J,MAAKY,QAAQ,SAAClQ,EAAK7D,MACpBoU,GAAK,KACHC,EAAkB,UAATjL,EACT7C,EAAWX,EAAe5F,GAC5BA,EACAA,EAAKsF,iBAEL+O,GAAmB,aAATjL,IACPiL,EACD9N,EAAS+N,eAAe,IACxB/N,EAASgO,cAAc,QACtB,IACCzI,GAAc,QAAT1C,EACPwC,GACA5L,EAAK2L,cAAgBpF,EAASiO,gBAAgB7I,cA1QzC,iCA4QJpF,EAASkO,gBAAgB3I,EAAI1C,KAGhC,GAAInE,GAAKmP,GAAIzG,KAAK3N,4CAeZyE,SACL0O,MACJ5O,OAAO,YACPE,KAAKA,sCAcCA,SACF0O,MACJ5O,OAAO,SACPE,KAAKA,+BAsBNlB,EAAU9D,SACM0T,KAAK,OAAfpD,IAAAA,YAEHtP,WAAUZ,OAQXY,UAAUZ,QAAU,GAAKsC,EAASoB,GAC/BwM,KAIMnN,EAAaW,GAEjBwM,EAAM2E,iBAAiBnR,IAAawM,EAAM4E,oBAAoBpR,GAAY,cAAgB,KALxF,IAQP9C,UAAUZ,QAAU,YACR0D,EAAW9D,IAGpB0T,KAAKE,QAAQ,SAACrT,KACLuD,EAAU,SAAC9D,EAAO8D,QACnBX,EAAaW,GAEpBrB,EAAMzC,KAAoB,IAAVA,QACX,IAAIwF,GAAKjF,GAAM4U,UAAUrR,KAG7BwM,MAAM8E,eAAetR,KACrBwM,MAAM+E,YACTvR,EACA9D,EAAM6C,QAAQsQ,GAAqB,IACnCA,GAAoB5N,KAAKvF,GAAS,YAAc,SAjC/CsQ,EAIE1Q,EAAiB0Q,EAAMgF,QAAQvR,MAnVT,OAmV4CH,mCAuDxE1C,EAAKlB,SACY0T,KAAK,OAAjB6B,IAAAA,YAEHvU,UAAUZ,aACRmV,GAIEpU,EAAkBoU,EAAStR,SAGX,IAArBjD,UAAUZ,QAAgBsC,EAASxB,GAAM,KACtCqU,eAIEA,GAAQrU,SAGbF,WAAUZ,QAAU,YACbc,EAAMlB,IAGV0T,KAAKE,QAAQ,SAACrT,KACLW,EAAK,SAAClB,EAAOkB,KACpBqU,QAAQrU,GAAOlB,uCAoBjBwV,MAAOC,+DAKVA,EAHFC,QAAAA,kBAGED,EAFFE,WAAAA,gBACGC,KACDH,4BACAI,EAAaL,MAEZpC,GAAY7N,KAAKrD,EAAY2T,UAEjB,GAAIC,OAAMD,GAAcH,UAASC,iBACvCE,EAAYD,GACnB,MAAOtM,UAGJoK,MAAKE,QAAQ,SAACrT,OACd6S,GAAY7N,KAAKrD,EAAY2T,IAAc,IACxC/O,GAAWX,EAAe5F,GAC5BA,EACAA,EAAKsF,gBAEIiB,EAASiP,YAAY,WACvBC,UAAUR,EAAOE,EAASC,KAE9BE,EAAYD,KAGhBK,cAAcJ,uCAclB5V,0DAAQ,QACPA,GAAQ,MACFyT,KAAKtT,OAASH,GAGjB,GAAIuF,GAAKkO,KAAKzT,gDAahBiW,yDAAWC,cACTzC,MAAKY,QAAQ,SAAClQ,EAAK7D,EAAMN,GAC1BiW,EAAS3V,EAAMN,QACbM,kCAaLqG,SACI8M,MAAKY,QAAQ,SAAClQ,EAAK7D,KACpBqE,EAAKgC,EAAUrG,sCAgBfT,uBACO4T,KAAM,SAAC1T,EAAOkB,KAChBlB,EAAOkB,OAGXwS,qCAcD/P,MACApD,GAAOmT,KAAK,OAEbnT,SACI,QAGM0E,EAAUtB,EAAMpD,GAAvB8L,IAAAA,SAEDA,GACH9L,EAAK6V,eAAe/J,EAAI1I,GACxBpD,EAAK8V,aAAa1S,oCAcfoQ,MACDxT,GAAOmT,KAAK,WAEXnT,GACHA,EAAKuT,UAAUY,SAASX,wCAcrBL,MAAKE,QAAQhO,gCAejB2I,OACEvN,UAAUZ,OAAQ,IACfG,GAAOmT,KAAK,SAEXnT,GACHA,EAAK+V,UACL,SAGC5C,MAAKE,QAAQ,SAACrT,KACd+V,UAAY/H,qCAIZhO,UACwB,IAAxBmT,KAAKlT,QAAQD,uCAgBV6M,KACAzG,EAAOyG,GAAS7M,KAAK,MAE3BgG,GAAS6G,EAAQ7G,eAEhBA,GAAOnG,UAIFgN,EAAQmJ,OAAO,KAChBhQ,EAAO,GAETmN,KAAKE,QAAQ,SAACrT,MACfA,IAAS6M,gBACDA,EAAQ/I,YAKhB+I,KACKoJ,aAAajW,EAAM6M,KAEnBqJ,YAAYlW,MAhBdmT,0CAkCEtG,KACDzG,EAAOyG,GAAS7M,KAAK,MAE3BgG,GAAS6G,EAAQ7G,eAEhBA,GAAOnG,UAIFgN,EAAQ,KACT7G,EAAO,GAETmN,KAAKE,QAAQ,SAACrT,KACZiW,aAAajW,EAAM6M,MAPnBsG,kCAyBNtG,MAASsJ,qEACF/P,EAAOyG,GAAS,KAIrBjH,EAAeiH,SAEXsG,UAGJgD,GAAOtJ,EAAQuJ,WAAY,KACzB,GAAIxW,GAAIuT,KAAKtT,OAAS,EAAGD,GAAK,EAAGA,MAC5BqW,aAAa9C,KAAKvT,GAAIiN,EAAQuJ,kBAGjCjD,YAGFA,MAAKE,QAAQ,SAACrT,KACXkW,YAAYlW,gCAmBrBqG,OACI8M,KAAKtT,cACD,KAGHG,GAAOmT,KAAK,UAEhBnT,EAAKqW,SACFrW,EAAKsW,iBACLtW,EAAKuW,uBACLvW,EAAKwW,oBACLxW,EAAKyW,mBACLzW,EAAK0W,yBAGWrQ,qCAafrG,GAAOmT,KAAK,SAEXnT,GACHA,EAAK4E,SAAS3B,kBACd8D,wCAaGoM,MAAKY,QAAQnQ,8BAyCnBqR,EAAO0B,GACJxU,EAAS8S,aACAA,EAAQ0B,OAGfC,MACAC,cAEQ5B,EAAO,SAAC0B,EAAU1B,KACjBA,EAAMzR,MA70BK,aA60ByB,SAACyR,IAC/C2B,EAAU3B,GAAS2B,EAAU3B,QAAcjL,KAAK2M,YAIhDtD,QAAQ,SAACrT,KACE4W,EAAW,SAACE,EAAW7B,KACtB6B,EAAW,SAACH,KAClBI,iBAAiB9B,EAAO0B,GAAU,IACtCE,EAAa5B,GAAS4B,EAAa5B,QAAcjL,KAAK,aAChDgN,oBAAoB/B,EAAO0B,WAMjC,SAA8B1B,GAC/BxU,UAAUZ,SACCY,UAAW,SAACwU,KACVA,EAAMzR,MAh2BC,aAg2B6B,SAACyR,MAC1CgC,GAAkBJ,EAAa5B,EAEjCgC,OACWA,EAAiB,SAACC,SAAmBA,aAE3CL,GAAa5B,UAKZ4B,EAAc,SAACI,EAAiBhC,KAC/BgC,EAAiB,SAACC,SAAmBA,aAE3CL,GAAa5B,6CAanB9B,MAAKY,QAAQhQ,wCAaboP,MAAKY,QAAQ9P,gCAiBjBV,EAAU9D,SACTgB,WAAUZ,QAAU,GAAKsC,EAASoB,GAC7B4P,KAAK,GAAKA,KAAK,GAAG5P,OAAYwD,IAGnCtG,UAAUZ,QAAU,YACR0D,EAAW9D,IAGpB0T,KAAKE,QAAQ,SAACrT,KACLuD,EAAU,SAAC9D,EAAO+E,KACzBA,GAAQ/E,8CAgBV0T,MAAKE,QAAQtN,8DAcboN,MAAKE,QAAQ,SAACrT,OACK,SAACoD,SACRsB,EAAUtB,EAAMpD,GAAvB8L,IAAAA,EAEJA,KACGqL,kBAAkBrL,EAAI1I,KAEtBgU,gBAAgBhU,mEAiBpB+P,MAAKE,QAAQ,SAACrT,MACbsT,GAAOtT,EAAKuT,cAEM,SAACC,SAAQF,GAAKvN,OAAOyN,iEAexCL,MAAKE,QAAQ,SAACrT,OACK,SAACsD,KAClByM,MAAM8E,eAAejS,EAAaU,wCAmBrCuJ,KACIzG,EAAOyG,MAEXwK,GAAQlE,KAAKnT,KAAK,GAClBgG,EAASqR,EAAMrR,aAEhBA,EAAOnG,aACHsT,SAGLnT,GAAOgG,EACPkN,EAAS,OACP8C,EAAOqB,EAAMrB,OAAO,GACpBsB,EAAOD,EAAMC,OAAO,EAEtBtB,MACKA,IACE,gBACAsB,MACFA,IACE,iBAGLvR,WAEEmN,GAAQlT,wCAcTmT,MAAKE,QAAQnN,yCAIb,IAAIjB,GAAKsS,2EAAYC,MAAMrE,KAAM1S,yCAerCgE,SACEhE,WAAUZ,OAIRsT,KAAKE,QAAQ,SAACrT,KACdyX,YAAchT,IAJZ0O,KAAK3O,KAAK,kDAsBVpB,EAAMsU,yBACRvE,MAAKE,QAAQ,SAACrT,KACZ,GAAIiF,GAAKjF,IAEZ2X,EAAU9X,OAAS,GAAKG,EAAKmQ,QAAQ/M,GAAQsU,KAC1CtU,KAAKA,EAAM,MAEXiG,WAAWjG,yCAmBVoQ,EAAKkE,yBACRvE,MAAKE,QAAQ,SAACrT,MACXuT,GAAcvT,EAAduT,YAEEqE,OAAOpE,EAAKqE,EAAUhY,OAAS,GAAK0T,EAAUY,SAASX,GAAOkE,YA7lC3D3F,MAkmCnBlQ,GAAeoD,GAAM,QAEjBlD,IAAUA,GAAO+V,YACF7S,SACdlD,GAAO+V,8BAEG/F,UtBlrCf,IAAMtK,IAAc,IOIhBuD,UCaE2B,GAAsB,4BCjBpBgC,MAAAA,ccMFtH,yBAeQiC,4BAER9H,GASE8H,EATF9H,KACA/B,EAQE6J,EARF7J,MACA8I,EAOEe,EAPFf,QACAvI,EAMEsJ,EANFtJ,KACA2G,EAKE2C,EALF3C,KACA6B,EAIEc,EAJFd,QACAC,EAGEa,EAHFb,YACAC,EAEEY,EAFFZ,YACAC,EACEW,EADFX,eAEI4B,KACAnC,OAEiB+K,wBAGX1T,oBAEG8I,wFAMA,WACD,SAACF,SAKL0K,EAAK5K,GAHPyB,IAAAA,UACAnK,IAAAA,MACAsY,IAAAA,OAEIC,EAAepO,EACjBnK,EACAiJ,EAAYP,GAAGS,SAASmP,SAExB1P,MACO2B,KAAK3B,GAGT2P,UAED,SAACC,KACF9P,GAAG+P,WAAY,KAEL3N,SAGR4N,eACL,MAAOpP,WACCC,2BAA4BxH,mBAAuBuH,IAGxDkP,GAAkBxP,KACLA,EAAYN,GAAGf,mBAWlCT,KAAOA,OAOP6B,QAAUA,OAOVC,YAAcA,OAOdC,YAAcA,OAOdC,eAAiBA,OAOjB3I,KAAOA,OAOPsL,KAAOtL,EAAK,KAELmI,GAAGf,OAAO4C,KAAKmJ,gFAlHdiF,+CACNA,GAASC,OAAOhJ,GAAW8D,8HA+H3B5T,SACA4T,MAAKhL,GAAGS,SAASrJ,WA5ItB8H,IACGuB,UAAW,EA+IpB/G,EAAewF,GAAO,QCrEtB,IAAMiR,OACAC,MACAC,GAAiB,4CACjBC,GAAkB,8BAClBC,GAA2B,UAC3BC,GAA8B,aAC9BC,GAAY,GAAI3T,IAChB4T,MACAC,MAqCA9M,yBAqUQ1C,4BAER9H,GAUE8H,EAVF9H,KACMuX,EASJzP,EATF3C,KACA2F,EAQEhD,EARFgD,WACAH,EAOE7C,EAPF6C,SACAnG,EAMEsD,EANFtD,OACAwF,EAKElC,EALFkC,WACA/C,EAIEa,EAJFb,YACAC,EAGEY,EAHFZ,YACAC,EAEEW,EAFFX,eACA8C,EACEnC,EADFmC,UAEIlB,KACA6B,EAAcgG,GAASe,MAAM/G,YAC7B4M,KACA5R,KACAkG,EAAgBtH,YAAkBgG,KAEjBmH,QAOlBA,mHA0BQ,GAAIlO,OACTmH,eACUD,WACJ6M,qDAIC,cACC,WACF,SAACC,EAAMC,EAAUC,EAAaC,EAAcC,EAAUC,OACzDrX,EAAWgX,SACPA,OAGQG,MACJC,KAEPnP,GAAkB,YAAT1I,IAAuB6X,GAAaC,GAC9CA,MAAkBnR,GAAG+B,UAEGiP,EAAcA,EAAYhR,MAA/CoC,IAAAA,iBACFgP,IAAiBL,QAEN,SAAXtQ,QACA4Q,SAEAD,QACI1O,UAAW,KACXC,sBAIGmO,EAAK/O,GACd,MAAOnB,QACH0Q,WAAaR,IACbS,SAAWT,EAAKS,WAChB5K,QAEA7M,EAAWmK,EAAYuN,mBAEXA,YAAY5Q,GACxB,MAAO6Q,WACC5Q,MAAM,uCAAwC4Q,OAKxDL,EAAc,IACVM,QAEOjP,GAAME,YAAa,SAAC1C,MACzBC,GAAU,cACRyR,GAAYlR,GAEdkR,KAAcN,GAAWL,EAAYhR,GAAG+P,aACjC4B,EAAWN,IAGlBO,0CAME1P,SAAW,aACJwP,EAAe,SAACE,MAEzB1R,GAEE0R,EAFF1R,QACAD,EACE2R,EADF3R,WAGcmC,EAAkBwP,KAClB3R,EAAUC,QAIhB2B,KAAK+P,KACF/P,KAAK+P,KACb/P,KAAK3B,QAGVwC,UAAW,KACXC,qBAGD0O,cAKH,SAACvB,KACF9P,GAAG+P,WAAY,KAEL3N,KAEFyO,EAAgBpK,MAChBxH,EAAQwH,UAGduJ,eACL,MAAOpP,WACCC,2BAA4BxH,mBAAuBuH,IAGxDkP,GAAkB3K,KACdnF,GAAG6R,cAAcC,EAAK9R,GAAGiF,UAG7B6K,GAAkBxP,KACLA,EAAYN,GAAGgE,cAG5BhE,GAAGiF,QAAQrH,wBAEH,SAACmU,QACT/R,GAAGiF,QAAU8M,EAEdD,EAAK9R,GAAGmG,iBAEH6L,iBACL,MAAOpR,WACCC,2BAA4BxH,yBAA6BuH,gBAI3D,SAACqR,EAAcC,MACnBC,GAAaL,EAAK9R,GAAGiF,QACrB1N,EAAQ4a,EAAWra,QAAQma,EAAa,GAAGlW,iBAAmB,EAChEgW,WAEU,IAAVxa,EACW0a,EAAavW,IAAIyW,GAEjBA,EACVrZ,MAAM,EAAGvB,GACTmE,IAAIuW,EAAcE,EAAWrZ,MAAMvB,MAGnCyI,GAAGoS,cAAcL,GAElB5M,IAAkB+M,KACblS,GAAGsF,WAAW2M,EAAcC,gBAG1B,SAACG,EAAeC,MACrBH,GAAaL,EAAK9R,GAAGiF,QACrB1N,EAAQ4a,EAAWra,QAAQua,EAAc,IACzCE,EAAaJ,EAAWra,QAAQwa,EAAM,IAAM,EAC9CP,WAEe,IAAfQ,EACWF,EAAc3W,IACzByW,EAAWrZ,MAAMyZ,EAAYhb,GAC7B4a,EAAWrZ,MAAMvB,EAAQ8a,EAAc3a,SAEhCH,EAAQgb,EACJJ,EACVrZ,MAAM,EAAGyZ,GACT7W,IACC2W,EACAF,EAAWrZ,MAAMyZ,EAAYhb,GAC7B4a,EAAWrZ,MAAMvB,EAAQ8a,EAAc3a,SAG9Bya,EACVrZ,MAAM,EAAGvB,GACTmE,IACCyW,EAAWrZ,MAAMvB,EAAQ8a,EAAc3a,OAAQ6a,GAC/CF,EACAF,EAAWrZ,MAAMyZ,MAIlBvS,GAAGoS,cAAcL,GAElB5M,GAAiBoN,KACZvS,GAAGwS,YAAYH,EAAeC,kBAG1B,SAACG,KACTzS,GAAGoS,cAAcN,EAAK9R,GAAGiF,QAAQyN,OAAO,SAAC7a,UACT,IAAnC4a,EAAgB3a,QAAQD,MAGtBsN,KACKnF,GAAG6R,cAAcY,sBAGT,SAACE,EAAiBC,MAC3BtP,GAAcwO,EAAK9R,GAAnBsD,UACJgP,EAAQ7B,MAERnN,YAAqBO,KACfP,EAAUtD,GAAGoF,cAAcuN,EAAiBC,OAC/C,IAAItP,IACDA,IACQ+B,YAAY/B,GAExB6B,IACEyN,IACK5S,GAAGwS,YAAYG,EAAiBL,KAEhCtS,GAAGsF,WAAWqN,GAAiB,QAGrC,IAAIxN,EAAe,IAChB7B,GAAczF,EAAOmC,GAArBsD,aAEJA,EAAW,IACT4O,SAEA5O,aAAqBO,MACfP,EAAUtD,GAAGoF,cAAcuN,EAAiBC,MACrC,MAEPtP,KACO,IACC+B,YAAY/B,IAG1BsP,IACK5S,GAAGwS,YAAYG,EAAiBL,KAEhCtS,GAAGsF,WAAWqN,EAAiBT,UAGhCrU,EAAOmC,GAAGuF,kBAAkBoN,EAAiBC,UAGvCpN,KAAKnC,GAAY,SAG/BuP,KACG5S,GAAGwS,YAAYG,EAAiBL,KAEhCtS,GAAGsF,WAAWqN,GAAiB,GAG/BL,iBAEM,SAACK,EAAiBC,MACvBtP,GAAcwO,EAAK9R,GAAnBsD,UACJgP,EAAQ7B,GACRoC,eAEAf,GAAK9R,GAAGiF,QAAQvN,UACVoa,EAAK9R,GAAGiF,QAAQpN,MAAM,MACb,IACDwN,YAAYiN,IACnBhP,YAAqBO,KACtBP,EAAUtD,GAAGoF,cAAcuN,EAAiBC,GAC3CtP,KACDA,KACS,IACD+B,YAAY/B,IACnB6B,IACDtH,EAAOmC,GAAGuF,kBAAkBoN,EAAiBC,KAErCpN,KAAKnC,GAAY,GAG/B8B,GAAiB0N,IACfD,IACK5S,GAAGwS,YAAYG,EAAiBL,KAEhCtS,GAAGsF,WAAWqN,IAIlBL,QAKCrO,EAAY6O,cAAe,SAACxb,EAAOa,KAC1CA,GAAYb,MAEN2M,EAAYsD,MAAO,SAACpP,KAC1BA,GAAY2Z,EAAK3Z,QAGlBsG,GAAarC,GAAO,MACtBoC,EAAOpC,GAAO6H,EAAY8O,aAAe,MACzCnO,WAEUgM,EAAc,SAACtZ,EAAOqH,MAC5BkG,GAAUnF,GAAa7C,KAAK8B,GAC5BqU,EAAYnO,GAAWD,EACzBxI,GAAOoC,GACPA,OAEGwU,EAEHnO,EAAS,IACLoO,GAAW1S,EAAYP,GAAGS,SAASnJ,EAAO,SAACA,KACjC0b,EAAWnU,KAClBmU,EAAWrT,EAAkBrI,MACtBkH,EAAMC,iBAGX,EAEJrG,EAAO4a,EAAWrT,EAAkBsT,OAGvCC,GAAuB,eAAT7Z,EACd4X,EAAeiC,GAAuB,UAARvU,KAEzB,EAEE,WAATtF,GAA6B,QAARsF,MACf4B,EAAYP,GAAGS,SAASnJ,EAAO,SAACA,KAC5BqH,GAAOrH,IACHkH,EAAMC,MACbwS,EAAciC,GAAuC,YAAxB5S,EAAYN,GAAG3G,SAG7CsF,GAAOrH,MAGI0T,WAMfvM,UAOGrC,GACPmE,EACIA,EAAYyB,QACZ,UAIMxD,EAAMC,GAEhB6B,KACUN,GAAGgE,SAASnC,KAAKmJ,0DA/oBdpK,WACTC,kCAAkCD,EAAI2Q,UAAY3Q,EAAI0Q,sCAAsC1Q,EAAI+F,MAAM3G,GAAG3G,WAAYuH,+CASpGuS,aACdtR,KAAKsR,GAET,aACWhD,GAAYgD,gDASLA,aACdtR,KAAKsR,GAET,aACW/C,GAAY+C,kCAYnB9Z,EAAMkN,iBACbzM,EAAWyM,KAAcF,GAAaxC,EAAO0C,GAAW,SACpDtC,EAAcsC,6BAKNpF,8EACJA,oBACYA,uBALG0C,KAChBgF,SAAW5E,EAAY4E,iBAS7B/O,EAAWyM,IAAa/I,GAAQ+I,GAAW,iJACrB1C,KAChBgF,wBAEEtC,WAKRzM,EAAWyM,IAAaA,EAASrO,MAAQqO,EAASjP,MAAO,iJACnCuM,KAChBgF,SAAWtC,UAIjBF,GAAaxC,EAAO0C,uBACf6M,kIAAmI/Z,yBAKzIkR,GAAWlR,uBACL+Z,aAAc/Z,uFAKnBgX,GAAexT,KAAKxD,uBACf+Z,cAAe/Z,kFAKpBN,GAAeiS,KAAM,kBACnBpH,QAAUxH,GAAO6N,GAASe,MAAMpH,UAGlC7K,EAAeiS,KAAM,wBACnB8H,kBAGF/Z,EAAeiS,KAAM,sBACnB+H,YAAc3W,GAAO,aAIf+T,GAAWD,OAAO,SAACjJ,EAAakM,MACnCE,GAAqBF,EAAKlM,EAAa5N,WAEtCgN,IAAaxC,EAAOwP,GACvBA,EACApM,GACHV,GACH,MAAO3F,WACCC,MAAM,gDAAiDD,GAG7DpD,GAAQ+I,EAASsC,cACVA,wBAEAtC,EAASsC,iBAOhBtC,EAASsC,SAFX3Q,IAAAA,KACAZ,IAAAA,eAGOwO,MAAQxO,IACRiQ,MAAQrP,IACR0L,QAAU7K,EAAewN,EAAU,WACxCA,EAAS3C,QACTxH,GAAO4O,KAAKpH,WACPG,QAAUhL,EAAewN,EAAU,WACxCA,EAASxC,QACT3H,GAAO4O,KAAKjH,SAEZhL,EAAewN,EAAU,mBAClBA,EAASwM,YAAa,WAG5BnP,QAAQvK,GAAQkN,EAEdA,8BASElN,SACF2R,MAAKpH,QAAQvK,oCASNA,SACP2R,MAAKjH,QAAQ1K,gCAUV+N,kFAC8CA,iCAW7C/N,EAAMkN,iBACbzM,EAAWyM,KAAcF,GAAanH,GAAOqH,GAAW,IACpD5F,GAAc4F,6KAGN7F,EAAUX,eACFW,EAAUX,EAAUiL,aAFjB9L,QAOtBmH,GAAanH,GAAOqH,uBACf6M,aAAc/Z,oHAKpBmR,GAAWnR,uBACL+Z,aAAc/Z,uFAKnBiX,GAAgBzT,KAAKxD,uBAChB+Z,cAAe/Z,kFAKpBN,GAAeiS,KAAM,kBACnBjH,QAAU3H,GAAO6N,GAASe,MAAMjH,gBAI1BqM,GAAWF,OAAO,SAACjJ,EAAakM,MACnCE,GAAqBF,EAAKlM,EAAa5N,WAEtCgN,IAAanH,GAAOmU,GACvBA,EACApM,GACHV,GACH,MAAO3F,WACCC,MAAM,gDAAiDD,YAGxDxB,OAASN,EAAoBzF,QAEjC0K,QAAQ1K,GAAQkN,EAEdA,4DA4BM0J,+CACNA,GAASC,OAAOnJ,GAAWiE,gOAsb3BA,MAAKhL,GAAGsT,OAAOxa,uDAUfkS,MAAKhL,GAAGf,OAAOnG,oDAUfkS,MAAKhL,GAAGuT,4DAURvI,MAAKhL,GAAG2D,0CAURqH,MAAKhL,GAAGiF,QAAQnM,uDAUhBkS,MAAKhL,GAAGM,0DAUR0K,MAAKhL,GAAGqD,WAAWvK,uDAUnBkS,MAAKhL,GAAGO,8DAURyK,MAAKhL,GAAGQ,gDAYRsQ,EAAM1Z,MAAUiB,0DAAS2S,WACzBA,MAAKhL,GAAGS,SAASqQ,EAAM1Z,EAAUiB,4CAIjC2S,MAAKhL,GAAG3G,uEAoCRnB,4CACDsb,GAAalb,UAAUA,UAAUZ,OAAS,OAE3CoC,EAAW0Z,uBACNJ,sDAAuDpI,KAAKhL,GAAG3G,mBAKnE6G,GAAU,mBAIS,IAArB5H,UAAUZ,iBACMsT,KAAM9K,MACR8K,KAAM9K,MACH8K,KAAM9K,cAOd5H,UAAW,SAACH,MACnBA,IAAaqb,MAMA,YAFFrb,SAGNuO,MAAwBxG,MAGhB,SAAb/H,QACK2O,MAAsB5G,MAGd,YAAb/H,QACKyO,MAAyB1G,MAG9BqQ,GAAyB1T,KAAK1E,GAAW,MAChCA,EAASgC,QAAQoW,GAA0B,KAEjDkD,EAAKzT,GAAGxB,KAAKrG,wBAIb6H,GAAGxB,KAAKrG,GAAU8H,SAASgD,KAAKpB,KAAK3B,MAKxCsQ,GAA4B3T,KAAK1E,GAAW,MACnCA,EAASgC,QAAQqW,GAA6B,KAEpDiD,EAAKzT,GAAGgC,QAAQ7J,aAIb8H,GAAawT,EAAKzT,GAAGgC,QAAQ7J,GAA7B8H,kBAECgD,KAAKpB,KAAK3B,UACdF,GAAGoC,iBAAiBP;wDAQtB4R,EAAKzT,GAAG0F,OAAOvN,MAIf6H,GAAG0F,OAAOvN,GAAU8H,SAASgD,KAAKpB,KAAK3B,kBAz8B5C2D,IAOGD,QAAUxH,GAAOmO,IAPpB1G,GAeGE,QAAU3H,GAAOoO,IAfpB3G,GAuBG0D,MAAQmJ,GAvBX7M,GA+BGiC,MAAQ6K,GA/BX9M,GAuCGkP,YAAc,KAvCjBlP,GA+CGiP,cAAgB,KA/CnBjP,GAuDGgF,4BAy5BTnP,EAAemK,GAAO,SACtBsG,GAAStG,GAAMhK,UAAW,SC3kCpB6Z,wLAqBE1I,KAAKhL,OAVPO,YACEP,GACe2T,IAAbpT,YACgBqT,IAAhBpT,eACcwD,IAAduP,aAGUM,IAAdN,aACA/S,IAAAA,eACA2D,IAAAA,WAEE2P,aAEAD,EAAYnc,eAIXqc,YAAcJ,OACdK,eAAiBJ,EAElBzP,EAAY,QACN3M,EAAYwM,EAAU,qBAAG3K,kBAA8C8K,KAEnE,QACNtG,GAASmN,MAIVnN,EAASA,EAAOmC,GAAGO,gBACfuT,EAAQtc,EAAYqG,EAAOmC,GAAGiU,QAAS,qBAAGjU,GAAMmE,aAA8CA,MAC9D,YAAlCtG,EAAOmC,GAAGO,YAAYP,GAAG3G,OAG1Bya,SACGC,YAAclW,OACdmW,eAAiBxT,IAChBlJ,gBACMwc,EAAMxc,MAAM0I,GAAGuT,oBAK1BtI,MAAQ6I,GAASA,EAAMxc,MAAM0M,SAAStM,OACvCoc,EAAMxc,MAAM0M,SACZ,eAECiH,MAAQjH,SAzDEH,GAAf6P,IACG7K,iOA6DT0B,GAAW,WAAamJ,EChExB,IAAM7K,uLAQAqL,uIAAcrQ,GAAdqQ,IACGrL,SAAWA,GADdqL,GAEG3M,MAAQsB,GAAS3Q,KAFpBgc,GAGGpO,MAAQ+C,GAASvR,gBCJpB6c,gEAMN5J,IAAW,qCACGpJ,8EACJA,uBAGJ3C,SACEwH,KAAMD,aAAW,cACjBxO,MAAO0O,aAAY,oBAIhB2E,EAAK5K,uBAEL4K,EAAKpM,KAAK4V,SAAOxV,4FAOnB6B,SAAS0T,GAAWnJ,KAAKqJ,gBACzBA,mBArBkCxQ,kCAwBzCwQ,UAAY,iBAWNC,EAAKtU,GATPuT,IAAAA,aACAgB,IAAAA,YACAhU,IAAAA,YACA8C,IAAAA,WACA7C,IAAAA,eACAuB,IAAAA,MACAgE,IAAAA,SACAE,IAAAA,UACAuO,IAAAA,IAGQC,IAARjW,KAAQiW,OAEJC,KACAC,KACAC,OAIFN,EAAK9V,KAFPqW,IAAAA,IACAC,IAAAA,SAEIC,EAAQvX,GAAQqX,GAChBG,EAAUD,EACZpd,EACAsB,CAEA8b,IAASjb,EAAW2a,OAChBI,EACH/b,QACAmc,KAAKR,IAGN3a,EAAWgb,QACDA,IAGVtX,GAAQsX,MACGA,EAAU,SAACpC,KAChBmC,EAAInC,OAAOA,OAIbmC,EAAK,SAAC7O,EAAMzO,KACZwO,GAAYC,IACZC,GAAa1O,KAEb6c,GAAM7T,EAAYP,GAAGS,SAAS+T,EAAK,KAAM,MAAM,GAAO,OAE7CJ,IAAQO,EAAeP,IAAQ,GAAK,IAC3C7c,GAAS6c,MAGbrO,GAAY,OACZE,GAAa,OAELsO,EAAa,SAACW,EAAOd,OAC5BO,EAAeP,iBACLc,EAAOtX,MAKTsX,EAAMnd,OAAO4c,EAAeP,IAAOxW,SAG9C0F,YAEIuR,EAAK,SAAC7O,EAAMzO,MACZ6c,GAAMQ,EAAQrd,GAChBoP,QAEA4N,GAAYH,IAAQG,EAAYH,GAAK1c,UAC/B6c,EAAYH,GAAKe,UACnBnV,GAAG+B,MAAMkE,GAAa1O,IACtByI,GAAG+B,MAAMgE,GAAYC,EAEvBW,EAAM3G,GAAGsD,YAAcA,GAAaA,KAC5BtD,GAAGoF,cAAcuB,EAAM3G,GAAGiF,SAAS,MAGvC/B,qDAME,mBACIqQ,eAECW,qFAUhBQ,EAAeN,GAAOM,EAAeN,QAAYvS,KAAK8E,KACjD3G,GAAGsD,UAAYA,IACTqD,MAGT3G,GAAGuU,YAAcG,OC1I1B,IAAMP,oCAEN5J,IAAW,uMAEClH,EAAe2H,KAAKhL,GAApBqD,aAKJ2H,KAAKxM,KAHP4E,IAAAA,YACA7C,IAAAA,YACAC,IAAAA,oBAGGR,GAAGS,SAAS0T,GAAW,iBAOtBG,EAAKtU,GALPgE,IAAAA,SACA/E,IAAAA,OACApB,IAAAA,OACAuE,IAAAA,iBACA6C,IAAAA,QAEM3N,EAAUgd,EAAK9V,KAAflH,QAEK0M,EAAUyC,MACVxH,EAAQwH,MACb7I,SAEJC,YAAkBgG,OACb7D,GAAG6R,cAAc5M,KAGrBjF,GAAGgE,cACHhE,GAAGf,YACHe,GAAGoC,iBAAmBA,EAAiBsQ,OAAO,eAAGzS,KAAAA,SAAUC,IAAAA,aAAS+Q,oBAE9D,IAGOhR,EAAUC,OAEvBF,GAAGiF,QAAU,GAAInI,OAElBwG,YAEShM,MAAa,SAAC4N,KACbhC,SACJgC,oGAUT8F,MAAM,UApDsCnH,aCRnD0G,IAIW,sCASGpJ,8EACJA,MAKFyJ,EAAK5K,GAFPO,IAAAA,YACAgT,IAAAA,aAEEhc,EAAQ6d,EAAAA,EACNpS,EAASuQ,EAAazJ,IAAI,SAAC5E,EAAOzN,MAEpC4B,GAGE6L,EAHF7L,OAGE6L,EAFFlK,MAAAA,kBACAgJ,EACEkB,EADFlB,SAEEqR,EAAOra,EAAMsa,YAEJ,WAATjc,IAAqBgc,GAChB9U,EAAYP,GAAGS,SAAS4U,EAAM,SAAC3U,QAC9BA,IAAasC,EAAOvL,OAInBA,KAAOiJ,IAEVjJ,EAAIF,QAIJE,EAAIF,WACEE,SACHwT,MAAQjH,MAKT8P,GAAQtc,EAAYwL,EAAQyK,QAE9BqG,MACMA,EAAMtb,MACTyS,MAAQsI,EAAaO,EAAMtb,KAAKwL,aAE7BoR,EAAAA,IACHnK,MAAQ,WAOfoK,GAAQ9d,IAAU6d,EAAAA,MACZ3d,IACHwT,MAAQjH,KAGNqR,+BA/DwBxR,OAC9BgF,sNfDHsL,mCAEN5J,IAAW,0CAWGpJ,8EACJA,MAHR5J,MAAQ6d,EAAAA,UAMJpV,OACEuT,aAAAA,kBACAhT,IAAAA,YAEF/B,IAAAA,KACQlH,IAARkH,KAAQlH,eAGL0L,OAASuQ,EAAazJ,IAAI,SAAC5E,EAAOzN,MAEnC4B,GAGE6L,EAHF7L,OAGE6L,EAFFlK,MAAAA,kBACAgJ,EACEkB,EADFlB,SAEEuR,EAAMva,EAAMsa,IAAMjb,WAET,cAAThB,EACI/B,EAEAiJ,EAAYP,GAAGS,SAAS8U,EAAK,SAAC7U,QAC9B8G,GAAOoD,EAAK5H,OAAOvL,GAAGH,MAAOoJ,OAI5BsC,OAAOvL,GAAGH,MAAQoJ,EAEnBjJ,EAAImT,EAAKrT,YAITE,EAAImT,EAAKrT,eACNA,MAAQE,SACRwT,MAAQjH,MAKT8P,GAAQtc,EAAYoT,EAAK5H,OAAQ,kBACrCwE,MADwClQ,MAC1BkH,EAAKlH,QAGjBwc,MACGvc,MAAQuc,EAAMtb,MACdyS,MAAQ6I,EAAMxc,MAAM0M,aAEpBzM,MAAQ6d,EAAAA,IACRnK,MAAQ,WAKfzD,GAAO+N,EAAKje,IAAUsT,EAAKrT,QAAU6d,EAAAA,MAClC7d,MAAQE,IACRwT,MAAQjH,4BAMNuR,mFAMN9U,SAAS0T,GAAW,cAEdzT,GACL4T,EAAK9V,KADPlH,QAGGC,MAAQ6d,EAAAA,IAEAd,EAAKtR,OAAQ,WAA4BvL,MAAzB4B,KAAAA,KAAM/B,IAAAA,MAAO0M,IAAAA,QAKpCwD,IAJiB,cAATnO,EACRqH,EACApJ,EAEYoJ,IAAa4T,EAAK/c,QAAU6d,EAAAA,MACrC7d,MAAQE,IACRwT,MAAQjH,KAIbsQ,EAAK/c,QAAU6d,EAAAA,MACZnK,MAAQ,eAnG0BpH,OACtCgF,4MgBHT2B,GAAW,6NACTxP,4EAEY0F,MAER7I,GAGEmT,KAHFnT,KACA2G,EAEEwM,KAFFxM,KACAxD,EACEgQ,KADFhQ,KAGEwD,OACS/F,EAAkB+F,EAAM,SAACxD,EAAOC,KACnCA,GAAQyF,OAIJ1F,EAAO,SAAC1D,EAAO+E,GACrBA,IAAQqE,MACPQ,WAAW7E,OAGfpB,KAAKyF,QAEL1F,MAAQ0F,4CAKX7I,GAEEmT,KAFFnT,KACAmD,EACEgQ,KADFhQ,QAGGkG,WAAWmO,MAAMxX,EAAM6G,GAAK1D,WAhCMkE,ICA3CsL,GAAW,6NACTgL,IAAMnb,qEAEM/C,QACLke,MAEA1b,EAAWxC,KAIZ0T,KAAKxM,UACFgX,IAAMxK,KAAKnT,KAAK4d,GAAGzK,KAAKxM,KAAKwL,KAAK,KAAM1S,SAExCke,IAAMnb,UAEHwG,MAAM,iJAKX2U,aApBkCtW,GCK3CsL,IAAW,8NACTkL,8EAEYhV,MAER7I,GAGEmT,KAHFnT,KACA2G,EAEEwM,KAFFxM,KACAkX,EACE1K,KADF0K,QAEIC,IAEFnX,OACSkC,EACPlC,MAIFxE,EAAS0G,OACAA,EAASrF,MApBA,QAuBlBmC,GAAQkD,MACGgV,EAAS,SAACrK,IACU,IAA3B3K,EAAS5I,QAAQuT,MACdrN,YAAYqN,OAGR3K,EAAU,SAAC2K,GAClBrR,EAASqR,OACAxJ,KAAKwJ,KACXjO,SAASiO,UAILqK,EAAS,SAACrK,GAChB3K,GAAaA,EAAS2K,MACpBrN,YAAYqN,OAGP3K,EAAU,SAAC6U,EAAKlK,GACxBkK,MACS1T,KAAKwJ,KACXjO,SAASiO,YAKfqK,QAAUC,4CAKb9d,GAEEmT,KAFFnT,KACA6d,EACE1K,KADF0K,UAGG1X,YAAYqR,MAAMxX,EAAM6d,UAxDYxW,aCT7CsL,IAKW,wCAGGrJ,8EACJA,IAGJ3C,IAAAA,KACAgC,IAAAA,eACA3I,IAAAA,KAEEkK,EAAQvB,EACRlJ,EAAQsT,EAAKnK,iBAEbjC,OACMlH,YAAiBuM,IACrBvM,EACAkJ,IACIhC,EAAK,IAGX1E,EAAWxC,KACPO,GACGmC,EAAS1C,OACZA,GAASO,uBAxBsBqH,OAClCuB,UAAW,SCHdmV,6KACQte,MACFO,GAASmT,KAATnT,IAEJP,KACG4F,SAEAa,mDAKFlG,KAAKkG,cAZMmB,GAgBpBsL,IAAW,UAAYoL,YCnBvBpL,IAKW,wCAGGrJ,8EACJA,IAGJ3C,IAAAA,KACAgC,IAAAA,eACA2C,IAAAA,KAEEpB,EAAQvB,EACRlJ,EAAQsT,EAAKnK,iBAEbjC,OACMlH,YAAiBuM,IACrBvM,EACAkJ,IACIhC,EAAK,IAGX1E,EAAWxC,KACP6L,GACGnJ,EAAS1C,OACZA,GAAS6L,uBAxBsBjE,OAClCuB,UAAW,eCNpB+J,IAIW,sCAGGrJ,8EACJA,UAEFyJ,GAAKpM,OACFgX,IAAM5K,EAAK/S,KAAK4d,GAAG7K,EAAKpM,KAAKwL,KAAK,KAAM,aACtCvJ,gBAGF+U,IAAMnb,UAEHwG,MAAM,+JAKX2U,aAlB8BtW,OAC9BuB,UAAW,MCFpB+J,GAAW,mLACGlT,MACFO,GAASmT,KAATnT,IAEJP,KACGyG,SAEAb,mDAKFrF,KAAKkG,cAZ6BmB,GtBI3C,IACM2I,IAA4B,SAElC2C,IAAW,8NACTrP,0EAEYuF,EAAUX,MAElBlI,GAGEmT,KAHFnT,KACA2G,EAEEwM,KAFFxM,KACArD,EACE6P,KADF7P,GAGEqD,OACS/F,EAAkB+F,EAAM,SAACrD,EAAKkB,KACnCA,GAAQqE,KAIZ1G,EAAS0G,OACAxJ,EACTwJ,EACGrF,MAtBwB,WAuBxBqX,OAAOjF,SACP3D,IAAInC,IACPzM,OAIUC,EAAK,SAAC7D,EAAO+E,GACpBqE,EAASrE,MACPoQ,UAAUpQ,OAGdlB,IAAIuF,QAEJvF,IAAMuF,4CAKT7I,GAEEmT,KAFFnT,KACAsD,EACE6P,KADF7P,MAGGsR,UAAU4C,MAAMxX,EAAM6G,GAAKvD,WA1CS+D,aCV7CsL,IAQW,yCAGGrJ,8EACJA,IAGJ3C,IAAAA,KACAgC,IAAAA,eACA3I,IAAAA,KAEIwB,EAAOxB,EAAKwB,OACZ4H,EAAOpJ,EAAKwE,KAAK,QACjB/E,EAAQsT,EAAKnK,WACfoV,EAAoB,OAEnBxZ,KAAO0L,GAAQ1O,EAAM4H,EAAMpJ,KAC3BwB,KAAOA,IACP4H,KAAOA,IACP3J,MAAQA,IACR+Q,QAAUxQ,EAAKqE,KAAK,YACpB6F,MAAQvB,EAEThC,MACGuD,MAAQzK,YAAiBuM,IAC1BvM,EACAkJ,IACClJ,MAAQkH,EAAK,IAGf1E,EAAW8Q,EAAKtT,WACCsT,EAAK7I,MAAM/B,GAAGS,SAAS,SAACsB,SAAUA,GAAM6I,EAAKtT,QAAQ,SAACoJ,GACpEkK,EAAKiF,eAAiBnP,MACnBmP,aAAenP,IACfoV,QAAQpV,YAKbqV,GAAmBnL,EAAK7C,QAAQ8N,GAAmB,GACnDG,EAA0Bjc,EAAM8b,GAChCI,EAAsB,aAAThV,EACbiV,EAAc,aACbrG,aAAejF,EAAK7C,QAAQ6C,EAAKiF,cAAc,KAC/CqG,qBAGHF,IAA2BC,KACxBpG,aAAekG,IACfG,eAEAF,GAA2BC,KACzBH,QAAQD,OAGVhG,aAAegG,IACfC,QAAQD,MAGVM,gBAAkBte,EAAK4d,GAAG/M,GAAgBrP,EAAM4H,GAAOiV,KACvDE,gBAAkBve,EAAKkF,QAAQ,QAAQ0Y,GAAG,QAAS,sBAC3CS,EAAa,mEAMxBnU,GAGEiJ,KAHFjJ,MACAzK,EAEE0T,KAFF1T,MACAuY,EACE7E,KADF6E,YAGE/V,GAAWxC,KACPuY,KAEAvY,GAASuY,kCAIXvY,MAEJO,GAMEmT,KANFnT,KACAwB,EAKE2R,KALF3R,KACAgD,EAIE2O,KAJF3O,KACA4E,EAGE+J,KAHF/J,KACAkC,EAEE6H,KAFF7H,KACAkF,EACE2C,KADF3C,OAGW,UAAThM,IACGC,KAAKhF,GACQ,oBAAT+E,IACD6O,QAAQ,SAACmL,KACR1N,UAA4C,IAAjCrR,EAAMQ,QAAQue,EAAO/e,WAGpC+E,KAAKA,EAAM4L,GAAmB5O,EAAM/B,EAAO2J,EAAMkC,EAAK7L,wCAIvD0L,EAAQsF,MAEZzQ,GAMEmT,KANFnT,KACAwB,EAKE2R,KALF3R,KACAgD,EAIE2O,KAJF3O,KACA4E,EAGE+J,KAHF/J,KACAkC,EAEE6H,KAFF7H,KACAkF,EACE2C,KADF3C,cAGc,SAAThM,EACHxE,EAAKyE,OACL8L,GAAmB/O,EAAMxB,EAAKwE,KAAKA,GAAO4E,EAAMkC,EAAK7L,MAAO0L,EAAQqF,EAASC,EAAe,oBAATjM,+CAIlF8Z,uBACAC,yBArHoClX,OACpCuB,UAAW,MsBLpBxH,EAAcsR,GAAY,SAAC1G,KACnB0D,MAAQ1D,EAAMgF,SAAS3Q,OACvB4N,MAAQjC,EAAMgF,SAASvR,QAG/B2B,EAAcuR,GAAY,SAACtL,EAAO7F,KAC1B+F,OAASN,EAAoBzF,ICArC,IAAakK,IAAM,GAAIzG,IAAKsB,IAQfyH,GAAO,GAAI/I,IAAKsB,GAASiO,iBAQzBiK,GAAO,GAAIxZ,IAAKsB,GAASkY,MAQzBra,GAAO,GAAIa,IAAKsB,GAASnC,KAEtCD,GAAoBC","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL3V0aWxzL2lzLmpzIiwiLi4vc3JjL3V0aWxzL2VzY2FwZVJlZ2V4LmpzIiwiLi4vc3JjL3V0aWxzL25vb3AuanMiLCIuLi9zcmMvdXRpbHMvdG9DYXNlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRBdHRyLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRDU1NQcm9wLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGREYXRhQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkTmV4dC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUGFyZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRQcmV2LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9jcmVhdGVIaWRlU3R5bGVOb2RlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRBdHRyTlMuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2hpZGUuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzRWxlbS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaXNFbGVtZW50c0NvbGxlY3Rpb24uanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzSFRNTERvY3VtZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9pc1ZhbGlkTm9kZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9zaG93LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS90b0VsZW0uanMiLCIuLi9zcmMvZmluZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jbGVhblByb3BlcnR5LmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0TWl4aW5SZWdleC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL21peGluTWF0Y2guanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay90cmFuc2Zvcm1SZXN0QXR0cnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9leGVjdXRlTWl4aW5XYXRjaGVycy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NyZWF0ZU1peGluLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY2FsY3VsYXRlQXR0cnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jb25zdHJ1Y3RQcml2YXRlU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9yZW1vdmVXYXRjaGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0UHVibGljU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jcmVhdGVCbG9jay5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2lzSW5zdGFuY2VPZi5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlbW92ZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3dhdGNoRm9yQWxsLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svd3JhcC5qcyIsIi4uL3NyYy9pbml0QXBwLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLXN3aXRjaC5qcyIsIi4uL3NyYy9taXhpbnMvZC1zdHlsZS5qcyIsIi4uL3NyYy9taXhpbnMvZC12YWx1ZS5qcyIsIi4uL3NyYy9pbnNlcnRUZW1wbGF0ZXMuanMiLCIuLi9zcmMvcmVtb3ZlQXBwLmpzIiwiLi4vc3JjL2dsb2JhbC5qcyIsIi4uL3NyYy91dGlscy9vYmplY3RTdGF0aWNzLmpzIiwiLi4vc3JjL2NvbnN0YW50cy5qcyIsIi4uL3NyYy9FbGVtLmpzIiwiLi4vc3JjL01peGluLmpzIiwiLi4vc3JjL0Jsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWJsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWl0ZW0uanMiLCIuLi9zcmMvYmxvY2tzL2QtZWFjaC5qcyIsIi4uL3NyYy9ibG9ja3MvZC1lbGVtZW50cy5qcyIsIi4uL3NyYy9ibG9ja3MvZC1pZi5qcyIsIi4uL3NyYy9taXhpbnMvZC1hdHRyLmpzIiwiLi4vc3JjL21peGlucy9kLWJpbmQuanMiLCIuLi9zcmMvbWl4aW5zL2QtY2xhc3MuanMiLCIuLi9zcmMvbWl4aW5zL2QtZWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvZC1oaWRlLmpzIiwiLi4vc3JjL21peGlucy9kLW5vZGUuanMiLCIuLi9zcmMvbWl4aW5zL2Qtb24uanMiLCIuLi9zcmMvbWl4aW5zL2Qtc2hvdy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlZ2lzdGVyQnVpbHRpbnMuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi9hcnJheSc7XG5cbmNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuY29uc3QgeyBzbGljZSB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChzb3VyY2UsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSA9IHt9KSB7XG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGNhbGxiYWNrKGluaXRpYWxWYWx1ZSwgdmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VwdChvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG4gIGNvbnN0IHBhdGhzID0gYXJndW1lbnRzOjpzbGljZSgxKTtcblxuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAocGF0aHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0OjpoYXMoa2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG5cbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgbmV3T2JqZWN0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZU9iamVjdCB9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lRnJvemVuUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIGZyb3plbiBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIH0gZnJvbSAnLi9kZWZpbmVQcm9wZXJ0eSc7XG5cbmNvbnN0IHsgU3ltYm9sIH0gPSBnbG9iYWw7XG5jb25zdCB7IHRvU3RyaW5nIH0gPSB7fTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdG9TdHJpbmdUYWdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGdldCB0b1N0cmluZ1RhZyBvZi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEN1dCBzdHJpbmcuXG4gKiBAZGVzY3JpcHRpb24gQ3V0IFwiVHlwZVwiIHN0cmluZyBmcm9tIFwiW29iamVjdCBUeXBlXVwiIHN0cmluZyB0aGF0IGdvdHRlbiBmcm9tIHt9LnRvU3RyaW5nLGNhbGwob2JqZWN0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0Ojp0b1N0cmluZygpLnNsaWNlKDgsIC0xKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKG9iamVjdCwgdGFnKSB7XG4gIGlmIChTeW1ib2wgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyhvYmplY3QucHJvdG90eXBlLCB7XG4gICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogdGFnXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2NoZWNrVHlwZXNcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGlzPFR5cGU+IG1ldGhvZHMuXG4gKi9cblxuaW1wb3J0IHsgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3RvU3RyaW5nVGFnJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNBcnJheVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGFycmF5LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvciBub3QuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBpc0FycmF5KFtdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzQXJyYXkoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpOyAvLyBmYWxzZVxuICovXG5leHBvcnQgY29uc3QgeyBpc0FycmF5IH0gPSBBcnJheTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNGdW5jdGlvbigoKSA9PiB7fSk7ICAgICAgICAgICAgLy8gdHJ1ZVxuICogXG4gKiBjb25zdCBmdW5jID0gKCkgPT4ge307XG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZnVuYywge30pO1xuICogaXNGdW5jdGlvbihmdW5jKTsgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOaWxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc05pbChudWxsKTsgICAgICAvLyB0cnVlXG4gKiBpc05pbCh1bmRlZmluZWQpOyAvLyB0cnVlXG4gKiBpc05pbChmYWxzZSk7ICAgICAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc1N0cmluZygnMCcpOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1N0cmluZyhuZXcgU3RyaW5nKCcwJykpOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnU3RyaW5nJztcbn1cbiIsImNvbnN0IHJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gW1xuICAnLicsXG4gICcrJywgJyonLCAnPycsXG4gICcoJywgJyknLFxuICAnWycsICddJyxcbiAgJ3snLCAnfScsXG4gICc8JywgJz4nLFxuICAnXicsICckJyxcbiAgJyEnLFxuICAnPScsXG4gICc6JyxcbiAgJy0nLFxuICAnfCcsXG4gICcsJyxcbiAgJ1xcXFwnXG5dO1xuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxuICByZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xuICAgIC5tYXAoKHMpID0+IGBcXFxcJHsgcyB9YClcbiAgICAuam9pbignfCcpLFxuICAnZydcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRBdHRyKGF0dHJzLCBhdHRyKSB7XG4gIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xufVxuIiwiaW1wb3J0IHsgdG9DYW1lbENhc2UgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCA9IC86IC87XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDU1NQcm9wKGNzcywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdChDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gICAgY3NzW3RvQ2FtZWxDYXNlKHByb3BlcnR5WzBdKV0gPSBwcm9wZXJ0eVsxXTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZERhdGFBdHRyKGRhdGEsIHZhbHVlLCBrZXkpIHtcbiAgZGF0YVtrZXldID0gdmFsdWU7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkTmV4dChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ubmV4dFNpYmxpbmcpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZFBhcmVudChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucGFyZW50Tm9kZSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUHJldihhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucHJldmlvdXNTaWJsaW5nKTtcbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGlkZVN0eWxlTm9kZShoZWFkKSB7XG4gIGNvbnN0IHN0eWxlID0gaGVhZC5maW5kKGBzdHlsZSMkeyBISURFX0NMQVNTIH1gKTtcblxuICBpZiAoc3R5bGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGVhZFxuICAgIC5jcmVhdGUoJ3N0eWxlJylcbiAgICAucHJvcCgnaWQnLCBISURFX0NMQVNTKVxuICAgIC50ZXh0KGAuJHsgSElERV9DTEFTUyB9e2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50O31gKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuY29uc3QgWF9MSU5LX0FUVFJfRklORF9SRUdFWCA9IC9eeGxpbms6XFx3LztcbmNvbnN0IFhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVggPSAvXnhsaW5rOi87XG5jb25zdCBYTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgWF9MSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgTnVsbCA9IHtcbiAgbnM6IG51bGxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyTlMoYXR0ciwgZWxlbSkge1xuICBjb25zdCBpc1htbE5zID0gYXR0ciA9PT0gJ3htbG5zJztcblxuICBpZiAoaXNYbWxOcyB8fCBhdHRyID09PSAneG1sbnM6eGxpbmsnKSB7XG4gICAgaWYgKGVsZW0ubm9kZU5hbWUgIT09ICdTVkcnKSB7XG4gICAgICByZXR1cm4gTnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbnM6IFhNTF9OUyxcbiAgICAgIG5hbWU6IGlzWG1sTnNcbiAgICAgICAgPyAneG1sbnMnXG4gICAgICAgIDogJ3hsaW5rJ1xuICAgIH07XG4gIH1cblxuICBpZiAoWF9MSU5LX0FUVFJfRklORF9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgaWYgKCFuZXcgRWxlbShlbGVtKS5jbG9zZXN0KCdzdmcnKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBOdWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuczogWF9MSU5LX05TLFxuICAgICAgbmFtZTogYXR0ci5yZXBsYWNlKFhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVgsICcnKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gTnVsbDtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUhpZGVTdHlsZU5vZGUgfSBmcm9tICcuL2NyZWF0ZUhpZGVTdHlsZU5vZGUnO1xuaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWRlKGVsZW0pIHtcbiAgY3JlYXRlSGlkZVN0eWxlTm9kZShuZXcgRWxlbShlbGVtLm93bmVyRG9jdW1lbnQuaGVhZCkpO1xuICBuZXcgRWxlbShlbGVtKS5hZGRDbGFzcyhISURFX0NMQVNTKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtO1xufVxuIiwiaW1wb3J0IHsgdG9TdHJpbmdUYWcsIGlzQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBpc0VsZW0gfSBmcm9tICcuL2lzRWxlbSc7XG5cbmNvbnN0IEhUTUxfQ09MTEVDVElPTl9SRUdFWCA9IC9eKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0KSQvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50c0NvbGxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBIVE1MX0NPTExFQ1RJT05fUkVHRVgudGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpXG4gICAgfHwgaXNFbGVtKHZhbHVlKVxuICAgIHx8IGlzQXJyYXkodmFsdWUpXG4gICk7XG59XG4iLCJpbXBvcnQgeyB0b1N0cmluZ1RhZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTERvY3VtZW50KHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdIVE1MRG9jdW1lbnQnO1xufVxuIiwiaW1wb3J0IHsgdG9TdHJpbmdUYWcgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IEVMRU1FTlRfUkVHRVggPSAvRWxlbWVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE5vZGUodmFsdWUpIHtcbiAgY29uc3QgdGFnID0gdG9TdHJpbmdUYWcodmFsdWUpO1xuXG4gIHJldHVybiAoXG4gICAgRUxFTUVOVF9SRUdFWC50ZXN0KHRhZylcbiAgICB8fCB0YWcgPT09ICdIVE1MRG9jdW1lbnQnXG4gICAgfHwgdGFnID09PSAnVGV4dCdcbiAgICB8fCB0YWcgPT09ICdEb2N1bWVudEZyYWdtZW50J1xuICAgIHx8IHRhZyA9PT0gJ0NvbW1lbnQnXG4gICk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsZW0pIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hvdyhlbGVtKSB7XG4gIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUNsYXNzKEhJREVfQ0xBU1MpO1xufVxuIiwiaW1wb3J0IHsgaXNFbGVtIH0gZnJvbSAnLi9pc0VsZW0nO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9FbGVtKGVsZW0pIHtcbiAgcmV0dXJuIGlzRWxlbShlbGVtKVxuICAgID8gZWxlbVxuICAgIDogbmV3IEVsZW0oZWxlbSk7XG59XG4iLCJpbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcbmltcG9ydCB7IGRvY3VtZW50IH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBmaW5kXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBmaW5kLlxuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9IFtiYXNlID0gZG9jdW1lbnRdIC0gQmFzZSB0byBmaW5kIGluLlxuICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gKiBbRG9jdW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZChzZWxlY3RvciwgYmFzZSA9IGRvY3VtZW50KSB7XG4gIHJldHVybiBuZXcgRWxlbShiYXNlLnF1ZXJ5U2VsZWN0b3JBbGwoU3RyaW5nKHNlbGVjdG9yKSkpO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5LCBrZXlzIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KSB7XG4gIGl0ZXJhdGVBcnJheShrZXlzKGFyZ3NPYmplY3QpLCAoYXJnKSA9PiB7XG4gICAgaWYgKCEoYXJnIGluIGFyZ3MpKSB7XG4gICAgICBhcmdzT2JqZWN0W2FyZ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcblxuICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gIGZvciAoY29uc3QgYXJnIGluIGFyZ3MpIHtcbiAgICBhcmdzT2JqZWN0W2FyZ10gPSBhcmdzW2FyZ107XG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjbGVhblByb3BlcnR5KHZhbHVlLCBhcmcsIG9iamVjdCkge1xuICBkZWxldGUgb2JqZWN0W2FyZ107XG59XG4iLCJpbXBvcnQgeyBlc2NhcGVSZWdleCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdE1peGluUmVnZXgobmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7IGVzY2FwZVJlZ2V4KG5hbWUpIH0oPzpcXFxcKChbXlxcXFwpXSopXFxcXCkpPyg/OiMoW1xcXFxzXFxcXFNdKikpPyRgKTtcbn1cbiIsImNvbnN0IENPTU1BX1JFR0VYID0gLywvO1xuXG5leHBvcnQgZnVuY3Rpb24gbWl4aW5NYXRjaChtaXhpbnMsIGF0dHIpIHtcbiAgbGV0IG1hdGNoO1xuXG4gIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgZm9yIChjb25zdCBuYW1lIGluIG1peGlucykge1xuICAgIGNvbnN0IE1peGluID0gbWl4aW5zW25hbWVdO1xuICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSBhdHRyLm1hdGNoKE1peGluLl9tYXRjaCk7XG5cbiAgICBpZiAobG9jYWxNYXRjaCkge1xuICAgICAgY29uc3QgYXJnc01hdGNoID0gbG9jYWxNYXRjaFsxXTtcbiAgICAgIGxldCBhcmdzO1xuXG4gICAgICBpZiAoYXJnc01hdGNoID09PSAnJykge1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NNYXRjaCkge1xuICAgICAgICBhcmdzID0gYXJnc01hdGNoLnNwbGl0KENPTU1BX1JFR0VYKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNvbW1lbnQ6IGxvY2FsTWF0Y2hbMl0sXG4gICAgICAgIE1peGluLFxuICAgICAgICBuYW1lXG4gICAgICB9O1xuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG4iLCJpbXBvcnQgeyBjb2xsZWN0RnJvbU9iamVjdCwgYXNzaWduIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRF9SRVNUX1JFR0VYIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IG1peGluTWF0Y2ggfSBmcm9tICcuL21peGluTWF0Y2gnO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUmVzdEF0dHJzKGF0dHJzLCBtaXhpbnMsIG1peGluRGVmYXVsdE9wdHMpIHtcbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGF0dHJzLCAoZXZlbnR1YWxBdHRycywgdmFsdWUsIGF0dHIpID0+IHtcbiAgICBpZiAoRF9SRVNUX1JFR0VYLnRlc3QoYXR0cikpIHtcbiAgICAgIHJldHVybiBhc3NpZ24oZXZlbnR1YWxBdHRycywgdHJhbnNmb3JtUmVzdEF0dHJzKHZhbHVlLCBtaXhpbnMsIG1peGluRGVmYXVsdE9wdHMpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IG1peGluTWF0Y2gobWl4aW5zLCBhdHRyKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXZlbnR1YWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgdHlwZTogJ21peGluJyxcbiAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgb3B0czoge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIC4uLm1hdGNoLFxuICAgICAgICAgIC4uLm1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudHVhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgdHlwZTogJ2F0dHInLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3RBcmdzKGFyZ3MpIHtcbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIGFkZEFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhZGRBcmdzKGFyZ3MsIHZhbHVlLCBhcmcpIHtcbiAgaWYgKERfUkVTVF9SRUdFWC50ZXN0KGFyZykpIHtcbiAgICBhc3NpZ24oYXJncywgdHJhbnNmb3JtUmVzdEFyZ3ModmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzW2FyZ10gPSB2YWx1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIHZhbHVlKSB7XG4gIGNvbnN0IG9sZFZhbHVlID0gbWl4aW4uJCQudmFsdWU7XG5cbiAgbWl4aW4uJCQudmFsdWUgPSB2YWx1ZTtcblxuICBpdGVyYXRlQXJyYXkobWl4aW4uJCQud2F0Y2hlcnMsICh3YXRjaGVyKSA9PiB7XG4gICAgd2F0Y2hlcih2YWx1ZSwgb2xkVmFsdWUpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNaXhpbih7XG4gIG5hbWUsIE1peGluLCBkeW5hbWljLFxuICB2YWx1ZSwgYXJncywgY29tbWVudCwgZWxlbSxcbiAgcGFyZW50QmxvY2ssIHBhcmVudFNjb3BlLCBwYXJlbnRUZW1wbGF0ZVxufSkge1xuICBjb25zdCBtaXhpbiA9IG5ldyBNaXhpbih7XG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICBkeW5hbWljLFxuICAgIGFyZ3MsXG4gICAgY29tbWVudCxcbiAgICBlbGVtLFxuICAgIHBhcmVudEJsb2NrLFxuICAgIHBhcmVudFNjb3BlLFxuICAgIHBhcmVudFRlbXBsYXRlXG4gIH0pO1xuXG4gIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gbWl4aW4udmFsdWUgPSBtaXhpbi5ldmFsdWF0ZSgobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICBtaXhpbi52YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBtaXhpbi5hZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclVwZGF0ZTpgLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWl4aW4uYWZ0ZXJVcGRhdGUodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIG1peGluO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZU9iamVjdCwgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZXhlY3V0ZU1peGluV2F0Y2hlcnMgfSBmcm9tICcuL2V4ZWN1dGVNaXhpbldhdGNoZXJzJztcbmltcG9ydCB7IGNyZWF0ZU1peGluIH0gZnJvbSAnLi9jcmVhdGVNaXhpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBdHRycyhhdHRycywgYXR0cnNPYmplY3QsIGVsZW0sIGZpcnN0VGltZSkge1xuICBpdGVyYXRlT2JqZWN0KGF0dHJzT2JqZWN0LCAoeyB0eXBlLCB2YWx1ZSB9LCBhdHRyKSA9PiB7XG4gICAgaWYgKCFhdHRyc1thdHRyXSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS4kJC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGF0dHJzT2JqZWN0W2F0dHJdO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbWl4aW5zID0gW107XG5cbiAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0c1xuICAgIH0gPSBhdHRyc1thdHRyXTtcbiAgICBsZXQgbmV4dFR5cGU7XG4gICAgbGV0IG5leHREeW5hbWljO1xuICAgIGxldCBuZXh0VmFsdWU7XG5cbiAgICBpZiAoYXR0cnNPYmplY3RbYXR0cl0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZTogcHJldlR5cGUsXG4gICAgICAgIHZhbHVlOiBwcmV2VmFsdWVcbiAgICAgIH0gPSBhdHRyc09iamVjdFthdHRyXTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBpZiAocHJldlR5cGUgPT09ICdtaXhpbicpIHtcbiAgICAgICAgICBwcmV2VmFsdWUuJCQucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGVsZW0uYXR0cihhdHRyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1peGluID0gcHJldlZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWl4aW4uJCQuaXNEeW5hbWljID0gZHluYW1pYztcblxuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW1peGluLiQkLmV2YWx1YXRlZCAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtaXhpbi4kJC5wYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGR5bmFtaWNcbiAgICAgICAgICAgIH0gPSBhdHRyc1thdHRyXTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtaXhpbik7XG5cbiAgICAgICAgICBtaXhpbi4kJC5ldmFsdWF0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRWYWx1ZSA9IG1peGluO1xuICAgICAgfVxuXG4gICAgICBuZXh0VHlwZSA9IHR5cGU7XG4gICAgICBuZXh0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcblxuICAgICAgICBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkTWl4aW4gPSAoKSA9PiB7XG4gICAgICAgICAgb3B0cy5keW5hbWljID0gZHluYW1pYztcblxuICAgICAgICAgIGNvbnN0IG1peGluID0gY3JlYXRlTWl4aW4ob3B0cyk7XG5cbiAgICAgICAgICBpZiAoIWR5bmFtaWMgJiYgb3B0cy5NaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBvcHRzO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZHluYW1pY1xuICAgICAgICAgICAgICB9ID0gYXR0cnNbYXR0cl07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtaXhpbik7XG5cbiAgICAgICAgICAgIG1peGluLiQkLmV2YWx1YXRlZCA9IHRydWU7XG4gICAgICAgICAgICBtaXhpbi4kJC52YWx1ZSA9IGZpcnN0VmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZHluYW1pYyxcbiAgICAgICAgICAgICAgdmFsdWU6IG1peGluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgbWl4aW5zLnB1c2goYnVpbGRNaXhpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRNaXhpbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRUeXBlID0gdHlwZTtcbiAgICAgIG5leHREeW5hbWljID0gZHluYW1pYztcbiAgICB9XG5cbiAgICBhdHRyc09iamVjdFthdHRyXSA9IHtcbiAgICAgIHR5cGU6IG5leHRUeXBlLFxuICAgICAgZHluYW1pYzogbmV4dER5bmFtaWMsXG4gICAgICB2YWx1ZTogbmV4dFZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChmaXJzdFRpbWUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KG1peGlucywgKGJ1aWxkTWl4aW4pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgb3B0c1xuICAgICAgICB9ID0gYnVpbGRNaXhpbigpO1xuXG4gICAgICAgIGF0dHJzT2JqZWN0W2F0dHJdID0gb3B0cztcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZSwgY29sbGVjdEZyb21PYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RQcml2YXRlU2NvcGUob2JqZWN0LCB0eXBlLCBwYXJlbnRTY29wZSkge1xuICBsZXQgc2NvcGUgPSB7fTtcblxuICBpZiAodHlwZSA9PT0gJ2dsb2JhbHMnKSB7XG4gICAgc2NvcGUgPSBjcmVhdGUoXG4gICAgICBwYXJlbnRTY29wZVxuICAgICAgICA/IHBhcmVudFNjb3BlLiQkLmdsb2JhbHNcbiAgICAgICAgOiBudWxsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChvYmplY3QsIChzY29wZSwgdmFsdWUsIGtleSkgPT4ge1xuICAgIHNjb3BlW2tleV0gPSB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHdhdGNoZXJzOiB7XG4gICAgICAgIHRlbXA6IFtdLFxuICAgICAgICBwZXJtOiBbXVxuICAgICAgfVxuICAgIH07XG4gIH0sIHNjb3BlKTtcbn1cbiIsImltcG9ydCB7IHJlbW92ZUFycmF5RWxlbSwgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVGVtcFdhdGNoZXIod2F0Y2hlcikge1xuICB3YXRjaGVyLm9uUmVtb3ZlKCk7XG4gIHdhdGNoZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcbiAgaXRlcmF0ZUFycmF5KHdhdGNoZXJzVG9SZW1vdmUsIHJlbW92ZVdhdGNoZXIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVXYXRjaGVyKHsgd2F0Y2hlciwgd2F0Y2hlcnMgfSkge1xuICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgbWFwT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBTY29wZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyByZW1vdmVUZW1wV2F0Y2hlciB9IGZyb20gJy4vcmVtb3ZlV2F0Y2hlcic7XG5cbmxldCBjaGFuZ2VkO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0UHVibGljU2NvcGUoc2NvcGUsIHNjb3BlVmFsdWVzLCBwcml2YXRlU2NvcGUpIHtcbiAgZGVmaW5lUHJvcGVydGllcyhzY29wZSwgbWFwT2JqZWN0KHNjb3BlVmFsdWVzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gcHJpdmF0ZVNjb3BlW2tleV07XG4gICAgY29uc3QgeyB3YXRjaGVycyB9ID0gc2NvcGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmIChTY29wZS5ldmFsTW9kZSkge1xuICAgICAgICAgIGlmIChTY29wZS5nZXR0aW5nVmFycy5pbmRleE9mKHdhdGNoZXJzLnRlbXApID09PSAtMSkge1xuICAgICAgICAgICAgU2NvcGUuZ2V0dGluZ1ZhcnMucHVzaCh3YXRjaGVycy50ZW1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gc2NvcGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRUZW1wV2F0Y2hlcnMgPSB3YXRjaGVycy50ZW1wLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc2NvcGUudmFsdWU7XG5cbiAgICAgICAgd2F0Y2hlcnMudGVtcCA9IFtdO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheShvbGRUZW1wV2F0Y2hlcnMsIHJlbW92ZVRlbXBXYXRjaGVyKTtcbiAgICAgICAgY2hhbmdlZC5wdXNoKHtcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB3YXMgPSBbXTtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgICAgIH0gPSBjaGFuZ2VkW2ldO1xuXG4gICAgICAgICAgICBpdGVyYXRlQXJyYXkoc2NvcGUud2F0Y2hlcnMucGVybSwgKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB3YXMuaW5kZXhPZih3YXRjaGVyKTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgd2FzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0ub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoYW5nZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWQgPSBudWxsO1xuXG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHdhcywgKHdhdGNoZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG9sZFZhbHVlXG4gICAgICAgICAgICB9ID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICB3YXRjaGVyKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKTtcbn1cbiIsImltcG9ydCB7XG4gIGV4Y2VwdCwgY3JlYXRlLCBhc3NpZ24sXG4gIGl0ZXJhdGVPYmplY3QsIGl0ZXJhdGVBcnJheSxcbiAgaXNOaWxcbn0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuaW1wb3J0IHtcbiAgU1ZHX05TLCBEX1JFU1RfUkVHRVhcbn0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNsZWFuUHJvcGVydHkgfSBmcm9tICcuL2NsZWFuUHJvcGVydHknO1xuaW1wb3J0IHsgdHJhbnNmb3JtUmVzdEF0dHJzIH0gZnJvbSAnLi90cmFuc2Zvcm1SZXN0QXR0cnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQXR0cnMgfSBmcm9tICcuL2NhbGN1bGF0ZUF0dHJzJztcbmltcG9ydCB7IG1peGluTWF0Y2ggfSBmcm9tICcuL21peGluTWF0Y2gnO1xuaW1wb3J0IHsgY29uc3RydWN0UHJpdmF0ZVNjb3BlIH0gZnJvbSAnLi9jb25zdHJ1Y3RQcml2YXRlU2NvcGUnO1xuaW1wb3J0IHsgY29uc3RydWN0UHVibGljU2NvcGUgfSBmcm9tICcuL2NvbnN0cnVjdFB1YmxpY1Njb3BlJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuXG5jb25zdCBOQU1FRF9EX0JMT0NLX1JFR0VYID0gL15kLWJsb2NrOihbXFxzXFxTXSspJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCbG9jayh7IG5vZGUsIENvbnN0cnVjdG9yLCBwYXJlbnQsIHBhcmVudEVsZW0sIHBhcmVudEJsb2NrLCBwYXJlbnRTY29wZSwgcGFyZW50VGVtcGxhdGUsIHByZXZCbG9jayB9KSB7XG4gIGNvbnN0IGRvYyA9IG5ldyBFbGVtKHBhcmVudEVsZW1bMF0ub3duZXJEb2N1bWVudCk7XG4gIGNvbnN0IGVsZW0gPSBwYXJlbnRFbGVtWzBdLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05TXG4gICAgPyBkb2MuY3JlYXRlKCdzdmcnKVxuICAgIDogZG9jO1xuICBjb25zdCBsb2NhbEJsb2NrcyA9IHBhcmVudFRlbXBsYXRlID8gcGFyZW50VGVtcGxhdGUuJCQubnMuX2Jsb2NrcyA6IEJsb2NrLl9ibG9ja3M7XG4gIGNvbnN0IGxvY2FsTWl4aW5zID0gcGFyZW50VGVtcGxhdGUgPyBwYXJlbnRUZW1wbGF0ZS4kJC5ucy5fbWl4aW5zIDogQmxvY2suX21peGlucztcbiAgbGV0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XG4gIGxldCBhcmdzID0gbm9kZS5hdHRycyA9IG5vZGUuYXR0cnMgfHwge307XG4gIGxldCBuYW1lID0gbm9kZS5uYW1lIHx8ICdVbmtub3duQmxvY2snO1xuICBsZXQgY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvciB8fCAobm9kZS5uYW1lICYmIGxvY2FsQmxvY2tzW25vZGUubmFtZV0pO1xuICBsZXQgZEJsb2NrTWF0Y2g7XG4gIGxldCBkQmxvY2tOYW1lO1xuICBsZXQgZEJsb2NrQXJncztcbiAgbGV0IGRCbG9ja0NoaWxkcmVuO1xuICBsZXQgZEVsZW1lbnRzTmFtZTtcbiAgbGV0IGRFbGVtZW50c0NvbnN0cnVjdG9yO1xuXG4gIGlmIChuYW1lID09PSAnZC1ibG9jaycgJiYgYXJncy5uYW1lKSB7XG4gICAgbmFtZSA9ICdkLWVsZW1lbnRzJztcbiAgICBjb25zdHJ1Y3RvciA9IGxvY2FsQmxvY2tzW25hbWVdO1xuICAgIGRFbGVtZW50c05hbWUgPSBhcmdzLm5hbWU7XG4gICAgZEJsb2NrQXJncyA9IGV4Y2VwdChhcmdzLCAnbmFtZScpO1xuICAgIGRCbG9ja0NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBbXTtcbiAgICBhcmdzID0ge307XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2QtYmxvY2snICYmIGFyZ3MuQ29uc3RydWN0b3IpIHtcbiAgICBuYW1lID0gJ1Vua25vd25CbG9jayc7XG4gICAgY29uc3RydWN0b3IgPSBsb2NhbEJsb2Nrc1tuYW1lXTtcbiAgICBkRWxlbWVudHNDb25zdHJ1Y3RvciA9IGFyZ3MuQ29uc3RydWN0b3I7XG4gICAgZEJsb2NrQXJncyA9IGV4Y2VwdChhcmdzLCAnQ29uc3RydWN0b3InKTtcbiAgICBkQmxvY2tDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gW107XG4gICAgYXJncyA9IHt9O1xuICB9IGVsc2UgaWYgKChkQmxvY2tNYXRjaCA9IG5hbWUubWF0Y2goTkFNRURfRF9CTE9DS19SRUdFWCkpIHx8IG5hbWUgPT09ICdkLWJsb2NrJykge1xuICAgIGNvbnN0cnVjdG9yID0gQmxvY2suX2Jsb2Nrc1snZC1ibG9jayddO1xuICAgIGRCbG9ja05hbWUgPSBkQmxvY2tNYXRjaCA/IGRCbG9ja01hdGNoWzFdIDogbnVsbDtcbiAgfVxuXG4gIGxldCBibG9ja0luc3RhbmNlO1xuXG4gIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgIHRyeSB7XG4gICAgICBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgcHJldkJsb2NrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluIG5ldyAkeyBuYW1lIH06YCwgZXJyKTtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBub2RlO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW0uY3JlYXRlKG5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgYXR0cnMgPSBjcmVhdGUobnVsbCk7XG4gICAgbGV0IHdhc0RSZXN0O1xuICAgIGNvbnN0IG1peGluRGVmYXVsdE9wdHMgPSB7XG4gICAgICBlbGVtOiBlbGVtZW50LFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfTtcblxuICAgIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBpc0RSZXN0ID0gRF9SRVNUX1JFR0VYLnRlc3QoYXR0cik7XG4gICAgICBjb25zdCBsb2NhbEF0dHJzID0gaXNEUmVzdCB8fCB3YXNEUmVzdFxuICAgICAgICA/IGNyZWF0ZShhdHRycylcbiAgICAgICAgOiBhdHRycztcblxuICAgICAgYXR0cnMgPSBsb2NhbEF0dHJzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXR0cnMgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXR0cnMsIGNsZWFuUHJvcGVydHkpO1xuICAgICAgICAgICAgYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICAgICAgdmFsdWUsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICByZXN0QXR0cnMsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaCA9IG1peGluTWF0Y2gobG9jYWxNaXhpbnMsIGF0dHIpO1xuXG4gICAgICB3YXNEUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgICB0eXBlOiAnbWl4aW4nLFxuICAgICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgICAuLi5taXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgdHlwZTogJ2F0dHInLFxuICAgICAgICB2YWx1ZTogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXR0cicsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsY3VsYXRlQXR0cnMoYXR0cnMsIGN1cnJlbnRBdHRycywgZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9LCBwYXJlbnRCbG9jaylcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCBjcmVhdGVNaXhpbnMgPSBjYWxjdWxhdGVBdHRycyhhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCB0cnVlKTtcblxuICAgIGlmIChuYW1lID09PSAnI2NvbW1lbnQnKSB7XG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnI3RleHQnKSB7XG4gICAgICBsZXQgdGV4dCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnRleHQoYCR7IHZhbHVlIH1gKTtcbiAgICAgIH0sIHBhcmVudEJsb2NrKTtcblxuICAgICAgaWYgKGlzTmlsKHRleHQpKSB7XG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC50ZXh0KGAkeyB0ZXh0IH1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IHBhcmVudEVsZW0gPSBuYW1lID09PSAndGVtcGxhdGUnXG4gICAgICAgID8gbmV3IEVsZW0oZWxlbWVudFswXS5jb250ZW50KVxuICAgICAgICA6IGVsZW1lbnQ7XG4gICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICBpdGVyYXRlQXJyYXkoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuXG4gICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChlbGVtZW50LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcblxuICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoZWxlbWVudCwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGNyZWF0ZU1peGlucygpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBjb25zdCB7XG4gICAgJCQsXG4gICAgYXJnczogQXJncyxcbiAgICBnbG9iYWxzLFxuICAgIC4uLmxvY2Fsc1xuICB9ID0gYmxvY2tJbnN0YW5jZTtcblxuICBpZiAoZEVsZW1lbnRzTmFtZSkge1xuICAgIG5vZGUgPSB7XG4gICAgICBhdHRyczogZEJsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBkQmxvY2tDaGlsZHJlblxuICAgIH07XG4gICAgbm9kZS5uYW1lID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoZEVsZW1lbnRzTmFtZSwgKG5ld05hbWUpID0+IHtcbiAgICAgIG5vZGUubmFtZSA9IG5ld05hbWU7XG5cbiAgICAgIEFyZ3MudmFsdWUgPSBbbm9kZV07XG4gICAgfSwgYmxvY2tJbnN0YW5jZSwgdHJ1ZSk7XG5cbiAgICBBcmdzLnZhbHVlID0gW25vZGVdO1xuICAgIEFyZ3MucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgICBBcmdzLnBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG4gIH1cblxuICBpZiAoZEVsZW1lbnRzQ29uc3RydWN0b3IpIHtcbiAgICBub2RlID0ge1xuICAgICAgbmFtZSxcbiAgICAgIGF0dHJzOiBkQmxvY2tBcmdzLFxuICAgICAgY2hpbGRyZW46IGRCbG9ja0NoaWxkcmVuXG4gICAgfTtcblxuICAgIEFyZ3MuQ29uc3RydWN0b3IgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShkRWxlbWVudHNDb25zdHJ1Y3RvciwgKG5ld0NvbnN0cnVjdG9yKSA9PiB7XG4gICAgICBBcmdzLkNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICBBcmdzLnZhbHVlID0gW25vZGVdO1xuICAgIH0sIGJsb2NrSW5zdGFuY2UsIHRydWUpO1xuICAgIEFyZ3MudmFsdWUgPSBbbm9kZV07XG4gICAgQXJncy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgIEFyZ3MucGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIGNvbnN0IGh0bWwgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IEFyZ3MudmFsdWUgfHwgW11cbiAgICA6IGNvbnN0cnVjdG9yLl9odG1sO1xuXG4gICQkLmFyZ3MgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoQXJncyk7XG4gICQkLmxvY2FscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShsb2NhbHMpO1xuICAkJC5nbG9iYWxzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGdsb2JhbHMsICdnbG9iYWxzJywgcGFyZW50U2NvcGUpO1xuXG4gIGlmIChuYW1lID09PSAnI2QtaXRlbScpIHtcbiAgICBjb25zdCBzY29wZVZhbHVlcyA9IHtcbiAgICAgIFtub2RlLml0ZW1OYW1lXTogbm9kZS5pdGVtLFxuICAgICAgW25vZGUuaW5kZXhOYW1lXTogbm9kZS5pbmRleFxuICAgIH07XG4gICAgY29uc3Qgc2NvcGUgPSBwYXJlbnRTY29wZS4kJC5uYW1lID09PSAnI2QtaXRlbSdcbiAgICAgID8gcGFyZW50U2NvcGUuJCQuc2NvcGVcbiAgICAgIDogcGFyZW50U2NvcGU7XG5cbiAgICAkJC5ucyA9IHBhcmVudFNjb3BlLiQkLm5zO1xuICAgICQkLnByaXZhdGVTY29wZSA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShzY29wZVZhbHVlcyk7XG4gICAgY29uc3RydWN0UHVibGljU2NvcGUoJCQuc2NvcGUgPSBjcmVhdGUoc2NvcGUpLCBzY29wZVZhbHVlcywgJCQucHJpdmF0ZVNjb3BlKTtcbiAgfVxuXG4gIGlmIChuYW1lID09PSAnZC1lYWNoJykge1xuICAgICQkLnNjb3BlID0gY3JlYXRlKHBhcmVudFNjb3BlLiQkLm5hbWUgPT09ICcjZC1pdGVtJyA/IHBhcmVudFNjb3BlLiQkLnNjb3BlIDogcGFyZW50U2NvcGUsIHtcbiAgICAgIFtBcmdzLml0ZW0gfHwgJyRpdGVtJ106IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW0FyZ3MuaW5kZXggfHwgJyRpbmRleCddOiB7XG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0UHVibGljU2NvcGUoQXJncywgQXJncywgJCQuYXJncyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGdsb2JhbHMsIGdsb2JhbHMsICQkLmdsb2JhbHMpO1xuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShibG9ja0luc3RhbmNlLCBsb2NhbHMsICQkLmxvY2Fscyk7XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyQ29uc3RydWN0KCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnN0cnVjdDpgLCBlcnIpO1xuICB9XG5cbiAgcHJldkJsb2NrID0gdW5kZWZpbmVkO1xuICBwYXJlbnRTY29wZSA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy5wYXJlbnRTY29wZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcbiAgcGFyZW50VGVtcGxhdGUgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IEFyZ3MucGFyZW50VGVtcGxhdGVcbiAgICA6IGJsb2NrSW5zdGFuY2U7XG5cbiAgaXRlcmF0ZUFycmF5KGh0bWwsIChjaGlsZCkgPT4ge1xuICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgcGFyZW50OiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrOiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0pO1xuICB9KTtcblxuICBibG9ja0luc3RhbmNlLiQkLmlzUmVuZGVyZWQgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgYmxvY2tJbnN0YW5jZS5hZnRlclJlbmRlcigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYWZ0ZXJSZW5kZXI6YCwgZXJyKTtcbiAgfVxuXG4gIHJldHVybiBibG9ja0luc3RhbmNlO1xufVxuIiwiY29uc3QgeyBpc1Byb3RvdHlwZU9mIH0gPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5zdGFuY2VPZihDbGFzcywgU3ViY2xhc3MpIHtcbiAgcmV0dXJuIENsYXNzOjppc1Byb3RvdHlwZU9mKFN1YmNsYXNzKSAmJiBDbGFzcy5wcm90b3R5cGU6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MucHJvdG90eXBlKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmVXaXRoUGFyZW50U2lnbmFsKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSh0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICBjaGlsZC4kJC5yZW1vdmUoKTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXRjaEZvckFsbExvY2FscyhibG9jaywgd2F0Y2hlcikge1xuICBpdGVyYXRlT2JqZWN0KGJsb2NrLiQkLmxvY2FscywgKHsgd2F0Y2hlcnMgfSkgPT4ge1xuICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXRjaEZvckFsbEdsb2JhbHMoYmxvY2ssIHdhdGNoZXIpIHtcbiAgY29uc3Qge1xuICAgIGdsb2JhbHMsXG4gICAgd2F0Y2hlcnNUb1JlbW92ZVxuICB9ID0gYmxvY2suJCQ7XG5cbiAgZm9yIChjb25zdCBnbG9iIGluIGdsb2JhbHMpIHtcbiAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgY29uc3Qgd2F0Y2hlcnMgPSBnbG9iYWxzW2dsb2JdLndhdGNoZXJzLnBlcm07XG5cbiAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgIHdhdGNoZXJzVG9SZW1vdmUucHVzaCh7XG4gICAgICB3YXRjaGVyLFxuICAgICAgd2F0Y2hlcnNcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hGb3JBbGxBcmdzKGJsb2NrLCB3YXRjaGVyKSB7XG4gIGl0ZXJhdGVPYmplY3QoYmxvY2suJCQuYXJncywgKHsgd2F0Y2hlcnMgfSkgPT4ge1xuICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2lzSW5zdGFuY2VPZic7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uLy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vLi4vTWl4aW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcEJsb2NrKGJsb2NrLCB3cmFwcGVyKSB7XG4gIGNvbnN0IHJldHVyblZhbHVlID0gd3JhcHBlcihibG9jayk7XG5cbiAgcmV0dXJuIGlzSW5zdGFuY2VPZihCbG9jaywgcmV0dXJuVmFsdWUpXG4gICAgPyByZXR1cm5WYWx1ZVxuICAgIDogYmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWl4aW4obWl4aW4sIHdyYXBwZXIpIHtcbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB3cmFwcGVyKG1peGluKTtcblxuICByZXR1cm4gaXNJbnN0YW5jZU9mKE1peGluLCByZXR1cm5WYWx1ZSlcbiAgICA/IHJldHVyblZhbHVlXG4gICAgOiBtaXhpbjtcbn1cbiIsImltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVCbG9jayB9IGZyb20gJy4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0QXBwKGh0bWwsIGNvbnRhaW5lcikge1xuICBjb25zdCBwYXJlbnRFbGVtID0gbmV3IEVsZW0oY29udGFpbmVyKS5lbGVtKDApO1xuXG4gIGlmICghcGFyZW50RWxlbS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuICB9XG5cbiAgaWYgKHBhcmVudEVsZW0ucHJvcCgnRHdheW5lUm9vdEJsb2NrJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGFscmVhZHkgZXhpc3RzIGEgRHdheW5lIGFwcCBpbnNpZGUgdGhlIGdpdmVuIGVsZW1lbnQhIChpbml0QXBwKScpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGh0bWwpKSB7XG4gICAgaHRtbCA9IHtcbiAgICAgIHZhcnM6IFtdLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6IGh0bWxcbiAgICAgIH1dXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGh0bWwpKSB7XG4gICAgaHRtbCA9IHtcbiAgICAgIHZhcnM6IFtdLFxuICAgICAgdmFsdWU6IGh0bWxcbiAgICB9O1xuICB9XG5cbiAgY2xhc3MgUm9vdEJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgIHN0YXRpYyBfdmFycyA9IGh0bWwudmFycztcbiAgICBzdGF0aWMgX2h0bWwgPSBodG1sLnZhbHVlXG4gIH1cblxuICBjb25zdCBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICBub2RlOiB7XG4gICAgICBuYW1lOiAnI1Jvb3RCbG9jaydcbiAgICB9LFxuICAgIENvbnN0cnVjdG9yOiBSb290QmxvY2ssXG4gICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgIHBhcmVudEVsZW1cbiAgfSk7XG5cbiAgcGFyZW50RWxlbVxuICAgIC5wcm9wKCdEd2F5bmVSb290QmxvY2snLCBibG9jaylcbiAgICAuYXR0cignZHdheW5lLXJvb3QnLCAnJyk7XG59XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSwgaXRlcmF0ZUFycmF5LCBub29wIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgYXJncy52YWx1ZWA7XG5cbnJvb3RCbG9ja3NbJ2Qtc3dpdGNoJ10gPSBjbGFzcyBEU3dpdGNoIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7JCQucGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcblxuICBpbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICQkOiB7XG4gICAgICAgIGh0bWxDaGlsZHJlbiA9IFtdLFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgfSxcbiAgICAgIGFyZ3MsXG4gICAgICBhcmdzOiB7IHZhbHVlIH1cbiAgICB9ID0gdGhpcztcblxuICAgIHRoaXMudmFsdWVzID0gaHRtbENoaWxkcmVuLm1hcCgoY2hpbGQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cnMgPSBbXSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGxldCB2YWwgPSBhdHRycy5pZiB8fCBub29wO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWwsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgIGlmIChlcXVhbHModGhpcy52YWx1ZXNbaV0udmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudmFsdWVzW2ldLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICBpZiAoaSA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA8IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZm91bmQgPSBmaW5kSW5BcnJheSh0aGlzLnZhbHVlcywgKHsgdmFsdWUgfSkgPT4gKFxuICAgICAgICAgICAgZXF1YWxzKHZhbHVlLCBhcmdzLnZhbHVlKVxuICAgICAgICAgICkpO1xuXG4gICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gZm91bmQua2V5O1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kLnZhbHVlLmNoaWxkcmVuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXF1YWxzKHZhbCwgdmFsdWUpICYmIHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB2YWx1ZTogdmFsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9ID0gdGhpcy5hcmdzO1xuXG4gICAgICB0aGlzLmluZGV4ID0gSW5maW5pdHk7XG5cbiAgICAgIGl0ZXJhdGVBcnJheSh0aGlzLnZhbHVlcywgKHsgbmFtZSwgdmFsdWUsIGNoaWxkcmVuIH0sIGkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICA/IG5ld1ZhbHVlXG4gICAgICAgICAgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoZXF1YWxzKHZhbCwgbmV3VmFsdWUpICYmIHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBlcXVhbHModmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMSA9PT0gdmFsdWUyO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNTdHJpbmcsIGl0ZXJhdGVPYmplY3QsIGtleXMsXG4gIGNvbGxlY3RGcm9tT2JqZWN0LCBjb2xsZWN0RnJvbUFycmF5XG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYID0gL1xccyo7XFxzKi87XG5jb25zdCBDU1NfU1RZTEVfU0VQQVJBVE9SX1JFR0VYID0gL1xccyo6XFxzKi87XG5cbnJvb3RNaXhpbnNbJ2Qtc3R5bGUnXSA9IGNsYXNzIERTdHlsZSBleHRlbmRzIE1peGluIHtcbiAgY3NzID0ge307XG5cbiAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjc3NcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIChjc3MsIHByb3ApID0+IHtcbiAgICAgICAgY3NzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tQXJyYXkoXG4gICAgICAgIG5ld1ZhbHVlXG4gICAgICAgICAgLnNwbGl0KENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAubWFwKGNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyksXG4gICAgICAgIGFkZENTU1Byb3BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZU9iamVjdChjc3MsICh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCFuZXdWYWx1ZVtwcm9wXSkge1xuICAgICAgICBlbGVtLnJlbW92ZUNTUyhwcm9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtLmNzcyhuZXdWYWx1ZSk7XG5cbiAgICB0aGlzLmNzcyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBjc3NcbiAgICB9ID0gdGhpcztcblxuICAgIGVsZW0ucmVtb3ZlQ1NTLmFwcGx5KGVsZW0sIGtleXMoY3NzKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFkZENTU1Byb3AoY3NzLCBpdGVtKSB7XG4gIGNvbnN0IFtwcm9wLCB2YWx1ZV0gPSBpdGVtO1xuXG4gIGNzc1twcm9wXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RTdHlsZUZyb21TdHJpbmcoc3R5bGUpIHtcbiAgY29uc3Qgc3BsaXQgPSBzdHlsZS5zcGxpdChDU1NfU1RZTEVfU0VQQVJBVE9SX1JFR0VYKTtcblxuICByZXR1cm4gW1xuICAgIHNwbGl0WzBdLnRyaW0oKSxcbiAgICBzcGxpdFsxXS50cmltKClcbiAgXTtcbn1cbiIsImltcG9ydCB7XG4gIGlzRnVuY3Rpb24sIGlzTmlsLFxuICBjb2xsZWN0RnJvbUFycmF5XG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC12YWx1ZSddID0gY2xhc3MgRFZhbHVlIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBlbGVtXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmFtZSA9IGVsZW0ubmFtZSgpO1xuICAgIGNvbnN0IHR5cGUgPSBlbGVtLnByb3AoJ3R5cGUnKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGUoKTtcbiAgICBsZXQgaW5pdGlhbFNjb3BlVmFsdWUgPSBudWxsO1xuXG4gICAgdGhpcy5wcm9wID0gZ2V0UHJvcChuYW1lLCB0eXBlLCBlbGVtKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IGVsZW0uZmluZCgnb3B0aW9uJyk7XG4gICAgdGhpcy5zY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHRoaXMuc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbih0aGlzLnZhbHVlKSkge1xuICAgICAgaW5pdGlhbFNjb3BlVmFsdWUgPSB0aGlzLnNjb3BlLiQkLmV2YWx1YXRlKChzY29wZSkgPT4gc2NvcGVbdGhpcy52YWx1ZV0sIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICB0aGlzLnNldFByb3AobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsRWxlbVZhbHVlID0gdGhpcy5nZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlLCB0cnVlKTtcbiAgICBjb25zdCBpc0luaXRpYWxTY29wZVZhbHVlTnVsbCA9IGlzTmlsKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICBjb25zdCBpc0NoZWNrYm94ID0gdHlwZSA9PT0gJ2NoZWNrYm94JztcbiAgICBjb25zdCBjaGFuZ2VTY29wZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5nZXRQcm9wKHRoaXMuY3VycmVudFZhbHVlLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG4gICAgfTtcblxuICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxFbGVtVmFsdWU7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG5cbiAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xuICAgICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxTY29wZVZhbHVlO1xuICAgICAgdGhpcy5zZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lciA9IGVsZW0ub24oZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpLCBjaGFuZ2VTY29wZSk7XG4gICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIgPSBlbGVtLmNsb3Nlc3QoJ2Zvcm0nKS5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KGNoYW5nZVNjb3BlLCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNoYW5nZVNjb3BlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjb3BlLFxuICAgICAgdmFsdWUsXG4gICAgICBjdXJyZW50VmFsdWVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NvcGVbdmFsdWVdID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb3AodmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChwcm9wID09PSAndGV4dCcpIHtcbiAgICAgIGVsZW0udGV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jykge1xuICAgICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnByb3AocHJvcCwgZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBub2RlLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvcCh2YWx1ZXMsIGluaXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiBwcm9wID09PSAndGV4dCdcbiAgICAgID8gZWxlbS50ZXh0KClcbiAgICAgIDogZ2V0VmFsdWVGb3JHZXR0aW5nKG5hbWUsIGVsZW0ucHJvcChwcm9wKSwgdHlwZSwgbm9kZS52YWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jyk7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5vZmZFbGVtTGlzdGVuZXIoKTtcbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lcigpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignbXVsdGlwbGUnKVxuICAgICAgICA/ICdtdWx0aXBsZS1zZWxlY3QnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgcmV0dXJuICdmaWxlcyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICAgICAgPyAnY2hlY2tlZCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBlbGVtLmhhc0F0dHIoJ2NvbnRlbnRFZGl0YWJsZScpXG4gICAgICAgID8gJ3RleHQnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlKSB7XG4gIGlmIChuYW1lICE9PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgaXNSYWRpbyA9IHR5cGUgPT09ICdyYWRpbyc7XG5cbiAgaWYgKCFpc1JhZGlvICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gaXNSYWRpb1xuICAgID8gdmFsdWUgPT09IGlucHV0VmFsdWVcbiAgICA6IHZhbHVlLmluZGV4T2YoaW5wdXRWYWx1ZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUsIHZhbHVlcywgb3B0aW9ucywgaW5pdCwgaXNNdWx0aXBsZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShvcHRpb25zLCBhZGRWYWx1ZSwgW10pO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgIT09ICdyYWRpbycgJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgID8gaW5wdXRWYWx1ZVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtdO1xuXG4gICAgICBpZiAoIXZhbHVlICYmIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKSA9PT0gLTFcbiAgICAgICAgICA/IHZhbHVlcy5jb25jYXQoaW5wdXRWYWx1ZSlcbiAgICAgICAgICA6IHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIC4uLnZhbHVlcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyTmFtZShuYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIHJldHVybiAnY2hhbmdlJztcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHR5cGUgPT09ICdyYWRpbydcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICB8fCB0eXBlID09PSAnY29sb3InXG4gICAgICAgIHx8IHR5cGUgPT09ICdmaWxlJ1xuICAgICAgKVxuICAgICAgICA/ICdjaGFuZ2UnXG4gICAgICAgIDogJ2NoYW5nZSBpbnB1dCc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuICdpbnB1dCc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKHZhbHVlcywgeyBzZWxlY3RlZCwgdmFsdWUgfSkge1xuICBpZiAoc2VsZWN0ZWQgJiYgdmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgdG9PYmplY3RLZXlzLFxuICBhc3NpZ24sIGtleXMsIGNyZWF0ZVxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFRlbXBsYXRlcyh0ZW1wbGF0ZSwgdGVtcGxhdGVzKSB7XG4gIGNvbnN0IHtcbiAgICB2YXJzLFxuICAgIHZhbHVlXG4gIH0gPSB0ZW1wbGF0ZTtcbiAgY29uc3QgbmV3VGVtcGxhdGVzID0gY3JlYXRlKG51bGwpO1xuICBjb25zdCBuZXdWYXJzID0gdG9PYmplY3RLZXlzKHZhcnMpO1xuXG4gIGFzc2lnbihuZXdUZW1wbGF0ZXMsIHRlbXBsYXRlcyk7XG4gIGl0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbih2YWx1ZSk7XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuKG5vZGVzID0gW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICAgIGlmIChuZXdUZW1wbGF0ZXNbdHJpbW1lZF0pIHtcbiAgICAgICAgICBjb25zdCBuZXdUZW1wbGF0ZSA9IG5ld1RlbXBsYXRlc1t0cmltbWVkXS52YWx1ZTtcblxuICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uZXdUZW1wbGF0ZSk7XG4gICAgICAgICAgYXNzaWduKG5ld1ZhcnMsIHRvT2JqZWN0S2V5cyhuZXdUZW1wbGF0ZXNbdHJpbW1lZF0udmFycykpO1xuXG4gICAgICAgICAgaSArPSBuZXdUZW1wbGF0ZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhcnMubGVuZ3RoID0gMDtcbiAgdmFycy5wdXNoKC4uLmtleXMobmV3VmFycykpO1xuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi9CbG9jayc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFwcChjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbSA9IG5ldyBFbGVtKGNvbnRhaW5lcikuZWxlbSgwKTtcblxuICBpZiAoIWVsZW0ubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBlbGVtZW50IHRvIHJlbW92ZSB0aGUgYXBwIGZyb20gd2FzIGdpdmVuISAocmVtb3ZlQXBwKScpO1xuICB9XG5cbiAgY29udGFpbmVyID0gZWxlbVswXTtcblxuICBjb25zdCB7IER3YXluZVJvb3RCbG9jayB9ID0gY29udGFpbmVyO1xuXG4gIGlmICghKER3YXluZVJvb3RCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYXBwIHJlZ2lzdGVyZWQgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAocmVtb3ZlQXBwKScpO1xuICB9XG5cbiAgRHdheW5lUm9vdEJsb2NrLiQkLnJlbW92ZSgpO1xuICBlbGVtLnJlbW92ZUF0dHIoJ2R3YXluZS1yb290Jyk7XG5cbiAgZGVsZXRlIGNvbnRhaW5lci5Ed2F5bmVSb290QmxvY2s7XG59XG4iLCIvKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cbi8qIGVzbGludCBuby1uZWdhdGVkLWNvbmRpdGlvbjogMCAqL1xuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbiIsImV4cG9ydCBjb25zdCB7XG4gIGNyZWF0ZSxcbiAga2V5cyxcbiAgZ2V0UHJvdG90eXBlT2Y6IGdldFByb3RvXG59ID0gT2JqZWN0O1xuXG5leHBvcnQgY29uc3Qgc2V0UHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCh0YXJnZXQsIHByb3RvKSA9PiB7XG4gIC8qIGVzbGludCBuby1wcm90bzogMCAqL1xuICB0YXJnZXQuX19wcm90b19fID0gcHJvdG87XG59KTtcbiIsImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJy4vdXRpbHMvb2JqZWN0U3RhdGljcyc7XG5cbmV4cG9ydCBjb25zdCBISURFX0NMQVNTID0gJ19fZHdheW5lLWhpZGRlbl9fJztcbmV4cG9ydCBjb25zdCBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuZXhwb3J0IGNvbnN0IERfUkVTVF9SRUdFWCA9IC9eZC1yZXN0KD86I3wkKS87XG5cbmV4cG9ydCBjb25zdCByb290QmxvY2tzID0gY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IHJvb3RNaXhpbnMgPSBjcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgU2NvcGUgPSB7XG4gIGV2YWxNb2RlOiBmYWxzZSxcbiAgZ2V0dGluZ1ZhcnM6IFtdXG59O1xuZXhwb3J0IGNvbnN0IHtcbiAgZG9jdW1lbnQgPSB7fVxufSA9IGdsb2JhbDtcbiIsImltcG9ydCB7XG4gIGlzTmlsLCBpc1N0cmluZywgYXNzaWduLFxuICBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzLCBkZWZpbmVQcm9wZXJ0aWVzLFxuICBjb2xsZWN0RnJvbUFycmF5LCBjb2xsZWN0RnJvbU9iamVjdCxcbiAgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICB0b0h5cGhlbkNhc2UsIHRvU3RyaW5nVGFnLFxuICBzZXRUb1N0cmluZ1RhZywgc2V0UHJvdG9cbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge1xuICBpc0hUTUxEb2N1bWVudCwgaXNWYWxpZE5vZGUsXG4gIGFkZEF0dHIsIGFkZENTU1Byb3AsIGFkZERhdGFBdHRyLFxuICBhZGROZXh0LCBhZGRQYXJlbnQsIGFkZFByZXYsXG4gIHRvRWxlbSwgaXNFbGVtZW50c0NvbGxlY3Rpb24sXG4gIGdldEF0dHJOUywgaGlkZSwgc2hvdywgcmVtb3ZlXG59IGZyb20gJy4vaGVscGVycy9FbGVtJztcbmltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd9IEVsZW1FdmVudFN0cmluZ1xuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIGNvbnRhaW5pbmcgZXZlbnRzIHNlcGFyYXRlZCBieSBhIGNvbW1hIHdpdGggemVybyBvciBtb3JlIHNwYWNlcyBvciBqdXN0IHNwYWNlcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtTGlzdGVuZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBGaXJlZCBldmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtUmVtb3ZlTGlzdGVuZXJzXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gey4uLkVsZW1FdmVudFN0cmluZ30gZXZlbnRzIC0gSWYgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IHByZXNlbnQgb25seSByZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBldmVudHMgaW4gdGhlIGFyZ3VtZW50cy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9IG5vZGUgLSBJdGVyYXRpb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEl0ZXJhdGlvbiBpbmRleC5cbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEluaXRpYWwgc2V0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1NZXRob2RcbiAqIEBwdWJsaWNcbiAqIEB0aGlzIEVsZW1cbiAqL1xuXG5jb25zdCB7IFN5bWJvbCB9ID0gZ2xvYmFsO1xuY29uc3QgRVZFTlRfU0VQQVJBVE9SX1JFR0VYID0gLyg/Oix8ICkgKi87XG5jb25zdCBDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWCA9IC87ID8vO1xuY29uc3QgQ1NTX0lNUE9SVEFOVF9SRUdFWCA9IC8gPyFpbXBvcnRhbnQkLztcbmNvbnN0IEVWRU5UX1JFR0VYID0gL0V2ZW50JC87XG5jb25zdCBYSFRNTF9OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbmNvbnN0IGVtcHR5Q29sbGVjdGlvbiA9IFtdO1xuXG4vKipcbiAqIEBjbGFzcyBFbGVtXG4gKiBAZXh0ZW5kcyBBcnJheS48RWxlbWVudHxOb2RlPlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gW2VsZW0gPSBbXV0gLSBBbiBlbGVtZW50IG9yIGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RWxlbX0gSW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFuIGVsZW1lbnRzIHNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG4gKiBuZXcgRWxlbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2xzJykpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xzJykpO1xuICovXG5jbGFzcyBFbGVtIGV4dGVuZHMgQXJyYXkge1xuICAvKipcbiAgICogQG1ldGhvZCBFbGVtLmFkZE1ldGhvZHNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgRWxlbU1ldGhvZD59IG1ldGhvZE5hbWUgLSBOYW1lIG9mIHRoZSBtZXRob2Qgb3Igb2JqZWN0IG9mXG4gICAqIG1ldGhvZCBuYW1lcyBhbmQgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtFbGVtTWV0aG9kfSBbbWV0aG9kXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyB0aGlzIHNob3VsZCBiZSB0aGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybnMge3R5cGVvZiBFbGVtfVxuICAgKi9cbiAgc3RhdGljIGFkZE1ldGhvZHMobWV0aG9kTmFtZSwgbWV0aG9kKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgbWV0aG9kTmFtZSA9IHsgW21ldGhvZE5hbWVdOiBtZXRob2QgfTtcbiAgICB9XG5cbiAgICBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRoaXMucHJvdG90eXBlLCBtZXRob2ROYW1lKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbSA9IGVtcHR5Q29sbGVjdGlvbikge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICBlbGVtID0gW2VsZW1dO1xuICAgIH1cblxuICAgIHNldFByb3RvKHRoaXMsIEVsZW0ucHJvdG90eXBlKTtcblxuICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgaWYgKCFpc0VsZW1lbnRzQ29sbGVjdGlvbihlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlQXJyYXkoZWxlbSwgKGVsZW0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVzKGVsZW0pICYmIGlzVmFsaWROb2RlKGVsZW0pKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYWRkXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4oRWxlbXxFbGVtZW50fEVsZW1lbnRbXSl9IGVsZW1lbnRzIC0gRWFjaCBhcmd1bWVudCBpcyBhIEVsZW0sIG9yIEVsZW1lbnQsIG9yIGFycmF5IG9mIEVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgbmV3IGVsZW1lbnRzIHRvIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0xLmZpbmQoJy5jbHMxJylcbiAgICogICAuYWRkKGVsZW0yLmZpbmQoJy5jbHMyJykpXG4gICAqICAgLmhpZGUoKTtcbiAgICovXG4gIGFkZCgpIHtcbiAgICBjb25zdCBlbGVtcyA9IHRoaXMuc2xpY2UoKTtcblxuICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIWVsZW1zLmluY2x1ZGVzKGVsZW0pICYmIGlzVmFsaWROb2RlKGVsZW0pKSB7XG4gICAgICAgICAgZWxlbXMucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWxlbXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2FkZENsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGNsYXNzZXMgLSBDbGFzc2VzIHRvIGFkZC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIGNsYXNzZXMgdG8gdGhlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygncmVkJywgJ3JvdW5kJyk7XG4gICAqL1xuICBhZGRDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChjbHMpID0+IGxpc3QuYWRkKGNscykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFthdHRyXSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBnZXQgb3JcbiAgICogYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gICAqIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBhdHRyaWJ1dGVzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQsIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHIxJywgJ3ZhbHVlMScpOyAvLyBhdHRyaWJ1dGUgYXR0cjEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uYXR0cignYXR0cjEnKTsgICAgICAgICAgIC8vICd2YWx1ZTEnXG4gICAqIGVsZW0uYXR0cih7XG4gICAqICAgYXR0cjE6ICd2YWx1ZTMnLCAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMydcbiAgICogICBhdHRyMjogJ3ZhbHVlMicgICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uYXR0cigpOyAgICAgICAgICAgICAgICAgIC8vIHsgYXR0cjE6ICd2YWx1ZTMnLCBhdHRyMjogJ3ZhbHVlMicgfVxuICAgKi9cbiAgYXR0cihhdHRyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShlbGVtLmF0dHJpYnV0ZXMsIGFkZEF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcoYXR0cikpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBucyxcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgICAgcmV0dXJuIG5zXG4gICAgICAgID8gZWxlbS5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSlcbiAgICAgICAgOiBlbGVtLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBhdHRyID0geyBbYXR0cl06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChhdHRyLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVBdHRyKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZTtcblxuICAgICAgICBjb25zdCB7IG5zIH0gPSBnZXRBdHRyTlMoa2V5LCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZU5TKG5zLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NoaWxkcmVuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IEQtV3JhcCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBlbGVtZW50J3MgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbigpO1xuICAgKi9cbiAgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXMubGVuZ3RoID8gdGhpc1swXS5jaGlsZE5vZGVzIDogW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjbG9zZXN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjY2xvc2VzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdH0uXG4gICAqL1xuICBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb2xsZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBjYiA9IDo6ZWxlbWVudHMucHVzaDtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNiLCBlbGVtLCBpbmRleCwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVsZW0oZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjb250YWluc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgYXJndW1lbnQgd2l0aGluIHRoaXMgZWxlbWVudC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBleHRlbnNpb24gZm9yXG4gICAqIFtOb2RlI2NvbnRhaW5zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcbiAgICovXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzWzBdO1xuICAgIGNvbnN0IGNoaWxkID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgcmV0dXJuICFwYXJlbnQgfHwgIWNoaWxkXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIElmIHR5cGUgaXMgXCIjY29tbWVudFwiIGEgY29tbWVudCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSAtIHdyYXAgb2YgdGhlIGNyZWF0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgZWxlbWVudCBpcyBqdXN0IGNyZWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKTtcbiAgICovXG4gIGNyZWF0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBsZXQgZWwgPSBudWxsO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdHlwZSA9PT0gJyN0ZXh0JztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gaXNIVE1MRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBpZiAoaXNUZXh0IHx8IHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgZWwgPSBpc1RleHRcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBucyA9IHR5cGUgPT09ICdzdmcnXG4gICAgICAgICAgPyBTVkdfTlNcbiAgICAgICAgICA6IGVsZW0ubmFtZXNwYWNlVVJJIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgfHwgWEhUTUxfTlM7XG5cbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBhZGQobmV3IEVsZW0oZWwpLmludG8oZWxlbSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVDb21tZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGNvbW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBjb21tZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGNvbW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZUNvbW1lbnQoJ2NvbW1lbnQnKTtcbiAgICovXG4gIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAuY3JlYXRlKCcjY29tbWVudCcpXG4gICAgICAudGV4dCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlVGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCB0ZXh0IG5vZGVzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyB0ZXh0IG5vZGVzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgdGV4dCBub2RlIGlzIGp1c3QgY3JlYXRlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGVUZXh0KCd0ZXh0Jyk7XG4gICAqL1xuICBjcmVhdGVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpc1xuICAgICAgLmNyZWF0ZSgnI3RleHQnKVxuICAgICAgLnRleHQodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBzdHlsZXMuIFN1cHBvcnRzICFpbXBvcnRhbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTsgLy8gZGlzcGxheSBzZXQgdG8gJ25vbmUnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBkaXNwbGF5OiAnaW5saW5lJywgICAgICAgICAvLyBkaXNwbGF5IHNldCB0byAnaW5saW5lJ1xuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygpOyAgICAgICAgICAgICAgICAgIC8vIHsgZGlzcGxheTogJ25vbmUnLCBjdXJzb3I6ICdwb2ludGVyJyB9XG4gICAqL1xuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KHN0eWxlLmNzc1RleHQuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpLCBhZGRDU1NQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpICsgKHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpID8gJyAhaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgdmFsdWUucmVwbGFjZShDU1NfSU1QT1JUQU5UX1JFR0VYLCAnJyksXG4gICAgICAgICAgQ1NTX0lNUE9SVEFOVF9SRUdFWC50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtrZXldIC0gTmFtZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgKHdpdGhvdXQgZGF0YS0gcHJlZml4KVxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBkYXRhc2V0IG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgZGF0YSBhdHRyaWJ1dGVzLiBTZWVcbiAgICogW0hUTUxFbGVtZW50I2RhdGFzZXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9kYXRhc2V0fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScsICd2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnKTsgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5kYXRhKHtcbiAgICogICBzb21lS2V5MTogJ3ZhbHVlMycsICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTMnXG4gICAqICAgc29tZUtleTI6ICd2YWx1ZTInICAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCk7ICAgICAgICAgICAgICAgICAgICAvLyB7IHNvbWVLZXkxOiAndmFsdWUzJywgc29tZUtleTI6ICd2YWx1ZTInIH1cbiAgICovXG4gIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGRhdGFzZXQsIGFkZERhdGFBdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YXNldFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChrZXksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGlzcGF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudH0gZXZlbnQgLSBFdmVudCBvciBhIHN0cmluZyAobmV3IEV2ZW50KGV2ZW50KSBpcyBjcmVhdGVkKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0V2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snKTtcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UsIGRhdGE6IDEgfSk7XG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XG4gICAqL1xuICBkaXNwYXRjaChldmVudCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYnViYmxlcyA9IHRydWUsXG4gICAgICBjYW5jZWxhYmxlID0gdHJ1ZSxcbiAgICAgIC4uLnJlYWxEZXRhaWxzXG4gICAgfSA9IGRldGFpbHM7XG4gICAgbGV0IGZpbmFsRXZlbnQgPSBldmVudDtcblxuICAgIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmFsRXZlbnQgPSBuZXcgRXZlbnQoZmluYWxFdmVudCwgeyBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xuICAgICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0hUTUxEb2N1bWVudChlbGVtKVxuICAgICAgICAgID8gZWxlbVxuICAgICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIGZpbmFsRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG4gICAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChmaW5hbEV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZWxlbVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXggPSAwXSAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9mIHRoZSBzZXQgdG8gZ2V0LiBOZWdhdGl2ZSBpbmRleCBtZWFucyBlbGVtLmxlbmd0aCArIGluZGV4LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZWxlbSgxKTsgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMVxuICAgKiBlbGVtLmVsZW0oKTsgIC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDBcbiAgICovXG4gIGVsZW0oaW5kZXggPSAwKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCArIGluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzW2luZGV4XSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbHRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtmaWx0ZXJGbiA9IEJvb2xlYW5dIC0gRmlsdGVyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmZpbHRlcigoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuY2xvc2VzdCgnLnBhcmVudCcpKTtcbiAgICovXG4gIGZpbHRlcihmaWx0ZXJGbiA9IEJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZmlsdGVyRm4oZWxlbSwgaW5kZXgsIHRoaXMpKSB7XG4gICAgICAgIGFkZChlbGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZmluZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFbGVtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKi9cbiAgZmluZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgYWRkKGZpbmQoc2VsZWN0b3IsIGVsZW0pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZm9yRWFjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBmaW5kKCcuY2xzJykuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgsIHNldCkgPT4ge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZ1xuICAgKiB9KTtcbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBpdGVyYXRlQXJyYXkodGhpcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGNhbGxiYWNrKHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hhc0F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHInLCAndmFsdWUnKS5oYXNBdHRyKCdhdHRyJyk7IC8vIHRydWVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdhdHRyJykuaGFzQXR0cignYXR0cicpOyAgICAvLyBmYWxzZVxuICAgKi9cbiAgaGFzQXR0cihhdHRyKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG5zIH0gPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICByZXR1cm4gbnNcbiAgICAgID8gZWxlbS5oYXNBdHRyaWJ1dGVOUyhucywgYXR0cilcbiAgICAgIDogZWxlbS5oYXNBdHRyaWJ1dGUoYXR0cik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hhc0NsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNscyAtIE5hbWUgb2YgdGhlIGNsYXNzLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGNsYXNzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgcmV0dXJucyBpZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3Mgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmFkZENsYXNzKCdjbHMnKS5oYXNDbGFzcygnY2xzJyk7ICAgIC8vIHRydWVcbiAgICogZWxlbS5yZW1vdmVDbGFzcygnY2xzJykuaGFzQ2xhc3MoJ2NscycpOyAvLyBmYWxzZVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xzKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICByZXR1cm4gZWxlbVxuICAgICAgPyBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhjbHMpXG4gICAgICA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoaWRlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEhpZGVzIGFsbCBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmhpZGUoKTtcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChoaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaHRtbFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFtodG1sXSAtIEhUTUwgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IEhUTUwuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCBIVE1MIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgSFRNTCBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIGh0bWwgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgSFRNTC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5odG1sKCc8ZGl2PjE8L2Rpdj4nKTtcbiAgICogZWxlbS5odG1sKCk7IC8vICc8ZGl2PjE8L2Rpdj4nXG4gICAqL1xuICBodG1sKGh0bWwpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICByZXR1cm4gZWxlbVxuICAgICAgICA/IGVsZW0uaW5uZXJIVE1MXG4gICAgICAgIDogJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9XG5cbiAgaW5jbHVkZXMoZWxlbSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbSkgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnNlcnRBZnRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGFmdGVyLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUHV0cyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGFmdGVyIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQuXG4gICAqIFRoZSBlbGVtZW50cyByZW1haW4gaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnNlcnRBZnRlcignI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0KClbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaWYgKGVsZW0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnNlcnRCZWZvcmVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gaW5zZXJ0IHRoaXMgZWxlbWVudCBiZWZvcmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYmVmb3JlIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQuXG4gICAqIFRoZSBlbGVtZW50cyByZW1haW4gaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKGVsZW0yKTtcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZSgnI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgaW5zZXJ0QmVmb3JlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpLmVsZW0oMCk7XG5cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnRbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtLCBlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaW50b1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBwdXQgdGhpcyBlbGVtZW50cyBpbnRvLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgdGhleSBhcmUgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjYXBwZW5kQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2FwcGVuZENoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnRvKGVsZW0yKTtcbiAgICogZWxlbS5pbnRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnRvKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnRvKGVsZW1lbnQsIGVuZCA9IHRydWUpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgaWYgKFxuICAgICAgIWVsZW1lbnRcbiAgICAgIHx8IGlzSFRNTERvY3VtZW50KGVsZW1lbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWVuZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXNbaV0sIGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2lzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjbWF0Y2hlc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gdHJ1ZVxuICAgKlxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKTtcbiAgICogZWxlbS5pcygnLmNscycpOyAgICAgICAgIC8vIGZhbHNlXG4gICAqL1xuICBpcyhzZWxlY3Rvcikge1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcbiAgICBjb25zdCBtYXRjaGVzID0gKFxuICAgICAgZWxlbS5tYXRjaGVzXG4gICAgICB8fCBlbGVtLm1hdGNoZXNTZWxlY3RvclxuICAgICAgfHwgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgICAgIHx8IGVsZW0ubW96TWF0Y2hlc1NlbGVjdG9yXG4gICAgICB8fCBlbGVtLm1zTWF0Y2hlc1NlbGVjdG9yXG4gICAgICB8fCBlbGVtLm9NYXRjaGVzU2VsZWN0b3JcbiAgICApO1xuXG4gICAgcmV0dXJuIGVsZW06Om1hdGNoZXMoc2VsZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNuYW1lXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cmluZ3x2b2lkfSBub2RlTmFtZSAobG93ZXJjYXNlZCkgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBuYW1lIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKS5uYW1lKCkgLy8gJ2RpdidcbiAgICovXG4gIG5hbWUoKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICByZXR1cm4gZWxlbVxuICAgICAgPyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNuZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5uZXh0KCk7IC8vIGZpbmRzIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZE5leHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNvblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbUV2ZW50U3RyaW5nfE9iamVjdC48RWxlbUV2ZW50U3RyaW5nfEVsZW1MaXN0ZW5lcj59IGV2ZW50IC0gRWl0aGVyIGEge0BsaW5rIEVsZW1FdmVudFN0cmluZ30gc3RyaW5nXG4gICAqIG9yIGFuIG9iamVjdCB3aXRoIGV2ZW50IGtleXMgKGEga2V5IGlzIGFsc28gRWxlbUV2ZW50U3RyaW5nKSBhbmQgbGlzdGVuZXJzIHZhbHVlcy5cbiAgICogQHBhcmFtIHtFbGVtTGlzdGVuZXJ9IFtsaXN0ZW5lcl0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgaXQgbXVzdCBiZSBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZvclxuICAgKiBzcGVjaWZpZWQgZXZlbnQocykuXG4gICAqIEByZXR1cm5zIHtFbGVtUmVtb3ZlTGlzdGVuZXJzfSBGdW5jdGlvbiB0aGF0IHRha2VzIG9wdGlvbmFsIGV2ZW50IGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5vbihcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXG4gICAqICAgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBkYXRhbGlzdCwga2V5Z2VuLCBvdXRwdXQnLFxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcbiAgICogKTtcbiAgICogZWxlbS5vbihcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXG4gICAqICAgKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKVxuICAgKiApO1xuICAgKiBlbGVtLm9uKFxuICAgKiAgIHtcbiAgICogICAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcbiAgICogICAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiAgIH0sXG4gICAqICAgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBkYXRhbGlzdCwga2V5Z2VuLCBvdXRwdXQnXG4gICAqICk7XG4gICAqXG4gICAqIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9IGVsZW0ub24oe1xuICAgKiAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcbiAgICogICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcbiAgICogfSk7XG4gICAqXG4gICAqIHJlbW92ZUxpc3RlbmVycygnY2xpY2snKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnLCAnaW5wdXQnKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAqL1xuICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoZXZlbnQpKSB7XG4gICAgICBldmVudCA9IHsgW2V2ZW50XTogbGlzdGVuZXIgfTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdFdmVudHMgPSB7fTtcbiAgICBjb25zdCBhbGxMaXN0ZW5lcnMgPSB7fTtcblxuICAgIGl0ZXJhdGVPYmplY3QoZXZlbnQsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShldmVudC5zcGxpdChFVkVOVF9TRVBBUkFUT1JfUkVHRVgpLCAoZXZlbnQpID0+IHtcbiAgICAgICAgKG5ld0V2ZW50c1tldmVudF0gPSBuZXdFdmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KG5ld0V2ZW50cywgKGxpc3RlbmVycywgZXZlbnQpID0+IHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGxpc3RlbmVycywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgIChhbGxMaXN0ZW5lcnNbZXZlbnRdID0gYWxsTGlzdGVuZXJzW2V2ZW50XSB8fCBbXSkucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhldmVudCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gYWxsTGlzdGVuZXJzW2V2ZW50XTtcblxuICAgICAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkocmVtb3ZlTGlzdGVuZXJzLCAocmVtb3ZlTGlzdGVuZXIpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuXG4gICAgICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVPYmplY3QoYWxsTGlzdGVuZXJzLCAocmVtb3ZlTGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICBkZWxldGUgYWxsTGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcGFyZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHJldHVybnMgd3JhcCBvZiB0aGUgc2V0IG9mIHRoZSBwYXJlbnQgZWxlbWVudHMgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqL1xuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGRQYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwcmV2XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJldigpOyAvLyBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBwcmV2KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkUHJldik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3Byb3BcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgKj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gYXNzaWduZWQgb2JqZWN0LlxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZ1xuICAgKiB0aGlzIGhhcyB0byBiZSBhbiBhc3NpZ25lZCB2YWx1ZSBpZiBpdCdzIHByZXNlbnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfCp9IFJldHVybnMgdGhpcyBpZiBpdCdzIHNldHRlciBvciBhIHZhbHVlIGlmIGdldHRlci5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IGlzIGVpdGhlciBhIHByb3BlcnR5IGdldHRlciBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiBvciBhIHNldHRlciBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScsIGZhbHNlKTtcbiAgICogZWxlbS5wcm9wKCdkcmFnZ2FibGUnKTsgLy8gZmFsc2VcbiAgICovXG4gIHByb3AocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXVtwcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgIGVsZW1bcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICogTm90ZTogaXQgZG9lc24ndCByZW1vdmUgdGhlbSBmcm9tIHRoZSBzZXQgc28gd2F0Y2ggb3V0IGZvciB0aGUgbWVtb3J5IGxlYWtzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZSgpO1xuICAgKi9cbiAgcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2gocmVtb3ZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdmb28nLCAnYmFyJywgJ2JheicpO1xuICAgKi9cbiAgcmVtb3ZlQXR0cigpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoYXR0cikgPT4ge1xuICAgICAgICBjb25zdCB7IG5zIH0gPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGVOUyhucywgYXR0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgY2xhc3NlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVDbGFzcygnZm9vJywgJ2JhcicsICdiYXonKTtcbiAgICovXG4gIHJlbW92ZUNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5yZW1vdmUoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNTU1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBwcm9wcyAtIENTUyBwcm9wZXJ0aWVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBDU1MgcHJvcGVydGllcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVDU1MoJ2Rpc3BsYXknLCAncG9zaXRpb24nLCAnbWFyZ2luJyk7XG4gICAqL1xuICByZW1vdmVDU1MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGNzcykgPT4ge1xuICAgICAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHRvSHlwaGVuQ2FzZShjc3MpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZXBsYWNlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHJlcGxhY2UgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiB3aXRoIGEgc2V0IG9mIGVsZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQgKEVsZW1lbnQgb3IgRWxlbSkuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNyZXBsYWNlQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL3JlcGxhY2VDaGlsZH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVwbGFjZShlbGVtMik7XG4gICAqIGVsZW0ucmVwbGFjZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0ucmVwbGFjZSgnI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgcmVwbGFjZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KTtcblxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5lbGVtKDApO1xuICAgIGNvbnN0IHBhcmVudCA9IGZpcnN0LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgZWxlbSA9IHBhcmVudDtcbiAgICBsZXQgbWV0aG9kID0gJ2ludG8nO1xuICAgIGNvbnN0IG5leHQgPSBmaXJzdC5uZXh0KClbMF07XG4gICAgY29uc3QgcHJldiA9IGZpcnN0LnByZXYoKVswXTtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBlbGVtID0gbmV4dDtcbiAgICAgIG1ldGhvZCA9ICdpbnNlcnRCZWZvcmUnO1xuICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgZWxlbSA9IHByZXY7XG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QWZ0ZXInO1xuICAgIH1cblxuICAgIGZpcnN0LnJlbW92ZSgpO1xuXG4gICAgZWxlbWVudFttZXRob2RdKGVsZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNzaG93XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFNob3dzIGFsbCBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKiBJZiBhbiBlbGVtZW50IHdhcyBoaWRkZW4gdXNpbmcge0BsaW5rIEVsZW0jaGlkZX0gcHJldmlvdXMgZGlzcGxheSBpcyBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uc2hvdygpO1xuICAgKi9cbiAgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKHNob3cpO1xuICB9XG5cbiAgc2xpY2UoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHN1cGVyLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0ZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW3RleHRdIC0gVGV4dCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgdGV4dC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHRleHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyB0ZXh0cyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIHRleHQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgdGV4dC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50ZXh0KCcxMjMnKTtcbiAgICogZWxlbS50ZXh0KCk7IC8vICcxMjMnXG4gICAqL1xuICB0ZXh0KHRleHQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AoJ3RleHRDb250ZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgYXR0cmlidXRlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFlbGVtLmhhc0F0dHIoYXR0cikgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdG9nZ2xlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gQ2xhc3MgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgY2xhc3NcbiAgICogYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgY2xhc3MuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXG4gICAqIHRoZSBjbGFzcyBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGNsYXNzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLnRvZ2dsZUNsYXNzKCdjbHMnLCBzb21lQ29uZGl0aW9uKTtcbiAgICovXG4gIHRvZ2dsZUNsYXNzKGNscywgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW07XG5cbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xzLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFjbGFzc0xpc3QuY29udGFpbnMoY2xzKSA6IGNvbmRpdGlvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoRWxlbSwgJ0VsZW0nKTtcblxuaWYgKFN5bWJvbCAmJiBTeW1ib2wuc3BlY2llcykge1xuICBkZWZpbmVQcm9wZXJ0aWVzKEVsZW0sIHtcbiAgICBbU3ltYm9sLnNwZWNpZXNdOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBBcnJheTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBFbGVtIH07XG4iLCJpbXBvcnQge1xuICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzLFxuICByZW1vdmVBcnJheUVsZW0sIHNldFRvU3RyaW5nVGFnXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgd3JhcE1peGluLCByZW1vdmVXYXRjaGVycyB9IGZyb20gJy4vaGVscGVycy9CbG9jayc7XG5cbmNsYXNzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQG1ldGhvZCBNaXhpbi53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIG1peGluLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIE1peGlufSBOZXcgbWl4aW4uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIG1peGlucy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIG1peGluIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gd3JhcHBlcnMucmVkdWNlKHdyYXBNaXhpbiwgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgY29tbWVudCxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCB3YXRjaGVycyA9IFtdO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAkJDoge1xuICAgICAgICBuYW1lLFxuICAgICAgICBfdmFsdWU6IHZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaXNEeW5hbWljOiBkeW5hbWljLFxuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICB3YXRjaGVycyxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgZXZhbHVhdGU6ICh3YXRjaGVyKSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaXNEeW5hbWljLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBfdmFsdWVcbiAgICAgICAgICB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpc0R5bmFtaWNcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoX3ZhbHVlKTtcblxuICAgICAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgICAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKGlzUGFyZW50U2lnbmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheUVsZW0ocGFyZW50QmxvY2suJCQubWl4aW5zLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBbTWl4aW4jYXJnc11cbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IFtNaXhpbiNjb21tZW50XVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudEJsb2NrXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRCbG9jayA9IHBhcmVudEJsb2NrO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QmxvY2t9IFtNaXhpbiNwYXJlbnRTY29wZV1cbiAgICAgKiBAdHlwZSB7QmxvY2t9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jsb2NrfSBbTWl4aW4jcGFyZW50VGVtcGxhdGVdXG4gICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtFbGVtfSBNaXhpbiNlbGVtXG4gICAgICogQHR5cGUge0VsZW19XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBNaXhpbiNub2RlXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMubm9kZSA9IGVsZW1bMF07XG5cbiAgICBwYXJlbnRCbG9jay4kJC5taXhpbnMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIGFmdGVyVXBkYXRlKCkge31cblxuICBiZWZvcmVSZW1vdmUoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtXYXRjaGVyfSBbY2FsbGJhY2tdIC0gSWYgcHJlc2VudCwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIG1peGluIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoY2FsbGJhY2spO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKE1peGluLCAnTWl4aW4nKTtcblxuZXhwb3J0IHsgTWl4aW4gfTtcbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcyxcbiAgYXNzaWduLCBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzRnVuY3Rpb24sIGlzQXJyYXksXG4gIHNldFRvU3RyaW5nVGFnLCBoYXNPd25Qcm9wZXJ0eSxcbiAgcmVtb3ZlQXJyYXlFbGVtLCBjcmVhdGUsXG4gIGdldFByb3RvLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGNvbnN0cnVjdE1peGluUmVnZXgsIGlzSW5zdGFuY2VPZixcbiAgcmVtb3ZlV2F0Y2hlcnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNsZWFuUHJvcGVydHksXG4gIHRyYW5zZm9ybVJlc3RBcmdzLCBjYWxjdWxhdGVBcmdzLCB3cmFwQmxvY2ssXG4gIHdhdGNoRm9yQWxsQXJncywgd2F0Y2hGb3JBbGxHbG9iYWxzLCB3YXRjaEZvckFsbExvY2Fsc1xufSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHtcbiAgRF9SRVNUX1JFR0VYLCBTY29wZSxcbiAgcm9vdEJsb2Nrcywgcm9vdE1peGluc1xufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBpbml0QXBwIH0gZnJvbSAnLi9pbml0QXBwJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi9NaXhpbic7XG5cbi8qKlxuICogQHR5cGVkZWYge0Vycm9yfSBFdmFsdWF0aW9uRXJyb3JcbiAqIEBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBleHByZXNzaW9uIC0gRXhwcmVzc2lvbiB3aGljaCBoYXMgYmVlbiBldmFsdWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBAcHJvcGVydHkge0Jsb2NrfSBibG9jayAtIEJsb2NrIGluIGNvbnRleHQgb2Ygd2hpY2ggdGhlIGV4cHJlc3Npb24gaGFzIGJlZW4gZXZhbHVhdGVkIHdpdGggdGhlIGVycm9yLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhdGNoZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFZhcnNXYXRjaGVyXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV3JhcHBlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHt0eXBlb2YgQmxvY2t8dHlwZW9mIE1peGlufSBCbG9jayBjbGFzcyB0byB3cmFwLlxuICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IEJsb2NrIGNsYXNzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEFmdGVyVXBkYXRlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gTmV3IHZhbHVlLlxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSAtIE9sZCB2YWx1ZS5cbiAqIEBwYXJhbSB7TWl4aW59IG1peGluIC0gTWl4aW4gaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQmxvY2tSZWdpc3Rlckhvb2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIEJsb2NrfSBCbG9jayAtIFJlZ2lzdGVyaW5nIGJsb2NrLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBuYW1lLlxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIHRoZSBibG9jay5cbiAqIElmIEJsb2NrIHN1YmNsYXNzIHJldHVybmVkIGl0J3MgcmVnaXN0ZXJlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsIGJsb2NrLCBvdGhlcndpc2VcbiAqIHRoZSBpbml0aWFsIGJsb2NrIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWl4aW5SZWdpc3Rlckhvb2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIE1peGlufSBNaXhpbiAtIFJlZ2lzdGVyaW5nIG1peGluLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBNaXhpbiBuYW1lLlxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIHRoZSBtaXhpbi5cbiAqIElmIE1peGluIHN1YmNsYXNzIHJldHVybmVkIGl0J3MgcmVnaXN0ZXJlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsIG1peGluLCBvdGhlcndpc2VcbiAqIHRoZSBpbml0aWFsIG1peGluIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVtb3ZlSG9va1xuICogQHB1YmxpY1xuICovXG5cbmNvbnN0IGJsb2NrSG9va3MgPSBbXTtcbmNvbnN0IG1peGluSG9va3MgPSBbXTtcbmNvbnN0IFRBR19OQU1FX1JFR0VYID0gL15bYS16XVthLXpcXGRcXC1fLjohQCMkJV4mKigpW1xcXXt9PSdcIlxcXFxdKiQvaTtcbmNvbnN0IEFUVFJfTkFNRV9SRUdFWCA9IC9eW15cXHUwMDAwLVxcdTAwMjBcXHMnXCI+Lz1dKyQvO1xuY29uc3QgV0FUQ0hFRF9BUkdfUFJFRklYX1JFR0VYID0gL15hcmdzXFwuLztcbmNvbnN0IFdBVENIRURfR0xPQkFMX1BSRUZJWF9SRUdFWCA9IC9eZ2xvYmFsc1xcLi87XG5jb25zdCBhZnRlckVsZW0gPSBuZXcgRWxlbSgpO1xuY29uc3Qgcm9vdFZhcnMgPSBbXTtcbmNvbnN0IHJvb3RUZW1wbGF0ZSA9IFtdO1xuXG4vKipcbiAqIEBjbGFzcyBCbG9ja1xuICogQGV4dGVuZHMgbnVsbFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBFbGVtZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7QmxvY2t9IEluc3RhbmNlIG9mIEJsb2NrLlxuICogQGRlc2NyaXB0aW9uIENsYXNzIGZvciBkeW5hbWljIHRlbXBsYXRpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEQsIEJsb2NrLCBpbml0QXBwIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiBjbGFzcyBBcHAgZXh0ZW5kcyBCbG9jayB7XG4gKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8SGVsbG8gdGV4dD1cInt0ZXh0fVwiLz4nO1xuICpcbiAqICAgY29uc3RydWN0b3Iob3B0cykge1xuICogICAgIHN1cGVyKG9wdHMpO1xuICpcbiAqICAgICB0aGlzLnRleHQgPSAnd29ybGQgKDApJztcbiAqICAgICB0aGlzLnRpbWVzID0gMDtcbiAqXG4gKiAgICAgdGhpcy5zZXRJbnRlcnZhbCgpO1xuICogICB9XG4gKlxuICogICBzZXRJbnRlcnZhbCgpIHtcbiAqICAgICBEKDEwMDApLmludGVydmFsKCgpID0+IHtcbiAqICAgICAgIHRoaXMudGV4dCA9IGB3b3JsZCAoJHsgKyt0aGlzLnRpbWVzIH0pYDtcbiAqICAgICB9KTtcbiAqICAgfVxuICogfVxuICpcbiAqIEJsb2NrLmJsb2NrKCdBcHAnLCBBcHApO1xuICogQmxvY2suYmxvY2soJ0hlbGxvJywgJ0hlbGxvLCB7YXJncy50ZXh0fSEnKTtcbiAqXG4gKiBpbml0QXBwKGh0bWxgPEFwcC8+YCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKSk7XG4gKi9cbmNsYXNzIEJsb2NrIHtcbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdC48U3RyaW5nLCB0eXBlb2YgQmxvY2s+fSBCbG9jay5fYmxvY2tzXG4gICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgdHlwZW9mIEJsb2NrPn1cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgbmFtZXNwYWNlIGJsb2Nrcy5cbiAgICovXG4gIHN0YXRpYyBfYmxvY2tzID0gY3JlYXRlKHJvb3RCbG9ja3MpO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPFN0cmluZywgdHlwZW9mIE1peGluPn0gQmxvY2suX21peGluc1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIHR5cGVvZiBNaXhpbj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIG5hbWVzcGFjZSBtaXhpbnMuXG4gICAqL1xuICBzdGF0aWMgX21peGlucyA9IGNyZWF0ZShyb290TWl4aW5zKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nW119IEJsb2NrLl92YXJzXG4gICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgdXNlZCBsb2NhbCB2YXJzLlxuICAgKi9cbiAgc3RhdGljIF92YXJzID0gcm9vdFZhcnM7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdFtdfSBCbG9jay5faHRtbFxuICAgKiBAdHlwZSB7T2JqZWN0W119XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIHRlbXBsYXRlLlxuICAgKi9cbiAgc3RhdGljIF9odG1sID0gcm9vdFRlbXBsYXRlO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay5kZWZhdWx0QXJncyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRlZmF1bHQgYXJncy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0QXJncyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLmRlZmF1bHRMb2NhbHMgPSBudWxsXVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkZWZhdWx0IGxvY2Fscy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0TG9jYWxzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2sudGVtcGxhdGUgPSB7IHZhcnM6IFtdLCB2YWx1ZTogW10gfV1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgdGVtcGxhdGUuXG4gICAqL1xuICBzdGF0aWMgdGVtcGxhdGUgPSB7XG4gICAgdmFyczogW10sXG4gICAgdmFsdWU6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sub25FdmFsRXJyb3JcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0V2YWx1YXRpb25FcnJvcn0gZXJyIC0gVGhlIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBhbiBldmFsdWF0aW9uIGVycm9yIG9jY3Vycy5cbiAgICovXG4gIHN0YXRpYyBvbkV2YWxFcnJvcihlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFdmFsIGVycm9yIChldmFsdWF0aW5nIFwiJHsgZXJyLm9yaWdpbmFsIHx8IGVyci5leHByZXNzaW9uIH1cIiBpbiBjb250ZXh0IG9mIGJsb2NrIFwiJHsgZXJyLmJsb2NrLiQkLm5hbWUgfVwiKTpgLCBlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmVmb3JlUmVnaXN0ZXJCbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7QmxvY2tSZWdpc3Rlckhvb2t9IGhvb2sgLSBCbG9jayByZWdpc3RlciBob29rLlxuICAgKiBAcmV0dXJucyB7UmVtb3ZlSG9va31cbiAgICovXG4gIHN0YXRpYyBiZWZvcmVSZWdpc3RlckJsb2NrKGhvb2spIHtcbiAgICBibG9ja0hvb2tzLnB1c2goaG9vayk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlQXJyYXlFbGVtKGJsb2NrSG9va3MsIGhvb2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5iZWZvcmVSZWdpc3Rlck1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtNaXhpblJlZ2lzdGVySG9va30gaG9vayAtIE1peGluIHJlZ2lzdGVyIGhvb2suXG4gICAqL1xuICBzdGF0aWMgYmVmb3JlUmVnaXN0ZXJNaXhpbihob29rKSB7XG4gICAgbWl4aW5Ib29rcy5wdXNoKGhvb2spO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlbW92ZUFycmF5RWxlbShtaXhpbkhvb2tzLCBob29rKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmxvY2tcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG9yIG1peGluIG5hbWUuXG4gICAqIEBwYXJhbSB7VGVtcGxhdGV8dHlwZW9mIEJsb2NrfSBTdWJjbGFzcyAtIFN1YmNsYXNzIG9mIEJsb2NrIG9yIHRlbXBsYXRlIHN0cmluZyBvZiBpdC5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja3x1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBCbG9jayBvciB1bmRlZmluZWQgaWYgdGhlIGJsb2NrIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBibG9jayBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgYmxvY2sobmFtZSwgU3ViY2xhc3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgIWlzSW5zdGFuY2VPZihCbG9jaywgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IFN1YmNsYXNzO1xuXG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgICBzdGF0aWMgdGVtcGxhdGUgPSBjb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgICAgdGhpczo6Y29uc3RydWN0b3Iob3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiBpc0FycmF5KFN1YmNsYXNzKSkge1xuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgICAgc3RhdGljIHRlbXBsYXRlID0ge1xuICAgICAgICAgIHZhcnM6IFtdLFxuICAgICAgICAgIHZhbHVlOiBTdWJjbGFzc1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU3ViY2xhc3MpICYmIFN1YmNsYXNzLnZhcnMgJiYgU3ViY2xhc3MudmFsdWUpIHtcbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IFN1YmNsYXNzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSW5zdGFuY2VPZihCbG9jaywgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEJsb2NrIG11c3QgYmUgYSB0ZW1wbGF0ZSAoYXJyYXkgb3IgYW4gb2JqZWN0IGZyb20gYW4gaHRtbCBsb2FkZXIpLCBhIGZ1bmN0aW9uIG9yIGEgY2xhc3MgdGhhdCBleHRlbmRzIEJsb2NrIGNsYXNzIChuYW1lOiBcIiR7IG5hbWUgfVwiKSAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocm9vdEJsb2Nrc1tuYW1lXSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBibG9jayBpcyBhIGJ1aWx0LWluIGJsb2NrIHNvIHRoZSBibG9jayB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5ibG9jaylgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghVEFHX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIGJsb2NrcyBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdfYmxvY2tzJykpIHtcbiAgICAgIHRoaXMuX2Jsb2NrcyA9IGNyZWF0ZShnZXRQcm90byh0aGlzKS5fYmxvY2tzKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdkZWZhdWx0TG9jYWxzJykpIHtcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FscyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ2RlZmF1bHRBcmdzJykpIHtcbiAgICAgIHRoaXMuZGVmYXVsdEFyZ3MgPSBjcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIFN1YmNsYXNzID0gYmxvY2tIb29rcy5yZWR1Y2UoKHJldHVyblZhbHVlLCBob29rKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZXR1cm5WYWx1ZSA9IGhvb2socmV0dXJuVmFsdWUsIG5hbWUsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIGN1cnJlbnRSZXR1cm5WYWx1ZSlcbiAgICAgICAgICA/IGN1cnJlbnRSZXR1cm5WYWx1ZVxuICAgICAgICAgIDogcmV0dXJuVmFsdWU7XG4gICAgICB9LCBTdWJjbGFzcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmNhdWdodCBlcnJvciBpbiBcImJlZm9yZVJlZ2lzdGVyQmxvY2tcIiBob29rOicsIGVycik7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoU3ViY2xhc3MudGVtcGxhdGUpKSB7XG4gICAgICBTdWJjbGFzcy50ZW1wbGF0ZSA9IHtcbiAgICAgICAgdmFyczogW10sXG4gICAgICAgIHZhbHVlOiBTdWJjbGFzcy50ZW1wbGF0ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB2YXJzLFxuICAgICAgdmFsdWVcbiAgICB9ID0gU3ViY2xhc3MudGVtcGxhdGU7XG5cbiAgICBTdWJjbGFzcy5faHRtbCA9IHZhbHVlO1xuICAgIFN1YmNsYXNzLl92YXJzID0gdmFycztcbiAgICBTdWJjbGFzcy5fYmxvY2tzID0gaGFzT3duUHJvcGVydHkoU3ViY2xhc3MsICdfYmxvY2tzJylcbiAgICAgID8gU3ViY2xhc3MuX2Jsb2Nrc1xuICAgICAgOiBjcmVhdGUodGhpcy5fYmxvY2tzKTtcbiAgICBTdWJjbGFzcy5fbWl4aW5zID0gaGFzT3duUHJvcGVydHkoU3ViY2xhc3MsICdfbWl4aW5zJylcbiAgICAgID8gU3ViY2xhc3MuX21peGluc1xuICAgICAgOiBjcmVhdGUodGhpcy5fbWl4aW5zKTtcblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShTdWJjbGFzcywgJ2RlZmF1bHRBcmdzJykpIHtcbiAgICAgIHNldFByb3RvKFN1YmNsYXNzLmRlZmF1bHRBcmdzLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ibG9ja3NbbmFtZV0gPSBTdWJjbGFzcztcblxuICAgIHJldHVybiBTdWJjbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmdldFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgbmFtZS5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja3x1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBCbG9jayB3aXRoIHNwZWNpZmllZCBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1tuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmdldE1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBNaXhpbiBuYW1lLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIE1peGlufHVuZGVmaW5lZH0gUmV0dXJucyByZWdpc3RlcmVkIE1peGluIHdpdGggc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0TWl4aW4obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9taXhpbnNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5pbml0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IFtjb250YWluZXJdIC0gQ29udGFpbmVyIG9mIHRoZSBhcHAuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpbml0aWFsaXppbmcgYXBwLlxuICAgKi9cbiAgc3RhdGljIGluaXQoY29udGFpbmVyKSB7XG4gICAgaW5pdEFwcChodG1sU2NvcGVsZXNzYDxkLWJsb2NrIENvbnN0cnVjdG9yPVwie3RoaXN9XCIvPmAsIGNvbnRhaW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5taXhpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgb3IgbWl4aW4gbmFtZS5cbiAgICogQHBhcmFtIHt0eXBlb2YgTWl4aW58QWZ0ZXJVcGRhdGV9IFN1YmNsYXNzIC0gU3ViY2xhc3Mgb2YgTWl4aW4gb3IgQWZ0ZXJVcGRhdGUgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgTWl4aW58dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgQmxvY2sgb3IgdW5kZWZpbmVkIGlmIHRoZSBibG9jayBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgbWl4aW4gaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGlzLlxuICAgKi9cbiAgc3RhdGljIG1peGluKG5hbWUsIFN1YmNsYXNzKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oU3ViY2xhc3MpICYmICFpc0luc3RhbmNlT2YoTWl4aW4sIFN1YmNsYXNzKSkge1xuICAgICAgY29uc3QgYWZ0ZXJVcGRhdGUgPSBTdWJjbGFzcztcblxuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIE1peGluIHtcbiAgICAgICAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAgdGhpczo6YWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSW5zdGFuY2VPZihNaXhpbiwgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIGNsYXNzIGRvZXMgbm90IGV4dGVuZCBNaXhpbiBvciBpcyBub3QgYW4gYWZ0ZXJVcGRhdGUgZnVuY3Rpb24sIHNvIGl0IHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLm1peGluKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJvb3RNaXhpbnNbbmFtZV0pIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgbWl4aW4gaXMgYSBidWlsdC1pbiBtaXhpbiBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIUFUVFJfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5hbWUgXCIkeyBuYW1lIH1cIiBpcyBub3QgYWxsb3dlZCBmb3IgbWl4aW5zIHNvIHRoZSBtaXhpbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ19taXhpbnMnKSkge1xuICAgICAgdGhpcy5fbWl4aW5zID0gY3JlYXRlKGdldFByb3RvKHRoaXMpLl9taXhpbnMpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBTdWJjbGFzcyA9IG1peGluSG9va3MucmVkdWNlKChyZXR1cm5WYWx1ZSwgaG9vaykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50UmV0dXJuVmFsdWUgPSBob29rKHJldHVyblZhbHVlLCBuYW1lLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gaXNJbnN0YW5jZU9mKE1peGluLCBjdXJyZW50UmV0dXJuVmFsdWUpXG4gICAgICAgICAgPyBjdXJyZW50UmV0dXJuVmFsdWVcbiAgICAgICAgICA6IHJldHVyblZhbHVlO1xuICAgICAgfSwgU3ViY2xhc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgZXJyb3IgaW4gXCJiZWZvcmVSZWdpc3Rlck1peGluXCIgaG9vazonLCBlcnIpO1xuICAgIH1cblxuICAgIFN1YmNsYXNzLl9tYXRjaCA9IGNvbnN0cnVjdE1peGluUmVnZXgobmFtZSk7XG5cbiAgICB0aGlzLl9taXhpbnNbbmFtZV0gPSBTdWJjbGFzcztcblxuICAgIHJldHVybiBTdWJjbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLndyYXBcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLldyYXBwZXJ9IHdyYXBwZXJzIC0gRnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgYmxvY2suXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t9IE5ldyBibG9jay5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd3JhcHBpbmcgYmxvY2tzIGludG8gYW5vdGhlciBibG9ja3MuXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBibG9jayB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2xhc3MgTXlCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdj4xMjM8L2Rpdj4nO1xuICAgKiB9XG4gICAqXG4gICAqIE15QmxvY2sud3JhcCgoQmxvY2spID0+IHtcbiAgICogICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAqICAgICBzdGF0aWMgdGVtcGxhdGUgPSBgPHNlY3Rpb24gY2xhc3M9XCJ3cmFwcGVyXCI+JHsgQmxvY2sudGVtcGxhdGUgfTwvc2VjdGlvbj5gO1xuICAgKlxuICAgKiAgICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgKiAgICAgICBzdXBlcihvcHRzKTtcbiAgICpcbiAgICogICAgICAgdGhpcy5hZGRpdGlvbmFsVmFyID0gJ2FkZGl0aW9uYWwnO1xuICAgKiAgICAgfVxuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gd3JhcHBlcnMucmVkdWNlKHdyYXBCbG9jaywgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGFyZ3M6IG9yaWdpbmFsQXJncyxcbiAgICAgIGRCbG9ja05hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBwcmV2QmxvY2tcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBnZXRQcm90byh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBjaGlsZHJlbkJsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG1peGlucyA9IFtdO1xuICAgIGNvbnN0IGlzUGFyZW50QmxvY2sgPSBwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaztcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtCbG9ja30gQmxvY2sjJFxuICAgICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICogQGRlc2NyaXB0aW9uIFRoaXMuXG4gICAgICAgKi9cbiAgICAgICQ6IHRoaXMsXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayMkJFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmdzIC0gUHJpdmF0ZSBhcmdzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gaHRtbENoaWxkcmVuIC0gQmxvY2sgaHRtbCBjaGlsZHJlbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2tbXX0gY2hpbGRyZW4gLSBDaGlsZCBibG9ja3MuXG4gICAgICAgKiBAcHJvcGVydHkge01peGluW119IG1peGlucyAtIENoaWxkIG1peGlucy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gcGFyZW50RWxlbSAtIFBhcmVudCBlbGVtZW50LlxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBjb250ZW50IC0gQ29udGVudCBlbGVtZW50cy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGV2YWx1YXRlIC0gRXZhbHVhdGUgZnVuY3Rpb24uXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gZ2xvYmFscyAtIFByaXZhdGUgZ2xvYmFscyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsb2NhbHMgLSBQcml2YXRlIGxvY2FscyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IHdhdGNoZXJzVG9SZW1vdmUgLSBXYXRjaGVycyB0byByZW1vdmUgYmVmb3JlIHJlbW92aW5nIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgICQkOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRCbG9ja05hbWUsXG4gICAgICAgIGRCbG9ja3M6IFtdLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIGNvbnRlbnQ6IG5ldyBFbGVtKCksXG4gICAgICAgIG5zOiBjb25zdHJ1Y3RvcixcbiAgICAgICAgaHRtbENoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuQmxvY2tzLFxuICAgICAgICBtaXhpbnMsXG4gICAgICAgIHByZXZCbG9jayxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgaXNSZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGV2YWx1YXRlOiAoZnVuYywgb25DaGFuZ2UsIHRhcmdldEJsb2NrLCBmb3JERWxlbWVudHMsIGZvckRJdGVtLCBmb3JERWFjaCkgPT4ge1xuICAgICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yREVsZW1lbnRzID0gISFmb3JERWxlbWVudHM7XG4gICAgICAgICAgZm9yREl0ZW0gPSAhIWZvckRJdGVtO1xuXG4gICAgICAgICAgY29uc3Qgc2NvcGUgPSAobmFtZSA9PT0gJyNkLWl0ZW0nICYmICFmb3JESXRlbSkgfHwgZm9yREVhY2hcbiAgICAgICAgICAgID8gKGZvckRFYWNoIHx8IHRoaXMpLiQkLnNjb3BlXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgICAgICAgY29uc3QgeyB3YXRjaGVyc1RvUmVtb3ZlIH0gPSB0YXJnZXRCbG9jayA/IHRhcmdldEJsb2NrLiQkIDoge307XG4gICAgICAgICAgY29uc3Qgb25DaGFuZ2VGbGFnID0gISFvbkNoYW5nZTtcblxuICAgICAgICAgIGNvbnN0IGV2YWx1YXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlRmxhZykge1xuICAgICAgICAgICAgICBTY29wZS5ldmFsTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgIFNjb3BlLmdldHRpbmdWYXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoc2NvcGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyci5leHByZXNzaW9uID0gZnVuYztcbiAgICAgICAgICAgICAgZXJyLm9yaWdpbmFsID0gZnVuYy5vcmlnaW5hbDtcbiAgICAgICAgICAgICAgZXJyLmJsb2NrID0gdGhpcztcblxuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb25zdHJ1Y3Rvci5vbkV2YWxFcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3Iub25FdmFsRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmNhdWdodCBlcnJvciBpbiBCbG9jay5vbkV2YWxFcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlRmxhZykge1xuICAgICAgICAgICAgICBjb25zdCBsb2NhbFdhdGNoZXJzID0gW107XG5cbiAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KFNjb3BlLmdldHRpbmdWYXJzLCAod2F0Y2hlcnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmVzdWx0ID0gZXZhbHVhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jlc3VsdCAhPT0gcmVzdWx0ICYmICF0YXJnZXRCbG9jay4kJC5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3UmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlckJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgZm9yREVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXJzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHdhdGNoZXIub25SZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkobG9jYWxXYXRjaGVycywgKHdhdGNoZXJCbG9jaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICB9ID0gd2F0Y2hlckJsb2NrO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVyc1RvUmVtb3ZlLCB3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxvY2FsV2F0Y2hlcnMucHVzaCh3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJzVG9SZW1vdmUucHVzaCh3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIFNjb3BlLmV2YWxNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgIFNjb3BlLmdldHRpbmdWYXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChpc1BhcmVudFNpZ25hbCkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuaXNSZW1vdmVkID0gdHJ1ZTtcblxuICAgICAgICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xuXG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuQmxvY2tzLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQodGhpcy4kJC5jb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheUVsZW0ocGFyZW50QmxvY2suJCQuY2hpbGRyZW4sIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY29udGVudC5yZW1vdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlQ29udGVudDogKG5ld0NvbnRlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKHRoaXMuJCQuaXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5hZnRlckRPTUNoYW5nZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnRlbnRDaGFuZ2U6YCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZENvbnRlbnQ6IChjb250ZW50VG9BZGQsIG5vdFJlY3Vyc2l2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvbGRDb250ZW50LmluZGV4T2YoY29udGVudFRvQWRkWzBdLnByZXZpb3VzU2libGluZykgKyAxO1xuICAgICAgICAgIGxldCBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudFRvQWRkLmFkZChvbGRDb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKGNvbnRlbnRUb0FkZCwgb2xkQ29udGVudC5zbGljZShpbmRleCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudChuZXdDb250ZW50KTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmICFub3RSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVDb250ZW50OiAoY29udGVudFRvTW92ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGRDb250ZW50ID0gdGhpcy4kJC5jb250ZW50O1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gb2xkQ29udGVudC5pbmRleE9mKGNvbnRlbnRUb01vdmVbMF0pO1xuICAgICAgICAgIGNvbnN0IGluZGV4VG9QdXQgPSBvbGRDb250ZW50LmluZGV4T2YoYWZ0ZXJbMF0pICsgMTtcbiAgICAgICAgICBsZXQgbmV3Q29udGVudDtcblxuICAgICAgICAgIGlmIChpbmRleFRvUHV0ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudFRvTW92ZS5hZGQoXG4gICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiBpbmRleFRvUHV0KSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgLmFkZChcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aCwgaW5kZXhUb1B1dCksXG4gICAgICAgICAgICAgICAgY29udGVudFRvTW92ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4VG9QdXQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KG5ld0NvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb01vdmUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNvbnRlbnQ6IChjb250ZW50VG9SZW1vdmUpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQodGhpcy4kJC5jb250ZW50LmZpbHRlcigoZWxlbSkgPT4gKFxuICAgICAgICAgICAgY29udGVudFRvUmVtb3ZlLmluZGV4T2YoZWxlbSkgPT09IC0xXG4gICAgICAgICAgKSkpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KGNvbnRlbnRUb1JlbW92ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRJblN0YXJ0T2ZJdDogKGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBhZnRlckVsZW07XG5cbiAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG5cbiAgICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gcGFyZW50LiQkO1xuXG4gICAgICAgICAgICBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICAgIGxldCBub3RSZWN1cnNpdmU7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgICAgICBub3RSZWN1cnNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgbm90UmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZnRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXJJdDogKGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBhZnRlckVsZW07XG4gICAgICAgICAgbGV0IHRyeVRvQWRkT3JNb3ZlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuJCQuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy4kJC5jb250ZW50LmVsZW0oLTEpO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIHRyeVRvQWRkT3JNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiB0cnlUb0FkZE9yTW92ZSkge1xuICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNvbnN0cnVjdG9yLmRlZmF1bHRMb2NhbHMsICh2YWx1ZSwgdmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgaXRlcmF0ZUFycmF5KGNvbnN0cnVjdG9yLl92YXJzLCAodmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdGhpc1t2YXJpYWJsZV07XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcmdzT2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuICAgIGxldCBhcmdzID0gY3JlYXRlKGNvbnN0cnVjdG9yLmRlZmF1bHRBcmdzIHx8IG51bGwpO1xuICAgIGxldCB3YXNEUmVzdDtcblxuICAgIGl0ZXJhdGVPYmplY3Qob3JpZ2luYWxBcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgY29uc3QgaXNEUmVzdCA9IERfUkVTVF9SRUdFWC50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBsb2NhbEFyZ3MgPSBpc0RSZXN0IHx8IHdhc0RSZXN0XG4gICAgICAgID8gY3JlYXRlKGFyZ3MpXG4gICAgICAgIDogYXJncztcblxuICAgICAgYXJncyA9IGxvY2FsQXJncztcblxuICAgICAgaWYgKGlzRFJlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdEFyZ3MgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZU9iamVjdChsb2NhbEFyZ3MsIGNsZWFuUHJvcGVydHkpO1xuICAgICAgICAgIGFzc2lnbihsb2NhbEFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHZhbHVlKSk7XG4gICAgICAgICAgY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgd2FzRFJlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyhyZXN0QXJncykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0RFbGVtZW50cyA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJztcbiAgICAgIGNvbnN0IGZvckRFbGVtZW50cyA9IGlzREVsZW1lbnRzICYmIGFyZyA9PT0gJ3ZhbHVlJztcblxuICAgICAgd2FzRFJlc3QgPSBmYWxzZTtcblxuICAgICAgaWYgKG5hbWUgIT09ICdkLWVhY2gnIHx8IGFyZyAhPT0gJ3VpZCcpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbG9jYWxBcmdzW2FyZ10gPSB2YWx1ZTtcbiAgICAgICAgICBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpO1xuICAgICAgICB9LCB0aGlzLCBmb3JERWxlbWVudHMsIGlzREVsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLm5hbWUgPT09ICcjZC1pdGVtJyk7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQXJnc1thcmddID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNhcmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhcmdzOiBhcmdzT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjZ2xvYmFsc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZ2xvYmFsczogY3JlYXRlKFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgICAgID8gcGFyZW50U2NvcGUuZ2xvYmFsc1xuICAgICAgICAgIDogbnVsbFxuICAgICAgKVxuICAgIH0pO1xuXG4gICAgY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnRCbG9jaykge1xuICAgICAgcGFyZW50QmxvY2suJCQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlckNvbnN0cnVjdFxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgY29uc3RydWN0aW9uIChpbmNsdWRpbmcgYWxsIHNjb3BlcylcbiAgICogYnV0IGJlZm9yZSByZW5kZXJpbmcgdGhlIGJsb2NrIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICBhZnRlckNvbnN0cnVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJET01DaGFuZ2VcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIERPTSBzdHJ1Y3R1cmUgaGFzIGNoYW5nZWQuXG4gICAqL1xuICBhZnRlckRPTUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJSZW5kZXJcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGhhcyBiZWVuIHJlbmRlcmVkLlxuICAgKi9cbiAgYWZ0ZXJSZW5kZXIoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2JlZm9yZVJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYmVmb3JlIHRoZSBibG9jayByZW1vdmFsLlxuICAgKi9cbiAgYmVmb3JlUmVtb3ZlKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRDaGlsZEJsb2Nrc1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBjaGlsZCBibG9ja3MuXG4gICAqL1xuICBnZXRDaGlsZEJsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ibG9ja3Muc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldENoaWxkQmxvY2tzXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge01peGluW119XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGNoaWxkIG1peGlucy5cbiAgICovXG4gIGdldENoaWxkTWl4aW5zKCkge1xuICAgIHJldHVybiB0aGlzLiQkLm1peGlucy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0Q2hpbGRyZW5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIEJsb2NrIEhUTUwgY2hpbGRyZW4uXG4gICAqL1xuICBnZXRDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5odG1sQ2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRDb25zdHJ1Y3RvclxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIEJsb2NrIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ2V0Q29uc3RydWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQubnM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRET01cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgRE9NIGNvbnRlbnRzIG9mIHRoZSBibG9jay5cbiAgICovXG4gIGdldERPTSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5jb250ZW50LnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRCbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBwYXJlbnQgYmxvY2suXG4gICAqL1xuICBnZXRQYXJlbnRCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRCbG9jaztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldFBhcmVudEVsZW1cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbXx2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBwYXJlbnQgRWxlbS5cbiAgICovXG4gIGdldFBhcmVudEVsZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50RWxlbS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50U2NvcGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QmxvY2t8dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgcGFyZW50IHNjb3BlLlxuICAgKi9cbiAgZ2V0UGFyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50U2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRUZW1wbGF0ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBwYXJlbnQgdGVtcGxhdGUuXG4gICAqL1xuICBnZXRQYXJlbnRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IFtjYWxsYmFja10gLSBJZiBwcmVzZW50LCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge0Jsb2NrfE1peGlufSBbdGFyZ2V0ID0gdGhpc10gLSBXaGF0IGJsb2NrIG9yIG1peGluIHJlcXVlc3RzIHRoZSB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gaW4gY29udGV4dCBvZiB0aGUgYmxvY2sgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGZ1bmMsIGNhbGxiYWNrLCB0YXJnZXQgPSB0aGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjd2F0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLignYXJncyd8J2dsb2JhbHMnfFN0cmluZyl9IFt2YXJzXSAtIFZhcnMgdG8gd2F0Y2ggKGFyZ3MsIGdsb2JhbHMgb3IgbG9jYWxzKS5cbiAgICogSWYgbm8gc3BlY2lmaWVkIGFsbCBsb2NhbHMsIGFyZ3MgYW5kIGdsb2JhbHMgYXJlIHRvIGJlIHdhdGNoZWQuXG4gICAqIElmIHRoZSAnYXJncycgc3RyaW5nIGFsbCBhcmdzIGFyZSB0byBiZSB3YXRjaGVkLlxuICAgKiBJZiB0aGUgJ2dsb2JhbHMnIHN0cmluZyBhbGwgZ2xvYmFscyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogQHBhcmFtIHtWYXJzV2F0Y2hlcn0gd2F0Y2hlciAtIENhbGxlZCB3aGVuIHdhdGNoZWQgdmFycyBhcmUgY2hhbmdlZC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd2F0Y2hpbmcgZm9yIHZhcnMuIElmIG5vIHZhcnMgcGFzc2VkIGluIGFyZ3VtZW50c1xuICAgKiBhbGwgdmFycyBhcmUgdG8gYmUgd2F0Y2hlZC4gSWYgdGhlICdhcmdzJyBzdHJpbmcgaXMgaW4gdGhlIGFyZ3VtZW50cyBhbGwgYXJncyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogSWYgdGhlICdnbG9iYWxzJyBzdHJpbmcgaXMgaW4gdGhlIGFyZ3VtZW50cyBhbGwgZ2xvYmFscyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogT3RoZXJ3aXNlIHNwZWNpZmllZCB2YXJzIHdpbGwgYmUgd2F0Y2hlZC5cbiAgICogV2F0Y2hlcnMgc2hvdWxkIG5vdCBiZSBwdXQgaW5zaWRlIHRoZSBjb25zdHJ1Y3Rvci4gSXQgaXMgY29uc2lkZXJlZCBiZXN0XG4gICAqIHByYWN0aWNlIHRvIGRvIGl0IGluc2lkZSB0aGUge0BsaW5rIEJsb2NrI2FmdGVyQ29uc3RydWN0fSBtZXRob2QuXG4gICAqIE5vdGUgdGhhdCB0aGVzZSBleHByZXNzaW9ucyAodmFycywgaS5lLiBcImFyZ3MuYXJnXCIpIGFyZSBub3QgdG8gYmVcbiAgICogZXZhbHVhdGVkIHNvIHlvdSBjYW5ub3QgcHV0IHRoZXJlIHRoaW5ncyBsaWtlIFwiYVtiXVwiIG9yIGFueSBqcyBjb2RlLFxuICAgKiBvbmx5IGV4cHJlc3Npb25zIGxpa2UgXCJhXCIsIFwiYlwiLCBcImFyZ3MuYVwiLCBcImFyZ3MuYlwiIGFuZCBcImdsb2JhbHMuYVwiLCBcImdsb2JhbHMuYlwiLlxuICAgKiBBbHNvIG5vdGUgdGhhdCBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSB2YXIgdGhhdCBhcmUgY2hhbmdlZCBhdCBvbmNlIChzeW5jaHJvbm91c2x5KVxuICAgKiB0aGUgd2F0Y2hlciBpcyBjYWxsZWQgb25seSBvbmNlLlxuICAgKiBOb3RlIHRoYXQgdGhlIHdhdGNoZXIgaXMgZXhlY3V0ZWQgcmlnaHQgYXdheSBiZWNhdXNlIGluIG1vc3QgY2FzZXNcbiAgICogdGhpcyBiZWhhdmlvdXIgaXMgdmVyeSBjb252ZW5pZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2IC8+JztcbiAgICpcbiAgICogICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICogICAgIHRoaXMud2F0Y2goJ2EnLCAoKSA9PiB7fSk7XG4gICAqICAgICB0aGlzLndhdGNoKCdhcmdzLmEnLCAnZ2xvYmFscy5yJywgKCkgPT4ge30pO1xuICAgKiAgICAgdGhpcy53YXRjaCgoKSA9PiB7fSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqL1xuICB3YXRjaCguLi52YXJzKSB7XG4gICAgY29uc3Qgb2xkV2F0Y2hlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24ob2xkV2F0Y2hlcikpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIGxhc3QgYXJndW1lbnQgKHdhdGNoZXIpIHdhc24ndCBzcGVjaWZpZWQgKCR7IHRoaXMuJCQubmFtZSB9I3dhdGNoKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2F0Y2hlciA9ICgpID0+IHtcbiAgICAgIG9sZFdhdGNoZXIoKTtcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdhdGNoRm9yQWxsTG9jYWxzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgd2F0Y2hGb3JBbGxBcmdzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgd2F0Y2hGb3JBbGxHbG9iYWxzKHRoaXMsIHdhdGNoZXIpO1xuXG4gICAgICBvbGRXYXRjaGVyKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAodmFyaWFibGUpID0+IHtcbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gb2xkV2F0Y2hlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhcmlhYmxlID0gYCR7IHZhcmlhYmxlIH1gO1xuXG4gICAgICBpZiAodmFyaWFibGUgPT09ICckJykge1xuICAgICAgICByZXR1cm4gd2F0Y2hGb3JBbGxMb2NhbHModGhpcywgd2F0Y2hlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gJ2FyZ3MnKSB7XG4gICAgICAgIHJldHVybiB3YXRjaEZvckFsbEFyZ3ModGhpcywgd2F0Y2hlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gJ2dsb2JhbHMnKSB7XG4gICAgICAgIHJldHVybiB3YXRjaEZvckFsbEdsb2JhbHModGhpcywgd2F0Y2hlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChXQVRDSEVEX0FSR19QUkVGSVhfUkVHRVgudGVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5yZXBsYWNlKFdBVENIRURfQVJHX1BSRUZJWF9SRUdFWCwgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy4kJC5hcmdzW3ZhcmlhYmxlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJCQuYXJnc1t2YXJpYWJsZV0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFdBVENIRURfR0xPQkFMX1BSRUZJWF9SRUdFWC50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnJlcGxhY2UoV0FUQ0hFRF9HTE9CQUxfUFJFRklYX1JFR0VYLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLiQkLmdsb2JhbHNbdmFyaWFibGVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB3YXRjaGVycyB9ID0gdGhpcy4kJC5nbG9iYWxzW3ZhcmlhYmxlXTtcblxuICAgICAgICB3YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XG4gICAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZS5wdXNoKHtcbiAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgIHdhdGNoZXJzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLiQkLmxvY2Fsc1t2YXJpYWJsZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiQkLmxvY2Fsc1t2YXJpYWJsZV0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuICAgIH0pO1xuXG4gICAgb2xkV2F0Y2hlcigpO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKEJsb2NrLCAnQmxvY2snKTtcbnNldFByb3RvKEJsb2NrLnByb3RvdHlwZSwgbnVsbCk7XG5cbmV4cG9ydCB7IEJsb2NrIH07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNsYXNzIERCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICA8ZC1lbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwie1BhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cIntQYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGU6IHtcbiAgICAgICAgJCQ6IHtcbiAgICAgICAgICBwYXJlbnRTY29wZTogcGFyZW50UGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGU6IHBhcmVudFBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIGh0bWxDaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGh0bWxDaGlsZHJlbjogb3duQ2hpbGRyZW4sXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGRCbG9ja05hbWVcbiAgICB9ID0gdGhpcy4kJDtcbiAgICBsZXQgZm91bmQ7XG5cbiAgICBpZiAob3duQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudFBhcmVudFNjb3BlO1xuICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRQYXJlbnRUZW1wbGF0ZTtcblxuICAgIGlmIChkQmxvY2tOYW1lKSB7XG4gICAgICBmb3VuZCA9IGZpbmRJbkFycmF5KGNoaWxkcmVuLCAoeyBuYW1lOiBub2RlTmFtZSB9KSA9PiBub2RlTmFtZSA9PT0gYGQtYmxvY2s6JHsgZEJsb2NrTmFtZSB9YCk7XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgLyogZXNsaW50IG5vLWVtcHR5OiAwICovXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LiQkLnBhcmVudFNjb3BlKVxuICAgICAgICAgICYmICEoZm91bmQgPSBmaW5kSW5BcnJheShwYXJlbnQuJCQuZEJsb2NrcywgKHsgJCQ6IHsgZEJsb2NrTmFtZTogREJsb2NrTmFtZSB9IH0pID0+IERCbG9ja05hbWUgPT09IGRCbG9ja05hbWUpKVxuICAgICAgICAgICYmIHBhcmVudC4kJC5wYXJlbnRTY29wZS4kJC5uYW1lID09PSAnI2QtaXRlbSdcbiAgICAgICAgKSB7fVxuXG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIHRoaXMuUGFyZW50U2NvcGUgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgICAgICAgIGZvdW5kLnZhbHVlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGZvdW5kLnZhbHVlLiQkLmh0bWxDaGlsZHJlblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kICYmIGZvdW5kLnZhbHVlLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICA/IGZvdW5kLnZhbHVlLmNoaWxkcmVuXG4gICAgICAgIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgIH1cbiAgfVxufVxuXG5yb290QmxvY2tzWydkLWJsb2NrJ10gPSBEQmxvY2s7XG5cbmV4cG9ydCB7IERCbG9jayB9O1xuIiwiaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5cbmNvbnN0IHRlbXBsYXRlID0gaHRtbGBcbiAgPGQtZWxlbWVudHNcbiAgICB2YWx1ZT1cInskJC5odG1sQ2hpbGRyZW59XCJcbiAgICBwYXJlbnRTY29wZT1cInt0aGlzfVwiXG4gICAgcGFyZW50VGVtcGxhdGU9XCJ7JCQucGFyZW50VGVtcGxhdGV9XCJcbiAgLz5cbmA7XG5cbmNsYXNzIERJdGVtIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgc3RhdGljIF92YXJzID0gdGVtcGxhdGUudmFycztcbiAgc3RhdGljIF9odG1sID0gdGVtcGxhdGUudmFsdWU7XG59XG5cbmV4cG9ydCB7IERJdGVtIH07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCxcbiAgaXNBcnJheSwgaXNGdW5jdGlvblxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyByZW1vdmUsIGNyZWF0ZUJsb2NrIH0gZnJvbSAnLi4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgREl0ZW0gfSBmcm9tICcuL2QtaXRlbSc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYFtcbiAgYXJncy5zZXQsXG4gIGFyZ3MuZmlsdGVyQnksXG4gIGFyZ3Muc29ydEJ5XG5dYDtcblxucm9vdEJsb2Nrc1snZC1lYWNoJ10gPSBjbGFzcyBERWFjaCBleHRlbmRzIEJsb2NrIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJnczoge1xuICAgICAgICBpdGVtOiBpdGVtTmFtZSA9ICckaXRlbScsXG4gICAgICAgIGluZGV4OiBpbmRleE5hbWUgPSAnJGluZGV4J1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuXG4gICAgYXNzaWduKHRoaXMuJCQsIHtcbiAgICAgIGl0ZW1zQnlVSURzOiB7fSxcbiAgICAgIFVJRDogdGhpcy5hcmdzLnVpZCB8fCB1bmRlZmluZWQsXG4gICAgICBpdGVtTmFtZSxcbiAgICAgIGluZGV4TmFtZVxuICAgIH0pO1xuICB9XG5cbiAgYWZ0ZXJSZW5kZXIoKSB7XG4gICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsIHRoaXMucmVuZGVyU2V0KTtcbiAgICB0aGlzLnJlbmRlclNldCgpO1xuICB9XG5cbiAgcmVuZGVyU2V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIGl0ZW1zQnlVSURzLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBzY29wZSxcbiAgICAgIGl0ZW1OYW1lLFxuICAgICAgaW5kZXhOYW1lLFxuICAgICAgVUlEXG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczogeyBzb3J0QnkgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0l0ZW1zQnlVSURzID0ge307XG4gICAgY29uc3QgbmV3VUlEc0NvdW50ZXIgPSB7fTtcbiAgICBjb25zdCBuZXdVSURzID0ge307XG4gICAgbGV0IHtcbiAgICAgIHNldCxcbiAgICAgIGZpbHRlckJ5XG4gICAgfSA9IHRoaXMuYXJncztcbiAgICBjb25zdCBpc0FyciA9IGlzQXJyYXkoc2V0KTtcbiAgICBjb25zdCBpdGVyYXRlID0gaXNBcnJcbiAgICAgID8gaXRlcmF0ZUFycmF5XG4gICAgICA6IGl0ZXJhdGVPYmplY3Q7XG5cbiAgICBpZiAoaXNBcnIgJiYgaXNGdW5jdGlvbihzb3J0QnkpKSB7XG4gICAgICBzZXQgPSBzZXRcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnNvcnQoc29ydEJ5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXJCeSkpIHtcbiAgICAgIGZpbHRlckJ5ID0gW2ZpbHRlckJ5XTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShmaWx0ZXJCeSkpIHtcbiAgICAgIGl0ZXJhdGVBcnJheShmaWx0ZXJCeSwgKGZpbHRlcikgPT4ge1xuICAgICAgICBzZXQgPSBzZXQuZmlsdGVyKGZpbHRlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpdGVyYXRlKHNldCwgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBzY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuICAgICAgc2NvcGVbaW5kZXhOYW1lXSA9IGluZGV4O1xuXG4gICAgICBjb25zdCB1aWQgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShVSUQsIG51bGwsIG51bGwsIGZhbHNlLCBmYWxzZSwgdGhpcyk7XG5cbiAgICAgIG5ld1VJRHNDb3VudGVyW3VpZF0gPSAobmV3VUlEc0NvdW50ZXJbdWlkXSB8fCAwKSArIDE7XG4gICAgICBuZXdVSURzW2luZGV4XSA9IHVpZDtcbiAgICB9KTtcblxuICAgIHNjb3BlW2l0ZW1OYW1lXSA9IG51bGw7XG4gICAgc2NvcGVbaW5kZXhOYW1lXSA9IG51bGw7XG5cbiAgICBpdGVyYXRlT2JqZWN0KGl0ZW1zQnlVSURzLCAoaXRlbXMsIHVpZCkgPT4ge1xuICAgICAgaWYgKCFuZXdVSURzQ291bnRlclt1aWRdKSB7XG4gICAgICAgIGl0ZXJhdGVBcnJheShpdGVtcywgcmVtb3ZlKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShpdGVtcy5zcGxpY2UobmV3VUlEc0NvdW50ZXJbdWlkXSksIHJlbW92ZSk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgaXRlcmF0ZShzZXQsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdWlkID0gbmV3VUlEc1tpbmRleF07XG4gICAgICBsZXQgYmxvY2s7XG5cbiAgICAgIGlmIChpdGVtc0J5VUlEc1t1aWRdICYmIGl0ZW1zQnlVSURzW3VpZF0ubGVuZ3RoKSB7XG4gICAgICAgIGJsb2NrID0gaXRlbXNCeVVJRHNbdWlkXS5zaGlmdCgpO1xuICAgICAgICBibG9jay4kJC5zY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG4gICAgICAgIGJsb2NrLiQkLnNjb3BlW2l0ZW1OYW1lXSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKGJsb2NrLiQkLnByZXZCbG9jayAhPT0gcHJldkJsb2NrICYmIHByZXZCbG9jaykge1xuICAgICAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGJsb2NrLiQkLmNvbnRlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICBpdGVtTmFtZSxcbiAgICAgICAgICAgIGluZGV4TmFtZSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIG5hbWU6ICcjZC1pdGVtJyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBodG1sQ2hpbGRyZW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIENvbnN0cnVjdG9yOiBESXRlbSxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIChuZXdJdGVtc0J5VUlEc1t1aWRdID0gbmV3SXRlbXNCeVVJRHNbdWlkXSB8fCBbXSkucHVzaChibG9jayk7XG4gICAgICBibG9jay4kJC5wcmV2QmxvY2sgPSBwcmV2QmxvY2s7XG4gICAgICBwcmV2QmxvY2sgPSBibG9jaztcbiAgICB9KTtcblxuICAgIHRoaXMuJCQuaXRlbXNCeVVJRHMgPSBuZXdJdGVtc0J5VUlEcztcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIHJlbW92ZUFycmF5RWxlbSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNyZWF0ZUJsb2NrIH0gZnJvbSAnLi4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi9FbGVtJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BhcmdzLnZhbHVlYDtcblxucm9vdEJsb2Nrc1snZC1lbGVtZW50cyddID0gY2xhc3MgREVsZW1lbnRzIGV4dGVuZHMgQmxvY2sge1xuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICBjb25zdCB7IHBhcmVudEVsZW0gfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfSA9IHRoaXMuYXJncztcblxuICAgIHRoaXMuJCQuZXZhbHVhdGUod2F0Y2hBcmdzLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtaXhpbnMsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG5cbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kJC5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy4kJC5taXhpbnMgPSBbXTtcbiAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JERWxlbWVudHMgfSkgPT4ge1xuICAgICAgICBpZiAoZm9yREVsZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiQkLmNvbnRlbnQgPSBuZXcgRWxlbSgpO1xuXG4gICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICBpdGVyYXRlQXJyYXkodmFsdWUgfHwgW10sIChjaGlsZCkgPT4ge1xuICAgICAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgQ29uc3RydWN0b3IsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2s6IHRoaXMsXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcywgdHJ1ZSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RCbG9ja3NbJ2QtaWYnXSA9IGNsYXNzIERJZiBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICA8ZC1lbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBodG1sQ2hpbGRyZW5cbiAgICB9ID0gdGhpcy4kJDtcbiAgICBsZXQgaW5kZXggPSBJbmZpbml0eTtcbiAgICBjb25zdCB2YWx1ZXMgPSBodG1sQ2hpbGRyZW4ubWFwKChjaGlsZCwgaSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBhdHRycyA9IHt9LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgbGV0IGNvbmQgPSBhdHRycy5pZjtcblxuICAgICAgaWYgKG5hbWUgIT09ICdkLWVsc2UnICYmIGNvbmQpIHtcbiAgICAgICAgY29uZCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGNvbmQsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgIGlmICghIW5ld1ZhbHVlID09PSB2YWx1ZXNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZXNbaV0gPSAhIW5ld1ZhbHVlO1xuXG4gICAgICAgICAgaWYgKGkgPiBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZvdW5kID0gZmluZEluQXJyYXkodmFsdWVzLCBCb29sZWFuKTtcblxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3VuZC5rZXk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gaHRtbENoaWxkcmVuW2ZvdW5kLmtleV0uY2hpbGRyZW47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25kICYmIGluZGV4ID09PSBJbmZpbml0eSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEhY29uZDtcbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGNvbGxlY3RGcm9tT2JqZWN0LCBpdGVyYXRlT2JqZWN0LCBrZXlzIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1hdHRyJ10gPSBjbGFzcyBEQXR0ciBleHRlbmRzIE1peGluIHtcbiAgYXR0cnMgPSB7fTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgYXR0cnNcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIChhdHRycywgYXR0cikgPT4ge1xuICAgICAgICBhdHRyc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZU9iamVjdChhdHRycywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIShwcm9wIGluIG5ld1ZhbHVlKSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHIocHJvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWxlbS5hdHRyKG5ld1ZhbHVlKTtcblxuICAgIHRoaXMuYXR0cnMgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXR0cnNcbiAgICB9ID0gdGhpcztcblxuICAgIGVsZW0ucmVtb3ZlQXR0ci5hcHBseShlbGVtLCBrZXlzKGF0dHJzKSk7XG4gIH1cbn07XG5cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLWJpbmQnXSA9IGNsYXNzIERCaW5kIGV4dGVuZHMgTWl4aW4ge1xuICBvZmYgPSBub29wO1xuXG4gIGFmdGVyVXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5vZmYoKTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLm9mZiA9IHRoaXMuZWxlbS5vbih0aGlzLmFyZ3Muam9pbignLCcpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmID0gbm9vcDtcblxuICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtYmluZFwiIG1peGluIHdpdGggYW4gZXZlbnQgbmFtZXMgKGxpa2UgXCJkLWJpbmQoY2xpY2spXCIgb3IgXCJkLWJpbmQoa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5vZmYoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIGlzQXJyYXksIGlzU3RyaW5nLFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3Rcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgRU1QVFlfU1BBQ0VfUkVHRVggPSAvXFxzKy87XG5cbnJvb3RNaXhpbnNbJ2QtY2xhc3MnXSA9IGNsYXNzIERDbGFzcyBleHRlbmRzIE1peGluIHtcbiAgY2xhc3NlcyA9IFtdO1xuXG4gIGFmdGVyVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjbGFzc2VzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3Q2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWVcbiAgICAgICAgPyBhcmdzXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKG5ld1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zcGxpdChFTVBUWV9TUEFDRV9SRUdFWCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICBpZiAobmV3VmFsdWUuaW5kZXhPZihjbHMpID09PSAtMSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlQXJyYXkobmV3VmFsdWUsIChjbHMpID0+IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNscykpIHtcbiAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8ICFuZXdWYWx1ZVtjbHNdKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3VmFsdWUsICh2YWwsIGNscykgPT4ge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzZXMgPSBuZXdDbGFzc2VzO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBjbGFzc2VzXG4gICAgfSA9IHRoaXM7XG5cbiAgICBlbGVtLnJlbW92ZUNsYXNzLmFwcGx5KGVsZW0sIGNsYXNzZXMpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2QtZWxlbSddID0gY2xhc3MgREVsZW0gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQgc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKCk7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHZhbHVlID0gYXJnc1swXTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlKGVsZW0pO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBlbGVtO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNsYXNzIERIaWRlIGV4dGVuZHMgTWl4aW4ge1xuICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICB0aGlzLmVsZW0uc2hvdygpO1xuICB9XG59XG5cbnJvb3RNaXhpbnNbJ2QtaGlkZSddID0gREhpZGU7XG5cbmV4cG9ydCB7IERIaWRlIH07XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1ub2RlJ10gPSBjbGFzcyBETm9kZSBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJncyxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgbm9kZVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBzY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGUoKTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUobm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHNjb3BlW3ZhbHVlXSA9IG5vZGU7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2Qtb24nXSA9IGNsYXNzIERPbiBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgdGhpcy5vZmYgPSB0aGlzLmVsZW0ub24odGhpcy5hcmdzLmpvaW4oJywnKSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmV2YWx1YXRlKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYgPSBub29wO1xuXG4gICAgICBjb25zb2xlLmVycm9yKCdQcm92aWRlIFwiZC1vblwiIG1peGluIHdpdGggYW4gZXZlbnQgbmFtZXMgKGxpa2UgXCJkLW9uKGNsaWNrKVwiIG9yIFwiZC1vbihrZXl1cCwga2V5cHJlc3MpXCIpIScpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICB0aGlzLm9mZigpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1zaG93J10gPSBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5lbGVtLnNob3coKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyByb290QmxvY2tzLCByb290TWl4aW5zIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbnN0cnVjdE1peGluUmVnZXggfSBmcm9tICcuL2NvbnN0cnVjdE1peGluUmVnZXgnO1xuXG5pdGVyYXRlT2JqZWN0KHJvb3RCbG9ja3MsIChCbG9jaykgPT4ge1xuICBCbG9jay5fdmFycyA9IEJsb2NrLnRlbXBsYXRlLnZhcnM7XG4gIEJsb2NrLl9odG1sID0gQmxvY2sudGVtcGxhdGUudmFsdWU7XG59KTtcblxuaXRlcmF0ZU9iamVjdChyb290TWl4aW5zLCAoTWl4aW4sIG5hbWUpID0+IHtcbiAgTWl4aW4uX21hdGNoID0gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKTtcbn0pO1xuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBjcmVhdGVIaWRlU3R5bGVOb2RlIH0gZnJvbSAnLi9oZWxwZXJzL0VsZW0nO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBkb2NcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBkb2MgPSBuZXcgRWxlbShkb2N1bWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBodG1sXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWwgPSBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gYm9keVxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5ib2R5LlxuICovXG5leHBvcnQgY29uc3QgYm9keSA9IG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gaGVhZFxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5oZWFkLlxuICovXG5leHBvcnQgY29uc3QgaGVhZCA9IG5ldyBFbGVtKGRvY3VtZW50LmhlYWQpO1xuXG5jcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpO1xuIl0sIm5hbWVzIjpbImNvbGxlY3RGcm9tQXJyYXkiLCJhcnJheSIsImNhbGxiYWNrIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJpbmRleCIsImZpbmRJbkFycmF5IiwiaSIsImxlbmd0aCIsIml0ZXJhdGVBcnJheSIsInJlbW92ZUFycmF5RWxlbSIsImVsZW0iLCJpbmRleE9mIiwic3BsaWNlIiwidG9PYmplY3RLZXlzIiwiYWRkS2V5IiwidmFycyIsInZhcmlhYmxlIiwiYXNzaWduIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwic291cmNlIiwia2V5IiwiY29sbGVjdEZyb21PYmplY3QiLCJvYmplY3QiLCJleGNlcHQiLCJuZXdPYmplY3QiLCJwYXRocyIsInNsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJoYXMiLCJpdGVyYXRlT2JqZWN0IiwibWFwT2JqZWN0IiwiZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJuYW1lIiwiZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsInNldFRvU3RyaW5nVGFnIiwidGFnIiwiU3ltYm9sIiwicHJvdG90eXBlIiwiaXNGdW5jdGlvbiIsImlzTmlsIiwiaXNTdHJpbmciLCJlc2NhcGVSZWdleCIsInN0cmluZyIsInJlcGxhY2UiLCJyZWdleHBTcGVjaWFsc1JlZ2V4cCIsIm5vb3AiLCJ0b0NhbWVsQ2FzZSIsIkRBU0hFRF9TWU1CT0xfUkVHRVgiLCJjYXBpdGFsaXplIiwidG9IeXBoZW5DYXNlIiwiVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVgiLCJoeXBoZW5pemUiLCJtYXRjaCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJhZGRBdHRyIiwiYXR0cnMiLCJhdHRyIiwiYWRkQ1NTUHJvcCIsImNzcyIsInByb3BlcnR5Iiwic3BsaXQiLCJDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgiLCJhZGREYXRhQXR0ciIsImRhdGEiLCJhZGROZXh0IiwiYWRkIiwibmV4dFNpYmxpbmciLCJhZGRQYXJlbnQiLCJwYXJlbnROb2RlIiwiYWRkUHJldiIsInByZXZpb3VzU2libGluZyIsImNyZWF0ZUhpZGVTdHlsZU5vZGUiLCJoZWFkIiwiZmluZCIsIkhJREVfQ0xBU1MiLCJjcmVhdGUiLCJwcm9wIiwidGV4dCIsImdldEF0dHJOUyIsImlzWG1sTnMiLCJub2RlTmFtZSIsIk51bGwiLCJYTUxfTlMiLCJYX0xJTktfQVRUUl9GSU5EX1JFR0VYIiwidGVzdCIsIkVsZW0iLCJjbG9zZXN0IiwiWF9MSU5LX05TIiwiWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCIsImhpZGUiLCJvd25lckRvY3VtZW50IiwiYWRkQ2xhc3MiLCJpc0VsZW0iLCJpc0VsZW1lbnRzQ29sbGVjdGlvbiIsIkhUTUxfQ09MTEVDVElPTl9SRUdFWCIsImlzQXJyYXkiLCJpc0hUTUxEb2N1bWVudCIsImlzVmFsaWROb2RlIiwiRUxFTUVOVF9SRUdFWCIsInJlbW92ZSIsInBhcmVudCIsInJlbW92ZUNoaWxkIiwic2hvdyIsInJlbW92ZUNsYXNzIiwidG9FbGVtIiwic2VsZWN0b3IiLCJiYXNlIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiU3RyaW5nIiwiY2FsY3VsYXRlQXJncyIsImFyZ3MiLCJhcmdzT2JqZWN0Iiwia2V5cyIsImFyZyIsInVuZGVmaW5lZCIsImNsZWFuUHJvcGVydHkiLCJjb25zdHJ1Y3RNaXhpblJlZ2V4IiwiUmVnRXhwIiwibWl4aW5NYXRjaCIsIm1peGlucyIsIk1peGluIiwibG9jYWxNYXRjaCIsIl9tYXRjaCIsImFyZ3NNYXRjaCIsIkNPTU1BX1JFR0VYIiwidHJhbnNmb3JtUmVzdEF0dHJzIiwibWl4aW5EZWZhdWx0T3B0cyIsImV2ZW50dWFsQXR0cnMiLCJEX1JFU1RfUkVHRVgiLCJ0cmFuc2Zvcm1SZXN0QXJncyIsImFkZEFyZ3MiLCJleGVjdXRlTWl4aW5XYXRjaGVycyIsIm1peGluIiwib2xkVmFsdWUiLCIkJCIsIndhdGNoZXJzIiwid2F0Y2hlciIsImNyZWF0ZU1peGluIiwiZHluYW1pYyIsImNvbW1lbnQiLCJwYXJlbnRCbG9jayIsInBhcmVudFNjb3BlIiwicGFyZW50VGVtcGxhdGUiLCJldmFsdWF0ZSIsIm5ld1ZhbHVlIiwiYWZ0ZXJVcGRhdGUiLCJlcnIiLCJlcnJvciIsImNhbGN1bGF0ZUF0dHJzIiwiYXR0cnNPYmplY3QiLCJmaXJzdFRpbWUiLCJ0eXBlIiwicmVtb3ZlQXR0ciIsIm9wdHMiLCJuZXh0VHlwZSIsIm5leHREeW5hbWljIiwibmV4dFZhbHVlIiwicHJldlR5cGUiLCJwcmV2VmFsdWUiLCJpc0R5bmFtaWMiLCJldmFsdWF0ZWQiLCJidWlsZE1peGluIiwiZmlyc3RWYWx1ZSIsInB1c2giLCJjb25zdHJ1Y3RQcml2YXRlU2NvcGUiLCJzY29wZSIsImdsb2JhbHMiLCJyZW1vdmVUZW1wV2F0Y2hlciIsIm9uUmVtb3ZlIiwicmVtb3ZlV2F0Y2hlcnMiLCJ3YXRjaGVyc1RvUmVtb3ZlIiwicmVtb3ZlV2F0Y2hlciIsImNvbnN0cnVjdFB1YmxpY1Njb3BlIiwic2NvcGVWYWx1ZXMiLCJwcml2YXRlU2NvcGUiLCJTY29wZSIsImV2YWxNb2RlIiwiZ2V0dGluZ1ZhcnMiLCJ0ZW1wIiwiY2hhbmdlZCIsIm9sZFRlbXBXYXRjaGVycyIsIndhcyIsInZhbHVlcyIsInBlcm0iLCJjcmVhdGVCbG9jayIsIm5vZGUiLCJDb25zdHJ1Y3RvciIsInBhcmVudEVsZW0iLCJwcmV2QmxvY2siLCJkb2MiLCJuYW1lc3BhY2VVUkkiLCJTVkdfTlMiLCJsb2NhbEJsb2NrcyIsIm5zIiwiX2Jsb2NrcyIsIkJsb2NrIiwibG9jYWxNaXhpbnMiLCJfbWl4aW5zIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsImRCbG9ja01hdGNoIiwiZEJsb2NrTmFtZSIsImRCbG9ja0FyZ3MiLCJkQmxvY2tDaGlsZHJlbiIsImRFbGVtZW50c05hbWUiLCJkRWxlbWVudHNDb25zdHJ1Y3RvciIsIk5BTUVEX0RfQkxPQ0tfUkVHRVgiLCJibG9ja0luc3RhbmNlIiwiZWxlbWVudCIsImN1cnJlbnRBdHRycyIsIndhc0RSZXN0IiwiaXNEUmVzdCIsImxvY2FsQXR0cnMiLCJyZXN0QXR0cnMiLCJjcmVhdGVNaXhpbnMiLCJjb250ZW50IiwiY2hpbGQiLCJpc1BhcmVudEJsb2NrIiwiaW5zZXJ0QWZ0ZXJJdCIsImluc2VydEFmdGVyIiwiYWRkQ29udGVudCIsImluc2VydEluU3RhcnRPZkl0IiwiaW50byIsIkFyZ3MiLCJsb2NhbHMiLCJuZXdOYW1lIiwibmV3Q29uc3RydWN0b3IiLCJodG1sIiwiX2h0bWwiLCJpdGVtTmFtZSIsIml0ZW0iLCJpbmRleE5hbWUiLCJhZnRlckNvbnN0cnVjdCIsImlzUmVuZGVyZWQiLCJhZnRlclJlbmRlciIsImlzSW5zdGFuY2VPZiIsIkNsYXNzIiwiU3ViY2xhc3MiLCJpc1Byb3RvdHlwZU9mIiwicmVtb3ZlV2l0aFBhcmVudFNpZ25hbCIsIndhdGNoRm9yQWxsTG9jYWxzIiwiYmxvY2siLCJ3YXRjaEZvckFsbEdsb2JhbHMiLCJnbG9iIiwid2F0Y2hGb3JBbGxBcmdzIiwid3JhcEJsb2NrIiwid3JhcHBlciIsInJldHVyblZhbHVlIiwid3JhcE1peGluIiwiaW5pdEFwcCIsImNvbnRhaW5lciIsIkVycm9yIiwiUm9vdEJsb2NrIiwiX3ZhcnMiLCJlcXVhbHMiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJjb25zdHJ1Y3RTdHlsZUZyb21TdHJpbmciLCJzdHlsZSIsIkNTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgiLCJ0cmltIiwiZ2V0UHJvcCIsImhhc0F0dHIiLCJnZXRWYWx1ZUZvclNldHRpbmciLCJpbnB1dFZhbHVlIiwiaXNSYWRpbyIsImdldFZhbHVlRm9yR2V0dGluZyIsIm9wdGlvbnMiLCJpbml0IiwiaXNNdWx0aXBsZSIsImFkZFZhbHVlIiwiY29uY2F0IiwiZ2V0TGlzdGVuZXJOYW1lIiwic2VsZWN0ZWQiLCJpbnNlcnRUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZSIsInRlbXBsYXRlcyIsIml0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbiIsIm5vZGVzIiwidHJpbW1lZCIsIm5ld1RlbXBsYXRlcyIsIm5ld1RlbXBsYXRlIiwibmV3VmFycyIsInJlbW92ZUFwcCIsIkR3YXluZVJvb3RCbG9jayIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiT2JqZWN0IiwiQXJyYXkiLCJyZWdleHBTcGVjaWFsQ2hhcmFjdGVycyIsIm1hcCIsInMiLCJqb2luIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInNldFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJwcm90byIsIl9fcHJvdG9fXyIsInJvb3RCbG9ja3MiLCJyb290TWl4aW5zIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsIkVWRU5UX1JFR0VYIiwiZW1wdHlDb2xsZWN0aW9uIiwiX3RoaXMiLCJpbmNsdWRlcyIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJ0aGlzIiwiZWxlbXMiLCJmb3JFYWNoIiwibGlzdCIsImNsYXNzTGlzdCIsImNscyIsImF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVOUyIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlIiwiY2hpbGROb2RlcyIsImNvbGxlY3QiLCJpcyIsImVsZW1lbnRzIiwiY2IiLCJjb250YWlucyIsImVsIiwiaXNUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJyZW1vdmVDU1MiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiY3NzVGV4dCIsImRhdGFzZXQiLCJldmVudCIsImRldGFpbHMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInJlYWxEZXRhaWxzIiwiZmluYWxFdmVudCIsIkV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZmlsdGVyRm4iLCJCb29sZWFuIiwiaGFzQXR0cmlidXRlTlMiLCJoYXNBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJuZXh0IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJlbmQiLCJmaXJzdENoaWxkIiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsImxpc3RlbmVyIiwibmV3RXZlbnRzIiwiYWxsTGlzdGVuZXJzIiwibGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwicmVtb3ZlQXR0cmlidXRlIiwiZmlyc3QiLCJwcmV2IiwiYmFiZWxIZWxwZXJzLmdldCIsImFwcGx5IiwidGV4dENvbnRlbnQiLCJjb25kaXRpb24iLCJfYXJndW1lbnRzNSIsInRvZ2dsZSIsIl9hcmd1bWVudHM2Iiwic3BlY2llcyIsIl92YWx1ZSIsImN1cnJlbnRWYWx1ZSIsImlzUGFyZW50U2lnbmFsIiwiaXNSZW1vdmVkIiwiYmVmb3JlUmVtb3ZlIiwid3JhcHBlcnMiLCJyZWR1Y2UiLCJibG9ja0hvb2tzIiwibWl4aW5Ib29rcyIsIlRBR19OQU1FX1JFR0VYIiwiQVRUUl9OQU1FX1JFR0VYIiwiV0FUQ0hFRF9BUkdfUFJFRklYX1JFR0VYIiwiV0FUQ0hFRF9HTE9CQUxfUFJFRklYX1JFR0VYIiwiYWZ0ZXJFbGVtIiwicm9vdFZhcnMiLCJyb290VGVtcGxhdGUiLCJvcmlnaW5hbEFyZ3MiLCJjaGlsZHJlbkJsb2NrcyIsImZ1bmMiLCJvbkNoYW5nZSIsInRhcmdldEJsb2NrIiwiZm9yREVsZW1lbnRzIiwiZm9yREl0ZW0iLCJmb3JERWFjaCIsIm9uQ2hhbmdlRmxhZyIsInJlc3VsdCIsImV4cHJlc3Npb24iLCJvcmlnaW5hbCIsIm9uRXZhbEVycm9yIiwiZSIsImxvY2FsV2F0Y2hlcnMiLCJuZXdSZXN1bHQiLCJ3YXRjaGVyQmxvY2siLCJyZW1vdmVDb250ZW50IiwiX3RoaXM4IiwibmV3Q29udGVudCIsImFmdGVyRE9NQ2hhbmdlIiwiY29udGVudFRvQWRkIiwibm90UmVjdXJzaXZlIiwib2xkQ29udGVudCIsImNoYW5nZUNvbnRlbnQiLCJjb250ZW50VG9Nb3ZlIiwiYWZ0ZXIiLCJpbmRleFRvUHV0IiwibW92ZUNvbnRlbnQiLCJjb250ZW50VG9SZW1vdmUiLCJmaWx0ZXIiLCJjb250ZW50VG9JbnNlcnQiLCJtb3ZlRmxhZyIsInRyeVRvQWRkT3JNb3ZlIiwiZGVmYXVsdExvY2FscyIsImRlZmF1bHRBcmdzIiwibG9jYWxBcmdzIiwicmVzdEFyZ3MiLCJpc0RFbGVtZW50cyIsImhvb2siLCJ3YXJuIiwiY3VycmVudFJldHVyblZhbHVlIiwiYmxvY2tzIiwiaHRtbENoaWxkcmVuIiwib2xkV2F0Y2hlciIsIl90aGlzOSIsIkRCbG9jayIsInBhcmVudFBhcmVudFNjb3BlIiwicGFyZW50UGFyZW50VGVtcGxhdGUiLCJvd25DaGlsZHJlbiIsImZvdW5kIiwiUGFyZW50U2NvcGUiLCJQYXJlbnRUZW1wbGF0ZSIsImRCbG9ja3MiLCJESXRlbSIsIndhdGNoQXJncyIsInVpZCIsInJlbmRlclNldCIsIl90aGlzMiIsIml0ZW1zQnlVSURzIiwiVUlEIiwic29ydEJ5IiwibmV3SXRlbXNCeVVJRHMiLCJuZXdVSURzQ291bnRlciIsIm5ld1VJRHMiLCJzZXQiLCJmaWx0ZXJCeSIsImlzQXJyIiwiaXRlcmF0ZSIsInNvcnQiLCJpdGVtcyIsInNoaWZ0IiwiSW5maW5pdHkiLCJjb25kIiwiaWYiLCJ2YWwiLCJvZmYiLCJvbiIsImNsYXNzZXMiLCJuZXdDbGFzc2VzIiwiREhpZGUiLCJpbml0aWFsU2NvcGVWYWx1ZSIsInNldFByb3AiLCJpbml0aWFsRWxlbVZhbHVlIiwiaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwiLCJpc0NoZWNrYm94IiwiY2hhbmdlU2NvcGUiLCJvZmZFbGVtTGlzdGVuZXIiLCJvZmZGb3JtTGlzdGVuZXIiLCJvcHRpb24iLCJib2R5Il0sIm1hcHBpbmdzIjoieUJBQU8sU0FBU0EsR0FBaUJDLEVBQU9DLE1BQVVDLHNFQUNuQ0YsRUFBTyxTQUFDRyxFQUFPQyxLQUNqQkYsRUFBY0MsRUFBT0MsRUFBT0osS0FHaENFLEVBR1QsUUFBZ0JHLEdBQVlMLEVBQU9DLE9BQzVCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsSUFBSyxJQUNoREgsR0FBUUgsRUFBTU0sTUFFaEJMLEVBQVNFLEVBQU9HLEVBQUdOLGNBRWRNLFlBT2IsUUFBZ0JFLEdBQWFSLEVBQU9DLE9BQzdCLEdBQUlLLEdBQUksRUFBR0MsRUFB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"}