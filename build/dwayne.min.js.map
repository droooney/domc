{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/toStringTag.js","../src/utils/is.js","../src/utils/escapeRegex.js","../src/utils/noop.js","../src/utils/toCase.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/is.js","../src/helpers/Elem/getEvent.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/matches.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/constructMixinRegex.js","../src/helpers/Block/mixinMatch.js","../src/helpers/Block/transformRestAttrs.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/normalizeArgs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/remove.js","../src/helpers/Block/wrap.js","../src/mixins/d-style.js","../src/mixins/d-value.js","../src/insertTemplates.js","../src/initApp.js","../src/removeApp.js","../src/global.js","../src/utils/objectStatics.js","../src/constants.js","../src/Elem.js","../src/utils/setSymbolSpecies.js","../src/Mixin.js","../src/Block.js","../src/blocks/d-block.js","../src/blocks/d-item.js","../src/blocks/d-each.js","../src/blocks/d-elements.js","../src/blocks/d-if.js","../src/blocks/d-switch.js","../src/mixins/d-bind.js","../src/mixins/d-class.js","../src/mixins/d-elem.js","../src/mixins/d-hide.js","../src/mixins/d-node.js","../src/mixins/d-on.js","../src/mixins/d-show.js","../src/helpers/Block/registerBuiltins.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","import { iterateArray } from './array';\n\nconst {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  iterateArray(arguments, (source, index) => {\n    if (index) {\n      iterateObject(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\n/**\n * @function defineProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining properties of an object.\n */\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineFrozenProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining frozen properties of an object.\n */\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","import { definePrototypeProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nconst { toString } = {};\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(klass, tag) {\n  if (Symbol.toStringTag) {\n    definePrototypeProperties(klass.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","/**\n * @module helpers/checkTypes\n * @private\n * @mixin\n * @description Exports is<Type> methods.\n */\n\nimport { toStringTag } from './toStringTag';\n\n/**\n * @function isArray\n * @public\n * @param {*} value - Value to check if it is an array.\n * @returns {Boolean} If the argument is an array or not.\n * \n * @example\n * isArray([]);                             // true\n * isArray(0);                              // true\n * isArray(document.querySelectorAll('*')); // false\n */\nexport const { isArray } = Array;\n\n/**\n * @function isFunction\n * @public\n * @param {*} value - Value to check if it is a function.\n * @returns {Boolean} If the argument is a function or not.\n * \n * @example\n * isFunction(() => {});            // true\n * \n * const func = () => {};\n * Object.setPrototypeOf(func, {});\n * isFunction(func);                // true\n */\nexport function isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\n * @function isNil\n * @public\n * @param {*} value - Value to check if it is null or undefined.\n * @returns {Boolean} If the argument is null or undefined or not.\n *\n * @example\n * isNil(null);      // true\n * isNil(undefined); // true\n * isNil(false);     // false\n */\nexport function isNil(value) {\n  /* eslint eqeqeq: 0 */\n  return value == null;\n}\n\n/**\n * @function isString\n * @public\n * @param {*} value - Value to check if it is a string.\n * @returns {Boolean} If the argument is a string or not.\n *\n * @example\n * isString('0');             // true\n * isString(new String('0')); // true\n */\nexport function isString(value) {\n  return toStringTag(value) === 'String';\n}\n","const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\nconst regexpSpecialsRegexp = new RegExp(\n  regexpSpecialCharacters\n    .map((s) => `\\\\${ s }`)\n    .join('|'),\n  'g'\n);\n\nexport function escapeRegex(string) {\n  return string.replace(regexpSpecialsRegexp, '\\\\$&');\n}\n","export function noop() {}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_FIND_REGEX = /^xlink:\\w/;\nconst X_LINK_ATTR_REPLACE_REGEX = /^xlink:/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst Null = {\n  ns: null\n};\n\nexport function getAttrNS(attr, elem) {\n  const isXmlNs = attr === 'xmlns';\n\n  if (isXmlNs || attr === 'xmlns:xlink') {\n    if (elem.nodeName !== 'SVG') {\n      return Null;\n    }\n\n    return {\n      ns: XML_NS,\n      name: isXmlNs\n        ? 'xmlns'\n        : 'xlink'\n    };\n  }\n\n  if (X_LINK_ATTR_FIND_REGEX.test(attr)) {\n    if (!new Elem(elem).closest('svg').length) {\n      return Null;\n    }\n\n    return {\n      ns: X_LINK_NS,\n      name: attr.replace(X_LINK_ATTR_REPLACE_REGEX, '')\n    };\n  }\n\n  return Null;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { Elem } from '../../Elem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\nconst DOCUMENT_REGEX = /Document$/;\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isDocument(value) {\n  return DOCUMENT_REGEX.test(toStringTag(value));\n}\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || DOCUMENT_REGEX.test(tag)\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","import { assign, toStringTag } from '../../utils';\nimport { isDocument } from './is';\n\nconst EVENT_REGEX = /Event$/;\n\nexport function getEvent(event, bubbles, cancelable, realDetails, elem) {\n  let finalEvent = event;\n\n  if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n    try {\n      finalEvent = new Event(finalEvent, { bubbles, cancelable });\n      assign(finalEvent, realDetails);\n    } catch (err) {\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      finalEvent = document.createEvent('Event');\n      finalEvent.initEvent(event, bubbles, cancelable);\n\n      assign(finalEvent, realDetails);\n    }\n  }\n\n  return finalEvent;\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { isDocument } from './is';\n\nconst { indexOf } = [];\n\nexport function getMatchesFunction(elem) {\n  return (\n    elem.matches\n    || elem.matchesSelector\n    || elem.webkitMatchesSelector\n    || elem.mozMatchesSelector\n    || elem.msMatchesSelector\n    || elem.oMatchesSelector\n    || matches\n  );\n}\n\nfunction matches(selector) {\n  const document = isDocument(this)\n    ? this\n    : this.ownerDocument;\n\n  return document.querySelectorAll(selector)::indexOf(this) !== -1;\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './is';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\nimport { document } from './constants';\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, iterateObject, keys } from '../../utils';\n\nexport function calculateArgs(args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  iterateObject(args, (value, arg) => {\n    argsObject[arg] = value;\n  });\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { escapeRegex } from '../../utils';\n\nexport function constructMixinRegex(name) {\n  return new RegExp(`^${ escapeRegex(name) }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n","const COMMA_REGEX = /,/;\n\nexport function mixinMatch(mixins, attr) {\n  let match;\n\n  /* eslint guard-for-in: 0 */\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (argsMatch === '') {\n        args = [];\n      } else if (argsMatch) {\n        args = argsMatch.split(COMMA_REGEX);\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n\n  return match;\n}\n","import { collectFromObject, assign } from '../../utils';\nimport { D_REST_REGEX } from '../../constants';\nimport { mixinMatch } from './mixinMatch';\n\nexport function transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return collectFromObject(attrs, (eventualAttrs, value, attr) => {\n    if (D_REST_REGEX.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  });\n}\n\nexport function transformRestArgs(args) {\n  return collectFromObject(args, addArgs);\n}\n\nfunction addArgs(args, value, arg) {\n  if (D_REST_REGEX.test(arg)) {\n    assign(args, transformRestArgs(value));\n  } else {\n    args[arg] = value;\n  }\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","import { iterateObject, iterateArray } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\n\nexport function calculateAttrs(normalizedAttrs, attrs, attrsObject, elem, firstTime) {\n  iterateObject(attrsObject, ({ type, value }, attr) => {\n    if (!attrs[attr]) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = [];\n\n  iterateObject(normalizedAttrs, ({ type, dynamic, value, opts }, attr) => {\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue,\n        dynamic: prevDynamic\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        let mixin = prevValue;\n        let created;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n\n          created = true;\n          opts.dynamic = dynamic;\n          mixin = new opts.Mixin(opts);\n        } else {\n          mixin.$$.isDynamic = dynamic;\n        }\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(\n            value,\n            constructMixinWatcher(mixin, attr, attrs),\n            mixin\n          );\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        } else if (prevDynamic && opts.Mixin.evaluate) {\n          executeMixinWatchers(mixin, mixin.$$.parentScope.$$.evaluate(value));\n        }\n\n        nextValue = mixin;\n\n        if (created) {\n          mixin.$$.setAfterUpdate();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = new opts.Mixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(\n              value,\n              constructMixinWatcher(mixin, attr, attrs),\n              mixin\n            );\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n          mixin.$$.setAfterUpdate();\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  });\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, (buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n\nfunction constructMixinWatcher(mixin, attr, attrs) {\n  return function (newValue) {\n    const {\n      type,\n      dynamic\n    } = attrs[attr];\n\n    if (type === 'mixin' && !dynamic) {\n      executeMixinWatchers(mixin, newValue);\n    }\n  };\n}\n","import { iterateArray, iterateObject } from '../../utils';\n\nexport function normalizeArgs(argsChain) {\n  const newArgs = {};\n\n  iterateArray(argsChain, (args) => {\n    iterateObject(args, (value, arg) => {\n      newArgs[arg] = value;\n    });\n  });\n\n  return newArgs;\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: []\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { gettingVars, evalMode } from '../../Block';\nimport { removeTempWatcher } from './removeWatcher';\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (gettingVars.indexOf(scope.watchers) === -1) {\n            gettingVars.push(scope.watchers);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        const oldTempWatchers = scope.watchers.slice();\n\n        scope.watchers = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n      }\n    };\n  }));\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil\n} from '../../utils';\nimport { isDocument } from '../Elem';\nimport { Elem } from '../../Elem';\nimport {\n  SVG_NS, D_REST_REGEX\n} from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { transformRestAttrs } from './transformRestAttrs';\nimport { calculateAttrs } from './calculateAttrs';\nimport { normalizeArgs } from './normalizeArgs';\nimport { mixinMatch } from './mixinMatch';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { Block } from '../../Block';\n\nconst NAMED_D_BLOCK_REGEX = /^d-block:([\\s\\S]+)$/;\nconst emptyArray = [];\n\nexport function createBlock({ node, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = isDocument(parentElem[0])\n    ? parentElem\n    : new Elem(parentElem[0].ownerDocument);\n  const elem = parentElem[0].namespaceURI === SVG_NS\n    ? doc.create('svg')\n    : doc;\n  const localBlocks = parentTemplate ? parentTemplate.$$.ns._blocks : Block._blocks;\n  const localMixins = parentTemplate ? parentTemplate.$$.ns._mixins : Block._mixins;\n  const args = node.attrs || {};\n  const name = node.name || 'UnknownBlock';\n  let { children } = node;\n  let constructor = node.Constructor || (node.name && localBlocks[node.name]);\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n\n  if (name === 'd-block' && args.name) {\n    dBlockArgs = except(args, 'name');\n  } else if (name === 'd-block' && args.Constructor) {\n    dBlockArgs = except(args, 'Constructor');\n  } else if ((dBlockMatch = name.match(NAMED_D_BLOCK_REGEX)) || name === 'd-block') {\n    constructor = Block._blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        dBlockArgs,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const { value } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = create(null);\n    let attrs = create(null);\n    let wasDRest;\n    const attrsChain = [attrs];\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    iterateObject(args, (value, attr) => {\n      const isDRest = D_REST_REGEX.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? create(attrs)\n        : attrs;\n\n      if (attrs !== localAttrs) {\n        attrsChain.push(localAttrs);\n      }\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localAttrs, cleanProperty);\n          assign(localAttrs, transformRestAttrs(\n            value,\n            localMixins,\n            mixinDefaultOpts\n          ));\n          calculateAttrs(normalizeArgs(attrsChain), attrs, currentAttrs, element, false);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(normalizeArgs(attrsChain), attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    parentBlock.$$.mixinsToBuild.push(calculateAttrs(normalizeArgs(attrsChain), attrs, currentAttrs, element, true));\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        element.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      element.text(`${ text }`);\n    }\n\n    const isParentBlock = parent instanceof Block;\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    if (children) {\n      let prevBlock;\n      let parentElem = element;\n\n      if (name === 'template') {\n        parentElem = new Elem(element[0].content);\n      } else if (name === 'iframe') {\n        if ('src' in attrs) {\n          children = emptyArray;\n        } else {\n          const document = element[0].contentDocument;\n\n          new Elem(document.documentElement).remove();\n\n          parentElem = new Elem(document);\n        }\n      }\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  const html = name === 'd-elements'\n    ? Args.value || []\n    : constructor.template.value;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  iterateArray(blockInstance.$$.mixinsToBuild, (executeBuilders) => {\n    executeBuilders();\n  });\n  blockInstance.$$.mixinsToBuild = [];\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /\\s*;\\s*/;\nconst CSS_STYLE_SEPARATOR_REGEX = /\\s*:\\s*/;\n\nrootMixins['d-style'] = class DStyle extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean)\n          .map(constructStyleFromString),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        css\n      } = this;\n\n      elem.removeCSS.apply(elem, keys(css));\n    }\n  }\n};\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n\nfunction constructStyleFromString(style) {\n  const split = style.split(CSS_STYLE_SEPARATOR_REGEX);\n\n  return [\n    split[0].trim(),\n    split[1].trim()\n  ];\n}\n","import {\n  isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-value'] = class DValue extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.find('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      this.value = args[0];\n    }\n\n    if (!isFunction(this.value)) {\n      initialScopeValue = this.scope.$$.evaluate((scope) => scope[this.value], (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue, false);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), changeScope);\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.offElemListener();\n    }\n\n    this.offFormListener();\n  }\n};\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      values = values || [];\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        return values.indexOf(inputValue) === -1\n          ? values.concat(inputValue)\n          : values;\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n","import {\n  toObjectKeys,\n  assign, keys, create\n} from './utils';\n\nexport function insertTemplates(template, templates) {\n  const {\n    vars,\n    value\n  } = template;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n  iterateAndChangeChildren(value);\n\n  function iterateAndChangeChildren(nodes = []) {\n    for (let i = 0; i < nodes.length; i++) {\n      const {\n        name,\n        value,\n        children\n      } = nodes[i];\n\n      if (name === '#comment') {\n        const trimmed = value.trim();\n\n        if (newTemplates[trimmed]) {\n          const newTemplate = newTemplates[trimmed].value;\n\n          nodes.splice(i, 1, ...newTemplate);\n          assign(newVars, toObjectKeys(newTemplates[trimmed].vars));\n\n          i += newTemplate.length - 1;\n        }\n      } else {\n        iterateAndChangeChildren(children);\n      }\n    }\n  }\n\n  vars.length = 0;\n  vars.push(...keys(newVars));\n\n  return template;\n}\n","import { isArray, isString } from './utils';\nimport { createBlock, isInstanceOf } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function initApp\n * @public\n * @param {Template|ScopelessTemplate|String|typeof Block} block - Root template (may be scopeless),\n * string defining a name of the root block or a block subclass.\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for initializing app.\n *\n * @example\n * import { initApp, doc } from 'dwayne';\n *\n * initApp(html`<App/>`, doc.create('div'));\n * initApp(htmlScopeless`<App/>`, doc.create('div'));\n * initApp('App', doc.create('div'));\n * initApp(App, doc.create('div'));\n */\nexport function initApp(block, container) {\n  const parentElem = new Elem(container).elem(0);\n\n  if (!parentElem.length) {\n    console.error('No valid element to insert the app into was given! (initApp)');\n\n    return;\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    console.error('There already exists a Dwayne app inside the given element! (initApp)');\n\n    return;\n  }\n\n  if (isString(block)) {\n    block = {\n      vars: [],\n      value: [{\n        name: block\n      }]\n    };\n  }\n\n  if (isArray(block)) {\n    block = {\n      vars: [],\n      value: block\n    };\n  }\n\n  let Constructor;\n\n  if (isInstanceOf(Block, block)) {\n    Constructor = block;\n  } else {\n    Constructor = class RootBlock extends Block {\n      static template = block;\n    };\n  }\n\n  const rootBlock = createBlock({\n    node: {\n      name: '#RootBlock',\n      Constructor\n    },\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', rootBlock)\n    .attr('dwayne-root', '');\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function removeApp\n * @public\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for removing app.\n *\n * @example\n * import { removeApp, find } from 'dwayne';\n *\n * removeApp(find('.root'));\n */\nexport function removeApp(container) {\n  const elem = new Elem(container).elem(0);\n\n  if (!elem.length) {\n    console.error('No valid element to remove the app from was given! (removeApp)');\n\n    return;\n  }\n\n  container = elem[0];\n\n  const { DwayneRootBlock } = container;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    console.error('No app registered inside the given element! (removeApp)');\n\n    return;\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete container.DwayneRootBlock;\n}\n","/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint no-proto: 0 */\n  target.__proto__ = proto;\n});\n","import { create } from './utils/objectStatics';\n\nexport const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const D_REST_REGEX = /^d-rest(?:#|$)/;\n\nexport const rootBlocks = create(null);\nexport const rootMixins = create(null);\nexport const {\n  document = {},\n  Symbol = {}\n} = global;\n","import {\n  isNil, isString,\n  definePrototypeProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, setSymbolSpecies,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isDocument, isValidNode, getMatchesFunction,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, getEvent, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback CollectCallback\n * @public\n * @param {AddCallback} add - Add element to the eventual set function.\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback AddCallback\n * @public\n * @param {...(Element|Node|elem)} elem - Element to add.\n */\n\n/**\n * @callback ElemMethod\n * @public\n * @this Elem\n */\n\nconst EVENT_SEPARATOR_REGEX = /[,| ] */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array.<Element|Node>\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  /**\n   * @method Elem.addMethods\n   * @public\n   * @param {String|Object.<String, ElemMethod>} methodName - Name of the method or object of\n   * method names and methods.\n   * @param {ElemMethod} [method] - If the first argument is a string this should be the method itself.\n   * @returns {typeof Elem}\n   */\n  static addMethods(methodName, method) {\n    if (arguments.length >= 2) {\n      methodName = { [methodName]: method };\n    }\n\n    definePrototypeProperties(this.prototype, methodName);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add(...elements) {\n    const elems = this.slice();\n\n    iterateArray(elements, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromArray(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const {\n        ns,\n        name\n      } = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, name)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const { ns } = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  /**\n   * @method Elem#collect\n   * @public\n   * @param {CollectCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns eventual set.\n   * @description Method for collecting elements into a new set.\n   *\n   * @example\n   * const parents = elem.collect((add, elem) => {\n   *   add(elem.parentNode);\n   * });\n   */\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        el = type === 'svg'\n          ? document.createElementNS(SVG_NS, type)\n          : document.createElement(type);\n      }\n\n      if (!isDocument(elem)) {\n        new Elem(el).into(elem);\n      }\n\n      add(el);\n    });\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details;\n\n    return this.forEach((elem) => {\n      elem.dispatchEvent(getEvent(\n        event,\n        bubbles,\n        cancelable,\n        realDetails,\n        elem\n      ));\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback|String} filter - Filter function or a selector.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filter) {\n    if (isString(filter)) {\n      const selector = filter;\n\n      filter = (elem) => (\n        new Elem(elem).is(selector)\n      );\n    }\n\n    return this.collect((add, elem, index) => {\n      if (filter(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const { ns } = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  /**\n   * @method Elem#includes\n   * @public\n   * @param {Element|node} elem - Element to search.\n   * @return {Boolean} If the element is in the set.\n   * @description The same as Array#includes.\n   */\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (!element) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = getMatchesFunction(elem);\n\n    return elem::matches(selector);\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr(...attributes) {\n    return this.forEach((elem) => {\n      iterateArray(attributes, (attr) => {\n        const { ns } = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS(...props) {\n    return this.forEach((elem) => {\n      iterateArray(props, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  /**\n   * @method Elem#slice\n   * @public\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n   * @returns {Elem}\n   * @description The same as Array#slice but for Elem.\n   */\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      classList.toggle(cls, arguments.length < 2 ? !classList.contains(cls) : condition);\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\nsetSymbolSpecies(Elem, Array);\n\nexport { Elem };\n","import { defineProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nexport function setSymbolSpecies(klass, species) {\n  if (Symbol.species) {\n    defineProperties(klass, {\n      [Symbol.species]: {\n        get() {\n          return species;\n        }\n      }\n    });\n  }\n}\n","import {\n  defineFrozenProperties, getProto,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\nconst toStringTag = '[object Mixin]';\n\n/**\n * @class Mixin\n * @public\n * @param {Object} opts - Mixin options.\n * @returns {Mixin} Instance of Mixin.\n */\nclass Mixin {\n  /**\n   * @member {Boolean} [Mixin.evaluate = true]\n   * @type {Boolean}\n   * @public\n   * @description If the mixin value should be evaluated and watched or not.\n   */\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n    const { constructor } = getProto(this);\n    const afterUpdate = (newValue, oldValue) => {\n      this.$$.value = newValue;\n\n      try {\n        this.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    };\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Mixin#$$\n       * @type {Object}\n       * @protected\n       * @property {Function} Mixin#$$.evaluate - Evaluate function.\n       * @property {Boolean} Mixin#$$.isDynamic - If the mixin is dynamic.\n       * @property {Boolean} Mixin#$$.isRemoved - If the block is removed.\n       * @property {String} Mixin#$$.name - Mixin name.\n       * @property {Block|void} Mixin#$$.parentBlock - Parent block.\n       * @property {Block|void} Mixin#$$.parentScope - Parent scope.\n       * @property {Block|void} Mixin#$$.parentTemplate - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing mixin.\n       */\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          isParentSignal = !!isParentSignal;\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove(isParentSignal);\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        },\n        setAfterUpdate: () => {\n          if (constructor.evaluate) {\n            afterUpdate(this.$$.evaluate(afterUpdate));\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {String} [Mixin#comment]\n     * @type {String}\n     * @public\n     */\n    this.comment = comment;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    parentBlock.$$.mixins.push(this);\n  }\n\n  afterUpdate() {}\n\n  /**\n   * @method Mixin#beforeRemove\n   * @public\n   * @param {Boolean} isElementRemoved - If element removed as well.\n   * @description Is called before the mixin removal.\n   */\n  beforeRemove(isElementRemoved) {}\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, isArray,\n  setToStringTag, hasOwnProperty,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  constructMixinRegex, isInstanceOf, normalizeArgs,\n  removeWatchers, removeWithParentSignal, cleanProperty,\n  transformRestArgs, calculateArgs, wrapBlock\n} from './helpers/Block';\nimport {\n  D_REST_REGEX,\n  rootBlocks, rootMixins\n} from './constants';\nimport { Mixin } from './Mixin';\n\n/**\n * @typedef {Object} Template\n * @public\n * @property {String[]} vars - Template used vars.\n * @property {Object[]} value - Template itself.\n */\n\n/**\n * @typedef {Object[]} ScopelessTemplate\n * @public\n */\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {Function} func - Function which caused eval error.\n * @property {String} original - Evaluated expression original js.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {Mixin} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {typeof Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {typeof Mixin} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\n/**\n * @callback RemoveHook\n * @public\n */\n\nconst blockHooks = [];\nconst mixinHooks = [];\nconst TAG_NAME_REGEX = /^[a-z][a-z\\d\\-_.:!@#$%^&*()[\\]{}='\"\\\\]*$/i;\nconst ATTR_NAME_REGEX = /^[^\\u0000-\\u0020\\s'\">/=]+$/;\nconst toStringTag = '[object Block]';\nconst afterElem = new Elem();\nconst emptyObject = {};\nlet evalMode = false;\nlet gettingVars = [];\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Block options.\n * @returns {Block} Instance of Block.\n *\n * @example\n * import { Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/> ({ this.times })';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     this.interval = setInterval(() => {\n *       this.times++;\n *     });\n *   }\n *\n *   beforeRemove() {\n *     clearInterval(this.interval);\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', html`Hello, {args.text}!`);\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  /**\n   * @member {Object.<String, typeof Block>} Block._blocks\n   * @type {Object.<String, typeof Block>}\n   * @protected\n   * @description Block namespace blocks.\n   */\n  static _blocks = create(rootBlocks);\n\n  /**\n   * @member {Object.<String, typeof Mixin>} Block._mixins\n   * @type {Object.<String, typeof Mixin>}\n   * @protected\n   * @description Block namespace mixins.\n   */\n  static _mixins = create(rootMixins);\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {Object} [Block.template = { vars: [], value: [] }]\n   * @type {Object}\n   * @public\n   * @description Block template.\n   */\n  static template = {\n    vars: [],\n    value: []\n  };\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.original || err.func }\" in context of ${ err.block.$$.name }):`, err);\n  }\n\n  /**\n   * @method Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterBlock(hook) {\n    blockHooks.push(hook);\n\n    return () => {\n      removeArrayElem(blockHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterMixin(hook) {\n    mixinHooks.push(hook);\n\n    return () => {\n      removeArrayElem(mixinHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Template|ScopelessTemplate|typeof Block} Subclass - Subclass of Block or template string of it.\n   * @returns {typeof Block|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        static template = constructor.template;\n\n        constructor(opts) {\n          super(opts);\n          this::constructor(opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass)) {\n      Subclass = class extends Block {\n        static template = {\n          vars: [],\n          value: Subclass\n        };\n      };\n    }\n\n    if (!isFunction(Subclass) && Subclass.vars && Subclass.value) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      console.warn(`Block must be a template (array or an object from an html loader), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (rootBlocks[name]) {\n      console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!TAG_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_blocks')) {\n      this._blocks = create(getProto(this)._blocks);\n    }\n\n    if (!hasOwnProperty(this, 'defaultLocals')) {\n      this.defaultLocals = {};\n    }\n\n    if (!hasOwnProperty(this, 'defaultArgs')) {\n      this.defaultArgs = create(null);\n    }\n\n    try {\n      Subclass = blockHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Block, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterBlock\" hook:', err);\n    }\n\n    if (isArray(Subclass.template)) {\n      Subclass.template = {\n        vars: [],\n        value: Subclass.template\n      };\n    }\n\n    Subclass._blocks = hasOwnProperty(Subclass, '_blocks')\n      ? Subclass._blocks\n      : create(this._blocks);\n    Subclass._mixins = hasOwnProperty(Subclass, '_mixins')\n      ? Subclass._mixins\n      : create(this._mixins);\n\n    if (hasOwnProperty(Subclass, 'defaultArgs')) {\n      setProto(Subclass.defaultArgs, null);\n    }\n\n    this._blocks[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.get\n   * @public\n   * @param {String} name - Block name.\n   * @returns {typeof Block|undefined} Returns registered Block with specified name.\n   */\n  static get(name) {\n    return this._blocks[name];\n  }\n\n  /**\n   * @method Block.getMixin\n   * @public\n   * @param {String} name - Mixin name.\n   * @returns {typeof Mixin|undefined} Returns registered Mixin with specified name.\n   */\n  static getMixin(name) {\n    return this._mixins[name];\n  }\n\n  /**\n   * @method Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {typeof Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {typeof Mixin|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          this::afterUpdate(newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin or is not an afterUpdate function, so it will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (rootMixins[name] || name === 'd-rest') {\n      console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!ATTR_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_mixins')) {\n      this._mixins = create(getProto(this)._mixins);\n    }\n\n    try {\n      Subclass = mixinHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Mixin, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterMixin\" hook:', err);\n    }\n\n    Subclass._match = constructMixinRegex(name);\n\n    this._mixins[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      dBlockArgs,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const { constructor } = getProto(this);\n    const childrenBlocks = [];\n    const mixins = [];\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} Block#$$.args - Private args scope.\n       * @property {Block[]} Block#$$.children - Child blocks.\n       * @property {Elem} Block#$$.content - Content elements.\n       * @property {Object|void} Block#$$.dBlockArgs - d-block args.\n       * @property {String|void} Block#$$.dBlockName - d-block name.\n       * @property {Block[]} Block#$$.dBlocks - d-block's within the block.\n       * @property {Function} Block#$$.evaluate - Evaluate function.\n       * @property {Object} Block#$$.globals - Private globals scope.\n       * @property {Object[]} Block#$$.htmlChildren - Block html children.\n       * @property {Boolean} Block#$$.isRemoved - If the block is removed.\n       * @property {Boolean} Block#$$.isRendered - If the block is rendered.\n       * @property {Object} Block#$$.locals - Private locals scope.\n       * @property {Mixin[]} Block#$$.mixins - Child mixins.\n       * @property {Function[]} Block#$$.mixinsToBuild - Pending mixins builders.\n       * @property {String} Block#$$.name - Block name.\n       * @property {typeof Block} Block#$$.ns - Block constructor.\n       * @property {Block|Elem|void} Block#$$.parent - Parent block or elem.\n       * @property {Block|void} Block#$$.parentBlock - Parent block.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Block|void} Block#$$.parentScope - Parent scope.\n       * @property {Block|void} Block#$$.parentTemplate - Parent template.\n       * @property {Block|Elem|void} Block#$$.prevBlock - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing the block.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlockArgs,\n        dBlocks: [],\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        htmlChildren: children || [],\n        children: childrenBlocks,\n        mixins,\n        mixinsToBuild: [],\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forDElements, forDItem) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = name === '#d-item' && !forDItem\n            ? this.$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : emptyObject;\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              evalMode = true;\n              gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.func = func;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error(`Uncaught error in ${ name }.onEvalError:`, e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(gettingVars, (watchers) => {\n                const watcher = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved && !this.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(mixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered && !this.$$.isRemoved) {\n            try {\n              this.afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterDOMChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor.template.vars, (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    const { defaultArgs } = constructor;\n    let args = create(defaultArgs || null);\n    let wasDRest;\n    const argsChain = [];\n\n    if (defaultArgs) {\n      argsChain.push(defaultArgs);\n    }\n\n    argsChain.push(args);\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isDRest = D_REST_REGEX.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? create(args)\n        : args;\n\n      if (args !== localArgs) {\n        argsChain.push(localArgs);\n      }\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, transformRestArgs(value));\n          calculateArgs(normalizeArgs(argsChain), argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return assign(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      localArgs[arg] = parentScope.$$.evaluate(value, (value) => {\n        localArgs[arg] = value;\n        calculateArgs(normalizeArgs(argsChain), argsObject);\n      }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(normalizeArgs(argsChain), argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed. Note that\n   * it's important not to modify the DOM structure within the block. You can only insert\n   * elements to empty elements (which Dwayne considers empty) and remove ones from them.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#getName\n   * @public\n   * @returns {String}\n   * @description Returns Block name.\n   */\n  getName() {\n    return this.$$.name;\n  }\n\n  /**\n   * @method Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @method Block#getParentScope\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentScope() {\n    return this.$$.parentScope;\n  }\n\n  /**\n   * @method Block#getParentTemplate\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentTemplate() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block, gettingVars, evalMode };\n","import { findInArray, isFunction } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchNameArgs = js`args.name`;\nconst watchConstructorArgs = js`args.Constructor`;\n\nclass DBlock extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{ParentScope}\"\n      parentTemplate=\"{ParentTemplate}\"\n    />\n  `;\n\n  afterConstruct(opts) {\n    const {\n      parentScope: {\n        $$: {\n          parentScope: parentParentScope,\n          parentTemplate: parentParentTemplate,\n          htmlChildren: children\n        }\n      },\n      htmlChildren: ownChildren,\n      parentScope,\n      parentTemplate,\n      dBlockName: DBlockName\n    } = this.$$;\n    const {\n      name,\n      Constructor\n    } = this.args;\n    let found;\n\n    this.ParentScope = parentScope;\n    this.ParentTemplate = parentTemplate;\n\n    if (name) {\n      this.constructDynamicNameBlock(\n        this.evaluate(watchNameArgs, this.constructDynamicNameBlock)\n      );\n\n      return;\n    }\n\n    if (Constructor) {\n      this.constructDynamicConstructorBlock(\n        this.evaluate(watchConstructorArgs, this.constructDynamicConstructorBlock)\n      );\n\n      return;\n    }\n\n    if (ownChildren.length) {\n      parentTemplate.$$.dBlocks.push(this);\n\n      return;\n    }\n\n    this.ParentScope = parentParentScope;\n    this.ParentTemplate = parentParentTemplate;\n\n    if (DBlockName) {\n      found = findInArray(children, ({ name: nodeName }) => nodeName === `d-block:${ DBlockName }`);\n\n      if (!found) {\n        found = findInArray(parentTemplate.$$.dBlocks, ({ $$: { dBlockName } }) => dBlockName === DBlockName);\n\n        if (found) {\n          this.ParentScope = parentTemplate;\n          this.ParentTemplate = parentTemplate;\n          found.value = {\n            children: found.value.$$.htmlChildren\n          };\n        }\n      }\n\n      this.elems = found\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = children;\n    }\n  }\n\n  constructDynamicNameBlock = (name) => {\n    const {\n      htmlChildren,\n      dBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      name,\n      attrs: dBlockArgs,\n      children: htmlChildren\n    }];\n  };\n\n  constructDynamicConstructorBlock = (Constructor) => {\n    if (!isFunction(Constructor)) {\n      this.elems = null;\n\n      return;\n    }\n\n    const {\n      htmlChildren,\n      dBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      Constructor,\n      attrs: dBlockArgs,\n      children: htmlChildren\n    }];\n  };\n}\n\nrootBlocks['d-block'] = DBlock;\n\nexport { DBlock };\n","import { Block } from '../Block';\n\nconst template = html`\n  <d-elements\n    value=\"{$$.htmlChildren}\"\n    parentScope=\"{this}\"\n    parentTemplate=\"{$$.parentTemplate}\"\n  />\n`;\n\nclass DItem extends Block {\n  static template = template;\n}\n\nexport { DItem };\n","import {\n  assign, iterateArray, iterateObject,\n  isArray, isFunction\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\nimport { DItem } from './d-item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nrootBlocks['d-each'] = class DEach extends Block {\n  static defaultArgs = {\n    uid(item, index) {\n      return index;\n    }\n  };\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item: itemName = '$item',\n        index: indexName = '$index'\n      }\n    } = this;\n\n    assign(this.$$, {\n      itemsByUIDs: {},\n      itemName,\n      indexName\n    });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, this.renderSet);\n    this.renderSet();\n  }\n\n  renderSet = () => {\n    const {\n      htmlChildren,\n      itemsByUIDs,\n      parentScope,\n      parentElem,\n      parentTemplate,\n      itemName,\n      indexName\n    } = this.$$;\n    const {\n      args: {\n        sortBy,\n        uid: UID\n      }\n    } = this;\n    const newItemsByUIDs = {};\n    const newUIDsCounter = {};\n    const newUIDs = {};\n    let {\n      set,\n      filterBy\n    } = this.args;\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      const uid = UID(item, index, set, parentScope);\n\n      newUIDsCounter[uid] = (newUIDsCounter[uid] || 0) + 1;\n      newUIDs[index] = uid;\n    });\n\n    iterateObject(itemsByUIDs, (items, uid) => {\n      if (!newUIDsCounter[uid]) {\n        iterateArray(items, remove);\n\n        return;\n      }\n\n      iterateArray(items.splice(newUIDsCounter[uid]), remove);\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (itemsByUIDs[uid] && itemsByUIDs[uid].length) {\n        block = itemsByUIDs[uid].shift();\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        if (block.$$.prevBlock !== prevBlock) {\n          const { content } = block.$$;\n\n          if (prevBlock) {\n            prevBlock.$$.insertAfterIt(content, true);\n          } else {\n            this.$$.insertInStartOfIt(content, true);\n          }\n        }\n      } else {\n        block = createBlock({\n          node: {\n            itemName,\n            indexName,\n            item,\n            index,\n            name: '#d-item',\n            Constructor: DItem,\n            children: htmlChildren\n          },\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      (newItemsByUIDs[uid] = newItemsByUIDs[uid] || []).push(block);\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.$$.itemsByUIDs = newItemsByUIDs;\n  };\n};\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-elements'] = class DElements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, (value) => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n        if (forDElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n      iterateArray(this.$$.mixinsToBuild, (executeBuilders) => {\n        executeBuilders();\n      });\n      this.$$.mixinsToBuild = [];\n    }, this, true);\n  }\n};\n","import { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.if`;\n\nrootBlocks['d-if'] = class DIf extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    this.condition = false;\n    this.constructElems(this.evaluate(watchArgs, this.constructElems));\n  }\n\n  constructElems = (condition) => {\n    condition = !!condition;\n\n    if (this.condition !== condition) {\n      this.condition = condition;\n      this.elems = condition\n        ? this.$$.htmlChildren\n        : null;\n    }\n  };\n};\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`[\n  args.value,\n  args.compareFn\n]`;\n\nrootBlocks['d-switch'] = class DSwitch extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n  static defaultArgs = {\n    compareFn(switchValue, caseValue) {\n      return (\n        switchValue === caseValue\n        || (switchValue !== switchValue && caseValue !== caseValue)\n      );\n    }\n  };\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren,\n        parentScope\n      },\n      args,\n      args: { value }\n    } = this;\n    let wasDefault = false;\n\n    this.values = htmlChildren\n      .filter(({ name }) => {\n        if (name !== 'd-case' && name !== 'd-default') {\n          return;\n        }\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (name === 'd-default') {\n          wasDefault = true;\n        }\n\n        return true;\n      })\n      .map((child, i) => {\n        const {\n          name,\n          attrs = {},\n          children\n        } = child;\n        let val;\n\n        if (name !== 'd-default') {\n          val = parentScope.$$.evaluate(attrs.if, (newValue) => {\n            this.values[i].value = newValue;\n\n            if (i > this.index) {\n              return;\n            }\n\n            const found = findInArray(this.values, ({ name, value }) => (\n              name === 'd-default'\n              || this.args.compareFn(args.value, value)\n            ));\n\n            this.index = found\n              ? found.key\n              : Infinity;\n            this.elems = found\n              ? found.value.children\n              : null;\n          }, this);\n        }\n\n        if (this.index === Infinity && (\n          name === 'd-default'\n          || this.args.compareFn(value, val)\n        )) {\n          this.index = i;\n          this.elems = children;\n        }\n\n        return {\n          name,\n          children,\n          value: val\n        };\n      });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, (args) => {\n      const newValue = args[0];\n      const compareFn = args[1];\n\n      this.index = Infinity;\n\n      this.values.some(({ name, value, children }, i) => {\n        if (\n          name === 'd-default'\n          || compareFn(newValue, value)\n        ) {\n          this.index = i;\n          this.elems = children;\n\n          return true;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n};\n","import { isFunction, noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-bind'] = class DBind extends Mixin {\n  off = noop;\n\n  afterUpdate(value) {\n    this.off();\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n};\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nrootMixins['d-class'] = class DClass extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        classes\n      } = this;\n\n      elem.removeClass.apply(elem, classes);\n    }\n  }\n};\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-elem'] = class DElem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nclass DHide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n}\n\nrootMixins['d-hide'] = DHide;\n\nexport { DHide };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-node'] = class DNode extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n};\n","import { noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-on'] = class DOn extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-show'] = class DShow extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n};\n","import { iterateObject } from '../../utils';\nimport { rootMixins } from '../../constants';\nimport { constructMixinRegex } from './constructMixinRegex';\n\niterateObject(rootMixins, (Mixin, name) => {\n  Mixin._match = constructMixinRegex(name);\n});\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\nimport { document } from './constants';\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","assign","target","arguments","source","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","toStringTag","toString","setToStringTag","klass","tag","Symbol","prototype","isFunction","isNil","isString","escapeRegex","string","replace","regexpSpecialsRegexp","noop","toCamelCase","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","isXmlNs","nodeName","Null","XML_NS","X_LINK_ATTR_FIND_REGEX","test","Elem","closest","X_LINK_NS","X_LINK_ATTR_REPLACE_REGEX","isDocument","DOCUMENT_REGEX","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isValidNode","ELEMENT_REGEX","getEvent","event","bubbles","cancelable","realDetails","finalEvent","EVENT_REGEX","Event","err","document","ownerDocument","createEvent","initEvent","hide","addClass","getMatchesFunction","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","this","querySelectorAll","remove","parent","removeChild","show","removeClass","toElem","base","String","calculateArgs","args","argsObject","keys","arg","undefined","cleanProperty","constructMixinRegex","RegExp","mixinMatch","mixins","Mixin","localMatch","_match","argsMatch","COMMA_REGEX","transformRestAttrs","mixinDefaultOpts","eventualAttrs","D_REST_REGEX","transformRestArgs","addArgs","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","calculateAttrs","normalizedAttrs","attrsObject","firstTime","type","removeAttr","dynamic","opts","nextType","nextDynamic","nextValue","prevType","prevValue","prevDynamic","created","isDynamic","evaluated","evaluate","newValue","parentScope","constructMixinWatcher","setAfterUpdate","buildMixin","firstValue","push","normalizeArgs","argsChain","newArgs","constructPrivateScope","scope","globals","removeTempWatcher","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","evalMode","gettingVars","oldTempWatchers","createBlock","node","parentElem","parentBlock","parentTemplate","prevBlock","doc","namespaceURI","SVG_NS","localBlocks","ns","_blocks","Block","localMixins","_mixins","children","constructor","Constructor","dBlockMatch","dBlockName","dBlockArgs","NAMED_D_BLOCK_REGEX","blockInstance","error","element","currentAttrs","wasDRest","attrsChain","isDRest","localAttrs","restAttrs","mixinsToBuild","isParentBlock","insertAfterIt","insertAfter","addContent","insertInStartOfIt","into","content","emptyArray","contentDocument","documentElement","child","Args","locals","html","template","itemName","item","indexName","afterConstruct","isRendered","executeBuilders","afterRender","isInstanceOf","Class","Subclass","isPrototypeOf","removeWithParentSignal","wrapBlock","block","wrapper","returnValue","wrapMixin","constructStyleFromString","style","CSS_STYLE_SEPARATOR_REGEX","trim","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","values","options","init","isMultiple","addValue","concat","getListenerName","selected","insertTemplates","templates","iterateAndChangeChildren","nodes","trimmed","newTemplates","newTemplate","newVars","initApp","container","rootBlock","removeApp","DwayneRootBlock","defineProperties","Object","window","global","self","getProto","getPrototypeOf","setProto","setPrototypeOf","proto","__proto__","rootBlocks","rootMixins","Array","regexpSpecialCharacters","map","s","join","CSS_IMPORTANT_REGEX","emptyCollection","_this","includes","methodName","method","elems","elements","classes","forEach","list","classList","cls","attributes","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","cb","contains","el","isText","createTextNode","createComment","createElementNS","createElement","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","details","dispatchEvent","filter","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","props","first","prev","babelHelpers.get","apply","textContent","condition","_arguments","toggle","_arguments2","species","comment","afterUpdate","_value","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","isElementRemoved","blockHooks","mixinHooks","TAG_NAME_REGEX","ATTR_NAME_REGEX","afterElem","emptyObject","originalArgs","childrenBlocks","func","onChange","targetBlock","forDElements","forDItem","_this7","onChangeFlag","result","original","onEvalError","e","localWatchers","watcherBlock","newResult","removeContent","newContent","afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","warn","currentReturnValue","watchNameArgs","watchConstructorArgs","DBlock","constructDynamicNameBlock","htmlChildren","constructDynamicConstructorBlock","parentParentScope","parentParentTemplate","ownChildren","DBlockName","found","ParentScope","ParentTemplate","dBlocks","DItem","watchArgs","renderSet","_this2","itemsByUIDs","sortBy","UID","uid","newItemsByUIDs","newUIDsCounter","newUIDs","set","filterBy","isArr","iterate","sort","items","shift","constructElems","Infinity","wasDefault","val","if","compareFn","some","switchValue","caseValue","off","on","newClasses","DHide","Boolean","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL3V0aWxzL2lzLmpzIiwiLi4vc3JjL3V0aWxzL2VzY2FwZVJlZ2V4LmpzIiwiLi4vc3JjL3V0aWxzL25vb3AuanMiLCIuLi9zcmMvdXRpbHMvdG9DYXNlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRBdHRyLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRDU1NQcm9wLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGREYXRhQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkTmV4dC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUGFyZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRQcmV2LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9jcmVhdGVIaWRlU3R5bGVOb2RlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRBdHRyTlMuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRFdmVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaGlkZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vbWF0Y2hlcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9zaG93LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS90b0VsZW0uanMiLCIuLi9zcmMvZmluZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jbGVhblByb3BlcnR5LmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0TWl4aW5SZWdleC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL21peGluTWF0Y2guanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay90cmFuc2Zvcm1SZXN0QXR0cnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9leGVjdXRlTWl4aW5XYXRjaGVycy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUF0dHJzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svbm9ybWFsaXplQXJncy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NvbnN0cnVjdFByaXZhdGVTY29wZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlbW92ZVdhdGNoZXIuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jb25zdHJ1Y3RQdWJsaWNTY29wZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NyZWF0ZUJsb2NrLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svaXNJbnN0YW5jZU9mLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svd3JhcC5qcyIsIi4uL3NyYy9taXhpbnMvZC1zdHlsZS5qcyIsIi4uL3NyYy9taXhpbnMvZC12YWx1ZS5qcyIsIi4uL3NyYy9pbnNlcnRUZW1wbGF0ZXMuanMiLCIuLi9zcmMvaW5pdEFwcC5qcyIsIi4uL3NyYy9yZW1vdmVBcHAuanMiLCIuLi9zcmMvZ2xvYmFsLmpzIiwiLi4vc3JjL3V0aWxzL29iamVjdFN0YXRpY3MuanMiLCIuLi9zcmMvY29uc3RhbnRzLmpzIiwiLi4vc3JjL0VsZW0uanMiLCIuLi9zcmMvdXRpbHMvc2V0U3ltYm9sU3BlY2llcy5qcyIsIi4uL3NyYy9NaXhpbi5qcyIsIi4uL3NyYy9CbG9jay5qcyIsIi4uL3NyYy9ibG9ja3MvZC1ibG9jay5qcyIsIi4uL3NyYy9ibG9ja3MvZC1pdGVtLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWVhY2guanMiLCIuLi9zcmMvYmxvY2tzL2QtZWxlbWVudHMuanMiLCIuLi9zcmMvYmxvY2tzL2QtaWYuanMiLCIuLi9zcmMvYmxvY2tzL2Qtc3dpdGNoLmpzIiwiLi4vc3JjL21peGlucy9kLWJpbmQuanMiLCIuLi9zcmMvbWl4aW5zL2QtY2xhc3MuanMiLCIuLi9zcmMvbWl4aW5zL2QtZWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvZC1oaWRlLmpzIiwiLi4vc3JjL21peGlucy9kLW5vZGUuanMiLCIuLi9zcmMvbWl4aW5zL2Qtb24uanMiLCIuLi9zcmMvbWl4aW5zL2Qtc2hvdy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlZ2lzdGVyQnVpbHRpbnMuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi9hcnJheSc7XG5cbmNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuY29uc3QgeyBzbGljZSB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChzb3VyY2UsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSA9IHt9KSB7XG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGNhbGxiYWNrKGluaXRpYWxWYWx1ZSwgdmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VwdChvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG4gIGNvbnN0IHBhdGhzID0gYXJndW1lbnRzOjpzbGljZSgxKTtcblxuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAocGF0aHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0OjpoYXMoa2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG5cbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgbmV3T2JqZWN0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZU9iamVjdCB9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lRnJvemVuUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIGZyb3plbiBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIH0gZnJvbSAnLi9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBTeW1ib2wgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB7IHRvU3RyaW5nIH0gPSB7fTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdG9TdHJpbmdUYWdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGdldCB0b1N0cmluZ1RhZyBvZi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEN1dCBzdHJpbmcuXG4gKiBAZGVzY3JpcHRpb24gQ3V0IFwiVHlwZVwiIHN0cmluZyBmcm9tIFwiW29iamVjdCBUeXBlXVwiIHN0cmluZyB0aGF0IGdvdHRlbiBmcm9tIHt9LnRvU3RyaW5nLGNhbGwob2JqZWN0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0Ojp0b1N0cmluZygpLnNsaWNlKDgsIC0xKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKGtsYXNzLCB0YWcpIHtcbiAgaWYgKFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMoa2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogdGFnXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2NoZWNrVHlwZXNcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGlzPFR5cGU+IG1ldGhvZHMuXG4gKi9cblxuaW1wb3J0IHsgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3RvU3RyaW5nVGFnJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNBcnJheVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGFycmF5LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvciBub3QuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBpc0FycmF5KFtdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzQXJyYXkoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpOyAvLyBmYWxzZVxuICovXG5leHBvcnQgY29uc3QgeyBpc0FycmF5IH0gPSBBcnJheTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNGdW5jdGlvbigoKSA9PiB7fSk7ICAgICAgICAgICAgLy8gdHJ1ZVxuICogXG4gKiBjb25zdCBmdW5jID0gKCkgPT4ge307XG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZnVuYywge30pO1xuICogaXNGdW5jdGlvbihmdW5jKTsgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOaWxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc05pbChudWxsKTsgICAgICAvLyB0cnVlXG4gKiBpc05pbCh1bmRlZmluZWQpOyAvLyB0cnVlXG4gKiBpc05pbChmYWxzZSk7ICAgICAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc1N0cmluZygnMCcpOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1N0cmluZyhuZXcgU3RyaW5nKCcwJykpOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnU3RyaW5nJztcbn1cbiIsImNvbnN0IHJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gW1xuICAnLicsXG4gICcrJywgJyonLCAnPycsXG4gICcoJywgJyknLFxuICAnWycsICddJyxcbiAgJ3snLCAnfScsXG4gICc8JywgJz4nLFxuICAnXicsICckJyxcbiAgJyEnLFxuICAnPScsXG4gICc6JyxcbiAgJy0nLFxuICAnfCcsXG4gICcsJyxcbiAgJ1xcXFwnXG5dO1xuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxuICByZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xuICAgIC5tYXAoKHMpID0+IGBcXFxcJHsgcyB9YClcbiAgICAuam9pbignfCcpLFxuICAnZydcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRBdHRyKGF0dHJzLCBhdHRyKSB7XG4gIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xufVxuIiwiaW1wb3J0IHsgdG9DYW1lbENhc2UgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCA9IC86IC87XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDU1NQcm9wKGNzcywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdChDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gICAgY3NzW3RvQ2FtZWxDYXNlKHByb3BlcnR5WzBdKV0gPSBwcm9wZXJ0eVsxXTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZERhdGFBdHRyKGRhdGEsIHZhbHVlLCBrZXkpIHtcbiAgZGF0YVtrZXldID0gdmFsdWU7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkTmV4dChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ubmV4dFNpYmxpbmcpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZFBhcmVudChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucGFyZW50Tm9kZSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUHJldihhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucHJldmlvdXNTaWJsaW5nKTtcbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGlkZVN0eWxlTm9kZShoZWFkKSB7XG4gIGNvbnN0IHN0eWxlID0gaGVhZC5maW5kKGBzdHlsZSMkeyBISURFX0NMQVNTIH1gKTtcblxuICBpZiAoc3R5bGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGVhZFxuICAgIC5jcmVhdGUoJ3N0eWxlJylcbiAgICAucHJvcCgnaWQnLCBISURFX0NMQVNTKVxuICAgIC50ZXh0KGAuJHsgSElERV9DTEFTUyB9e2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50O31gKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuY29uc3QgWF9MSU5LX0FUVFJfRklORF9SRUdFWCA9IC9eeGxpbms6XFx3LztcbmNvbnN0IFhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVggPSAvXnhsaW5rOi87XG5jb25zdCBYTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgWF9MSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgTnVsbCA9IHtcbiAgbnM6IG51bGxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyTlMoYXR0ciwgZWxlbSkge1xuICBjb25zdCBpc1htbE5zID0gYXR0ciA9PT0gJ3htbG5zJztcblxuICBpZiAoaXNYbWxOcyB8fCBhdHRyID09PSAneG1sbnM6eGxpbmsnKSB7XG4gICAgaWYgKGVsZW0ubm9kZU5hbWUgIT09ICdTVkcnKSB7XG4gICAgICByZXR1cm4gTnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbnM6IFhNTF9OUyxcbiAgICAgIG5hbWU6IGlzWG1sTnNcbiAgICAgICAgPyAneG1sbnMnXG4gICAgICAgIDogJ3hsaW5rJ1xuICAgIH07XG4gIH1cblxuICBpZiAoWF9MSU5LX0FUVFJfRklORF9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgaWYgKCFuZXcgRWxlbShlbGVtKS5jbG9zZXN0KCdzdmcnKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBOdWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuczogWF9MSU5LX05TLFxuICAgICAgbmFtZTogYXR0ci5yZXBsYWNlKFhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVgsICcnKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gTnVsbDtcbn1cbiIsImltcG9ydCB7IHRvU3RyaW5nVGFnLCBpc0FycmF5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5jb25zdCBIVE1MX0NPTExFQ1RJT05fUkVHRVggPSAvXihIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdCkkLztcbmNvbnN0IERPQ1VNRU5UX1JFR0VYID0gL0RvY3VtZW50JC87XG5jb25zdCBFTEVNRU5UX1JFR0VYID0gL0VsZW1lbnQkLztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIERPQ1VNRU5UX1JFR0VYLnRlc3QodG9TdHJpbmdUYWcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50c0NvbGxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBIVE1MX0NPTExFQ1RJT05fUkVHRVgudGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpXG4gICAgfHwgaXNFbGVtKHZhbHVlKVxuICAgIHx8IGlzQXJyYXkodmFsdWUpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTm9kZSh2YWx1ZSkge1xuICBjb25zdCB0YWcgPSB0b1N0cmluZ1RhZyh2YWx1ZSk7XG5cbiAgcmV0dXJuIChcbiAgICBFTEVNRU5UX1JFR0VYLnRlc3QodGFnKVxuICAgIHx8IERPQ1VNRU5UX1JFR0VYLnRlc3QodGFnKVxuICAgIHx8IHRhZyA9PT0gJ1RleHQnXG4gICAgfHwgdGFnID09PSAnRG9jdW1lbnRGcmFnbWVudCdcbiAgICB8fCB0YWcgPT09ICdDb21tZW50J1xuICApO1xufVxuIiwiaW1wb3J0IHsgYXNzaWduLCB0b1N0cmluZ1RhZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGlzRG9jdW1lbnQgfSBmcm9tICcuL2lzJztcblxuY29uc3QgRVZFTlRfUkVHRVggPSAvRXZlbnQkLztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50LCBidWJibGVzLCBjYW5jZWxhYmxlLCByZWFsRGV0YWlscywgZWxlbSkge1xuICBsZXQgZmluYWxFdmVudCA9IGV2ZW50O1xuXG4gIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICB0cnkge1xuICAgICAgZmluYWxFdmVudCA9IG5ldyBFdmVudChmaW5hbEV2ZW50LCB7IGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG4gICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KGVsZW0pXG4gICAgICAgID8gZWxlbVxuICAgICAgICA6IGVsZW0ub3duZXJEb2N1bWVudDtcblxuICAgICAgZmluYWxFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG4gICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbEV2ZW50O1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlSGlkZVN0eWxlTm9kZSB9IGZyb20gJy4vY3JlYXRlSGlkZVN0eWxlTm9kZSc7XG5pbXBvcnQgeyBISURFX0NMQVNTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGUoZWxlbSkge1xuICBjcmVhdGVIaWRlU3R5bGVOb2RlKG5ldyBFbGVtKGVsZW0ub3duZXJEb2N1bWVudC5oZWFkKSk7XG4gIG5ldyBFbGVtKGVsZW0pLmFkZENsYXNzKEhJREVfQ0xBU1MpO1xufVxuIiwiaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4vaXMnO1xuXG5jb25zdCB7IGluZGV4T2YgfSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF0Y2hlc0Z1bmN0aW9uKGVsZW0pIHtcbiAgcmV0dXJuIChcbiAgICBlbGVtLm1hdGNoZXNcbiAgICB8fCBlbGVtLm1hdGNoZXNTZWxlY3RvclxuICAgIHx8IGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm1zTWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS5vTWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgbWF0Y2hlc1xuICApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gIGNvbnN0IGRvY3VtZW50ID0gaXNEb2N1bWVudCh0aGlzKVxuICAgID8gdGhpc1xuICAgIDogdGhpcy5vd25lckRvY3VtZW50O1xuXG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTo6aW5kZXhPZih0aGlzKSAhPT0gLTE7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsZW0pIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hvdyhlbGVtKSB7XG4gIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUNsYXNzKEhJREVfQ0xBU1MpO1xufVxuIiwiaW1wb3J0IHsgaXNFbGVtIH0gZnJvbSAnLi9pcyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0VsZW0oZWxlbSkge1xuICByZXR1cm4gaXNFbGVtKGVsZW0pXG4gICAgPyBlbGVtXG4gICAgOiBuZXcgRWxlbShlbGVtKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGZpbmRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gW2Jhc2UgPSBkb2N1bWVudF0gLSBCYXNlIHRvIGZpbmQgaW4uXG4gKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAqIFtEb2N1bWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBiYXNlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBFbGVtKGJhc2UucXVlcnlTZWxlY3RvckFsbChTdHJpbmcoc2VsZWN0b3IpKSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsIGtleXMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpIHtcbiAgaXRlcmF0ZUFycmF5KGtleXMoYXJnc09iamVjdCksIChhcmcpID0+IHtcbiAgICBpZiAoIShhcmcgaW4gYXJncykpIHtcbiAgICAgIGFyZ3NPYmplY3RbYXJnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhcmcpID0+IHtcbiAgICBhcmdzT2JqZWN0W2FyZ10gPSB2YWx1ZTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY2xlYW5Qcm9wZXJ0eSh2YWx1ZSwgYXJnLCBvYmplY3QpIHtcbiAgZGVsZXRlIG9iamVjdFthcmddO1xufVxuIiwiaW1wb3J0IHsgZXNjYXBlUmVnZXggfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RNaXhpblJlZ2V4KG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4keyBlc2NhcGVSZWdleChuYW1lKSB9KD86XFxcXCgoW15cXFxcKV0qKVxcXFwpKT8oPzojKFtcXFxcc1xcXFxTXSopKT8kYCk7XG59XG4iLCJjb25zdCBDT01NQV9SRUdFWCA9IC8sLztcblxuZXhwb3J0IGZ1bmN0aW9uIG1peGluTWF0Y2gobWl4aW5zLCBhdHRyKSB7XG4gIGxldCBtYXRjaDtcblxuICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gIGZvciAoY29uc3QgbmFtZSBpbiBtaXhpbnMpIHtcbiAgICBjb25zdCBNaXhpbiA9IG1peGluc1tuYW1lXTtcbiAgICBjb25zdCBsb2NhbE1hdGNoID0gYXR0ci5tYXRjaChNaXhpbi5fbWF0Y2gpO1xuXG4gICAgaWYgKGxvY2FsTWF0Y2gpIHtcbiAgICAgIGNvbnN0IGFyZ3NNYXRjaCA9IGxvY2FsTWF0Y2hbMV07XG4gICAgICBsZXQgYXJncztcblxuICAgICAgaWYgKGFyZ3NNYXRjaCA9PT0gJycpIHtcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChhcmdzTWF0Y2gpIHtcbiAgICAgICAgYXJncyA9IGFyZ3NNYXRjaC5zcGxpdChDT01NQV9SRUdFWCk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0ge1xuICAgICAgICBhcmdzLFxuICAgICAgICBjb21tZW50OiBsb2NhbE1hdGNoWzJdLFxuICAgICAgICBNaXhpbixcbiAgICAgICAgbmFtZVxuICAgICAgfTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuIiwiaW1wb3J0IHsgY29sbGVjdEZyb21PYmplY3QsIGFzc2lnbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IERfUkVTVF9SRUdFWCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBtaXhpbk1hdGNoIH0gZnJvbSAnLi9taXhpbk1hdGNoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3RBdHRycyhhdHRycywgbWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzKSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChhdHRycywgKGV2ZW50dWFsQXR0cnMsIHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgaWYgKERfUkVTVF9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgICByZXR1cm4gYXNzaWduKGV2ZW50dWFsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyh2YWx1ZSwgbWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBtaXhpbk1hdGNoKG1peGlucywgYXR0cik7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGV2ZW50dWFsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgIHR5cGU6ICdtaXhpbicsXG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIG9wdHM6IHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAuLi5taXhpbkRlZmF1bHRPcHRzXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnR1YWxBdHRyc1thdHRyXSA9IHtcbiAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SZXN0QXJncyhhcmdzKSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChhcmdzLCBhZGRBcmdzKTtcbn1cblxuZnVuY3Rpb24gYWRkQXJncyhhcmdzLCB2YWx1ZSwgYXJnKSB7XG4gIGlmIChEX1JFU1RfUkVHRVgudGVzdChhcmcpKSB7XG4gICAgYXNzaWduKGFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1thcmddID0gdmFsdWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSkge1xuICBjb25zdCBvbGRWYWx1ZSA9IG1peGluLiQkLnZhbHVlO1xuXG4gIG1peGluLiQkLnZhbHVlID0gdmFsdWU7XG5cbiAgaXRlcmF0ZUFycmF5KG1peGluLiQkLndhdGNoZXJzLCAod2F0Y2hlcikgPT4ge1xuICAgIHdhdGNoZXIodmFsdWUsIG9sZFZhbHVlKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBleGVjdXRlTWl4aW5XYXRjaGVycyB9IGZyb20gJy4vZXhlY3V0ZU1peGluV2F0Y2hlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXR0cnMobm9ybWFsaXplZEF0dHJzLCBhdHRycywgYXR0cnNPYmplY3QsIGVsZW0sIGZpcnN0VGltZSkge1xuICBpdGVyYXRlT2JqZWN0KGF0dHJzT2JqZWN0LCAoeyB0eXBlLCB2YWx1ZSB9LCBhdHRyKSA9PiB7XG4gICAgaWYgKCFhdHRyc1thdHRyXSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS4kJC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGF0dHJzT2JqZWN0W2F0dHJdO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbWl4aW5zID0gW107XG5cbiAgaXRlcmF0ZU9iamVjdChub3JtYWxpemVkQXR0cnMsICh7IHR5cGUsIGR5bmFtaWMsIHZhbHVlLCBvcHRzIH0sIGF0dHIpID0+IHtcbiAgICBsZXQgbmV4dFR5cGU7XG4gICAgbGV0IG5leHREeW5hbWljO1xuICAgIGxldCBuZXh0VmFsdWU7XG5cbiAgICBpZiAoYXR0cnNPYmplY3RbYXR0cl0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZTogcHJldlR5cGUsXG4gICAgICAgIHZhbHVlOiBwcmV2VmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IHByZXZEeW5hbWljXG4gICAgICB9ID0gYXR0cnNPYmplY3RbYXR0cl07XG5cbiAgICAgIGlmICh0eXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgaWYgKHByZXZUeXBlID09PSAnbWl4aW4nKSB7XG4gICAgICAgICAgcHJldlZhbHVlLiQkLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbWl4aW4gPSBwcmV2VmFsdWU7XG4gICAgICAgIGxldCBjcmVhdGVkO1xuXG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xuXG4gICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgb3B0cy5keW5hbWljID0gZHluYW1pYztcbiAgICAgICAgICBtaXhpbiA9IG5ldyBvcHRzLk1peGluKG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1peGluLiQkLmlzRHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW1peGluLiQkLmV2YWx1YXRlZCAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtaXhpbi4kJC5wYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29uc3RydWN0TWl4aW5XYXRjaGVyKG1peGluLCBhdHRyLCBhdHRycyksXG4gICAgICAgICAgICBtaXhpblxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBtaXhpbi4kJC5ldmFsdWF0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2RHluYW1pYyAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG1peGluLiQkLnBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0VmFsdWUgPSBtaXhpbjtcblxuICAgICAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgICAgIG1peGluLiQkLnNldEFmdGVyVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFR5cGUgPSB0eXBlO1xuICAgICAgbmV4dER5bmFtaWMgPSBkeW5hbWljO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGVsZW0uYXR0cihhdHRyLCB2YWx1ZSk7XG5cbiAgICAgICAgbmV4dFZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWlsZE1peGluID0gKCkgPT4ge1xuICAgICAgICAgIG9wdHMuZHluYW1pYyA9IGR5bmFtaWM7XG5cbiAgICAgICAgICBjb25zdCBtaXhpbiA9IG5ldyBvcHRzLk1peGluKG9wdHMpO1xuXG4gICAgICAgICAgaWYgKCFkeW5hbWljICYmIG9wdHMuTWl4aW4uZXZhbHVhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gb3B0cztcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdE1peGluV2F0Y2hlcihtaXhpbiwgYXR0ciwgYXR0cnMpLFxuICAgICAgICAgICAgICBtaXhpblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbWl4aW4uJCQuZXZhbHVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1peGluLiQkLnZhbHVlID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0VmFsdWUgPSBtaXhpbjtcbiAgICAgICAgICBtaXhpbi4kJC5zZXRBZnRlclVwZGF0ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGR5bmFtaWMsXG4gICAgICAgICAgICAgIHZhbHVlOiBtaXhpblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgIG1peGlucy5wdXNoKGJ1aWxkTWl4aW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkTWl4aW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0VHlwZSA9IHR5cGU7XG4gICAgICBuZXh0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfVxuXG4gICAgYXR0cnNPYmplY3RbYXR0cl0gPSB7XG4gICAgICB0eXBlOiBuZXh0VHlwZSxcbiAgICAgIGR5bmFtaWM6IG5leHREeW5hbWljLFxuICAgICAgdmFsdWU6IG5leHRWYWx1ZVxuICAgIH07XG4gIH0pO1xuXG4gIGlmIChmaXJzdFRpbWUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KG1peGlucywgKGJ1aWxkTWl4aW4pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgb3B0c1xuICAgICAgICB9ID0gYnVpbGRNaXhpbigpO1xuXG4gICAgICAgIGF0dHJzT2JqZWN0W2F0dHJdID0gb3B0cztcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0TWl4aW5XYXRjaGVyKG1peGluLCBhdHRyLCBhdHRycykge1xuICByZXR1cm4gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGR5bmFtaWNcbiAgICB9ID0gYXR0cnNbYXR0cl07XG5cbiAgICBpZiAodHlwZSA9PT0gJ21peGluJyAmJiAhZHluYW1pYykge1xuICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVBcmdzKGFyZ3NDaGFpbikge1xuICBjb25zdCBuZXdBcmdzID0ge307XG5cbiAgaXRlcmF0ZUFycmF5KGFyZ3NDaGFpbiwgKGFyZ3MpID0+IHtcbiAgICBpdGVyYXRlT2JqZWN0KGFyZ3MsICh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgICBuZXdBcmdzW2FyZ10gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ld0FyZ3M7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGUsIGNvbGxlY3RGcm9tT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0UHJpdmF0ZVNjb3BlKG9iamVjdCwgdHlwZSwgcGFyZW50U2NvcGUpIHtcbiAgbGV0IHNjb3BlID0ge307XG5cbiAgaWYgKHR5cGUgPT09ICdnbG9iYWxzJykge1xuICAgIHNjb3BlID0gY3JlYXRlKFxuICAgICAgcGFyZW50U2NvcGVcbiAgICAgICAgPyBwYXJlbnRTY29wZS4kJC5nbG9iYWxzXG4gICAgICAgIDogbnVsbFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29sbGVjdEZyb21PYmplY3Qob2JqZWN0LCAoc2NvcGUsIHZhbHVlLCBrZXkpID0+IHtcbiAgICBzY29wZVtrZXldID0ge1xuICAgICAgdmFsdWUsXG4gICAgICB3YXRjaGVyczogW11cbiAgICB9O1xuICB9LCBzY29wZSk7XG59XG4iLCJpbXBvcnQgeyByZW1vdmVBcnJheUVsZW0sIGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRlbXBXYXRjaGVyKHdhdGNoZXIpIHtcbiAgd2F0Y2hlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSkge1xuICBpdGVyYXRlQXJyYXkod2F0Y2hlcnNUb1JlbW92ZSwgcmVtb3ZlV2F0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVdhdGNoZXIoeyB3YXRjaGVyLCB3YXRjaGVycyB9KSB7XG4gIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVycywgd2F0Y2hlcik7XG59XG4iLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBtYXBPYmplY3QsIGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGdldHRpbmdWYXJzLCBldmFsTW9kZSB9IGZyb20gJy4uLy4uL0Jsb2NrJztcbmltcG9ydCB7IHJlbW92ZVRlbXBXYXRjaGVyIH0gZnJvbSAnLi9yZW1vdmVXYXRjaGVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFB1YmxpY1Njb3BlKHNjb3BlLCBzY29wZVZhbHVlcywgcHJpdmF0ZVNjb3BlKSB7XG4gIGRlZmluZVByb3BlcnRpZXMoc2NvcGUsIG1hcE9iamVjdChzY29wZVZhbHVlcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IHByaXZhdGVTY29wZVtrZXldO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAoZXZhbE1vZGUpIHtcbiAgICAgICAgICBpZiAoZ2V0dGluZ1ZhcnMuaW5kZXhPZihzY29wZS53YXRjaGVycykgPT09IC0xKSB7XG4gICAgICAgICAgICBnZXR0aW5nVmFycy5wdXNoKHNjb3BlLndhdGNoZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gc2NvcGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRUZW1wV2F0Y2hlcnMgPSBzY29wZS53YXRjaGVycy5zbGljZSgpO1xuXG4gICAgICAgIHNjb3BlLndhdGNoZXJzID0gW107XG4gICAgICAgIHNjb3BlLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaXRlcmF0ZUFycmF5KG9sZFRlbXBXYXRjaGVycywgcmVtb3ZlVGVtcFdhdGNoZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKTtcbn1cbiIsImltcG9ydCB7XG4gIGV4Y2VwdCwgY3JlYXRlLCBhc3NpZ24sXG4gIGl0ZXJhdGVPYmplY3QsIGl0ZXJhdGVBcnJheSxcbiAgaXNOaWxcbn0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuaW1wb3J0IHtcbiAgU1ZHX05TLCBEX1JFU1RfUkVHRVhcbn0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNsZWFuUHJvcGVydHkgfSBmcm9tICcuL2NsZWFuUHJvcGVydHknO1xuaW1wb3J0IHsgdHJhbnNmb3JtUmVzdEF0dHJzIH0gZnJvbSAnLi90cmFuc2Zvcm1SZXN0QXR0cnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQXR0cnMgfSBmcm9tICcuL2NhbGN1bGF0ZUF0dHJzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUFyZ3MgfSBmcm9tICcuL25vcm1hbGl6ZUFyZ3MnO1xuaW1wb3J0IHsgbWl4aW5NYXRjaCB9IGZyb20gJy4vbWl4aW5NYXRjaCc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RQcml2YXRlU2NvcGUgfSBmcm9tICcuL2NvbnN0cnVjdFByaXZhdGVTY29wZSc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RQdWJsaWNTY29wZSB9IGZyb20gJy4vY29uc3RydWN0UHVibGljU2NvcGUnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5cbmNvbnN0IE5BTUVEX0RfQkxPQ0tfUkVHRVggPSAvXmQtYmxvY2s6KFtcXHNcXFNdKykkLztcbmNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHsgbm9kZSwgcGFyZW50LCBwYXJlbnRFbGVtLCBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUsIHBhcmVudFRlbXBsYXRlLCBwcmV2QmxvY2sgfSkge1xuICBjb25zdCBkb2MgPSBpc0RvY3VtZW50KHBhcmVudEVsZW1bMF0pXG4gICAgPyBwYXJlbnRFbGVtXG4gICAgOiBuZXcgRWxlbShwYXJlbnRFbGVtWzBdLm93bmVyRG9jdW1lbnQpO1xuICBjb25zdCBlbGVtID0gcGFyZW50RWxlbVswXS5uYW1lc3BhY2VVUkkgPT09IFNWR19OU1xuICAgID8gZG9jLmNyZWF0ZSgnc3ZnJylcbiAgICA6IGRvYztcbiAgY29uc3QgbG9jYWxCbG9ja3MgPSBwYXJlbnRUZW1wbGF0ZSA/IHBhcmVudFRlbXBsYXRlLiQkLm5zLl9ibG9ja3MgOiBCbG9jay5fYmxvY2tzO1xuICBjb25zdCBsb2NhbE1peGlucyA9IHBhcmVudFRlbXBsYXRlID8gcGFyZW50VGVtcGxhdGUuJCQubnMuX21peGlucyA6IEJsb2NrLl9taXhpbnM7XG4gIGNvbnN0IGFyZ3MgPSBub2RlLmF0dHJzIHx8IHt9O1xuICBjb25zdCBuYW1lID0gbm9kZS5uYW1lIHx8ICdVbmtub3duQmxvY2snO1xuICBsZXQgeyBjaGlsZHJlbiB9ID0gbm9kZTtcbiAgbGV0IGNvbnN0cnVjdG9yID0gbm9kZS5Db25zdHJ1Y3RvciB8fCAobm9kZS5uYW1lICYmIGxvY2FsQmxvY2tzW25vZGUubmFtZV0pO1xuICBsZXQgZEJsb2NrTWF0Y2g7XG4gIGxldCBkQmxvY2tOYW1lO1xuICBsZXQgZEJsb2NrQXJncztcblxuICBpZiAobmFtZSA9PT0gJ2QtYmxvY2snICYmIGFyZ3MubmFtZSkge1xuICAgIGRCbG9ja0FyZ3MgPSBleGNlcHQoYXJncywgJ25hbWUnKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSAnZC1ibG9jaycgJiYgYXJncy5Db25zdHJ1Y3Rvcikge1xuICAgIGRCbG9ja0FyZ3MgPSBleGNlcHQoYXJncywgJ0NvbnN0cnVjdG9yJyk7XG4gIH0gZWxzZSBpZiAoKGRCbG9ja01hdGNoID0gbmFtZS5tYXRjaChOQU1FRF9EX0JMT0NLX1JFR0VYKSkgfHwgbmFtZSA9PT0gJ2QtYmxvY2snKSB7XG4gICAgY29uc3RydWN0b3IgPSBCbG9jay5fYmxvY2tzWydkLWJsb2NrJ107XG4gICAgZEJsb2NrTmFtZSA9IGRCbG9ja01hdGNoID8gZEJsb2NrTWF0Y2hbMV0gOiBudWxsO1xuICB9XG5cbiAgbGV0IGJsb2NrSW5zdGFuY2U7XG5cbiAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJsb2NrSW5zdGFuY2UgPSBuZXcgY29uc3RydWN0b3Ioe1xuICAgICAgICBuYW1lLFxuICAgICAgICBhcmdzLFxuICAgICAgICBkQmxvY2tOYW1lLFxuICAgICAgICBkQmxvY2tBcmdzLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBwcmV2QmxvY2tcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gbmV3ICR7IG5hbWUgfTpgLCBlcnIpO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW0uY3JlYXRlKG5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgYXR0cnMgPSBjcmVhdGUobnVsbCk7XG4gICAgbGV0IHdhc0RSZXN0O1xuICAgIGNvbnN0IGF0dHJzQ2hhaW4gPSBbYXR0cnNdO1xuICAgIGNvbnN0IG1peGluRGVmYXVsdE9wdHMgPSB7XG4gICAgICBlbGVtOiBlbGVtZW50LFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfTtcblxuICAgIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBpc0RSZXN0ID0gRF9SRVNUX1JFR0VYLnRlc3QoYXR0cik7XG4gICAgICBjb25zdCBsb2NhbEF0dHJzID0gaXNEUmVzdCB8fCB3YXNEUmVzdFxuICAgICAgICA/IGNyZWF0ZShhdHRycylcbiAgICAgICAgOiBhdHRycztcblxuICAgICAgaWYgKGF0dHJzICE9PSBsb2NhbEF0dHJzKSB7XG4gICAgICAgIGF0dHJzQ2hhaW4ucHVzaChsb2NhbEF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgYXR0cnMgPSBsb2NhbEF0dHJzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXR0cnMgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZU9iamVjdChsb2NhbEF0dHJzLCBjbGVhblByb3BlcnR5KTtcbiAgICAgICAgICBhc3NpZ24obG9jYWxBdHRycywgdHJhbnNmb3JtUmVzdEF0dHJzKFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsb2NhbE1peGlucyxcbiAgICAgICAgICAgIG1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgICApKTtcbiAgICAgICAgICBjYWxjdWxhdGVBdHRycyhub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLCBhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH0sIHBhcmVudEJsb2NrKTtcblxuICAgICAgICB3YXNEUmVzdCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbihsb2NhbEF0dHJzLCB0cmFuc2Zvcm1SZXN0QXR0cnMoXG4gICAgICAgICAgcmVzdEF0dHJzLCBsb2NhbE1peGlucywgbWl4aW5EZWZhdWx0T3B0c1xuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0Y2ggPSBtaXhpbk1hdGNoKGxvY2FsTWl4aW5zLCBhdHRyKTtcblxuICAgICAgd2FzRFJlc3QgPSBmYWxzZTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgICAgdHlwZTogJ21peGluJyxcbiAgICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIC4uLm1hdGNoLFxuICAgICAgICAgICAgLi4ubWl4aW5EZWZhdWx0T3B0c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgICAgdmFsdWU6IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F0dHInLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKG5vcm1hbGl6ZUFyZ3MoYXR0cnNDaGFpbiksIGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcGFyZW50QmxvY2suJCQubWl4aW5zVG9CdWlsZC5wdXNoKGNhbGN1bGF0ZUF0dHJzKG5vcm1hbGl6ZUFyZ3MoYXR0cnNDaGFpbiksIGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIHRydWUpKTtcblxuICAgIGlmIChuYW1lID09PSAnI2NvbW1lbnQnKSB7XG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnI3RleHQnKSB7XG4gICAgICBsZXQgdGV4dCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnRleHQoYCR7IHZhbHVlIH1gKTtcbiAgICAgIH0sIHBhcmVudEJsb2NrKTtcblxuICAgICAgaWYgKGlzTmlsKHRleHQpKSB7XG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC50ZXh0KGAkeyB0ZXh0IH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1BhcmVudEJsb2NrID0gcGFyZW50IGluc3RhbmNlb2YgQmxvY2s7XG5cbiAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgZWxlbWVudC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChlbGVtZW50LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZXQgcHJldkJsb2NrO1xuICAgICAgbGV0IHBhcmVudEVsZW0gPSBlbGVtZW50O1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBwYXJlbnRFbGVtID0gbmV3IEVsZW0oZWxlbWVudFswXS5jb250ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgaWYgKCdzcmMnIGluIGF0dHJzKSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSBlbXB0eUFycmF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbWVudFswXS5jb250ZW50RG9jdW1lbnQ7XG5cbiAgICAgICAgICBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcGFyZW50RWxlbSA9IG5ldyBFbGVtKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyYXRlQXJyYXkoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBjb25zdCB7XG4gICAgJCQsXG4gICAgYXJnczogQXJncyxcbiAgICBnbG9iYWxzLFxuICAgIC4uLmxvY2Fsc1xuICB9ID0gYmxvY2tJbnN0YW5jZTtcblxuICBjb25zdCBodG1sID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnZhbHVlIHx8IFtdXG4gICAgOiBjb25zdHJ1Y3Rvci50ZW1wbGF0ZS52YWx1ZTtcblxuICAkJC5hcmdzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKEFyZ3MpO1xuICAkJC5sb2NhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUobG9jYWxzKTtcbiAgJCQuZ2xvYmFscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShnbG9iYWxzLCAnZ2xvYmFscycsIHBhcmVudFNjb3BlKTtcblxuICBpZiAobmFtZSA9PT0gJyNkLWl0ZW0nKSB7XG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcbiAgICAgIFtub2RlLmluZGV4TmFtZV06IG5vZGUuaW5kZXhcbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gcGFyZW50U2NvcGUuJCQubmFtZSA9PT0gJyNkLWl0ZW0nXG4gICAgICA/IHBhcmVudFNjb3BlLiQkLnNjb3BlXG4gICAgICA6IHBhcmVudFNjb3BlO1xuXG4gICAgJCQubnMgPSBwYXJlbnRTY29wZS4kJC5ucztcbiAgICAkJC5wcml2YXRlU2NvcGUgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoc2NvcGVWYWx1ZXMpO1xuICAgIGNvbnN0cnVjdFB1YmxpY1Njb3BlKCQkLnNjb3BlID0gY3JlYXRlKHNjb3BlKSwgc2NvcGVWYWx1ZXMsICQkLnByaXZhdGVTY29wZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShBcmdzLCBBcmdzLCAkJC5hcmdzKTtcbiAgY29uc3RydWN0UHVibGljU2NvcGUoZ2xvYmFscywgZ2xvYmFscywgJCQuZ2xvYmFscyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGJsb2NrSW5zdGFuY2UsIGxvY2FscywgJCQubG9jYWxzKTtcblxuICB0cnkge1xuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJDb25zdHJ1Y3QoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyQ29uc3RydWN0OmAsIGVycik7XG4gIH1cblxuICBwcmV2QmxvY2sgPSB1bmRlZmluZWQ7XG4gIHBhcmVudFNjb3BlID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnBhcmVudFNjb3BlXG4gICAgOiBibG9ja0luc3RhbmNlO1xuICBwYXJlbnRUZW1wbGF0ZSA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy5wYXJlbnRUZW1wbGF0ZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcblxuICBpdGVyYXRlQXJyYXkoaHRtbCwgKGNoaWxkKSA9PiB7XG4gICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXJlbnQ6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50QmxvY2s6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgcHJldkJsb2NrXG4gICAgfSk7XG4gIH0pO1xuXG4gIGJsb2NrSW5zdGFuY2UuJCQuaXNSZW5kZXJlZCA9IHRydWU7XG5cbiAgaXRlcmF0ZUFycmF5KGJsb2NrSW5zdGFuY2UuJCQubWl4aW5zVG9CdWlsZCwgKGV4ZWN1dGVCdWlsZGVycykgPT4ge1xuICAgIGV4ZWN1dGVCdWlsZGVycygpO1xuICB9KTtcbiAgYmxvY2tJbnN0YW5jZS4kJC5taXhpbnNUb0J1aWxkID0gW107XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyUmVuZGVyKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclJlbmRlcjpgLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIGJsb2NrSW5zdGFuY2U7XG59XG4iLCJjb25zdCB7IGlzUHJvdG90eXBlT2YgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKENsYXNzLCBTdWJjbGFzcykge1xuICByZXR1cm4gQ2xhc3M6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MpICYmIENsYXNzLnByb3RvdHlwZTo6aXNQcm90b3R5cGVPZihTdWJjbGFzcy5wcm90b3R5cGUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwoY2hpbGQpIHtcbiAgY2hpbGQuJCQucmVtb3ZlKHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgaXNJbnN0YW5jZU9mIH0gZnJvbSAnLi9pc0luc3RhbmNlT2YnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uLy4uL01peGluJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBCbG9jayhibG9jaywgd3JhcHBlcikge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHdyYXBwZXIoYmxvY2spO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIHJldHVyblZhbHVlKVxuICAgID8gcmV0dXJuVmFsdWVcbiAgICA6IGJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1peGluKG1peGluLCB3cmFwcGVyKSB7XG4gIGNvbnN0IHJldHVyblZhbHVlID0gd3JhcHBlcihtaXhpbik7XG5cbiAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgcmV0dXJuVmFsdWUpXG4gICAgPyByZXR1cm5WYWx1ZVxuICAgIDogbWl4aW47XG59XG4iLCJpbXBvcnQge1xuICBpc1N0cmluZywgaXRlcmF0ZU9iamVjdCwga2V5cyxcbiAgY29sbGVjdEZyb21PYmplY3QsIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVggPSAvXFxzKjtcXHMqLztcbmNvbnN0IENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVggPSAvXFxzKjpcXHMqLztcblxucm9vdE1peGluc1snZC1zdHlsZSddID0gY2xhc3MgRFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xuICBjc3MgPSB7fTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNzc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21PYmplY3QoYXJncywgKGNzcywgcHJvcCkgPT4ge1xuICAgICAgICBjc3NbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21BcnJheShcbiAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgIC5tYXAoY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nKSxcbiAgICAgICAgYWRkQ1NTUHJvcFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNzcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIW5ld1ZhbHVlW3Byb3BdKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ1NTKHByb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVsZW0uY3NzKG5ld1ZhbHVlKTtcblxuICAgIHRoaXMuY3NzID0gbmV3VmFsdWU7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBjc3NcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBlbGVtLnJlbW92ZUNTUy5hcHBseShlbGVtLCBrZXlzKGNzcykpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gYWRkQ1NTUHJvcChjc3MsIGl0ZW0pIHtcbiAgY29uc3QgW3Byb3AsIHZhbHVlXSA9IGl0ZW07XG5cbiAgY3NzW3Byb3BdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyhzdHlsZSkge1xuICBjb25zdCBzcGxpdCA9IHN0eWxlLnNwbGl0KENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gIHJldHVybiBbXG4gICAgc3BsaXRbMF0udHJpbSgpLFxuICAgIHNwbGl0WzFdLnRyaW0oKVxuICBdO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNGdW5jdGlvbiwgaXNOaWwsXG4gIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLXZhbHVlJ10gPSBjbGFzcyBEVmFsdWUgZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuYW1lID0gZWxlbS5uYW1lKCk7XG4gICAgY29uc3QgdHlwZSA9IGVsZW0ucHJvcCgndHlwZScpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuICAgIGxldCBpbml0aWFsU2NvcGVWYWx1ZSA9IG51bGw7XG5cbiAgICB0aGlzLnByb3AgPSBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gZWxlbS5maW5kKCdvcHRpb24nKTtcbiAgICB0aGlzLnNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgdGhpcy5zY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdGhpcy52YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHRoaXMudmFsdWUpKSB7XG4gICAgICBpbml0aWFsU2NvcGVWYWx1ZSA9IHRoaXMuc2NvcGUuJCQuZXZhbHVhdGUoKHNjb3BlKSA9PiBzY29wZVt0aGlzLnZhbHVlXSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0UHJvcChuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxFbGVtVmFsdWUgPSB0aGlzLmdldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsID0gaXNOaWwoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgIGNvbnN0IGlzQ2hlY2tib3ggPSB0eXBlID09PSAnY2hlY2tib3gnO1xuICAgIGNvbnN0IGNoYW5nZVNjb3BlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLmdldFByb3AodGhpcy5jdXJyZW50VmFsdWUsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIHx8IGlzQ2hlY2tib3gpIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbEVsZW1WYWx1ZTtcbiAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcblxuICAgICAgaWYgKCFpc0luaXRpYWxTY29wZVZhbHVlTnVsbCAmJiBpc0NoZWNrYm94KSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbFNjb3BlVmFsdWU7XG4gICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMub2ZmRWxlbUxpc3RlbmVyID0gZWxlbS5vbihnZXRMaXN0ZW5lck5hbWUobmFtZSwgdHlwZSksIGNoYW5nZVNjb3BlKTtcbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lciA9IGVsZW0uY2xvc2VzdCgnZm9ybScpLm9uKCdyZXNldCcsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoY2hhbmdlU2NvcGUsIDApO1xuICAgIH0pO1xuICB9XG5cbiAgY2hhbmdlU2NvcGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NvcGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGN1cnJlbnRWYWx1ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgc2V0UHJvcCh2YWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBuYW1lLFxuICAgICAgcHJvcCxcbiAgICAgIHR5cGUsXG4gICAgICBub2RlLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3AgPT09ICd0ZXh0Jykge1xuICAgICAgZWxlbS50ZXh0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKSB7XG4gICAgICBvcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmRleE9mKG9wdGlvbi52YWx1ZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0ucHJvcChwcm9wLCBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIG5vZGUudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcm9wKHZhbHVlcywgaW5pdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBuYW1lLFxuICAgICAgcHJvcCxcbiAgICAgIHR5cGUsXG4gICAgICBub2RlLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIHByb3AgPT09ICd0ZXh0J1xuICAgICAgPyBlbGVtLnRleHQoKVxuICAgICAgOiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgZWxlbS5wcm9wKHByb3ApLCB0eXBlLCBub2RlLnZhbHVlLCB2YWx1ZXMsIG9wdGlvbnMsIGluaXQsIHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKTtcbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHRoaXMub2ZmRm9ybUxpc3RlbmVyKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICByZXR1cm4gZWxlbS5oYXNBdHRyKCdtdWx0aXBsZScpXG4gICAgICAgID8gJ211bHRpcGxlLXNlbGVjdCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICByZXR1cm4gJ2ZpbGVzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICA/ICdjaGVja2VkJ1xuICAgICAgICA6ICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignY29udGVudEVkaXRhYmxlJylcbiAgICAgICAgPyAndGV4dCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUpIHtcbiAgaWYgKG5hbWUgIT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBpc1JhZGlvID0gdHlwZSA9PT0gJ3JhZGlvJztcblxuICBpZiAoIWlzUmFkaW8gJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpc1JhZGlvXG4gICAgPyB2YWx1ZSA9PT0gaW5wdXRWYWx1ZVxuICAgIDogdmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yR2V0dGluZyhuYW1lLCB2YWx1ZSwgdHlwZSwgaW5wdXRWYWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBpc011bHRpcGxlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KG9wdGlvbnMsIGFkZFZhbHVlLCBbXSk7XG4gICAgfVxuXG4gICAgY2FzZSAnaW5wdXQnOiB7XG4gICAgICBpZiAodHlwZSAhPT0gJ3JhZGlvJyAmJiB0eXBlICE9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgPyBpbnB1dFZhbHVlXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW107XG5cbiAgICAgIGlmICghdmFsdWUgJiYgaW5pdCkge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpID09PSAtMVxuICAgICAgICAgID8gdmFsdWVzLmNvbmNhdChpbnB1dFZhbHVlKVxuICAgICAgICAgIDogdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAuLi52YWx1ZXMuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuICdjaGFuZ2UnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZSA9PT0gJ3JhZGlvJ1xuICAgICAgICB8fCB0eXBlID09PSAnY2hlY2tib3gnXG4gICAgICAgIHx8IHR5cGUgPT09ICdjb2xvcidcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2ZpbGUnXG4gICAgICApXG4gICAgICAgID8gJ2NoYW5nZSdcbiAgICAgICAgOiAnY2hhbmdlIGlucHV0JztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gJ2lucHV0JztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUodmFsdWVzLCB7IHNlbGVjdGVkLCB2YWx1ZSB9KSB7XG4gIGlmIChzZWxlY3RlZCAmJiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICB0b09iamVjdEtleXMsXG4gIGFzc2lnbiwga2V5cywgY3JlYXRlXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0VGVtcGxhdGVzKHRlbXBsYXRlLCB0ZW1wbGF0ZXMpIHtcbiAgY29uc3Qge1xuICAgIHZhcnMsXG4gICAgdmFsdWVcbiAgfSA9IHRlbXBsYXRlO1xuICBjb25zdCBuZXdUZW1wbGF0ZXMgPSBjcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5ld1ZhcnMgPSB0b09iamVjdEtleXModmFycyk7XG5cbiAgYXNzaWduKG5ld1RlbXBsYXRlcywgdGVtcGxhdGVzKTtcbiAgaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuKHZhbHVlKTtcblxuICBmdW5jdGlvbiBpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4obm9kZXMgPSBbXSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gbm9kZXNbaV07XG5cbiAgICAgIGlmIChuYW1lID09PSAnI2NvbW1lbnQnKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5ld1RlbXBsYXRlc1t0cmltbWVkXSkge1xuICAgICAgICAgIGNvbnN0IG5ld1RlbXBsYXRlID0gbmV3VGVtcGxhdGVzW3RyaW1tZWRdLnZhbHVlO1xuXG4gICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm5ld1RlbXBsYXRlKTtcbiAgICAgICAgICBhc3NpZ24obmV3VmFycywgdG9PYmplY3RLZXlzKG5ld1RlbXBsYXRlc1t0cmltbWVkXS52YXJzKSk7XG5cbiAgICAgICAgICBpICs9IG5ld1RlbXBsYXRlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFycy5sZW5ndGggPSAwO1xuICB2YXJzLnB1c2goLi4ua2V5cyhuZXdWYXJzKSk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuIiwiaW1wb3J0IHsgaXNBcnJheSwgaXNTdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUJsb2NrLCBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpbml0QXBwXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1RlbXBsYXRlfFNjb3BlbGVzc1RlbXBsYXRlfFN0cmluZ3x0eXBlb2YgQmxvY2t9IGJsb2NrIC0gUm9vdCB0ZW1wbGF0ZSAobWF5IGJlIHNjb3BlbGVzcyksXG4gKiBzdHJpbmcgZGVmaW5pbmcgYSBuYW1lIG9mIHRoZSByb290IGJsb2NrIG9yIGEgYmxvY2sgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIG9mIHRoZSBhcHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGluaXRpYWxpemluZyBhcHAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGluaXRBcHAsIGRvYyB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogaW5pdEFwcChodG1sYDxBcHAvPmAsIGRvYy5jcmVhdGUoJ2RpdicpKTtcbiAqIGluaXRBcHAoaHRtbFNjb3BlbGVzc2A8QXBwLz5gLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKCdBcHAnLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKEFwcCwgZG9jLmNyZWF0ZSgnZGl2JykpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEFwcChibG9jaywgY29udGFpbmVyKSB7XG4gIGNvbnN0IHBhcmVudEVsZW0gPSBuZXcgRWxlbShjb250YWluZXIpLmVsZW0oMCk7XG5cbiAgaWYgKCFwYXJlbnRFbGVtLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHBhcmVudEVsZW0ucHJvcCgnRHdheW5lUm9vdEJsb2NrJykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdUaGVyZSBhbHJlYWR5IGV4aXN0cyBhIER3YXluZSBhcHAgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAoaW5pdEFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhibG9jaykpIHtcbiAgICBibG9jayA9IHtcbiAgICAgIHZhcnM6IFtdLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6IGJsb2NrXG4gICAgICB9XVxuICAgIH07XG4gIH1cblxuICBpZiAoaXNBcnJheShibG9jaykpIHtcbiAgICBibG9jayA9IHtcbiAgICAgIHZhcnM6IFtdLFxuICAgICAgdmFsdWU6IGJsb2NrXG4gICAgfTtcbiAgfVxuXG4gIGxldCBDb25zdHJ1Y3RvcjtcblxuICBpZiAoaXNJbnN0YW5jZU9mKEJsb2NrLCBibG9jaykpIHtcbiAgICBDb25zdHJ1Y3RvciA9IGJsb2NrO1xuICB9IGVsc2Uge1xuICAgIENvbnN0cnVjdG9yID0gY2xhc3MgUm9vdEJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgICAgc3RhdGljIHRlbXBsYXRlID0gYmxvY2s7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHJvb3RCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICBub2RlOiB7XG4gICAgICBuYW1lOiAnI1Jvb3RCbG9jaycsXG4gICAgICBDb25zdHJ1Y3RvclxuICAgIH0sXG4gICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgIHBhcmVudEVsZW1cbiAgfSk7XG5cbiAgcGFyZW50RWxlbVxuICAgIC5wcm9wKCdEd2F5bmVSb290QmxvY2snLCByb290QmxvY2spXG4gICAgLmF0dHIoJ2R3YXluZS1yb290JywgJycpO1xufVxuIiwiaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG4vKipcbiAqIEBmdW5jdGlvbiByZW1vdmVBcHBcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgb2YgdGhlIGFwcC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcmVtb3ZpbmcgYXBwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyByZW1vdmVBcHAsIGZpbmQgfSBmcm9tICdkd2F5bmUnO1xuICpcbiAqIHJlbW92ZUFwcChmaW5kKCcucm9vdCcpKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFwcChjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbSA9IG5ldyBFbGVtKGNvbnRhaW5lcikuZWxlbSgwKTtcblxuICBpZiAoIWVsZW0ubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCB0byByZW1vdmUgdGhlIGFwcCBmcm9tIHdhcyBnaXZlbiEgKHJlbW92ZUFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRhaW5lciA9IGVsZW1bMF07XG5cbiAgY29uc3QgeyBEd2F5bmVSb290QmxvY2sgfSA9IGNvbnRhaW5lcjtcblxuICBpZiAoIShEd2F5bmVSb290QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdObyBhcHAgcmVnaXN0ZXJlZCBpbnNpZGUgdGhlIGdpdmVuIGVsZW1lbnQhIChyZW1vdmVBcHApJyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBEd2F5bmVSb290QmxvY2suJCQucmVtb3ZlKCk7XG4gIGVsZW0ucmVtb3ZlQXR0cignZHdheW5lLXJvb3QnKTtcblxuICBkZWxldGUgY29udGFpbmVyLkR3YXluZVJvb3RCbG9jaztcbn1cbiIsIi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xuLyogZXNsaW50IG5vLW5lZ2F0ZWQtY29uZGl0aW9uOiAwICovXG5leHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuIiwiZXhwb3J0IGNvbnN0IHtcbiAgY3JlYXRlLFxuICBrZXlzLFxuICBnZXRQcm90b3R5cGVPZjogZ2V0UHJvdG9cbn0gPSBPYmplY3Q7XG5cbmV4cG9ydCBjb25zdCBzZXRQcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoKHRhcmdldCwgcHJvdG8pID0+IHtcbiAgLyogZXNsaW50IG5vLXByb3RvOiAwICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBwcm90bztcbn0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi91dGlscy9vYmplY3RTdGF0aWNzJztcblxuZXhwb3J0IGNvbnN0IEhJREVfQ0xBU1MgPSAnX19kd2F5bmUtaGlkZGVuX18nO1xuZXhwb3J0IGNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgY29uc3QgRF9SRVNUX1JFR0VYID0gL15kLXJlc3QoPzojfCQpLztcblxuZXhwb3J0IGNvbnN0IHJvb3RCbG9ja3MgPSBjcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3Qgcm9vdE1peGlucyA9IGNyZWF0ZShudWxsKTtcbmV4cG9ydCBjb25zdCB7XG4gIGRvY3VtZW50ID0ge30sXG4gIFN5bWJvbCA9IHt9XG59ID0gZ2xvYmFsO1xuIiwiaW1wb3J0IHtcbiAgaXNOaWwsIGlzU3RyaW5nLFxuICBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzLFxuICBjb2xsZWN0RnJvbUFycmF5LCBjb2xsZWN0RnJvbU9iamVjdCxcbiAgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICB0b0h5cGhlbkNhc2UsIHNldFN5bWJvbFNwZWNpZXMsXG4gIHNldFRvU3RyaW5nVGFnLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGlzRG9jdW1lbnQsIGlzVmFsaWROb2RlLCBnZXRNYXRjaGVzRnVuY3Rpb24sXG4gIGFkZEF0dHIsIGFkZENTU1Byb3AsIGFkZERhdGFBdHRyLFxuICBhZGROZXh0LCBhZGRQYXJlbnQsIGFkZFByZXYsXG4gIHRvRWxlbSwgaXNFbGVtZW50c0NvbGxlY3Rpb24sXG4gIGdldEF0dHJOUywgZ2V0RXZlbnQsIGhpZGUsIHNob3csIHJlbW92ZVxufSBmcm9tICcuL2hlbHBlcnMvRWxlbSc7XG5pbXBvcnQgeyBTVkdfTlMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnLi9maW5kJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7U3RyaW5nfSBFbGVtRXZlbnRTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBBIHN0cmluZyBjb250YWluaW5nIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBjb21tYSB3aXRoIHplcm8gb3IgbW9yZSBzcGFjZXMgb3IganVzdCBzcGFjZXMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbUxpc3RlbmVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0V2ZW50fSBlIC0gRmlyZWQgZXZlbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBFbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbVJlbW92ZUxpc3RlbmVyc1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsuLi5FbGVtRXZlbnRTdHJpbmd9IGV2ZW50cyAtIElmIGF0IGxlYXN0IG9uZSBhcmd1bWVudCBwcmVzZW50IG9ubHkgcmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgc3BlY2lmaWVkXG4gKiBieSB0aGUgZXZlbnRzIGluIHRoZSBhcmd1bWVudHMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSXRlcmF0aW9uQ2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBub2RlIC0gSXRlcmF0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJdGVyYXRpb24gaW5kZXguXG4gKiBAcGFyYW0ge0VsZW19IGVsZW0gLSBJbml0aWFsIHNldC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBDb2xsZWN0Q2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QWRkQ2FsbGJhY2t9IGFkZCAtIEFkZCBlbGVtZW50IHRvIHRoZSBldmVudHVhbCBzZXQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gbm9kZSAtIEl0ZXJhdGlvbiBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSXRlcmF0aW9uIGluZGV4LlxuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gSW5pdGlhbCBzZXQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQWRkQ2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Li4uKEVsZW1lbnR8Tm9kZXxlbGVtKX0gZWxlbSAtIEVsZW1lbnQgdG8gYWRkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1NZXRob2RcbiAqIEBwdWJsaWNcbiAqIEB0aGlzIEVsZW1cbiAqL1xuXG5jb25zdCBFVkVOVF9TRVBBUkFUT1JfUkVHRVggPSAvWyx8IF0gKi87XG5jb25zdCBDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWCA9IC87ID8vO1xuY29uc3QgQ1NTX0lNUE9SVEFOVF9SRUdFWCA9IC8gPyFpbXBvcnRhbnQkLztcbmNvbnN0IGVtcHR5Q29sbGVjdGlvbiA9IFtdO1xuXG4vKipcbiAqIEBjbGFzcyBFbGVtXG4gKiBAZXh0ZW5kcyBBcnJheS48RWxlbWVudHxOb2RlPlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gW2VsZW0gPSBbXV0gLSBBbiBlbGVtZW50IG9yIGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RWxlbX0gSW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFuIGVsZW1lbnRzIHNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG4gKiBuZXcgRWxlbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2xzJykpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xzJykpO1xuICovXG5jbGFzcyBFbGVtIGV4dGVuZHMgQXJyYXkge1xuICAvKipcbiAgICogQG1ldGhvZCBFbGVtLmFkZE1ldGhvZHNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgRWxlbU1ldGhvZD59IG1ldGhvZE5hbWUgLSBOYW1lIG9mIHRoZSBtZXRob2Qgb3Igb2JqZWN0IG9mXG4gICAqIG1ldGhvZCBuYW1lcyBhbmQgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtFbGVtTWV0aG9kfSBbbWV0aG9kXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyB0aGlzIHNob3VsZCBiZSB0aGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybnMge3R5cGVvZiBFbGVtfVxuICAgKi9cbiAgc3RhdGljIGFkZE1ldGhvZHMobWV0aG9kTmFtZSwgbWV0aG9kKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgbWV0aG9kTmFtZSA9IHsgW21ldGhvZE5hbWVdOiBtZXRob2QgfTtcbiAgICB9XG5cbiAgICBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRoaXMucHJvdG90eXBlLCBtZXRob2ROYW1lKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbSA9IGVtcHR5Q29sbGVjdGlvbikge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICBlbGVtID0gW2VsZW1dO1xuICAgIH1cblxuICAgIHNldFByb3RvKHRoaXMsIEVsZW0ucHJvdG90eXBlKTtcblxuICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgaWYgKCFpc0VsZW1lbnRzQ29sbGVjdGlvbihlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlQXJyYXkoZWxlbSwgKGVsZW0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVzKGVsZW0pICYmIGlzVmFsaWROb2RlKGVsZW0pKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYWRkXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4oRWxlbXxFbGVtZW50fEVsZW1lbnRbXSl9IGVsZW1lbnRzIC0gRWFjaCBhcmd1bWVudCBpcyBhIEVsZW0sIG9yIEVsZW1lbnQsIG9yIGFycmF5IG9mIEVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgbmV3IGVsZW1lbnRzIHRvIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0xLmZpbmQoJy5jbHMxJylcbiAgICogICAuYWRkKGVsZW0yLmZpbmQoJy5jbHMyJykpXG4gICAqICAgLmhpZGUoKTtcbiAgICovXG4gIGFkZCguLi5lbGVtZW50cykge1xuICAgIGNvbnN0IGVsZW1zID0gdGhpcy5zbGljZSgpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGVsZW1lbnRzLCAoZWxlbSkgPT4ge1xuICAgICAgaWYgKCFpc0VsZW1lbnRzQ29sbGVjdGlvbihlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlQXJyYXkoZWxlbSwgKGVsZW0pID0+IHtcbiAgICAgICAgaWYgKCFlbGVtcy5pbmNsdWRlcyhlbGVtKSAmJiBpc1ZhbGlkTm9kZShlbGVtKSkge1xuICAgICAgICAgIGVsZW1zLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBjbGFzc2VzIHRvIHRoZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ3JlZCcsICdyb3VuZCcpO1xuICAgKi9cbiAgYWRkQ2xhc3MoLi4uY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGNsYXNzZXMsIChjbHMpID0+IGxpc3QuYWRkKGNscykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFthdHRyXSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBnZXQgb3JcbiAgICogYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gICAqIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBhdHRyaWJ1dGVzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQsIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHIxJywgJ3ZhbHVlMScpOyAvLyBhdHRyaWJ1dGUgYXR0cjEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uYXR0cignYXR0cjEnKTsgICAgICAgICAgIC8vICd2YWx1ZTEnXG4gICAqIGVsZW0uYXR0cih7XG4gICAqICAgYXR0cjE6ICd2YWx1ZTMnLCAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMydcbiAgICogICBhdHRyMjogJ3ZhbHVlMicgICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uYXR0cigpOyAgICAgICAgICAgICAgICAgIC8vIHsgYXR0cjE6ICd2YWx1ZTMnLCBhdHRyMjogJ3ZhbHVlMicgfVxuICAgKi9cbiAgYXR0cihhdHRyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShlbGVtLmF0dHJpYnV0ZXMsIGFkZEF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcoYXR0cikpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBucyxcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgICAgcmV0dXJuIG5zXG4gICAgICAgID8gZWxlbS5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSlcbiAgICAgICAgOiBlbGVtLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBhdHRyID0geyBbYXR0cl06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChhdHRyLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVBdHRyKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZTtcblxuICAgICAgICBjb25zdCB7IG5zIH0gPSBnZXRBdHRyTlMoa2V5LCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZU5TKG5zLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NoaWxkcmVuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IEQtV3JhcCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBlbGVtZW50J3MgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbigpO1xuICAgKi9cbiAgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXMubGVuZ3RoID8gdGhpc1swXS5jaGlsZE5vZGVzIDogW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjbG9zZXN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjY2xvc2VzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdH0uXG4gICAqL1xuICBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NvbGxlY3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0NvbGxlY3RDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIGV2ZW50dWFsIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY29sbGVjdGluZyBlbGVtZW50cyBpbnRvIGEgbmV3IHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcGFyZW50cyA9IGVsZW0uY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAqICAgYWRkKGVsZW0ucGFyZW50Tm9kZSk7XG4gICAqIH0pO1xuICAgKi9cbiAgY29sbGVjdChjYWxsYmFjaykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgY29uc3QgY2IgPSA6OmVsZW1lbnRzLnB1c2g7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBjYWxsYmFjayhjYiwgZWxlbSwgaW5kZXgsIHRoaXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBFbGVtKGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY29udGFpbnNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gZmluZCBvdXQgaWYgaXQncyB3aXRoaW4gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgaWYgdGhlIGFyZ3VtZW50IHdpdGhpbiB0aGlzIGVsZW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgZXh0ZW5zaW9uIGZvclxuICAgKiBbTm9kZSNjb250YWluc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvY29udGFpbnN9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNvbnRhaW5zKGVsZW0yKTsgICAvLyB0cnVlfGZhbHNlXG4gICAqL1xuICBjb250YWlucyhlbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1swXTtcbiAgICBjb25zdCBjaGlsZCA9IHRvRWxlbShlbGVtZW50KVswXTtcblxuICAgIHJldHVybiAhcGFyZW50IHx8ICFjaGlsZFxuICAgICAgPyBmYWxzZVxuICAgICAgOiBwYXJlbnQuY29udGFpbnMoY2hpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFR5cGUgb2YgY3JlYXRlZCBlbGVtZW50LiBJZiB0eXBlIGlzIFwiI3RleHRcIiBhIHRleHQgbm9kZSBpcyBjcmVhdGVkLlxuICAgKiBJZiB0eXBlIGlzIFwiI2NvbW1lbnRcIiBhIGNvbW1lbnQgbm9kZSBpcyBjcmVhdGVkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBlbGVtZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGVsZW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZSgnZGl2Jyk7XG4gICAqL1xuICBjcmVhdGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgbGV0IGVsID0gbnVsbDtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHR5cGUgPT09ICcjdGV4dCc7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBpZiAoaXNUZXh0IHx8IHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgZWwgPSBpc1RleHRcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IHR5cGUgPT09ICdzdmcnXG4gICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0RvY3VtZW50KGVsZW0pKSB7XG4gICAgICAgIG5ldyBFbGVtKGVsKS5pbnRvKGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBhZGQoZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3Byb3BlcnR5XSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFtwcm9wZXJ0eV06IHZhbHVlLCAuLi4gfSB0byBzZXQgc3R5bGVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBzaG91bGQgYmUgYSB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBjc3Mgc3R5bGVzIG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgc3R5bGVzLiBTdXBwb3J0cyAhaW1wb3J0YW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNzcygnZGlzcGxheScsICdub25lJyk7IC8vIGRpc3BsYXkgc2V0IHRvICdub25lJyBhbmQgdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygnZGlzcGxheScpOyAgICAgICAgIC8vICdub25lJ1xuICAgKiBlbGVtLmNzcyh7XG4gICAqICAgZGlzcGxheTogJ2lubGluZScsICAgICAgICAgLy8gZGlzcGxheSBzZXQgdG8gJ2lubGluZSdcbiAgICogICBjdXJzb3I6ICdwb2ludGVyJyAgICAgICAgICAvLyBjdXJzb3Igc2V0IHRvICdwb2ludGVyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5jc3MoKTsgICAgICAgICAgICAgICAgICAvLyB7IGRpc3BsYXk6ICdub25lJywgY3Vyc29yOiAncG9pbnRlcicgfVxuICAgKi9cbiAgY3NzKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXNbMF0gfHwge307XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShzdHlsZS5jc3NUZXh0LnNwbGl0KENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYKSwgYWRkQ1NTUHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBwcm9wZXJ0eSA9IHRvSHlwaGVuQ2FzZShwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSArIChzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHByb3BlcnR5KSA/ICcgIWltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBwcm9wZXJ0eSA9IHRvSHlwaGVuQ2FzZShwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ1NTKHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlLnJlcGxhY2UoQ1NTX0lNUE9SVEFOVF9SRUdFWCwgJycpLFxuICAgICAgICAgIENTU19JTVBPUlRBTlRfUkVHRVgudGVzdCh2YWx1ZSkgPyAnaW1wb3J0YW50JyA6ICcnXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGF0YVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBba2V5XSAtIE5hbWUgb2YgdGhlIGRhdGEgYXR0cmlidXRlICh3aXRob3V0IGRhdGEtIHByZWZpeClcbiAgICogdG8gZ2V0IG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW2F0dHJOYW1lXTogdmFsdWUsIC4uLiB9IHRvIHNldCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBzaG91bGQgYmUgYSB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN0cmluZ3xFbGVtfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkLCBELVdyYXAgb2YgZGF0YXNldCBvZiB0aGUgZWxlbWVudCByZXR1cm5lZCxcbiAgICogaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGRhdGEgYXR0cmlidXRlcy4gU2VlXG4gICAqIFtIVE1MRWxlbWVudCNkYXRhc2V0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvZGF0YXNldH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnLCAndmFsdWUnKTsgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkxIHNldCB0byAndmFsdWUxJyBhbmQgdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmRhdGEoJ3NvbWVLZXkxJyk7ICAgICAgICAgIC8vICd2YWx1ZTEnXG4gICAqIGVsZW0uZGF0YSh7XG4gICAqICAgc29tZUtleTE6ICd2YWx1ZTMnLCAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIHNvbWVLZXkyOiAndmFsdWUyJyAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBkYXRhLXNvbWUta2V5MiBzZXQgdG8gJ3ZhbHVlMidcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgpOyAgICAgICAgICAgICAgICAgICAgLy8geyBzb21lS2V5MTogJ3ZhbHVlMycsIHNvbWVLZXkyOiAndmFsdWUyJyB9XG4gICAqL1xuICBkYXRhKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXNbMF0gfHwge307XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZGF0YXNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChkYXRhc2V0LCBhZGREYXRhQXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNTdHJpbmcoa2V5KSkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFzZXRba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBrZXkgPSB7IFtrZXldOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3Qoa2V5LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBlbGVtLmRhdGFzZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Rpc3BhdGNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR9IGV2ZW50IC0gRXZlbnQgb3IgYSBzdHJpbmcgKG5ldyBFdmVudChldmVudCkgaXMgY3JlYXRlZCkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlscyA9IHt9XSAtIE9iamVjdCB0aGF0IGlzIGFzc2lnbmVkIHRvIHRoZSBldmVudC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnQvRXZlbnRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFdmVudFRhcmdldCNkaXNwYXRjaEV2ZW50XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvZGlzcGF0Y2hFdmVudH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJyk7XG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJywgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsbGFibGU6IGZhbHNlLCBkYXRhOiAxIH0pO1xuICAgKiBlbGVtLmRpc3BhdGNoKG5ldyBDdXN0b21FdmVudCgnY3VzdG9tLWV2ZW50JykpO1xuICAgKi9cbiAgZGlzcGF0Y2goZXZlbnQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1YmJsZXMgPSB0cnVlLFxuICAgICAgY2FuY2VsYWJsZSA9IHRydWUsXG4gICAgICAuLi5yZWFsRGV0YWlsc1xuICAgIH0gPSBkZXRhaWxzO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGdldEV2ZW50KFxuICAgICAgICBldmVudCxcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZSxcbiAgICAgICAgcmVhbERldGFpbHMsXG4gICAgICAgIGVsZW1cbiAgICAgICkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNlbGVtXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleCA9IDBdIC0gSW5kZXggb2YgdGhlIGVsZW1lbnQgb2YgdGhlIHNldCB0byBnZXQuIE5lZ2F0aXZlIGluZGV4IG1lYW5zIGVsZW0ubGVuZ3RoICsgaW5kZXguXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5lbGVtKDEpOyAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAxXG4gICAqIGVsZW0uZWxlbSgpOyAgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMFxuICAgKi9cbiAgZWxlbShpbmRleCA9IDApIHtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMubGVuZ3RoICsgaW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXNbaW5kZXhdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZmlsdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja3xTdHJpbmd9IGZpbHRlciAtIEZpbHRlciBmdW5jdGlvbiBvciBhIHNlbGVjdG9yLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbHRlcmluZyBlbGVtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5maWx0ZXIoKGVsZW0pID0+IG5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJy5wYXJlbnQnKSk7XG4gICAqL1xuICBmaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKGZpbHRlcikpIHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZmlsdGVyO1xuXG4gICAgICBmaWx0ZXIgPSAoZWxlbSkgPT4gKFxuICAgICAgICBuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGZpbHRlcihlbGVtLCBpbmRleCwgdGhpcykpIHtcbiAgICAgICAgYWRkKGVsZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmaW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXG4gICAqL1xuICBmaW5kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBhZGQoZmluZChzZWxlY3RvciwgZWxlbSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmb3JFYWNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGZpbmQoJy5jbHMnKS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCwgc2V0KSA9PiB7XG4gICAqICAgLy8gZG8gc29tZXRoaW5nXG4gICAqIH0pO1xuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIGl0ZXJhdGVBcnJheSh0aGlzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY2FsbGJhY2sodmFsdWUsIGtleSwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGF0dHJpYnV0ZS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGF0dHJpYnV0ZSBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cicsICd2YWx1ZScpLmhhc0F0dHIoJ2F0dHInKTsgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2F0dHInKS5oYXNBdHRyKCdhdHRyJyk7ICAgIC8vIGZhbHNlXG4gICAqL1xuICBoYXNBdHRyKGF0dHIpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIGlmICghZWxlbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgIHJldHVybiBuc1xuICAgICAgPyBlbGVtLmhhc0F0dHJpYnV0ZU5TKG5zLCBhdHRyKVxuICAgICAgOiBlbGVtLmhhc0F0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gTmFtZSBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3MuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcyBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgICAgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKS5oYXNDbGFzcygnY2xzJyk7IC8vIGZhbHNlXG4gICAqL1xuICBoYXNDbGFzcyhjbHMpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNscylcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hpZGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gSGlkZXMgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaGlkZSgpO1xuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGhpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNodG1sXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW2h0bWxdIC0gSFRNTCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgSFRNTC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIEhUTUwgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyBIVE1MIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgaHRtbCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyBIVE1MLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmh0bWwoJzxkaXY+MTwvZGl2PicpO1xuICAgKiBlbGVtLmh0bWwoKTsgLy8gJzxkaXY+MTwvZGl2PidcbiAgICovXG4gIGh0bWwoaHRtbCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgIHJldHVybiBlbGVtXG4gICAgICAgID8gZWxlbS5pbm5lckhUTUxcbiAgICAgICAgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luY2x1ZGVzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtZW50fG5vZGV9IGVsZW0gLSBFbGVtZW50IHRvIHNlYXJjaC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBzYW1lIGFzIEFycmF5I2luY2x1ZGVzLlxuICAgKi9cbiAgaW5jbHVkZXMoZWxlbSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbSkgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnNlcnRBZnRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGFmdGVyLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUHV0cyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGFmdGVyIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQuXG4gICAqIFRoZSBlbGVtZW50cyByZW1haW4gaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnNlcnRBZnRlcignI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0KClbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaWYgKGVsZW0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnNlcnRCZWZvcmVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gaW5zZXJ0IHRoaXMgZWxlbWVudCBiZWZvcmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYmVmb3JlIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQuXG4gICAqIFRoZSBlbGVtZW50cyByZW1haW4gaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKGVsZW0yKTtcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZSgnI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgaW5zZXJ0QmVmb3JlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpLmVsZW0oMCk7XG5cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnRbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtLCBlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaW50b1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBwdXQgdGhpcyBlbGVtZW50cyBpbnRvLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgdGhleSBhcmUgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjYXBwZW5kQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2FwcGVuZENoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnRvKGVsZW0yKTtcbiAgICogZWxlbS5pbnRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnRvKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnRvKGVsZW1lbnQsIGVuZCA9IHRydWUpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWVuZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXNbaV0sIGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2lzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjbWF0Y2hlc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gdHJ1ZVxuICAgKlxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKTtcbiAgICogZWxlbS5pcygnLmNscycpOyAgICAgICAgIC8vIGZhbHNlXG4gICAqL1xuICBpcyhzZWxlY3Rvcikge1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcbiAgICBjb25zdCBtYXRjaGVzID0gZ2V0TWF0Y2hlc0Z1bmN0aW9uKGVsZW0pO1xuXG4gICAgcmV0dXJuIGVsZW06Om1hdGNoZXMoc2VsZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNuYW1lXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cmluZ3x2b2lkfSBub2RlTmFtZSAobG93ZXJjYXNlZCkgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBuYW1lIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKS5uYW1lKCkgLy8gJ2RpdidcbiAgICovXG4gIG5hbWUoKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICByZXR1cm4gZWxlbVxuICAgICAgPyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNuZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5uZXh0KCk7IC8vIGZpbmRzIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZE5leHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNvblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbUV2ZW50U3RyaW5nfE9iamVjdC48RWxlbUV2ZW50U3RyaW5nfEVsZW1MaXN0ZW5lcj59IGV2ZW50IC0gRWl0aGVyIGEge0BsaW5rIEVsZW1FdmVudFN0cmluZ30gc3RyaW5nXG4gICAqIG9yIGFuIG9iamVjdCB3aXRoIGV2ZW50IGtleXMgKGEga2V5IGlzIGFsc28gRWxlbUV2ZW50U3RyaW5nKSBhbmQgbGlzdGVuZXJzIHZhbHVlcy5cbiAgICogQHBhcmFtIHtFbGVtTGlzdGVuZXJ9IFtsaXN0ZW5lcl0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgaXQgbXVzdCBiZSBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZvclxuICAgKiBzcGVjaWZpZWQgZXZlbnQocykuXG4gICAqIEByZXR1cm5zIHtFbGVtUmVtb3ZlTGlzdGVuZXJzfSBGdW5jdGlvbiB0aGF0IHRha2VzIG9wdGlvbmFsIGV2ZW50IGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5vbihcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXG4gICAqICAgKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKVxuICAgKiApO1xuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oe1xuICAgKiAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcbiAgICogICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9IGVsZW0ub24oe1xuICAgKiAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcbiAgICogICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcbiAgICogfSk7XG4gICAqXG4gICAqIHJlbW92ZUxpc3RlbmVycygnY2xpY2snKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnLCAnaW5wdXQnKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAqL1xuICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoZXZlbnQpKSB7XG4gICAgICBldmVudCA9IHsgW2V2ZW50XTogbGlzdGVuZXIgfTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdFdmVudHMgPSB7fTtcbiAgICBjb25zdCBhbGxMaXN0ZW5lcnMgPSB7fTtcblxuICAgIGl0ZXJhdGVPYmplY3QoZXZlbnQsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShldmVudC5zcGxpdChFVkVOVF9TRVBBUkFUT1JfUkVHRVgpLCAoZXZlbnQpID0+IHtcbiAgICAgICAgKG5ld0V2ZW50c1tldmVudF0gPSBuZXdFdmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KG5ld0V2ZW50cywgKGxpc3RlbmVycywgZXZlbnQpID0+IHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGxpc3RlbmVycywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgIChhbGxMaXN0ZW5lcnNbZXZlbnRdID0gYWxsTGlzdGVuZXJzW2V2ZW50XSB8fCBbXSkucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhldmVudCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gYWxsTGlzdGVuZXJzW2V2ZW50XTtcblxuICAgICAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkocmVtb3ZlTGlzdGVuZXJzLCAocmVtb3ZlTGlzdGVuZXIpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuXG4gICAgICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVPYmplY3QoYWxsTGlzdGVuZXJzLCAocmVtb3ZlTGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICBkZWxldGUgYWxsTGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcGFyZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHJldHVybnMgd3JhcCBvZiB0aGUgc2V0IG9mIHRoZSBwYXJlbnQgZWxlbWVudHMgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqL1xuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGRQYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwcmV2XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJldigpOyAvLyBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBwcmV2KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkUHJldik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3Byb3BcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgKj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gYXNzaWduZWQgb2JqZWN0LlxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZ1xuICAgKiB0aGlzIGhhcyB0byBiZSBhbiBhc3NpZ25lZCB2YWx1ZSBpZiBpdCdzIHByZXNlbnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfCp9IFJldHVybnMgdGhpcyBpZiBpdCdzIHNldHRlciBvciBhIHZhbHVlIGlmIGdldHRlci5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IGlzIGVpdGhlciBhIHByb3BlcnR5IGdldHRlciBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiBvciBhIHNldHRlciBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScsIGZhbHNlKTtcbiAgICogZWxlbS5wcm9wKCdkcmFnZ2FibGUnKTsgLy8gZmFsc2VcbiAgICovXG4gIHByb3AocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXVtwcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgIGVsZW1bcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICogTm90ZTogaXQgZG9lc24ndCByZW1vdmUgdGhlbSBmcm9tIHRoZSBzZXQgc28gd2F0Y2ggb3V0IGZvciB0aGUgbWVtb3J5IGxlYWtzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZSgpO1xuICAgKi9cbiAgcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2gocmVtb3ZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdmb28nLCAnYmFyJywgJ2JheicpO1xuICAgKi9cbiAgcmVtb3ZlQXR0ciguLi5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGF0dHJpYnV0ZXMsIChhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBhdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGNsYXNzZXMgLSBDbGFzc2VzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBjbGFzc2VzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdmb28nLCAnYmFyJywgJ2JheicpO1xuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoLi4uY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGNsYXNzZXMsIChjbHMpID0+IGxpc3QucmVtb3ZlKGNscykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVDU1NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gcHJvcHMgLSBDU1MgcHJvcGVydGllcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgQ1NTIHByb3BlcnRpZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ1NTKCdkaXNwbGF5JywgJ3Bvc2l0aW9uJywgJ21hcmdpbicpO1xuICAgKi9cbiAgcmVtb3ZlQ1NTKC4uLnByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KHByb3BzLCAoY3NzKSA9PiB7XG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkodG9IeXBoZW5DYXNlKGNzcykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlcGxhY2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gcmVwbGFjZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHdpdGggYSBzZXQgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudCAoRWxlbWVudCBvciBFbGVtKS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBzaW1pbGFyIHRvXG4gICAqIFtOb2RlI3JlcGxhY2VDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvcmVwbGFjZUNoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZXBsYWNlKGVsZW0yKTtcbiAgICogZWxlbS5yZXBsYWNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5yZXBsYWNlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICByZXBsYWNlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpO1xuXG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmVsZW0oMCk7XG4gICAgY29uc3QgcGFyZW50ID0gZmlyc3QucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBlbGVtID0gcGFyZW50O1xuICAgIGxldCBtZXRob2QgPSAnaW50byc7XG4gICAgY29uc3QgbmV4dCA9IGZpcnN0Lm5leHQoKVswXTtcbiAgICBjb25zdCBwcmV2ID0gZmlyc3QucHJldigpWzBdO1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIGVsZW0gPSBuZXh0O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEJlZm9yZSc7XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbGVtID0gcHJldjtcbiAgICAgIG1ldGhvZCA9ICdpbnNlcnRBZnRlcic7XG4gICAgfVxuXG4gICAgZmlyc3QucmVtb3ZlKCk7XG5cbiAgICBlbGVtZW50W21ldGhvZF0oZWxlbSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3Nob3dcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gU2hvd3MgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqIElmIGFuIGVsZW1lbnQgd2FzIGhpZGRlbiB1c2luZyB7QGxpbmsgRWxlbSNoaWRlfSBwcmV2aW91cyBkaXNwbGF5IGlzIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5zaG93KCk7XG4gICAqL1xuICBzaG93KCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goc2hvdyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3NsaWNlXG4gICAqIEBwdWJsaWNcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zbGljZVxuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBzYW1lIGFzIEFycmF5I3NsaWNlIGJ1dCBmb3IgRWxlbS5cbiAgICovXG4gIHNsaWNlKCkge1xuICAgIHJldHVybiBuZXcgRWxlbShzdXBlci5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFt0ZXh0XSAtIFRleHQgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IHRleHQuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCB0ZXh0IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgdGV4dHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSB0ZXh0IGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIHRleHQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udGV4dCgnMTIzJyk7XG4gICAqIGVsZW0udGV4dCgpOyAvLyAnMTIzJ1xuICAgKi9cbiAgdGV4dCh0ZXh0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wKCd0ZXh0Q29udGVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0b2dnbGVBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgLSBBdHRyaWJ1dGUgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgYXR0cmlidXRlXG4gICAqIHdpdGggdGhlICcnIHZhbHVlIGFuZCBpZiBmYWxzZXkgbWV0aG9kIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZS4gSWYgbm90IHByZXNlbnQgbWV0aG9kIGFkZHNcbiAgICogdGhlIGF0dHJpYnV0ZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicpO1xuICAgKiBlbGVtLnRvZ2dsZUF0dHIoJ2F0dHInLCBzb21lQ29uZGl0aW9uKTtcbiAgICovXG4gIHRvZ2dsZUF0dHIoYXR0ciwgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhZWxlbS5oYXNBdHRyKGF0dHIpIDogY29uZGl0aW9uKSB7XG4gICAgICAgIGVsZW0uYXR0cihhdHRyLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUNsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNscyAtIENsYXNzIHRvIHRvZ2dsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtjb25kaXRpb25dIC0gSWYgcHJlc2VudCBhbmQgdGhlIGNvbmRpdGlvbiBpcyB0cnV0aHkgbWV0aG9kIGFkZHMgdGhlIGNsYXNzXG4gICAqIGFuZCBpZiBmYWxzZXkgbWV0aG9kIHJlbW92ZXMgdGhlIGNsYXNzLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgY2xhc3MgaWYgaXQgZG9lc24ndCBleGlzdCBhbmQgcmVtb3ZlcyBpZiBpdCBkb2VzLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB0b2dnbGluZyBjbGFzc2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnRvZ2dsZUNsYXNzKCdjbHMnKTtcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJywgc29tZUNvbmRpdGlvbik7XG4gICAqL1xuICB0b2dnbGVDbGFzcyhjbHMsIGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IHsgY2xhc3NMaXN0IH0gPSBlbGVtO1xuXG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKGNscywgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhY2xhc3NMaXN0LmNvbnRhaW5zKGNscykgOiBjb25kaXRpb24pO1xuICAgIH0pO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKEVsZW0sICdFbGVtJyk7XG5zZXRTeW1ib2xTcGVjaWVzKEVsZW0sIEFycmF5KTtcblxuZXhwb3J0IHsgRWxlbSB9O1xuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gJy4vZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgU3ltYm9sIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFN5bWJvbFNwZWNpZXMoa2xhc3MsIHNwZWNpZXMpIHtcbiAgaWYgKFN5bWJvbC5zcGVjaWVzKSB7XG4gICAgZGVmaW5lUHJvcGVydGllcyhrbGFzcywge1xuICAgICAgW1N5bWJvbC5zcGVjaWVzXToge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNwZWNpZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcywgZ2V0UHJvdG8sXG4gIHJlbW92ZUFycmF5RWxlbSwgc2V0VG9TdHJpbmdUYWdcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB3cmFwTWl4aW4sIHJlbW92ZVdhdGNoZXJzIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcblxuY29uc3QgdG9TdHJpbmdUYWcgPSAnW29iamVjdCBNaXhpbl0nO1xuXG4vKipcbiAqIEBjbGFzcyBNaXhpblxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBNaXhpbiBvcHRpb25zLlxuICogQHJldHVybnMge01peGlufSBJbnN0YW5jZSBvZiBNaXhpbi5cbiAqL1xuY2xhc3MgTWl4aW4ge1xuICAvKipcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gW01peGluLmV2YWx1YXRlID0gdHJ1ZV1cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSBtaXhpbiB2YWx1ZSBzaG91bGQgYmUgZXZhbHVhdGVkIGFuZCB3YXRjaGVkIG9yIG5vdC5cbiAgICovXG4gIHN0YXRpYyBldmFsdWF0ZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTWl4aW4ud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBtaXhpbi5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbn0gTmV3IG1peGluLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBtaXhpbnMuXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBtaXhpbiB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKC4uLndyYXBwZXJzKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJzLnJlZHVjZSh3cmFwTWl4aW4sIHRoaXMpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGR5bmFtaWMsXG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNvbW1lbnQsXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3Qgd2F0Y2hlcnMgPSBbXTtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yIH0gPSBnZXRQcm90byh0aGlzKTtcbiAgICBjb25zdCBhZnRlclVwZGF0ZSA9IChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIHRoaXMuJCQudmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5hZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclVwZGF0ZTpgLCBlcnIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBNaXhpbiMkJFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IE1peGluIyQkLmV2YWx1YXRlIC0gRXZhbHVhdGUgZnVuY3Rpb24uXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IE1peGluIyQkLmlzRHluYW1pYyAtIElmIHRoZSBtaXhpbiBpcyBkeW5hbWljLlxuICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBNaXhpbiMkJC5pc1JlbW92ZWQgLSBJZiB0aGUgYmxvY2sgaXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBNaXhpbiMkJC5uYW1lIC0gTWl4aW4gbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gTWl4aW4jJCQucGFyZW50QmxvY2sgLSBQYXJlbnQgYmxvY2suXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IE1peGluIyQkLnBhcmVudFNjb3BlIC0gUGFyZW50IHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBNaXhpbiMkJC5wYXJlbnRUZW1wbGF0ZSAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7V2F0Y2hlcltdfSBCbG9jayMkJC53YXRjaGVycyAtIFRlbXBvcmFyeSB2YXJzIHdhdGNoZXJzLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gQmxvY2sjJCQud2F0Y2hlcnNUb1JlbW92ZSAtIFdhdGNoZXJzIHRvIHJlbW92ZSBiZWZvcmUgcmVtb3ZpbmcgbWl4aW4uXG4gICAgICAgKi9cbiAgICAgICQkOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIF92YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc0R5bmFtaWM6IGR5bmFtaWMsXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIHdhdGNoZXJzLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBpc1JlbW92ZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc0R5bmFtaWMsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIF92YWx1ZVxuICAgICAgICAgIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGlzRHluYW1pY1xuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShfdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoaXNQYXJlbnRTaWduYWwpID0+IHtcbiAgICAgICAgICBpc1BhcmVudFNpZ25hbCA9ICEhaXNQYXJlbnRTaWduYWw7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoaXNQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5taXhpbnMsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0QWZ0ZXJVcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICBpZiAoY29uc3RydWN0b3IuZXZhbHVhdGUpIHtcbiAgICAgICAgICAgIGFmdGVyVXBkYXRlKHRoaXMuJCQuZXZhbHVhdGUoYWZ0ZXJVcGRhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBbTWl4aW4jYXJnc11cbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IFtNaXhpbiNjb21tZW50XVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudFNjb3BlXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QmxvY2t9IFtNaXhpbiNwYXJlbnRUZW1wbGF0ZV1cbiAgICAgKiBAdHlwZSB7QmxvY2t9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMucGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0VsZW19IE1peGluI2VsZW1cbiAgICAgKiBAdHlwZSB7RWxlbX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IE1peGluI25vZGVcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5ub2RlID0gZWxlbVswXTtcblxuICAgIHBhcmVudEJsb2NrLiQkLm1peGlucy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1peGluI2JlZm9yZVJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFbGVtZW50UmVtb3ZlZCAtIElmIGVsZW1lbnQgcmVtb3ZlZCBhcyB3ZWxsLlxuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGJlZm9yZSB0aGUgbWl4aW4gcmVtb3ZhbC5cbiAgICovXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtXYXRjaGVyfSBbY2FsbGJhY2tdIC0gSWYgcHJlc2VudCwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIG1peGluIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoY2FsbGJhY2spO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nVGFnO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKE1peGluLCAnTWl4aW4nKTtcblxuZXhwb3J0IHsgTWl4aW4gfTtcbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcyxcbiAgYXNzaWduLCBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzRnVuY3Rpb24sIGlzQXJyYXksXG4gIHNldFRvU3RyaW5nVGFnLCBoYXNPd25Qcm9wZXJ0eSxcbiAgcmVtb3ZlQXJyYXlFbGVtLCBjcmVhdGUsXG4gIGdldFByb3RvLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGNvbnN0cnVjdE1peGluUmVnZXgsIGlzSW5zdGFuY2VPZiwgbm9ybWFsaXplQXJncyxcbiAgcmVtb3ZlV2F0Y2hlcnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNsZWFuUHJvcGVydHksXG4gIHRyYW5zZm9ybVJlc3RBcmdzLCBjYWxjdWxhdGVBcmdzLCB3cmFwQmxvY2tcbn0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7XG4gIERfUkVTVF9SRUdFWCxcbiAgcm9vdEJsb2Nrcywgcm9vdE1peGluc1xufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4vTWl4aW4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlbXBsYXRlXG4gKiBAcHVibGljXG4gKiBAcHJvcGVydHkge1N0cmluZ1tdfSB2YXJzIC0gVGVtcGxhdGUgdXNlZCB2YXJzLlxuICogQHByb3BlcnR5IHtPYmplY3RbXX0gdmFsdWUgLSBUZW1wbGF0ZSBpdHNlbGYuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0W119IFNjb3BlbGVzc1RlbXBsYXRlXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEV2YWx1YXRpb25FcnJvclxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHdoaWNoIGNhdXNlZCBldmFsIGVycm9yLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG9yaWdpbmFsIC0gRXZhbHVhdGVkIGV4cHJlc3Npb24gb3JpZ2luYWwganMuXG4gKiBAcHJvcGVydHkge0Jsb2NrfSBibG9jayAtIEJsb2NrIGluIGNvbnRleHQgb2Ygd2hpY2ggdGhlIGV4cHJlc3Npb24gaGFzIGJlZW4gZXZhbHVhdGVkIHdpdGggdGhlIGVycm9yLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhdGNoZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdyYXBwZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIEJsb2NrfHR5cGVvZiBNaXhpbn0gQmxvY2sgY2xhc3MgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t9IE5ldyBCbG9jayBjbGFzcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBZnRlclVwZGF0ZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXG4gKiBAcGFyYW0ge01peGlufSBtaXhpbiAtIE1peGluIGluc3RhbmNlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEJsb2NrUmVnaXN0ZXJIb29rXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3R5cGVvZiBCbG9ja30gQmxvY2sgLSBSZWdpc3RlcmluZyBibG9jay5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgbmFtZS5cbiAqIEByZXR1cm5zIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciByZWdpc3RlcmluZyB0aGUgYmxvY2suXG4gKiBJZiBCbG9jayBzdWJjbGFzcyByZXR1cm5lZCBpdCdzIHJlZ2lzdGVyZWQgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCBibG9jaywgb3RoZXJ3aXNlXG4gKiB0aGUgaW5pdGlhbCBibG9jayBpcyB1c2VkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1peGluUmVnaXN0ZXJIb29rXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3R5cGVvZiBNaXhpbn0gTWl4aW4gLSBSZWdpc3RlcmluZyBtaXhpbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTWl4aW4gbmFtZS5cbiAqIEByZXR1cm5zIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciByZWdpc3RlcmluZyB0aGUgbWl4aW4uXG4gKiBJZiBNaXhpbiBzdWJjbGFzcyByZXR1cm5lZCBpdCdzIHJlZ2lzdGVyZWQgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCBtaXhpbiwgb3RoZXJ3aXNlXG4gKiB0aGUgaW5pdGlhbCBtaXhpbiBpcyB1c2VkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlbW92ZUhvb2tcbiAqIEBwdWJsaWNcbiAqL1xuXG5jb25zdCBibG9ja0hvb2tzID0gW107XG5jb25zdCBtaXhpbkhvb2tzID0gW107XG5jb25zdCBUQUdfTkFNRV9SRUdFWCA9IC9eW2Etel1bYS16XFxkXFwtXy46IUAjJCVeJiooKVtcXF17fT0nXCJcXFxcXSokL2k7XG5jb25zdCBBVFRSX05BTUVfUkVHRVggPSAvXlteXFx1MDAwMC1cXHUwMDIwXFxzJ1wiPi89XSskLztcbmNvbnN0IHRvU3RyaW5nVGFnID0gJ1tvYmplY3QgQmxvY2tdJztcbmNvbnN0IGFmdGVyRWxlbSA9IG5ldyBFbGVtKCk7XG5jb25zdCBlbXB0eU9iamVjdCA9IHt9O1xubGV0IGV2YWxNb2RlID0gZmFsc2U7XG5sZXQgZ2V0dGluZ1ZhcnMgPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgQmxvY2tcbiAqIEBleHRlbmRzIG51bGxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQmxvY2sgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtCbG9ja30gSW5zdGFuY2Ugb2YgQmxvY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEJsb2NrLCBpbml0QXBwIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiBjbGFzcyBBcHAgZXh0ZW5kcyBCbG9jayB7XG4gKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8SGVsbG8gdGV4dD1cInt0ZXh0fVwiLz4gKHsgdGhpcy50aW1lcyB9KSc7XG4gKlxuICogICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gKiAgICAgc3VwZXIob3B0cyk7XG4gKlxuICogICAgIHRoaXMudGV4dCA9ICd3b3JsZCc7XG4gKiAgICAgdGhpcy50aW1lcyA9IDA7XG4gKlxuICogICAgIHRoaXMuc2V0SW50ZXJ2YWwoKTtcbiAqICAgfVxuICpcbiAqICAgc2V0SW50ZXJ2YWwoKSB7XG4gKiAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAqICAgICAgIHRoaXMudGltZXMrKztcbiAqICAgICB9KTtcbiAqICAgfVxuICpcbiAqICAgYmVmb3JlUmVtb3ZlKCkge1xuICogICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBCbG9jay5ibG9jaygnQXBwJywgQXBwKTtcbiAqIEJsb2NrLmJsb2NrKCdIZWxsbycsIGh0bWxgSGVsbG8sIHthcmdzLnRleHR9IWApO1xuICpcbiAqIGluaXRBcHAoJ0FwcCcsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykpO1xuICovXG5jbGFzcyBCbG9jayB7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPFN0cmluZywgdHlwZW9mIEJsb2NrPn0gQmxvY2suX2Jsb2Nrc1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIHR5cGVvZiBCbG9jaz59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIG5hbWVzcGFjZSBibG9ja3MuXG4gICAqL1xuICBzdGF0aWMgX2Jsb2NrcyA9IGNyZWF0ZShyb290QmxvY2tzKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0LjxTdHJpbmcsIHR5cGVvZiBNaXhpbj59IEJsb2NrLl9taXhpbnNcbiAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCB0eXBlb2YgTWl4aW4+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBuYW1lc3BhY2UgbWl4aW5zLlxuICAgKi9cbiAgc3RhdGljIF9taXhpbnMgPSBjcmVhdGUocm9vdE1peGlucyk7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLmRlZmF1bHRBcmdzID0gbnVsbF1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgZGVmYXVsdCBhcmdzLlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRBcmdzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2suZGVmYXVsdExvY2FscyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRlZmF1bHQgbG9jYWxzLlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRMb2NhbHMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay50ZW1wbGF0ZSA9IHsgdmFyczogW10sIHZhbHVlOiBbXSB9XVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayB0ZW1wbGF0ZS5cbiAgICovXG4gIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICB2YXJzOiBbXSxcbiAgICB2YWx1ZTogW11cbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5vbkV2YWxFcnJvclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RXZhbHVhdGlvbkVycm9yfSBlcnIgLSBUaGUgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGFuIGV2YWx1YXRpb24gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgc3RhdGljIG9uRXZhbEVycm9yKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEV2YWwgZXJyb3IgKGV2YWx1YXRpbmcgXCIkeyBlcnIub3JpZ2luYWwgfHwgZXJyLmZ1bmMgfVwiIGluIGNvbnRleHQgb2YgJHsgZXJyLmJsb2NrLiQkLm5hbWUgfSk6YCwgZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmJlZm9yZVJlZ2lzdGVyQmxvY2tcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jsb2NrUmVnaXN0ZXJIb29rfSBob29rIC0gQmxvY2sgcmVnaXN0ZXIgaG9vay5cbiAgICogQHJldHVybnMge1JlbW92ZUhvb2t9XG4gICAqL1xuICBzdGF0aWMgYmVmb3JlUmVnaXN0ZXJCbG9jayhob29rKSB7XG4gICAgYmxvY2tIb29rcy5wdXNoKGhvb2spO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlbW92ZUFycmF5RWxlbShibG9ja0hvb2tzLCBob29rKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmVmb3JlUmVnaXN0ZXJNaXhpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TWl4aW5SZWdpc3Rlckhvb2t9IGhvb2sgLSBNaXhpbiByZWdpc3RlciBob29rLlxuICAgKiBAcmV0dXJucyB7UmVtb3ZlSG9va31cbiAgICovXG4gIHN0YXRpYyBiZWZvcmVSZWdpc3Rlck1peGluKGhvb2spIHtcbiAgICBtaXhpbkhvb2tzLnB1c2goaG9vayk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlQXJyYXlFbGVtKG1peGluSG9va3MsIGhvb2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5ibG9ja1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgb3IgbWl4aW4gbmFtZS5cbiAgICogQHBhcmFtIHtUZW1wbGF0ZXxTY29wZWxlc3NUZW1wbGF0ZXx0eXBlb2YgQmxvY2t9IFN1YmNsYXNzIC0gU3ViY2xhc3Mgb2YgQmxvY2sgb3IgdGVtcGxhdGUgc3RyaW5nIG9mIGl0LlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEJsb2NrfHVuZGVmaW5lZH0gUmV0dXJucyByZWdpc3RlcmVkIEJsb2NrIG9yIHVuZGVmaW5lZCBpZiB0aGUgYmxvY2sgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogQGRlc2NyaXB0aW9uIFJlZ2lzdGVyIGJsb2NrIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhpcy5cbiAgICovXG4gIHN0YXRpYyBibG9jayhuYW1lLCBTdWJjbGFzcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiAhaXNJbnN0YW5jZU9mKEJsb2NrLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gU3ViY2xhc3M7XG5cbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGNvbnN0cnVjdG9yLnRlbXBsYXRlO1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgICB0aGlzOjpjb25zdHJ1Y3RvcihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU3ViY2xhc3MpICYmIGlzQXJyYXkoU3ViY2xhc3MpKSB7XG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgICBzdGF0aWMgdGVtcGxhdGUgPSB7XG4gICAgICAgICAgdmFyczogW10sXG4gICAgICAgICAgdmFsdWU6IFN1YmNsYXNzXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgU3ViY2xhc3MudmFycyAmJiBTdWJjbGFzcy52YWx1ZSkge1xuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgICAgc3RhdGljIHRlbXBsYXRlID0gU3ViY2xhc3M7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNJbnN0YW5jZU9mKEJsb2NrLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQmxvY2sgbXVzdCBiZSBhIHRlbXBsYXRlIChhcnJheSBvciBhbiBvYmplY3QgZnJvbSBhbiBodG1sIGxvYWRlciksIGEgZnVuY3Rpb24gb3IgYSBjbGFzcyB0aGF0IGV4dGVuZHMgQmxvY2sgY2xhc3MgKG5hbWU6IFwiJHsgbmFtZSB9XCIpIChCbG9jay5ibG9jaylgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyb290QmxvY2tzW25hbWVdKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIGJsb2NrIGlzIGEgYnVpbHQtaW4gYmxvY2sgc28gdGhlIGJsb2NrIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFUQUdfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5hbWUgXCIkeyBuYW1lIH1cIiBpcyBub3QgYWxsb3dlZCBmb3IgYmxvY2tzIHNvIHRoZSBibG9jayB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5ibG9jaylgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ19ibG9ja3MnKSkge1xuICAgICAgdGhpcy5fYmxvY2tzID0gY3JlYXRlKGdldFByb3RvKHRoaXMpLl9ibG9ja3MpO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ2RlZmF1bHRMb2NhbHMnKSkge1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEFyZ3MnKSkge1xuICAgICAgdGhpcy5kZWZhdWx0QXJncyA9IGNyZWF0ZShudWxsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgU3ViY2xhc3MgPSBibG9ja0hvb2tzLnJlZHVjZSgocmV0dXJuVmFsdWUsIGhvb2spID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJldHVyblZhbHVlID0gaG9vayhyZXR1cm5WYWx1ZSwgbmFtZSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZihCbG9jaywgY3VycmVudFJldHVyblZhbHVlKVxuICAgICAgICAgID8gY3VycmVudFJldHVyblZhbHVlXG4gICAgICAgICAgOiByZXR1cm5WYWx1ZTtcbiAgICAgIH0sIFN1YmNsYXNzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuY2F1Z2h0IGVycm9yIGluIFwiYmVmb3JlUmVnaXN0ZXJCbG9ja1wiIGhvb2s6JywgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShTdWJjbGFzcy50ZW1wbGF0ZSkpIHtcbiAgICAgIFN1YmNsYXNzLnRlbXBsYXRlID0ge1xuICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgdmFsdWU6IFN1YmNsYXNzLnRlbXBsYXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIFN1YmNsYXNzLl9ibG9ja3MgPSBoYXNPd25Qcm9wZXJ0eShTdWJjbGFzcywgJ19ibG9ja3MnKVxuICAgICAgPyBTdWJjbGFzcy5fYmxvY2tzXG4gICAgICA6IGNyZWF0ZSh0aGlzLl9ibG9ja3MpO1xuICAgIFN1YmNsYXNzLl9taXhpbnMgPSBoYXNPd25Qcm9wZXJ0eShTdWJjbGFzcywgJ19taXhpbnMnKVxuICAgICAgPyBTdWJjbGFzcy5fbWl4aW5zXG4gICAgICA6IGNyZWF0ZSh0aGlzLl9taXhpbnMpO1xuXG4gICAgaWYgKGhhc093blByb3BlcnR5KFN1YmNsYXNzLCAnZGVmYXVsdEFyZ3MnKSkge1xuICAgICAgc2V0UHJvdG8oU3ViY2xhc3MuZGVmYXVsdEFyZ3MsIG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMuX2Jsb2Nrc1tuYW1lXSA9IFN1YmNsYXNzO1xuXG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suZ2V0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBuYW1lLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEJsb2NrfHVuZGVmaW5lZH0gUmV0dXJucyByZWdpc3RlcmVkIEJsb2NrIHdpdGggc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suZ2V0TWl4aW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE1peGluIG5hbWUuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgTWl4aW58dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgTWl4aW4gd2l0aCBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXRNaXhpbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peGluc1tuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLm1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge3R5cGVvZiBNaXhpbnxBZnRlclVwZGF0ZX0gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBNaXhpbiBvciBBZnRlclVwZGF0ZSBjYWxsYmFjay5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbnx1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBCbG9jayBvciB1bmRlZmluZWQgaWYgdGhlIGJsb2NrIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBtaXhpbiBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgbWl4aW4obmFtZSwgU3ViY2xhc3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgIWlzSW5zdGFuY2VPZihNaXhpbiwgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zdCBhZnRlclVwZGF0ZSA9IFN1YmNsYXNzO1xuXG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICAgICAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICB0aGlzOjphZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNJbnN0YW5jZU9mKE1peGluLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgY2xhc3MgZG9lcyBub3QgZXh0ZW5kIE1peGluIG9yIGlzIG5vdCBhbiBhZnRlclVwZGF0ZSBmdW5jdGlvbiwgc28gaXQgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocm9vdE1peGluc1tuYW1lXSB8fCBuYW1lID09PSAnZC1yZXN0Jykge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBtaXhpbiBpcyBhIGJ1aWx0LWluIG1peGluIHNvIHRoZSBtaXhpbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghQVRUUl9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTmFtZSBcIiR7IG5hbWUgfVwiIGlzIG5vdCBhbGxvd2VkIGZvciBtaXhpbnMgc28gdGhlIG1peGluIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLm1peGluKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnX21peGlucycpKSB7XG4gICAgICB0aGlzLl9taXhpbnMgPSBjcmVhdGUoZ2V0UHJvdG8odGhpcykuX21peGlucyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIFN1YmNsYXNzID0gbWl4aW5Ib29rcy5yZWR1Y2UoKHJldHVyblZhbHVlLCBob29rKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZXR1cm5WYWx1ZSA9IGhvb2socmV0dXJuVmFsdWUsIG5hbWUsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBpc0luc3RhbmNlT2YoTWl4aW4sIGN1cnJlbnRSZXR1cm5WYWx1ZSlcbiAgICAgICAgICA/IGN1cnJlbnRSZXR1cm5WYWx1ZVxuICAgICAgICAgIDogcmV0dXJuVmFsdWU7XG4gICAgICB9LCBTdWJjbGFzcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmNhdWdodCBlcnJvciBpbiBcImJlZm9yZVJlZ2lzdGVyTWl4aW5cIiBob29rOicsIGVycik7XG4gICAgfVxuXG4gICAgU3ViY2xhc3MuX21hdGNoID0gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKTtcblxuICAgIHRoaXMuX21peGluc1tuYW1lXSA9IFN1YmNsYXNzO1xuXG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBibG9jay5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IGJsb2NrLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBibG9ja3MgaW50byBhbm90aGVyIGJsb2Nrcy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIGJsb2NrIHdpdGggYSBuZXcgb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2PjEyMzwvZGl2Pic7XG4gICAqIH1cbiAgICpcbiAgICogTXlCbG9jay53cmFwKChCbG9jaykgPT4ge1xuICAgKiAgIHJldHVybiBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICogICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGA8c2VjdGlvbiBjbGFzcz1cIndyYXBwZXJcIj4keyBCbG9jay50ZW1wbGF0ZSB9PC9zZWN0aW9uPmA7XG4gICAqXG4gICAqICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAqICAgICAgIHN1cGVyKG9wdHMpO1xuICAgKlxuICAgKiAgICAgICB0aGlzLmFkZGl0aW9uYWxWYXIgPSAnYWRkaXRpb25hbCc7XG4gICAqICAgICB9XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqL1xuICBzdGF0aWMgd3JhcCguLi53cmFwcGVycykge1xuICAgIHJldHVybiB3cmFwcGVycy5yZWR1Y2Uod3JhcEJsb2NrLCB0aGlzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYXJnczogb3JpZ2luYWxBcmdzLFxuICAgICAgZEJsb2NrTmFtZSxcbiAgICAgIGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBwcmV2QmxvY2tcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvciB9ID0gZ2V0UHJvdG8odGhpcyk7XG4gICAgY29uc3QgY2hpbGRyZW5CbG9ja3MgPSBbXTtcbiAgICBjb25zdCBtaXhpbnMgPSBbXTtcbiAgICBjb25zdCBpc1BhcmVudEJsb2NrID0gcGFyZW50IGluc3RhbmNlb2YgQmxvY2s7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayMkJFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBCbG9jayMkJC5hcmdzIC0gUHJpdmF0ZSBhcmdzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja1tdfSBCbG9jayMkJC5jaGlsZHJlbiAtIENoaWxkIGJsb2Nrcy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gQmxvY2sjJCQuY29udGVudCAtIENvbnRlbnQgZWxlbWVudHMuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdHx2b2lkfSBCbG9jayMkJC5kQmxvY2tBcmdzIC0gZC1ibG9jayBhcmdzLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd8dm9pZH0gQmxvY2sjJCQuZEJsb2NrTmFtZSAtIGQtYmxvY2sgbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2tbXX0gQmxvY2sjJCQuZEJsb2NrcyAtIGQtYmxvY2sncyB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gQmxvY2sjJCQuZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBCbG9jayMkJC5nbG9iYWxzIC0gUHJpdmF0ZSBnbG9iYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gQmxvY2sjJCQuaHRtbENoaWxkcmVuIC0gQmxvY2sgaHRtbCBjaGlsZHJlbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gQmxvY2sjJCQuaXNSZW1vdmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbW92ZWQuXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IEJsb2NrIyQkLmlzUmVuZGVyZWQgLSBJZiB0aGUgYmxvY2sgaXMgcmVuZGVyZWQuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQubG9jYWxzIC0gUHJpdmF0ZSBsb2NhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge01peGluW119IEJsb2NrIyQkLm1peGlucyAtIENoaWxkIG1peGlucy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gQmxvY2sjJCQubWl4aW5zVG9CdWlsZCAtIFBlbmRpbmcgbWl4aW5zIGJ1aWxkZXJzLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IEJsb2NrIyQkLm5hbWUgLSBCbG9jayBuYW1lLlxuICAgICAgICogQHByb3BlcnR5IHt0eXBlb2YgQmxvY2t9IEJsb2NrIyQkLm5zIC0gQmxvY2sgY29uc3RydWN0b3IuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfEVsZW18dm9pZH0gQmxvY2sjJCQucGFyZW50IC0gUGFyZW50IGJsb2NrIG9yIGVsZW0uXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudEJsb2NrIC0gUGFyZW50IGJsb2NrLlxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBwYXJlbnRFbGVtIC0gUGFyZW50IGVsZW1lbnQuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudFNjb3BlIC0gUGFyZW50IHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBCbG9jayMkJC5wYXJlbnRUZW1wbGF0ZSAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8RWxlbXx2b2lkfSBCbG9jayMkJC5wcmV2QmxvY2sgLSBQYXJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcHJvcGVydHkge1dhdGNoZXJbXX0gQmxvY2sjJCQud2F0Y2hlcnMgLSBUZW1wb3JhcnkgdmFycyB3YXRjaGVycy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IEJsb2NrIyQkLndhdGNoZXJzVG9SZW1vdmUgLSBXYXRjaGVycyB0byByZW1vdmUgYmVmb3JlIHJlbW92aW5nIHRoZSBibG9jay5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrQXJncyxcbiAgICAgICAgZEJsb2NrczogW10sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgY29udGVudDogbmV3IEVsZW0oKSxcbiAgICAgICAgbnM6IGNvbnN0cnVjdG9yLFxuICAgICAgICBodG1sQ2hpbGRyZW46IGNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5CbG9ja3MsXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgbWl4aW5zVG9CdWlsZDogW10sXG4gICAgICAgIHByZXZCbG9jayxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgaXNSZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGV2YWx1YXRlOiAoZnVuYywgb25DaGFuZ2UsIHRhcmdldEJsb2NrLCBmb3JERWxlbWVudHMsIGZvckRJdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JERWxlbWVudHMgPSAhIWZvckRFbGVtZW50cztcbiAgICAgICAgICBmb3JESXRlbSA9ICEhZm9yREl0ZW07XG5cbiAgICAgICAgICBjb25zdCBzY29wZSA9IG5hbWUgPT09ICcjZC1pdGVtJyAmJiAhZm9yREl0ZW1cbiAgICAgICAgICAgID8gdGhpcy4kJC5zY29wZVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgd2F0Y2hlcnNUb1JlbW92ZSB9ID0gdGFyZ2V0QmxvY2sgPyB0YXJnZXRCbG9jay4kJCA6IGVtcHR5T2JqZWN0O1xuICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlRmxhZyA9ICEhb25DaGFuZ2U7XG5cbiAgICAgICAgICBjb25zdCBldmFsdWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChvbkNoYW5nZUZsYWcpIHtcbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBnZXR0aW5nVmFycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHNjb3BlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBlcnIuZnVuYyA9IGZ1bmM7XG4gICAgICAgICAgICAgIGVyci5vcmlnaW5hbCA9IGZ1bmMub3JpZ2luYWw7XG4gICAgICAgICAgICAgIGVyci5ibG9jayA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29uc3RydWN0b3Iub25FdmFsRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9Lm9uRXZhbEVycm9yOmAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2VGbGFnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2F0Y2hlcnMgPSBbXTtcblxuICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkoZ2V0dGluZ1ZhcnMsICh3YXRjaGVycykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhdGNoZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkobG9jYWxXYXRjaGVycywgKHdhdGNoZXJCbG9jaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICB9ID0gd2F0Y2hlckJsb2NrO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVyc1RvUmVtb3ZlLCB3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc3VsdCA9IGV2YWx1YXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHQgIT09IHJlc3VsdCAmJiAhdGFyZ2V0QmxvY2suJCQuaXNSZW1vdmVkICYmICF0aGlzLiQkLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdSZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICBmb3JERWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbG9jYWxXYXRjaGVycy5wdXNoKHdhdGNoZXJCbG9jayk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZS5wdXNoKHdhdGNoZXJCbG9jayk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZ2V0dGluZ1ZhcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKGlzUGFyZW50U2lnbmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICBpdGVyYXRlQXJyYXkoY2hpbGRyZW5CbG9ja3MsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlUmVtb3ZlOmAsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgcGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5jaGlsZHJlbiwgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jb250ZW50LnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjaGFuZ2VDb250ZW50OiAobmV3Q29udGVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuY29udGVudCA9IG5ld0NvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodGhpcy4kJC5pc1JlbmRlcmVkICYmICF0aGlzLiQkLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5hZnRlckRPTUNoYW5nZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckRPTUNoYW5nZTpgLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29udGVudDogKGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkQ29udGVudCA9IHRoaXMuJCQuY29udGVudDtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9sZENvbnRlbnQuaW5kZXhPZihjb250ZW50VG9BZGRbMF0ucHJldmlvdXNTaWJsaW5nKSArIDE7XG4gICAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50VG9BZGQuYWRkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoY29udGVudFRvQWRkLCBvbGRDb250ZW50LnNsaWNlKGluZGV4KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KG5ld0NvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgIW5vdFJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvQWRkLCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZUNvbnRlbnQ6IChjb250ZW50VG9Nb3ZlLCBhZnRlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvbGRDb250ZW50LmluZGV4T2YoY29udGVudFRvTW92ZVswXSk7XG4gICAgICAgICAgY29uc3QgaW5kZXhUb1B1dCA9IG9sZENvbnRlbnQuaW5kZXhPZihhZnRlclswXSkgKyAxO1xuICAgICAgICAgIGxldCBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKGluZGV4VG9QdXQgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50VG9Nb3ZlLmFkZChcbiAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGluZGV4VG9QdXQpIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBvbGRDb250ZW50XG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleFRvUHV0KVxuICAgICAgICAgICAgICAuYWRkKFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUb01vdmUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoLCBpbmRleFRvUHV0KSxcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQobmV3Q29udGVudCk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiBpbmRleFRvUHV0KSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvTW92ZSwgYWZ0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ29udGVudDogKGNvbnRlbnRUb1JlbW92ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQuZmlsdGVyKChlbGVtKSA9PiAoXG4gICAgICAgICAgICBjb250ZW50VG9SZW1vdmUuaW5kZXhPZihlbGVtKSA9PT0gLTFcbiAgICAgICAgICApKSk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQoY29udGVudFRvUmVtb3ZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEluU3RhcnRPZkl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcblxuICAgICAgICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcblxuICAgICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSBwYXJlbnQuJCQ7XG5cbiAgICAgICAgICAgIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgICAgbGV0IG5vdFJlY3Vyc2l2ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICAgICAgbm90UmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgdGhpcy4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRBZnRlckl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcbiAgICAgICAgICBsZXQgdHJ5VG9BZGRPck1vdmU7XG5cbiAgICAgICAgICBpZiAodGhpcy4kJC5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLiQkLmNvbnRlbnQuZWxlbSgtMSk7XG4gICAgICAgICAgICB0cnlUb0FkZE9yTW92ZSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIoYWZ0ZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmIHRyeVRvQWRkT3JNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0ZXJhdGVPYmplY3QoY29uc3RydWN0b3IuZGVmYXVsdExvY2FscywgKHZhbHVlLCB2YXJpYWJsZSkgPT4ge1xuICAgICAgdGhpc1t2YXJpYWJsZV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBpdGVyYXRlQXJyYXkoY29uc3RydWN0b3IudGVtcGxhdGUudmFycywgKHZhcmlhYmxlKSA9PiB7XG4gICAgICB0aGlzW3ZhcmlhYmxlXSA9IHRoaXNbdmFyaWFibGVdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJnc09iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB7IGRlZmF1bHRBcmdzIH0gPSBjb25zdHJ1Y3RvcjtcbiAgICBsZXQgYXJncyA9IGNyZWF0ZShkZWZhdWx0QXJncyB8fCBudWxsKTtcbiAgICBsZXQgd2FzRFJlc3Q7XG4gICAgY29uc3QgYXJnc0NoYWluID0gW107XG5cbiAgICBpZiAoZGVmYXVsdEFyZ3MpIHtcbiAgICAgIGFyZ3NDaGFpbi5wdXNoKGRlZmF1bHRBcmdzKTtcbiAgICB9XG5cbiAgICBhcmdzQ2hhaW4ucHVzaChhcmdzKTtcblxuICAgIGl0ZXJhdGVPYmplY3Qob3JpZ2luYWxBcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgY29uc3QgaXNEUmVzdCA9IERfUkVTVF9SRUdFWC50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBsb2NhbEFyZ3MgPSBpc0RSZXN0IHx8IHdhc0RSZXN0XG4gICAgICAgID8gY3JlYXRlKGFyZ3MpXG4gICAgICAgIDogYXJncztcblxuICAgICAgaWYgKGFyZ3MgIT09IGxvY2FsQXJncykge1xuICAgICAgICBhcmdzQ2hhaW4ucHVzaChsb2NhbEFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gbG9jYWxBcmdzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXJncyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXJncywgY2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgYXNzaWduKGxvY2FsQXJncywgdHJhbnNmb3JtUmVzdEFyZ3ModmFsdWUpKTtcbiAgICAgICAgICBjYWxjdWxhdGVBcmdzKG5vcm1hbGl6ZUFyZ3MoYXJnc0NoYWluKSwgYXJnc09iamVjdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXJncywgdHJhbnNmb3JtUmVzdEFyZ3MocmVzdEFyZ3MpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNERWxlbWVudHMgPSBuYW1lID09PSAnZC1lbGVtZW50cyc7XG4gICAgICBjb25zdCBmb3JERWxlbWVudHMgPSBpc0RFbGVtZW50cyAmJiBhcmcgPT09ICd2YWx1ZSc7XG5cbiAgICAgIHdhc0RSZXN0ID0gZmFsc2U7XG5cbiAgICAgIGxvY2FsQXJnc1thcmddID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICBsb2NhbEFyZ3NbYXJnXSA9IHZhbHVlO1xuICAgICAgICBjYWxjdWxhdGVBcmdzKG5vcm1hbGl6ZUFyZ3MoYXJnc0NoYWluKSwgYXJnc09iamVjdCk7XG4gICAgICB9LCB0aGlzLCBmb3JERWxlbWVudHMsIGlzREVsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLm5hbWUgPT09ICcjZC1pdGVtJyk7XG4gICAgfSk7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNhcmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhcmdzOiBhcmdzT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjZ2xvYmFsc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZ2xvYmFsczogY3JlYXRlKFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgICAgID8gcGFyZW50U2NvcGUuZ2xvYmFsc1xuICAgICAgICAgIDogbnVsbFxuICAgICAgKVxuICAgIH0pO1xuXG4gICAgY2FsY3VsYXRlQXJncyhub3JtYWxpemVBcmdzKGFyZ3NDaGFpbiksIGFyZ3NPYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudEJsb2NrKSB7XG4gICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyQ29uc3RydWN0XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBjb25zdHJ1Y3Rpb24gKGluY2x1ZGluZyBhbGwgc2NvcGVzKVxuICAgKiBidXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgYmxvY2sgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIGFmdGVyQ29uc3RydWN0KCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlckRPTUNoYW5nZVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgRE9NIHN0cnVjdHVyZSBoYXMgY2hhbmdlZC4gTm90ZSB0aGF0XG4gICAqIGl0J3MgaW1wb3J0YW50IG5vdCB0byBtb2RpZnkgdGhlIERPTSBzdHJ1Y3R1cmUgd2l0aGluIHRoZSBibG9jay4gWW91IGNhbiBvbmx5IGluc2VydFxuICAgKiBlbGVtZW50cyB0byBlbXB0eSBlbGVtZW50cyAod2hpY2ggRHdheW5lIGNvbnNpZGVycyBlbXB0eSkgYW5kIHJlbW92ZSBvbmVzIGZyb20gdGhlbS5cbiAgICovXG4gIGFmdGVyRE9NQ2hhbmdlKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlclJlbmRlclxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAqL1xuICBhZnRlclJlbmRlcigpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYmVmb3JlUmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBiZWZvcmUgdGhlIGJsb2NrIHJlbW92YWwuXG4gICAqL1xuICBiZWZvcmVSZW1vdmUoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldERPTVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBET00gY29udGVudHMgb2YgdGhlIGJsb2NrLlxuICAgKi9cbiAgZ2V0RE9NKCkge1xuICAgIHJldHVybiB0aGlzLiQkLmNvbnRlbnQuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldE5hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBCbG9jayBuYW1lLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50RWxlbVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfHZvaWR9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHBhcmVudCBFbGVtLlxuICAgKi9cbiAgZ2V0UGFyZW50RWxlbSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRFbGVtLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRTY29wZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBibG9jayBpbiB3aGljaCB0ZW1wbGF0ZSB0aGUgYmxvY2sgaXMgbG9jYXRlZCBpbi5cbiAgICovXG4gIGdldFBhcmVudFNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudFNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50VGVtcGxhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QmxvY2t8dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYmxvY2sgaW4gd2hpY2ggdGVtcGxhdGUgdGhlIGJsb2NrIGlzIGxvY2F0ZWQgaW4uXG4gICAqL1xuICBnZXRQYXJlbnRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IFtjYWxsYmFja10gLSBJZiBwcmVzZW50LCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge0Jsb2NrfE1peGlufSBbdGFyZ2V0ID0gdGhpc10gLSBXaGF0IGJsb2NrIG9yIG1peGluIHJlcXVlc3RzIHRoZSB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gaW4gY29udGV4dCBvZiB0aGUgYmxvY2sgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGZ1bmMsIGNhbGxiYWNrLCB0YXJnZXQgPSB0aGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWc7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoQmxvY2ssICdCbG9jaycpO1xuc2V0UHJvdG8oQmxvY2sucHJvdG90eXBlLCBudWxsKTtcblxuZXhwb3J0IHsgQmxvY2ssIGdldHRpbmdWYXJzLCBldmFsTW9kZSB9O1xuIiwiaW1wb3J0IHsgZmluZEluQXJyYXksIGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB3YXRjaE5hbWVBcmdzID0ganNgYXJncy5uYW1lYDtcbmNvbnN0IHdhdGNoQ29uc3RydWN0b3JBcmdzID0ganNgYXJncy5Db25zdHJ1Y3RvcmA7XG5cbmNsYXNzIERCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICA8ZC1lbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwie1BhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cIntQYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3Qob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjb3BlOiB7XG4gICAgICAgICQkOiB7XG4gICAgICAgICAgcGFyZW50U2NvcGU6IHBhcmVudFBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlOiBwYXJlbnRQYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBodG1sQ2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBodG1sQ2hpbGRyZW46IG93bkNoaWxkcmVuLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGRCbG9ja05hbWU6IERCbG9ja05hbWVcbiAgICB9ID0gdGhpcy4kJDtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgQ29uc3RydWN0b3JcbiAgICB9ID0gdGhpcy5hcmdzO1xuICAgIGxldCBmb3VuZDtcblxuICAgIHRoaXMuUGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgICB0aGlzLlBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3REeW5hbWljTmFtZUJsb2NrKFxuICAgICAgICB0aGlzLmV2YWx1YXRlKHdhdGNoTmFtZUFyZ3MsIHRoaXMuY29uc3RydWN0RHluYW1pY05hbWVCbG9jaylcbiAgICAgICk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0RHluYW1pY0NvbnN0cnVjdG9yQmxvY2soXG4gICAgICAgIHRoaXMuZXZhbHVhdGUod2F0Y2hDb25zdHJ1Y3RvckFyZ3MsIHRoaXMuY29uc3RydWN0RHluYW1pY0NvbnN0cnVjdG9yQmxvY2spXG4gICAgICApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG93bkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcGFyZW50VGVtcGxhdGUuJCQuZEJsb2Nrcy5wdXNoKHRoaXMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudFBhcmVudFNjb3BlO1xuICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRQYXJlbnRUZW1wbGF0ZTtcblxuICAgIGlmIChEQmxvY2tOYW1lKSB7XG4gICAgICBmb3VuZCA9IGZpbmRJbkFycmF5KGNoaWxkcmVuLCAoeyBuYW1lOiBub2RlTmFtZSB9KSA9PiBub2RlTmFtZSA9PT0gYGQtYmxvY2s6JHsgREJsb2NrTmFtZSB9YCk7XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgZm91bmQgPSBmaW5kSW5BcnJheShwYXJlbnRUZW1wbGF0ZS4kJC5kQmxvY2tzLCAoeyAkJDogeyBkQmxvY2tOYW1lIH0gfSkgPT4gZEJsb2NrTmFtZSA9PT0gREJsb2NrTmFtZSk7XG5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgICAgICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgICAgICBmb3VuZC52YWx1ZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBmb3VuZC52YWx1ZS4kJC5odG1sQ2hpbGRyZW5cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZFxuICAgICAgICA/IGZvdW5kLnZhbHVlLmNoaWxkcmVuXG4gICAgICAgIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdER5bmFtaWNOYW1lQmxvY2sgPSAobmFtZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIGRCbG9ja0FyZ3NcbiAgICB9ID0gdGhpcy4kJDtcblxuICAgIHRoaXMuZWxlbXMgPSBbe1xuICAgICAgbmFtZSxcbiAgICAgIGF0dHJzOiBkQmxvY2tBcmdzLFxuICAgICAgY2hpbGRyZW46IGh0bWxDaGlsZHJlblxuICAgIH1dO1xuICB9O1xuXG4gIGNvbnN0cnVjdER5bmFtaWNDb25zdHJ1Y3RvckJsb2NrID0gKENvbnN0cnVjdG9yKSA9PiB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBodG1sQ2hpbGRyZW4sXG4gICAgICBkQmxvY2tBcmdzXG4gICAgfSA9IHRoaXMuJCQ7XG5cbiAgICB0aGlzLmVsZW1zID0gW3tcbiAgICAgIENvbnN0cnVjdG9yLFxuICAgICAgYXR0cnM6IGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbjogaHRtbENoaWxkcmVuXG4gICAgfV07XG4gIH07XG59XG5cbnJvb3RCbG9ja3NbJ2QtYmxvY2snXSA9IERCbG9jaztcblxuZXhwb3J0IHsgREJsb2NrIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcblxuY29uc3QgdGVtcGxhdGUgPSBodG1sYFxuICA8ZC1lbGVtZW50c1xuICAgIHZhbHVlPVwieyQkLmh0bWxDaGlsZHJlbn1cIlxuICAgIHBhcmVudFNjb3BlPVwie3RoaXN9XCJcbiAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAvPlxuYDtcblxuY2xhc3MgREl0ZW0gZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyB0ZW1wbGF0ZSA9IHRlbXBsYXRlO1xufVxuXG5leHBvcnQgeyBESXRlbSB9O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLCBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzQXJyYXksIGlzRnVuY3Rpb25cbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlLCBjcmVhdGVCbG9jayB9IGZyb20gJy4uL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IERJdGVtIH0gZnJvbSAnLi9kLWl0ZW0nO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BbXG4gIGFyZ3Muc2V0LFxuICBhcmdzLmZpbHRlckJ5LFxuICBhcmdzLnNvcnRCeVxuXWA7XG5cbnJvb3RCbG9ja3NbJ2QtZWFjaCddID0gY2xhc3MgREVhY2ggZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyBkZWZhdWx0QXJncyA9IHtcbiAgICB1aWQoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJnczoge1xuICAgICAgICBpdGVtOiBpdGVtTmFtZSA9ICckaXRlbScsXG4gICAgICAgIGluZGV4OiBpbmRleE5hbWUgPSAnJGluZGV4J1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuXG4gICAgYXNzaWduKHRoaXMuJCQsIHtcbiAgICAgIGl0ZW1zQnlVSURzOiB7fSxcbiAgICAgIGl0ZW1OYW1lLFxuICAgICAgaW5kZXhOYW1lXG4gICAgfSk7XG4gIH1cblxuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgdGhpcy5yZW5kZXJTZXQpO1xuICAgIHRoaXMucmVuZGVyU2V0KCk7XG4gIH1cblxuICByZW5kZXJTZXQgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgaXRlbXNCeVVJRHMsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGl0ZW1OYW1lLFxuICAgICAgaW5kZXhOYW1lXG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczoge1xuICAgICAgICBzb3J0QnksXG4gICAgICAgIHVpZDogVUlEXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3SXRlbXNCeVVJRHMgPSB7fTtcbiAgICBjb25zdCBuZXdVSURzQ291bnRlciA9IHt9O1xuICAgIGNvbnN0IG5ld1VJRHMgPSB7fTtcbiAgICBsZXQge1xuICAgICAgc2V0LFxuICAgICAgZmlsdGVyQnlcbiAgICB9ID0gdGhpcy5hcmdzO1xuICAgIGNvbnN0IGlzQXJyID0gaXNBcnJheShzZXQpO1xuICAgIGNvbnN0IGl0ZXJhdGUgPSBpc0FyclxuICAgICAgPyBpdGVyYXRlQXJyYXlcbiAgICAgIDogaXRlcmF0ZU9iamVjdDtcblxuICAgIGlmIChpc0FyciAmJiBpc0Z1bmN0aW9uKHNvcnRCeSkpIHtcbiAgICAgIHNldCA9IHNldFxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydChzb3J0QnkpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGZpbHRlckJ5KSkge1xuICAgICAgZmlsdGVyQnkgPSBbZmlsdGVyQnldO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGZpbHRlckJ5KSkge1xuICAgICAgaXRlcmF0ZUFycmF5KGZpbHRlckJ5LCAoZmlsdGVyKSA9PiB7XG4gICAgICAgIHNldCA9IHNldC5maWx0ZXIoZmlsdGVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGl0ZXJhdGUoc2V0LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHVpZCA9IFVJRChpdGVtLCBpbmRleCwgc2V0LCBwYXJlbnRTY29wZSk7XG5cbiAgICAgIG5ld1VJRHNDb3VudGVyW3VpZF0gPSAobmV3VUlEc0NvdW50ZXJbdWlkXSB8fCAwKSArIDE7XG4gICAgICBuZXdVSURzW2luZGV4XSA9IHVpZDtcbiAgICB9KTtcblxuICAgIGl0ZXJhdGVPYmplY3QoaXRlbXNCeVVJRHMsIChpdGVtcywgdWlkKSA9PiB7XG4gICAgICBpZiAoIW5ld1VJRHNDb3VudGVyW3VpZF0pIHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGl0ZW1zLCByZW1vdmUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGl0ZW1zLnNwbGljZShuZXdVSURzQ291bnRlclt1aWRdKSwgcmVtb3ZlKTtcbiAgICB9KTtcblxuICAgIGxldCBwcmV2QmxvY2s7XG5cbiAgICBpdGVyYXRlKHNldCwgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB1aWQgPSBuZXdVSURzW2luZGV4XTtcbiAgICAgIGxldCBibG9jaztcblxuICAgICAgaWYgKGl0ZW1zQnlVSURzW3VpZF0gJiYgaXRlbXNCeVVJRHNbdWlkXS5sZW5ndGgpIHtcbiAgICAgICAgYmxvY2sgPSBpdGVtc0J5VUlEc1t1aWRdLnNoaWZ0KCk7XG4gICAgICAgIGJsb2NrLiQkLnNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcbiAgICAgICAgYmxvY2suJCQuc2NvcGVbaXRlbU5hbWVdID0gaXRlbTtcblxuICAgICAgICBpZiAoYmxvY2suJCQucHJldkJsb2NrICE9PSBwcmV2QmxvY2spIHtcbiAgICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IGJsb2NrLiQkO1xuXG4gICAgICAgICAgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICBpdGVtTmFtZSxcbiAgICAgICAgICAgIGluZGV4TmFtZSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIG5hbWU6ICcjZC1pdGVtJyxcbiAgICAgICAgICAgIENvbnN0cnVjdG9yOiBESXRlbSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBodG1sQ2hpbGRyZW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgKG5ld0l0ZW1zQnlVSURzW3VpZF0gPSBuZXdJdGVtc0J5VUlEc1t1aWRdIHx8IFtdKS5wdXNoKGJsb2NrKTtcbiAgICAgIGJsb2NrLiQkLnByZXZCbG9jayA9IHByZXZCbG9jaztcbiAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kJC5pdGVtc0J5VUlEcyA9IG5ld0l0ZW1zQnlVSURzO1xuICB9O1xufTtcbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgcmVtb3ZlQXJyYXlFbGVtIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCwgY3JlYXRlQmxvY2sgfSBmcm9tICcuLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MudmFsdWVgO1xuXG5yb290QmxvY2tzWydkLWVsZW1lbnRzJ10gPSBjbGFzcyBERWxlbWVudHMgZXh0ZW5kcyBCbG9jayB7XG4gIGFmdGVyQ29uc3RydWN0KCkge1xuICAgIGNvbnN0IHsgcGFyZW50RWxlbSB9ID0gdGhpcy4kJDtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfSA9IHRoaXMuYXJncztcblxuICAgIHRoaXMuJCQuZXZhbHVhdGUod2F0Y2hBcmdzLCAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBjb250ZW50XG4gICAgICB9ID0gdGhpcy4kJDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuICAgICAgY29udGVudC5yZW1vdmUoKTtcblxuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiQkLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLiQkLm1peGlucyA9IFtdO1xuICAgICAgdGhpcy4kJC53YXRjaGVyc1RvUmVtb3ZlID0gd2F0Y2hlcnNUb1JlbW92ZS5maWx0ZXIoKHsgd2F0Y2hlcnMsIHdhdGNoZXIsIGZvckRFbGVtZW50cyB9KSA9PiB7XG4gICAgICAgIGlmIChmb3JERWxlbWVudHMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVycywgd2F0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJCQuY29udGVudCA9IG5ldyBFbGVtKCk7XG5cbiAgICAgIGxldCBwcmV2QmxvY2s7XG5cbiAgICAgIGl0ZXJhdGVBcnJheSh2YWx1ZSB8fCBbXSwgKGNoaWxkKSA9PiB7XG4gICAgICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVBcnJheSh0aGlzLiQkLm1peGluc1RvQnVpbGQsIChleGVjdXRlQnVpbGRlcnMpID0+IHtcbiAgICAgICAgZXhlY3V0ZUJ1aWxkZXJzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJCQubWl4aW5zVG9CdWlsZCA9IFtdO1xuICAgIH0sIHRoaXMsIHRydWUpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgYXJncy5pZmA7XG5cbnJvb3RCbG9ja3NbJ2QtaWYnXSA9IGNsYXNzIERJZiBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICA8ZC1lbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5jb25kaXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0cnVjdEVsZW1zKHRoaXMuZXZhbHVhdGUod2F0Y2hBcmdzLCB0aGlzLmNvbnN0cnVjdEVsZW1zKSk7XG4gIH1cblxuICBjb25zdHJ1Y3RFbGVtcyA9IChjb25kaXRpb24pID0+IHtcbiAgICBjb25kaXRpb24gPSAhIWNvbmRpdGlvbjtcblxuICAgIGlmICh0aGlzLmNvbmRpdGlvbiAhPT0gY29uZGl0aW9uKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIHRoaXMuZWxlbXMgPSBjb25kaXRpb25cbiAgICAgICAgPyB0aGlzLiQkLmh0bWxDaGlsZHJlblxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCB7IGZpbmRJbkFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgW1xuICBhcmdzLnZhbHVlLFxuICBhcmdzLmNvbXBhcmVGblxuXWA7XG5cbnJvb3RCbG9ja3NbJ2Qtc3dpdGNoJ10gPSBjbGFzcyBEU3dpdGNoIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7JCQucGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcbiAgc3RhdGljIGRlZmF1bHRBcmdzID0ge1xuICAgIGNvbXBhcmVGbihzd2l0Y2hWYWx1ZSwgY2FzZVZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzd2l0Y2hWYWx1ZSA9PT0gY2FzZVZhbHVlXG4gICAgICAgIHx8IChzd2l0Y2hWYWx1ZSAhPT0gc3dpdGNoVmFsdWUgJiYgY2FzZVZhbHVlICE9PSBjYXNlVmFsdWUpXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBpbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICQkOiB7XG4gICAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgICAgcGFyZW50U2NvcGVcbiAgICAgIH0sXG4gICAgICBhcmdzLFxuICAgICAgYXJnczogeyB2YWx1ZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHdhc0RlZmF1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMudmFsdWVzID0gaHRtbENoaWxkcmVuXG4gICAgICAuZmlsdGVyKCh7IG5hbWUgfSkgPT4ge1xuICAgICAgICBpZiAobmFtZSAhPT0gJ2QtY2FzZScgJiYgbmFtZSAhPT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FzRGVmYXVsdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSAnZC1kZWZhdWx0Jykge1xuICAgICAgICAgIHdhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICAgLm1hcCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cnMgPSB7fSxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9ID0gY2hpbGQ7XG4gICAgICAgIGxldCB2YWw7XG5cbiAgICAgICAgaWYgKG5hbWUgIT09ICdkLWRlZmF1bHQnKSB7XG4gICAgICAgICAgdmFsID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoYXR0cnMuaWYsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNbaV0udmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGkgPiB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSBmaW5kSW5BcnJheSh0aGlzLnZhbHVlcywgKHsgbmFtZSwgdmFsdWUgfSkgPT4gKFxuICAgICAgICAgICAgICBuYW1lID09PSAnZC1kZWZhdWx0J1xuICAgICAgICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKGFyZ3MudmFsdWUsIHZhbHVlKVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZFxuICAgICAgICAgICAgICA/IGZvdW5kLmtleVxuICAgICAgICAgICAgICA6IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kXG4gICAgICAgICAgICAgID8gZm91bmQudmFsdWUuY2hpbGRyZW5cbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5ICYmIChcbiAgICAgICAgICBuYW1lID09PSAnZC1kZWZhdWx0J1xuICAgICAgICAgIHx8IHRoaXMuYXJncy5jb21wYXJlRm4odmFsdWUsIHZhbClcbiAgICAgICAgKSkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgfVxuXG4gIGFmdGVyQ29uc3RydWN0KCkge1xuICAgIHRoaXMuZXZhbHVhdGUod2F0Y2hBcmdzLCAoYXJncykgPT4ge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBhcmdzWzBdO1xuICAgICAgY29uc3QgY29tcGFyZUZuID0gYXJnc1sxXTtcblxuICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xuXG4gICAgICB0aGlzLnZhbHVlcy5zb21lKCh7IG5hbWUsIHZhbHVlLCBjaGlsZHJlbiB9LCBpKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuYW1lID09PSAnZC1kZWZhdWx0J1xuICAgICAgICAgIHx8IGNvbXBhcmVGbihuZXdWYWx1ZSwgdmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2QtYmluZCddID0gY2xhc3MgREJpbmQgZXh0ZW5kcyBNaXhpbiB7XG4gIG9mZiA9IG5vb3A7XG5cbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLm9mZigpO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYgPSBub29wO1xuXG4gICAgICBjb25zb2xlLmVycm9yKCdQcm92aWRlIFwiZC1iaW5kXCIgbWl4aW4gd2l0aCBhbiBldmVudCBuYW1lcyAobGlrZSBcImQtYmluZChjbGljaylcIiBvciBcImQtYmluZChrZXl1cCwga2V5cHJlc3MpXCIpIScpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLm9mZigpO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIGlzQXJyYXksIGlzU3RyaW5nLFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3Rcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgRU1QVFlfU1BBQ0VfUkVHRVggPSAvXFxzKy87XG5cbnJvb3RNaXhpbnNbJ2QtY2xhc3MnXSA9IGNsYXNzIERDbGFzcyBleHRlbmRzIE1peGluIHtcbiAgY2xhc3NlcyA9IFtdO1xuXG4gIGFmdGVyVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjbGFzc2VzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3Q2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWVcbiAgICAgICAgPyBhcmdzXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKG5ld1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zcGxpdChFTVBUWV9TUEFDRV9SRUdFWCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICBpZiAobmV3VmFsdWUuaW5kZXhPZihjbHMpID09PSAtMSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlQXJyYXkobmV3VmFsdWUsIChjbHMpID0+IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNscykpIHtcbiAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8ICFuZXdWYWx1ZVtjbHNdKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3VmFsdWUsICh2YWwsIGNscykgPT4ge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzZXMgPSBuZXdDbGFzc2VzO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICBpZiAoIWlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgY2xhc3Nlc1xuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MuYXBwbHkoZWxlbSwgY2xhc3Nlcyk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2QtZWxlbSddID0gY2xhc3MgREVsZW0gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQgc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKCk7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHZhbHVlID0gYXJnc1swXTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlKGVsZW0pO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBlbGVtO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNsYXNzIERIaWRlIGV4dGVuZHMgTWl4aW4ge1xuICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxufVxuXG5yb290TWl4aW5zWydkLWhpZGUnXSA9IERIaWRlO1xuXG5leHBvcnQgeyBESGlkZSB9O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2Qtbm9kZSddID0gY2xhc3MgRE5vZGUgZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIG5vZGVcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKCk7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHZhbHVlID0gYXJnc1swXTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBub2RlO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLW9uJ10gPSBjbGFzcyBET24gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksICgpID0+IHtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmID0gbm9vcDtcblxuICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtb25cIiBtaXhpbiB3aXRoIGFuIGV2ZW50IG5hbWVzIChsaWtlIFwiZC1vbihjbGljaylcIiBvciBcImQtb24oa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5vZmYoKTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLXNob3cnXSA9IGNsYXNzIERTaG93IGV4dGVuZHMgTWl4aW4ge1xuICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbnN0cnVjdE1peGluUmVnZXggfSBmcm9tICcuL2NvbnN0cnVjdE1peGluUmVnZXgnO1xuXG5pdGVyYXRlT2JqZWN0KHJvb3RNaXhpbnMsIChNaXhpbiwgbmFtZSkgPT4ge1xuICBNaXhpbi5fbWF0Y2ggPSBjb25zdHJ1Y3RNaXhpblJlZ2V4KG5hbWUpO1xufSk7XG4iLCJpbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcbmltcG9ydCB7IGNyZWF0ZUhpZGVTdHlsZU5vZGUgfSBmcm9tICcuL2hlbHBlcnMvRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGRvY1xuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGh0bWxcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IG5ldyBFbGVtKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBib2R5XG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmJvZHkuXG4gKi9cbmV4cG9ydCBjb25zdCBib2R5ID0gbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBoZWFkXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFkID0gbmV3IEVsZW0oZG9jdW1lbnQuaGVhZCk7XG5cbmNyZWF0ZUhpZGVTdHlsZU5vZGUoaGVhZCk7XG4iXSwibmFtZXMiOlsiY29sbGVjdEZyb21BcnJheSIsImFycmF5IiwiY2FsbGJhY2siLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZSIsImluZGV4IiwiZmluZEluQXJyYXkiLCJpIiwibGVuZ3RoIiwiaXRlcmF0ZUFycmF5IiwicmVtb3ZlQXJyYXlFbGVtIiwiZWxlbSIsImluZGV4T2YiLCJzcGxpY2UiLCJ0b09iamVjdEtleXMiLCJhZGRLZXkiLCJ2YXJzIiwidmFyaWFibGUiLCJhc3NpZ24iLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJrZXkiLCJjb2xsZWN0RnJvbU9iamVjdCIsIm9iamVjdCIsImV4Y2VwdCIsIm5ld09iamVjdCIsInBhdGhzIiwic2xpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsIml0ZXJhdGVPYmplY3QiLCJtYXBPYmplY3QiLCJkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0eSIsImRlZmluZUZyb3plblByb3BlcnRpZXMiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwic2V0VG9TdHJpbmdUYWciLCJrbGFzcyIsInRhZyIsIlN5bWJvbCIsInByb3RvdHlwZSIsImlzRnVuY3Rpb24iLCJpc05pbCIsImlzU3RyaW5nIiwiZXNjYXBlUmVnZXgiLCJzdHJpbmciLCJyZXBsYWNlIiwicmVnZXhwU3BlY2lhbHNSZWdleHAiLCJub29wIiwidG9DYW1lbENhc2UiLCJEQVNIRURfU1lNQk9MX1JFR0VYIiwiY2FwaXRhbGl6ZSIsInRvSHlwaGVuQ2FzZSIsIlVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYIiwiaHlwaGVuaXplIiwibWF0Y2giLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiYWRkQXR0ciIsImF0dHJzIiwiYXR0ciIsImFkZENTU1Byb3AiLCJjc3MiLCJwcm9wZXJ0eSIsInNwbGl0IiwiQ1NTX1BST1BfVkFMVUVfU0VQQVJBVE9SX1JFR0VYIiwiYWRkRGF0YUF0dHIiLCJkYXRhIiwiYWRkTmV4dCIsImFkZCIsIm5leHRTaWJsaW5nIiwiYWRkUGFyZW50IiwicGFyZW50Tm9kZSIsImFkZFByZXYiLCJwcmV2aW91c1NpYmxpbmciLCJjcmVhdGVIaWRlU3R5bGVOb2RlIiwiaGVhZCIsImZpbmQiLCJISURFX0NMQVNTIiwiY3JlYXRlIiwicHJvcCIsInRleHQiLCJnZXRBdHRyTlMiLCJpc1htbE5zIiwibm9kZU5hbWUiLCJOdWxsIiwiWE1MX05TIiwiWF9MSU5LX0FUVFJfRklORF9SRUdFWCIsInRlc3QiLCJFbGVtIiwiY2xvc2VzdCIsIlhfTElOS19OUyIsIlhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVgiLCJpc0RvY3VtZW50IiwiRE9DVU1FTlRfUkVHRVgiLCJpc0VsZW0iLCJpc0VsZW1lbnRzQ29sbGVjdGlvbiIsIkhUTUxfQ09MTEVDVElPTl9SRUdFWCIsImlzQXJyYXkiLCJpc1ZhbGlkTm9kZSIsIkVMRU1FTlRfUkVHRVgiLCJnZXRFdmVudCIsImV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJyZWFsRGV0YWlscyIsImZpbmFsRXZlbnQiLCJFVkVOVF9SRUdFWCIsIkV2ZW50IiwiZXJyIiwiZG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJoaWRlIiwiYWRkQ2xhc3MiLCJnZXRNYXRjaGVzRnVuY3Rpb24iLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwic2VsZWN0b3IiLCJ0aGlzIiwicXVlcnlTZWxlY3RvckFsbCIsInJlbW92ZSIsInBhcmVudCIsInJlbW92ZUNoaWxkIiwic2hvdyIsInJlbW92ZUNsYXNzIiwidG9FbGVtIiwiYmFzZSIsIlN0cmluZyIsImNhbGN1bGF0ZUFyZ3MiLCJhcmdzIiwiYXJnc09iamVjdCIsImtleXMiLCJhcmciLCJ1bmRlZmluZWQiLCJjbGVhblByb3BlcnR5IiwiY29uc3RydWN0TWl4aW5SZWdleCIsIlJlZ0V4cCIsIm1peGluTWF0Y2giLCJtaXhpbnMiLCJNaXhpbiIsImxvY2FsTWF0Y2giLCJfbWF0Y2giLCJhcmdzTWF0Y2giLCJDT01NQV9SRUdFWCIsInRyYW5zZm9ybVJlc3RBdHRycyIsIm1peGluRGVmYXVsdE9wdHMiLCJldmVudHVhbEF0dHJzIiwiRF9SRVNUX1JFR0VYIiwidHJhbnNmb3JtUmVzdEFyZ3MiLCJhZGRBcmdzIiwiZXhlY3V0ZU1peGluV2F0Y2hlcnMiLCJtaXhpbiIsIm9sZFZhbHVlIiwiJCQiLCJ3YXRjaGVycyIsIndhdGNoZXIiLCJjYWxjdWxhdGVBdHRycyIsIm5vcm1hbGl6ZWRBdHRycyIsImF0dHJzT2JqZWN0IiwiZmlyc3RUaW1lIiwidHlwZSIsInJlbW92ZUF0dHIiLCJkeW5hbWljIiwib3B0cyIsIm5leHRUeXBlIiwibmV4dER5bmFtaWMiLCJuZXh0VmFsdWUiLCJwcmV2VHlwZSIsInByZXZWYWx1ZSIsInByZXZEeW5hbWljIiwiY3JlYXRlZCIsImlzRHluYW1pYyIsImV2YWx1YXRlZCIsImV2YWx1YXRlIiwibmV3VmFsdWUiLCJwYXJlbnRTY29wZSIsImNvbnN0cnVjdE1peGluV2F0Y2hlciIsInNldEFmdGVyVXBkYXRlIiwiYnVpbGRNaXhpbiIsImZpcnN0VmFsdWUiLCJwdXNoIiwibm9ybWFsaXplQXJncyIsImFyZ3NDaGFpbiIsIm5ld0FyZ3MiLCJjb25zdHJ1Y3RQcml2YXRlU2NvcGUiLCJzY29wZSIsImdsb2JhbHMiLCJyZW1vdmVUZW1wV2F0Y2hlciIsInJlbW92ZVdhdGNoZXJzIiwid2F0Y2hlcnNUb1JlbW92ZSIsInJlbW92ZVdhdGNoZXIiLCJjb25zdHJ1Y3RQdWJsaWNTY29wZSIsInNjb3BlVmFsdWVzIiwicHJpdmF0ZVNjb3BlIiwiZXZhbE1vZGUiLCJnZXR0aW5nVmFycyIsIm9sZFRlbXBXYXRjaGVycyIsImNyZWF0ZUJsb2NrIiwibm9kZSIsInBhcmVudEVsZW0iLCJwYXJlbnRCbG9jayIsInBhcmVudFRlbXBsYXRlIiwicHJldkJsb2NrIiwiZG9jIiwibmFtZXNwYWNlVVJJIiwiU1ZHX05TIiwibG9jYWxCbG9ja3MiLCJucyIsIl9ibG9ja3MiLCJCbG9jayIsImxvY2FsTWl4aW5zIiwiX21peGlucyIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvciIsImRCbG9ja01hdGNoIiwiZEJsb2NrTmFtZSIsImRCbG9ja0FyZ3MiLCJOQU1FRF9EX0JMT0NLX1JFR0VYIiwiYmxvY2tJbnN0YW5jZSIsImVycm9yIiwiZWxlbWVudCIsImN1cnJlbnRBdHRycyIsIndhc0RSZXN0IiwiYXR0cnNDaGFpbiIsImlzRFJlc3QiLCJsb2NhbEF0dHJzIiwicmVzdEF0dHJzIiwibWl4aW5zVG9CdWlsZCIsImlzUGFyZW50QmxvY2siLCJpbnNlcnRBZnRlckl0IiwiaW5zZXJ0QWZ0ZXIiLCJhZGRDb250ZW50IiwiaW5zZXJ0SW5TdGFydE9mSXQiLCJpbnRvIiwiY29udGVudCIsImVtcHR5QXJyYXkiLCJjb250ZW50RG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjaGlsZCIsIkFyZ3MiLCJsb2NhbHMiLCJodG1sIiwidGVtcGxhdGUiLCJpdGVtTmFtZSIsIml0ZW0iLCJpbmRleE5hbWUiLCJhZnRlckNvbnN0cnVjdCIsImlzUmVuZGVyZWQiLCJleGVjdXRlQnVpbGRlcnMiLCJhZnRlclJlbmRlciIsImlzSW5zdGFuY2VPZiIsIkNsYXNzIiwiU3ViY2xhc3MiLCJpc1Byb3RvdHlwZU9mIiwicmVtb3ZlV2l0aFBhcmVudFNpZ25hbCIsIndyYXBCbG9jayIsImJsb2NrIiwid3JhcHBlciIsInJldHVyblZhbHVlIiwid3JhcE1peGluIiwiY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nIiwic3R5bGUiLCJDU1NfU1RZTEVfU0VQQVJBVE9SX1JFR0VYIiwidHJpbSIsImdldFByb3AiLCJoYXNBdHRyIiwiZ2V0VmFsdWVGb3JTZXR0aW5nIiwiaW5wdXRWYWx1ZSIsImlzUmFkaW8iLCJnZXRWYWx1ZUZvckdldHRpbmciLCJ2YWx1ZXMiLCJvcHRpb25zIiwiaW5pdCIsImlzTXVsdGlwbGUiLCJhZGRWYWx1ZSIsImNvbmNhdCIsImdldExpc3RlbmVyTmFtZSIsInNlbGVjdGVkIiwiaW5zZXJ0VGVtcGxhdGVzIiwidGVtcGxhdGVzIiwiaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuIiwibm9kZXMiLCJ0cmltbWVkIiwibmV3VGVtcGxhdGVzIiwibmV3VGVtcGxhdGUiLCJuZXdWYXJzIiwiaW5pdEFwcCIsImNvbnRhaW5lciIsInJvb3RCbG9jayIsInJlbW92ZUFwcCIsIkR3YXluZVJvb3RCbG9jayIsImRlZmluZVByb3BlcnRpZXMiLCJPYmplY3QiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInNldFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJwcm90byIsIl9fcHJvdG9fXyIsInJvb3RCbG9ja3MiLCJyb290TWl4aW5zIiwiQXJyYXkiLCJyZWdleHBTcGVjaWFsQ2hhcmFjdGVycyIsIm1hcCIsInMiLCJqb2luIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsImVtcHR5Q29sbGVjdGlvbiIsIl90aGlzIiwiaW5jbHVkZXMiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiZWxlbXMiLCJlbGVtZW50cyIsImNsYXNzZXMiLCJmb3JFYWNoIiwibGlzdCIsImNsYXNzTGlzdCIsImNscyIsImF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVOUyIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlIiwiY2hpbGROb2RlcyIsImNvbGxlY3QiLCJpcyIsImNiIiwiY29udGFpbnMiLCJlbCIsImlzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUVsZW1lbnQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0UHJvcGVydHlQcmlvcml0eSIsInJlbW92ZUNTUyIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJjc3NUZXh0IiwiZGF0YXNldCIsImRldGFpbHMiLCJkaXNwYXRjaEV2ZW50IiwiZmlsdGVyIiwiaGFzQXR0cmlidXRlTlMiLCJoYXNBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJuZXh0IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJlbmQiLCJmaXJzdENoaWxkIiwibGlzdGVuZXIiLCJuZXdFdmVudHMiLCJhbGxMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwcm9wcyIsImZpcnN0IiwicHJldiIsImJhYmVsSGVscGVycy5nZXQiLCJhcHBseSIsInRleHRDb250ZW50IiwiY29uZGl0aW9uIiwiX2FyZ3VtZW50cyIsInRvZ2dsZSIsIl9hcmd1bWVudHMyIiwic3BlY2llcyIsImNvbW1lbnQiLCJhZnRlclVwZGF0ZSIsIl92YWx1ZSIsImN1cnJlbnRWYWx1ZSIsImlzUGFyZW50U2lnbmFsIiwiaXNSZW1vdmVkIiwiYmVmb3JlUmVtb3ZlIiwid3JhcHBlcnMiLCJyZWR1Y2UiLCJpc0VsZW1lbnRSZW1vdmVkIiwiYmxvY2tIb29rcyIsIm1peGluSG9va3MiLCJUQUdfTkFNRV9SRUdFWCIsIkFUVFJfTkFNRV9SRUdFWCIsImFmdGVyRWxlbSIsImVtcHR5T2JqZWN0Iiwib3JpZ2luYWxBcmdzIiwiY2hpbGRyZW5CbG9ja3MiLCJmdW5jIiwib25DaGFuZ2UiLCJ0YXJnZXRCbG9jayIsImZvckRFbGVtZW50cyIsImZvckRJdGVtIiwiX3RoaXM3Iiwib25DaGFuZ2VGbGFnIiwicmVzdWx0Iiwib3JpZ2luYWwiLCJvbkV2YWxFcnJvciIsImUiLCJsb2NhbFdhdGNoZXJzIiwid2F0Y2hlckJsb2NrIiwibmV3UmVzdWx0IiwicmVtb3ZlQ29udGVudCIsIm5ld0NvbnRlbnQiLCJhZnRlckRPTUNoYW5nZSIsImNvbnRlbnRUb0FkZCIsIm5vdFJlY3Vyc2l2ZSIsIm9sZENvbnRlbnQiLCJjaGFuZ2VDb250ZW50IiwiY29udGVudFRvTW92ZSIsImFmdGVyIiwiaW5kZXhUb1B1dCIsIm1vdmVDb250ZW50IiwiY29udGVudFRvUmVtb3ZlIiwiY29udGVudFRvSW5zZXJ0IiwibW92ZUZsYWciLCJ0cnlUb0FkZE9yTW92ZSIsImRlZmF1bHRMb2NhbHMiLCJkZWZhdWx0QXJncyIsImxvY2FsQXJncyIsInJlc3RBcmdzIiwiaXNERWxlbWVudHMiLCJob29rIiwid2FybiIsImN1cnJlbnRSZXR1cm5WYWx1ZSIsIndhdGNoTmFtZUFyZ3MiLCJ3YXRjaENvbnN0cnVjdG9yQXJncyIsIkRCbG9jayIsImNvbnN0cnVjdER5bmFtaWNOYW1lQmxvY2siLCJodG1sQ2hpbGRyZW4iLCJjb25zdHJ1Y3REeW5hbWljQ29uc3RydWN0b3JCbG9jayIsInBhcmVudFBhcmVudFNjb3BlIiwicGFyZW50UGFyZW50VGVtcGxhdGUiLCJvd25DaGlsZHJlbiIsIkRCbG9ja05hbWUiLCJmb3VuZCIsIlBhcmVudFNjb3BlIiwiUGFyZW50VGVtcGxhdGUiLCJkQmxvY2tzIiwiREl0ZW0iLCJ3YXRjaEFyZ3MiLCJyZW5kZXJTZXQiLCJfdGhpczIiLCJpdGVtc0J5VUlEcyIsInNvcnRCeSIsIlVJRCIsInVpZCIsIm5ld0l0ZW1zQnlVSURzIiwibmV3VUlEc0NvdW50ZXIiLCJuZXdVSURzIiwic2V0IiwiZmlsdGVyQnkiLCJpc0FyciIsIml0ZXJhdGUiLCJzb3J0IiwiaXRlbXMiLCJzaGlmdCIsImNvbnN0cnVjdEVsZW1zIiwiSW5maW5pdHkiLCJ3YXNEZWZhdWx0IiwidmFsIiwiaWYiLCJjb21wYXJlRm4iLCJzb21lIiwic3dpdGNoVmFsdWUiLCJjYXNlVmFsdWUiLCJvZmYiLCJvbiIsIm5ld0NsYXNzZXMiLCJESGlkZSIsIkJvb2xlYW4iLCJpbml0aWFsU2NvcGVWYWx1ZSIsInNldFByb3AiLCJpbml0aWFsRWxlbVZhbHVlIiwiaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwiLCJpc0NoZWNrYm94IiwiY2hhbmdlU2NvcGUiLCJvZmZFbGVtTGlzdGVuZXIiLCJvZmZGb3JtTGlzdGVuZXIiLCJvcHRpb24iLCJib2R5Il0sIm1hcHBpbmdzIjoieUJBQU8sU0FBU0EsR0FBaUJDLEVBQU9DLE1BQVVDLHNFQUNuQ0YsRUFBTyxTQUFDRyxFQUFPQyxLQUNqQkYsRUFBY0MsRUFBT0MsRUFBT0osS0FHaENFLEVBR1QsUUFBZ0JHLEdBQVlMLEVBQU9DLE9BQzVCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsSUFBSyxJQUNoREgsR0FBUUgsRUFBTU0sTUFFaEJMLEVBQVNFLEVBQU9HLEVBQUdOLGNBRWRNLFlBT2IsUUFBZ0JFLEdBQWFSLEVBQU9DLE9BQzdCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsTUFDeENOLEVBQU1NLEdBQUlBLEVBQUdOLEdBSTFCLFFBQWdCUyxHQUFnQlQsRUFBT1UsTUFDL0JOLEdBQVFKLEVBQU1XLFFBQVFELElBRWIsSUFBWE4sS0FDSVEsT0FBT1IsRUFBTyxHQUl4QixRQUFnQlMsR0FBYWIsU0FDcEJELEdBQWlCQyxFQUFPYyxHQUdqQyxRQUFTQSxHQUFPQyxFQUFNQyxLQUNmQSxJQUFZ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"}