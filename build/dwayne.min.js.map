{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/is.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/noop.js","../src/utils/toCase.js","../src/utils/toStringTag.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/is.js","../src/helpers/Elem/getEvent.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/matches.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/normalizeArgs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/extend.js","../src/helpers/Block/getDefaultArgs.js","../src/helpers/Block/remove.js","../src/helpers/Block/wrap.js","../src/mixins/Style.js","../src/mixins/Value.js","../src/insertHtml.js","../src/initApp.js","../src/removeApp.js","../src/global.js","../src/constants.js","../src/utils/objectStatics.js","../src/Elem.js","../src/utils/setSymbolSpecies.js","../src/helpers/Block/InternalMixin.js","../src/Mixin.js","../src/Block.js","../src/BlockPublic.js","../src/blocks/Case.js","../src/blocks/Elements.js","../src/blocks/Children.js","../src/blocks/DynamicBlock.js","../src/blocks/Item.js","../src/blocks/Each.js","../src/blocks/If.js","../src/blocks/Switch.js","../src/mixins/Bind.js","../src/mixins/Class.js","../src/mixins/Elem.js","../src/mixins/Hide.js","../src/mixins/Node.js","../src/mixins/On.js","../src/mixins/Rest.js","../src/mixins/Show.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","export const { isArray } = Array;\n\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\nexport function isNil(value) {\n  /* eslint-disable eqeqeq */\n  return value == null;\n  /* eslint-enable eqeqeq */\n}\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n","const {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  for (let i = 1, length = arguments.length; i < length; i++) {\n    iterateObject(arguments[i], (value, key) => {\n      target[key] = value;\n    });\n  }\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","export function noop() {}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","import { definePrototypeProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nconst { toString } = {};\n\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(klass, tag) {\n  if (Symbol.toStringTag) {\n    definePrototypeProperties(klass.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_FIND_REGEX = /^xlink:\\w/;\nconst X_LINK_ATTR_REPLACE_REGEX = /^xlink:/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst Null = {\n  ns: null\n};\n\nexport function getAttrNS(attr, elem) {\n  const isXmlNs = attr === 'xmlns';\n\n  if (isXmlNs || attr === 'xmlns:xlink') {\n    if (elem.nodeName !== 'SVG') {\n      return Null;\n    }\n\n    return {\n      ns: XML_NS,\n      name: isXmlNs\n        ? 'xmlns'\n        : 'xlink'\n    };\n  }\n\n  if (X_LINK_ATTR_FIND_REGEX.test(attr)) {\n    if (!new Elem(elem).closest('svg').length) {\n      return Null;\n    }\n\n    return {\n      ns: X_LINK_NS,\n      name: attr.replace(X_LINK_ATTR_REPLACE_REGEX, '')\n    };\n  }\n\n  return Null;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { Elem } from '../../Elem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\nconst DOCUMENT_REGEX = /Document$/;\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isDocument(value) {\n  return DOCUMENT_REGEX.test(toStringTag(value));\n}\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || DOCUMENT_REGEX.test(tag)\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","import { assign, toStringTag } from '../../utils';\nimport { isDocument } from './is';\n\nconst EVENT_REGEX = /Event$/;\n\nexport function getEvent(event, bubbles, cancelable, realDetails, elem) {\n  let finalEvent = event;\n\n  if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n    try {\n      finalEvent = new Event(finalEvent, { bubbles, cancelable });\n      assign(finalEvent, realDetails);\n    } catch (err) {\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      finalEvent = document.createEvent('Event');\n      finalEvent.initEvent(event, bubbles, cancelable);\n\n      assign(finalEvent, realDetails);\n    }\n  }\n\n  return finalEvent;\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { isDocument } from './is';\n\nconst { indexOf } = [];\n\nexport function getMatchesFunction(elem) {\n  return (\n    elem.matches\n    || elem.matchesSelector\n    || elem.webkitMatchesSelector\n    || elem.mozMatchesSelector\n    || elem.msMatchesSelector\n    || elem.oMatchesSelector\n    || matches\n  );\n}\n\nfunction matches(selector) {\n  const document = isDocument(this)\n    ? this\n    : this.ownerDocument;\n\n  return document.querySelectorAll(selector)::indexOf(this) !== -1;\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './is';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\nimport { document } from './constants';\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, iterateObject, keys } from '../../utils';\n\nexport function calculateArgs(normalizedArgs, args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  iterateObject(normalizedArgs, (value, arg) => {\n    argsObject[arg] = value;\n  });\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","import { iterateObject, iterateArray, hasOwnProperty } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\nimport { InternalMixin } from './InternalMixin';\n\nexport function calculateAttrs({\n  newAttrs, currentAttrs, currentMixins,\n  elem, parentBlock, firstTime\n}) {\n  iterateObject(currentAttrs, (value, attr) => {\n    if (!hasOwnProperty(newAttrs, attr)) {\n      if (value instanceof InternalMixin) {\n        currentMixins[attr].$$.remove();\n        delete currentMixins[attr];\n      } else {\n        elem.removeAttr(attr);\n      }\n\n      delete currentAttrs[attr];\n    }\n  });\n\n  const mixins = [];\n\n  iterateObject(newAttrs, (value, attr) => {\n    const prevValue = currentAttrs[attr];\n\n    if (prevValue === value) {\n      return;\n    }\n\n    if (value instanceof InternalMixin) {\n      const {\n        parentScope,\n        Mixin,\n        value: evalFn\n      } = value;\n\n      if (prevValue) {\n        const mixin = currentMixins[attr];\n        const { $$ } = mixin;\n        let newValue;\n\n        $$.internal = value;\n\n        if ($$.internals.indexOf(value) === -1) {\n          $$.internals.push(value);\n\n          if (Mixin.evaluate) {\n            newValue = parentScope.$$.evaluate(\n              evalFn,\n              constructMixinWatcher(mixin, value),\n              mixin\n            );\n          }\n        } else if (Mixin.evaluate) {\n          newValue = parentScope.$$.evaluate(evalFn);\n        }\n\n        if (Mixin.evaluate) {\n          executeMixinWatchers(mixin, newValue);\n        }\n      } else {\n        const buildMixin = () => {\n          const mixin = new Mixin({\n            ...value,\n            parentBlock,\n            elem,\n            internal: value\n          });\n          const { $$ } = mixin;\n\n          $$.internal = value;\n          $$.internals = [value];\n          currentMixins[attr] = mixin;\n\n          if (Mixin.evaluate) {\n            const afterUpdate = (newValue, oldValue) => {\n              try {\n                mixin.afterUpdate(newValue, oldValue);\n              } catch (err) {\n                console.error(`Uncaught error in ${ $$.name }#afterUpdate:`, err);\n              }\n            };\n\n            $$.value = parentScope.$$.evaluate(\n              evalFn,\n              constructMixinWatcher(mixin, value),\n              mixin\n            );\n            afterUpdate($$.evaluate(afterUpdate));\n          }\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n    } else {\n      elem.attr(attr, value);\n    }\n\n    currentAttrs[attr] = value;\n  });\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, buildMixin);\n    };\n  }\n}\n\nfunction constructMixinWatcher(mixin, internalMixin) {\n  return function (newValue) {\n    if (mixin.$$.internal === internalMixin) {\n      executeMixinWatchers(mixin, newValue);\n    }\n  };\n}\n\nfunction buildMixin(builder) {\n  builder();\n}\n","import { iterateArray, iterateObject } from '../../utils';\n\nexport function normalizeArgs(argsChain) {\n  const newArgs = {};\n\n  iterateArray(argsChain, (args) => {\n    iterateObject(args, (value, arg) => {\n      newArgs[arg] = value;\n    });\n  });\n\n  return newArgs;\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: []\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { gettingVars, evalMode } from '../../Block';\nimport { removeTempWatcher } from './removeWatcher';\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (gettingVars.indexOf(scope.watchers) === -1) {\n            gettingVars.push(scope.watchers);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        const oldTempWatchers = scope.watchers.slice();\n\n        scope.watchers = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n      }\n    };\n  }));\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil, isString, isArray\n} from '../../utils';\nimport { isDocument } from '../Elem';\nimport { Elem } from '../../Elem';\nimport { SVG_NS, blocks, mixins } from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { calculateAttrs } from './calculateAttrs';\nimport { normalizeArgs } from './normalizeArgs';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { isInstanceOf } from './isInstanceOf';\nimport { InternalMixin } from './InternalMixin';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nconst emptyArray = [];\n\nexport function createBlock({ node, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = isDocument(parentElem[0])\n    ? parentElem\n    : new Elem(parentElem[0].ownerDocument);\n  const args = node.args || {};\n  const { type } = node;\n  const isElements = type === blocks.Elements;\n  let { children } = node;\n  let constructor = !isString(type) && type;\n  let DynamicBlockArgs;\n\n  if (type === blocks.DynamicBlock) {\n    DynamicBlockArgs = except(args, 'type');\n  }\n\n  if (isArray(constructor)) {\n    constructor = class extends Block {\n      static html = constructor;\n    };\n  }\n\n  if (!isInstanceOf(Block, constructor) && !isString(type)) {\n    throw new Error(`Wrong block type given: ${ type }`);\n  }\n\n  if (!constructor) {\n    const { value } = node;\n    const elem = (\n      parentElem[0].namespaceURI === SVG_NS\n        ? doc.create('svg')\n        : doc\n    ).create(type);\n    const currentAttrs = create(null);\n    const currentMixins = create(null);\n    let attrs = create(null);\n    let wasRest;\n    const attrsChain = [attrs];\n\n    iterateObject(args, (value, attr) => {\n      const isRest = value.mixin === mixins.Rest;\n      const localAttrs = isRest || wasRest\n        ? create(attrs)\n        : attrs;\n\n      if (attrs !== localAttrs) {\n        attrsChain.push(localAttrs);\n      }\n\n      attrs = localAttrs;\n\n      if (isRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localAttrs, cleanProperty);\n          assign(localAttrs, value);\n          calculateAttrs({\n            newAttrs: normalizeArgs(attrsChain),\n            currentAttrs,\n            currentMixins,\n            elem,\n            parentBlock,\n            firstTime: false\n          });\n        }, parentBlock);\n\n        wasRest = true;\n\n        return assign(localAttrs, restAttrs);\n      }\n\n      wasRest = false;\n\n      if (isInstanceOf(Mixin, value.mixin)) {\n        localAttrs[attr] = new InternalMixin({\n          Mixin: value.mixin,\n          args: value.args,\n          parentScope,\n          parentTemplate,\n          value\n        });\n\n        return;\n      }\n\n      localAttrs[attr] = parentScope.$$.evaluate(value, (value) => {\n        localAttrs[attr] = value;\n        calculateAttrs({\n          newAttrs: normalizeArgs(attrsChain),\n          currentAttrs,\n          currentMixins,\n          elem,\n          parentBlock,\n          firstTime: false\n        });\n      }, parentBlock);\n    });\n\n    parentBlock.$$.mixinsToBuild.push(calculateAttrs({\n      newAttrs: normalizeArgs(attrsChain),\n      currentAttrs,\n      currentMixins,\n      elem,\n      parentBlock,\n      firstTime: true\n    }));\n\n    if (type === '#comment') {\n      elem.text(value);\n    }\n\n    if (type === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        elem.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      elem.text(`${ text }`);\n    }\n\n    const isParentBlock = parent instanceof Block;\n    const childBlocks = [];\n\n    /* istanbul ignore if */\n    if (type === 'iframe' && !('src' in attrs)) {\n      elem.on('load', () => {\n        const document = elem[0].contentDocument;\n        const doc = new Elem(document);\n\n        new Elem(document.documentElement).remove();\n        iterateChildren(childBlocks, true);\n\n        function iterateChildren(children, isRoot) {\n          iterateArray(children, (child) => {\n            if (child instanceof Block) {\n              if (isRoot) {\n                child.$$.parentElem = doc;\n                child.$$.parent = doc;\n                child.$$.content.into(doc);\n              }\n\n              iterateChildren(child.$$.children, false);\n            } else {\n              child.into(doc);\n            }\n          });\n        }\n      });\n    }\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(elem, false);\n    } else if (prevBlock) {\n      elem.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(elem);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(elem, false);\n    } else {\n      elem.into(parentElem, false);\n    }\n\n    if (children) {\n      let prevBlock;\n      let parentElem = elem;\n\n      /* istanbul ignore if */\n      if (type === 'template') {\n        parentElem = new Elem(elem[0].content = elem[0].content || doc[0].createDocumentFragment());\n      } else if (type === 'iframe') {\n        if ('src' in attrs) {\n          children = emptyArray;\n        } else {\n          const document = elem[0].contentDocument;\n\n          new Elem(document.documentElement).remove();\n\n          parentElem = new Elem(document);\n        }\n      }\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n        childBlocks.push(prevBlock);\n      });\n    }\n\n    return elem;\n  }\n\n  const blockInstance = new constructor({\n    args,\n    DynamicBlockArgs,\n    children,\n    parent,\n    parentElem,\n    parentBlock,\n    parentScope,\n    parentTemplate,\n    prevBlock\n  });\n  const {\n    $$,\n    $$: { name },\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  const html = isElements\n    ? Args.value || []\n    : constructor.html;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (type === blocks.Item) {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.Constructor === blocks.Item\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance._afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = isElements\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = isElements\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  iterateArray(blockInstance.$$.mixinsToBuild, (executeBuilders) => {\n    executeBuilders();\n  });\n  blockInstance.$$.mixinsToBuild = [];\n\n  try {\n    blockInstance._afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","import { setProto, getProto } from '../../utils';\nimport { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\n\nexport function extendBlock(block, newBlock) {\n  if (isInstanceOf(Block, newBlock)) {\n    if (isInstanceOf(block, newBlock)) {\n      let currentBlock = newBlock;\n      let proto;\n\n      while ((proto = getProto(currentBlock)) !== block) {\n        currentBlock = proto;\n      }\n\n      extend(currentBlock, getProto(block));\n    }\n\n    extend(block, newBlock);\n  }\n\n  return block;\n}\n\nfunction extend(Block, BaseBlock) {\n  setProto(Block, BaseBlock);\n  setProto(Block.prototype, BaseBlock.prototype);\n}\n","import { iterateObject, create } from '../../utils';\n\nexport function getDefaultArgs(argsDescriptions) {\n  const newArgs = create(null);\n\n  iterateObject(argsDescriptions, ({ default: def }, arg) => {\n    newArgs[arg] = def;\n  });\n\n  return newArgs;\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const newBlock = wrapper(block);\n\n  return isInstanceOf(Block, newBlock)\n    ? newBlock\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const newMixin = wrapper(mixin);\n\n  return isInstanceOf(Mixin, newMixin)\n    ? newMixin\n    : mixin;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /\\s*;\\s*/;\nconst CSS_STYLE_SEPARATOR_REGEX = /\\s*:\\s*/;\n\nclass Style extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean)\n          .map(constructStyleFromString),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        css\n      } = this;\n\n      elem.removeCSS.apply(elem, keys(css));\n    }\n  }\n}\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n\nfunction constructStyleFromString(style) {\n  const split = style.split(CSS_STYLE_SEPARATOR_REGEX);\n\n  return [\n    split[0].trim(),\n    split[1].trim()\n  ];\n}\n\nexport { Style };\n","import {\n  isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\n\nclass Value extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.children().filter('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      this.value = args[0];\n    }\n\n    if (!isFunction(this.value)) {\n      initialScopeValue = this.scope.$$.evaluate((scope) => scope[this.value], (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue, false);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), changeScope);\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.offElemListener();\n    }\n\n    this.offFormListener();\n  }\n}\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      values = values || [];\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        return values.indexOf(inputValue) === -1\n          ? values.concat(inputValue)\n          : values;\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n\nexport { Value };\n","import {\n  toObjectKeys,\n  assign, keys, create\n} from './utils';\n\nexport function insertHtml(html, templates) {\n  const {\n    vars = []\n  } = html;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n\n  (function iterateAndChangeChildren(nodes = []) {\n    for (let i = 0; i < nodes.length; i++) {\n      const {\n        type,\n        value,\n        children\n      } = nodes[i];\n\n      if (type === '#comment') {\n        const trimmed = value.trim();\n\n        if (newTemplates[trimmed]) {\n          const newTemplate = newTemplates[trimmed];\n\n          nodes.splice(i, 1, ...newTemplate);\n          assign(newVars, toObjectKeys(newTemplates[trimmed].vars));\n\n          i += newTemplate.length - 1;\n        }\n      } else {\n        iterateAndChangeChildren(children);\n      }\n    }\n  })(html);\n\n  html.vars = keys(newVars);\n\n  return html;\n}\n","import { isArray } from './utils';\nimport { createBlock, isInstanceOf } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function initApp\n * @public\n * @param {Template|typeof Block} html - Root template or root block constructor.\n * @param {Elem|Element} container - Container of the app.\n * @returns {Block|void} Root block if the app has been registered and undefined if not.\n * @description Method for initializing app.\n *\n * @example\n * import { initApp, doc } from 'dwayne';\n *\n * initApp(html`<App/>`, doc.create('div'));\n * initApp(htmlScopeless`<App/>`, doc.create('div'));\n * initApp('App', doc.create('div'));\n * initApp(App, doc.create('div'));\n */\nexport function initApp(html, container) {\n  const parentElem = new Elem(container).elem(0);\n\n  if (!parentElem.length) {\n    console.error('No valid element to insert the app into was given! (initApp)');\n\n    return;\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    console.error('There already exists a Dwayne app inside the given element! (initApp)');\n\n    return;\n  }\n\n  let RootBlock = html;\n\n  if (isArray(html)) {\n    RootBlock = class RootBlock extends Block {\n      static html = html;\n    };\n  }\n\n  if (!isInstanceOf(Block, RootBlock)) {\n    console.error('No valid root block was given! (initApp)');\n\n    return;\n  }\n\n  const rootBlock = createBlock({\n    node: {\n      type: RootBlock\n    },\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', rootBlock)\n    .attr('dwayne-root', '');\n\n  return rootBlock;\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function removeApp\n * @public\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for removing app.\n *\n * @example\n * import { removeApp, find } from 'dwayne';\n *\n * removeApp(find('.root'));\n */\nexport function removeApp(container) {\n  const elem = new Elem(container).elem(0);\n\n  if (!elem.length) {\n    console.error('No valid element to remove the app from was given! (removeApp)');\n\n    return;\n  }\n\n  container = elem[0];\n\n  const { DwayneRootBlock } = container;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    console.error('No app registered inside the given element! (removeApp)');\n\n    return;\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete container.DwayneRootBlock;\n}\n","/* eslint-disable no-nested-ternary, no-negated-condition */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n/* eslint-enable no-nested-ternary, no-negated-condition */\n","export const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\n\nexport const blocks = {};\nexport const mixins = {};\nexport const {\n  document = {},\n  Symbol = {}\n} = global;\nexport const version = '4.1.1';\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint-disable no-proto */\n  target.__proto__ = proto;\n  /* eslint-enable no-proto */\n});\n","import {\n  isNil, isString,\n  definePrototypeProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, setSymbolSpecies,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isDocument, isValidNode, getMatchesFunction,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, getEvent, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback CollectCallback\n * @public\n * @param {AddCallback} add - Add element to the eventual set function.\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback AddCallback\n * @public\n * @param {...(Element|Node|elem)} elem - Element to add.\n */\n\n/**\n * @callback ElemMethod\n * @public\n * @this Elem\n */\n\nconst EVENT_SEPARATOR_REGEX = /[,| ] */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array.<Element|Node>\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  /**\n   * @method Elem.addMethods\n   * @public\n   * @param {String|Object.<String, ElemMethod>} methodName - Name of the method or object of\n   * method names and methods.\n   * @param {ElemMethod} [method] - If the first argument is a string this should be the method itself.\n   * @returns {typeof Elem}\n   */\n  static addMethods(methodName, method) {\n    if (arguments.length >= 2) {\n      methodName = { [methodName]: method };\n    }\n\n    definePrototypeProperties(this.prototype, methodName);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add(...elements) {\n    const elems = this.slice();\n\n    iterateArray(elements, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, object of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromArray(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const {\n        ns,\n        name\n      } = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, name)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const { ns } = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} Set of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  /**\n   * @method Elem#collect\n   * @public\n   * @param {CollectCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns eventual set.\n   * @description Method for collecting elements into a new set.\n   *\n   * @example\n   * const parents = elem.collect((add, elem) => {\n   *   add(elem.parentNode);\n   * });\n   */\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        el = type === 'svg'\n          ? document.createElementNS(SVG_NS, type)\n          : document.createElement(type);\n      }\n\n      if (!isDocument(elem)) {\n        new Elem(el).into(elem);\n      }\n\n      add(el);\n    });\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, object of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, object of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details;\n\n    return this.forEach((elem) => {\n      elem.dispatchEvent(getEvent(\n        event,\n        bubbles,\n        cancelable,\n        realDetails,\n        elem\n      ));\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback|String} filter - Filter function or a selector.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filter) {\n    if (isString(filter)) {\n      const selector = filter;\n\n      filter = (elem) => (\n        new Elem(elem).is(selector)\n      );\n    }\n\n    return this.collect((add, elem, index) => {\n      if (filter(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const { ns } = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  /**\n   * @method Elem#includes\n   * @public\n   * @param {Element|node} elem - Element to search.\n   * @return {Boolean} If the element is in the set.\n   * @description The same as Array#includes.\n   */\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (!element) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = getMatchesFunction(elem);\n\n    return elem::matches(selector);\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr(...attributes) {\n    return this.forEach((elem) => {\n      iterateArray(attributes, (attr) => {\n        const { ns } = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS(...props) {\n    return this.forEach((elem) => {\n      iterateArray(props, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  /**\n   * @method Elem#slice\n   * @public\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n   * @returns {Elem}\n   * @description The same as Array#slice but for Elem.\n   */\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !classList.contains(cls) : condition) {\n        elem.addClass(cls);\n      } else {\n        elem.removeClass(cls);\n      }\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\nsetSymbolSpecies(Elem, Array);\n\nexport { Elem };\n","import { defineProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nexport function setSymbolSpecies(klass, species) {\n  if (Symbol.species) {\n    defineProperties(klass, {\n      [Symbol.species]: {\n        get() {\n          return species;\n        }\n      }\n    });\n  }\n}\n","import { assign } from '../../utils';\n\nclass InternalMixin {\n  constructor(opts) {\n    assign(this, opts);\n  }\n}\n\nexport { InternalMixin };\n","import {\n  defineFrozenProperties, getProto,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\nconst toStringTag = '[object Mixin]';\n\n/**\n * @class Mixin\n * @public\n * @param {Object} opts - Mixin options.\n * @returns {Mixin} Instance of Mixin.\n */\nclass Mixin {\n  /**\n   * @member {Boolean} [Mixin.evaluate = true]\n   * @type {Boolean}\n   * @public\n   * @description If the mixin value should be evaluated and watched or not.\n   */\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      internal,\n      elem,\n      args,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n    const { constructor } = getProto(this);\n    const name = constructor.displayName || constructor.name;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Mixin#$$\n       * @type {Object}\n       * @protected\n       * @property {Function} Mixin#$$.evaluate - Evaluate function.\n       * @property {Boolean} Mixin#$$.isRemoved - If the block is removed.\n       * @property {InternalMixin} Mixin#$$.internal - Current internal mixin instance.\n       * @property {InternalMixin[]} Mixin#$$.internals - Array of internal mixins bound to the the mixin.\n       * @property {String} Mixin#$$.name - Mixin name.\n       * @property {Block|void} Mixin#$$.parentBlock - Parent block.\n       * @property {Block|void} Mixin#$$.parentScope - Parent scope.\n       * @property {Block|void} Mixin#$$.parentTemplate - Parent template.\n       * @property {*} Mixin#$$.value - Current value.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing mixin.\n       */\n      $$: {\n        name,\n        internal,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            value,\n            internal\n          } = this.$$;\n          const currentValue = constructor.evaluate\n            ? value\n            : parentScope.$$.evaluate(internal.value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          isParentSignal = !!isParentSignal;\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove(isParentSignal);\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    /**\n     * @member {String} [Mixin#name]\n     * @type {String}\n     * @public\n     */\n    this.name = name;\n\n    parentBlock.$$.mixins.push(this);\n  }\n\n  afterUpdate() {}\n\n  /**\n   * @method Mixin#beforeRemove\n   * @public\n   * @param {Boolean} isElementRemoved - If element removed as well.\n   * @description Is called before the mixin removal.\n   */\n  beforeRemove(isElementRemoved) {}\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, setToStringTag,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  normalizeArgs, removeWatchers, removeWithParentSignal,\n  cleanProperty, InternalMixin, calculateArgs,\n  wrapBlock, extendBlock, getDefaultArgs, isInstanceOf\n} from './helpers/Block';\nimport { blocks, mixins } from './constants';\nimport { Mixin } from './Mixin';\n\n/**\n * @typedef {BlockNode[]} Template\n * @public\n * @property {String[]} vars - Template used vars.\n */\n\n/**\n * @typedef {Object} BlockNode\n * @public\n * @property {String|typeof Block} type - Block type.\n * @property {Object} [args] - Block args.\n * @property {BlockNode[]} children - Block children.\n * @property {*} value - Text or comment node value.\n */\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {Function} func - Function which caused eval error.\n * @property {String} original - Evaluated expression original js.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\nconst toStringTag = '[object Block]';\nconst afterElem = new Elem();\nconst emptyObject = {};\nlet evalMode = false;\nlet gettingVars = [];\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Block options.\n * @returns {Block} Instance of Block.\n *\n * @example\n * import { Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static html = html`<Hello text=\"{text}\"/> ({ this.times })`;\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     this.interval = setInterval(() => {\n *       this.times++;\n *     });\n *   }\n *\n *   beforeRemove() {\n *     clearInterval(this.interval);\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', html`Hello, {args.text}!`);\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  /**\n   * @member {Object} [Block.args = null]\n   * @type {Object}\n   * @public\n   * @description Block args description.\n   */\n  static args = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {String} [Block.displayName = null]\n   * @type {String}\n   * @public\n   * @description Block display name.\n   */\n  static displayName = null;\n\n  /**\n   * @member {Template} [Block.html = []]\n   * @type {Template}\n   * @public\n   * @description Block template.\n   */\n  static html = [];\n\n  /**\n   * @method Block.extend\n   * @public\n   * @param {...(typeof Block)} blocks - Blocks that will be extended by the context.\n   * @returns {typeof Block} Returns this.\n   * @description Method for extending blocks. Usually used with extending the default block.\n   */\n  static extend(...blocks) {\n    return blocks.reduce(extendBlock, this);\n  }\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.original || err.func }\" in context of ${ err.block.$$.name }):`, err);\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      args: originalArgs,\n      DynamicBlockArgs,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const { constructor } = getProto(this);\n    const name = constructor.displayName || constructor.name;\n    const childrenBlocks = [];\n    const childrenMixins = [];\n    const isParentBlock = parent instanceof Block;\n    const isElements = constructor === blocks.Elements;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} Block#$$.args - Private args scope.\n       * @property {Block[]} Block#$$.children - Child blocks.\n       * @property {Elem} Block#$$.content - Content elements.\n       * @property {Object|void} Block#$$.DynamicBlockArgs - DynamicBlock args.\n       * @property {Function} Block#$$.evaluate - Evaluate function.\n       * @property {Object} Block#$$.globals - Private globals scope.\n       * @property {Object[]} Block#$$.htmlChildren - Block html children.\n       * @property {Boolean} Block#$$.isRemoved - If the block is removed.\n       * @property {Boolean} Block#$$.isRendered - If the block is rendered.\n       * @property {Object} Block#$$.locals - Private locals scope.\n       * @property {Mixin[]} Block#$$.mixins - Child mixins.\n       * @property {Function[]} Block#$$.mixinsToBuild - Pending mixins builders.\n       * @property {String} Block#$$.name - Block name.\n       * @property {typeof Block} Block#$$.Constructor - Block constructor.\n       * @property {Block|Elem|void} Block#$$.parent - Parent block or elem.\n       * @property {Block|void} Block#$$.parentBlock - Parent block.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Block|void} Block#$$.parentScope - Parent scope.\n       * @property {Block|void} Block#$$.parentTemplate - Parent template.\n       * @property {Block|Elem|void} Block#$$.prevBlock - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing the block.\n       */\n      $$: {\n        name,\n        DynamicBlockArgs,\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        Constructor: constructor,\n        htmlChildren: children || [],\n        children: childrenBlocks,\n        mixins: childrenMixins,\n        mixinsToBuild: [],\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forElements, forItem) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forElements = !!forElements;\n\n          const scope = constructor === blocks.Item && !forItem\n            ? this.$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : emptyObject;\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              evalMode = true;\n              gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.func = func;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error(`Uncaught error in ${ name }.onEvalError:`, e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(gettingVars, (watchers) => {\n                const watcher = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved && !this.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forElements,\n                  watcher,\n                  watchers\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(childrenMixins, removeWithParentSignal);\n\n          try {\n            this._beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered && !this.$$.isRemoved) {\n            try {\n              this._afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterDOMChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor.html.vars || [], (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    const {\n      args: argsDescriptions\n    } = constructor;\n    const defaultArgs = getDefaultArgs(argsDescriptions);\n    let args = create(defaultArgs);\n    let wasRest;\n    const argsChain = [defaultArgs, args];\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isRest = value.mixin === mixins.Rest;\n      const localArgs = isRest || wasRest\n        ? create(args)\n        : args;\n\n      if (args !== localArgs) {\n        argsChain.push(localArgs);\n      }\n\n      args = localArgs;\n\n      if (isRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, value);\n          calculateArgs(normalizeArgs(argsChain), args, argsObject);\n        }, this);\n\n        wasRest = true;\n\n        return assign(localArgs, restArgs);\n      }\n\n      wasRest = false;\n\n      if (isInstanceOf(Mixin, value.mixin)) {\n        localArgs[arg] = new InternalMixin({\n          Mixin: value.mixin,\n          args: value.args,\n          value,\n          parentScope,\n          parentTemplate\n        });\n\n        return;\n      }\n\n      const forElements = isElements && arg === 'value';\n\n      localArgs[arg] = parentScope.$$.evaluate(value, (value) => {\n        localArgs[arg] = value;\n        calculateArgs(normalizeArgs(argsChain), args, argsObject);\n      }, this, forElements, isElements && parentBlock.$$.Constructor === blocks.Item);\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(normalizeArgs(argsChain), args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#_afterConstruct\n   * @protected\n   */\n  _afterConstruct() {\n    this.afterConstruct();\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#_afterDOMChange\n   * @protected\n   */\n  _afterDOMChange() {\n    this.afterDOMChange();\n  }\n\n  /**\n   * @method Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed. Note that\n   * it's important not to modify the DOM structure within the block. You can only insert\n   * elements to empty elements (which Dwayne considers empty) and remove ones from them.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @method Block#_afterRender\n   * @protected\n   */\n  _afterRender() {\n    this.afterRender();\n  }\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#_beforeRemove\n   * @protected\n   */\n  _beforeRemove() {\n    this.beforeRemove();\n  }\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getConstructor\n   * @public\n   * @returns {typeof Block}\n   * @description Returns Block constructor.\n   */\n  getConstructor() {\n    return getProto(this).constructor;\n  }\n\n  /**\n   * @method Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#getName\n   * @public\n   * @returns {String}\n   * @description Returns Block name.\n   */\n  getName() {\n    return this.$$.name;\n  }\n\n  /**\n   * @method Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @method Block#getParentScope\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentScope() {\n    return this.$$.parentScope;\n  }\n\n  /**\n   * @method Block#getParentTemplate\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentTemplate() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block, gettingVars, evalMode };\n","import { Block as BaseBlock } from './Block';\n\nclass Block extends BaseBlock {}\n\nexport { Block };\n","import { Block } from '../Block';\n\nclass Case extends Block {}\n\nexport { Case };\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { blocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nclass Elements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, (value) => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forElements }) => {\n        if (forElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n      iterateArray(this.$$.mixinsToBuild, (executeBuilders) => {\n        executeBuilders();\n      });\n      this.$$.mixinsToBuild = [];\n    }, this, true);\n  }\n}\n\nblocks.Elements = Elements;\n\nexport { Elements };\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { Elements } from './Elements';\n\nclass Children extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentTemplate.$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate.$$.parentTemplate}\"\n    />\n  `;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      parentTemplate: {\n        $$: { htmlChildren }\n      }\n    } = this.$$;\n    const { name } = this.args;\n    let found;\n\n    if (name) {\n      found = findInArray(htmlChildren, ({ type, args }) => (\n        type === Children\n        && args\n        && args.name === name\n      ));\n\n      this.elems = found\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = htmlChildren;\n    }\n  }\n}\n\nexport { Children };\n\n","import { Block } from '../Block';\nimport { blocks } from '../constants';\nimport { Elements } from './Elements';\n\nconst watchArgs = js`args.type`;\n\nclass DynamicBlock extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    this.construct(\n      this.evaluate(watchArgs, this.construct)\n    );\n  }\n\n  construct = (type) => {\n    const {\n      htmlChildren,\n      DynamicBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      type,\n      args: DynamicBlockArgs,\n      children: htmlChildren\n    }];\n  };\n}\n\nblocks.DynamicBlock = DynamicBlock;\n\nexport { DynamicBlock };\n","import { Block } from '../Block';\nimport { Elements } from './Elements';\nimport { blocks } from '../constants';\n\nclass Item extends Block {\n  static html = html`\n    <Elements\n      value=\"{$$.htmlChildren}\"\n      parentScope=\"{this}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n}\n\nblocks.Item = Item;\n\nexport default Item;\n","import {\n  iterateArray, iterateObject,\n  isArray, isFunction, create\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport Item from './Item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nclass Each extends Block {\n  static args = {\n    uid: {\n      default(item, index) {\n        return index;\n      }\n    }\n  };\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item = '$item',\n        index = '$index'\n      }\n    } = this;\n\n    this.itemName = item;\n    this.indexName = index;\n    this.itemsByUIDs = create(null);\n  }\n\n  afterConstruct() {\n    this.renderSet(\n      this.evaluate(watchArgs, this.renderSet)\n    );\n  }\n\n  renderSet = (args) => {\n    let set = args[0];\n    let filterBy = args[1];\n    const sortBy = args[2];\n\n    const {\n      htmlChildren,\n      parentScope,\n      parentElem,\n      parentTemplate\n    } = this.$$;\n    const {\n      args: {\n        uid: UID\n      },\n      itemsByUIDs,\n      itemName,\n      indexName\n    } = this;\n    const newItemsByUIDs = create(null);\n    const newUIDsByIndexes = create(null);\n    const newUIDs = create(null);\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      const uid = UID(item, index, set, parentScope);\n\n      if (uid in newUIDsByIndexes) {\n        console.error(`UIDs can't be same for multiple items! In UID function: \"${ UID.original || UID }\"`);\n      }\n\n      newUIDsByIndexes[uid] = index;\n      newUIDs[index] = uid;\n    });\n\n    iterateObject(itemsByUIDs, (block, uid) => {\n      if (!(uid in newUIDsByIndexes)) {\n        remove(block);\n      }\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (newUIDsByIndexes[uid] !== index) {\n        return;\n      }\n\n      const prevUIDBlock = itemsByUIDs[uid];\n\n      if (prevUIDBlock) {\n        block = prevUIDBlock;\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        if (block.$$.prevBlock !== prevBlock) {\n          const { content } = block.$$;\n\n          if (prevBlock) {\n            prevBlock.$$.insertAfterIt(content, true);\n          } else {\n            this.$$.insertInStartOfIt(content, true);\n          }\n        }\n      } else {\n        block = createBlock({\n          node: {\n            type: Item,\n            itemName,\n            indexName,\n            item,\n            index,\n            children: htmlChildren\n          },\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      newItemsByUIDs[uid] = block;\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.itemsByUIDs = newItemsByUIDs;\n  };\n}\n\nexport { Each };\n","import { Block } from '../Block';\nimport { Elements } from './Elements';\n\nconst watchArgs = js`args.if`;\n\nclass If extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    this.condition = false;\n    this.constructElems(this.evaluate(watchArgs, this.constructElems));\n  }\n\n  constructElems = (condition) => {\n    condition = !!condition;\n\n    if (this.condition !== condition) {\n      this.condition = condition;\n      this.elems = condition\n        ? this.$$.htmlChildren\n        : null;\n    }\n  };\n}\n\nexport { If };\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { Elements } from './Elements';\nimport { Case } from './Case';\n\nconst watchArgs = js`[\n  args.value,\n  args.compareFn\n]`;\n\nclass Switch extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n  static args = {\n    default: {\n      default: false\n    },\n    compareFn: {\n      default(switchValue, caseValue) {\n        return (\n          switchValue === caseValue\n          || (switchValue !== switchValue && caseValue !== caseValue)\n        );\n      }\n    }\n  };\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren,\n        parentScope\n      },\n      args: switchArgs,\n      args: { value }\n    } = this;\n    let wasDefault = false;\n\n    this.values = htmlChildren\n      .filter(({ type, args }) => {\n        if (type !== Case) {\n          return;\n        }\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (args && args.default) {\n          wasDefault = true;\n        }\n\n        return true;\n      })\n      .map((child, i) => {\n        const {\n          args = {},\n          children\n        } = child;\n        let val;\n\n        if (!args.default) {\n          val = parentScope.$$.evaluate(args.when, (newValue) => {\n            this.values[i].value = newValue;\n\n            if (i > this.index) {\n              return;\n            }\n\n            const found = findInArray(this.values, ({ args, value }) => (\n              args.default\n              || this.args.compareFn(switchArgs.value, value)\n            ));\n\n            this.index = found\n              ? found.key\n              : Infinity;\n            this.elems = found\n              ? found.value.children\n              : null;\n          }, this);\n        }\n\n        if (this.index === Infinity && (\n          args.default\n          || this.args.compareFn(value, val)\n        )) {\n          this.index = i;\n          this.elems = children;\n        }\n\n        return {\n          args,\n          children,\n          value: val\n        };\n      });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, (args) => {\n      const newValue = args[0];\n      const compareFn = args[1];\n\n      this.index = Infinity;\n\n      this.values.some(({ args, value, children }, i) => {\n        if (\n          args.default\n          || compareFn(newValue, value)\n        ) {\n          this.index = i;\n          this.elems = children;\n\n          return true;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n}\n\nexport { Switch };\n","import { isFunction, noop } from '../utils';\nimport { Mixin } from '../Mixin';\n\nclass Bind extends Mixin {\n  off = noop;\n\n  afterUpdate(value) {\n    this.off();\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"Bind\" mixin with event name args (like \"Bind(click)\" or \"Bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n}\n\nexport { Bind };\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nclass Class extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        classes\n      } = this;\n\n      elem.removeClass.apply(elem, classes);\n    }\n  }\n}\n\nexport { Class };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\n\nclass Elem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n}\n\nexport { Elem as ElemMixin };\n","import { Mixin } from '../Mixin';\n\nclass Hide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n}\n\nexport { Hide };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\n\nclass Node extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n}\n\nexport { Node as NodeMixin };\n","import { noop } from '../utils';\nimport { Mixin } from '../Mixin';\n\nclass On extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"On\" mixin with event name args (like \"On(click)\" or \"On(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n}\n\nexport { On };\n","import { Mixin } from '../Mixin';\nimport { mixins } from '../constants';\n\nclass Rest extends Mixin {}\n\nmixins.Rest = Rest;\n\nexport { Rest };\n","import { Mixin } from '../Mixin';\n\nclass Show extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n}\n\nexport { Show };\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\nimport { document } from './constants';\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","isFunction","isNil","isString","assign","target","arguments","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","noop","toCamelCase","replace","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","toStringTag","toString","setToStringTag","klass","tag","Symbol","prototype","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","isXmlNs","nodeName","Null","XML_NS","X_LINK_ATTR_FIND_REGEX","test","Elem","closest","X_LINK_NS","X_LINK_ATTR_REPLACE_REGEX","isDocument","DOCUMENT_REGEX","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isValidNode","ELEMENT_REGEX","getEvent","event","bubbles","cancelable","realDetails","finalEvent","EVENT_REGEX","Event","err","document","ownerDocument","createEvent","initEvent","hide","addClass","getMatchesFunction","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","this","querySelectorAll","remove","parent","removeChild","show","removeClass","toElem","base","String","calculateArgs","normalizedArgs","args","argsObject","keys","arg","undefined","cleanProperty","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","calculateAttrs","newAttrs","currentAttrs","currentMixins","parentBlock","firstTime","InternalMixin","removeAttr","mixins","prevValue","parentScope","Mixin","evalFn","newValue","internal","internals","push","evaluate","constructMixinWatcher","buildMixin","afterUpdate","error","internalMixin","builder","normalizeArgs","argsChain","newArgs","constructPrivateScope","type","scope","globals","removeTempWatcher","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","evalMode","gettingVars","oldTempWatchers","isInstanceOf","Class","Subclass","isPrototypeOf","createBlock","node","parentElem","parentTemplate","prevBlock","doc","isElements","blocks","Elements","children","constructor","DynamicBlockArgs","DynamicBlock","Block","html","Error","namespaceURI","SVG_NS","wasRest","attrsChain","isRest","Rest","localAttrs","restAttrs","mixinsToBuild","isParentBlock","childBlocks","on","iterateChildren","isRoot","child","content","into","contentDocument","documentElement","insertAfterIt","insertAfter","addContent","insertInStartOfIt","createDocumentFragment","emptyArray","blockInstance","Args","locals","Item","itemName","item","indexName","Constructor","_afterConstruct","isRendered","executeBuilders","_afterRender","extendBlock","block","newBlock","currentBlock","proto","getProto","extend","BaseBlock","getDefaultArgs","argsDescriptions","def","default","removeWithParentSignal","wrapBlock","wrapper","wrapMixin","newMixin","constructStyleFromString","style","CSS_STYLE_SEPARATOR_REGEX","trim","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","values","options","init","isMultiple","addValue","concat","getListenerName","selected","insertHtml","templates","newTemplates","newVars","iterateAndChangeChildren","nodes","trimmed","newTemplate","initApp","container","RootBlock","rootBlock","removeApp","DwayneRootBlock","window","global","self","Array","defineProperties","Object","getPrototypeOf","setProto","setPrototypeOf","__proto__","CSS_IMPORTANT_REGEX","emptyCollection","_this","includes","methodName","method","elems","elements","classes","forEach","list","classList","cls","attributes","ns","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","cb","element","contains","el","isText","createTextNode","createComment","createElementNS","createElement","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","details","dispatchEvent","filter","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","props","first","prev","babelHelpers.get","apply","textContent","condition","_arguments","_arguments2","species","opts","displayName","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","isElementRemoved","afterElem","emptyObject","originalArgs","childrenBlocks","childrenMixins","func","onChange","targetBlock","forElements","forItem","onChangeFlag","result","original","onEvalError","e","localWatchers","watcherBlock","newResult","_beforeRemove","removeContent","newContent","_afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","afterConstruct","afterDOMChange","afterRender","Case","watchArgs","_this2","Children","htmlChildren","found","construct","Each","itemsByUIDs","renderSet","set","filterBy","sortBy","UID","uid","newItemsByUIDs","newUIDsByIndexes","newUIDs","isArr","iterate","sort","prevUIDBlock","If","constructElems","Switch","Infinity","switchArgs","wasDefault","map","val","when","compareFn","some","switchValue","caseValue","Bind","off","join","newClasses","Hide","Node","On","Show","Style","Boolean","Value","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvaXMuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL25vb3AuanMiLCIuLi9zcmMvdXRpbHMvdG9DYXNlLmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRBdHRyLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRDU1NQcm9wLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGREYXRhQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkTmV4dC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUGFyZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRQcmV2LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9jcmVhdGVIaWRlU3R5bGVOb2RlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRBdHRyTlMuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRFdmVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaGlkZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vbWF0Y2hlcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9zaG93LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS90b0VsZW0uanMiLCIuLi9zcmMvZmluZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jbGVhblByb3BlcnR5LmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svZXhlY3V0ZU1peGluV2F0Y2hlcnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jYWxjdWxhdGVBdHRycy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL25vcm1hbGl6ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jb25zdHJ1Y3RQcml2YXRlU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9yZW1vdmVXYXRjaGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0UHVibGljU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9pc0luc3RhbmNlT2YuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jcmVhdGVCbG9jay5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2V4dGVuZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2dldERlZmF1bHRBcmdzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svd3JhcC5qcyIsIi4uL3NyYy9taXhpbnMvU3R5bGUuanMiLCIuLi9zcmMvbWl4aW5zL1ZhbHVlLmpzIiwiLi4vc3JjL2luc2VydEh0bWwuanMiLCIuLi9zcmMvaW5pdEFwcC5qcyIsIi4uL3NyYy9yZW1vdmVBcHAuanMiLCIuLi9zcmMvZ2xvYmFsLmpzIiwiLi4vc3JjL2NvbnN0YW50cy5qcyIsIi4uL3NyYy91dGlscy9vYmplY3RTdGF0aWNzLmpzIiwiLi4vc3JjL0VsZW0uanMiLCIuLi9zcmMvdXRpbHMvc2V0U3ltYm9sU3BlY2llcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL0ludGVybmFsTWl4aW4uanMiLCIuLi9zcmMvTWl4aW4uanMiLCIuLi9zcmMvQmxvY2suanMiLCIuLi9zcmMvQmxvY2tQdWJsaWMuanMiLCIuLi9zcmMvYmxvY2tzL0Nhc2UuanMiLCIuLi9zcmMvYmxvY2tzL0VsZW1lbnRzLmpzIiwiLi4vc3JjL2Jsb2Nrcy9DaGlsZHJlbi5qcyIsIi4uL3NyYy9ibG9ja3MvRHluYW1pY0Jsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9JdGVtLmpzIiwiLi4vc3JjL2Jsb2Nrcy9FYWNoLmpzIiwiLi4vc3JjL2Jsb2Nrcy9JZi5qcyIsIi4uL3NyYy9ibG9ja3MvU3dpdGNoLmpzIiwiLi4vc3JjL21peGlucy9CaW5kLmpzIiwiLi4vc3JjL21peGlucy9DbGFzcy5qcyIsIi4uL3NyYy9taXhpbnMvRWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvSGlkZS5qcyIsIi4uL3NyYy9taXhpbnMvTm9kZS5qcyIsIi4uL3NyYy9taXhpbnMvT24uanMiLCIuLi9zcmMvbWl4aW5zL1Jlc3QuanMiLCIuLi9zcmMvbWl4aW5zL1Nob3cuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiZXhwb3J0IGNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbiIsImNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuY29uc3QgeyBzbGljZSB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGZvciAobGV0IGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpdGVyYXRlT2JqZWN0KGFyZ3VtZW50c1tpXSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdEZyb21PYmplY3Qob2JqZWN0LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlID0ge30pIHtcbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY2FsbGJhY2soaW5pdGlhbFZhbHVlLCB2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhjZXB0KG9iamVjdCkge1xuICBjb25zdCBuZXdPYmplY3QgPSB7fTtcbiAgY29uc3QgcGF0aHMgPSBhcmd1bWVudHM6OnNsaWNlKDEpO1xuXG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmIChwYXRocy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBuZXdPYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3Q6OmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXRlcmF0ZU9iamVjdChvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkpIHtcbiAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBjYWxsYmFjaykge1xuICBjb25zdCBuZXdPYmplY3QgPSB7fTtcblxuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBuZXdPYmplY3Rba2V5XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0IH0gZnJvbSAnLi9vYmplY3QnO1xuXG5leHBvcnQgY29uc3QgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImltcG9ydCB7IGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3Q6OnRvU3RyaW5nKCkuc2xpY2UoOCwgLTEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG9TdHJpbmdUYWcoa2xhc3MsIHRhZykge1xuICBpZiAoU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyhrbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiB0YWdcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZEF0dHIoYXR0cnMsIGF0dHIpIHtcbiAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG59XG4iLCJpbXBvcnQgeyB0b0NhbWVsQ2FzZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuY29uc3QgQ1NTX1BST1BfVkFMVUVfU0VQQVJBVE9SX1JFR0VYID0gLzogLztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENTU1Byb3AoY3NzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHZhbHVlLnNwbGl0KENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCk7XG5cbiAgICBjc3NbdG9DYW1lbENhc2UocHJvcGVydHlbMF0pXSA9IHByb3BlcnR5WzFdO1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkRGF0YUF0dHIoZGF0YSwgdmFsdWUsIGtleSkge1xuICBkYXRhW2tleV0gPSB2YWx1ZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGROZXh0KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5uZXh0U2libGluZyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUGFyZW50KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wYXJlbnROb2RlKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRQcmV2KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wcmV2aW91c1NpYmxpbmcpO1xufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpIHtcbiAgY29uc3Qgc3R5bGUgPSBoZWFkLmZpbmQoYHN0eWxlIyR7IEhJREVfQ0xBU1MgfWApO1xuXG4gIGlmIChzdHlsZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoZWFkXG4gICAgLmNyZWF0ZSgnc3R5bGUnKVxuICAgIC5wcm9wKCdpZCcsIEhJREVfQ0xBU1MpXG4gICAgLnRleHQoYC4keyBISURFX0NMQVNTIH17ZGlzcGxheTpub25lICFpbXBvcnRhbnQ7fWApO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5jb25zdCBYX0xJTktfQVRUUl9GSU5EX1JFR0VYID0gL154bGluazpcXHcvO1xuY29uc3QgWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCA9IC9eeGxpbms6LztcbmNvbnN0IFhNTF9OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XG5jb25zdCBYX0xJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBOdWxsID0ge1xuICBuczogbnVsbFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJOUyhhdHRyLCBlbGVtKSB7XG4gIGNvbnN0IGlzWG1sTnMgPSBhdHRyID09PSAneG1sbnMnO1xuXG4gIGlmIChpc1htbE5zIHx8IGF0dHIgPT09ICd4bWxuczp4bGluaycpIHtcbiAgICBpZiAoZWxlbS5ub2RlTmFtZSAhPT0gJ1NWRycpIHtcbiAgICAgIHJldHVybiBOdWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuczogWE1MX05TLFxuICAgICAgbmFtZTogaXNYbWxOc1xuICAgICAgICA/ICd4bWxucydcbiAgICAgICAgOiAneGxpbmsnXG4gICAgfTtcbiAgfVxuXG4gIGlmIChYX0xJTktfQVRUUl9GSU5EX1JFR0VYLnRlc3QoYXR0cikpIHtcbiAgICBpZiAoIW5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJ3N2ZycpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIE51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5zOiBYX0xJTktfTlMsXG4gICAgICBuYW1lOiBhdHRyLnJlcGxhY2UoWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCwgJycpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBOdWxsO1xufVxuIiwiaW1wb3J0IHsgdG9TdHJpbmdUYWcsIGlzQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmNvbnN0IEhUTUxfQ09MTEVDVElPTl9SRUdFWCA9IC9eKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0KSQvO1xuY29uc3QgRE9DVU1FTlRfUkVHRVggPSAvRG9jdW1lbnQkLztcbmNvbnN0IEVMRU1FTlRfUkVHRVggPSAvRWxlbWVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEb2N1bWVudCh2YWx1ZSkge1xuICByZXR1cm4gRE9DVU1FTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRzQ29sbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIEhUTUxfQ09MTEVDVElPTl9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKHZhbHVlKSlcbiAgICB8fCBpc0VsZW0odmFsdWUpXG4gICAgfHwgaXNBcnJheSh2YWx1ZSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROb2RlKHZhbHVlKSB7XG4gIGNvbnN0IHRhZyA9IHRvU3RyaW5nVGFnKHZhbHVlKTtcblxuICByZXR1cm4gKFxuICAgIEVMRU1FTlRfUkVHRVgudGVzdCh0YWcpXG4gICAgfHwgRE9DVU1FTlRfUkVHRVgudGVzdCh0YWcpXG4gICAgfHwgdGFnID09PSAnVGV4dCdcbiAgICB8fCB0YWcgPT09ICdEb2N1bWVudEZyYWdtZW50J1xuICAgIHx8IHRhZyA9PT0gJ0NvbW1lbnQnXG4gICk7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24sIHRvU3RyaW5nVGFnIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4vaXMnO1xuXG5jb25zdCBFVkVOVF9SRUdFWCA9IC9FdmVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHJlYWxEZXRhaWxzLCBlbGVtKSB7XG4gIGxldCBmaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgaWYgKCFFVkVOVF9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKGZpbmFsRXZlbnQpKSkge1xuICAgIHRyeSB7XG4gICAgICBmaW5hbEV2ZW50ID0gbmV3IEV2ZW50KGZpbmFsRXZlbnQsIHsgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbiAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBmaW5hbEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBmaW5hbEV2ZW50LmluaXRFdmVudChldmVudCwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cbiAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsRXZlbnQ7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVIaWRlU3R5bGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVIaWRlU3R5bGVOb2RlJztcbmltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaGlkZShlbGVtKSB7XG4gIGNyZWF0ZUhpZGVTdHlsZU5vZGUobmV3IEVsZW0oZWxlbS5vd25lckRvY3VtZW50LmhlYWQpKTtcbiAgbmV3IEVsZW0oZWxlbSkuYWRkQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0RvY3VtZW50IH0gZnJvbSAnLi9pcyc7XG5cbmNvbnN0IHsgaW5kZXhPZiB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSkge1xuICByZXR1cm4gKFxuICAgIGVsZW0ubWF0Y2hlc1xuICAgIHx8IGVsZW0ubWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm1vek1hdGNoZXNTZWxlY3RvclxuICAgIHx8IGVsZW0ubXNNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm9NYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBtYXRjaGVzXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcbiAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KHRoaXMpXG4gICAgPyB0aGlzXG4gICAgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOjppbmRleE9mKHRoaXMpICE9PSAtMTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWxlbSkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93KGVsZW0pIHtcbiAgbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0VsZW0gfSBmcm9tICcuL2lzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvRWxlbShlbGVtKSB7XG4gIHJldHVybiBpc0VsZW0oZWxlbSlcbiAgICA/IGVsZW1cbiAgICA6IG5ldyBFbGVtKGVsZW0pO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZmluZFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBbYmFzZSA9IGRvY3VtZW50XSAtIEJhc2UgdG8gZmluZCBpbi5cbiAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICogW0RvY3VtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGJhc2UgPSBkb2N1bWVudCkge1xuICByZXR1cm4gbmV3IEVsZW0oYmFzZS5xdWVyeVNlbGVjdG9yQWxsKFN0cmluZyhzZWxlY3RvcikpKTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCwga2V5cyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFyZ3Mobm9ybWFsaXplZEFyZ3MsIGFyZ3MsIGFyZ3NPYmplY3QpIHtcbiAgaXRlcmF0ZUFycmF5KGtleXMoYXJnc09iamVjdCksIChhcmcpID0+IHtcbiAgICBpZiAoIShhcmcgaW4gYXJncykpIHtcbiAgICAgIGFyZ3NPYmplY3RbYXJnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIGl0ZXJhdGVPYmplY3Qobm9ybWFsaXplZEFyZ3MsICh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgYXJnc09iamVjdFthcmddID0gdmFsdWU7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsZWFuUHJvcGVydHkodmFsdWUsIGFyZywgb2JqZWN0KSB7XG4gIGRlbGV0ZSBvYmplY3RbYXJnXTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSkge1xuICBjb25zdCBvbGRWYWx1ZSA9IG1peGluLiQkLnZhbHVlO1xuXG4gIG1peGluLiQkLnZhbHVlID0gdmFsdWU7XG5cbiAgaXRlcmF0ZUFycmF5KG1peGluLiQkLndhdGNoZXJzLCAod2F0Y2hlcikgPT4ge1xuICAgIHdhdGNoZXIodmFsdWUsIG9sZFZhbHVlKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXksIGhhc093blByb3BlcnR5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZXhlY3V0ZU1peGluV2F0Y2hlcnMgfSBmcm9tICcuL2V4ZWN1dGVNaXhpbldhdGNoZXJzJztcbmltcG9ydCB7IEludGVybmFsTWl4aW4gfSBmcm9tICcuL0ludGVybmFsTWl4aW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXR0cnMoe1xuICBuZXdBdHRycywgY3VycmVudEF0dHJzLCBjdXJyZW50TWl4aW5zLFxuICBlbGVtLCBwYXJlbnRCbG9jaywgZmlyc3RUaW1lXG59KSB7XG4gIGl0ZXJhdGVPYmplY3QoY3VycmVudEF0dHJzLCAodmFsdWUsIGF0dHIpID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KG5ld0F0dHJzLCBhdHRyKSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJuYWxNaXhpbikge1xuICAgICAgICBjdXJyZW50TWl4aW5zW2F0dHJdLiQkLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgY3VycmVudE1peGluc1thdHRyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGN1cnJlbnRBdHRyc1thdHRyXTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG1peGlucyA9IFtdO1xuXG4gIGl0ZXJhdGVPYmplY3QobmV3QXR0cnMsICh2YWx1ZSwgYXR0cikgPT4ge1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9IGN1cnJlbnRBdHRyc1thdHRyXTtcblxuICAgIGlmIChwcmV2VmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJuYWxNaXhpbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgTWl4aW4sXG4gICAgICAgIHZhbHVlOiBldmFsRm5cbiAgICAgIH0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHByZXZWYWx1ZSkge1xuICAgICAgICBjb25zdCBtaXhpbiA9IGN1cnJlbnRNaXhpbnNbYXR0cl07XG4gICAgICAgIGNvbnN0IHsgJCQgfSA9IG1peGluO1xuICAgICAgICBsZXQgbmV3VmFsdWU7XG5cbiAgICAgICAgJCQuaW50ZXJuYWwgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoJCQuaW50ZXJuYWxzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICQkLmludGVybmFscy5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShcbiAgICAgICAgICAgICAgZXZhbEZuLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RNaXhpbldhdGNoZXIobWl4aW4sIHZhbHVlKSxcbiAgICAgICAgICAgICAgbWl4aW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShldmFsRm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVpbGRNaXhpbiA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtaXhpbiA9IG5ldyBNaXhpbih7XG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgIGludGVybmFsOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHsgJCQgfSA9IG1peGluO1xuXG4gICAgICAgICAgJCQuaW50ZXJuYWwgPSB2YWx1ZTtcbiAgICAgICAgICAkJC5pbnRlcm5hbHMgPSBbdmFsdWVdO1xuICAgICAgICAgIGN1cnJlbnRNaXhpbnNbYXR0cl0gPSBtaXhpbjtcblxuICAgICAgICAgIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJVcGRhdGUgPSAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWl4aW4uYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgJCQubmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQkLnZhbHVlID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoXG4gICAgICAgICAgICAgIGV2YWxGbixcbiAgICAgICAgICAgICAgY29uc3RydWN0TWl4aW5XYXRjaGVyKG1peGluLCB2YWx1ZSksXG4gICAgICAgICAgICAgIG1peGluXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWZ0ZXJVcGRhdGUoJCQuZXZhbHVhdGUoYWZ0ZXJVcGRhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgIG1peGlucy5wdXNoKGJ1aWxkTWl4aW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkTWl4aW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRBdHRyc1thdHRyXSA9IHZhbHVlO1xuICB9KTtcblxuICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIGJ1aWxkTWl4aW4pO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0TWl4aW5XYXRjaGVyKG1peGluLCBpbnRlcm5hbE1peGluKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICBpZiAobWl4aW4uJCQuaW50ZXJuYWwgPT09IGludGVybmFsTWl4aW4pIHtcbiAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZE1peGluKGJ1aWxkZXIpIHtcbiAgYnVpbGRlcigpO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQXJncyhhcmdzQ2hhaW4pIHtcbiAgY29uc3QgbmV3QXJncyA9IHt9O1xuXG4gIGl0ZXJhdGVBcnJheShhcmdzQ2hhaW4sIChhcmdzKSA9PiB7XG4gICAgaXRlcmF0ZU9iamVjdChhcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgbmV3QXJnc1thcmddID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdBcmdzO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlLCBjb2xsZWN0RnJvbU9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IGNyZWF0ZShcbiAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgID8gcGFyZW50U2NvcGUuJCQuZ2xvYmFsc1xuICAgICAgICA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IFtdXG4gICAgfTtcbiAgfSwgc2NvcGUpO1xufVxuIiwiaW1wb3J0IHsgcmVtb3ZlQXJyYXlFbGVtLCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUZW1wV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHdhdGNoZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcbiAgaXRlcmF0ZUFycmF5KHdhdGNoZXJzVG9SZW1vdmUsIHJlbW92ZVdhdGNoZXIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVXYXRjaGVyKHsgd2F0Y2hlciwgd2F0Y2hlcnMgfSkge1xuICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgbWFwT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBnZXR0aW5nVmFycywgZXZhbE1vZGUgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyByZW1vdmVUZW1wV2F0Y2hlciB9IGZyb20gJy4vcmVtb3ZlV2F0Y2hlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCBtYXBPYmplY3Qoc2NvcGVWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKGdldHRpbmdWYXJzLmluZGV4T2Yoc2NvcGUud2F0Y2hlcnMpID09PSAtMSkge1xuICAgICAgICAgICAgZ2V0dGluZ1ZhcnMucHVzaChzY29wZS53YXRjaGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHNjb3BlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2xkVGVtcFdhdGNoZXJzID0gc2NvcGUud2F0Y2hlcnMuc2xpY2UoKTtcblxuICAgICAgICBzY29wZS53YXRjaGVycyA9IFtdO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheShvbGRUZW1wV2F0Y2hlcnMsIHJlbW92ZVRlbXBXYXRjaGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSk7XG59XG4iLCJjb25zdCB7IGlzUHJvdG90eXBlT2YgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKENsYXNzLCBTdWJjbGFzcykge1xuICByZXR1cm4gQ2xhc3M6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MpICYmIENsYXNzLnByb3RvdHlwZTo6aXNQcm90b3R5cGVPZihTdWJjbGFzcy5wcm90b3R5cGUpO1xufVxuIiwiaW1wb3J0IHtcbiAgZXhjZXB0LCBjcmVhdGUsIGFzc2lnbixcbiAgaXRlcmF0ZU9iamVjdCwgaXRlcmF0ZUFycmF5LFxuICBpc05pbCwgaXNTdHJpbmcsIGlzQXJyYXlcbn0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuaW1wb3J0IHsgU1ZHX05TLCBibG9ja3MsIG1peGlucyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjbGVhblByb3BlcnR5IH0gZnJvbSAnLi9jbGVhblByb3BlcnR5JztcbmltcG9ydCB7IGNhbGN1bGF0ZUF0dHJzIH0gZnJvbSAnLi9jYWxjdWxhdGVBdHRycyc7XG5pbXBvcnQgeyBub3JtYWxpemVBcmdzIH0gZnJvbSAnLi9ub3JtYWxpemVBcmdzJztcbmltcG9ydCB7IGNvbnN0cnVjdFByaXZhdGVTY29wZSB9IGZyb20gJy4vY29uc3RydWN0UHJpdmF0ZVNjb3BlJztcbmltcG9ydCB7IGNvbnN0cnVjdFB1YmxpY1Njb3BlIH0gZnJvbSAnLi9jb25zdHJ1Y3RQdWJsaWNTY29wZSc7XG5pbXBvcnQgeyBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2lzSW5zdGFuY2VPZic7XG5pbXBvcnQgeyBJbnRlcm5hbE1peGluIH0gZnJvbSAnLi9JbnRlcm5hbE1peGluJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi8uLi9NaXhpbic7XG5cbmNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHsgbm9kZSwgcGFyZW50LCBwYXJlbnRFbGVtLCBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUsIHBhcmVudFRlbXBsYXRlLCBwcmV2QmxvY2sgfSkge1xuICBjb25zdCBkb2MgPSBpc0RvY3VtZW50KHBhcmVudEVsZW1bMF0pXG4gICAgPyBwYXJlbnRFbGVtXG4gICAgOiBuZXcgRWxlbShwYXJlbnRFbGVtWzBdLm93bmVyRG9jdW1lbnQpO1xuICBjb25zdCBhcmdzID0gbm9kZS5hcmdzIHx8IHt9O1xuICBjb25zdCB7IHR5cGUgfSA9IG5vZGU7XG4gIGNvbnN0IGlzRWxlbWVudHMgPSB0eXBlID09PSBibG9ja3MuRWxlbWVudHM7XG4gIGxldCB7IGNoaWxkcmVuIH0gPSBub2RlO1xuICBsZXQgY29uc3RydWN0b3IgPSAhaXNTdHJpbmcodHlwZSkgJiYgdHlwZTtcbiAgbGV0IER5bmFtaWNCbG9ja0FyZ3M7XG5cbiAgaWYgKHR5cGUgPT09IGJsb2Nrcy5EeW5hbWljQmxvY2spIHtcbiAgICBEeW5hbWljQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICd0eXBlJyk7XG4gIH1cblxuICBpZiAoaXNBcnJheShjb25zdHJ1Y3RvcikpIHtcbiAgICBjb25zdHJ1Y3RvciA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgc3RhdGljIGh0bWwgPSBjb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFpc0luc3RhbmNlT2YoQmxvY2ssIGNvbnN0cnVjdG9yKSAmJiAhaXNTdHJpbmcodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGJsb2NrIHR5cGUgZ2l2ZW46ICR7IHR5cGUgfWApO1xuICB9XG5cbiAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgY29uc3QgZWxlbSA9IChcbiAgICAgIHBhcmVudEVsZW1bMF0ubmFtZXNwYWNlVVJJID09PSBTVkdfTlNcbiAgICAgICAgPyBkb2MuY3JlYXRlKCdzdmcnKVxuICAgICAgICA6IGRvY1xuICAgICkuY3JlYXRlKHR5cGUpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBjdXJyZW50TWl4aW5zID0gY3JlYXRlKG51bGwpO1xuICAgIGxldCBhdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgd2FzUmVzdDtcbiAgICBjb25zdCBhdHRyc0NoYWluID0gW2F0dHJzXTtcblxuICAgIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBpc1Jlc3QgPSB2YWx1ZS5taXhpbiA9PT0gbWl4aW5zLlJlc3Q7XG4gICAgICBjb25zdCBsb2NhbEF0dHJzID0gaXNSZXN0IHx8IHdhc1Jlc3RcbiAgICAgICAgPyBjcmVhdGUoYXR0cnMpXG4gICAgICAgIDogYXR0cnM7XG5cbiAgICAgIGlmIChhdHRycyAhPT0gbG9jYWxBdHRycykge1xuICAgICAgICBhdHRyc0NoYWluLnB1c2gobG9jYWxBdHRycyk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzID0gbG9jYWxBdHRycztcblxuICAgICAgaWYgKGlzUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXR0cnMgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZU9iamVjdChsb2NhbEF0dHJzLCBjbGVhblByb3BlcnR5KTtcbiAgICAgICAgICBhc3NpZ24obG9jYWxBdHRycywgdmFsdWUpO1xuICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKHtcbiAgICAgICAgICAgIG5ld0F0dHJzOiBub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLFxuICAgICAgICAgICAgY3VycmVudEF0dHJzLFxuICAgICAgICAgICAgY3VycmVudE1peGlucyxcbiAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgICAgIGZpcnN0VGltZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICAgIHdhc1Jlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBdHRycywgcmVzdEF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgd2FzUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNJbnN0YW5jZU9mKE1peGluLCB2YWx1ZS5taXhpbikpIHtcbiAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IG5ldyBJbnRlcm5hbE1peGluKHtcbiAgICAgICAgICBNaXhpbjogdmFsdWUubWl4aW4sXG4gICAgICAgICAgYXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgY2FsY3VsYXRlQXR0cnMoe1xuICAgICAgICAgIG5ld0F0dHJzOiBub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLFxuICAgICAgICAgIGN1cnJlbnRBdHRycyxcbiAgICAgICAgICBjdXJyZW50TWl4aW5zLFxuICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgICAgZmlyc3RUaW1lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0sIHBhcmVudEJsb2NrKTtcbiAgICB9KTtcblxuICAgIHBhcmVudEJsb2NrLiQkLm1peGluc1RvQnVpbGQucHVzaChjYWxjdWxhdGVBdHRycyh7XG4gICAgICBuZXdBdHRyczogbm9ybWFsaXplQXJncyhhdHRyc0NoYWluKSxcbiAgICAgIGN1cnJlbnRBdHRycyxcbiAgICAgIGN1cnJlbnRNaXhpbnMsXG4gICAgICBlbGVtLFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICB9KSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgZWxlbS50ZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgbGV0IHRleHQgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS50ZXh0KGAkeyB2YWx1ZSB9YCk7XG4gICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgIGlmIChpc05pbCh0ZXh0KSkge1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGVsZW0udGV4dChgJHsgdGV4dCB9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuICAgIGNvbnN0IGNoaWxkQmxvY2tzID0gW107XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZSA9PT0gJ2lmcmFtZScgJiYgISgnc3JjJyBpbiBhdHRycykpIHtcbiAgICAgIGVsZW0ub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbVswXS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuICAgICAgICBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnJlbW92ZSgpO1xuICAgICAgICBpdGVyYXRlQ2hpbGRyZW4oY2hpbGRCbG9ja3MsIHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVDaGlsZHJlbihjaGlsZHJlbiwgaXNSb290KSB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC4kJC5wYXJlbnRFbGVtID0gZG9jO1xuICAgICAgICAgICAgICAgIGNoaWxkLiQkLnBhcmVudCA9IGRvYztcbiAgICAgICAgICAgICAgICBjaGlsZC4kJC5jb250ZW50LmludG8oZG9jKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGl0ZXJhdGVDaGlsZHJlbihjaGlsZC4kJC5jaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGQuaW50byhkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGVsZW0sIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgZWxlbS5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChlbGVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChlbGVtLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZXQgcHJldkJsb2NrO1xuICAgICAgbGV0IHBhcmVudEVsZW0gPSBlbGVtO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0eXBlID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShlbGVtWzBdLmNvbnRlbnQgPSBlbGVtWzBdLmNvbnRlbnQgfHwgZG9jWzBdLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAgIGlmICgnc3JjJyBpbiBhdHRycykge1xuICAgICAgICAgIGNoaWxkcmVuID0gZW1wdHlBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGVsZW1bMF0uY29udGVudERvY3VtZW50O1xuXG4gICAgICAgICAgbmV3IEVsZW0oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5yZW1vdmUoKTtcblxuICAgICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRCbG9ja3MucHVzaChwcmV2QmxvY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICBjb25zdCBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcbiAgICBhcmdzLFxuICAgIER5bmFtaWNCbG9ja0FyZ3MsXG4gICAgY2hpbGRyZW4sXG4gICAgcGFyZW50LFxuICAgIHBhcmVudEVsZW0sXG4gICAgcGFyZW50QmxvY2ssXG4gICAgcGFyZW50U2NvcGUsXG4gICAgcGFyZW50VGVtcGxhdGUsXG4gICAgcHJldkJsb2NrXG4gIH0pO1xuICBjb25zdCB7XG4gICAgJCQsXG4gICAgJCQ6IHsgbmFtZSB9LFxuICAgIGFyZ3M6IEFyZ3MsXG4gICAgZ2xvYmFscyxcbiAgICAuLi5sb2NhbHNcbiAgfSA9IGJsb2NrSW5zdGFuY2U7XG5cbiAgY29uc3QgaHRtbCA9IGlzRWxlbWVudHNcbiAgICA/IEFyZ3MudmFsdWUgfHwgW11cbiAgICA6IGNvbnN0cnVjdG9yLmh0bWw7XG5cbiAgJCQuYXJncyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShBcmdzKTtcbiAgJCQubG9jYWxzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGxvY2Fscyk7XG4gICQkLmdsb2JhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoZ2xvYmFscywgJ2dsb2JhbHMnLCBwYXJlbnRTY29wZSk7XG5cbiAgaWYgKHR5cGUgPT09IGJsb2Nrcy5JdGVtKSB7XG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcbiAgICAgIFtub2RlLmluZGV4TmFtZV06IG5vZGUuaW5kZXhcbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gcGFyZW50U2NvcGUuJCQuQ29uc3RydWN0b3IgPT09IGJsb2Nrcy5JdGVtXG4gICAgICA/IHBhcmVudFNjb3BlLiQkLnNjb3BlXG4gICAgICA6IHBhcmVudFNjb3BlO1xuXG4gICAgJCQucHJpdmF0ZVNjb3BlID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKHNjb3BlVmFsdWVzKTtcbiAgICBjb25zdHJ1Y3RQdWJsaWNTY29wZSgkJC5zY29wZSA9IGNyZWF0ZShzY29wZSksIHNjb3BlVmFsdWVzLCAkJC5wcml2YXRlU2NvcGUpO1xuICB9XG5cbiAgY29uc3RydWN0UHVibGljU2NvcGUoQXJncywgQXJncywgJCQuYXJncyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGdsb2JhbHMsIGdsb2JhbHMsICQkLmdsb2JhbHMpO1xuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShibG9ja0luc3RhbmNlLCBsb2NhbHMsICQkLmxvY2Fscyk7XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLl9hZnRlckNvbnN0cnVjdCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYWZ0ZXJDb25zdHJ1Y3Q6YCwgZXJyKTtcbiAgfVxuXG4gIHByZXZCbG9jayA9IHVuZGVmaW5lZDtcbiAgcGFyZW50U2NvcGUgPSBpc0VsZW1lbnRzXG4gICAgPyBBcmdzLnBhcmVudFNjb3BlXG4gICAgOiBibG9ja0luc3RhbmNlO1xuICBwYXJlbnRUZW1wbGF0ZSA9IGlzRWxlbWVudHNcbiAgICA/IEFyZ3MucGFyZW50VGVtcGxhdGVcbiAgICA6IGJsb2NrSW5zdGFuY2U7XG5cbiAgaXRlcmF0ZUFycmF5KGh0bWwsIChjaGlsZCkgPT4ge1xuICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgcGFyZW50OiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrOiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0pO1xuICB9KTtcblxuICBibG9ja0luc3RhbmNlLiQkLmlzUmVuZGVyZWQgPSB0cnVlO1xuXG4gIGl0ZXJhdGVBcnJheShibG9ja0luc3RhbmNlLiQkLm1peGluc1RvQnVpbGQsIChleGVjdXRlQnVpbGRlcnMpID0+IHtcbiAgICBleGVjdXRlQnVpbGRlcnMoKTtcbiAgfSk7XG4gIGJsb2NrSW5zdGFuY2UuJCQubWl4aW5zVG9CdWlsZCA9IFtdO1xuXG4gIHRyeSB7XG4gICAgYmxvY2tJbnN0YW5jZS5fYWZ0ZXJSZW5kZXIoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyUmVuZGVyOmAsIGVycik7XG4gIH1cblxuICByZXR1cm4gYmxvY2tJbnN0YW5jZTtcbn1cbiIsImltcG9ydCB7IHNldFByb3RvLCBnZXRQcm90byB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGlzSW5zdGFuY2VPZiB9IGZyb20gJy4vaXNJbnN0YW5jZU9mJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQmxvY2soYmxvY2ssIG5ld0Jsb2NrKSB7XG4gIGlmIChpc0luc3RhbmNlT2YoQmxvY2ssIG5ld0Jsb2NrKSkge1xuICAgIGlmIChpc0luc3RhbmNlT2YoYmxvY2ssIG5ld0Jsb2NrKSkge1xuICAgICAgbGV0IGN1cnJlbnRCbG9jayA9IG5ld0Jsb2NrO1xuICAgICAgbGV0IHByb3RvO1xuXG4gICAgICB3aGlsZSAoKHByb3RvID0gZ2V0UHJvdG8oY3VycmVudEJsb2NrKSkgIT09IGJsb2NrKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jayA9IHByb3RvO1xuICAgICAgfVxuXG4gICAgICBleHRlbmQoY3VycmVudEJsb2NrLCBnZXRQcm90byhibG9jaykpO1xuICAgIH1cblxuICAgIGV4dGVuZChibG9jaywgbmV3QmxvY2spO1xuICB9XG5cbiAgcmV0dXJuIGJsb2NrO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoQmxvY2ssIEJhc2VCbG9jaykge1xuICBzZXRQcm90byhCbG9jaywgQmFzZUJsb2NrKTtcbiAgc2V0UHJvdG8oQmxvY2sucHJvdG90eXBlLCBCYXNlQmxvY2sucHJvdG90eXBlKTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QsIGNyZWF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRBcmdzKGFyZ3NEZXNjcmlwdGlvbnMpIHtcbiAgY29uc3QgbmV3QXJncyA9IGNyZWF0ZShudWxsKTtcblxuICBpdGVyYXRlT2JqZWN0KGFyZ3NEZXNjcmlwdGlvbnMsICh7IGRlZmF1bHQ6IGRlZiB9LCBhcmcpID0+IHtcbiAgICBuZXdBcmdzW2FyZ10gPSBkZWY7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdBcmdzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwoY2hpbGQpIHtcbiAgY2hpbGQuJCQucmVtb3ZlKHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgaXNJbnN0YW5jZU9mIH0gZnJvbSAnLi9pc0luc3RhbmNlT2YnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uLy4uL01peGluJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBCbG9jayhibG9jaywgd3JhcHBlcikge1xuICBjb25zdCBuZXdCbG9jayA9IHdyYXBwZXIoYmxvY2spO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIG5ld0Jsb2NrKVxuICAgID8gbmV3QmxvY2tcbiAgICA6IGJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1peGluKG1peGluLCB3cmFwcGVyKSB7XG4gIGNvbnN0IG5ld01peGluID0gd3JhcHBlcihtaXhpbik7XG5cbiAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgbmV3TWl4aW4pXG4gICAgPyBuZXdNaXhpblxuICAgIDogbWl4aW47XG59XG4iLCJpbXBvcnQge1xuICBpc1N0cmluZywgaXRlcmF0ZU9iamVjdCwga2V5cyxcbiAgY29sbGVjdEZyb21PYmplY3QsIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5cbmNvbnN0IENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYID0gL1xccyo7XFxzKi87XG5jb25zdCBDU1NfU1RZTEVfU0VQQVJBVE9SX1JFR0VYID0gL1xccyo6XFxzKi87XG5cbmNsYXNzIFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xuICBjc3MgPSB7fTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNzc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21PYmplY3QoYXJncywgKGNzcywgcHJvcCkgPT4ge1xuICAgICAgICBjc3NbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21BcnJheShcbiAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgIC5tYXAoY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nKSxcbiAgICAgICAgYWRkQ1NTUHJvcFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNzcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIW5ld1ZhbHVlW3Byb3BdKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ1NTKHByb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVsZW0uY3NzKG5ld1ZhbHVlKTtcblxuICAgIHRoaXMuY3NzID0gbmV3VmFsdWU7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBjc3NcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBlbGVtLnJlbW92ZUNTUy5hcHBseShlbGVtLCBrZXlzKGNzcykpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRDU1NQcm9wKGNzcywgaXRlbSkge1xuICBjb25zdCBbcHJvcCwgdmFsdWVdID0gaXRlbTtcblxuICBjc3NbcHJvcF0gPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nKHN0eWxlKSB7XG4gIGNvbnN0IHNwbGl0ID0gc3R5bGUuc3BsaXQoQ1NTX1NUWUxFX1NFUEFSQVRPUl9SRUdFWCk7XG5cbiAgcmV0dXJuIFtcbiAgICBzcGxpdFswXS50cmltKCksXG4gICAgc3BsaXRbMV0udHJpbSgpXG4gIF07XG59XG5cbmV4cG9ydCB7IFN0eWxlIH07XG4iLCJpbXBvcnQge1xuICBpc0Z1bmN0aW9uLCBpc05pbCxcbiAgY29sbGVjdEZyb21BcnJheVxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuXG5jbGFzcyBWYWx1ZSBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJncyxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZWxlbVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5hbWUgPSBlbGVtLm5hbWUoKTtcbiAgICBjb25zdCB0eXBlID0gZWxlbS5wcm9wKCd0eXBlJyk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKCk7XG4gICAgbGV0IGluaXRpYWxTY29wZVZhbHVlID0gbnVsbDtcblxuICAgIHRoaXMucHJvcCA9IGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBlbGVtLmNoaWxkcmVuKCkuZmlsdGVyKCdvcHRpb24nKTtcbiAgICB0aGlzLnNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgdGhpcy5zY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdGhpcy52YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHRoaXMudmFsdWUpKSB7XG4gICAgICBpbml0aWFsU2NvcGVWYWx1ZSA9IHRoaXMuc2NvcGUuJCQuZXZhbHVhdGUoKHNjb3BlKSA9PiBzY29wZVt0aGlzLnZhbHVlXSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0UHJvcChuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxFbGVtVmFsdWUgPSB0aGlzLmdldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsID0gaXNOaWwoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgIGNvbnN0IGlzQ2hlY2tib3ggPSB0eXBlID09PSAnY2hlY2tib3gnO1xuICAgIGNvbnN0IGNoYW5nZVNjb3BlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLmdldFByb3AodGhpcy5jdXJyZW50VmFsdWUsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIHx8IGlzQ2hlY2tib3gpIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbEVsZW1WYWx1ZTtcbiAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcblxuICAgICAgaWYgKCFpc0luaXRpYWxTY29wZVZhbHVlTnVsbCAmJiBpc0NoZWNrYm94KSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbFNjb3BlVmFsdWU7XG4gICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMub2ZmRWxlbUxpc3RlbmVyID0gZWxlbS5vbihnZXRMaXN0ZW5lck5hbWUobmFtZSwgdHlwZSksIGNoYW5nZVNjb3BlKTtcbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lciA9IGVsZW0uY2xvc2VzdCgnZm9ybScpLm9uKCdyZXNldCcsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoY2hhbmdlU2NvcGUsIDApO1xuICAgIH0pO1xuICB9XG5cbiAgY2hhbmdlU2NvcGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NvcGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGN1cnJlbnRWYWx1ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgc2V0UHJvcCh2YWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBuYW1lLFxuICAgICAgcHJvcCxcbiAgICAgIHR5cGUsXG4gICAgICBub2RlLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3AgPT09ICd0ZXh0Jykge1xuICAgICAgZWxlbS50ZXh0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKSB7XG4gICAgICBvcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmRleE9mKG9wdGlvbi52YWx1ZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0ucHJvcChwcm9wLCBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIG5vZGUudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcm9wKHZhbHVlcywgaW5pdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBuYW1lLFxuICAgICAgcHJvcCxcbiAgICAgIHR5cGUsXG4gICAgICBub2RlLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIHByb3AgPT09ICd0ZXh0J1xuICAgICAgPyBlbGVtLnRleHQoKVxuICAgICAgOiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgZWxlbS5wcm9wKHByb3ApLCB0eXBlLCBub2RlLnZhbHVlLCB2YWx1ZXMsIG9wdGlvbnMsIGluaXQsIHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKTtcbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHRoaXMub2ZmRm9ybUxpc3RlbmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcChuYW1lLCB0eXBlLCBlbGVtKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIHJldHVybiBlbGVtLmhhc0F0dHIoJ211bHRpcGxlJylcbiAgICAgICAgPyAnbXVsdGlwbGUtc2VsZWN0J1xuICAgICAgICA6ICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgY2FzZSAnaW5wdXQnOiB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHJldHVybiAnZmlsZXMnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnXG4gICAgICAgID8gJ2NoZWNrZWQnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gZWxlbS5oYXNBdHRyKCdjb250ZW50RWRpdGFibGUnKVxuICAgICAgICA/ICd0ZXh0J1xuICAgICAgICA6ICd2YWx1ZSc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yU2V0dGluZyhuYW1lLCB2YWx1ZSwgdHlwZSwgaW5wdXRWYWx1ZSkge1xuICBpZiAobmFtZSAhPT0gJ2lucHV0Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IGlzUmFkaW8gPSB0eXBlID09PSAncmFkaW8nO1xuXG4gIGlmICghaXNSYWRpbyAmJiB0eXBlICE9PSAnY2hlY2tib3gnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGlzUmFkaW9cbiAgICA/IHZhbHVlID09PSBpbnB1dFZhbHVlXG4gICAgOiB2YWx1ZS5pbmRleE9mKGlucHV0VmFsdWUpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JHZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlLCB2YWx1ZXMsIG9wdGlvbnMsIGluaXQsIGlzTXVsdGlwbGUpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tQXJyYXkob3B0aW9ucywgYWRkVmFsdWUsIFtdKTtcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIGlmICh0eXBlICE9PSAncmFkaW8nICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICA/IGlucHV0VmFsdWVcbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlcyA9IHZhbHVlcyB8fCBbXTtcblxuICAgICAgaWYgKCF2YWx1ZSAmJiBpbml0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmluZGV4T2YoaW5wdXRWYWx1ZSkgPT09IC0xXG4gICAgICAgICAgPyB2YWx1ZXMuY29uY2F0KGlucHV0VmFsdWUpXG4gICAgICAgICAgOiB2YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gdmFsdWVzLmluZGV4T2YoaW5wdXRWYWx1ZSk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAuLi52YWx1ZXMuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgIC4uLnZhbHVlcy5zbGljZShpbmRleCArIDEpXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMaXN0ZW5lck5hbWUobmFtZSwgdHlwZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICByZXR1cm4gJ2NoYW5nZSc7XG4gICAgfVxuXG4gICAgY2FzZSAnaW5wdXQnOiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0eXBlID09PSAncmFkaW8nXG4gICAgICAgIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2NvbG9yJ1xuICAgICAgICB8fCB0eXBlID09PSAnZmlsZSdcbiAgICAgIClcbiAgICAgICAgPyAnY2hhbmdlJ1xuICAgICAgICA6ICdjaGFuZ2UgaW5wdXQnO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiAnaW5wdXQnO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRWYWx1ZSh2YWx1ZXMsIHsgc2VsZWN0ZWQsIHZhbHVlIH0pIHtcbiAgaWYgKHNlbGVjdGVkICYmIHZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgVmFsdWUgfTtcbiIsImltcG9ydCB7XG4gIHRvT2JqZWN0S2V5cyxcbiAgYXNzaWduLCBrZXlzLCBjcmVhdGVcbn0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRIdG1sKGh0bWwsIHRlbXBsYXRlcykge1xuICBjb25zdCB7XG4gICAgdmFycyA9IFtdXG4gIH0gPSBodG1sO1xuICBjb25zdCBuZXdUZW1wbGF0ZXMgPSBjcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5ld1ZhcnMgPSB0b09iamVjdEtleXModmFycyk7XG5cbiAgYXNzaWduKG5ld1RlbXBsYXRlcywgdGVtcGxhdGVzKTtcblxuICAoZnVuY3Rpb24gaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuKG5vZGVzID0gW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICAgIGlmIChuZXdUZW1wbGF0ZXNbdHJpbW1lZF0pIHtcbiAgICAgICAgICBjb25zdCBuZXdUZW1wbGF0ZSA9IG5ld1RlbXBsYXRlc1t0cmltbWVkXTtcblxuICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uZXdUZW1wbGF0ZSk7XG4gICAgICAgICAgYXNzaWduKG5ld1ZhcnMsIHRvT2JqZWN0S2V5cyhuZXdUZW1wbGF0ZXNbdHJpbW1lZF0udmFycykpO1xuXG4gICAgICAgICAgaSArPSBuZXdUZW1wbGF0ZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSkoaHRtbCk7XG5cbiAgaHRtbC52YXJzID0ga2V5cyhuZXdWYXJzKTtcblxuICByZXR1cm4gaHRtbDtcbn1cbiIsImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUJsb2NrLCBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpbml0QXBwXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1RlbXBsYXRlfHR5cGVvZiBCbG9ja30gaHRtbCAtIFJvb3QgdGVtcGxhdGUgb3Igcm9vdCBibG9jayBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgb2YgdGhlIGFwcC5cbiAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfSBSb290IGJsb2NrIGlmIHRoZSBhcHAgaGFzIGJlZW4gcmVnaXN0ZXJlZCBhbmQgdW5kZWZpbmVkIGlmIG5vdC5cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGluaXRpYWxpemluZyBhcHAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGluaXRBcHAsIGRvYyB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogaW5pdEFwcChodG1sYDxBcHAvPmAsIGRvYy5jcmVhdGUoJ2RpdicpKTtcbiAqIGluaXRBcHAoaHRtbFNjb3BlbGVzc2A8QXBwLz5gLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKCdBcHAnLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKEFwcCwgZG9jLmNyZWF0ZSgnZGl2JykpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEFwcChodG1sLCBjb250YWluZXIpIHtcbiAgY29uc3QgcGFyZW50RWxlbSA9IG5ldyBFbGVtKGNvbnRhaW5lcikuZWxlbSgwKTtcblxuICBpZiAoIXBhcmVudEVsZW0ubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCB0byBpbnNlcnQgdGhlIGFwcCBpbnRvIHdhcyBnaXZlbiEgKGluaXRBcHApJyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocGFyZW50RWxlbS5wcm9wKCdEd2F5bmVSb290QmxvY2snKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIGFscmVhZHkgZXhpc3RzIGEgRHdheW5lIGFwcCBpbnNpZGUgdGhlIGdpdmVuIGVsZW1lbnQhIChpbml0QXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IFJvb3RCbG9jayA9IGh0bWw7XG5cbiAgaWYgKGlzQXJyYXkoaHRtbCkpIHtcbiAgICBSb290QmxvY2sgPSBjbGFzcyBSb290QmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAgICBzdGF0aWMgaHRtbCA9IGh0bWw7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghaXNJbnN0YW5jZU9mKEJsb2NrLCBSb290QmxvY2spKSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gdmFsaWQgcm9vdCBibG9jayB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgcm9vdEJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgIG5vZGU6IHtcbiAgICAgIHR5cGU6IFJvb3RCbG9ja1xuICAgIH0sXG4gICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgIHBhcmVudEVsZW1cbiAgfSk7XG5cbiAgcGFyZW50RWxlbVxuICAgIC5wcm9wKCdEd2F5bmVSb290QmxvY2snLCByb290QmxvY2spXG4gICAgLmF0dHIoJ2R3YXluZS1yb290JywgJycpO1xuXG4gIHJldHVybiByb290QmxvY2s7XG59XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUFwcFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGNvbnRhaW5lciAtIENvbnRhaW5lciBvZiB0aGUgYXBwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZW1vdmluZyBhcHAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHJlbW92ZUFwcCwgZmluZCB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogcmVtb3ZlQXBwKGZpbmQoJy5yb290JykpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXBwKGNvbnRhaW5lcikge1xuICBjb25zdCBlbGVtID0gbmV3IEVsZW0oY29udGFpbmVyKS5lbGVtKDApO1xuXG4gIGlmICghZWxlbS5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdObyB2YWxpZCBlbGVtZW50IHRvIHJlbW92ZSB0aGUgYXBwIGZyb20gd2FzIGdpdmVuISAocmVtb3ZlQXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udGFpbmVyID0gZWxlbVswXTtcblxuICBjb25zdCB7IER3YXluZVJvb3RCbG9jayB9ID0gY29udGFpbmVyO1xuXG4gIGlmICghKER3YXluZVJvb3RCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIGFwcCByZWdpc3RlcmVkIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCEgKHJlbW92ZUFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIER3YXluZVJvb3RCbG9jay4kJC5yZW1vdmUoKTtcbiAgZWxlbS5yZW1vdmVBdHRyKCdkd2F5bmUtcm9vdCcpO1xuXG4gIGRlbGV0ZSBjb250YWluZXIuRHdheW5lUm9vdEJsb2NrO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmVzdGVkLXRlcm5hcnksIG5vLW5lZ2F0ZWQtY29uZGl0aW9uICovXG5leHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuLyogZXNsaW50LWVuYWJsZSBuby1uZXN0ZWQtdGVybmFyeSwgbm8tbmVnYXRlZC1jb25kaXRpb24gKi9cbiIsImV4cG9ydCBjb25zdCBISURFX0NMQVNTID0gJ19fZHdheW5lLWhpZGRlbl9fJztcbmV4cG9ydCBjb25zdCBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG5leHBvcnQgY29uc3QgYmxvY2tzID0ge307XG5leHBvcnQgY29uc3QgbWl4aW5zID0ge307XG5leHBvcnQgY29uc3Qge1xuICBkb2N1bWVudCA9IHt9LFxuICBTeW1ib2wgPSB7fVxufSA9IGdsb2JhbDtcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzQuMS4xJztcbiIsImV4cG9ydCBjb25zdCB7XG4gIGNyZWF0ZSxcbiAga2V5cyxcbiAgZ2V0UHJvdG90eXBlT2Y6IGdldFByb3RvXG59ID0gT2JqZWN0O1xuXG5leHBvcnQgY29uc3Qgc2V0UHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCh0YXJnZXQsIHByb3RvKSA9PiB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBwcm90bztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufSk7XG4iLCJpbXBvcnQge1xuICBpc05pbCwgaXNTdHJpbmcsXG4gIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMsXG4gIGNvbGxlY3RGcm9tQXJyYXksIGNvbGxlY3RGcm9tT2JqZWN0LFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIHRvSHlwaGVuQ2FzZSwgc2V0U3ltYm9sU3BlY2llcyxcbiAgc2V0VG9TdHJpbmdUYWcsIHNldFByb3RvXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgaXNEb2N1bWVudCwgaXNWYWxpZE5vZGUsIGdldE1hdGNoZXNGdW5jdGlvbixcbiAgYWRkQXR0ciwgYWRkQ1NTUHJvcCwgYWRkRGF0YUF0dHIsXG4gIGFkZE5leHQsIGFkZFBhcmVudCwgYWRkUHJldixcbiAgdG9FbGVtLCBpc0VsZW1lbnRzQ29sbGVjdGlvbixcbiAgZ2V0QXR0ck5TLCBnZXRFdmVudCwgaGlkZSwgc2hvdywgcmVtb3ZlXG59IGZyb20gJy4vaGVscGVycy9FbGVtJztcbmltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd9IEVsZW1FdmVudFN0cmluZ1xuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIGNvbnRhaW5pbmcgZXZlbnRzIHNlcGFyYXRlZCBieSBhIGNvbW1hIHdpdGggemVybyBvciBtb3JlIHNwYWNlcyBvciBqdXN0IHNwYWNlcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtTGlzdGVuZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBGaXJlZCBldmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtUmVtb3ZlTGlzdGVuZXJzXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gey4uLkVsZW1FdmVudFN0cmluZ30gZXZlbnRzIC0gSWYgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IHByZXNlbnQgb25seSByZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBldmVudHMgaW4gdGhlIGFyZ3VtZW50cy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9IG5vZGUgLSBJdGVyYXRpb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEl0ZXJhdGlvbiBpbmRleC5cbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEluaXRpYWwgc2V0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIENvbGxlY3RDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtBZGRDYWxsYmFja30gYWRkIC0gQWRkIGVsZW1lbnQgdG8gdGhlIGV2ZW50dWFsIHNldCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBub2RlIC0gSXRlcmF0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJdGVyYXRpb24gaW5kZXguXG4gKiBAcGFyYW0ge0VsZW19IGVsZW0gLSBJbml0aWFsIHNldC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBZGRDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsuLi4oRWxlbWVudHxOb2RlfGVsZW0pfSBlbGVtIC0gRWxlbWVudCB0byBhZGQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbU1ldGhvZFxuICogQHB1YmxpY1xuICogQHRoaXMgRWxlbVxuICovXG5cbmNvbnN0IEVWRU5UX1NFUEFSQVRPUl9SRUdFWCA9IC9bLHwgXSAqLztcbmNvbnN0IENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYID0gLzsgPy87XG5jb25zdCBDU1NfSU1QT1JUQU5UX1JFR0VYID0gLyA/IWltcG9ydGFudCQvO1xuY29uc3QgZW1wdHlDb2xsZWN0aW9uID0gW107XG5cbi8qKlxuICogQGNsYXNzIEVsZW1cbiAqIEBleHRlbmRzIEFycmF5LjxFbGVtZW50fE5vZGU+XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBbZWxlbSA9IFtdXSAtIEFuIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgZWxlbWVudHMgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFbGVtfSBJbnN0YW5jZSBvZiBFbGVtLlxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYW4gZWxlbWVudHMgc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBuZXcgRWxlbShkb2N1bWVudC5ib2R5KTtcbiAqIG5ldyBFbGVtKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jbHMnKSk7XG4gKiBuZXcgRWxlbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjbHMnKSk7XG4gKi9cbmNsYXNzIEVsZW0gZXh0ZW5kcyBBcnJheSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0uYWRkTWV0aG9kc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBFbGVtTWV0aG9kPn0gbWV0aG9kTmFtZSAtIE5hbWUgb2YgdGhlIG1ldGhvZCBvciBvYmplY3Qgb2ZcbiAgICogbWV0aG9kIG5hbWVzIGFuZCBtZXRob2RzLlxuICAgKiBAcGFyYW0ge0VsZW1NZXRob2R9IFttZXRob2RdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIHRoaXMgc2hvdWxkIGJlIHRoZSBtZXRob2QgaXRzZWxmLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW19XG4gICAqL1xuICBzdGF0aWMgYWRkTWV0aG9kcyhtZXRob2ROYW1lLCBtZXRob2QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBtZXRob2ROYW1lID0geyBbbWV0aG9kTmFtZV06IG1ldGhvZCB9O1xuICAgIH1cblxuICAgIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXModGhpcy5wcm90b3R5cGUsIG1ldGhvZE5hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbGVtID0gZW1wdHlDb2xsZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgfVxuXG4gICAgc2V0UHJvdG8odGhpcywgRWxlbS5wcm90b3R5cGUpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICB0aGlzLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLihFbGVtfEVsZW1lbnR8RWxlbWVudFtdKX0gZWxlbWVudHMgLSBFYWNoIGFyZ3VtZW50IGlzIGEgRWxlbSwgb3IgRWxlbWVudCwgb3IgYXJyYXkgb2YgRWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgZWxlbWVudHMgdG8gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbTEuZmluZCgnLmNsczEnKVxuICAgKiAgIC5hZGQoZWxlbTIuZmluZCgnLmNsczInKSlcbiAgICogICAuaGlkZSgpO1xuICAgKi9cbiAgYWRkKC4uLmVsZW1lbnRzKSB7XG4gICAgY29uc3QgZWxlbXMgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICBpdGVyYXRlQXJyYXkoZWxlbWVudHMsIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIWVsZW1zLmluY2x1ZGVzKGVsZW0pICYmIGlzVmFsaWROb2RlKGVsZW0pKSB7XG4gICAgICAgICAgZWxlbXMucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWxlbXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2FkZENsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGNsYXNzZXMgLSBDbGFzc2VzIHRvIGFkZC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIGNsYXNzZXMgdG8gdGhlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygncmVkJywgJ3JvdW5kJyk7XG4gICAqL1xuICBhZGRDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4gbGlzdC5hZGQoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2F0dHJdIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAgICogaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgb2JqZWN0IG9mIGF0dHJpYnV0ZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiByZXR1cm5lZCwgaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cjEnLCAndmFsdWUxJyk7IC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCdhdHRyMScpOyAgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5hdHRyKHtcbiAgICogICBhdHRyMTogJ3ZhbHVlMycsICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIGF0dHIyOiAndmFsdWUyJyAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCk7ICAgICAgICAgICAgICAgICAgLy8geyBhdHRyMTogJ3ZhbHVlMycsIGF0dHIyOiAndmFsdWUyJyB9XG4gICAqL1xuICBhdHRyKGF0dHIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGVsZW0uYXR0cmlidXRlcywgYWRkQXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhhdHRyKSkge1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5zLFxuICAgICAgICBuYW1lXG4gICAgICB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgICByZXR1cm4gbnNcbiAgICAgICAgPyBlbGVtLmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKVxuICAgICAgICA6IGVsZW0uZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGF0dHIgPSB7IFthdHRyXTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KGF0dHIsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlO1xuXG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhrZXksIGVsZW0pO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTlMobnMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY2hpbGRyZW5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGVsZW1lbnQncyBjaGlsZHJlbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgY2hpbGRyZW4gPSBlbGVtLmNoaWxkcmVuKCk7XG4gICAqL1xuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gbmV3IEVsZW0odGhpcy5sZW5ndGggPyB0aGlzWzBdLmNoaWxkTm9kZXMgOiBbXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nsb3Nlc3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBTZXQgb2YgdGhlIGNsb3Nlc3QgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNjbG9zZXN0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0fS5cbiAgICovXG4gIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICAgIGlmIChuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gYWRkKGVsZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY29sbGVjdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Q29sbGVjdENhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgZXZlbnR1YWwgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjb2xsZWN0aW5nIGVsZW1lbnRzIGludG8gYSBuZXcgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBwYXJlbnRzID0gZWxlbS5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICogICBhZGQoZWxlbS5wYXJlbnROb2RlKTtcbiAgICogfSk7XG4gICAqL1xuICBjb2xsZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBjYiA9IDo6ZWxlbWVudHMucHVzaDtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNiLCBlbGVtLCBpbmRleCwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVsZW0oZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjb250YWluc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgYXJndW1lbnQgd2l0aGluIHRoaXMgZWxlbWVudC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBleHRlbnNpb24gZm9yXG4gICAqIFtOb2RlI2NvbnRhaW5zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcbiAgICovXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzWzBdO1xuICAgIGNvbnN0IGNoaWxkID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgcmV0dXJuICFwYXJlbnQgfHwgIWNoaWxkXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIElmIHR5cGUgaXMgXCIjY29tbWVudFwiIGEgY29tbWVudCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSAtIHdyYXAgb2YgdGhlIGNyZWF0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgZWxlbWVudCBpcyBqdXN0IGNyZWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKTtcbiAgICovXG4gIGNyZWF0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBsZXQgZWwgPSBudWxsO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdHlwZSA9PT0gJyN0ZXh0JztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gaXNEb2N1bWVudChlbGVtKVxuICAgICAgICA/IGVsZW1cbiAgICAgICAgOiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIGlmIChpc1RleHQgfHwgdHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgICBlbCA9IGlzVGV4dFxuICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpXG4gICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gdHlwZSA9PT0gJ3N2ZydcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpXG4gICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRG9jdW1lbnQoZWxlbSkpIHtcbiAgICAgICAgbmV3IEVsZW0oZWwpLmludG8oZWxlbSk7XG4gICAgICB9XG5cbiAgICAgIGFkZChlbCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgb2JqZWN0IG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBzdHlsZXMuIFN1cHBvcnRzICFpbXBvcnRhbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTsgLy8gZGlzcGxheSBzZXQgdG8gJ25vbmUnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBkaXNwbGF5OiAnaW5saW5lJywgICAgICAgICAvLyBkaXNwbGF5IHNldCB0byAnaW5saW5lJ1xuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygpOyAgICAgICAgICAgICAgICAgIC8vIHsgZGlzcGxheTogJ25vbmUnLCBjdXJzb3I6ICdwb2ludGVyJyB9XG4gICAqL1xuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KHN0eWxlLmNzc1RleHQuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpLCBhZGRDU1NQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpICsgKHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpID8gJyAhaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgdmFsdWUucmVwbGFjZShDU1NfSU1QT1JUQU5UX1JFR0VYLCAnJyksXG4gICAgICAgICAgQ1NTX0lNUE9SVEFOVF9SRUdFWC50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtrZXldIC0gTmFtZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgKHdpdGhvdXQgZGF0YS0gcHJlZml4KVxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIG9iamVjdCBvZiBkYXRhc2V0IG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgZGF0YSBhdHRyaWJ1dGVzLiBTZWVcbiAgICogW0hUTUxFbGVtZW50I2RhdGFzZXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9kYXRhc2V0fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScsICd2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnKTsgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5kYXRhKHtcbiAgICogICBzb21lS2V5MTogJ3ZhbHVlMycsICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTMnXG4gICAqICAgc29tZUtleTI6ICd2YWx1ZTInICAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCk7ICAgICAgICAgICAgICAgICAgICAvLyB7IHNvbWVLZXkxOiAndmFsdWUzJywgc29tZUtleTI6ICd2YWx1ZTInIH1cbiAgICovXG4gIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGRhdGFzZXQsIGFkZERhdGFBdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YXNldFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChrZXksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGlzcGF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudH0gZXZlbnQgLSBFdmVudCBvciBhIHN0cmluZyAobmV3IEV2ZW50KGV2ZW50KSBpcyBjcmVhdGVkKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0V2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snKTtcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UsIGRhdGE6IDEgfSk7XG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XG4gICAqL1xuICBkaXNwYXRjaChldmVudCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYnViYmxlcyA9IHRydWUsXG4gICAgICBjYW5jZWxhYmxlID0gdHJ1ZSxcbiAgICAgIC4uLnJlYWxEZXRhaWxzXG4gICAgfSA9IGRldGFpbHM7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZ2V0RXZlbnQoXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBidWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlLFxuICAgICAgICByZWFsRGV0YWlscyxcbiAgICAgICAgZWxlbVxuICAgICAgKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2VsZW1cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4ID0gMF0gLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvZiB0aGUgc2V0IHRvIGdldC4gTmVnYXRpdmUgaW5kZXggbWVhbnMgZWxlbS5sZW5ndGggKyBpbmRleC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmVsZW0oMSk7IC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDFcbiAgICogZWxlbS5lbGVtKCk7ICAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAwXG4gICAqL1xuICBlbGVtKGluZGV4ID0gMCkge1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggKyBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW0odGhpc1tpbmRleF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmaWx0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfFN0cmluZ30gZmlsdGVyIC0gRmlsdGVyIGZ1bmN0aW9uIG9yIGEgc2VsZWN0b3IuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmZpbHRlcigoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuY2xvc2VzdCgnLnBhcmVudCcpKTtcbiAgICovXG4gIGZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBmaWx0ZXI7XG5cbiAgICAgIGZpbHRlciA9IChlbGVtKSA9PiAoXG4gICAgICAgIG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZmlsdGVyKGVsZW0sIGluZGV4LCB0aGlzKSkge1xuICAgICAgICBhZGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbmRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cbiAgICovXG4gIGZpbmQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICAgIGFkZChmaW5kKHNlbGVjdG9yLCBlbGVtKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZvckVhY2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZmluZCgnLmNscycpLmZvckVhY2goKGVsZW1lbnQsIGluZGV4LCBzZXQpID0+IHtcbiAgICogICAvLyBkbyBzb21ldGhpbmdcbiAgICogfSk7XG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgaXRlcmF0ZUFycmF5KHRoaXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoYXNBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgYXR0cmlidXRlLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgcmV0dXJucyBpZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgYXR0cmlidXRlIG9yIG5vdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hdHRyKCdhdHRyJywgJ3ZhbHVlJykuaGFzQXR0cignYXR0cicpOyAvLyB0cnVlXG4gICAqIGVsZW0ucmVtb3ZlQXR0cignYXR0cicpLmhhc0F0dHIoJ2F0dHInKTsgICAgLy8gZmFsc2VcbiAgICovXG4gIGhhc0F0dHIoYXR0cikge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeyBucyB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgcmV0dXJuIG5zXG4gICAgICA/IGVsZW0uaGFzQXR0cmlidXRlTlMobnMsIGF0dHIpXG4gICAgICA6IGVsZW0uaGFzQXR0cmlidXRlKGF0dHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoYXNDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBOYW1lIG9mIHRoZSBjbGFzcy5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGNsYXNzIG9yIG5vdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJykuaGFzQ2xhc3MoJ2NscycpOyAgICAvLyB0cnVlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgLy8gZmFsc2VcbiAgICovXG4gIGhhc0NsYXNzKGNscykge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgcmV0dXJuIGVsZW1cbiAgICAgID8gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoY2xzKVxuICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGlkZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBIaWRlcyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5oaWRlKCk7XG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goaGlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2h0bWxcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBbaHRtbF0gLSBIVE1MIHRvIHdyaXRlIGluc3RlYWQgb2YgY3VycmVudCBIVE1MLlxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgSFRNTCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIEhUTUwgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSBodG1sIGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIEhUTUwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaHRtbCgnPGRpdj4xPC9kaXY+Jyk7XG4gICAqIGVsZW0uaHRtbCgpOyAvLyAnPGRpdj4xPC9kaXY+J1xuICAgKi9cbiAgaHRtbChodG1sKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgICAgcmV0dXJuIGVsZW1cbiAgICAgICAgPyBlbGVtLmlubmVySFRNTFxuICAgICAgICA6ICcnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0uaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaW5jbHVkZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW1lbnR8bm9kZX0gZWxlbSAtIEVsZW1lbnQgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHNhbWUgYXMgQXJyYXkjaW5jbHVkZXMuXG4gICAqL1xuICBpbmNsdWRlcyhlbGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEFmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYWZ0ZXIgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGJlZm9yZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudFswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnRvXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHB1dCB0aGlzIGVsZW1lbnRzIGludG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSB0aGV5IGFyZSBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNhcHBlbmRDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvYXBwZW5kQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmludG8oZWxlbTIpO1xuICAgKiBlbGVtLmludG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmludG8oJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGludG8oZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudClbMF07XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpc1tpXSwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSk7XG5cbiAgICByZXR1cm4gZWxlbTo6bWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfHZvaWR9IG5vZGVOYW1lIChsb3dlcmNhc2VkKSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIG5hbWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGUoJ2RpdicpLm5hbWUoKSAvLyAnZGl2J1xuICAgKi9cbiAgbmFtZSgpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25leHRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm5leHQoKTsgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkTmV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI29uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtRXZlbnRTdHJpbmd8T2JqZWN0LjxFbGVtRXZlbnRTdHJpbmd8RWxlbUxpc3RlbmVyPn0gZXZlbnQgLSBFaXRoZXIgYSB7QGxpbmsgRWxlbUV2ZW50U3RyaW5nfSBzdHJpbmdcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggZXZlbnQga2V5cyAoYSBrZXkgaXMgYWxzbyBFbGVtRXZlbnRTdHJpbmcpIGFuZCBsaXN0ZW5lcnMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0VsZW1MaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBtdXN0IGJlIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yXG4gICAqIHNwZWNpZmllZCBldmVudChzKS5cbiAgICogQHJldHVybnMge0VsZW1SZW1vdmVMaXN0ZW5lcnN9IEZ1bmN0aW9uIHRoYXQgdGFrZXMgb3B0aW9uYWwgZXZlbnQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oXG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnLFxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcbiAgICogKTtcbiAgICogZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdjbGljaycpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScsICdpbnB1dCcpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICovXG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChpc1N0cmluZyhldmVudCkpIHtcbiAgICAgIGV2ZW50ID0geyBbZXZlbnRdOiBsaXN0ZW5lciB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0V2ZW50cyA9IHt9O1xuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IHt9O1xuXG4gICAgaXRlcmF0ZU9iamVjdChldmVudCwgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAobmV3RXZlbnRzW2V2ZW50XSA9IG5ld0V2ZW50c1tldmVudF0gfHwgW10pLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3RXZlbnRzLCAobGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICBpdGVyYXRlQXJyYXkobGlzdGVuZXJzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgKGFsbExpc3RlbmVyc1tldmVudF0gPSBhbGxMaXN0ZW5lcnNbZXZlbnRdIHx8IFtdKS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkoZXZlbnQuc3BsaXQoRVZFTlRfU0VQQVJBVE9SX1JFR0VYKSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuXG4gICAgICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGFsbExpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZU9iamVjdChhbGxMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcnMsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHJlbW92ZUxpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcblxuICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB3cmFwIG9mIHRoZSBzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICovXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZFBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3ByZXZcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5wcmV2KCk7IC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICovXG4gIHByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGRQcmV2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcHJvcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCAqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBhc3NpZ25lZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cbiAgICogQHJldHVybnMge0VsZW18Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3Mgc2V0dGVyIG9yIGEgdmFsdWUgaWYgZ2V0dGVyLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgaXMgZWl0aGVyIGEgcHJvcGVydHkgZ2V0dGVyIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIG9yIGEgc2V0dGVyIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJywgZmFsc2UpO1xuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScpOyAvLyBmYWxzZVxuICAgKi9cbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3ApID0+IHtcbiAgICAgICAgZWxlbVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGZyb20gdGhlIGRvY3VtZW50LlxuICAgKiBOb3RlOiBpdCBkb2Vzbid0IHJlbW92ZSB0aGVtIGZyb20gdGhlIHNldCBzbyB3YXRjaCBvdXQgZm9yIHRoZSBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlKCk7XG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChyZW1vdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVBdHRyKC4uLmF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkoYXR0cmlidXRlcywgKGF0dHIpID0+IHtcbiAgICAgICAgY29uc3QgeyBucyB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlTlMobnMsIGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGNsYXNzZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4gbGlzdC5yZW1vdmUoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNTU1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBwcm9wcyAtIENTUyBwcm9wZXJ0aWVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBDU1MgcHJvcGVydGllcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVDU1MoJ2Rpc3BsYXknLCAncG9zaXRpb24nLCAnbWFyZ2luJyk7XG4gICAqL1xuICByZW1vdmVDU1MoLi4ucHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkocHJvcHMsIChjc3MpID0+IHtcbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0b0h5cGhlbkNhc2UoY3NzKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVwbGFjZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byByZXBsYWNlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogd2l0aCBhIHNldCBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50IChFbGVtZW50IG9yIEVsZW0pLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjcmVwbGFjZUNoaWxkXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9yZXBsYWNlQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlcGxhY2UoZWxlbTIpO1xuICAgKiBlbGVtLnJlcGxhY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLnJlcGxhY2UoJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIHJlcGxhY2UoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCk7XG5cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZWxlbSgwKTtcbiAgICBjb25zdCBwYXJlbnQgPSBmaXJzdC5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGVsZW0gPSBwYXJlbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdpbnRvJztcbiAgICBjb25zdCBuZXh0ID0gZmlyc3QubmV4dCgpWzBdO1xuICAgIGNvbnN0IHByZXYgPSBmaXJzdC5wcmV2KClbMF07XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgZWxlbSA9IG5leHQ7XG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QmVmb3JlJztcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsZW0gPSBwcmV2O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEFmdGVyJztcbiAgICB9XG5cbiAgICBmaXJzdC5yZW1vdmUoKTtcblxuICAgIGVsZW1lbnRbbWV0aG9kXShlbGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jc2hvd1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTaG93cyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICogSWYgYW4gZWxlbWVudCB3YXMgaGlkZGVuIHVzaW5nIHtAbGluayBFbGVtI2hpZGV9IHByZXZpb3VzIGRpc3BsYXkgaXMgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnNob3coKTtcbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChzaG93KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jc2xpY2VcbiAgICogQHB1YmxpY1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHNhbWUgYXMgQXJyYXkjc2xpY2UgYnV0IGZvciBFbGVtLlxuICAgKi9cbiAgc2xpY2UoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHN1cGVyLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0ZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW3RleHRdIC0gVGV4dCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgdGV4dC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHRleHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyB0ZXh0cyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIHRleHQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgdGV4dC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50ZXh0KCcxMjMnKTtcbiAgICogZWxlbS50ZXh0KCk7IC8vICcxMjMnXG4gICAqL1xuICB0ZXh0KHRleHQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AoJ3RleHRDb250ZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgYXR0cmlidXRlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFlbGVtLmhhc0F0dHIoYXR0cikgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdG9nZ2xlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gQ2xhc3MgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgY2xhc3NcbiAgICogYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgY2xhc3MuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXG4gICAqIHRoZSBjbGFzcyBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGNsYXNzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLnRvZ2dsZUNsYXNzKCdjbHMnLCBzb21lQ29uZGl0aW9uKTtcbiAgICovXG4gIHRvZ2dsZUNsYXNzKGNscywgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW07XG5cbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIWNsYXNzTGlzdC5jb250YWlucyhjbHMpIDogY29uZGl0aW9uKSB7XG4gICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhFbGVtLCAnRWxlbScpO1xuc2V0U3ltYm9sU3BlY2llcyhFbGVtLCBBcnJheSk7XG5cbmV4cG9ydCB7IEVsZW0gfTtcbiIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTeW1ib2xTcGVjaWVzKGtsYXNzLCBzcGVjaWVzKSB7XG4gIGlmIChTeW1ib2wuc3BlY2llcykge1xuICAgIGRlZmluZVByb3BlcnRpZXMoa2xhc3MsIHtcbiAgICAgIFtTeW1ib2wuc3BlY2llc106IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuY2xhc3MgSW50ZXJuYWxNaXhpbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBhc3NpZ24odGhpcywgb3B0cyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgSW50ZXJuYWxNaXhpbiB9O1xuIiwiaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcywgZ2V0UHJvdG8sXG4gIHJlbW92ZUFycmF5RWxlbSwgc2V0VG9TdHJpbmdUYWdcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB3cmFwTWl4aW4sIHJlbW92ZVdhdGNoZXJzIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcblxuY29uc3QgdG9TdHJpbmdUYWcgPSAnW29iamVjdCBNaXhpbl0nO1xuXG4vKipcbiAqIEBjbGFzcyBNaXhpblxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBNaXhpbiBvcHRpb25zLlxuICogQHJldHVybnMge01peGlufSBJbnN0YW5jZSBvZiBNaXhpbi5cbiAqL1xuY2xhc3MgTWl4aW4ge1xuICAvKipcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gW01peGluLmV2YWx1YXRlID0gdHJ1ZV1cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSBtaXhpbiB2YWx1ZSBzaG91bGQgYmUgZXZhbHVhdGVkIGFuZCB3YXRjaGVkIG9yIG5vdC5cbiAgICovXG4gIHN0YXRpYyBldmFsdWF0ZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTWl4aW4ud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBtaXhpbi5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbn0gTmV3IG1peGluLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBtaXhpbnMuXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBtaXhpbiB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKC4uLndyYXBwZXJzKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJzLnJlZHVjZSh3cmFwTWl4aW4sIHRoaXMpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsLFxuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3Qgd2F0Y2hlcnMgPSBbXTtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yIH0gPSBnZXRQcm90byh0aGlzKTtcbiAgICBjb25zdCBuYW1lID0gY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZTtcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IE1peGluIyQkXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gTWl4aW4jJCQuZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gTWl4aW4jJCQuaXNSZW1vdmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbW92ZWQuXG4gICAgICAgKiBAcHJvcGVydHkge0ludGVybmFsTWl4aW59IE1peGluIyQkLmludGVybmFsIC0gQ3VycmVudCBpbnRlcm5hbCBtaXhpbiBpbnN0YW5jZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7SW50ZXJuYWxNaXhpbltdfSBNaXhpbiMkJC5pbnRlcm5hbHMgLSBBcnJheSBvZiBpbnRlcm5hbCBtaXhpbnMgYm91bmQgdG8gdGhlIHRoZSBtaXhpbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBNaXhpbiMkJC5uYW1lIC0gTWl4aW4gbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gTWl4aW4jJCQucGFyZW50QmxvY2sgLSBQYXJlbnQgYmxvY2suXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IE1peGluIyQkLnBhcmVudFNjb3BlIC0gUGFyZW50IHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBNaXhpbiMkJC5wYXJlbnRUZW1wbGF0ZSAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Kn0gTWl4aW4jJCQudmFsdWUgLSBDdXJyZW50IHZhbHVlLlxuICAgICAgICogQHByb3BlcnR5IHtXYXRjaGVyW119IEJsb2NrIyQkLndhdGNoZXJzIC0gVGVtcG9yYXJ5IHZhcnMgd2F0Y2hlcnMuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBCbG9jayMkJC53YXRjaGVyc1RvUmVtb3ZlIC0gV2F0Y2hlcnMgdG8gcmVtb3ZlIGJlZm9yZSByZW1vdmluZyBtaXhpbi5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaW50ZXJuYWwsXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIHdhdGNoZXJzLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBpc1JlbW92ZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY29uc3RydWN0b3IuZXZhbHVhdGVcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoaW50ZXJuYWwudmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoaXNQYXJlbnRTaWduYWwpID0+IHtcbiAgICAgICAgICBpc1BhcmVudFNpZ25hbCA9ICEhaXNQYXJlbnRTaWduYWw7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoaXNQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5taXhpbnMsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IFtNaXhpbiNhcmdzXVxuICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5hcmdzID0gYXJncztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jsb2NrfSBbTWl4aW4jcGFyZW50U2NvcGVdXG4gICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudFRlbXBsYXRlXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbX0gTWl4aW4jZWxlbVxuICAgICAqIEB0eXBlIHtFbGVtfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gTWl4aW4jbm9kZVxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGUgPSBlbGVtWzBdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBbTWl4aW4jbmFtZV1cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnB1c2godGhpcyk7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTWl4aW4jYmVmb3JlUmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0VsZW1lbnRSZW1vdmVkIC0gSWYgZWxlbWVudCByZW1vdmVkIGFzIHdlbGwuXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYmVmb3JlIHRoZSBtaXhpbiByZW1vdmFsLlxuICAgKi9cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IFtjYWxsYmFja10gLSBJZiBwcmVzZW50LCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgbWl4aW4gdmFsdWUgaXMgY2hhbmdlZC5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIHRoZSBtaXhpbiB2YWx1ZSBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZShjYWxsYmFjayk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWc7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoTWl4aW4sICdNaXhpbicpO1xuXG5leHBvcnQgeyBNaXhpbiB9O1xuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQge1xuICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzLFxuICBhc3NpZ24sIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCxcbiAgaXNGdW5jdGlvbiwgc2V0VG9TdHJpbmdUYWcsXG4gIHJlbW92ZUFycmF5RWxlbSwgY3JlYXRlLFxuICBnZXRQcm90bywgc2V0UHJvdG9cbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge1xuICBub3JtYWxpemVBcmdzLCByZW1vdmVXYXRjaGVycywgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCxcbiAgY2xlYW5Qcm9wZXJ0eSwgSW50ZXJuYWxNaXhpbiwgY2FsY3VsYXRlQXJncyxcbiAgd3JhcEJsb2NrLCBleHRlbmRCbG9jaywgZ2V0RGVmYXVsdEFyZ3MsIGlzSW5zdGFuY2VPZlxufSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgYmxvY2tzLCBtaXhpbnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4vTWl4aW4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtCbG9ja05vZGVbXX0gVGVtcGxhdGVcbiAqIEBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IHZhcnMgLSBUZW1wbGF0ZSB1c2VkIHZhcnMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCbG9ja05vZGVcbiAqIEBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfHR5cGVvZiBCbG9ja30gdHlwZSAtIEJsb2NrIHR5cGUuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2FyZ3NdIC0gQmxvY2sgYXJncy5cbiAqIEBwcm9wZXJ0eSB7QmxvY2tOb2RlW119IGNoaWxkcmVuIC0gQmxvY2sgY2hpbGRyZW4uXG4gKiBAcHJvcGVydHkgeyp9IHZhbHVlIC0gVGV4dCBvciBjb21tZW50IG5vZGUgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEV2YWx1YXRpb25FcnJvclxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHdoaWNoIGNhdXNlZCBldmFsIGVycm9yLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG9yaWdpbmFsIC0gRXZhbHVhdGVkIGV4cHJlc3Npb24gb3JpZ2luYWwganMuXG4gKiBAcHJvcGVydHkge0Jsb2NrfSBibG9jayAtIEJsb2NrIGluIGNvbnRleHQgb2Ygd2hpY2ggdGhlIGV4cHJlc3Npb24gaGFzIGJlZW4gZXZhbHVhdGVkIHdpdGggdGhlIGVycm9yLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhdGNoZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdyYXBwZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIEJsb2NrfHR5cGVvZiBNaXhpbn0gQmxvY2sgY2xhc3MgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t9IE5ldyBCbG9jayBjbGFzcy5cbiAqL1xuXG5jb25zdCB0b1N0cmluZ1RhZyA9ICdbb2JqZWN0IEJsb2NrXSc7XG5jb25zdCBhZnRlckVsZW0gPSBuZXcgRWxlbSgpO1xuY29uc3QgZW1wdHlPYmplY3QgPSB7fTtcbmxldCBldmFsTW9kZSA9IGZhbHNlO1xubGV0IGdldHRpbmdWYXJzID0gW107XG5cbi8qKlxuICogQGNsYXNzIEJsb2NrXG4gKiBAZXh0ZW5kcyBudWxsXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEJsb2NrIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7QmxvY2t9IEluc3RhbmNlIG9mIEJsb2NrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBCbG9jaywgaW5pdEFwcCB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogY2xhc3MgQXBwIGV4dGVuZHMgQmxvY2sge1xuICogICBzdGF0aWMgaHRtbCA9IGh0bWxgPEhlbGxvIHRleHQ9XCJ7dGV4dH1cIi8+ICh7IHRoaXMudGltZXMgfSlgO1xuICpcbiAqICAgY29uc3RydWN0b3Iob3B0cykge1xuICogICAgIHN1cGVyKG9wdHMpO1xuICpcbiAqICAgICB0aGlzLnRleHQgPSAnd29ybGQnO1xuICogICAgIHRoaXMudGltZXMgPSAwO1xuICpcbiAqICAgICB0aGlzLnNldEludGVydmFsKCk7XG4gKiAgIH1cbiAqXG4gKiAgIHNldEludGVydmFsKCkge1xuICogICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gKiAgICAgICB0aGlzLnRpbWVzKys7XG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqXG4gKiAgIGJlZm9yZVJlbW92ZSgpIHtcbiAqICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICogICB9XG4gKiB9XG4gKlxuICogQmxvY2suYmxvY2soJ0FwcCcsIEFwcCk7XG4gKiBCbG9jay5ibG9jaygnSGVsbG8nLCBodG1sYEhlbGxvLCB7YXJncy50ZXh0fSFgKTtcbiAqXG4gKiBpbml0QXBwKCdBcHAnLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpKTtcbiAqL1xuY2xhc3MgQmxvY2sge1xuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2suYXJncyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGFyZ3MgZGVzY3JpcHRpb24uXG4gICAqL1xuICBzdGF0aWMgYXJncyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLmRlZmF1bHRMb2NhbHMgPSBudWxsXVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkZWZhdWx0IGxvY2Fscy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0TG9jYWxzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBbQmxvY2suZGlzcGxheU5hbWUgPSBudWxsXVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkaXNwbGF5IG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtUZW1wbGF0ZX0gW0Jsb2NrLmh0bWwgPSBbXV1cbiAgICogQHR5cGUge1RlbXBsYXRlfVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayB0ZW1wbGF0ZS5cbiAgICovXG4gIHN0YXRpYyBodG1sID0gW107XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suZXh0ZW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4odHlwZW9mIEJsb2NrKX0gYmxvY2tzIC0gQmxvY2tzIHRoYXQgd2lsbCBiZSBleHRlbmRlZCBieSB0aGUgY29udGV4dC5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBleHRlbmRpbmcgYmxvY2tzLiBVc3VhbGx5IHVzZWQgd2l0aCBleHRlbmRpbmcgdGhlIGRlZmF1bHQgYmxvY2suXG4gICAqL1xuICBzdGF0aWMgZXh0ZW5kKC4uLmJsb2Nrcykge1xuICAgIHJldHVybiBibG9ja3MucmVkdWNlKGV4dGVuZEJsb2NrLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLm9uRXZhbEVycm9yXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFdmFsdWF0aW9uRXJyb3J9IGVyciAtIFRoZSBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYW4gZXZhbHVhdGlvbiBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBzdGF0aWMgb25FdmFsRXJyb3IoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXZhbCBlcnJvciAoZXZhbHVhdGluZyBcIiR7IGVyci5vcmlnaW5hbCB8fCBlcnIuZnVuYyB9XCIgaW4gY29udGV4dCBvZiAkeyBlcnIuYmxvY2suJCQubmFtZSB9KTpgLCBlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBibG9jay5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IGJsb2NrLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBibG9ja3MgaW50byBhbm90aGVyIGJsb2Nrcy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIGJsb2NrIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gd3JhcHBlcnMucmVkdWNlKHdyYXBCbG9jaywgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczogb3JpZ2luYWxBcmdzLFxuICAgICAgRHluYW1pY0Jsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yIH0gPSBnZXRQcm90byh0aGlzKTtcbiAgICBjb25zdCBuYW1lID0gY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCBjaGlsZHJlbkJsb2NrcyA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuTWl4aW5zID0gW107XG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuICAgIGNvbnN0IGlzRWxlbWVudHMgPSBjb25zdHJ1Y3RvciA9PT0gYmxvY2tzLkVsZW1lbnRzO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjJCRcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQuYXJncyAtIFByaXZhdGUgYXJncyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2tbXX0gQmxvY2sjJCQuY2hpbGRyZW4gLSBDaGlsZCBibG9ja3MuXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IEJsb2NrIyQkLmNvbnRlbnQgLSBDb250ZW50IGVsZW1lbnRzLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R8dm9pZH0gQmxvY2sjJCQuRHluYW1pY0Jsb2NrQXJncyAtIER5bmFtaWNCbG9jayBhcmdzLlxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gQmxvY2sjJCQuZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBCbG9jayMkJC5nbG9iYWxzIC0gUHJpdmF0ZSBnbG9iYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gQmxvY2sjJCQuaHRtbENoaWxkcmVuIC0gQmxvY2sgaHRtbCBjaGlsZHJlbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gQmxvY2sjJCQuaXNSZW1vdmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbW92ZWQuXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IEJsb2NrIyQkLmlzUmVuZGVyZWQgLSBJZiB0aGUgYmxvY2sgaXMgcmVuZGVyZWQuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQubG9jYWxzIC0gUHJpdmF0ZSBsb2NhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge01peGluW119IEJsb2NrIyQkLm1peGlucyAtIENoaWxkIG1peGlucy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gQmxvY2sjJCQubWl4aW5zVG9CdWlsZCAtIFBlbmRpbmcgbWl4aW5zIGJ1aWxkZXJzLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IEJsb2NrIyQkLm5hbWUgLSBCbG9jayBuYW1lLlxuICAgICAgICogQHByb3BlcnR5IHt0eXBlb2YgQmxvY2t9IEJsb2NrIyQkLkNvbnN0cnVjdG9yIC0gQmxvY2sgY29uc3RydWN0b3IuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfEVsZW18dm9pZH0gQmxvY2sjJCQucGFyZW50IC0gUGFyZW50IGJsb2NrIG9yIGVsZW0uXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudEJsb2NrIC0gUGFyZW50IGJsb2NrLlxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBwYXJlbnRFbGVtIC0gUGFyZW50IGVsZW1lbnQuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudFNjb3BlIC0gUGFyZW50IHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBCbG9jayMkJC5wYXJlbnRUZW1wbGF0ZSAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8RWxlbXx2b2lkfSBCbG9jayMkJC5wcmV2QmxvY2sgLSBQYXJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcHJvcGVydHkge1dhdGNoZXJbXX0gQmxvY2sjJCQud2F0Y2hlcnMgLSBUZW1wb3JhcnkgdmFycyB3YXRjaGVycy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IEJsb2NrIyQkLndhdGNoZXJzVG9SZW1vdmUgLSBXYXRjaGVycyB0byByZW1vdmUgYmVmb3JlIHJlbW92aW5nIHRoZSBibG9jay5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgRHluYW1pY0Jsb2NrQXJncyxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBjb250ZW50OiBuZXcgRWxlbSgpLFxuICAgICAgICBDb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG4gICAgICAgIGh0bWxDaGlsZHJlbjogY2hpbGRyZW4gfHwgW10sXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbkJsb2NrcyxcbiAgICAgICAgbWl4aW5zOiBjaGlsZHJlbk1peGlucyxcbiAgICAgICAgbWl4aW5zVG9CdWlsZDogW10sXG4gICAgICAgIHByZXZCbG9jayxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgaXNSZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGV2YWx1YXRlOiAoZnVuYywgb25DaGFuZ2UsIHRhcmdldEJsb2NrLCBmb3JFbGVtZW50cywgZm9ySXRlbSkgPT4ge1xuICAgICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yRWxlbWVudHMgPSAhIWZvckVsZW1lbnRzO1xuXG4gICAgICAgICAgY29uc3Qgc2NvcGUgPSBjb25zdHJ1Y3RvciA9PT0gYmxvY2tzLkl0ZW0gJiYgIWZvckl0ZW1cbiAgICAgICAgICAgID8gdGhpcy4kJC5zY29wZVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgd2F0Y2hlcnNUb1JlbW92ZSB9ID0gdGFyZ2V0QmxvY2sgPyB0YXJnZXRCbG9jay4kJCA6IGVtcHR5T2JqZWN0O1xuICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlRmxhZyA9ICEhb25DaGFuZ2U7XG5cbiAgICAgICAgICBjb25zdCBldmFsdWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChvbkNoYW5nZUZsYWcpIHtcbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBnZXR0aW5nVmFycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHNjb3BlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBlcnIuZnVuYyA9IGZ1bmM7XG4gICAgICAgICAgICAgIGVyci5vcmlnaW5hbCA9IGZ1bmMub3JpZ2luYWw7XG4gICAgICAgICAgICAgIGVyci5ibG9jayA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29uc3RydWN0b3Iub25FdmFsRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9Lm9uRXZhbEVycm9yOmAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2VGbGFnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2F0Y2hlcnMgPSBbXTtcblxuICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkoZ2V0dGluZ1ZhcnMsICh3YXRjaGVycykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhdGNoZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkobG9jYWxXYXRjaGVycywgKHdhdGNoZXJCbG9jaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICB9ID0gd2F0Y2hlckJsb2NrO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVyc1RvUmVtb3ZlLCB3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc3VsdCA9IGV2YWx1YXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHQgIT09IHJlc3VsdCAmJiAhdGFyZ2V0QmxvY2suJCQuaXNSZW1vdmVkICYmICF0aGlzLiQkLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdSZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICBmb3JFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsb2NhbFdhdGNoZXJzLnB1c2god2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLnB1c2god2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBldmFsTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBnZXR0aW5nVmFycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoaXNQYXJlbnRTaWduYWwpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmlzUmVtb3ZlZCA9IHRydWU7XG5cbiAgICAgICAgICByZW1vdmVXYXRjaGVycyh3YXRjaGVyc1RvUmVtb3ZlKTtcblxuICAgICAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbkJsb2NrcywgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuTWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVSZW1vdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KHRoaXMuJCQuY29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBwYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLCB0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQucmVtb3ZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZUNvbnRlbnQ6IChuZXdDb250ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5jb250ZW50ID0gbmV3Q29udGVudDtcblxuICAgICAgICAgIGlmICh0aGlzLiQkLmlzUmVuZGVyZWQgJiYgIXRoaXMuJCQuaXNSZW1vdmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9hZnRlckRPTUNoYW5nZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckRPTUNoYW5nZTpgLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29udGVudDogKGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkQ29udGVudCA9IHRoaXMuJCQuY29udGVudDtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9sZENvbnRlbnQuaW5kZXhPZihjb250ZW50VG9BZGRbMF0ucHJldmlvdXNTaWJsaW5nKSArIDE7XG4gICAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50VG9BZGQuYWRkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoY29udGVudFRvQWRkLCBvbGRDb250ZW50LnNsaWNlKGluZGV4KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KG5ld0NvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgIW5vdFJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvQWRkLCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZUNvbnRlbnQ6IChjb250ZW50VG9Nb3ZlLCBhZnRlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvbGRDb250ZW50LmluZGV4T2YoY29udGVudFRvTW92ZVswXSk7XG4gICAgICAgICAgY29uc3QgaW5kZXhUb1B1dCA9IG9sZENvbnRlbnQuaW5kZXhPZihhZnRlclswXSkgKyAxO1xuICAgICAgICAgIGxldCBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKGluZGV4VG9QdXQgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50VG9Nb3ZlLmFkZChcbiAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGluZGV4VG9QdXQpIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBvbGRDb250ZW50XG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleFRvUHV0KVxuICAgICAgICAgICAgICAuYWRkKFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUb01vdmUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoLCBpbmRleFRvUHV0KSxcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQobmV3Q29udGVudCk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiBpbmRleFRvUHV0KSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvTW92ZSwgYWZ0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ29udGVudDogKGNvbnRlbnRUb1JlbW92ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQuZmlsdGVyKChlbGVtKSA9PiAoXG4gICAgICAgICAgICBjb250ZW50VG9SZW1vdmUuaW5kZXhPZihlbGVtKSA9PT0gLTFcbiAgICAgICAgICApKSk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQoY29udGVudFRvUmVtb3ZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEluU3RhcnRPZkl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcblxuICAgICAgICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcblxuICAgICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSBwYXJlbnQuJCQ7XG5cbiAgICAgICAgICAgIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgICAgbGV0IG5vdFJlY3Vyc2l2ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICAgICAgbm90UmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgdGhpcy4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRBZnRlckl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcbiAgICAgICAgICBsZXQgdHJ5VG9BZGRPck1vdmU7XG5cbiAgICAgICAgICBpZiAodGhpcy4kJC5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLiQkLmNvbnRlbnQuZWxlbSgtMSk7XG4gICAgICAgICAgICB0cnlUb0FkZE9yTW92ZSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIoYWZ0ZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmIHRyeVRvQWRkT3JNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0ZXJhdGVPYmplY3QoY29uc3RydWN0b3IuZGVmYXVsdExvY2FscywgKHZhbHVlLCB2YXJpYWJsZSkgPT4ge1xuICAgICAgdGhpc1t2YXJpYWJsZV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBpdGVyYXRlQXJyYXkoY29uc3RydWN0b3IuaHRtbC52YXJzIHx8IFtdLCAodmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdGhpc1t2YXJpYWJsZV07XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcmdzT2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3M6IGFyZ3NEZXNjcmlwdGlvbnNcbiAgICB9ID0gY29uc3RydWN0b3I7XG4gICAgY29uc3QgZGVmYXVsdEFyZ3MgPSBnZXREZWZhdWx0QXJncyhhcmdzRGVzY3JpcHRpb25zKTtcbiAgICBsZXQgYXJncyA9IGNyZWF0ZShkZWZhdWx0QXJncyk7XG4gICAgbGV0IHdhc1Jlc3Q7XG4gICAgY29uc3QgYXJnc0NoYWluID0gW2RlZmF1bHRBcmdzLCBhcmdzXTtcblxuICAgIGl0ZXJhdGVPYmplY3Qob3JpZ2luYWxBcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgY29uc3QgaXNSZXN0ID0gdmFsdWUubWl4aW4gPT09IG1peGlucy5SZXN0O1xuICAgICAgY29uc3QgbG9jYWxBcmdzID0gaXNSZXN0IHx8IHdhc1Jlc3RcbiAgICAgICAgPyBjcmVhdGUoYXJncylcbiAgICAgICAgOiBhcmdzO1xuXG4gICAgICBpZiAoYXJncyAhPT0gbG9jYWxBcmdzKSB7XG4gICAgICAgIGFyZ3NDaGFpbi5wdXNoKGxvY2FsQXJncyk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSBsb2NhbEFyZ3M7XG5cbiAgICAgIGlmIChpc1Jlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdEFyZ3MgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZU9iamVjdChsb2NhbEFyZ3MsIGNsZWFuUHJvcGVydHkpO1xuICAgICAgICAgIGFzc2lnbihsb2NhbEFyZ3MsIHZhbHVlKTtcbiAgICAgICAgICBjYWxjdWxhdGVBcmdzKG5vcm1hbGl6ZUFyZ3MoYXJnc0NoYWluKSwgYXJncywgYXJnc09iamVjdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHdhc1Jlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBcmdzLCByZXN0QXJncyk7XG4gICAgICB9XG5cbiAgICAgIHdhc1Jlc3QgPSBmYWxzZTtcblxuICAgICAgaWYgKGlzSW5zdGFuY2VPZihNaXhpbiwgdmFsdWUubWl4aW4pKSB7XG4gICAgICAgIGxvY2FsQXJnc1thcmddID0gbmV3IEludGVybmFsTWl4aW4oe1xuICAgICAgICAgIE1peGluOiB2YWx1ZS5taXhpbixcbiAgICAgICAgICBhcmdzOiB2YWx1ZS5hcmdzLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9yRWxlbWVudHMgPSBpc0VsZW1lbnRzICYmIGFyZyA9PT0gJ3ZhbHVlJztcblxuICAgICAgbG9jYWxBcmdzW2FyZ10gPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsQXJnc1thcmddID0gdmFsdWU7XG4gICAgICAgIGNhbGN1bGF0ZUFyZ3Mobm9ybWFsaXplQXJncyhhcmdzQ2hhaW4pLCBhcmdzLCBhcmdzT2JqZWN0KTtcbiAgICAgIH0sIHRoaXMsIGZvckVsZW1lbnRzLCBpc0VsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLkNvbnN0cnVjdG9yID09PSBibG9ja3MuSXRlbSk7XG4gICAgfSk7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNhcmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhcmdzOiBhcmdzT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjZ2xvYmFsc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZ2xvYmFsczogY3JlYXRlKFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgICAgID8gcGFyZW50U2NvcGUuZ2xvYmFsc1xuICAgICAgICAgIDogbnVsbFxuICAgICAgKVxuICAgIH0pO1xuXG4gICAgY2FsY3VsYXRlQXJncyhub3JtYWxpemVBcmdzKGFyZ3NDaGFpbiksIGFyZ3MsIGFyZ3NPYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudEJsb2NrKSB7XG4gICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI19hZnRlckNvbnN0cnVjdFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5hZnRlckNvbnN0cnVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3RcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGNvbnN0cnVjdGlvbiAoaW5jbHVkaW5nIGFsbCBzY29wZXMpXG4gICAqIGJ1dCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBibG9jayBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI19hZnRlckRPTUNoYW5nZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfYWZ0ZXJET01DaGFuZ2UoKSB7XG4gICAgdGhpcy5hZnRlckRPTUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJET01DaGFuZ2VcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIERPTSBzdHJ1Y3R1cmUgaGFzIGNoYW5nZWQuIE5vdGUgdGhhdFxuICAgKiBpdCdzIGltcG9ydGFudCBub3QgdG8gbW9kaWZ5IHRoZSBET00gc3RydWN0dXJlIHdpdGhpbiB0aGUgYmxvY2suIFlvdSBjYW4gb25seSBpbnNlcnRcbiAgICogZWxlbWVudHMgdG8gZW1wdHkgZWxlbWVudHMgKHdoaWNoIER3YXluZSBjb25zaWRlcnMgZW1wdHkpIGFuZCByZW1vdmUgb25lcyBmcm9tIHRoZW0uXG4gICAqL1xuICBhZnRlckRPTUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjX2FmdGVyUmVuZGVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9hZnRlclJlbmRlcigpIHtcbiAgICB0aGlzLmFmdGVyUmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlclJlbmRlclxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAqL1xuICBhZnRlclJlbmRlcigpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjX2JlZm9yZVJlbW92ZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfYmVmb3JlUmVtb3ZlKCkge1xuICAgIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNiZWZvcmVSZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGJlZm9yZSB0aGUgYmxvY2sgcmVtb3ZhbC5cbiAgICovXG4gIGJlZm9yZVJlbW92ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0Q29uc3RydWN0b3JcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7dHlwZW9mIEJsb2NrfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBCbG9jayBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdldENvbnN0cnVjdG9yKCkge1xuICAgIHJldHVybiBnZXRQcm90byh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldERPTVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBET00gY29udGVudHMgb2YgdGhlIGJsb2NrLlxuICAgKi9cbiAgZ2V0RE9NKCkge1xuICAgIHJldHVybiB0aGlzLiQkLmNvbnRlbnQuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldE5hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBCbG9jayBuYW1lLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50RWxlbVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfHZvaWR9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHBhcmVudCBFbGVtLlxuICAgKi9cbiAgZ2V0UGFyZW50RWxlbSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRFbGVtLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRTY29wZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBibG9jayBpbiB3aGljaCB0ZW1wbGF0ZSB0aGUgYmxvY2sgaXMgbG9jYXRlZCBpbi5cbiAgICovXG4gIGdldFBhcmVudFNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudFNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50VGVtcGxhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QmxvY2t8dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYmxvY2sgaW4gd2hpY2ggdGVtcGxhdGUgdGhlIGJsb2NrIGlzIGxvY2F0ZWQgaW4uXG4gICAqL1xuICBnZXRQYXJlbnRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IFtjYWxsYmFja10gLSBJZiBwcmVzZW50LCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge0Jsb2NrfE1peGlufSBbdGFyZ2V0ID0gdGhpc10gLSBXaGF0IGJsb2NrIG9yIG1peGluIHJlcXVlc3RzIHRoZSB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gaW4gY29udGV4dCBvZiB0aGUgYmxvY2sgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGZ1bmMsIGNhbGxiYWNrLCB0YXJnZXQgPSB0aGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWc7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoQmxvY2ssICdCbG9jaycpO1xuc2V0UHJvdG8oQmxvY2sucHJvdG90eXBlLCBudWxsKTtcblxuZXhwb3J0IHsgQmxvY2ssIGdldHRpbmdWYXJzLCBldmFsTW9kZSB9O1xuIiwiaW1wb3J0IHsgQmxvY2sgYXMgQmFzZUJsb2NrIH0gZnJvbSAnLi9CbG9jayc7XG5cbmNsYXNzIEJsb2NrIGV4dGVuZHMgQmFzZUJsb2NrIHt9XG5cbmV4cG9ydCB7IEJsb2NrIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcblxuY2xhc3MgQ2FzZSBleHRlbmRzIEJsb2NrIHt9XG5cbmV4cG9ydCB7IENhc2UgfTtcbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgcmVtb3ZlQXJyYXlFbGVtIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCwgY3JlYXRlQmxvY2sgfSBmcm9tICcuLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgYmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgYXJncy52YWx1ZWA7XG5cbmNsYXNzIEVsZW1lbnRzIGV4dGVuZHMgQmxvY2sge1xuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICBjb25zdCB7IHBhcmVudEVsZW0gfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICB0aGlzLiQkLmV2YWx1YXRlKHdhdGNoQXJncywgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtaXhpbnMsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IHRoaXMuJCQ7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG5cbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kJC5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy4kJC5taXhpbnMgPSBbXTtcbiAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JFbGVtZW50cyB9KSA9PiB7XG4gICAgICAgIGlmIChmb3JFbGVtZW50cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHdhdGNoZXJzLCB3YXRjaGVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kJC5jb250ZW50ID0gbmV3IEVsZW0oKTtcblxuICAgICAgbGV0IHByZXZCbG9jaztcblxuICAgICAgaXRlcmF0ZUFycmF5KHZhbHVlIHx8IFtdLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZUFycmF5KHRoaXMuJCQubWl4aW5zVG9CdWlsZCwgKGV4ZWN1dGVCdWlsZGVycykgPT4ge1xuICAgICAgICBleGVjdXRlQnVpbGRlcnMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kJC5taXhpbnNUb0J1aWxkID0gW107XG4gICAgfSwgdGhpcywgdHJ1ZSk7XG4gIH1cbn1cblxuYmxvY2tzLkVsZW1lbnRzID0gRWxlbWVudHM7XG5cbmV4cG9ydCB7IEVsZW1lbnRzIH07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuL0VsZW1lbnRzJztcblxuY2xhc3MgQ2hpbGRyZW4gZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyBodG1sID0gaHRtbGBcbiAgICA8RWxlbWVudHNcbiAgICAgIHZhbHVlPVwie2VsZW1zfVwiXG4gICAgICBwYXJlbnRTY29wZT1cInskJC5wYXJlbnRUZW1wbGF0ZS4kJC5wYXJlbnRTY29wZX1cIlxuICAgICAgcGFyZW50VGVtcGxhdGU9XCJ7JCQucGFyZW50VGVtcGxhdGUuJCQucGFyZW50VGVtcGxhdGV9XCJcbiAgICAvPlxuICBgO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFRlbXBsYXRlOiB7XG4gICAgICAgICQkOiB7IGh0bWxDaGlsZHJlbiB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3QgeyBuYW1lIH0gPSB0aGlzLmFyZ3M7XG4gICAgbGV0IGZvdW5kO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGZvdW5kID0gZmluZEluQXJyYXkoaHRtbENoaWxkcmVuLCAoeyB0eXBlLCBhcmdzIH0pID0+IChcbiAgICAgICAgdHlwZSA9PT0gQ2hpbGRyZW5cbiAgICAgICAgJiYgYXJnc1xuICAgICAgICAmJiBhcmdzLm5hbWUgPT09IG5hbWVcbiAgICAgICkpO1xuXG4gICAgICB0aGlzLmVsZW1zID0gZm91bmRcbiAgICAgICAgPyBmb3VuZC52YWx1ZS5jaGlsZHJlblxuICAgICAgICA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbXMgPSBodG1sQ2hpbGRyZW47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IENoaWxkcmVuIH07XG5cbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgYmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MudHlwZWA7XG5cbmNsYXNzIER5bmFtaWNCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGh0bWwgPSBodG1sYFxuICAgIDxFbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3QoXG4gICAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgdGhpcy5jb25zdHJ1Y3QpXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdCA9ICh0eXBlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgRHluYW1pY0Jsb2NrQXJnc1xuICAgIH0gPSB0aGlzLiQkO1xuXG4gICAgdGhpcy5lbGVtcyA9IFt7XG4gICAgICB0eXBlLFxuICAgICAgYXJnczogRHluYW1pY0Jsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBodG1sQ2hpbGRyZW5cbiAgICB9XTtcbiAgfTtcbn1cblxuYmxvY2tzLkR5bmFtaWNCbG9jayA9IER5bmFtaWNCbG9jaztcblxuZXhwb3J0IHsgRHluYW1pY0Jsb2NrIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5pbXBvcnQgeyBibG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jbGFzcyBJdGVtIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgaHRtbCA9IGh0bWxgXG4gICAgPEVsZW1lbnRzXG4gICAgICB2YWx1ZT1cInskJC5odG1sQ2hpbGRyZW59XCJcbiAgICAgIHBhcmVudFNjb3BlPVwie3RoaXN9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcbn1cblxuYmxvY2tzLkl0ZW0gPSBJdGVtO1xuXG5leHBvcnQgZGVmYXVsdCBJdGVtO1xuIiwiaW1wb3J0IHtcbiAgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICBpc0FycmF5LCBpc0Z1bmN0aW9uLCBjcmVhdGVcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlLCBjcmVhdGVCbG9jayB9IGZyb20gJy4uL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL0l0ZW0nO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BbXG4gIGFyZ3Muc2V0LFxuICBhcmdzLmZpbHRlckJ5LFxuICBhcmdzLnNvcnRCeVxuXWA7XG5cbmNsYXNzIEVhY2ggZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyBhcmdzID0ge1xuICAgIHVpZDoge1xuICAgICAgZGVmYXVsdChpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3M6IHtcbiAgICAgICAgaXRlbSA9ICckaXRlbScsXG4gICAgICAgIGluZGV4ID0gJyRpbmRleCdcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcblxuICAgIHRoaXMuaXRlbU5hbWUgPSBpdGVtO1xuICAgIHRoaXMuaW5kZXhOYW1lID0gaW5kZXg7XG4gICAgdGhpcy5pdGVtc0J5VUlEcyA9IGNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGFmdGVyQ29uc3RydWN0KCkge1xuICAgIHRoaXMucmVuZGVyU2V0KFxuICAgICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsIHRoaXMucmVuZGVyU2V0KVxuICAgICk7XG4gIH1cblxuICByZW5kZXJTZXQgPSAoYXJncykgPT4ge1xuICAgIGxldCBzZXQgPSBhcmdzWzBdO1xuICAgIGxldCBmaWx0ZXJCeSA9IGFyZ3NbMV07XG4gICAgY29uc3Qgc29ydEJ5ID0gYXJnc1syXTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczoge1xuICAgICAgICB1aWQ6IFVJRFxuICAgICAgfSxcbiAgICAgIGl0ZW1zQnlVSURzLFxuICAgICAgaXRlbU5hbWUsXG4gICAgICBpbmRleE5hbWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdJdGVtc0J5VUlEcyA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBuZXdVSURzQnlJbmRleGVzID0gY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IG5ld1VJRHMgPSBjcmVhdGUobnVsbCk7XG4gICAgY29uc3QgaXNBcnIgPSBpc0FycmF5KHNldCk7XG4gICAgY29uc3QgaXRlcmF0ZSA9IGlzQXJyXG4gICAgICA/IGl0ZXJhdGVBcnJheVxuICAgICAgOiBpdGVyYXRlT2JqZWN0O1xuXG4gICAgaWYgKGlzQXJyICYmIGlzRnVuY3Rpb24oc29ydEJ5KSkge1xuICAgICAgc2V0ID0gc2V0XG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5zb3J0KHNvcnRCeSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oZmlsdGVyQnkpKSB7XG4gICAgICBmaWx0ZXJCeSA9IFtmaWx0ZXJCeV07XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoZmlsdGVyQnkpKSB7XG4gICAgICBpdGVyYXRlQXJyYXkoZmlsdGVyQnksIChmaWx0ZXIpID0+IHtcbiAgICAgICAgc2V0ID0gc2V0LmZpbHRlcihmaWx0ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZShzZXQsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdWlkID0gVUlEKGl0ZW0sIGluZGV4LCBzZXQsIHBhcmVudFNjb3BlKTtcblxuICAgICAgaWYgKHVpZCBpbiBuZXdVSURzQnlJbmRleGVzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVJRHMgY2FuJ3QgYmUgc2FtZSBmb3IgbXVsdGlwbGUgaXRlbXMhIEluIFVJRCBmdW5jdGlvbjogXCIkeyBVSUQub3JpZ2luYWwgfHwgVUlEIH1cImApO1xuICAgICAgfVxuXG4gICAgICBuZXdVSURzQnlJbmRleGVzW3VpZF0gPSBpbmRleDtcbiAgICAgIG5ld1VJRHNbaW5kZXhdID0gdWlkO1xuICAgIH0pO1xuXG4gICAgaXRlcmF0ZU9iamVjdChpdGVtc0J5VUlEcywgKGJsb2NrLCB1aWQpID0+IHtcbiAgICAgIGlmICghKHVpZCBpbiBuZXdVSURzQnlJbmRleGVzKSkge1xuICAgICAgICByZW1vdmUoYmxvY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHByZXZCbG9jaztcblxuICAgIGl0ZXJhdGUoc2V0LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHVpZCA9IG5ld1VJRHNbaW5kZXhdO1xuICAgICAgbGV0IGJsb2NrO1xuXG4gICAgICBpZiAobmV3VUlEc0J5SW5kZXhlc1t1aWRdICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZXZVSURCbG9jayA9IGl0ZW1zQnlVSURzW3VpZF07XG5cbiAgICAgIGlmIChwcmV2VUlEQmxvY2spIHtcbiAgICAgICAgYmxvY2sgPSBwcmV2VUlEQmxvY2s7XG4gICAgICAgIGJsb2NrLiQkLnNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcbiAgICAgICAgYmxvY2suJCQuc2NvcGVbaXRlbU5hbWVdID0gaXRlbTtcblxuICAgICAgICBpZiAoYmxvY2suJCQucHJldkJsb2NrICE9PSBwcmV2QmxvY2spIHtcbiAgICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IGJsb2NrLiQkO1xuXG4gICAgICAgICAgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICB0eXBlOiBJdGVtLFxuICAgICAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgICAgICBpbmRleE5hbWUsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBjaGlsZHJlbjogaHRtbENoaWxkcmVuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5ld0l0ZW1zQnlVSURzW3VpZF0gPSBibG9jaztcbiAgICAgIGJsb2NrLiQkLnByZXZCbG9jayA9IHByZXZCbG9jaztcbiAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pdGVtc0J5VUlEcyA9IG5ld0l0ZW1zQnlVSURzO1xuICB9O1xufVxuXG5leHBvcnQgeyBFYWNoIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MuaWZgO1xuXG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGh0bWwgPSBodG1sYFxuICAgIDxFbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5jb25kaXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0cnVjdEVsZW1zKHRoaXMuZXZhbHVhdGUod2F0Y2hBcmdzLCB0aGlzLmNvbnN0cnVjdEVsZW1zKSk7XG4gIH1cblxuICBjb25zdHJ1Y3RFbGVtcyA9IChjb25kaXRpb24pID0+IHtcbiAgICBjb25kaXRpb24gPSAhIWNvbmRpdGlvbjtcblxuICAgIGlmICh0aGlzLmNvbmRpdGlvbiAhPT0gY29uZGl0aW9uKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIHRoaXMuZWxlbXMgPSBjb25kaXRpb25cbiAgICAgICAgPyB0aGlzLiQkLmh0bWxDaGlsZHJlblxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBJZiB9O1xuIiwiaW1wb3J0IHsgZmluZEluQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5pbXBvcnQgeyBDYXNlIH0gZnJvbSAnLi9DYXNlJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgW1xuICBhcmdzLnZhbHVlLFxuICBhcmdzLmNvbXBhcmVGblxuXWA7XG5cbmNsYXNzIFN3aXRjaCBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGh0bWwgPSBodG1sYFxuICAgIDxFbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG4gIHN0YXRpYyBhcmdzID0ge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjb21wYXJlRm46IHtcbiAgICAgIGRlZmF1bHQoc3dpdGNoVmFsdWUsIGNhc2VWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHN3aXRjaFZhbHVlID09PSBjYXNlVmFsdWVcbiAgICAgICAgICB8fCAoc3dpdGNoVmFsdWUgIT09IHN3aXRjaFZhbHVlICYmIGNhc2VWYWx1ZSAhPT0gY2FzZVZhbHVlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICQkOiB7XG4gICAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgICAgcGFyZW50U2NvcGVcbiAgICAgIH0sXG4gICAgICBhcmdzOiBzd2l0Y2hBcmdzLFxuICAgICAgYXJnczogeyB2YWx1ZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHdhc0RlZmF1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMudmFsdWVzID0gaHRtbENoaWxkcmVuXG4gICAgICAuZmlsdGVyKCh7IHR5cGUsIGFyZ3MgfSkgPT4ge1xuICAgICAgICBpZiAodHlwZSAhPT0gQ2FzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3YXNEZWZhdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5kZWZhdWx0KSB7XG4gICAgICAgICAgd2FzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAubWFwKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJncyA9IHt9LFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgbGV0IHZhbDtcblxuICAgICAgICBpZiAoIWFyZ3MuZGVmYXVsdCkge1xuICAgICAgICAgIHZhbCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGFyZ3Mud2hlbiwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc1tpXS52YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZpbmRJbkFycmF5KHRoaXMudmFsdWVzLCAoeyBhcmdzLCB2YWx1ZSB9KSA9PiAoXG4gICAgICAgICAgICAgIGFyZ3MuZGVmYXVsdFxuICAgICAgICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKHN3aXRjaEFyZ3MudmFsdWUsIHZhbHVlKVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZFxuICAgICAgICAgICAgICA/IGZvdW5kLmtleVxuICAgICAgICAgICAgICA6IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kXG4gICAgICAgICAgICAgID8gZm91bmQudmFsdWUuY2hpbGRyZW5cbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5ICYmIChcbiAgICAgICAgICBhcmdzLmRlZmF1bHRcbiAgICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKHZhbHVlLCB2YWwpXG4gICAgICAgICkpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgKGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gYXJnc1swXTtcbiAgICAgIGNvbnN0IGNvbXBhcmVGbiA9IGFyZ3NbMV07XG5cbiAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcblxuICAgICAgdGhpcy52YWx1ZXMuc29tZSgoeyBhcmdzLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXJncy5kZWZhdWx0XG4gICAgICAgICAgfHwgY29tcGFyZUZuKG5ld1ZhbHVlLCB2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3dpdGNoIH07XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBub29wIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5cbmNsYXNzIEJpbmQgZXh0ZW5kcyBNaXhpbiB7XG4gIG9mZiA9IG5vb3A7XG5cbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLm9mZigpO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYgPSBub29wO1xuXG4gICAgICBjb25zb2xlLmVycm9yKCdQcm92aWRlIFwiQmluZFwiIG1peGluIHdpdGggZXZlbnQgbmFtZSBhcmdzIChsaWtlIFwiQmluZChjbGljaylcIiBvciBcIkJpbmQoa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5vZmYoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQmluZCB9O1xuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSwgaXNTdHJpbmcsXG4gIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY29uc3QgRU1QVFlfU1BBQ0VfUkVHRVggPSAvXFxzKy87XG5cbmNsYXNzIENsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICBjbGFzc2VzID0gW107XG5cbiAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNsYXNzZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdDbGFzc2VzID0gW107XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgICA/IGFyZ3NcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNwbGl0KEVNUFRZX1NQQUNFX1JFR0VYKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKGNscykgPT09IC0xKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVBcnJheShuZXdWYWx1ZSwgKGNscykgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcoY2xzKSkge1xuICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmICghbmV3VmFsdWUgfHwgIW5ld1ZhbHVlW2Nsc10pIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZU9iamVjdChuZXdWYWx1ZSwgKHZhbCwgY2xzKSA9PiB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NlcyA9IG5ld0NsYXNzZXM7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBjbGFzc2VzXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgZWxlbS5yZW1vdmVDbGFzcy5hcHBseShlbGVtLCBjbGFzc2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQ2xhc3MgfTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgRWxlbSBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJncyxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZWxlbVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBzY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGUoKTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoZWxlbSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHNjb3BlW3ZhbHVlXSA9IGVsZW07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEVsZW0gYXMgRWxlbU1peGluIH07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgSGlkZSBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5lbGVtLnNob3coKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgSGlkZSB9O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuXG5jbGFzcyBOb2RlIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBub2RlXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHNjb3BlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogcGFyZW50VGVtcGxhdGU7XG4gICAgICB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgc2NvcGVbdmFsdWVdID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgTm9kZSBhcyBOb2RlTWl4aW4gfTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgT24gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksICgpID0+IHtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmID0gbm9vcDtcblxuICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcIk9uXCIgbWl4aW4gd2l0aCBldmVudCBuYW1lIGFyZ3MgKGxpa2UgXCJPbihjbGljaylcIiBvciBcIk9uKGtleXVwLCBrZXlwcmVzcylcIikhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICBpZiAoIWlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICAgIHRoaXMub2ZmKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IE9uIH07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IG1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNsYXNzIFJlc3QgZXh0ZW5kcyBNaXhpbiB7fVxuXG5taXhpbnMuUmVzdCA9IFJlc3Q7XG5cbmV4cG9ydCB7IFJlc3QgfTtcbiIsImltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuXG5jbGFzcyBTaG93IGV4dGVuZHMgTWl4aW4ge1xuICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBTaG93IH07XG4iLCJpbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcbmltcG9ydCB7IGNyZWF0ZUhpZGVTdHlsZU5vZGUgfSBmcm9tICcuL2hlbHBlcnMvRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGRvY1xuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGh0bWxcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IG5ldyBFbGVtKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBib2R5XG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmJvZHkuXG4gKi9cbmV4cG9ydCBjb25zdCBib2R5ID0gbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBoZWFkXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFkID0gbmV3IEVsZW0oZG9jdW1lbnQuaGVhZCk7XG5cbmNyZWF0ZUhpZGVTdHlsZU5vZGUoaGVhZCk7XG4iXSwibmFtZXMiOlsiY29sbGVjdEZyb21BcnJheSIsImFycmF5IiwiY2FsbGJhY2siLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZSIsImluZGV4IiwiZmluZEluQXJyYXkiLCJpIiwibGVuZ3RoIiwiaXRlcmF0ZUFycmF5IiwicmVtb3ZlQXJyYXlFbGVtIiwiZWxlbSIsImluZGV4T2YiLCJzcGxpY2UiLCJ0b09iamVjdEtleXMiLCJhZGRLZXkiLCJ2YXJzIiwidmFyaWFibGUiLCJpc0Z1bmN0aW9uIiwiaXNOaWwiLCJpc1N0cmluZyIsImFzc2lnbiIsInRhcmdldCIsImFyZ3VtZW50cyIsImtleSIsImNvbGxlY3RGcm9tT2JqZWN0Iiwib2JqZWN0IiwiZXhjZXB0IiwibmV3T2JqZWN0IiwicGF0aHMiLCJzbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzIiwiaXRlcmF0ZU9iamVjdCIsIm1hcE9iamVjdCIsImRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwibmFtZSIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lRnJvemVuUHJvcGVydGllcyIsIm5vb3AiLCJ0b0NhbWVsQ2FzZSIsInJlcGxhY2UiLCJEQVNIRURfU1lNQk9MX1JFR0VYIiwiY2FwaXRhbGl6ZSIsInRvSHlwaGVuQ2FzZSIsIlVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYIiwiaHlwaGVuaXplIiwibWF0Y2giLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsInNldFRvU3RyaW5nVGFnIiwia2xhc3MiLCJ0YWciLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJhZGRBdHRyIiwiYXR0cnMiLCJhdHRyIiwiYWRkQ1NTUHJvcCIsImNzcyIsInByb3BlcnR5Iiwic3BsaXQiLCJDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgiLCJhZGREYXRhQXR0ciIsImRhdGEiLCJhZGROZXh0IiwiYWRkIiwibmV4dFNpYmxpbmciLCJhZGRQYXJlbnQiLCJwYXJlbnROb2RlIiwiYWRkUHJldiIsInByZXZpb3VzU2libGluZyIsImNyZWF0ZUhpZGVTdHlsZU5vZGUiLCJoZWFkIiwiZmluZCIsIkhJREVfQ0xBU1MiLCJjcmVhdGUiLCJwcm9wIiwidGV4dCIsImdldEF0dHJOUyIsImlzWG1sTnMiLCJub2RlTmFtZSIsIk51bGwiLCJYTUxfTlMiLCJYX0xJTktfQVRUUl9GSU5EX1JFR0VYIiwidGVzdCIsIkVsZW0iLCJjbG9zZXN0IiwiWF9MSU5LX05TIiwiWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCIsImlzRG9jdW1lbnQiLCJET0NVTUVOVF9SRUdFWCIsImlzRWxlbSIsImlzRWxlbWVudHNDb2xsZWN0aW9uIiwiSFRNTF9DT0xMRUNUSU9OX1JFR0VYIiwiaXNBcnJheSIsImlzVmFsaWROb2RlIiwiRUxFTUVOVF9SRUdFWCIsImdldEV2ZW50IiwiZXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInJlYWxEZXRhaWxzIiwiZmluYWxFdmVudCIsIkVWRU5UX1JFR0VYIiwiRXZlbnQiLCJlcnIiLCJkb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImhpZGUiLCJhZGRDbGFzcyIsImdldE1hdGNoZXNGdW5jdGlvbiIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJzZWxlY3RvciIsInRoaXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlIiwicGFyZW50IiwicmVtb3ZlQ2hpbGQiLCJzaG93IiwicmVtb3ZlQ2xhc3MiLCJ0b0VsZW0iLCJiYXNlIiwiU3RyaW5nIiwiY2FsY3VsYXRlQXJncyIsIm5vcm1hbGl6ZWRBcmdzIiwiYXJncyIsImFyZ3NPYmplY3QiLCJrZXlzIiwiYXJnIiwidW5kZWZpbmVkIiwiY2xlYW5Qcm9wZXJ0eSIsImV4ZWN1dGVNaXhpbldhdGNoZXJzIiwibWl4aW4iLCJvbGRWYWx1ZSIsIiQkIiwid2F0Y2hlcnMiLCJ3YXRjaGVyIiwiY2FsY3VsYXRlQXR0cnMiLCJuZXdBdHRycyIsImN1cnJlbnRBdHRycyIsImN1cnJlbnRNaXhpbnMiLCJwYXJlbnRCbG9jayIsImZpcnN0VGltZSIsIkludGVybmFsTWl4aW4iLCJyZW1vdmVBdHRyIiwibWl4aW5zIiwicHJldlZhbHVlIiwicGFyZW50U2NvcGUiLCJNaXhpbiIsImV2YWxGbiIsIm5ld1ZhbHVlIiwiaW50ZXJuYWwiLCJpbnRlcm5hbHMiLCJwdXNoIiwiZXZhbHVhdGUiLCJjb25zdHJ1Y3RNaXhpbldhdGNoZXIiLCJidWlsZE1peGluIiwiYWZ0ZXJVcGRhdGUiLCJlcnJvciIsImludGVybmFsTWl4aW4iLCJidWlsZGVyIiwibm9ybWFsaXplQXJncyIsImFyZ3NDaGFpbiIsIm5ld0FyZ3MiLCJjb25zdHJ1Y3RQcml2YXRlU2NvcGUiLCJ0eXBlIiwic2NvcGUiLCJnbG9iYWxzIiwicmVtb3ZlVGVtcFdhdGNoZXIiLCJyZW1vdmVXYXRjaGVycyIsIndhdGNoZXJzVG9SZW1vdmUiLCJyZW1vdmVXYXRjaGVyIiwiY29uc3RydWN0UHVibGljU2NvcGUiLCJzY29wZVZhbHVlcyIsInByaXZhdGVTY29wZSIsImV2YWxNb2RlIiwiZ2V0dGluZ1ZhcnMiLCJvbGRUZW1wV2F0Y2hlcnMiLCJpc0luc3RhbmNlT2YiLCJDbGFzcyIsIlN1YmNsYXNzIiwiaXNQcm90b3R5cGVPZiIsImNyZWF0ZUJsb2NrIiwibm9kZSIsInBhcmVudEVsZW0iLCJwYXJlbnRUZW1wbGF0ZSIsInByZXZCbG9jayIsImRvYyIsImlzRWxlbWVudHMiLCJibG9ja3MiLCJFbGVtZW50cyIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJEeW5hbWljQmxvY2tBcmdzIiwiRHluYW1pY0Jsb2NrIiwiQmxvY2siLCJodG1sIiwiRXJyb3IiLCJuYW1lc3BhY2VVUkkiLCJTVkdfTlMiLCJ3YXNSZXN0IiwiYXR0cnNDaGFpbiIsImlzUmVzdCIsIlJlc3QiLCJsb2NhbEF0dHJzIiwicmVzdEF0dHJzIiwibWl4aW5zVG9CdWlsZCIsImlzUGFyZW50QmxvY2siLCJjaGlsZEJsb2NrcyIsIm9uIiwiaXRlcmF0ZUNoaWxkcmVuIiwiaXNSb290IiwiY2hpbGQiLCJjb250ZW50IiwiaW50byIsImNvbnRlbnREb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImluc2VydEFmdGVySXQiLCJpbnNlcnRBZnRlciIsImFkZENvbnRlbnQiLCJpbnNlcnRJblN0YXJ0T2ZJdCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlbXB0eUFycmF5IiwiYmxvY2tJbnN0YW5jZSIsIkFyZ3MiLCJsb2NhbHMiLCJJdGVtIiwiaXRlbU5hbWUiLCJpdGVtIiwiaW5kZXhOYW1lIiwiQ29uc3RydWN0b3IiLCJfYWZ0ZXJDb25zdHJ1Y3QiLCJpc1JlbmRlcmVkIiwiZXhlY3V0ZUJ1aWxkZXJzIiwiX2FmdGVyUmVuZGVyIiwiZXh0ZW5kQmxvY2siLCJibG9jayIsIm5ld0Jsb2NrIiwiY3VycmVudEJsb2NrIiwicHJvdG8iLCJnZXRQcm90byIsImV4dGVuZCIsIkJhc2VCbG9jayIsImdldERlZmF1bHRBcmdzIiwiYXJnc0Rlc2NyaXB0aW9ucyIsImRlZiIsImRlZmF1bHQiLCJyZW1vdmVXaXRoUGFyZW50U2lnbmFsIiwid3JhcEJsb2NrIiwid3JhcHBlciIsIndyYXBNaXhpbiIsIm5ld01peGluIiwiY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nIiwic3R5bGUiLCJDU1NfU1RZTEVfU0VQQVJBVE9SX1JFR0VYIiwidHJpbSIsImdldFByb3AiLCJoYXNBdHRyIiwiZ2V0VmFsdWVGb3JTZXR0aW5nIiwiaW5wdXRWYWx1ZSIsImlzUmFkaW8iLCJnZXRWYWx1ZUZvckdldHRpbmciLCJ2YWx1ZXMiLCJvcHRpb25zIiwiaW5pdCIsImlzTXVsdGlwbGUiLCJhZGRWYWx1ZSIsImNvbmNhdCIsImdldExpc3RlbmVyTmFtZSIsInNlbGVjdGVkIiwiaW5zZXJ0SHRtbCIsInRlbXBsYXRlcyIsIm5ld1RlbXBsYXRlcyIsIm5ld1ZhcnMiLCJpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4iLCJub2RlcyIsInRyaW1tZWQiLCJuZXdUZW1wbGF0ZSIsImluaXRBcHAiLCJjb250YWluZXIiLCJSb290QmxvY2siLCJyb290QmxvY2siLCJyZW1vdmVBcHAiLCJEd2F5bmVSb290QmxvY2siLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiQXJyYXkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJzZXRQcm90byIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsImVtcHR5Q29sbGVjdGlvbiIsIl90aGlzIiwiaW5jbHVkZXMiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiZWxlbXMiLCJlbGVtZW50cyIsImNsYXNzZXMiLCJmb3JFYWNoIiwibGlzdCIsImNsYXNzTGlzdCIsImNscyIsImF0dHJpYnV0ZXMiLCJucyIsImdldEF0dHJpYnV0ZU5TIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZE5vZGVzIiwiY29sbGVjdCIsImlzIiwiY2IiLCJlbGVtZW50IiwiY29udGFpbnMiLCJlbCIsImlzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUVsZW1lbnQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0UHJvcGVydHlQcmlvcml0eSIsInJlbW92ZUNTUyIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJjc3NUZXh0IiwiZGF0YXNldCIsImRldGFpbHMiLCJkaXNwYXRjaEV2ZW50IiwiZmlsdGVyIiwiaGFzQXR0cmlidXRlTlMiLCJoYXNBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJuZXh0IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJlbmQiLCJmaXJzdENoaWxkIiwibGlzdGVuZXIiLCJuZXdFdmVudHMiLCJhbGxMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwcm9wcyIsImZpcnN0IiwicHJldiIsImJhYmVsSGVscGVycy5nZXQiLCJhcHBseSIsInRleHRDb250ZW50IiwiY29uZGl0aW9uIiwiX2FyZ3VtZW50cyIsIl9hcmd1bWVudHMyIiwic3BlY2llcyIsIm9wdHMiLCJkaXNwbGF5TmFtZSIsImN1cnJlbnRWYWx1ZSIsImlzUGFyZW50U2lnbmFsIiwiaXNSZW1vdmVkIiwiYmVmb3JlUmVtb3ZlIiwid3JhcHBlcnMiLCJyZWR1Y2UiLCJpc0VsZW1lbnRSZW1vdmVkIiwiYWZ0ZXJFbGVtIiwiZW1wdHlPYmplY3QiLCJvcmlnaW5hbEFyZ3MiLCJjaGlsZHJlbkJsb2NrcyIsImNoaWxkcmVuTWl4aW5zIiwiZnVuYyIsIm9uQ2hhbmdlIiwidGFyZ2V0QmxvY2siLCJmb3JFbGVtZW50cyIsImZvckl0ZW0iLCJvbkNoYW5nZUZsYWciLCJyZXN1bHQiLCJvcmlnaW5hbCIsIm9uRXZhbEVycm9yIiwiZSIsImxvY2FsV2F0Y2hlcnMiLCJ3YXRjaGVyQmxvY2siLCJuZXdSZXN1bHQiLCJfYmVmb3JlUmVtb3ZlIiwicmVtb3ZlQ29udGVudCIsIm5ld0NvbnRlbnQiLCJfYWZ0ZXJET01DaGFuZ2UiLCJjb250ZW50VG9BZGQiLCJub3RSZWN1cnNpdmUiLCJvbGRDb250ZW50IiwiY2hhbmdlQ29udGVudCIsImNvbnRlbnRUb01vdmUiLCJhZnRlciIsImluZGV4VG9QdXQiLCJtb3ZlQ29udGVudCIsImNvbnRlbnRUb1JlbW92ZSIsImNvbnRlbnRUb0luc2VydCIsIm1vdmVGbGFnIiwidHJ5VG9BZGRPck1vdmUiLCJkZWZhdWx0TG9jYWxzIiwiZGVmYXVsdEFyZ3MiLCJsb2NhbEFyZ3MiLCJyZXN0QXJncyIsImFmdGVyQ29uc3RydWN0IiwiYWZ0ZXJET01DaGFuZ2UiLCJhZnRlclJlbmRlciIsIkNhc2UiLCJ3YXRjaEFyZ3MiLCJfdGhpczIiLCJDaGlsZHJlbiIsImh0bWxDaGlsZHJlbiIsImZvdW5kIiwiY29uc3RydWN0IiwiRWFjaCIsIml0ZW1zQnlVSURzIiwicmVuZGVyU2V0Iiwic2V0IiwiZmlsdGVyQnkiLCJzb3J0QnkiLCJVSUQiLCJ1aWQiLCJuZXdJdGVtc0J5VUlEcyIsIm5ld1VJRHNCeUluZGV4ZXMiLCJuZXdVSURzIiwiaXNBcnIiLCJpdGVyYXRlIiwic29ydCIsInByZXZVSURCbG9jayIsIklmIiwiY29uc3RydWN0RWxlbXMiLCJTd2l0Y2giLCJJbmZpbml0eSIsInN3aXRjaEFyZ3MiLCJ3YXNEZWZhdWx0IiwibWFwIiwidmFsIiwid2hlbiIsImNvbXBhcmVGbiIsInNvbWUiLCJzd2l0Y2hWYWx1ZSIsImNhc2VWYWx1ZSIsIkJpbmQiLCJvZmYiLCJqb2luIiwibmV3Q2xhc3NlcyIsIkhpZGUiLCJOb2RlIiwiT24iLCJTaG93IiwiU3R5bGUiLCJCb29sZWFuIiwiVmFsdWUiLCJpbml0aWFsU2NvcGVWYWx1ZSIsInNldFByb3AiLCJpbml0aWFsRWxlbVZhbHVlIiwiaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwiLCJpc0NoZWNrYm94IiwiY2hhbmdlU2NvcGUiLCJvZmZFbGVtTGlzdGVuZXIiLCJvZmZGb3JtTGlzdGVuZXIiLCJvcHRpb24iLCJib2R5Il0sIm1hcHBpbmdzIjoieUJBQU8sU0FBU0EsR0FBaUJDLEVBQU9DLE1BQVVDLHNFQUNuQ0YsRUFBTyxTQUFDRyxFQUFPQyxLQUNqQkYsRUFBY0MsRUFBT0MsRUFBT0osS0FHaENFLEVBR1QsUUFBZ0JHLEdBQVlMLEVBQU9DLE9BQzVCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsSUFBSyxJQUNoREgsR0FBUUgsRUFBTU0sTUFFaEJMLEVBQVNFLEVBQU9HLEVBQUdOLGNBRWRNLFlBT2IsUUFBZ0JFLEdBQWFSLEVBQU9DLE9BQzdCLEdBQUlLLEdBQUksRUFB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"}