{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/toStringTag.js","../src/utils/is.js","../src/utils/escapeRegex.js","../src/utils/toCase.js","../src/Elem.js","../src/blocks/d-block.js","../src/blocks/d-each.js","../src/blocks/d-elements.js","../src/blocks/d-if.js","../src/blocks/d-item.js","../src/blocks/d-switch.js","../src/mixins/d-attr.js","../src/mixins/d-bind.js","../src/mixins/d-class.js","../src/mixins/d-elem.js","../src/mixins/d-hide.js","../src/mixins/d-node.js","../src/mixins/d-on.js","../src/mixins/d-show.js","../src/mixins/d-style.js","../src/mixins/d-value.js","../src/Block.js","../src/global.js","../src/utils/objectStatics.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","import { iterateArray } from './array';\n\nconst {\n  hasOwnProperty: has\n} = {};\n\n/**\n * @const\n * @function assign\n * @param {Object} target - Object to assign rest of arguments to.\n * @param {...Object} objects - Objects that are assigned to the target.\n * @returns {Object} Target.\n */\nexport function assign(target, ...objects) {\n  iterateArray(arguments, (source, index) => {\n    if (index) {\n      iterateObject(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\n/**\n * @function defineProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining properties of an object.\n */\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineFrozenProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining frozen properties of an object.\n */\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","import { definePrototypeProperties } from './defineProperty';\n\nconst { Symbol } = global;\nconst { toString } = {};\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(object, tag) {\n  if (Symbol && Symbol.toStringTag) {\n    definePrototypeProperties(object.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","/**\n * @module helpers/checkTypes\n * @private\n * @mixin\n * @description Exports is<Type> methods.\n */\n\nimport { toStringTag } from './toStringTag';\n\n/**\n * @function isArray\n * @public\n * @param {*} value - Value to check if it is an array.\n * @returns {Boolean} If the argument is an array or not.\n * \n * @example\n * isArray([]);                             // true\n * isArray(0);                              // true\n * isArray(document.querySelectorAll('*')); // false\n */\nexport const { isArray } = Array;\n\n/**\n * @function isFunction\n * @public\n * @param {*} value - Value to check if it is a function.\n * @returns {Boolean} If the argument is a function or not.\n * \n * @example\n * isFunction(() => {});            // true\n * \n * const func = () => {};\n * Object.setPrototypeOf(func, {});\n * isFunction(func);                // true\n */\nexport function isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\n * @function isNil\n * @public\n * @param {*} value - Value to check if it is null or undefined.\n * @returns {Boolean} If the argument is null or undefined or not.\n *\n * @example\n * isNil(null);      // true\n * isNil(undefined); // true\n * isNil(false);     // false\n */\nexport function isNil(value) {\n  /* eslint eqeqeq: 0 */\n  return value == null;\n}\n\n/**\n * @function isString\n * @public\n * @param {*} value - Value to check if it is a string.\n * @returns {Boolean} If the argument is a string or not.\n *\n * @example\n * isString('0');             // true\n * isString(new String('0')); // true\n */\nexport function isString(value) {\n  return toStringTag(value) === 'String';\n}\n","const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\nconst regexpSpecialsRegexp = new RegExp(\n  regexpSpecialCharacters\n    .map((s) => `\\\\${ s }`)\n    .join('|'),\n  'g'\n);\n\nexport function escapeRegex(string) {\n  return string.replace(regexpSpecialsRegexp, '\\\\$&');\n}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","import {\n  isArray, isNil, isString,\n  assign, definePrototypeProperties,\n  defineProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toCamelCase, toHyphenCase, toStringTag,\n  setToStringTag, setProto\n} from './utils';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\nconst {\n  document = {},\n  Symbol\n} = global;\nconst HIDE_CLASS = '__dwayne-hidden__';\nconst EVENT_SEPARATOR_REGEX = /(?:,| ) */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst EVENT_REGEX = /Event$/;\nconst ELEMENT_REGEX = /Element$/;\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\nconst X_LINK_ATTR_REGEX = /^xlink:\\w/;\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst XHTML_NS = 'http://www.w3.org/1999/xhtml';\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends [].constructor {\n  static addMethods(property, value) {\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    definePrototypeProperties(this.prototype, property);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add() {\n    const elems = this.slice();\n\n    iterateArray(arguments, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromObject(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const ns = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, attr)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const ns = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isHTMLDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        const ns = type === 'svg'\n          ? SVG_NS\n          : elem.namespaceURI || document.documentElement.namespaceURI || XHTML_NS;\n\n        el = document.createElementNS(ns, type);\n      }\n\n      add(new Elem(el).into(elem));\n    });\n  }\n\n  /**\n   * @method Elem#createComment\n   * @public\n   * @param {String} text - Text of the comment.\n   * @returns {Elem} New instance of Elem - wrap of the created comments.\n   * @description Method for creating comments inside this element.\n   * If this element is not an Element the comment is just created.\n   *\n   * @example\n   * elem.createComment('comment');\n   */\n  createComment(text) {\n    return this\n      .create('#comment')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#createText\n   * @public\n   * @param {String} text - Text.\n   * @returns {Elem} New instance of Elem - wrap of the created text nodes.\n   * @description Method for creating text nodes inside this element.\n   * If this element is not an Element the text node is just created.\n   *\n   * @example\n   * elem.createText('text');\n   */\n  createText(text) {\n    return this\n      .create('#text')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details || {};\n    let finalEvent = event;\n\n    if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n      try {\n        finalEvent = new Event(finalEvent, { bubbles, cancelable });\n        assign(finalEvent, realDetails);\n      } catch (err) {}\n    }\n\n    return this.forEach((elem) => {\n      if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n        const document = isHTMLDocument(elem)\n          ? elem\n          : elem.ownerDocument;\n\n        finalEvent = document.createEvent('Event');\n        finalEvent.initEvent(event, bubbles, cancelable);\n\n        assign(finalEvent, realDetails);\n      }\n\n      elem.dispatchEvent(finalEvent);\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback} [filterFn = Boolean] - Filter function\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filterFn = Boolean) {\n    return this.collect((add, elem, index) => {\n      if (filterFn(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const ns = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (\n      !element\n      || isHTMLDocument(element)\n    ) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = (\n      elem.matches\n      || elem.matchesSelector\n      || elem.webkitMatchesSelector\n      || elem.mozMatchesSelector\n      || elem.msMatchesSelector\n      || elem.oMatchesSelector\n    );\n\n    try {\n      return matches.call(elem, selector);\n    } catch (err) {\n      console.error(`Selector '${ selector }' is not a valid selector (Elem#is)`);\n\n      return false;\n    }\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * const elem1 = elem.create('div');\n   * elem1.name() // 'div'\n   */\n  name() {\n    return getName(this[0]);\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   'input, select, textarea, datalist, keygen, output',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   {\n   *     'change, input': (e, elem, index) => console.log(elem.value),\n   *     'blur': () => console.log('blur')\n   *   },\n   *   'input, select, textarea, datalist, keygen, output'\n   * );\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (attr) => {\n        const ns = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      classList.toggle(cls, arguments.length < 2 ? !classList.contains(cls) : condition);\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\n\nif (Symbol && Symbol.species) {\n  defineProperties(Elem, {\n    [Symbol.species]: {\n      get() {\n        return Array;\n      }\n    }\n  });\n}\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nconst doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nconst html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nconst body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nconst head = new Elem(document.head);\n\n/**\n * @function toElem\n * @private\n * @param {Element|Elem} elem - Element or Elem.\n * @returns {Elem} Instance of Elem.\n */\nfunction toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n\n/**\n * @function isElem\n * @private\n * @param {*} value - Value to check if it's Elem.\n * @returns {Boolean} If the value is Elem.\n * @description Returns if the value is Elem or not.\n */\nfunction isElem(value) {\n  return value instanceof Elem;\n}\n\n/**\n * @function isHTMLDocument\n * @private\n * @param {*} value - Value to check if it's HTMLDocument.\n * @returns {Boolean} If the value is HTMLDocument.\n * @description Returns if the value is HTMLDocument or not.\n */\nfunction isHTMLDocument(value) {\n  return toStringTag(value) === 'HTMLDocument';\n}\n\n/**\n * @function isElementsCollection\n * @private\n * @param {*} value - Value to check if it's Comment or Text.\n * @returns {Boolean} If the value is HTMLDocument.\n * @description Returns if the value is Comment or Text or not.\n */\nfunction isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n\nfunction isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || tag === 'HTMLDocument'\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n\n/**\n * @function getName\n * @private\n * @param {Element} [elem] - Element which name is needed to know.\n * @returns {String} Element name.\n */\nfunction getName(elem) {\n  return (elem && elem.nodeName && elem.nodeName.toLowerCase()) || '';\n}\n\nfunction getAttrNS(attr, elem) {\n  if (attr === 'xmlns' || attr === 'xmlns:xlink') {\n    return elem.nodeName === 'SVG'\n      ? XML_NS\n      : null;\n  }\n\n  if (X_LINK_ATTR_REGEX.test(attr)) {\n    return new Elem(elem).closest('svg').length\n      ? X_LINK_NS\n      : null;\n  }\n}\n\nfunction createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n\nfunction addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n\nfunction addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n\nfunction addDataAttr(data, value, key) {\n  data[key] = value;\n}\n\nfunction hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n\nfunction addNext(add, elem) {\n  add(elem.nextSibling);\n}\n\nfunction addParent(add, elem) {\n  add(elem.parentNode);\n}\n\nfunction addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n\nfunction remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n\nfunction show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nfunction find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n\ncreateHideStyleNode(head);\n\nexport { Elem, doc, html, body, head, find };\n","import { findInArray } from '../utils';\n\nexport function registerDBlock(Block) {\n  class DBlock extends Block {\n    static template = html`\n      <d-elements\n        value=\"{elems}\"\n        parentScope=\"{ParentScope}\"\n        parentTemplate=\"{ParentTemplate}\"\n      />\n    `;\n\n    afterConstruct() {\n      const {\n        parentScope: {\n          $$: {\n            parentScope: parentParentScope,\n            parentTemplate: parentParentTemplate,\n            argsChildren: children\n          }\n        },\n        argsChildren: ownChildren,\n        parentTemplate,\n        dBlockName\n      } = this.$$;\n      let found;\n\n      if (ownChildren.length) {\n        return;\n      }\n\n      this.ParentScope = parentParentScope;\n      this.ParentTemplate = parentParentTemplate;\n\n      if (dBlockName) {\n        found = findInArray(children, ({ name: nodeName }) => nodeName === `d-block:${ dBlockName }`);\n\n        if (!found) {\n          let parent = this;\n\n          /* eslint no-empty: 0 */\n          while (\n            (parent = parent.$$.parentScope)\n            && !(found = findInArray(parent.$$.dBlocks, ({ $$: { dBlockName: DBlockName } }) => DBlockName === dBlockName))\n            && parent.$$.parentScope.$$.name === '#d-item'\n          ) {}\n\n          if (found) {\n            this.ParentScope = parent;\n            this.ParentTemplate = parentTemplate;\n            found.value = {\n              children: found.value.$$.argsChildren\n            };\n          }\n        }\n\n        this.elems = found && found.value.children.length\n          ? found.value.children\n          : null;\n      } else {\n        this.elems = children;\n      }\n    }\n  }\n\n  return {\n    name: 'd-block',\n    value: DBlock\n  };\n}\n","import {\n  assign, iterateArray, iterateObject,\n  isArray, isFunction\n} from '../utils';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nexport function registerDEach(Block, createBlock) {\n  class DEach extends Block {\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args: {\n          item: itemName = '$item',\n          index: indexName = '$index'\n        }\n      } = this;\n\n      assign(this.$$, {\n        itemsByUIDs: {},\n        UID: this.args.uid || undefined,\n        itemName,\n        indexName\n      });\n    }\n\n    afterRender() {\n      this.evaluateAndWatch(watchArgs, this.renderSet);\n      this.renderSet();\n    }\n\n    renderSet = () => {\n      const {\n        argsChildren,\n        itemsByUIDs,\n        parentScope,\n        parentElem,\n        parentTemplate,\n        scope,\n        itemName,\n        indexName,\n        UID\n      } = this.$$;\n      const {\n        args: { sortBy }\n      } = this;\n      const newItemsByUIDs = {};\n      const newUIDsCounter = {};\n      const newUIDs = {};\n      let {\n        set,\n        filterBy\n      } = this.args;\n      const isArr = isArray(set);\n      const iterate = isArr\n        ? iterateArray\n        : iterateObject;\n\n      if (isArr && isFunction(sortBy)) {\n        set = set\n          .slice()\n          .sort(sortBy);\n      }\n\n      if (isFunction(filterBy)) {\n        filterBy = [filterBy];\n      }\n\n      if (isArray(filterBy)) {\n        iterateArray(filterBy, (filter) => {\n          set = set.filter(filter);\n        });\n      }\n\n      iterate(set, (item, index) => {\n        scope[itemName] = item;\n        scope[indexName] = index;\n\n        const uid = parentScope.$$.evaluate(UID, null, null, false, false, this);\n\n        newUIDsCounter[uid] = (newUIDsCounter[uid] || 0) + 1;\n        newUIDs[index] = uid;\n      });\n\n      scope[itemName] = null;\n      scope[indexName] = null;\n\n      iterateObject(itemsByUIDs, (items, uid) => {\n        if (!newUIDsCounter[uid]) {\n          iterateArray(items, remove);\n\n          return;\n        }\n\n        iterateArray(items.splice(newUIDsCounter[uid]), remove);\n      });\n\n      let prevBlock;\n\n      iterate(set, (item, index) => {\n        const uid = newUIDs[index];\n        let block;\n\n        if (itemsByUIDs[uid] && itemsByUIDs[uid].length) {\n          block = itemsByUIDs[uid].shift();\n          block.$$.scope[indexName] = index;\n          block.$$.scope[itemName] = item;\n\n          if (block.$$.prevBlock !== prevBlock && prevBlock) {\n            prevBlock.$$.insertAfterIt(block.$$.content, true);\n          }\n        } else {\n          block = createBlock({\n            node: {\n              itemName,\n              indexName,\n              item,\n              index,\n              name: '#d-item',\n              children: argsChildren\n            },\n            parent: this,\n            parentElem,\n            parentBlock: this,\n            parentScope,\n            parentTemplate,\n            prevBlock\n          });\n        }\n\n        (newItemsByUIDs[uid] = newItemsByUIDs[uid] || []).push(block);\n        block.$$.prevBlock = prevBlock;\n        prevBlock = block;\n      });\n\n      this.$$.itemsByUIDs = newItemsByUIDs;\n    };\n  }\n\n  return {\n    name: 'd-each',\n    value: DEach\n  };\n}\n\nfunction remove(item) {\n  item.$$.remove();\n}\n","import { Elem } from '../Elem';\nimport { iterateArray, removeArrayElem } from '../utils';\n\nconst watchArgs = js`args.value`;\n\nexport function registerDElements(Block, createBlock) {\n  class DElements extends Block {\n    afterConstruct() {\n      const { parentElem } = this.$$;\n      const {\n        parentScope,\n        parentTemplate\n      } = this.args;\n\n      this.$$.evaluate(watchArgs, () => {\n        const {\n          children,\n          mixins,\n          parent,\n          watchersToRemove,\n          content\n        } = this.$$;\n        const { value } = this.args;\n\n        iterateArray(children, removeWithParentSignal);\n        iterateArray(mixins, removeWithParentSignal);\n        content.remove();\n\n        if (parent instanceof Block) {\n          parent.$$.removeContent(content);\n        }\n\n        this.$$.children = [];\n        this.$$.mixins = [];\n        this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n          if (forDElements) {\n            return true;\n          }\n\n          removeArrayElem(watchers, watcher);\n        });\n        this.$$.content = new Elem();\n\n        let prevBlock;\n\n        iterateArray(value || [], (child) => {\n          prevBlock = createBlock({\n            node: child,\n            parent: this,\n            parentElem,\n            parentBlock: this,\n            parentScope,\n            parentTemplate,\n            prevBlock\n          });\n        });\n      }, this, true);\n    }\n  }\n\n  return {\n    name: 'd-elements',\n    value: DElements\n  };\n}\n\nfunction removeWithParentSignal(item) {\n  item.$$.remove(true);\n}\n","import { findInArray } from '../utils';\n\nexport function registerDIf(Block) {\n  class DIf extends Block {\n    static template = html`\n      <d-elements\n        value=\"{elems}\"\n        parentScope=\"{$$.parentScope}\"\n        parentTemplate=\"{$$.parentTemplate}\"\n      />\n    `;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        parentScope,\n        argsChildren\n      } = this.$$;\n      let index = Infinity;\n      const values = argsChildren.map((child, i) => {\n        const {\n          name,\n          attrs = {},\n          children\n        } = child;\n        let cond = attrs.if;\n\n        if (name !== 'd-else' && cond) {\n          cond = parentScope.$$.evaluate(cond, (newValue) => {\n            if (!!newValue === values[i]) {\n              return;\n            }\n\n            values[i] = !!newValue;\n\n            if (i > index) {\n              return;\n            }\n\n            if (i < index) {\n              index = i;\n              this.elems = children;\n\n              return;\n            }\n\n            const found = findInArray(values, Boolean);\n\n            if (found) {\n              index = found.key;\n              this.elems = argsChildren[found.key].children;\n            } else {\n              index = Infinity;\n              this.elems = null;\n            }\n          }, this);\n        } else {\n          cond = true;\n        }\n\n        if (cond && index === Infinity) {\n          index = i;\n          this.elems = children;\n        }\n\n        return !!cond;\n      });\n    }\n  }\n\n  return {\n    name: 'd-if',\n    value: DIf\n  };\n}\n","export function registerDItem(Block) {\n  class DItem extends Block {\n    static template = html`\n      <d-elements\n        value=\"{$$.argsChildren}\"\n        parentScope=\"{this}\"\n        parentTemplate=\"{$$.parentTemplate}\"\n      />\n    `;\n  }\n\n  return {\n    name: '#d-item',\n    value: DItem\n  };\n}\n","import { collectFromArray, findInArray, iterateArray } from '../utils';\n\nconst watchArgs = js`args.value`;\n\nexport function registerDSwitch(Block) {\n  class DSwitch extends Block {\n    static template = html`\n      <d-elements\n        value=\"{elems}\"\n        parentScope=\"{$$.parentScope}\"\n        parentTemplate=\"{$$.parentTemplate}\"\n      />\n    `;\n\n    index = Infinity;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        $$: {\n          argsChildren,\n          parentScope\n        },\n        args,\n        args: { value }\n      } = this;\n      let wasDefault;\n\n      this.values = collectFromArray(argsChildren, (values, child, i) => {\n        const {\n          name,\n          attrs,\n          children\n        } = child;\n        let val = attrs.if;\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (name !== 'd-case' && name !== 'd-default') {\n          return;\n        }\n\n        if (name === 'd-default') {\n          wasDefault = true;\n        }\n\n        if (name === 'd-default') {\n          val = value;\n        } else if (val) {\n          val = parentScope.$$.evaluate(val, (newValue) => {\n            if (this.equals(this.values[i].value, newValue)) {\n              return;\n            }\n\n            this.values[i].value = newValue;\n\n            if (i > this.index) {\n              return;\n            }\n\n            if (i < this.index) {\n              this.index = i;\n              this.elems = children;\n\n              return;\n            }\n\n            const found = findInArray(this.values, ({ value }) => (\n              this.equals(value, args.value)\n            ));\n\n            if (found) {\n              this.index = found.key;\n              this.elems = found.value.children;\n            } else {\n              this.index = Infinity;\n              this.elems = null;\n            }\n          }, this);\n        } else {\n          val = undefined;\n        }\n\n        if (this.equals(val, value) && this.index === Infinity) {\n          this.index = i;\n          this.elems = children;\n        }\n\n        values.push({\n          name,\n          children,\n          value: val\n        });\n      }, []);\n    }\n\n    afterConstruct() {\n      this.evaluateAndWatch(watchArgs, () => {\n        const {\n          value: newValue\n        } = this.args;\n\n        this.index = Infinity;\n\n        iterateArray(this.values, ({ name, value, children }, i) => {\n          const val = name === 'd-default'\n            ? newValue\n            : value;\n\n          if (this.equals(val, newValue) && this.index === Infinity) {\n            this.index = i;\n            this.elems = children;\n          }\n        });\n\n        if (this.index === Infinity) {\n          this.elems = null;\n        }\n      });\n    }\n\n    equals(value1, value2) {\n      return value1 === value2;\n    }\n  }\n\n  return {\n    name: 'd-switch',\n    value: DSwitch\n  };\n}\n","import { collectFromObject, iterateObject, keys } from '../utils';\n\nexport function registerDAttr(Mixin) {\n  class DAttr extends Mixin {\n    attrs = {};\n\n    afterUpdate(newValue) {\n      const {\n        elem,\n        args,\n        attrs\n      } = this;\n\n      if (args) {\n        newValue = collectFromObject(args, (attrs, attr) => {\n          attrs[attr] = newValue;\n        });\n      }\n\n      iterateObject(attrs, (value, prop) => {\n        if (!(prop in newValue)) {\n          elem.removeAttr(prop);\n        }\n      });\n      elem.attr(newValue);\n\n      this.attrs = newValue;\n    }\n\n    beforeRemove() {\n      const {\n        elem,\n        attrs\n      } = this;\n\n      elem.removeAttr.apply(elem, keys(attrs));\n    }\n  }\n\n  return {\n    name: 'd-attr',\n    value: DAttr\n  };\n}\n\n","import { isFunction } from '../utils';\n\nexport function registerDBind(Mixin) {\n  class DBind extends Mixin {\n    afterUpdate(value) {\n      if (this.off) {\n        this.off();\n      }\n\n      if (!isFunction(value)) {\n        return;\n      }\n\n      if (this.args) {\n        this.off = this.elem.on(this.args.join(','), value);\n      } else {\n        console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n      }\n    }\n\n    beforeRemove() {\n      const { off } = this;\n\n      if (off) {\n        off();\n      }\n    }\n  }\n\n  return {\n    name: 'd-bind',\n    value: DBind\n  };\n}\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nexport function registerDClass(Mixin) {\n  class DClass extends Mixin {\n    classes = [];\n\n    afterUpdate(newValue) {\n      const {\n        elem,\n        args,\n        classes\n      } = this;\n      const newClasses = [];\n\n      if (args) {\n        newValue = newValue\n          ? args\n          : [];\n      }\n\n      if (isString(newValue)) {\n        newValue = newValue.split(EMPTY_SPACE_REGEX);\n      }\n\n      if (isArray(newValue)) {\n        iterateArray(classes, (cls) => {\n          if (newValue.indexOf(cls) === -1) {\n            elem.removeClass(cls);\n          }\n        });\n        iterateArray(newValue, (cls) => {\n          if (isString(cls)) {\n            newClasses.push(cls);\n            elem.addClass(cls);\n          }\n        });\n      } else {\n        iterateArray(classes, (cls) => {\n          if (!newValue || !newValue[cls]) {\n            elem.removeClass(cls);\n          }\n        });\n        iterateObject(newValue, (val, cls) => {\n          if (val) {\n            newClasses.push(cls);\n            elem.addClass(cls);\n          }\n        });\n      }\n\n      this.classes = newClasses;\n    }\n\n    beforeRemove() {\n      const {\n        elem,\n        classes\n      } = this;\n\n      elem.removeClass.apply(elem, classes);\n    }\n  }\n\n  return {\n    name: 'd-class',\n    value: DClass\n  };\n}\n","import { isFunction, isString } from '../utils';\n\nexport function registerDElem(Mixin, createBlock, Block) {\n  class DElem extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args,\n        parentTemplate,\n        elem\n      } = this;\n      let scope = parentTemplate;\n      let value = this.evaluateOnce();\n\n      if (args) {\n        scope = value instanceof Block\n          ? value\n          : parentTemplate;\n        value = args[0];\n      }\n\n      if (isFunction(value)) {\n        value(elem);\n      } else if (isString(value)) {\n        scope[value] = elem;\n      }\n    }\n  }\n\n  return {\n    name: 'd-elem',\n    value: DElem\n  };\n}\n","export function registerDHide(Mixin) {\n  class DHide extends Mixin {\n    afterUpdate(value) {\n      const { elem } = this;\n\n      if (value) {\n        elem.hide();\n      } else {\n        elem.show();\n      }\n    }\n\n    beforeRemove() {\n      this.elem.show();\n    }\n  }\n\n  return {\n    name: 'd-hide',\n    value: DHide\n  };\n}\n","import { isFunction, isString } from '../utils';\n\nexport function registerDNode(Mixin, createBlock, Block) {\n  class DNode extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args,\n        parentTemplate,\n        node\n      } = this;\n      let scope = parentTemplate;\n      let value = this.evaluateOnce();\n\n      if (args) {\n        scope = value instanceof Block\n          ? value\n          : parentTemplate;\n        value = args[0];\n      }\n\n      if (isFunction(value)) {\n        value(node);\n      } else if (isString(value)) {\n        scope[value] = node;\n      }\n    }\n  }\n\n  return {\n    name: 'd-node',\n    value: DNode\n  };\n}\n","export function registerDOn(Mixin) {\n  class DOn extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      if (this.args) {\n        this.off = this.elem.on(this.args.join(','), () => {\n          this.evaluateOnce();\n        });\n      } else {\n        console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n      }\n    }\n\n    beforeRemove() {\n      const { off } = this;\n\n      if (off) {\n        off();\n      }\n    }\n  }\n\n  return {\n    name: 'd-on',\n    value: DOn\n  };\n}\n","export function registerDShow(Mixin) {\n  class DShow extends Mixin {\n    afterUpdate(value) {\n      const { elem } = this;\n\n      if (value) {\n        elem.show();\n      } else {\n        elem.hide();\n      }\n    }\n\n    beforeRemove() {\n      this.elem.show();\n    }\n  }\n\n  return {\n    name: 'd-show',\n    value: DShow\n  };\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\n\nexport function registerDStyle(Mixin) {\n  class DStyle extends Mixin {\n    css = {};\n\n    afterUpdate(newValue, oldValue) {\n      const {\n        elem,\n        args,\n        css\n      } = this;\n\n      if (args) {\n        newValue = collectFromObject(args, (css, prop) => {\n          css[prop] = newValue;\n        });\n      }\n\n      if (isString(newValue)) {\n        newValue = collectFromArray(\n          newValue\n            .split(CSS_STYLES_SEPARATOR_REGEX)\n            .filter(Boolean),\n          addCSSProp\n        );\n      }\n\n      iterateObject(css, (value, prop) => {\n        if (!newValue[prop]) {\n          elem.removeCSS(prop);\n        }\n      });\n      elem.css(newValue);\n\n      this.css = newValue;\n    }\n\n    beforeRemove() {\n      const {\n        elem,\n        css\n      } = this;\n\n      elem.removeCSS.apply(elem, keys(css));\n    }\n  }\n\n  return {\n    name: 'd-style',\n    value: DStyle\n  };\n}\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n","import {\n  isArray, isFunction, isNil,\n  collectFromArray\n} from '../utils';\n\nexport function registerDValue(Mixin, createBlock, Block) {\n  class DValue extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args,\n        parentTemplate,\n        elem,\n        node\n      } = this;\n      const name = elem.name();\n      const type = elem.prop('type');\n      const value = this.evaluateOnce();\n      let initialScopeValue = null;\n\n      this.prop = getProp(name, type, elem);\n      this.name = name;\n      this.type = type;\n      this.value = value;\n      this.options = elem.find('option');\n      this.scope = parentTemplate;\n\n      if (args) {\n        this.name = args[0];\n        this.scope = value instanceof Block\n          ? value\n          : parentTemplate;\n      }\n\n      if (!isFunction(value)) {\n        initialScopeValue = this.scope.$$.evaluate(getEvalFunction(value), (newValue) => {\n          if (this.currentValue !== newValue) {\n            this.currentValue = newValue;\n            this.setProp(newValue);\n          }\n        }, this);\n      }\n\n      const initialElemValue = this.getProp(initialScopeValue, true);\n      const isInitialScopeValueNull = isNil(initialScopeValue);\n      const isCheckbox = type === 'checkbox';\n      const changeScope = () => {\n        this.currentValue = this.getProp(this.currentValue);\n        this.changeScope();\n      };\n\n      if (isInitialScopeValueNull || isCheckbox) {\n        this.currentValue = initialElemValue;\n        this.changeScope();\n\n        if (!isInitialScopeValueNull && isCheckbox) {\n          this.setProp(initialScopeValue);\n        }\n      } else {\n        this.currentValue = initialScopeValue;\n        this.setProp(initialScopeValue);\n      }\n\n      this.offElemListener = elem.on(getListenerName(name, type), (e) => {\n        if (e.target === node) {\n          changeScope();\n        }\n      });\n      this.offFormListener = elem.closest('form').on('reset', () => {\n        setTimeout(changeScope, 0);\n      });\n    }\n\n    changeScope() {\n      const {\n        scope,\n        value,\n        currentValue\n      } = this;\n\n      if (isFunction(value)) {\n        value(currentValue);\n      } else {\n        scope[value] = currentValue;\n      }\n    }\n\n    setProp(value) {\n      const {\n        elem,\n        name,\n        prop,\n        type,\n        node,\n        options\n      } = this;\n\n      if (prop === 'text') {\n        elem.text(value);\n      } else if (prop === 'multiple-select') {\n        options.forEach((option) => {\n          option.selected = value.indexOf(option.value) !== -1;\n        });\n      } else {\n        elem.prop(prop, getValueForSetting(name, value, type, node.value));\n      }\n    }\n\n    getProp(values, init) {\n      const {\n        elem,\n        name,\n        prop,\n        type,\n        node,\n        options\n      } = this;\n\n      return prop === 'text'\n        ? elem.text()\n        : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n    }\n\n    beforeRemove() {\n      this.offElemListener();\n      this.offFormListener();\n    }\n  }\n\n  return {\n    name: 'd-value',\n    value: DValue\n  };\n}\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        if (values) {\n          return values.indexOf(inputValue) === -1\n            ? values.concat(inputValue)\n            : values;\n        }\n\n        return [inputValue];\n      }\n\n      if (!isArray(values)) {\n        return [];\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction getEvalFunction(value) {\n  return (scope) => scope[value];\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n","/**\n * @module Block\n * @private\n * @mixin\n * @description Exports Block class.\n */\n\nimport { Elem } from './Elem';\nimport {\n  defineFrozenProperties, defineProperties,\n  assign, escapeRegex, mapObject,\n  toObjectKeys, collectFromObject,\n  iterateArray, iterateObject,\n  isFunction, isNil, isArray,\n  setToStringTag, hasOwnProperty,\n  removeArrayElem, create,\n  getProto, setProto, keys\n} from './utils';\nimport * as Blocks from './blocks';\nimport * as Mixins from './mixins';\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {String} expression - Expression which has been evaluated with the error.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback VarsWatcher\n * @public\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {Block} Block class to wrap.\n * @returns {Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {*} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {Block} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\nconst rootBlocks = create(null);\nconst rootMixins = create(null);\nconst blockHooks = [];\nconst mixinHooks = [];\nconst { isPrototypeOf } = {};\nconst TAG_NAME_REGEX = /^[a-z][a-z\\d\\-_.:!@#$%^&*()[\\]{}='\"\\\\]*$/i;\nconst ATTR_NAME_REGEX = /^[\\u0000-\\u0020\\s'\">/=]+$/;\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst D_REST_REGEX = /^d-rest(?:#|$)/;\nconst WATCHED_ARG_PREFIX_REGEX = /^args\\./;\nconst WATCHED_GLOBAL_PREFIX_REGEX = /^globals\\./;\nconst NAMED_D_BLOCK_REGEX = /^d-block:([\\s\\S]+)$/;\nconst COMMA_REGEX = /,/;\nconst afterElem = new Elem();\nconst emptyChildren = [];\nconst emptyAttrs = {};\nlet evalMode;\nlet getting = [];\nlet changed;\n\n/**\n * @class Block\n * @public\n * @param {Object} opts - Element options.\n * @returns {Block} Instance of Block.\n * @description Class for dynamic templating.\n *\n * @example\n * import { D, Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/>';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world (0)';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     D(1000).interval(() => {\n *       this.text = `world (${ ++this.times })`;\n *     });\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', 'Hello, {args.text}!');\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  static _blocks = create(rootBlocks);\n  static _mixins = create(rootMixins);\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {Object} [Block.template = { vars: [], value: [] }]\n   * @type {Object}\n   * @public\n   * @description Block template.\n   */\n  static template = {\n    vars: [],\n    value: []\n  };\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.expression }\" in context of block \"${ err.block.$$.name }\"):`, err);\n  }\n\n  /**\n   * @method Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   */\n  static beforeRegisterBlock(hook) {\n    blockHooks.push(hook);\n\n    return () => {\n      removeArrayElem(blockHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   */\n  static beforeRegisterMixin(hook) {\n    mixinHooks.push(hook);\n\n    return () => {\n      removeArrayElem(mixinHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Template|typeof Block} Subclass - Subclass of Block or template string of it.\n   * @returns {typeof Block|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        constructor(opts) {\n          super(opts);\n\n          this::constructor(opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass)) {\n      Subclass = class extends Block {\n        static template = {\n          vars: [],\n          value: Subclass\n        };\n      };\n    }\n\n    if (!isFunction(Subclass) && Subclass.vars && Subclass.value) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (!isFunction(Subclass)) {\n      console.warn(`Block must be a string (representing a block template), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      extendBlock(Subclass);\n    }\n\n    if (rootBlocks[name]) {\n      console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!TAG_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_blocks')) {\n      this._blocks = create(getProto(this)._blocks);\n    }\n\n    if (!hasOwnProperty(this, 'defaultLocals')) {\n      this.defaultLocals = {};\n    }\n\n    if (!hasOwnProperty(this, 'defaultArgs')) {\n      this.defaultArgs = create(null);\n    }\n\n    try {\n      Subclass = blockHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Block, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterBlock\" hook:', err);\n    }\n\n    const {\n      vars,\n      value\n    } = Subclass.template;\n\n    Subclass._html = value;\n    Subclass._vars = vars;\n\n    if (hasOwnProperty(Subclass, 'defaultArgs')) {\n      setProto(Subclass.defaultArgs, null);\n    }\n\n    this._blocks[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {typeof Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {typeof Mixin|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          this::afterUpdate(newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin and will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (rootMixins[name]) {\n      console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!ATTR_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_mixins')) {\n      this._mixins = create(getProto(this)._mixins);\n    }\n\n    try {\n      Subclass = mixinHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Mixin, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterMixin\" hook:', err);\n    }\n\n    Subclass._match = constructMixinRegExp(name);\n\n    this._mixins[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const constructor = getProto(this).constructor;\n    const childrenBlocks = [];\n    const mixins = [];\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Block} Block#$\n       * @type {Block}\n       * @public\n       * @description This.\n       */\n      $: this,\n\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} args - Private args scope.\n       * @property {Object[]} argsChildren - Block args children.\n       * @property {Block[]} children - Child blocks.\n       * @property {Mixin[]} mixins - Child mixins.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Elem} content - Content elements.\n       * @property {Function} evaluate - Evaluate function.\n       * @property {Object} globals - Private globals scope.\n       * @property {Object} locals - Private locals scope.\n       * @property {Object[]} watchersToRemove - Watchers to remove before removing element.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlocks: [],\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        argsChildren: children,\n        children: childrenBlocks,\n        mixins,\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (func, onChange, targetBlock, forDElements, forDItem, forDEach) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = (name === '#d-item' && !forDItem) || forDEach\n            ? (forDEach || this).$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : {};\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              evalMode = true;\n              getting = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.expression = func.expression;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error('Uncaught error in onEvalError:', e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(getting, (watchers) => {\n                const watcher = () => {\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                watcher.onRemove = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              getting = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n\n          iterateArray(mixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const index = this.$$.content.indexOf(contentToAdd[0].previousSibling) + 1;\n\n          if (index === 0) {\n            this.$$.content = contentToAdd.add(this.$$.content);\n          } else {\n            this.$$.content = this.$$.content\n              .slice(0, index)\n              .add(contentToAdd, this.$$.content.slice(index));\n          }\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const index = this.$$.content.indexOf(contentToMove[0]);\n          const indexToPut = this.$$.content.indexOf(after[0]) + 1;\n\n          if (indexToPut === 0) {\n            this.$$.content = contentToMove.add(\n              this.$$.content.slice(indexToPut, index),\n              this.$$.content.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            this.$$.content = this.$$.content\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                this.$$.content.slice(indexToPut, index),\n                this.$$.content.slice(index + contentToMove.length)\n              );\n          } else {\n            this.$$.content = this.$$.content\n              .slice(0, index)\n              .add(\n                this.$$.content.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                this.$$.content.slice(indexToPut)\n              );\n          }\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.content = this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          ));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor._vars, (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    let args = create(constructor.defaultArgs || null);\n    let wasDRest;\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isDRest = D_REST_REGEX.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? create(args)\n        : args;\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, transformRestArgs(value));\n          calculateArgs(args, argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return assign(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      if (name !== 'd-each' || arg !== 'uid') {\n        value = parentScope.$$.evaluate(value, (value) => {\n          localArgs[arg] = value;\n          calculateArgs(args, argsObject);\n        }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n      }\n\n      localArgs[arg] = value;\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      ),\n\n      /**\n       * @member {Block|undefined} Block#parentScope\n       * @type {Block|undefined}\n       * @public\n       */\n      parentScope,\n\n      /**\n       * @member {Block|undefined} Block#parentTemplate\n       * @type {Block|undefined}\n       * @public\n       */\n      parentTemplate\n    });\n\n    calculateArgs(args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getContent\n   * @public\n   * @returns {Elem}\n   * @description Returns contents of the block.\n   */\n  getContent() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#evaluateAndWatch\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} callback - Callback which is called when the expression value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluateAndWatch(func, callback) {\n    return this.$$.evaluate(func, callback, this);\n  }\n\n  /**\n   * @method Block#watch\n   * @public\n   * @param {...('args'|'globals'|String)} [vars] - Vars to watch (args, globals or locals).\n   * If no specified all locals, args and globals are to be watched.\n   * If the 'args' string all args are to be watched.\n   * If the 'globals' string all globals are to be watched.\n   * @param {VarsWatcher} watcher - Called when watched vars are changed.\n   * @description Method for watching for vars. If no vars passed in arguments\n   * all vars are to be watched. If the 'args' string is in the arguments all args are to be watched.\n   * If the 'globals' string is in the arguments all globals are to be watched.\n   * Otherwise specified vars will be watched.\n   * Watchers should not be put inside the constructor. It is considered best\n   * practice to do it inside the {@link Block#afterConstruct} method.\n   * Note that these expressions (vars, i.e. \"args.arg\") are not to be\n   * evaluated so you cannot put there things like \"a[b]\" or any js code,\n   * only expressions like \"a\", \"b\", \"args.a\", \"args.b\" and \"globals.a\", \"globals.b\".\n   * Also note that if there are more than one var that are changed at once (synchronously)\n   * the watcher is called only once.\n   * Note that the watcher is executed right away because in most cases\n   * this behaviour is very convenient.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div />';\n   *\n   *   afterConstruct() {\n   *     this.watch('a', () => {});\n   *     this.watch('args.a', 'globals.r', () => {});\n   *     this.watch(() => {});\n   *   }\n   * }\n   */\n  watch(...vars) {\n    const oldWatcher = arguments[arguments.length - 1];\n\n    if (!isFunction(oldWatcher)) {\n      console.warn(`The last argument (watcher) wasn't specified (${ this.$$.name }#watch)`);\n\n      return;\n    }\n\n    const watcher = () => {\n      oldWatcher();\n    };\n\n    if (arguments.length === 1) {\n      watchForAllLocals(this, watcher);\n      watchForAllArgs(this, watcher);\n      watchForAllGlobals(this, watcher);\n\n      oldWatcher();\n\n      return;\n    }\n\n    iterateArray(arguments, (variable) => {\n      if (variable === oldWatcher) {\n        return;\n      }\n\n      variable = `${ variable }`;\n\n      if (variable === '$') {\n        return watchForAllLocals(this, watcher);\n      }\n\n      if (variable === 'args') {\n        return watchForAllArgs(this, watcher);\n      }\n\n      if (variable === 'globals') {\n        return watchForAllGlobals(this, watcher);\n      }\n\n      if (WATCHED_ARG_PREFIX_REGEX.test(variable)) {\n        variable = variable.replace(WATCHED_ARG_PREFIX_REGEX, '');\n\n        if (!this.$$.args[variable]) {\n          return;\n        }\n\n        this.$$.args[variable].watchers.perm.push(watcher);\n\n        return;\n      }\n\n      if (WATCHED_GLOBAL_PREFIX_REGEX.test(variable)) {\n        variable = variable.replace(WATCHED_GLOBAL_PREFIX_REGEX, '');\n\n        if (!this.$$.globals[variable]) {\n          return;\n        }\n\n        const { watchers } = this.$$.globals[variable];\n\n        watchers.perm.push(watcher);\n        this.$$.watchersToRemove.push({\n          watcher,\n          watchers\n        });\n\n        return;\n      }\n\n      if (!this.$$.locals[variable]) {\n        return;\n      }\n\n      this.$$.locals[variable].watchers.perm.push(watcher);\n    });\n\n    oldWatcher();\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nregisterBuiltIns(Blocks, rootBlocks, Block);\n\nconst blocks = Block._blocks;\n\nclass Mixin {\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n\n    defineFrozenProperties(this, {\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        }\n      }\n    });\n\n    this.args = args;\n    this.comment = comment;\n    this.parentScope = parentScope;\n    this.parentTemplate = parentTemplate;\n    this.elem = elem;\n    this.node = elem[0];\n\n    if (parentBlock) {\n      parentBlock.$$.mixins.push(this);\n    }\n  }\n\n  afterUpdate() {}\n\n  beforeRemove() {}\n\n  /**\n   * @method Block#evaluateAndWatch\n   * @public\n   * @param {Watcher} callback - Callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluateAndWatch(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  /**\n   * @method Block#evaluateOnce\n   * @public\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value once.\n   */\n  evaluateOnce() {\n    return this.$$.evaluate();\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nregisterBuiltIns(Mixins, rootMixins, Mixin);\n\nconst mixins = Block._mixins;\n\nfunction initApp(html, node) {\n  const parentElem = new Elem(node).elem(0);\n\n  if (!parentElem.length) {\n    throw new Error('No valid element to insert the app into was given! (initApp)');\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    throw new Error('There already exists a Dwayne app inside the given element! (initApp)');\n  }\n\n  if (isArray(html)) {\n    html = {\n      vars: [],\n      value: html\n    };\n  }\n\n  class RootBlock extends Block {\n    static _vars = html.vars;\n    static _html = html.value\n  }\n\n  const block = createBlock({\n    node: {\n      name: '#RootBlock'\n    },\n    Constructor: RootBlock,\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', block)\n    .attr('dwayne-root', '');\n}\n\nfunction removeApp(node) {\n  const elem = new Elem(node);\n\n  if (!elem.length) {\n    throw new Error('No valid element to remove the app from was given! (removeApp)');\n  }\n\n  const { DwayneRootBlock } = elem[0];\n\n  if (!DwayneRootBlock) {\n    throw new Error('No app registered inside the given element! (removeApp)');\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete elem[0].DwayneRootBlock;\n}\n\nfunction registerBuiltIns(set, scope, proto) {\n  iterateObject(set, (register) => {\n    const {\n      name,\n      value\n    } = register(proto, createBlock, Block);\n\n    if (proto === Block) {\n      const {\n        vars,\n        value: html\n      } = value.template;\n\n      value._html = html;\n      value._vars = vars;\n    } else {\n      value._match = constructMixinRegExp(name);\n    }\n\n    scope[name] = value;\n  });\n}\n\nfunction createBlock({ node, Constructor, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = new Elem(parentElem[0].ownerDocument);\n  const elem = parentElem[0].namespaceURI === SVG_NS\n    ? doc.create('svg')\n    : doc;\n  const localBlocks = parentScope ? parentScope.$$.ns._blocks : blocks;\n  const localMixins = parentScope ? parentScope.$$.ns._mixins : mixins;\n  let children = node.children = node.children || emptyChildren;\n  let args = node.attrs = node.attrs || emptyAttrs;\n  let name = node.name || 'UnknownBlock';\n  let constructor = Constructor || (node.name && localBlocks[node.name]);\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n  let dBlockChildren;\n  let dElementsName;\n\n  if (name === 'd-block' && args.name) {\n    name = 'd-elements';\n    constructor = localBlocks[name];\n    dElementsName = args.name;\n    dBlockArgs = args;\n    dBlockChildren = children;\n    children = emptyChildren;\n\n    delete args.name;\n    args = {};\n  } else if (name === 'd-block' && hasOwnProperty(args, 'constructor')) {\n    name = 'UnknownBlock';\n    constructor = parentScope.$$.evaluate(args.constructor);\n\n    if (isFunction(constructor)) {\n      delete args.constructor;\n    } else {\n      constructor = null;\n    }\n  } else if ((dBlockMatch = name.match(NAMED_D_BLOCK_REGEX)) || name === 'd-block') {\n    constructor = blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const {\n      value,\n      children\n    } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = create(null);\n    let attrs = create(null);\n    let wasDRest;\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    iterateObject(args, (value, attr) => {\n      const isDRest = D_REST_REGEX.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? create(attrs)\n        : attrs;\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          setTimeout(() => {\n            iterateObject(localAttrs, cleanProperty);\n            assign(localAttrs, transformRestAttrs(\n              value, localMixins, mixinDefaultOpts\n            ));\n            calculateAttrs(attrs, currentAttrs, element, false);\n          }, 0);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        if (value === true) {\n          value = 'true';\n        }\n\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    const createMixins = calculateAttrs(attrs, currentAttrs, element, true);\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        element.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      element.text(`${ text }`);\n    }\n\n    if (children) {\n      const parentElem = name === 'template'\n        ? new Elem(element[0].content)\n        : element;\n      let prevBlock;\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }\n\n    const isParentBlock = parent instanceof Block;\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    createMixins();\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  if (dBlockMatch || name === 'd-block') {\n    parentScope.$$.dBlocks.push(blockInstance);\n  }\n\n  if (dBlockArgs) {\n    node = {\n      attrs: dBlockArgs,\n      children: dBlockChildren\n    };\n    node.name = parentScope.$$.evaluate(dElementsName, (newName) => {\n      node.name = newName;\n\n      Args.value = [node];\n    }, blockInstance, true);\n\n    Args.value = [node];\n    Args.parentScope = parentScope;\n  }\n\n  const html = name === 'd-elements'\n    ? Args.value || []\n    : constructor._html;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  if (name === 'd-each') {\n    $$.scope = create(parentScope.$$.name === '#d-item' ? parentScope.$$.scope : parentScope, {\n      [Args.item || '$item']: {\n        value: null,\n        writable: true\n      },\n      [Args.index || '$index']: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n\nfunction createMixin({ name, Mixin, dynamic, value, args, comment, elem, parentBlock, parentScope, parentTemplate }) {\n  const mixin = new Mixin({\n    name,\n    value,\n    dynamic,\n    args,\n    comment,\n    elem,\n    parentBlock,\n    parentScope,\n    parentTemplate\n  });\n\n  if (Mixin.evaluate) {\n    const value = mixin.value = mixin.evaluateAndWatch((newValue, oldValue) => {\n      mixin.value = newValue;\n\n      try {\n        mixin.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    });\n\n    mixin.afterUpdate(value);\n  }\n\n  return mixin;\n}\n\nfunction isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n\nfunction removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: {\n        temp: [],\n        perm: []\n      }\n    };\n  }, scope);\n}\n\nfunction constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n    const { watchers } = scope;\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (getting.indexOf(watchers.temp) === -1) {\n            getting.push(watchers.temp);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        if (!changed) {\n          changed = [];\n        }\n\n        const oldTempWatchers = watchers.temp.slice();\n        const oldValue = scope.value;\n\n        watchers.temp = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n        changed.push({\n          scope,\n          oldValue,\n          value\n        });\n\n        setTimeout(() => {\n          if (!changed) {\n            return;\n          }\n\n          const was = [];\n          const values = [];\n\n          for (let i = changed.length - 1; i >= 0; i--) {\n            const {\n              scope,\n              value,\n              oldValue\n            } = changed[i];\n\n            iterateArray(scope.watchers.perm, (watcher) => {\n              const index = was.indexOf(watcher);\n\n              if (index === -1) {\n                was.push(watcher);\n                values.push({\n                  value,\n                  oldValue\n                });\n              } else {\n                values[index].oldValue = oldValue;\n              }\n            });\n\n            changed.splice(i, 1);\n          }\n\n          changed = null;\n\n          iterateArray(was, (watcher, i) => {\n            const {\n              value,\n              oldValue\n            } = values[i];\n\n            watcher(value, oldValue);\n          });\n        }, 0);\n      }\n    };\n  }));\n}\n\nfunction watchForAllLocals(block, watcher) {\n  iterateObject(block.$$.locals, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n\nfunction watchForAllGlobals(block, watcher) {\n  const {\n    globals,\n    watchersToRemove\n  } = block.$$;\n\n  for (const glob in globals) {\n    /* eslint guard-for-in: 0 */\n    const watchers = globals[glob].watchers.perm;\n\n    watchers.push(watcher);\n    watchersToRemove.push({\n      watcher,\n      watchers\n    });\n  }\n}\n\nfunction watchForAllArgs(block, watcher) {\n  iterateObject(block.$$.args, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n\nfunction calculateArgs(args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  for (const arg in args) {\n    argsObject[arg] = args[arg];\n  }\n}\n\nfunction transformRestArgs(args) {\n  return collectFromObject(args, addArgs);\n}\n\nfunction transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return collectFromObject(attrs, (eventualAttrs, value, attr) => {\n    if (D_REST_REGEX.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  });\n}\n\nfunction mixinMatch(mixins, attr) {\n  let match;\n\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (argsMatch === '') {\n        args = [];\n      } else if (argsMatch) {\n        args = argsMatch.split(COMMA_REGEX);\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n\n  return match;\n}\n\nfunction calculateAttrs(attrs, attrsObject, elem, firstTime) {\n  iterateObject(attrsObject, ({ type, value }, attr) => {\n    if (!attrs[attr]) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = [];\n\n  for (const attr in attrs) {\n    const {\n      type,\n      dynamic,\n      value,\n      opts\n    } = attrs[attr];\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        const mixin = prevValue;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n        }\n\n        mixin.$$.isDynamic = dynamic;\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(value, (newValue) => {\n            const {\n              type,\n              dynamic\n            } = attrs[attr];\n\n            if (type === 'mixin' && !dynamic) {\n              executeMixinWatchers(mixin, newValue);\n            }\n          }, mixin);\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        }\n\n        nextValue = mixin;\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = createMixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(value, (newValue) => {\n              const {\n                type,\n                dynamic\n              } = attrs[attr];\n\n              if (type === 'mixin' && !dynamic) {\n                executeMixinWatchers(mixin, newValue);\n              }\n            }, mixin);\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  }\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, (buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n\nfunction executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n\nfunction constructMixinRegExp(name) {\n  return new RegExp(`^${ escapeRegex(name) }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n\nfunction extendBlock(cls) {\n  setProto(cls, Block);\n  setProto(cls.prototype, Block.prototype);\n}\n\nfunction insertTemplates(template, templates) {\n  const { vars, value } = template;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n  iterateArray(value, forEachNode);\n\n  function forEachNode({ type, value, children }, index, tree) {\n    if (type === '#comment') {\n      value = value.trim();\n\n      if (newTemplates[value]) {\n        tree[index] = newTemplates[value].value;\n        assign(newVars, toObjectKeys(newTemplates[value].vars));\n      }\n    } else {\n      iterateArray(children, forEachNode);\n    }\n  }\n\n  vars.length = 0;\n  vars.push(...keys(newVars));\n\n  return template;\n}\n\nfunction wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nfunction wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n\nfunction removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nfunction remove(child) {\n  child.$$.remove();\n}\n\nfunction cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n\nfunction removeTempWatcher(watcher) {\n  watcher.onRemove();\n  watcher();\n}\n\nfunction addArgs(args, value, arg) {\n  if (D_REST_REGEX.test(arg)) {\n    assign(args, transformRestArgs(value));\n  } else {\n    args[arg] = value;\n  }\n}\n\nexport { Block, Mixin, initApp, removeApp, insertTemplates };\n","/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint no-proto: 0 */\n  target.__proto__ = proto;\n});\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","assign","target","objects","arguments","source","key","collectFromObject","object","hasOwnProperty","has","iterateObject","mapObject","newObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","toStringTag","toString","slice","setToStringTag","tag","Symbol","prototype","isFunction","isNil","isString","escapeRegex","string","replace","regexpSpecialsRegexp","toCamelCase","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","toElem","isElem","Elem","isHTMLDocument","isElementsCollection","HTML_COLLECTION_REGEX","test","isArray","isValidNode","ELEMENT_REGEX","getName","nodeName","getAttrNS","attr","XML_NS","X_LINK_ATTR_REGEX","closest","X_LINK_NS","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","addAttr","attrs","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","hide","ownerDocument","addClass","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","remove","parent","removeChild","show","removeClass","selector","base","document","querySelectorAll","String","registerDBlock","Block","DBlock","this","$$","parentScope","parentParentScope","parentParentTemplate","parentTemplate","children","argsChildren","ownChildren","dBlockName","found","ParentScope","ParentTemplate","dBlocks","elems","template","registerDEach","createBlock","renderSet","_this2","itemsByUIDs","parentElem","scope","itemName","indexName","UID","sortBy","args","newItemsByUIDs","newUIDsCounter","newUIDs","set","filterBy","isArr","iterate","sort","filter","item","uid","evaluate","items","prevBlock","block","shift","insertAfterIt","content","push","opts","_this","undefined","evaluateAndWatch","watchArgs","registerDElements","mixins","watchersToRemove","removeWithParentSignal","removeContent","watchers","watcher","forDElements","child","registerDIf","DIf","Infinity","values","map","cond","if","newValue","Boolean","registerDItem","DItem","registerDSwitch","DSwitch","wasDefault","val","equals","value1","value2","registerDAttr","Mixin","removeAttr","apply","keys","registerDBind","off","on","join","error","registerDClass","classes","newClasses","EMPTY_SPACE_REGEX","cls","registerDElem","DElem","evaluateOnce","registerDHide","registerDNode","DNode","node","registerDOn","DOn","registerDShow","registerDStyle","oldValue","CSS_STYLES_SEPARATOR_REGEX","removeCSS","registerDValue","DValue","type","initialScopeValue","getProp","options","getEvalFunction","currentValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","getListenerName","e","offFormListener","forEach","option","selected","getValueForSetting","init","getValueForGetting","hasAttr","inputValue","isRadio","isMultiple","addValue","concat","initApp","html","Error","RootBlock","_vars","_html","removeApp","DwayneRootBlock","registerBuiltIns","proto","register","_match","constructMixinRegExp","Constructor","parentBlock","doc","namespaceURI","SVG_NS","localBlocks","ns","_blocks","blocks","localMixins","_mixins","emptyChildren","emptyAttrs","constructor","dBlockMatch","dBlockArgs","dBlockChildren","dElementsName","NAMED_D_BLOCK_REGEX","blockInstance","err","element","currentAttrs","wasDRest","mixinDefaultOpts","isDRest","D_REST_REGEX","localAttrs","restAttrs","cleanProperty","transformRestAttrs","mixinMatch","createMixins","calculateAttrs","isParentBlock","insertAfter","addContent","insertInStartOfIt","into","Args","globals","locals","newName","constructPrivateScope","scopeValues","privateScope","afterConstruct","afterRender","createMixin","dynamic","comment","mixin","afterUpdate","isInstanceOf","Class","Subclass","isPrototypeOf","removeWatchers","removeWatcher","constructPublicScope","evalMode","getting","temp","changed","oldTempWatchers","removeTempWatcher","was","perm","watchForAllLocals","watchForAllGlobals","glob","watchForAllArgs","calculateArgs","argsObject","arg","transformRestArgs","addArgs","eventualAttrs","localMatch","argsMatch","COMMA_REGEX","attrsObject","firstTime","nextType","nextDynamic","nextValue","prevType","prevValue","isDynamic","evaluated","buildMixin","firstValue","executeMixinWatchers","RegExp","extendBlock","insertTemplates","templates","forEachNode","tree","trim","newTemplates","newVars","wrapBlock","wrapper","returnValue","wrapMixin","onRemove","window","global","self","defineProperties","Object","Array","regexpSpecialCharacters","s","getProto","getPrototypeOf","setProto","setPrototypeOf","__proto__","CSS_IMPORTANT_REGEX","EVENT_REGEX","emptyCollection","includes","list","classList","attributes","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","elements","cb","contains","el","isText","createTextNode","createComment","documentElement","createElementNS","style","getPropertyValue","getPropertyPriority","removeProperty","setProperty","cssText","dataset","event","details","bubbles","cancelable","realDetails","finalEvent","Event","createEvent","initEvent","dispatchEvent","filterFn","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","first","method","prev","babelHelpers.get","textContent","condition","_arguments5","toggle","_arguments6","species","body","rootBlocks","rootMixins","blockHooks","mixinHooks","TAG_NAME_REGEX","ATTR_NAME_REGEX","WATCHED_ARG_PREFIX_REGEX","WATCHED_GLOBAL_PREFIX_REGEX","afterElem","originalArgs","childrenBlocks","func","onChange","targetBlock","forDItem","forDEach","onChangeFlag","result","expression","original","onEvalError","localWatchers","newResult","isRemoved","watcherBlock","isParentSignal","beforeRemove","_this7","contentToAdd","notRecursive","contentToMove","after","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","warn","reduce","currentReturnValue","wrappers","oldWatcher","_this8","Blocks","_this9","_value","Mixins"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL3V0aWxzL2lzLmpzIiwiLi4vc3JjL3V0aWxzL2VzY2FwZVJlZ2V4LmpzIiwiLi4vc3JjL3V0aWxzL3RvQ2FzZS5qcyIsIi4uL3NyYy9FbGVtLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWJsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWVhY2guanMiLCIuLi9zcmMvYmxvY2tzL2QtZWxlbWVudHMuanMiLCIuLi9zcmMvYmxvY2tzL2QtaWYuanMiLCIuLi9zcmMvYmxvY2tzL2QtaXRlbS5qcyIsIi4uL3NyYy9ibG9ja3MvZC1zd2l0Y2guanMiLCIuLi9zcmMvbWl4aW5zL2QtYXR0ci5qcyIsIi4uL3NyYy9taXhpbnMvZC1iaW5kLmpzIiwiLi4vc3JjL21peGlucy9kLWNsYXNzLmpzIiwiLi4vc3JjL21peGlucy9kLWVsZW0uanMiLCIuLi9zcmMvbWl4aW5zL2QtaGlkZS5qcyIsIi4uL3NyYy9taXhpbnMvZC1ub2RlLmpzIiwiLi4vc3JjL21peGlucy9kLW9uLmpzIiwiLi4vc3JjL21peGlucy9kLXNob3cuanMiLCIuLi9zcmMvbWl4aW5zL2Qtc3R5bGUuanMiLCIuLi9zcmMvbWl4aW5zL2QtdmFsdWUuanMiLCIuLi9zcmMvQmxvY2suanMiLCIuLi9zcmMvZ2xvYmFsLmpzIiwiLi4vc3JjL3V0aWxzL29iamVjdFN0YXRpY3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi9hcnJheSc7XG5cbmNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuXG4vKipcbiAqIEBjb25zdFxuICogQGZ1bmN0aW9uIGFzc2lnblxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCB0byBhc3NpZ24gcmVzdCBvZiBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0cyAtIE9iamVjdHMgdGhhdCBhcmUgYXNzaWduZWQgdG8gdGhlIHRhcmdldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIC4uLm9iamVjdHMpIHtcbiAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKHNvdXJjZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIGl0ZXJhdGVPYmplY3Qoc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdEZyb21PYmplY3Qob2JqZWN0LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlID0ge30pIHtcbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY2FsbGJhY2soaW5pdGlhbFZhbHVlLCB2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdDo6aGFzKGtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpdGVyYXRlT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5ld09iamVjdCA9IHt9O1xuXG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIG5ld09iamVjdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuL29iamVjdCc7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG5lZWRlZCB0byBiZSBhc3NpZ24gdG8gdGhlIHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBkZWZpbmluZyBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHsgZGVmaW5lUHJvcGVydGllcyB9ID0gT2JqZWN0O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgaXRlcmF0ZU9iamVjdChwcm9wZXJ0aWVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG5lZWRlZCB0byBiZSBhc3NpZ24gdG8gdGhlIHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBkZWZpbmluZyBmcm96ZW4gcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyB9IGZyb20gJy4vZGVmaW5lUHJvcGVydHknO1xuXG5jb25zdCB7IFN5bWJvbCB9ID0gZ2xvYmFsO1xuY29uc3QgeyB0b1N0cmluZyB9ID0ge307XG5cbi8qKlxuICogQGZ1bmN0aW9uIHRvU3RyaW5nVGFnXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBnZXQgdG9TdHJpbmdUYWcgb2YuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDdXQgc3RyaW5nLlxuICogQGRlc2NyaXB0aW9uIEN1dCBcIlR5cGVcIiBzdHJpbmcgZnJvbSBcIltvYmplY3QgVHlwZV1cIiBzdHJpbmcgdGhhdCBnb3R0ZW4gZnJvbSB7fS50b1N0cmluZyxjYWxsKG9iamVjdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1RhZyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdDo6dG9TdHJpbmcoKS5zbGljZSg4LCAtMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRUb1N0cmluZ1RhZyhvYmplY3QsIHRhZykge1xuICBpZiAoU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMob2JqZWN0LnByb3RvdHlwZSwge1xuICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHRhZ1xuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy9jaGVja1R5cGVzXG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBpczxUeXBlPiBtZXRob2RzLlxuICovXG5cbmltcG9ydCB7IHRvU3RyaW5nVGFnIH0gZnJvbSAnLi90b1N0cmluZ1RhZyc7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzQXJyYXlcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhbiBhcnJheS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNBcnJheShbXSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc0FycmF5KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpKTsgLy8gZmFsc2VcbiAqL1xuZXhwb3J0IGNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzRnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uIG9yIG5vdC5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGlzRnVuY3Rpb24oKCkgPT4ge30pOyAgICAgICAgICAgIC8vIHRydWVcbiAqIFxuICogY29uc3QgZnVuYyA9ICgpID0+IHt9O1xuICogT2JqZWN0LnNldFByb3RvdHlwZU9mKGZ1bmMsIHt9KTtcbiAqIGlzRnVuY3Rpb24oZnVuYyk7ICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzTmlsXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNOaWwobnVsbCk7ICAgICAgLy8gdHJ1ZVxuICogaXNOaWwodW5kZWZpbmVkKTsgLy8gdHJ1ZVxuICogaXNOaWwoZmFsc2UpOyAgICAgLy8gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIC8qIGVzbGludCBlcWVxZXE6IDAgKi9cbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzU3RyaW5nXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNTdHJpbmcoJzAnKTsgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNTdHJpbmcobmV3IFN0cmluZygnMCcpKTsgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1N0cmluZyc7XG59XG4iLCJjb25zdCByZWdleHBTcGVjaWFsQ2hhcmFjdGVycyA9IFtcbiAgJy4nLFxuICAnKycsICcqJywgJz8nLFxuICAnKCcsICcpJyxcbiAgJ1snLCAnXScsXG4gICd7JywgJ30nLFxuICAnPCcsICc+JyxcbiAgJ14nLCAnJCcsXG4gICchJyxcbiAgJz0nLFxuICAnOicsXG4gICctJyxcbiAgJ3wnLFxuICAnLCcsXG4gICdcXFxcJ1xuXTtcbmNvbnN0IHJlZ2V4cFNwZWNpYWxzUmVnZXhwID0gbmV3IFJlZ0V4cChcbiAgcmVnZXhwU3BlY2lhbENoYXJhY3RlcnNcbiAgICAubWFwKChzKSA9PiBgXFxcXCR7IHMgfWApXG4gICAgLmpvaW4oJ3wnKSxcbiAgJ2cnXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShyZWdleHBTcGVjaWFsc1JlZ2V4cCwgJ1xcXFwkJicpO1xufVxuIiwiY29uc3QgREFTSEVEX1NZTUJPTF9SRUdFWCA9IC8tW2Etel0vZztcbmNvbnN0IFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYID0gL1tBLVpdL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0NhbWVsQ2FzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShEQVNIRURfU1lNQk9MX1JFR0VYLCBjYXBpdGFsaXplKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvSHlwaGVuQ2FzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShVUFBFUkNBU0VEX1NZTUJPTF9SRUdFWCwgaHlwaGVuaXplKTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShtYXRjaCkge1xuICByZXR1cm4gbWF0Y2hbMV0udG9VcHBlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gaHlwaGVuaXplKG1hdGNoKSB7XG4gIHJldHVybiBgLSR7IG1hdGNoWzBdLnRvTG93ZXJDYXNlKCkgfWA7XG59XG4iLCJpbXBvcnQge1xuICBpc0FycmF5LCBpc05pbCwgaXNTdHJpbmcsXG4gIGFzc2lnbiwgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyxcbiAgZGVmaW5lUHJvcGVydGllcyxcbiAgY29sbGVjdEZyb21BcnJheSwgY29sbGVjdEZyb21PYmplY3QsXG4gIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCxcbiAgdG9DYW1lbENhc2UsIHRvSHlwaGVuQ2FzZSwgdG9TdHJpbmdUYWcsXG4gIHNldFRvU3RyaW5nVGFnLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7U3RyaW5nfSBFbGVtRXZlbnRTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBBIHN0cmluZyBjb250YWluaW5nIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBjb21tYSB3aXRoIHplcm8gb3IgbW9yZSBzcGFjZXMgb3IganVzdCBzcGFjZXMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbUxpc3RlbmVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0V2ZW50fSBlIC0gRmlyZWQgZXZlbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBFbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbVJlbW92ZUxpc3RlbmVyc1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsuLi5FbGVtRXZlbnRTdHJpbmd9IGV2ZW50cyAtIElmIGF0IGxlYXN0IG9uZSBhcmd1bWVudCBwcmVzZW50IG9ubHkgcmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgc3BlY2lmaWVkXG4gKiBieSB0aGUgZXZlbnRzIGluIHRoZSBhcmd1bWVudHMuXG4gKi9cblxuY29uc3Qge1xuICBkb2N1bWVudCA9IHt9LFxuICBTeW1ib2xcbn0gPSBnbG9iYWw7XG5jb25zdCBISURFX0NMQVNTID0gJ19fZHdheW5lLWhpZGRlbl9fJztcbmNvbnN0IEVWRU5UX1NFUEFSQVRPUl9SRUdFWCA9IC8oPzosfCApICovO1xuY29uc3QgQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVggPSAvOyA/LztcbmNvbnN0IENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCA9IC86IC87XG5jb25zdCBDU1NfSU1QT1JUQU5UX1JFR0VYID0gLyA/IWltcG9ydGFudCQvO1xuY29uc3QgRVZFTlRfUkVHRVggPSAvRXZlbnQkLztcbmNvbnN0IEVMRU1FTlRfUkVHRVggPSAvRWxlbWVudCQvO1xuY29uc3QgSFRNTF9DT0xMRUNUSU9OX1JFR0VYID0gL14oSFRNTENvbGxlY3Rpb258Tm9kZUxpc3QpJC87XG5jb25zdCBYX0xJTktfQVRUUl9SRUdFWCA9IC9eeGxpbms6XFx3LztcbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBYTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgWF9MSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgWEhUTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBlbXB0eUNvbGxlY3Rpb24gPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgRWxlbVxuICogQGV4dGVuZHMgQXJyYXlcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IFtlbGVtID0gW11dIC0gQW4gZWxlbWVudCBvciBhbiBhcnJheSBvZiBlbGVtZW50cyB0byB3cmFwLlxuICogQHJldHVybnMge0VsZW19IEluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhbiBlbGVtZW50cyBzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNscycpKTtcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NscycpKTtcbiAqL1xuY2xhc3MgRWxlbSBleHRlbmRzIFtdLmNvbnN0cnVjdG9yIHtcbiAgc3RhdGljIGFkZE1ldGhvZHMocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyh0aGlzLnByb3RvdHlwZSwgcHJvcGVydHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbGVtID0gZW1wdHlDb2xsZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgfVxuXG4gICAgc2V0UHJvdG8odGhpcywgRWxlbS5wcm90b3R5cGUpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICB0aGlzLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLihFbGVtfEVsZW1lbnR8RWxlbWVudFtdKX0gZWxlbWVudHMgLSBFYWNoIGFyZ3VtZW50IGlzIGEgRWxlbSwgb3IgRWxlbWVudCwgb3IgYXJyYXkgb2YgRWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgZWxlbWVudHMgdG8gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbTEuZmluZCgnLmNsczEnKVxuICAgKiAgIC5hZGQoZWxlbTIuZmluZCgnLmNsczInKSlcbiAgICogICAuaGlkZSgpO1xuICAgKi9cbiAgYWRkKCkge1xuICAgIGNvbnN0IGVsZW1zID0gdGhpcy5zbGljZSgpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGVsZW0pID0+IHtcbiAgICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgICAgZWxlbSA9IFtlbGVtXTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICAgIGlmICghZWxlbXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICBlbGVtcy5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYWRkQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY2xhc3NlcyB0byB0aGUgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmFkZENsYXNzKCdyZWQnLCAncm91bmQnKTtcbiAgICovXG4gIGFkZENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5hZGQoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2F0dHJdIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAgICogaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGF0dHJpYnV0ZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiByZXR1cm5lZCwgaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cjEnLCAndmFsdWUxJyk7IC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCdhdHRyMScpOyAgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5hdHRyKHtcbiAgICogICBhdHRyMTogJ3ZhbHVlMycsICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIGF0dHIyOiAndmFsdWUyJyAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCk7ICAgICAgICAgICAgICAgICAgLy8geyBhdHRyMTogJ3ZhbHVlMycsIGF0dHIyOiAndmFsdWUyJyB9XG4gICAqL1xuICBhdHRyKGF0dHIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChlbGVtLmF0dHJpYnV0ZXMsIGFkZEF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcoYXR0cikpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnMgPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICAgIHJldHVybiBuc1xuICAgICAgICA/IGVsZW0uZ2V0QXR0cmlidXRlTlMobnMsIGF0dHIpXG4gICAgICAgIDogZWxlbS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgYXR0ciA9IHsgW2F0dHJdOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QoYXR0ciwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQXR0cihrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWU7XG5cbiAgICAgICAgY29uc3QgbnMgPSBnZXRBdHRyTlMoa2V5LCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZU5TKG5zLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NoaWxkcmVuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IEQtV3JhcCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBlbGVtZW50J3MgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbigpO1xuICAgKi9cbiAgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXMubGVuZ3RoID8gdGhpc1swXS5jaGlsZE5vZGVzIDogW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjbG9zZXN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjY2xvc2VzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdH0uXG4gICAqL1xuICBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb2xsZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBjYiA9IDo6ZWxlbWVudHMucHVzaDtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNiLCBlbGVtLCBpbmRleCwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVsZW0oZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjb250YWluc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgYXJndW1lbnQgd2l0aGluIHRoaXMgZWxlbWVudC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBleHRlbnNpb24gZm9yXG4gICAqIFtOb2RlI2NvbnRhaW5zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcbiAgICovXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzWzBdO1xuICAgIGNvbnN0IGNoaWxkID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgcmV0dXJuICFwYXJlbnQgfHwgIWNoaWxkXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIElmIHR5cGUgaXMgXCIjY29tbWVudFwiIGEgY29tbWVudCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSAtIHdyYXAgb2YgdGhlIGNyZWF0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgZWxlbWVudCBpcyBqdXN0IGNyZWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKTtcbiAgICovXG4gIGNyZWF0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBsZXQgZWwgPSBudWxsO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdHlwZSA9PT0gJyN0ZXh0JztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gaXNIVE1MRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBpZiAoaXNUZXh0IHx8IHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgZWwgPSBpc1RleHRcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBucyA9IHR5cGUgPT09ICdzdmcnXG4gICAgICAgICAgPyBTVkdfTlNcbiAgICAgICAgICA6IGVsZW0ubmFtZXNwYWNlVVJJIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgfHwgWEhUTUxfTlM7XG5cbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBhZGQobmV3IEVsZW0oZWwpLmludG8oZWxlbSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVDb21tZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGNvbW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBjb21tZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGNvbW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZUNvbW1lbnQoJ2NvbW1lbnQnKTtcbiAgICovXG4gIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAuY3JlYXRlKCcjY29tbWVudCcpXG4gICAgICAudGV4dCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlVGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCB0ZXh0IG5vZGVzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyB0ZXh0IG5vZGVzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgdGV4dCBub2RlIGlzIGp1c3QgY3JlYXRlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGVUZXh0KCd0ZXh0Jyk7XG4gICAqL1xuICBjcmVhdGVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpc1xuICAgICAgLmNyZWF0ZSgnI3RleHQnKVxuICAgICAgLnRleHQodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBzdHlsZXMuIFN1cHBvcnRzICFpbXBvcnRhbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTsgLy8gZGlzcGxheSBzZXQgdG8gJ25vbmUnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBkaXNwbGF5OiAnaW5saW5lJywgICAgICAgICAvLyBkaXNwbGF5IHNldCB0byAnaW5saW5lJ1xuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygpOyAgICAgICAgICAgICAgICAgIC8vIHsgZGlzcGxheTogJ25vbmUnLCBjdXJzb3I6ICdwb2ludGVyJyB9XG4gICAqL1xuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KHN0eWxlLmNzc1RleHQuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpLCBhZGRDU1NQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpICsgKHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpID8gJyAhaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgdmFsdWUucmVwbGFjZShDU1NfSU1QT1JUQU5UX1JFR0VYLCAnJyksXG4gICAgICAgICAgQ1NTX0lNUE9SVEFOVF9SRUdFWC50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtrZXldIC0gTmFtZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgKHdpdGhvdXQgZGF0YS0gcHJlZml4KVxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBkYXRhc2V0IG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgZGF0YSBhdHRyaWJ1dGVzLiBTZWVcbiAgICogW0hUTUxFbGVtZW50I2RhdGFzZXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9kYXRhc2V0fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScsICd2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnKTsgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5kYXRhKHtcbiAgICogICBzb21lS2V5MTogJ3ZhbHVlMycsICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTMnXG4gICAqICAgc29tZUtleTI6ICd2YWx1ZTInICAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCk7ICAgICAgICAgICAgICAgICAgICAvLyB7IHNvbWVLZXkxOiAndmFsdWUzJywgc29tZUtleTI6ICd2YWx1ZTInIH1cbiAgICovXG4gIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGRhdGFzZXQsIGFkZERhdGFBdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YXNldFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChrZXksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGlzcGF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudH0gZXZlbnQgLSBFdmVudCBvciBhIHN0cmluZyAobmV3IEV2ZW50KGV2ZW50KSBpcyBjcmVhdGVkKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0V2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snKTtcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UsIGRhdGE6IDEgfSk7XG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XG4gICAqL1xuICBkaXNwYXRjaChldmVudCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYnViYmxlcyA9IHRydWUsXG4gICAgICBjYW5jZWxhYmxlID0gdHJ1ZSxcbiAgICAgIC4uLnJlYWxEZXRhaWxzXG4gICAgfSA9IGRldGFpbHMgfHwge307XG4gICAgbGV0IGZpbmFsRXZlbnQgPSBldmVudDtcblxuICAgIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmFsRXZlbnQgPSBuZXcgRXZlbnQoZmluYWxFdmVudCwgeyBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xuICAgICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0hUTUxEb2N1bWVudChlbGVtKVxuICAgICAgICAgID8gZWxlbVxuICAgICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIGZpbmFsRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG4gICAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChmaW5hbEV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZWxlbVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXggPSAwXSAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9mIHRoZSBzZXQgdG8gZ2V0LiBOZWdhdGl2ZSBpbmRleCBtZWFucyBlbGVtLmxlbmd0aCArIGluZGV4LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZWxlbSgxKTsgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMVxuICAgKiBlbGVtLmVsZW0oKTsgIC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDBcbiAgICovXG4gIGVsZW0oaW5kZXggPSAwKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCArIGluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzW2luZGV4XSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbHRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtmaWx0ZXJGbiA9IEJvb2xlYW5dIC0gRmlsdGVyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmZpbHRlcigoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuY2xvc2VzdCgnLnBhcmVudCcpKTtcbiAgICovXG4gIGZpbHRlcihmaWx0ZXJGbiA9IEJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZmlsdGVyRm4oZWxlbSwgaW5kZXgsIHRoaXMpKSB7XG4gICAgICAgIGFkZChlbGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZmluZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFbGVtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKi9cbiAgZmluZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgYWRkKGZpbmQoc2VsZWN0b3IsIGVsZW0pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZm9yRWFjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBmaW5kKCcuY2xzJykuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgsIHNldCkgPT4ge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZ1xuICAgKiB9KTtcbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBpdGVyYXRlQXJyYXkodGhpcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGNhbGxiYWNrKHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hhc0F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHInLCAndmFsdWUnKS5oYXNBdHRyKCdhdHRyJyk7IC8vIHRydWVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdhdHRyJykuaGFzQXR0cignYXR0cicpOyAgICAvLyBmYWxzZVxuICAgKi9cbiAgaGFzQXR0cihhdHRyKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBucyA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgIHJldHVybiBuc1xuICAgICAgPyBlbGVtLmhhc0F0dHJpYnV0ZU5TKG5zLCBhdHRyKVxuICAgICAgOiBlbGVtLmhhc0F0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gTmFtZSBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3MuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcyBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgICAgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKS5oYXNDbGFzcygnY2xzJyk7IC8vIGZhbHNlXG4gICAqL1xuICBoYXNDbGFzcyhjbHMpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNscylcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hpZGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gSGlkZXMgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaGlkZSgpO1xuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGhpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNodG1sXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW2h0bWxdIC0gSFRNTCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgSFRNTC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIEhUTUwgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyBIVE1MIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgaHRtbCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyBIVE1MLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmh0bWwoJzxkaXY+MTwvZGl2PicpO1xuICAgKiBlbGVtLmh0bWwoKTsgLy8gJzxkaXY+MTwvZGl2PidcbiAgICovXG4gIGh0bWwoaHRtbCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgIHJldHVybiBlbGVtXG4gICAgICAgID8gZWxlbS5pbm5lckhUTUxcbiAgICAgICAgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH1cblxuICBpbmNsdWRlcyhlbGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEFmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYWZ0ZXIgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGJlZm9yZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudFswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnRvXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHB1dCB0aGlzIGVsZW1lbnRzIGludG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSB0aGV5IGFyZSBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNhcHBlbmRDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvYXBwZW5kQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmludG8oZWxlbTIpO1xuICAgKiBlbGVtLmludG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmludG8oJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGludG8oZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudClbMF07XG5cbiAgICBpZiAoXG4gICAgICAhZWxlbWVudFxuICAgICAgfHwgaXNIVE1MRG9jdW1lbnQoZWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpc1tpXSwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoXG4gICAgICBlbGVtLm1hdGNoZXNcbiAgICAgIHx8IGVsZW0ubWF0Y2hlc1NlbGVjdG9yXG4gICAgICB8fCBlbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgfHwgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICAgIHx8IGVsZW0ubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgIHx8IGVsZW0ub01hdGNoZXNTZWxlY3RvclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtLCBzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBTZWxlY3RvciAnJHsgc2VsZWN0b3IgfScgaXMgbm90IGEgdmFsaWQgc2VsZWN0b3IgKEVsZW0jaXMpYCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBub2RlTmFtZSAobG93ZXJjYXNlZCkgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBuYW1lIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGVsZW0xID0gZWxlbS5jcmVhdGUoJ2RpdicpO1xuICAgKiBlbGVtMS5uYW1lKCkgLy8gJ2RpdidcbiAgICovXG4gIG5hbWUoKSB7XG4gICAgcmV0dXJuIGdldE5hbWUodGhpc1swXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25leHRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm5leHQoKTsgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkTmV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI29uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtRXZlbnRTdHJpbmd8T2JqZWN0LjxFbGVtRXZlbnRTdHJpbmd8RWxlbUxpc3RlbmVyPn0gZXZlbnQgLSBFaXRoZXIgYSB7QGxpbmsgRWxlbUV2ZW50U3RyaW5nfSBzdHJpbmdcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggZXZlbnQga2V5cyAoYSBrZXkgaXMgYWxzbyBFbGVtRXZlbnRTdHJpbmcpIGFuZCBsaXN0ZW5lcnMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0VsZW1MaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBtdXN0IGJlIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yXG4gICAqIHNwZWNpZmllZCBldmVudChzKS5cbiAgICogQHJldHVybnMge0VsZW1SZW1vdmVMaXN0ZW5lcnN9IEZ1bmN0aW9uIHRoYXQgdGFrZXMgb3B0aW9uYWwgZXZlbnQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGRhdGFsaXN0LCBrZXlnZW4sIG91dHB1dCcsXG4gICAqICAgKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKVxuICAgKiApO1xuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oXG4gICAqICAge1xuICAgKiAgICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICAgJ2JsdXInOiAoKSA9PiBjb25zb2xlLmxvZygnYmx1cicpXG4gICAqICAgfSxcbiAgICogICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGRhdGFsaXN0LCBrZXlnZW4sIG91dHB1dCdcbiAgICogKTtcbiAgICpcbiAgICogY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdjbGljaycpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScsICdpbnB1dCcpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICovXG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChpc1N0cmluZyhldmVudCkpIHtcbiAgICAgIGV2ZW50ID0geyBbZXZlbnRdOiBsaXN0ZW5lciB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0V2ZW50cyA9IHt9O1xuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IHt9O1xuXG4gICAgaXRlcmF0ZU9iamVjdChldmVudCwgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAobmV3RXZlbnRzW2V2ZW50XSA9IG5ld0V2ZW50c1tldmVudF0gfHwgW10pLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3RXZlbnRzLCAobGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICBpdGVyYXRlQXJyYXkobGlzdGVuZXJzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgKGFsbExpc3RlbmVyc1tldmVudF0gPSBhbGxMaXN0ZW5lcnNbZXZlbnRdIHx8IFtdKS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkoZXZlbnQuc3BsaXQoRVZFTlRfU0VQQVJBVE9SX1JFR0VYKSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuXG4gICAgICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGFsbExpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZU9iamVjdChhbGxMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcnMsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHJlbW92ZUxpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcblxuICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB3cmFwIG9mIHRoZSBzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICovXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZFBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3ByZXZcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5wcmV2KCk7IC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICovXG4gIHByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGRQcmV2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcHJvcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCAqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBhc3NpZ25lZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cbiAgICogQHJldHVybnMge0VsZW18Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3Mgc2V0dGVyIG9yIGEgdmFsdWUgaWYgZ2V0dGVyLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgaXMgZWl0aGVyIGEgcHJvcGVydHkgZ2V0dGVyIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIG9yIGEgc2V0dGVyIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJywgZmFsc2UpO1xuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScpOyAvLyBmYWxzZVxuICAgKi9cbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3ApID0+IHtcbiAgICAgICAgZWxlbVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGZyb20gdGhlIGRvY3VtZW50LlxuICAgKiBOb3RlOiBpdCBkb2Vzbid0IHJlbW92ZSB0aGVtIGZyb20gdGhlIHNldCBzbyB3YXRjaCBvdXQgZm9yIHRoZSBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlKCk7XG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChyZW1vdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVBdHRyKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5zID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlTlMobnMsIGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGNsYXNzZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChjbHMpID0+IGxpc3QucmVtb3ZlKGNscykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVDU1NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gcHJvcHMgLSBDU1MgcHJvcGVydGllcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgQ1NTIHByb3BlcnRpZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ1NTKCdkaXNwbGF5JywgJ3Bvc2l0aW9uJywgJ21hcmdpbicpO1xuICAgKi9cbiAgcmVtb3ZlQ1NTKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChjc3MpID0+IHtcbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0b0h5cGhlbkNhc2UoY3NzKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVwbGFjZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byByZXBsYWNlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogd2l0aCBhIHNldCBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50IChFbGVtZW50IG9yIEVsZW0pLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjcmVwbGFjZUNoaWxkXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9yZXBsYWNlQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlcGxhY2UoZWxlbTIpO1xuICAgKiBlbGVtLnJlcGxhY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLnJlcGxhY2UoJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIHJlcGxhY2UoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCk7XG5cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZWxlbSgwKTtcbiAgICBjb25zdCBwYXJlbnQgPSBmaXJzdC5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGVsZW0gPSBwYXJlbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdpbnRvJztcbiAgICBjb25zdCBuZXh0ID0gZmlyc3QubmV4dCgpWzBdO1xuICAgIGNvbnN0IHByZXYgPSBmaXJzdC5wcmV2KClbMF07XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgZWxlbSA9IG5leHQ7XG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QmVmb3JlJztcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsZW0gPSBwcmV2O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEFmdGVyJztcbiAgICB9XG5cbiAgICBmaXJzdC5yZW1vdmUoKTtcblxuICAgIGVsZW1lbnRbbWV0aG9kXShlbGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jc2hvd1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTaG93cyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICogSWYgYW4gZWxlbWVudCB3YXMgaGlkZGVuIHVzaW5nIHtAbGluayBFbGVtI2hpZGV9IHByZXZpb3VzIGRpc3BsYXkgaXMgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnNob3coKTtcbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChzaG93KTtcbiAgfVxuXG4gIHNsaWNlKCkge1xuICAgIHJldHVybiBuZXcgRWxlbShzdXBlci5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFt0ZXh0XSAtIFRleHQgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IHRleHQuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCB0ZXh0IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgdGV4dHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSB0ZXh0IGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIHRleHQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udGV4dCgnMTIzJyk7XG4gICAqIGVsZW0udGV4dCgpOyAvLyAnMTIzJ1xuICAgKi9cbiAgdGV4dCh0ZXh0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wKCd0ZXh0Q29udGVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0b2dnbGVBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgLSBBdHRyaWJ1dGUgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgYXR0cmlidXRlXG4gICAqIHdpdGggdGhlICcnIHZhbHVlIGFuZCBpZiBmYWxzZXkgbWV0aG9kIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZS4gSWYgbm90IHByZXNlbnQgbWV0aG9kIGFkZHNcbiAgICogdGhlIGF0dHJpYnV0ZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicpO1xuICAgKiBlbGVtLnRvZ2dsZUF0dHIoJ2F0dHInLCBzb21lQ29uZGl0aW9uKTtcbiAgICovXG4gIHRvZ2dsZUF0dHIoYXR0ciwgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhZWxlbS5oYXNBdHRyKGF0dHIpIDogY29uZGl0aW9uKSB7XG4gICAgICAgIGVsZW0uYXR0cihhdHRyLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUNsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNscyAtIENsYXNzIHRvIHRvZ2dsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtjb25kaXRpb25dIC0gSWYgcHJlc2VudCBhbmQgdGhlIGNvbmRpdGlvbiBpcyB0cnV0aHkgbWV0aG9kIGFkZHMgdGhlIGNsYXNzXG4gICAqIGFuZCBpZiBmYWxzZXkgbWV0aG9kIHJlbW92ZXMgdGhlIGNsYXNzLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgY2xhc3MgaWYgaXQgZG9lc24ndCBleGlzdCBhbmQgcmVtb3ZlcyBpZiBpdCBkb2VzLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB0b2dnbGluZyBjbGFzc2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnRvZ2dsZUNsYXNzKCdjbHMnKTtcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJywgc29tZUNvbmRpdGlvbik7XG4gICAqL1xuICB0b2dnbGVDbGFzcyhjbHMsIGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IHsgY2xhc3NMaXN0IH0gPSBlbGVtO1xuXG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKGNscywgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhY2xhc3NMaXN0LmNvbnRhaW5zKGNscykgOiBjb25kaXRpb24pO1xuICAgIH0pO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKEVsZW0sICdFbGVtJyk7XG5cbmlmIChTeW1ib2wgJiYgU3ltYm9sLnNwZWNpZXMpIHtcbiAgZGVmaW5lUHJvcGVydGllcyhFbGVtLCB7XG4gICAgW1N5bWJvbC5zcGVjaWVzXToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gQXJyYXk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGRvY1xuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cbiAqL1xuY29uc3QgZG9jID0gbmV3IEVsZW0oZG9jdW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gaHRtbFxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuXG4gKi9cbmNvbnN0IGh0bWwgPSBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gYm9keVxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5ib2R5LlxuICovXG5jb25zdCBib2R5ID0gbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBoZWFkXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXG4gKi9cbmNvbnN0IGhlYWQgPSBuZXcgRWxlbShkb2N1bWVudC5oZWFkKTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdG9FbGVtXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFbGVtZW50fEVsZW19IGVsZW0gLSBFbGVtZW50IG9yIEVsZW0uXG4gKiBAcmV0dXJucyB7RWxlbX0gSW5zdGFuY2Ugb2YgRWxlbS5cbiAqL1xuZnVuY3Rpb24gdG9FbGVtKGVsZW0pIHtcbiAgcmV0dXJuIGlzRWxlbShlbGVtKVxuICAgID8gZWxlbVxuICAgIDogbmV3IEVsZW0oZWxlbSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzRWxlbVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIEVsZW0uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgRWxlbSBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzRWxlbSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0hUTUxEb2N1bWVudFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIEhUTUxEb2N1bWVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgSFRNTERvY3VtZW50LlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIHZhbHVlIGlzIEhUTUxEb2N1bWVudCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzSFRNTERvY3VtZW50KHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdIVE1MRG9jdW1lbnQnO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0VsZW1lbnRzQ29sbGVjdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIENvbW1lbnQgb3IgVGV4dC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgSFRNTERvY3VtZW50LlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIHZhbHVlIGlzIENvbW1lbnQgb3IgVGV4dCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudHNDb2xsZWN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgSFRNTF9DT0xMRUNUSU9OX1JFR0VYLnRlc3QodG9TdHJpbmdUYWcodmFsdWUpKVxuICAgIHx8IGlzRWxlbSh2YWx1ZSlcbiAgICB8fCBpc0FycmF5KHZhbHVlKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkTm9kZSh2YWx1ZSkge1xuICBjb25zdCB0YWcgPSB0b1N0cmluZ1RhZyh2YWx1ZSk7XG5cbiAgcmV0dXJuIChcbiAgICBFTEVNRU5UX1JFR0VYLnRlc3QodGFnKVxuICAgIHx8IHRhZyA9PT0gJ0hUTUxEb2N1bWVudCdcbiAgICB8fCB0YWcgPT09ICdUZXh0J1xuICAgIHx8IHRhZyA9PT0gJ0RvY3VtZW50RnJhZ21lbnQnXG4gICAgfHwgdGFnID09PSAnQ29tbWVudCdcbiAgKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0TmFtZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1dIC0gRWxlbWVudCB3aGljaCBuYW1lIGlzIG5lZWRlZCB0byBrbm93LlxuICogQHJldHVybnMge1N0cmluZ30gRWxlbWVudCBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXROYW1lKGVsZW0pIHtcbiAgcmV0dXJuIChlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB8fCAnJztcbn1cblxuZnVuY3Rpb24gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pIHtcbiAgaWYgKGF0dHIgPT09ICd4bWxucycgfHwgYXR0ciA9PT0gJ3htbG5zOnhsaW5rJykge1xuICAgIHJldHVybiBlbGVtLm5vZGVOYW1lID09PSAnU1ZHJ1xuICAgICAgPyBYTUxfTlNcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGlmIChYX0xJTktfQVRUUl9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJ3N2ZycpLmxlbmd0aFxuICAgICAgPyBYX0xJTktfTlNcbiAgICAgIDogbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpIHtcbiAgY29uc3Qgc3R5bGUgPSBoZWFkLmZpbmQoYHN0eWxlIyR7IEhJREVfQ0xBU1MgfWApO1xuXG4gIGlmIChzdHlsZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoZWFkXG4gICAgLmNyZWF0ZSgnc3R5bGUnKVxuICAgIC5wcm9wKCdpZCcsIEhJREVfQ0xBU1MpXG4gICAgLnRleHQoYC4keyBISURFX0NMQVNTIH17ZGlzcGxheTpub25lICFpbXBvcnRhbnQ7fWApO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyKGF0dHJzLCBhdHRyKSB7XG4gIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBhZGRDU1NQcm9wKGNzcywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdChDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gICAgY3NzW3RvQ2FtZWxDYXNlKHByb3BlcnR5WzBdKV0gPSBwcm9wZXJ0eVsxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGREYXRhQXR0cihkYXRhLCB2YWx1ZSwga2V5KSB7XG4gIGRhdGFba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBoaWRlKGVsZW0pIHtcbiAgY3JlYXRlSGlkZVN0eWxlTm9kZShuZXcgRWxlbShlbGVtLm93bmVyRG9jdW1lbnQuaGVhZCkpO1xuICBuZXcgRWxlbShlbGVtKS5hZGRDbGFzcyhISURFX0NMQVNTKTtcbn1cblxuZnVuY3Rpb24gYWRkTmV4dChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ubmV4dFNpYmxpbmcpO1xufVxuXG5mdW5jdGlvbiBhZGRQYXJlbnQoYWRkLCBlbGVtKSB7XG4gIGFkZChlbGVtLnBhcmVudE5vZGUpO1xufVxuXG5mdW5jdGlvbiBhZGRQcmV2KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wcmV2aW91c1NpYmxpbmcpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoZWxlbSkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG93KGVsZW0pIHtcbiAgbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ2xhc3MoSElERV9DTEFTUyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGZpbmRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtiYXNlID0gZG9jdW1lbnRdIC0gQmFzZSB0byBmaW5kIGluLlxuICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gKiBbRG9jdW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICovXG5mdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBiYXNlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBFbGVtKGJhc2UucXVlcnlTZWxlY3RvckFsbChTdHJpbmcoc2VsZWN0b3IpKSk7XG59XG5cbmNyZWF0ZUhpZGVTdHlsZU5vZGUoaGVhZCk7XG5cbmV4cG9ydCB7IEVsZW0sIGRvYywgaHRtbCwgYm9keSwgaGVhZCwgZmluZCB9O1xuIiwiaW1wb3J0IHsgZmluZEluQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRCbG9jayhCbG9jaykge1xuICBjbGFzcyBEQmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICAgIDxkLWVsZW1lbnRzXG4gICAgICAgIHZhbHVlPVwie2VsZW1zfVwiXG4gICAgICAgIHBhcmVudFNjb3BlPVwie1BhcmVudFNjb3BlfVwiXG4gICAgICAgIHBhcmVudFRlbXBsYXRlPVwie1BhcmVudFRlbXBsYXRlfVwiXG4gICAgICAvPlxuICAgIGA7XG5cbiAgICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyZW50U2NvcGU6IHtcbiAgICAgICAgICAkJDoge1xuICAgICAgICAgICAgcGFyZW50U2NvcGU6IHBhcmVudFBhcmVudFNjb3BlLFxuICAgICAgICAgICAgcGFyZW50VGVtcGxhdGU6IHBhcmVudFBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgICAgYXJnc0NoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXJnc0NoaWxkcmVuOiBvd25DaGlsZHJlbixcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIGRCbG9ja05hbWVcbiAgICAgIH0gPSB0aGlzLiQkO1xuICAgICAgbGV0IGZvdW5kO1xuXG4gICAgICBpZiAob3duQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudFBhcmVudFNjb3BlO1xuICAgICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFBhcmVudFRlbXBsYXRlO1xuXG4gICAgICBpZiAoZEJsb2NrTmFtZSkge1xuICAgICAgICBmb3VuZCA9IGZpbmRJbkFycmF5KGNoaWxkcmVuLCAoeyBuYW1lOiBub2RlTmFtZSB9KSA9PiBub2RlTmFtZSA9PT0gYGQtYmxvY2s6JHsgZEJsb2NrTmFtZSB9YCk7XG5cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgICAgLyogZXNsaW50IG5vLWVtcHR5OiAwICovXG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgKHBhcmVudCA9IHBhcmVudC4kJC5wYXJlbnRTY29wZSlcbiAgICAgICAgICAgICYmICEoZm91bmQgPSBmaW5kSW5BcnJheShwYXJlbnQuJCQuZEJsb2NrcywgKHsgJCQ6IHsgZEJsb2NrTmFtZTogREJsb2NrTmFtZSB9IH0pID0+IERCbG9ja05hbWUgPT09IGRCbG9ja05hbWUpKVxuICAgICAgICAgICAgJiYgcGFyZW50LiQkLnBhcmVudFNjb3BlLiQkLm5hbWUgPT09ICcjZC1pdGVtJ1xuICAgICAgICAgICkge31cblxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgICAgICAgIGZvdW5kLnZhbHVlID0ge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogZm91bmQudmFsdWUuJCQuYXJnc0NoaWxkcmVuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZCAmJiBmb3VuZC52YWx1ZS5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICA/IGZvdW5kLnZhbHVlLmNoaWxkcmVuXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtYmxvY2snLFxuICAgIHZhbHVlOiBEQmxvY2tcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGFzc2lnbiwgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICBpc0FycmF5LCBpc0Z1bmN0aW9uXG59IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgW1xuICBhcmdzLnNldCxcbiAgYXJncy5maWx0ZXJCeSxcbiAgYXJncy5zb3J0Qnlcbl1gO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJERWFjaChCbG9jaywgY3JlYXRlQmxvY2spIHtcbiAgY2xhc3MgREVhY2ggZXh0ZW5kcyBCbG9jayB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJnczoge1xuICAgICAgICAgIGl0ZW06IGl0ZW1OYW1lID0gJyRpdGVtJyxcbiAgICAgICAgICBpbmRleDogaW5kZXhOYW1lID0gJyRpbmRleCdcbiAgICAgICAgfVxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGFzc2lnbih0aGlzLiQkLCB7XG4gICAgICAgIGl0ZW1zQnlVSURzOiB7fSxcbiAgICAgICAgVUlEOiB0aGlzLmFyZ3MudWlkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgIGluZGV4TmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJSZW5kZXIoKSB7XG4gICAgICB0aGlzLmV2YWx1YXRlQW5kV2F0Y2god2F0Y2hBcmdzLCB0aGlzLnJlbmRlclNldCk7XG4gICAgICB0aGlzLnJlbmRlclNldCgpO1xuICAgIH1cblxuICAgIHJlbmRlclNldCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJnc0NoaWxkcmVuLFxuICAgICAgICBpdGVtc0J5VUlEcyxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgIGluZGV4TmFtZSxcbiAgICAgICAgVUlEXG4gICAgICB9ID0gdGhpcy4kJDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJnczogeyBzb3J0QnkgfVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBuZXdJdGVtc0J5VUlEcyA9IHt9O1xuICAgICAgY29uc3QgbmV3VUlEc0NvdW50ZXIgPSB7fTtcbiAgICAgIGNvbnN0IG5ld1VJRHMgPSB7fTtcbiAgICAgIGxldCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZmlsdGVyQnlcbiAgICAgIH0gPSB0aGlzLmFyZ3M7XG4gICAgICBjb25zdCBpc0FyciA9IGlzQXJyYXkoc2V0KTtcbiAgICAgIGNvbnN0IGl0ZXJhdGUgPSBpc0FyclxuICAgICAgICA/IGl0ZXJhdGVBcnJheVxuICAgICAgICA6IGl0ZXJhdGVPYmplY3Q7XG5cbiAgICAgIGlmIChpc0FyciAmJiBpc0Z1bmN0aW9uKHNvcnRCeSkpIHtcbiAgICAgICAgc2V0ID0gc2V0XG4gICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAuc29ydChzb3J0QnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXJCeSkpIHtcbiAgICAgICAgZmlsdGVyQnkgPSBbZmlsdGVyQnldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShmaWx0ZXJCeSkpIHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGZpbHRlckJ5LCAoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgc2V0ID0gc2V0LmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZShzZXQsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBzY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuICAgICAgICBzY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG5cbiAgICAgICAgY29uc3QgdWlkID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoVUlELCBudWxsLCBudWxsLCBmYWxzZSwgZmFsc2UsIHRoaXMpO1xuXG4gICAgICAgIG5ld1VJRHNDb3VudGVyW3VpZF0gPSAobmV3VUlEc0NvdW50ZXJbdWlkXSB8fCAwKSArIDE7XG4gICAgICAgIG5ld1VJRHNbaW5kZXhdID0gdWlkO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlW2l0ZW1OYW1lXSA9IG51bGw7XG4gICAgICBzY29wZVtpbmRleE5hbWVdID0gbnVsbDtcblxuICAgICAgaXRlcmF0ZU9iamVjdChpdGVtc0J5VUlEcywgKGl0ZW1zLCB1aWQpID0+IHtcbiAgICAgICAgaWYgKCFuZXdVSURzQ291bnRlclt1aWRdKSB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGl0ZW1zLCByZW1vdmUpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0ZUFycmF5KGl0ZW1zLnNwbGljZShuZXdVSURzQ291bnRlclt1aWRdKSwgcmVtb3ZlKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICBpdGVyYXRlKHNldCwgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHVpZCA9IG5ld1VJRHNbaW5kZXhdO1xuICAgICAgICBsZXQgYmxvY2s7XG5cbiAgICAgICAgaWYgKGl0ZW1zQnlVSURzW3VpZF0gJiYgaXRlbXNCeVVJRHNbdWlkXS5sZW5ndGgpIHtcbiAgICAgICAgICBibG9jayA9IGl0ZW1zQnlVSURzW3VpZF0uc2hpZnQoKTtcbiAgICAgICAgICBibG9jay4kJC5zY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG4gICAgICAgICAgYmxvY2suJCQuc2NvcGVbaXRlbU5hbWVdID0gaXRlbTtcblxuICAgICAgICAgIGlmIChibG9jay4kJC5wcmV2QmxvY2sgIT09IHByZXZCbG9jayAmJiBwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGJsb2NrLiQkLmNvbnRlbnQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgICAgICAgIGluZGV4TmFtZSxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIG5hbWU6ICcjZC1pdGVtJyxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGFyZ3NDaGlsZHJlblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIChuZXdJdGVtc0J5VUlEc1t1aWRdID0gbmV3SXRlbXNCeVVJRHNbdWlkXSB8fCBbXSkucHVzaChibG9jayk7XG4gICAgICAgIGJsb2NrLiQkLnByZXZCbG9jayA9IHByZXZCbG9jaztcbiAgICAgICAgcHJldkJsb2NrID0gYmxvY2s7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kJC5pdGVtc0J5VUlEcyA9IG5ld0l0ZW1zQnlVSURzO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWVhY2gnLFxuICAgIHZhbHVlOiBERWFjaFxuICB9O1xufVxuXG5mdW5jdGlvbiByZW1vdmUoaXRlbSkge1xuICBpdGVtLiQkLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgaXRlcmF0ZUFycmF5LCByZW1vdmVBcnJheUVsZW0gfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MudmFsdWVgO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJERWxlbWVudHMoQmxvY2ssIGNyZWF0ZUJsb2NrKSB7XG4gIGNsYXNzIERFbGVtZW50cyBleHRlbmRzIEJsb2NrIHtcbiAgICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICAgIGNvbnN0IHsgcGFyZW50RWxlbSB9ID0gdGhpcy4kJDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgICB9ID0gdGhpcy5hcmdzO1xuXG4gICAgICB0aGlzLiQkLmV2YWx1YXRlKHdhdGNoQXJncywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgbWl4aW5zLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuYXJncztcblxuICAgICAgICBpdGVyYXRlQXJyYXkoY2hpbGRyZW4sIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuICAgICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgICAgY29udGVudC5yZW1vdmUoKTtcblxuICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJCQuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy4kJC5taXhpbnMgPSBbXTtcbiAgICAgICAgdGhpcy4kJC53YXRjaGVyc1RvUmVtb3ZlID0gd2F0Y2hlcnNUb1JlbW92ZS5maWx0ZXIoKHsgd2F0Y2hlcnMsIHdhdGNoZXIsIGZvckRFbGVtZW50cyB9KSA9PiB7XG4gICAgICAgICAgaWYgKGZvckRFbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHdhdGNoZXJzLCB3YXRjaGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJCQuY29udGVudCA9IG5ldyBFbGVtKCk7XG5cbiAgICAgICAgbGV0IHByZXZCbG9jaztcblxuICAgICAgICBpdGVyYXRlQXJyYXkodmFsdWUgfHwgW10sIChjaGlsZCkgPT4ge1xuICAgICAgICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxuICAgICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtZWxlbWVudHMnLFxuICAgIHZhbHVlOiBERWxlbWVudHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlV2l0aFBhcmVudFNpZ25hbChpdGVtKSB7XG4gIGl0ZW0uJCQucmVtb3ZlKHRydWUpO1xufVxuIiwiaW1wb3J0IHsgZmluZEluQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRJZihCbG9jaykge1xuICBjbGFzcyBESWYgZXh0ZW5kcyBCbG9jayB7XG4gICAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICAgIDxkLWVsZW1lbnRzXG4gICAgICAgIHZhbHVlPVwie2VsZW1zfVwiXG4gICAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgICAvPlxuICAgIGA7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICBzdXBlcihvcHRzKTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgYXJnc0NoaWxkcmVuXG4gICAgICB9ID0gdGhpcy4kJDtcbiAgICAgIGxldCBpbmRleCA9IEluZmluaXR5O1xuICAgICAgY29uc3QgdmFsdWVzID0gYXJnc0NoaWxkcmVuLm1hcCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cnMgPSB7fSxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9ID0gY2hpbGQ7XG4gICAgICAgIGxldCBjb25kID0gYXR0cnMuaWY7XG5cbiAgICAgICAgaWYgKG5hbWUgIT09ICdkLWVsc2UnICYmIGNvbmQpIHtcbiAgICAgICAgICBjb25kID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoY29uZCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoISFuZXdWYWx1ZSA9PT0gdmFsdWVzW2ldKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVzW2ldID0gISFuZXdWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGkgPiBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZpbmRJbkFycmF5KHZhbHVlcywgQm9vbGVhbik7XG5cbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICBpbmRleCA9IGZvdW5kLmtleTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGFyZ3NDaGlsZHJlbltmb3VuZC5rZXldLmNoaWxkcmVuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZCAmJiBpbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhY29uZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtaWYnLFxuICAgIHZhbHVlOiBESWZcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRJdGVtKEJsb2NrKSB7XG4gIGNsYXNzIERJdGVtIGV4dGVuZHMgQmxvY2sge1xuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGh0bWxgXG4gICAgICA8ZC1lbGVtZW50c1xuICAgICAgICB2YWx1ZT1cInskJC5hcmdzQ2hpbGRyZW59XCJcbiAgICAgICAgcGFyZW50U2NvcGU9XCJ7dGhpc31cIlxuICAgICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgICAgLz5cbiAgICBgO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnI2QtaXRlbScsXG4gICAgdmFsdWU6IERJdGVtXG4gIH07XG59XG4iLCJpbXBvcnQgeyBjb2xsZWN0RnJvbUFycmF5LCBmaW5kSW5BcnJheSwgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BhcmdzLnZhbHVlYDtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFN3aXRjaChCbG9jaykge1xuICBjbGFzcyBEU3dpdGNoIGV4dGVuZHMgQmxvY2sge1xuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGh0bWxgXG4gICAgICA8ZC1lbGVtZW50c1xuICAgICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgICBwYXJlbnRTY29wZT1cInskJC5wYXJlbnRTY29wZX1cIlxuICAgICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgICAgLz5cbiAgICBgO1xuXG4gICAgaW5kZXggPSBJbmZpbml0eTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgICQkOiB7XG4gICAgICAgICAgYXJnc0NoaWxkcmVuLFxuICAgICAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGFyZ3M6IHsgdmFsdWUgfVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgd2FzRGVmYXVsdDtcblxuICAgICAgdGhpcy52YWx1ZXMgPSBjb2xsZWN0RnJvbUFycmF5KGFyZ3NDaGlsZHJlbiwgKHZhbHVlcywgY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBsZXQgdmFsID0gYXR0cnMuaWY7XG5cbiAgICAgICAgaWYgKHdhc0RlZmF1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSAhPT0gJ2QtY2FzZScgJiYgbmFtZSAhPT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgICB3YXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSAnZC1kZWZhdWx0Jykge1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHModGhpcy52YWx1ZXNbaV0udmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudmFsdWVzW2ldLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSBmaW5kSW5BcnJheSh0aGlzLnZhbHVlcywgKHsgdmFsdWUgfSkgPT4gKFxuICAgICAgICAgICAgICB0aGlzLmVxdWFscyh2YWx1ZSwgYXJncy52YWx1ZSlcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGZvdW5kLmtleTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kLnZhbHVlLmNoaWxkcmVuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5lcXVhbHModmFsLCB2YWx1ZSkgJiYgdGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIGFmdGVyQ29uc3RydWN0KCkge1xuICAgICAgdGhpcy5ldmFsdWF0ZUFuZFdhdGNoKHdhdGNoQXJncywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheSh0aGlzLnZhbHVlcywgKHsgbmFtZSwgdmFsdWUsIGNoaWxkcmVuIH0sIGkpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWwgPSBuYW1lID09PSAnZC1kZWZhdWx0J1xuICAgICAgICAgICAgPyBuZXdWYWx1ZVxuICAgICAgICAgICAgOiB2YWx1ZTtcblxuICAgICAgICAgIGlmICh0aGlzLmVxdWFscyh2YWwsIG5ld1ZhbHVlKSAmJiB0aGlzLmluZGV4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXF1YWxzKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC1zd2l0Y2gnLFxuICAgIHZhbHVlOiBEU3dpdGNoXG4gIH07XG59XG4iLCJpbXBvcnQgeyBjb2xsZWN0RnJvbU9iamVjdCwgaXRlcmF0ZU9iamVjdCwga2V5cyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREF0dHIoTWl4aW4pIHtcbiAgY2xhc3MgREF0dHIgZXh0ZW5kcyBNaXhpbiB7XG4gICAgYXR0cnMgPSB7fTtcblxuICAgIGFmdGVyVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGF0dHJzXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb2xsZWN0RnJvbU9iamVjdChhcmdzLCAoYXR0cnMsIGF0dHIpID0+IHtcbiAgICAgICAgICBhdHRyc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZU9iamVjdChhdHRycywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmICghKHByb3AgaW4gbmV3VmFsdWUpKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyKHByb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVsZW0uYXR0cihuZXdWYWx1ZSk7XG5cbiAgICAgIHRoaXMuYXR0cnMgPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGF0dHJzXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgZWxlbS5yZW1vdmVBdHRyLmFwcGx5KGVsZW0sIGtleXMoYXR0cnMpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWF0dHInLFxuICAgIHZhbHVlOiBEQXR0clxuICB9O1xufVxuXG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQmluZChNaXhpbikge1xuICBjbGFzcyBEQmluZCBleHRlbmRzIE1peGluIHtcbiAgICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMub2ZmKSB7XG4gICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3ZpZGUgXCJkLWJpbmRcIiBtaXhpbiB3aXRoIGFuIGV2ZW50IG5hbWVzIChsaWtlIFwiZC1iaW5kKGNsaWNrKVwiIG9yIFwiZC1iaW5kKGtleXVwLCBrZXlwcmVzcylcIikhJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3JlUmVtb3ZlKCkge1xuICAgICAgY29uc3QgeyBvZmYgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgb2ZmKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC1iaW5kJyxcbiAgICB2YWx1ZTogREJpbmRcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGlzQXJyYXksIGlzU3RyaW5nLFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3Rcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBFTVBUWV9TUEFDRV9SRUdFWCA9IC9cXHMrLztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRENsYXNzKE1peGluKSB7XG4gIGNsYXNzIERDbGFzcyBleHRlbmRzIE1peGluIHtcbiAgICBjbGFzc2VzID0gW107XG5cbiAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBhcmdzLFxuICAgICAgICBjbGFzc2VzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBbXTtcblxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgICAgID8gYXJnc1xuICAgICAgICAgIDogW107XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zcGxpdChFTVBUWV9TUEFDRV9SRUdFWCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKGNscykgPT09IC0xKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXRlcmF0ZUFycmF5KG5ld1ZhbHVlLCAoY2xzKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNscykpIHtcbiAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICAgIGlmICghbmV3VmFsdWUgfHwgIW5ld1ZhbHVlW2Nsc10pIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVyYXRlT2JqZWN0KG5ld1ZhbHVlLCAodmFsLCBjbHMpID0+IHtcbiAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsYXNzZXMgPSBuZXdDbGFzc2VzO1xuICAgIH1cblxuICAgIGJlZm9yZVJlbW92ZSgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgY2xhc3Nlc1xuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MuYXBwbHkoZWxlbSwgY2xhc3Nlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC1jbGFzcycsXG4gICAgdmFsdWU6IERDbGFzc1xuICB9O1xufVxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRFbGVtKE1peGluLCBjcmVhdGVCbG9jaywgQmxvY2spIHtcbiAgY2xhc3MgREVsZW0gZXh0ZW5kcyBNaXhpbiB7XG4gICAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICBzdXBlcihvcHRzKTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBhcmdzLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgZWxlbVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGVPbmNlKCk7XG5cbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIHNjb3BlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZShlbGVtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHNjb3BlW3ZhbHVlXSA9IGVsZW07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC1lbGVtJyxcbiAgICB2YWx1ZTogREVsZW1cbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRIaWRlKE1peGluKSB7XG4gIGNsYXNzIERIaWRlIGV4dGVuZHMgTWl4aW4ge1xuICAgIGFmdGVyVXBkYXRlKHZhbHVlKSB7XG4gICAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbGVtLmhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uc2hvdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZVJlbW92ZSgpIHtcbiAgICAgIHRoaXMuZWxlbS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC1oaWRlJyxcbiAgICB2YWx1ZTogREhpZGVcbiAgfTtcbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJETm9kZShNaXhpbiwgY3JlYXRlQmxvY2ssIEJsb2NrKSB7XG4gIGNsYXNzIEROb2RlIGV4dGVuZHMgTWl4aW4ge1xuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xuXG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBzY29wZVt2YWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtbm9kZScsXG4gICAgdmFsdWU6IEROb2RlXG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJET24oTWl4aW4pIHtcbiAgY2xhc3MgRE9uIGV4dGVuZHMgTWl4aW4ge1xuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLmVsZW0ub24odGhpcy5hcmdzLmpvaW4oJywnKSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZXZhbHVhdGVPbmNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtb25cIiBtaXhpbiB3aXRoIGFuIGV2ZW50IG5hbWVzIChsaWtlIFwiZC1vbihjbGljaylcIiBvciBcImQtb24oa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICBjb25zdCB7IG9mZiB9ID0gdGhpcztcblxuICAgICAgaWYgKG9mZikge1xuICAgICAgICBvZmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLW9uJyxcbiAgICB2YWx1ZTogRE9uXG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEU2hvdyhNaXhpbikge1xuICBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcbiAgICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgICAgY29uc3QgeyBlbGVtIH0gPSB0aGlzO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZWxlbS5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtc2hvdycsXG4gICAgdmFsdWU6IERTaG93XG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBpc1N0cmluZywgaXRlcmF0ZU9iamVjdCwga2V5cyxcbiAgY29sbGVjdEZyb21PYmplY3QsIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWCA9IC87ID8vO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEU3R5bGUoTWl4aW4pIHtcbiAgY2xhc3MgRFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xuICAgIGNzcyA9IHt9O1xuXG4gICAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNzc1xuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21PYmplY3QoYXJncywgKGNzcywgcHJvcCkgPT4ge1xuICAgICAgICAgIGNzc1twcm9wXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKG5ld1ZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tQXJyYXkoXG4gICAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAgIC5zcGxpdChDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWClcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgICAgYWRkQ1NTUHJvcFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlT2JqZWN0KGNzcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmICghbmV3VmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUNTUyhwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbGVtLmNzcyhuZXdWYWx1ZSk7XG5cbiAgICAgIHRoaXMuY3NzID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgYmVmb3JlUmVtb3ZlKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBjc3NcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBlbGVtLnJlbW92ZUNTUy5hcHBseShlbGVtLCBrZXlzKGNzcykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtc3R5bGUnLFxuICAgIHZhbHVlOiBEU3R5bGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkQ1NTUHJvcChjc3MsIGl0ZW0pIHtcbiAgY29uc3QgW3Byb3AsIHZhbHVlXSA9IGl0ZW07XG5cbiAgY3NzW3Byb3BdID0gdmFsdWU7XG59XG4iLCJpbXBvcnQge1xuICBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc05pbCxcbiAgY29sbGVjdEZyb21BcnJheVxufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRWYWx1ZShNaXhpbiwgY3JlYXRlQmxvY2ssIEJsb2NrKSB7XG4gIGNsYXNzIERWYWx1ZSBleHRlbmRzIE1peGluIHtcbiAgICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBlbGVtLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLm5hbWUoKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBlbGVtLnByb3AoJ3R5cGUnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZU9uY2UoKTtcbiAgICAgIGxldCBpbml0aWFsU2NvcGVWYWx1ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMucHJvcCA9IGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSk7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGVsZW0uZmluZCgnb3B0aW9uJyk7XG4gICAgICB0aGlzLnNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IGFyZ3NbMF07XG4gICAgICAgIHRoaXMuc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgIDogcGFyZW50VGVtcGxhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgaW5pdGlhbFNjb3BlVmFsdWUgPSB0aGlzLnNjb3BlLiQkLmV2YWx1YXRlKGdldEV2YWxGdW5jdGlvbih2YWx1ZSksIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFByb3AobmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluaXRpYWxFbGVtVmFsdWUgPSB0aGlzLmdldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUsIHRydWUpO1xuICAgICAgY29uc3QgaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgPSBpc05pbChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICBjb25zdCBpc0NoZWNrYm94ID0gdHlwZSA9PT0gJ2NoZWNrYm94JztcbiAgICAgIGNvbnN0IGNoYW5nZVNjb3BlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0UHJvcCh0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbEVsZW1WYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTY29wZSgpO1xuXG4gICAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xuICAgICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbFNjb3BlVmFsdWU7XG4gICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2ZmRWxlbUxpc3RlbmVyID0gZWxlbS5vbihnZXRMaXN0ZW5lck5hbWUobmFtZSwgdHlwZSksIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gbm9kZSkge1xuICAgICAgICAgIGNoYW5nZVNjb3BlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIgPSBlbGVtLmNsb3Nlc3QoJ2Zvcm0nKS5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoY2hhbmdlU2NvcGUsIDApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2hhbmdlU2NvcGUoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjb3BlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY3VycmVudFZhbHVlXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZVt2YWx1ZV0gPSBjdXJyZW50VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0UHJvcCh2YWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wLFxuICAgICAgICB0eXBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKHByb3AgPT09ICd0ZXh0Jykge1xuICAgICAgICBlbGVtLnRleHQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jykge1xuICAgICAgICBvcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2Yob3B0aW9uLnZhbHVlKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5wcm9wKHByb3AsIGdldFZhbHVlRm9yU2V0dGluZyhuYW1lLCB2YWx1ZSwgdHlwZSwgbm9kZS52YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldFByb3AodmFsdWVzLCBpbml0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICByZXR1cm4gcHJvcCA9PT0gJ3RleHQnXG4gICAgICAgID8gZWxlbS50ZXh0KClcbiAgICAgICAgOiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgZWxlbS5wcm9wKHByb3ApLCB0eXBlLCBub2RlLnZhbHVlLCB2YWx1ZXMsIG9wdGlvbnMsIGluaXQsIHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKTtcbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lcigpO1xuICAgICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLXZhbHVlJyxcbiAgICB2YWx1ZTogRFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICByZXR1cm4gZWxlbS5oYXNBdHRyKCdtdWx0aXBsZScpXG4gICAgICAgID8gJ211bHRpcGxlLXNlbGVjdCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICByZXR1cm4gJ2ZpbGVzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICA/ICdjaGVja2VkJ1xuICAgICAgICA6ICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignY29udGVudEVkaXRhYmxlJylcbiAgICAgICAgPyAndGV4dCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUpIHtcbiAgaWYgKG5hbWUgIT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBpc1JhZGlvID0gdHlwZSA9PT0gJ3JhZGlvJztcblxuICBpZiAoIWlzUmFkaW8gJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpc1JhZGlvXG4gICAgPyB2YWx1ZSA9PT0gaW5wdXRWYWx1ZVxuICAgIDogdmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yR2V0dGluZyhuYW1lLCB2YWx1ZSwgdHlwZSwgaW5wdXRWYWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBpc011bHRpcGxlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KG9wdGlvbnMsIGFkZFZhbHVlLCBbXSk7XG4gICAgfVxuXG4gICAgY2FzZSAnaW5wdXQnOiB7XG4gICAgICBpZiAodHlwZSAhPT0gJ3JhZGlvJyAmJiB0eXBlICE9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgPyBpbnB1dFZhbHVlXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZhbHVlICYmIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzLmluZGV4T2YoaW5wdXRWYWx1ZSkgPT09IC0xXG4gICAgICAgICAgICA/IHZhbHVlcy5jb25jYXQoaW5wdXRWYWx1ZSlcbiAgICAgICAgICAgIDogdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtpbnB1dFZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAuLi52YWx1ZXMuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuICdjaGFuZ2UnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZSA9PT0gJ3JhZGlvJ1xuICAgICAgICB8fCB0eXBlID09PSAnY2hlY2tib3gnXG4gICAgICAgIHx8IHR5cGUgPT09ICdjb2xvcidcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2ZpbGUnXG4gICAgICApXG4gICAgICAgID8gJ2NoYW5nZSdcbiAgICAgICAgOiAnY2hhbmdlIGlucHV0JztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gJ2lucHV0JztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RXZhbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAoc2NvcGUpID0+IHNjb3BlW3ZhbHVlXTtcbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUodmFsdWVzLCB7IHNlbGVjdGVkLCB2YWx1ZSB9KSB7XG4gIGlmIChzZWxlY3RlZCAmJiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgQmxvY2tcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEJsb2NrIGNsYXNzLlxuICovXG5cbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcywgZGVmaW5lUHJvcGVydGllcyxcbiAgYXNzaWduLCBlc2NhcGVSZWdleCwgbWFwT2JqZWN0LFxuICB0b09iamVjdEtleXMsIGNvbGxlY3RGcm9tT2JqZWN0LFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzRnVuY3Rpb24sIGlzTmlsLCBpc0FycmF5LFxuICBzZXRUb1N0cmluZ1RhZywgaGFzT3duUHJvcGVydHksXG4gIHJlbW92ZUFycmF5RWxlbSwgY3JlYXRlLFxuICBnZXRQcm90bywgc2V0UHJvdG8sIGtleXNcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgKiBhcyBCbG9ja3MgZnJvbSAnLi9ibG9ja3MnO1xuaW1wb3J0ICogYXMgTWl4aW5zIGZyb20gJy4vbWl4aW5zJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEV2YWx1YXRpb25FcnJvclxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGV4cHJlc3Npb24gLSBFeHByZXNzaW9uIHdoaWNoIGhhcyBiZWVuIGV2YWx1YXRlZCB3aXRoIHRoZSBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgaW4gY29udGV4dCBvZiB3aGljaCB0aGUgZXhwcmVzc2lvbiBoYXMgYmVlbiBldmFsdWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2F0Y2hlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgVmFyc1dhdGNoZXJcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXcmFwcGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Jsb2NrfSBCbG9jayBjbGFzcyB0byB3cmFwLlxuICogQHJldHVybnMge0Jsb2NrfSBOZXcgQmxvY2sgY2xhc3MuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQWZ0ZXJVcGRhdGVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxuICogQHBhcmFtIHsqfSBtaXhpbiAtIE1peGluIGluc3RhbmNlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEJsb2NrUmVnaXN0ZXJIb29rXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Jsb2NrfSBCbG9jayAtIFJlZ2lzdGVyaW5nIGJsb2NrLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBuYW1lLlxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIHRoZSBibG9jay5cbiAqIElmIEJsb2NrIHN1YmNsYXNzIHJldHVybmVkIGl0J3MgcmVnaXN0ZXJlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsIGJsb2NrLCBvdGhlcndpc2VcbiAqIHRoZSBpbml0aWFsIGJsb2NrIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWl4aW5SZWdpc3Rlckhvb2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QmxvY2t9IE1peGluIC0gUmVnaXN0ZXJpbmcgbWl4aW4uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE1peGluIG5hbWUuXG4gKiBAcmV0dXJucyBSZXR1cm4gdmFsdWUgaXMgdXNlZCBmb3IgcmVnaXN0ZXJpbmcgdGhlIG1peGluLlxuICogSWYgTWl4aW4gc3ViY2xhc3MgcmV0dXJuZWQgaXQncyByZWdpc3RlcmVkIGluc3RlYWQgb2YgdGhlIGluaXRpYWwgbWl4aW4sIG90aGVyd2lzZVxuICogdGhlIGluaXRpYWwgbWl4aW4gaXMgdXNlZC5cbiAqL1xuXG5jb25zdCByb290QmxvY2tzID0gY3JlYXRlKG51bGwpO1xuY29uc3Qgcm9vdE1peGlucyA9IGNyZWF0ZShudWxsKTtcbmNvbnN0IGJsb2NrSG9va3MgPSBbXTtcbmNvbnN0IG1peGluSG9va3MgPSBbXTtcbmNvbnN0IHsgaXNQcm90b3R5cGVPZiB9ID0ge307XG5jb25zdCBUQUdfTkFNRV9SRUdFWCA9IC9eW2Etel1bYS16XFxkXFwtXy46IUAjJCVeJiooKVtcXF17fT0nXCJcXFxcXSokL2k7XG5jb25zdCBBVFRSX05BTUVfUkVHRVggPSAvXltcXHUwMDAwLVxcdTAwMjBcXHMnXCI+Lz1dKyQvO1xuY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IERfUkVTVF9SRUdFWCA9IC9eZC1yZXN0KD86I3wkKS87XG5jb25zdCBXQVRDSEVEX0FSR19QUkVGSVhfUkVHRVggPSAvXmFyZ3NcXC4vO1xuY29uc3QgV0FUQ0hFRF9HTE9CQUxfUFJFRklYX1JFR0VYID0gL15nbG9iYWxzXFwuLztcbmNvbnN0IE5BTUVEX0RfQkxPQ0tfUkVHRVggPSAvXmQtYmxvY2s6KFtcXHNcXFNdKykkLztcbmNvbnN0IENPTU1BX1JFR0VYID0gLywvO1xuY29uc3QgYWZ0ZXJFbGVtID0gbmV3IEVsZW0oKTtcbmNvbnN0IGVtcHR5Q2hpbGRyZW4gPSBbXTtcbmNvbnN0IGVtcHR5QXR0cnMgPSB7fTtcbmxldCBldmFsTW9kZTtcbmxldCBnZXR0aW5nID0gW107XG5sZXQgY2hhbmdlZDtcblxuLyoqXG4gKiBAY2xhc3MgQmxvY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gRWxlbWVudCBvcHRpb25zLlxuICogQHJldHVybnMge0Jsb2NrfSBJbnN0YW5jZSBvZiBCbG9jay5cbiAqIEBkZXNjcmlwdGlvbiBDbGFzcyBmb3IgZHluYW1pYyB0ZW1wbGF0aW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBELCBCbG9jaywgaW5pdEFwcCB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogY2xhc3MgQXBwIGV4dGVuZHMgQmxvY2sge1xuICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPEhlbGxvIHRleHQ9XCJ7dGV4dH1cIi8+JztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAqICAgICBzdXBlcihvcHRzKTtcbiAqXG4gKiAgICAgdGhpcy50ZXh0ID0gJ3dvcmxkICgwKSc7XG4gKiAgICAgdGhpcy50aW1lcyA9IDA7XG4gKlxuICogICAgIHRoaXMuc2V0SW50ZXJ2YWwoKTtcbiAqICAgfVxuICpcbiAqICAgc2V0SW50ZXJ2YWwoKSB7XG4gKiAgICAgRCgxMDAwKS5pbnRlcnZhbCgoKSA9PiB7XG4gKiAgICAgICB0aGlzLnRleHQgPSBgd29ybGQgKCR7ICsrdGhpcy50aW1lcyB9KWA7XG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBCbG9jay5ibG9jaygnQXBwJywgQXBwKTtcbiAqIEJsb2NrLmJsb2NrKCdIZWxsbycsICdIZWxsbywge2FyZ3MudGV4dH0hJyk7XG4gKlxuICogaW5pdEFwcCgnQXBwJywgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKSk7XG4gKi9cbmNsYXNzIEJsb2NrIHtcbiAgc3RhdGljIF9ibG9ja3MgPSBjcmVhdGUocm9vdEJsb2Nrcyk7XG4gIHN0YXRpYyBfbWl4aW5zID0gY3JlYXRlKHJvb3RNaXhpbnMpO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay5kZWZhdWx0QXJncyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRlZmF1bHQgYXJncy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0QXJncyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLmRlZmF1bHRMb2NhbHMgPSBudWxsXVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkZWZhdWx0IGxvY2Fscy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0TG9jYWxzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2sudGVtcGxhdGUgPSB7IHZhcnM6IFtdLCB2YWx1ZTogW10gfV1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgdGVtcGxhdGUuXG4gICAqL1xuICBzdGF0aWMgdGVtcGxhdGUgPSB7XG4gICAgdmFyczogW10sXG4gICAgdmFsdWU6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sub25FdmFsRXJyb3JcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0V2YWx1YXRpb25FcnJvcn0gZXJyIC0gVGhlIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBhbiBldmFsdWF0aW9uIGVycm9yIG9jY3Vycy5cbiAgICovXG4gIHN0YXRpYyBvbkV2YWxFcnJvcihlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFdmFsIGVycm9yIChldmFsdWF0aW5nIFwiJHsgZXJyLmV4cHJlc3Npb24gfVwiIGluIGNvbnRleHQgb2YgYmxvY2sgXCIkeyBlcnIuYmxvY2suJCQubmFtZSB9XCIpOmAsIGVycik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5iZWZvcmVSZWdpc3RlckJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtCbG9ja1JlZ2lzdGVySG9va30gaG9vayAtIEJsb2NrIHJlZ2lzdGVyIGhvb2suXG4gICAqL1xuICBzdGF0aWMgYmVmb3JlUmVnaXN0ZXJCbG9jayhob29rKSB7XG4gICAgYmxvY2tIb29rcy5wdXNoKGhvb2spO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlbW92ZUFycmF5RWxlbShibG9ja0hvb2tzLCBob29rKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmVmb3JlUmVnaXN0ZXJNaXhpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TWl4aW5SZWdpc3Rlckhvb2t9IGhvb2sgLSBNaXhpbiByZWdpc3RlciBob29rLlxuICAgKi9cbiAgc3RhdGljIGJlZm9yZVJlZ2lzdGVyTWl4aW4oaG9vaykge1xuICAgIG1peGluSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW1vdmVBcnJheUVsZW0obWl4aW5Ib29rcywgaG9vayk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge1RlbXBsYXRlfHR5cGVvZiBCbG9ja30gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBCbG9jayBvciB0ZW1wbGF0ZSBzdHJpbmcgb2YgaXQuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t8dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgQmxvY2sgb3IgdW5kZWZpbmVkIGlmIHRoZSBibG9jayBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgYmxvY2sgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGlzLlxuICAgKi9cbiAgc3RhdGljIGJsb2NrKG5hbWUsIFN1YmNsYXNzKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oU3ViY2xhc3MpICYmICFpc0luc3RhbmNlT2YoQmxvY2ssIFN1YmNsYXNzKSkge1xuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBTdWJjbGFzcztcblxuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICAgICAgdGhpczo6Y29uc3RydWN0b3Iob3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiBpc0FycmF5KFN1YmNsYXNzKSkge1xuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgICAgc3RhdGljIHRlbXBsYXRlID0ge1xuICAgICAgICAgIHZhcnM6IFtdLFxuICAgICAgICAgIHZhbHVlOiBTdWJjbGFzc1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU3ViY2xhc3MpICYmIFN1YmNsYXNzLnZhcnMgJiYgU3ViY2xhc3MudmFsdWUpIHtcbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IFN1YmNsYXNzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU3ViY2xhc3MpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEJsb2NrIG11c3QgYmUgYSBzdHJpbmcgKHJlcHJlc2VudGluZyBhIGJsb2NrIHRlbXBsYXRlKSwgYSBmdW5jdGlvbiBvciBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBCbG9jayBjbGFzcyAobmFtZTogXCIkeyBuYW1lIH1cIikgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc0luc3RhbmNlT2YoQmxvY2ssIFN1YmNsYXNzKSkge1xuICAgICAgZXh0ZW5kQmxvY2soU3ViY2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChyb290QmxvY2tzW25hbWVdKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIGJsb2NrIGlzIGEgYnVpbHQtaW4gYmxvY2sgc28gdGhlIGJsb2NrIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFUQUdfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5hbWUgXCIkeyBuYW1lIH1cIiBpcyBub3QgYWxsb3dlZCBmb3IgYmxvY2tzIHNvIHRoZSBibG9jayB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5ibG9jaylgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ19ibG9ja3MnKSkge1xuICAgICAgdGhpcy5fYmxvY2tzID0gY3JlYXRlKGdldFByb3RvKHRoaXMpLl9ibG9ja3MpO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ2RlZmF1bHRMb2NhbHMnKSkge1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEFyZ3MnKSkge1xuICAgICAgdGhpcy5kZWZhdWx0QXJncyA9IGNyZWF0ZShudWxsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgU3ViY2xhc3MgPSBibG9ja0hvb2tzLnJlZHVjZSgocmV0dXJuVmFsdWUsIGhvb2spID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJldHVyblZhbHVlID0gaG9vayhyZXR1cm5WYWx1ZSwgbmFtZSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZihCbG9jaywgY3VycmVudFJldHVyblZhbHVlKVxuICAgICAgICAgID8gY3VycmVudFJldHVyblZhbHVlXG4gICAgICAgICAgOiByZXR1cm5WYWx1ZTtcbiAgICAgIH0sIFN1YmNsYXNzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuY2F1Z2h0IGVycm9yIGluIFwiYmVmb3JlUmVnaXN0ZXJCbG9ja1wiIGhvb2s6JywgZXJyKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB2YXJzLFxuICAgICAgdmFsdWVcbiAgICB9ID0gU3ViY2xhc3MudGVtcGxhdGU7XG5cbiAgICBTdWJjbGFzcy5faHRtbCA9IHZhbHVlO1xuICAgIFN1YmNsYXNzLl92YXJzID0gdmFycztcblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShTdWJjbGFzcywgJ2RlZmF1bHRBcmdzJykpIHtcbiAgICAgIHNldFByb3RvKFN1YmNsYXNzLmRlZmF1bHRBcmdzLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ibG9ja3NbbmFtZV0gPSBTdWJjbGFzcztcblxuICAgIHJldHVybiBTdWJjbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLm1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge3R5cGVvZiBNaXhpbnxBZnRlclVwZGF0ZX0gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBNaXhpbiBvciBBZnRlclVwZGF0ZSBjYWxsYmFjay5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbnx1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBCbG9jayBvciB1bmRlZmluZWQgaWYgdGhlIGJsb2NrIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBtaXhpbiBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgbWl4aW4obmFtZSwgU3ViY2xhc3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgIWlzSW5zdGFuY2VPZihNaXhpbiwgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zdCBhZnRlclVwZGF0ZSA9IFN1YmNsYXNzO1xuXG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICAgICAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICB0aGlzOjphZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNJbnN0YW5jZU9mKE1peGluLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgY2xhc3MgZG9lcyBub3QgZXh0ZW5kIE1peGluIGFuZCB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyb290TWl4aW5zW25hbWVdKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIG1peGluIGlzIGEgYnVpbHQtaW4gbWl4aW4gc28gdGhlIG1peGluIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLm1peGluKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFBVFRSX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIG1peGlucyBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdfbWl4aW5zJykpIHtcbiAgICAgIHRoaXMuX21peGlucyA9IGNyZWF0ZShnZXRQcm90byh0aGlzKS5fbWl4aW5zKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgU3ViY2xhc3MgPSBtaXhpbkhvb2tzLnJlZHVjZSgocmV0dXJuVmFsdWUsIGhvb2spID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJldHVyblZhbHVlID0gaG9vayhyZXR1cm5WYWx1ZSwgbmFtZSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgY3VycmVudFJldHVyblZhbHVlKVxuICAgICAgICAgID8gY3VycmVudFJldHVyblZhbHVlXG4gICAgICAgICAgOiByZXR1cm5WYWx1ZTtcbiAgICAgIH0sIFN1YmNsYXNzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuY2F1Z2h0IGVycm9yIGluIFwiYmVmb3JlUmVnaXN0ZXJNaXhpblwiIGhvb2s6JywgZXJyKTtcbiAgICB9XG5cbiAgICBTdWJjbGFzcy5fbWF0Y2ggPSBjb25zdHJ1Y3RNaXhpblJlZ0V4cChuYW1lKTtcblxuICAgIHRoaXMuX21peGluc1tuYW1lXSA9IFN1YmNsYXNzO1xuXG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBibG9jay5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IGJsb2NrLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBibG9ja3MgaW50byBhbm90aGVyIGJsb2Nrcy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIGJsb2NrIHdpdGggYSBuZXcgb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2PjEyMzwvZGl2Pic7XG4gICAqIH1cbiAgICpcbiAgICogTXlCbG9jay53cmFwKChCbG9jaykgPT4ge1xuICAgKiAgIHJldHVybiBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICogICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGA8c2VjdGlvbiBjbGFzcz1cIndyYXBwZXJcIj4keyBCbG9jay50ZW1wbGF0ZSB9PC9zZWN0aW9uPmA7XG4gICAqXG4gICAqICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAqICAgICAgIHN1cGVyKG9wdHMpO1xuICAgKlxuICAgKiAgICAgICB0aGlzLmFkZGl0aW9uYWxWYXIgPSAnYWRkaXRpb25hbCc7XG4gICAqICAgICB9XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqL1xuICBzdGF0aWMgd3JhcCguLi53cmFwcGVycykge1xuICAgIHJldHVybiB3cmFwcGVycy5yZWR1Y2Uod3JhcEJsb2NrLCB0aGlzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYXJnczogb3JpZ2luYWxBcmdzLFxuICAgICAgZEJsb2NrTmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldFByb3RvKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNoaWxkcmVuQmxvY2tzID0gW107XG4gICAgY29uc3QgbWl4aW5zID0gW107XG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0Jsb2NrfSBCbG9jayMkXG4gICAgICAgKiBAdHlwZSB7QmxvY2t9XG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKiBAZGVzY3JpcHRpb24gVGhpcy5cbiAgICAgICAqL1xuICAgICAgJDogdGhpcyxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrIyQkXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFyZ3MgLSBQcml2YXRlIGFyZ3Mgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBhcmdzQ2hpbGRyZW4gLSBCbG9jayBhcmdzIGNoaWxkcmVuLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja1tdfSBjaGlsZHJlbiAtIENoaWxkIGJsb2Nrcy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7TWl4aW5bXX0gbWl4aW5zIC0gQ2hpbGQgbWl4aW5zLlxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBwYXJlbnRFbGVtIC0gUGFyZW50IGVsZW1lbnQuXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IGNvbnRlbnQgLSBDb250ZW50IGVsZW1lbnRzLlxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnbG9iYWxzIC0gUHJpdmF0ZSBnbG9iYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGxvY2FscyAtIFByaXZhdGUgbG9jYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gd2F0Y2hlcnNUb1JlbW92ZSAtIFdhdGNoZXJzIHRvIHJlbW92ZSBiZWZvcmUgcmVtb3ZpbmcgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrczogW10sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgY29udGVudDogbmV3IEVsZW0oKSxcbiAgICAgICAgbnM6IGNvbnN0cnVjdG9yLFxuICAgICAgICBhcmdzQ2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5CbG9ja3MsXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgcHJldkJsb2NrLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBpc1JlbW92ZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKGZ1bmMsIG9uQ2hhbmdlLCB0YXJnZXRCbG9jaywgZm9yREVsZW1lbnRzLCBmb3JESXRlbSwgZm9yREVhY2gpID0+IHtcbiAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvckRFbGVtZW50cyA9ICEhZm9yREVsZW1lbnRzO1xuICAgICAgICAgIGZvckRJdGVtID0gISFmb3JESXRlbTtcblxuICAgICAgICAgIGNvbnN0IHNjb3BlID0gKG5hbWUgPT09ICcjZC1pdGVtJyAmJiAhZm9yREl0ZW0pIHx8IGZvckRFYWNoXG4gICAgICAgICAgICA/IChmb3JERWFjaCB8fCB0aGlzKS4kJC5zY29wZVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgd2F0Y2hlcnNUb1JlbW92ZSB9ID0gdGFyZ2V0QmxvY2sgPyB0YXJnZXRCbG9jay4kJCA6IHt9O1xuICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlRmxhZyA9ICEhb25DaGFuZ2U7XG5cbiAgICAgICAgICBjb25zdCBldmFsdWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChvbkNoYW5nZUZsYWcpIHtcbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBnZXR0aW5nID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoc2NvcGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyci5leHByZXNzaW9uID0gZnVuYy5leHByZXNzaW9uO1xuICAgICAgICAgICAgICBlcnIub3JpZ2luYWwgPSBmdW5jLm9yaWdpbmFsO1xuICAgICAgICAgICAgICBlcnIuYmxvY2sgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5vbkV2YWxFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuY2F1Z2h0IGVycm9yIGluIG9uRXZhbEVycm9yOicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2VGbGFnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2F0Y2hlcnMgPSBbXTtcblxuICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkoZ2V0dGluZywgKHdhdGNoZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc3VsdCA9IGV2YWx1YXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHQgIT09IHJlc3VsdCAmJiAhdGFyZ2V0QmxvY2suJCQuaXNSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld1Jlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhdGNoZXJCbG9jayA9IHtcbiAgICAgICAgICAgICAgICAgIGZvckRFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB3YXRjaGVyLm9uUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KGxvY2FsV2F0Y2hlcnMsICh3YXRjaGVyQmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgfSA9IHdhdGNoZXJCbG9jaztcblxuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnNUb1JlbW92ZSwgd2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHdhdGNoZXJzLCB3YXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsb2NhbFdhdGNoZXJzLnB1c2god2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLnB1c2god2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBldmFsTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBnZXR0aW5nID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChpc1BhcmVudFNpZ25hbCkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuaXNSZW1vdmVkID0gdHJ1ZTtcblxuICAgICAgICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xuXG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuQmxvY2tzLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcblxuICAgICAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlUmVtb3ZlOmAsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgcGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5jaGlsZHJlbiwgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jb250ZW50LnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRDb250ZW50OiAoY29udGVudFRvQWRkLCBub3RSZWN1cnNpdmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuJCQuY29udGVudC5pbmRleE9mKGNvbnRlbnRUb0FkZFswXS5wcmV2aW91c1NpYmxpbmcpICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy4kJC5jb250ZW50ID0gY29udGVudFRvQWRkLmFkZCh0aGlzLiQkLmNvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKGNvbnRlbnRUb0FkZCwgdGhpcy4kJC5jb250ZW50LnNsaWNlKGluZGV4KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgIW5vdFJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvQWRkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVDb250ZW50OiAoY29udGVudFRvTW92ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuJCQuY29udGVudC5pbmRleE9mKGNvbnRlbnRUb01vdmVbMF0pO1xuICAgICAgICAgIGNvbnN0IGluZGV4VG9QdXQgPSB0aGlzLiQkLmNvbnRlbnQuaW5kZXhPZihhZnRlclswXSkgKyAxO1xuXG4gICAgICAgICAgaWYgKGluZGV4VG9QdXQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuJCQuY29udGVudCA9IGNvbnRlbnRUb01vdmUuYWRkKFxuICAgICAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGluZGV4VG9QdXQpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuY29udGVudCA9IHRoaXMuJCQuY29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgLmFkZChcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIHRoaXMuJCQuY29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgdGhpcy4kJC5jb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuY29udGVudCA9IHRoaXMuJCQuY29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy4kJC5jb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgsIGluZGV4VG9QdXQpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUb01vdmUsXG4gICAgICAgICAgICAgICAgdGhpcy4kJC5jb250ZW50LnNsaWNlKGluZGV4VG9QdXQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb01vdmUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNvbnRlbnQ6IChjb250ZW50VG9SZW1vdmUpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQuZmlsdGVyKChlbGVtKSA9PiAoXG4gICAgICAgICAgICBjb250ZW50VG9SZW1vdmUuaW5kZXhPZihlbGVtKSA9PT0gLTFcbiAgICAgICAgICApKTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50VG9SZW1vdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0SW5TdGFydE9mSXQ6IChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgbGV0IGFmdGVyID0gYWZ0ZXJFbGVtO1xuXG4gICAgICAgICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHBhcmVudC4kJDtcblxuICAgICAgICAgICAgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgICBsZXQgbm90UmVjdXJzaXZlO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgICAgICAgbm90UmVjdXJzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgICAgICBub3RSZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIG5vdFJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50LiQkLmluc2VydEluU3RhcnRPZkl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICB0aGlzLiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEFmdGVySXQ6IChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgbGV0IGFmdGVyID0gYWZ0ZXJFbGVtO1xuICAgICAgICAgIGxldCB0cnlUb0FkZE9yTW92ZTtcblxuICAgICAgICAgIGlmICh0aGlzLiQkLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuJCQuY29udGVudC5lbGVtKC0xKTtcbiAgICAgICAgICAgIHRyeVRvQWRkT3JNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihhZnRlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICB0cnlUb0FkZE9yTW92ZSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50LiQkLmluc2VydEluU3RhcnRPZkl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgdHJ5VG9BZGRPck1vdmUpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZnRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXRlcmF0ZU9iamVjdChjb25zdHJ1Y3Rvci5kZWZhdWx0TG9jYWxzLCAodmFsdWUsIHZhcmlhYmxlKSA9PiB7XG4gICAgICB0aGlzW3ZhcmlhYmxlXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGl0ZXJhdGVBcnJheShjb25zdHJ1Y3Rvci5fdmFycywgKHZhcmlhYmxlKSA9PiB7XG4gICAgICB0aGlzW3ZhcmlhYmxlXSA9IHRoaXNbdmFyaWFibGVdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJnc09iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgYXJncyA9IGNyZWF0ZShjb25zdHJ1Y3Rvci5kZWZhdWx0QXJncyB8fCBudWxsKTtcbiAgICBsZXQgd2FzRFJlc3Q7XG5cbiAgICBpdGVyYXRlT2JqZWN0KG9yaWdpbmFsQXJncywgKHZhbHVlLCBhcmcpID0+IHtcbiAgICAgIGNvbnN0IGlzRFJlc3QgPSBEX1JFU1RfUkVHRVgudGVzdChhcmcpO1xuICAgICAgY29uc3QgbG9jYWxBcmdzID0gaXNEUmVzdCB8fCB3YXNEUmVzdFxuICAgICAgICA/IGNyZWF0ZShhcmdzKVxuICAgICAgICA6IGFyZ3M7XG5cbiAgICAgIGFyZ3MgPSBsb2NhbEFyZ3M7XG5cbiAgICAgIGlmIChpc0RSZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3RBcmdzID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGl0ZXJhdGVPYmplY3QobG9jYWxBcmdzLCBjbGVhblByb3BlcnR5KTtcbiAgICAgICAgICBhc3NpZ24obG9jYWxBcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyh2YWx1ZSkpO1xuICAgICAgICAgIGNhbGN1bGF0ZUFyZ3MoYXJncywgYXJnc09iamVjdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXJncywgdHJhbnNmb3JtUmVzdEFyZ3MocmVzdEFyZ3MpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNERWxlbWVudHMgPSBuYW1lID09PSAnZC1lbGVtZW50cyc7XG4gICAgICBjb25zdCBmb3JERWxlbWVudHMgPSBpc0RFbGVtZW50cyAmJiBhcmcgPT09ICd2YWx1ZSc7XG5cbiAgICAgIHdhc0RSZXN0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChuYW1lICE9PSAnZC1lYWNoJyB8fCBhcmcgIT09ICd1aWQnKSB7XG4gICAgICAgIHZhbHVlID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxvY2FsQXJnc1thcmddID0gdmFsdWU7XG4gICAgICAgICAgY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KTtcbiAgICAgICAgfSwgdGhpcywgZm9yREVsZW1lbnRzLCBpc0RFbGVtZW50cyAmJiBwYXJlbnRCbG9jay4kJC5uYW1lID09PSAnI2QtaXRlbScpO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEFyZ3NbYXJnXSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjYXJnc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgYXJnczogYXJnc09iamVjdCxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrI2dsb2JhbHNcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGdsb2JhbHM6IGNyZWF0ZShcbiAgICAgICAgcGFyZW50U2NvcGVcbiAgICAgICAgICA/IHBhcmVudFNjb3BlLmdsb2JhbHNcbiAgICAgICAgICA6IG51bGxcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7QmxvY2t8dW5kZWZpbmVkfSBCbG9jayNwYXJlbnRTY29wZVxuICAgICAgICogQHR5cGUge0Jsb2NrfHVuZGVmaW5lZH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcGFyZW50U2NvcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7QmxvY2t8dW5kZWZpbmVkfSBCbG9jayNwYXJlbnRUZW1wbGF0ZVxuICAgICAgICogQHR5cGUge0Jsb2NrfHVuZGVmaW5lZH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9KTtcblxuICAgIGNhbGN1bGF0ZUFyZ3MoYXJncywgYXJnc09iamVjdCk7XG5cbiAgICBpZiAocGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3RcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGNvbnN0cnVjdGlvbiAoaW5jbHVkaW5nIGFsbCBzY29wZXMpXG4gICAqIGJ1dCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBibG9jayBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyUmVuZGVyXG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICovXG4gIGFmdGVyUmVuZGVyKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNiZWZvcmVSZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGJlZm9yZSB0aGUgYmxvY2sgcmVtb3ZhbC5cbiAgICovXG4gIGJlZm9yZVJlbW92ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0Q29udGVudFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBjb250ZW50cyBvZiB0aGUgYmxvY2suXG4gICAqL1xuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLiQkLmNvbnRlbnQuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlQW5kV2F0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gY2FsbGJhY2sgLSBDYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGlvbiByZXN1bHQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiBpbiBjb250ZXh0IG9mIHRoZSBibG9jayBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGVBbmRXYXRjaChmdW5jLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLiQkLmV2YWx1YXRlKGZ1bmMsIGNhbGxiYWNrLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI3dhdGNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4oJ2FyZ3MnfCdnbG9iYWxzJ3xTdHJpbmcpfSBbdmFyc10gLSBWYXJzIHRvIHdhdGNoIChhcmdzLCBnbG9iYWxzIG9yIGxvY2FscykuXG4gICAqIElmIG5vIHNwZWNpZmllZCBhbGwgbG9jYWxzLCBhcmdzIGFuZCBnbG9iYWxzIGFyZSB0byBiZSB3YXRjaGVkLlxuICAgKiBJZiB0aGUgJ2FyZ3MnIHN0cmluZyBhbGwgYXJncyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogSWYgdGhlICdnbG9iYWxzJyBzdHJpbmcgYWxsIGdsb2JhbHMgYXJlIHRvIGJlIHdhdGNoZWQuXG4gICAqIEBwYXJhbSB7VmFyc1dhdGNoZXJ9IHdhdGNoZXIgLSBDYWxsZWQgd2hlbiB3YXRjaGVkIHZhcnMgYXJlIGNoYW5nZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdhdGNoaW5nIGZvciB2YXJzLiBJZiBubyB2YXJzIHBhc3NlZCBpbiBhcmd1bWVudHNcbiAgICogYWxsIHZhcnMgYXJlIHRvIGJlIHdhdGNoZWQuIElmIHRoZSAnYXJncycgc3RyaW5nIGlzIGluIHRoZSBhcmd1bWVudHMgYWxsIGFyZ3MgYXJlIHRvIGJlIHdhdGNoZWQuXG4gICAqIElmIHRoZSAnZ2xvYmFscycgc3RyaW5nIGlzIGluIHRoZSBhcmd1bWVudHMgYWxsIGdsb2JhbHMgYXJlIHRvIGJlIHdhdGNoZWQuXG4gICAqIE90aGVyd2lzZSBzcGVjaWZpZWQgdmFycyB3aWxsIGJlIHdhdGNoZWQuXG4gICAqIFdhdGNoZXJzIHNob3VsZCBub3QgYmUgcHV0IGluc2lkZSB0aGUgY29uc3RydWN0b3IuIEl0IGlzIGNvbnNpZGVyZWQgYmVzdFxuICAgKiBwcmFjdGljZSB0byBkbyBpdCBpbnNpZGUgdGhlIHtAbGluayBCbG9jayNhZnRlckNvbnN0cnVjdH0gbWV0aG9kLlxuICAgKiBOb3RlIHRoYXQgdGhlc2UgZXhwcmVzc2lvbnMgKHZhcnMsIGkuZS4gXCJhcmdzLmFyZ1wiKSBhcmUgbm90IHRvIGJlXG4gICAqIGV2YWx1YXRlZCBzbyB5b3UgY2Fubm90IHB1dCB0aGVyZSB0aGluZ3MgbGlrZSBcImFbYl1cIiBvciBhbnkganMgY29kZSxcbiAgICogb25seSBleHByZXNzaW9ucyBsaWtlIFwiYVwiLCBcImJcIiwgXCJhcmdzLmFcIiwgXCJhcmdzLmJcIiBhbmQgXCJnbG9iYWxzLmFcIiwgXCJnbG9iYWxzLmJcIi5cbiAgICogQWxzbyBub3RlIHRoYXQgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgdmFyIHRoYXQgYXJlIGNoYW5nZWQgYXQgb25jZSAoc3luY2hyb25vdXNseSlcbiAgICogdGhlIHdhdGNoZXIgaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAgICogTm90ZSB0aGF0IHRoZSB3YXRjaGVyIGlzIGV4ZWN1dGVkIHJpZ2h0IGF3YXkgYmVjYXVzZSBpbiBtb3N0IGNhc2VzXG4gICAqIHRoaXMgYmVoYXZpb3VyIGlzIHZlcnkgY29udmVuaWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2xhc3MgTXlCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdiAvPic7XG4gICAqXG4gICAqICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAqICAgICB0aGlzLndhdGNoKCdhJywgKCkgPT4ge30pO1xuICAgKiAgICAgdGhpcy53YXRjaCgnYXJncy5hJywgJ2dsb2JhbHMucicsICgpID0+IHt9KTtcbiAgICogICAgIHRoaXMud2F0Y2goKCkgPT4ge30pO1xuICAgKiAgIH1cbiAgICogfVxuICAgKi9cbiAgd2F0Y2goLi4udmFycykge1xuICAgIGNvbnN0IG9sZFdhdGNoZXIgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKG9sZFdhdGNoZXIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBsYXN0IGFyZ3VtZW50ICh3YXRjaGVyKSB3YXNuJ3Qgc3BlY2lmaWVkICgkeyB0aGlzLiQkLm5hbWUgfSN3YXRjaClgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHdhdGNoZXIgPSAoKSA9PiB7XG4gICAgICBvbGRXYXRjaGVyKCk7XG4gICAgfTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3YXRjaEZvckFsbExvY2Fscyh0aGlzLCB3YXRjaGVyKTtcbiAgICAgIHdhdGNoRm9yQWxsQXJncyh0aGlzLCB3YXRjaGVyKTtcbiAgICAgIHdhdGNoRm9yQWxsR2xvYmFscyh0aGlzLCB3YXRjaGVyKTtcblxuICAgICAgb2xkV2F0Y2hlcigpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKHZhcmlhYmxlKSA9PiB7XG4gICAgICBpZiAodmFyaWFibGUgPT09IG9sZFdhdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXJpYWJsZSA9IGAkeyB2YXJpYWJsZSB9YDtcblxuICAgICAgaWYgKHZhcmlhYmxlID09PSAnJCcpIHtcbiAgICAgICAgcmV0dXJuIHdhdGNoRm9yQWxsTG9jYWxzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFyaWFibGUgPT09ICdhcmdzJykge1xuICAgICAgICByZXR1cm4gd2F0Y2hGb3JBbGxBcmdzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFyaWFibGUgPT09ICdnbG9iYWxzJykge1xuICAgICAgICByZXR1cm4gd2F0Y2hGb3JBbGxHbG9iYWxzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoV0FUQ0hFRF9BUkdfUFJFRklYX1JFR0VYLnRlc3QodmFyaWFibGUpKSB7XG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUucmVwbGFjZShXQVRDSEVEX0FSR19QUkVGSVhfUkVHRVgsICcnKTtcblxuICAgICAgICBpZiAoIXRoaXMuJCQuYXJnc1t2YXJpYWJsZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiQkLmFyZ3NbdmFyaWFibGVdLndhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChXQVRDSEVEX0dMT0JBTF9QUkVGSVhfUkVHRVgudGVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5yZXBsYWNlKFdBVENIRURfR0xPQkFMX1BSRUZJWF9SRUdFWCwgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy4kJC5nbG9iYWxzW3ZhcmlhYmxlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgd2F0Y2hlcnMgfSA9IHRoaXMuJCQuZ2xvYmFsc1t2YXJpYWJsZV07XG5cbiAgICAgICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuICAgICAgICB0aGlzLiQkLndhdGNoZXJzVG9SZW1vdmUucHVzaCh7XG4gICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy4kJC5sb2NhbHNbdmFyaWFibGVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kJC5sb2NhbHNbdmFyaWFibGVdLndhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcbiAgICB9KTtcblxuICAgIG9sZFdhdGNoZXIoKTtcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhCbG9jaywgJ0Jsb2NrJyk7XG5zZXRQcm90byhCbG9jay5wcm90b3R5cGUsIG51bGwpO1xuXG5yZWdpc3RlckJ1aWx0SW5zKEJsb2Nrcywgcm9vdEJsb2NrcywgQmxvY2spO1xuXG5jb25zdCBibG9ja3MgPSBCbG9jay5fYmxvY2tzO1xuXG5jbGFzcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTWl4aW4ud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBtaXhpbi5cbiAgICogQHJldHVybnMge01peGlufSBOZXcgbWl4aW4uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIG1peGlucy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIG1peGluIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gd3JhcHBlcnMucmVkdWNlKHdyYXBNaXhpbiwgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgY29tbWVudCxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCB3YXRjaGVycyA9IFtdO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAkJDoge1xuICAgICAgICBuYW1lLFxuICAgICAgICBfdmFsdWU6IHZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaXNEeW5hbWljOiBkeW5hbWljLFxuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICB3YXRjaGVycyxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgZXZhbHVhdGU6ICh3YXRjaGVyKSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaXNEeW5hbWljLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBfdmFsdWVcbiAgICAgICAgICB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpc0R5bmFtaWNcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoX3ZhbHVlKTtcblxuICAgICAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgICAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKGlzUGFyZW50U2lnbmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheUVsZW0ocGFyZW50QmxvY2suJCQubWl4aW5zLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbiAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgdGhpcy5wYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5ub2RlID0gZWxlbVswXTtcblxuICAgIGlmIChwYXJlbnRCbG9jaykge1xuICAgICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7fVxuXG4gIGJlZm9yZVJlbW92ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVBbmRXYXRjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gY2FsbGJhY2sgLSBDYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgbWl4aW4gdmFsdWUgaXMgY2hhbmdlZC5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIHRoZSBtaXhpbiB2YWx1ZSBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGVBbmRXYXRjaChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLiQkLmV2YWx1YXRlKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlT25jZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgb25jZS5cbiAgICovXG4gIGV2YWx1YXRlT25jZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZSgpO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKE1peGluLCAnTWl4aW4nKTtcblxucmVnaXN0ZXJCdWlsdElucyhNaXhpbnMsIHJvb3RNaXhpbnMsIE1peGluKTtcblxuY29uc3QgbWl4aW5zID0gQmxvY2suX21peGlucztcblxuZnVuY3Rpb24gaW5pdEFwcChodG1sLCBub2RlKSB7XG4gIGNvbnN0IHBhcmVudEVsZW0gPSBuZXcgRWxlbShub2RlKS5lbGVtKDApO1xuXG4gIGlmICghcGFyZW50RWxlbS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuICB9XG5cbiAgaWYgKHBhcmVudEVsZW0ucHJvcCgnRHdheW5lUm9vdEJsb2NrJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGFscmVhZHkgZXhpc3RzIGEgRHdheW5lIGFwcCBpbnNpZGUgdGhlIGdpdmVuIGVsZW1lbnQhIChpbml0QXBwKScpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoaHRtbCkpIHtcbiAgICBodG1sID0ge1xuICAgICAgdmFyczogW10sXG4gICAgICB2YWx1ZTogaHRtbFxuICAgIH07XG4gIH1cblxuICBjbGFzcyBSb290QmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAgc3RhdGljIF92YXJzID0gaHRtbC52YXJzO1xuICAgIHN0YXRpYyBfaHRtbCA9IGh0bWwudmFsdWVcbiAgfVxuXG4gIGNvbnN0IGJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgIG5vZGU6IHtcbiAgICAgIG5hbWU6ICcjUm9vdEJsb2NrJ1xuICAgIH0sXG4gICAgQ29uc3RydWN0b3I6IFJvb3RCbG9jayxcbiAgICBwYXJlbnQ6IHBhcmVudEVsZW0sXG4gICAgcGFyZW50RWxlbVxuICB9KTtcblxuICBwYXJlbnRFbGVtXG4gICAgLnByb3AoJ0R3YXluZVJvb3RCbG9jaycsIGJsb2NrKVxuICAgIC5hdHRyKCdkd2F5bmUtcm9vdCcsICcnKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQXBwKG5vZGUpIHtcbiAgY29uc3QgZWxlbSA9IG5ldyBFbGVtKG5vZGUpO1xuXG4gIGlmICghZWxlbS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhcHAgZnJvbSB3YXMgZ2l2ZW4hIChyZW1vdmVBcHApJyk7XG4gIH1cblxuICBjb25zdCB7IER3YXluZVJvb3RCbG9jayB9ID0gZWxlbVswXTtcblxuICBpZiAoIUR3YXluZVJvb3RCbG9jaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYXBwIHJlZ2lzdGVyZWQgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAocmVtb3ZlQXBwKScpO1xuICB9XG5cbiAgRHdheW5lUm9vdEJsb2NrLiQkLnJlbW92ZSgpO1xuICBlbGVtLnJlbW92ZUF0dHIoJ2R3YXluZS1yb290Jyk7XG5cbiAgZGVsZXRlIGVsZW1bMF0uRHdheW5lUm9vdEJsb2NrO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckJ1aWx0SW5zKHNldCwgc2NvcGUsIHByb3RvKSB7XG4gIGl0ZXJhdGVPYmplY3Qoc2V0LCAocmVnaXN0ZXIpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVcbiAgICB9ID0gcmVnaXN0ZXIocHJvdG8sIGNyZWF0ZUJsb2NrLCBCbG9jayk7XG5cbiAgICBpZiAocHJvdG8gPT09IEJsb2NrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhcnMsXG4gICAgICAgIHZhbHVlOiBodG1sXG4gICAgICB9ID0gdmFsdWUudGVtcGxhdGU7XG5cbiAgICAgIHZhbHVlLl9odG1sID0gaHRtbDtcbiAgICAgIHZhbHVlLl92YXJzID0gdmFycztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUuX21hdGNoID0gY29uc3RydWN0TWl4aW5SZWdFeHAobmFtZSk7XG4gICAgfVxuXG4gICAgc2NvcGVbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHsgbm9kZSwgQ29uc3RydWN0b3IsIHBhcmVudCwgcGFyZW50RWxlbSwgcGFyZW50QmxvY2ssIHBhcmVudFNjb3BlLCBwYXJlbnRUZW1wbGF0ZSwgcHJldkJsb2NrIH0pIHtcbiAgY29uc3QgZG9jID0gbmV3IEVsZW0ocGFyZW50RWxlbVswXS5vd25lckRvY3VtZW50KTtcbiAgY29uc3QgZWxlbSA9IHBhcmVudEVsZW1bMF0ubmFtZXNwYWNlVVJJID09PSBTVkdfTlNcbiAgICA/IGRvYy5jcmVhdGUoJ3N2ZycpXG4gICAgOiBkb2M7XG4gIGNvbnN0IGxvY2FsQmxvY2tzID0gcGFyZW50U2NvcGUgPyBwYXJlbnRTY29wZS4kJC5ucy5fYmxvY2tzIDogYmxvY2tzO1xuICBjb25zdCBsb2NhbE1peGlucyA9IHBhcmVudFNjb3BlID8gcGFyZW50U2NvcGUuJCQubnMuX21peGlucyA6IG1peGlucztcbiAgbGV0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgZW1wdHlDaGlsZHJlbjtcbiAgbGV0IGFyZ3MgPSBub2RlLmF0dHJzID0gbm9kZS5hdHRycyB8fCBlbXB0eUF0dHJzO1xuICBsZXQgbmFtZSA9IG5vZGUubmFtZSB8fCAnVW5rbm93bkJsb2NrJztcbiAgbGV0IGNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IgfHwgKG5vZGUubmFtZSAmJiBsb2NhbEJsb2Nrc1tub2RlLm5hbWVdKTtcbiAgbGV0IGRCbG9ja01hdGNoO1xuICBsZXQgZEJsb2NrTmFtZTtcbiAgbGV0IGRCbG9ja0FyZ3M7XG4gIGxldCBkQmxvY2tDaGlsZHJlbjtcbiAgbGV0IGRFbGVtZW50c05hbWU7XG5cbiAgaWYgKG5hbWUgPT09ICdkLWJsb2NrJyAmJiBhcmdzLm5hbWUpIHtcbiAgICBuYW1lID0gJ2QtZWxlbWVudHMnO1xuICAgIGNvbnN0cnVjdG9yID0gbG9jYWxCbG9ja3NbbmFtZV07XG4gICAgZEVsZW1lbnRzTmFtZSA9IGFyZ3MubmFtZTtcbiAgICBkQmxvY2tBcmdzID0gYXJncztcbiAgICBkQmxvY2tDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZW1wdHlDaGlsZHJlbjtcblxuICAgIGRlbGV0ZSBhcmdzLm5hbWU7XG4gICAgYXJncyA9IHt9O1xuICB9IGVsc2UgaWYgKG5hbWUgPT09ICdkLWJsb2NrJyAmJiBoYXNPd25Qcm9wZXJ0eShhcmdzLCAnY29uc3RydWN0b3InKSkge1xuICAgIG5hbWUgPSAnVW5rbm93bkJsb2NrJztcbiAgICBjb25zdHJ1Y3RvciA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGFyZ3MuY29uc3RydWN0b3IpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29uc3RydWN0b3IpKSB7XG4gICAgICBkZWxldGUgYXJncy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmICgoZEJsb2NrTWF0Y2ggPSBuYW1lLm1hdGNoKE5BTUVEX0RfQkxPQ0tfUkVHRVgpKSB8fCBuYW1lID09PSAnZC1ibG9jaycpIHtcbiAgICBjb25zdHJ1Y3RvciA9IGJsb2Nrc1snZC1ibG9jayddO1xuICAgIGRCbG9ja05hbWUgPSBkQmxvY2tNYXRjaCA/IGRCbG9ja01hdGNoWzFdIDogbnVsbDtcbiAgfVxuXG4gIGxldCBibG9ja0luc3RhbmNlO1xuXG4gIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgIHRyeSB7XG4gICAgICBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgcHJldkJsb2NrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluIG5ldyAkeyBuYW1lIH06YCwgZXJyKTtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBub2RlO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW0uY3JlYXRlKG5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgYXR0cnMgPSBjcmVhdGUobnVsbCk7XG4gICAgbGV0IHdhc0RSZXN0O1xuICAgIGNvbnN0IG1peGluRGVmYXVsdE9wdHMgPSB7XG4gICAgICBlbGVtOiBlbGVtZW50LFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfTtcblxuICAgIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBpc0RSZXN0ID0gRF9SRVNUX1JFR0VYLnRlc3QoYXR0cik7XG4gICAgICBjb25zdCBsb2NhbEF0dHJzID0gaXNEUmVzdCB8fCB3YXNEUmVzdFxuICAgICAgICA/IGNyZWF0ZShhdHRycylcbiAgICAgICAgOiBhdHRycztcblxuICAgICAgYXR0cnMgPSBsb2NhbEF0dHJzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXR0cnMgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXR0cnMsIGNsZWFuUHJvcGVydHkpO1xuICAgICAgICAgICAgYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICAgICAgdmFsdWUsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICByZXN0QXR0cnMsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaCA9IG1peGluTWF0Y2gobG9jYWxNaXhpbnMsIGF0dHIpO1xuXG4gICAgICB3YXNEUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICAgIHR5cGU6ICdtaXhpbicsXG4gICAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAgIC4uLm1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICB0eXBlOiAnYXR0cicsXG4gICAgICAgIHZhbHVlOiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxjdWxhdGVBdHRycyhhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH0sIHBhcmVudEJsb2NrKVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGNyZWF0ZU1peGlucyA9IGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIHRydWUpO1xuXG4gICAgaWYgKG5hbWUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgIGVsZW1lbnQudGV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgIGxldCB0ZXh0ID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQudGV4dChgJHsgdmFsdWUgfWApO1xuICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICBpZiAoaXNOaWwodGV4dCkpIHtcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnRleHQoYCR7IHRleHQgfWApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgY29uc3QgcGFyZW50RWxlbSA9IG5hbWUgPT09ICd0ZW1wbGF0ZSdcbiAgICAgICAgPyBuZXcgRWxlbShlbGVtZW50WzBdLmNvbnRlbnQpXG4gICAgICAgIDogZWxlbWVudDtcbiAgICAgIGxldCBwcmV2QmxvY2s7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1BhcmVudEJsb2NrID0gcGFyZW50IGluc3RhbmNlb2YgQmxvY2s7XG5cbiAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgZWxlbWVudC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChlbGVtZW50LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTWl4aW5zKCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICAkJCxcbiAgICBhcmdzOiBBcmdzLFxuICAgIGdsb2JhbHMsXG4gICAgLi4ubG9jYWxzXG4gIH0gPSBibG9ja0luc3RhbmNlO1xuXG4gIGlmIChkQmxvY2tNYXRjaCB8fCBuYW1lID09PSAnZC1ibG9jaycpIHtcbiAgICBwYXJlbnRTY29wZS4kJC5kQmxvY2tzLnB1c2goYmxvY2tJbnN0YW5jZSk7XG4gIH1cblxuICBpZiAoZEJsb2NrQXJncykge1xuICAgIG5vZGUgPSB7XG4gICAgICBhdHRyczogZEJsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBkQmxvY2tDaGlsZHJlblxuICAgIH07XG4gICAgbm9kZS5uYW1lID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoZEVsZW1lbnRzTmFtZSwgKG5ld05hbWUpID0+IHtcbiAgICAgIG5vZGUubmFtZSA9IG5ld05hbWU7XG5cbiAgICAgIEFyZ3MudmFsdWUgPSBbbm9kZV07XG4gICAgfSwgYmxvY2tJbnN0YW5jZSwgdHJ1ZSk7XG5cbiAgICBBcmdzLnZhbHVlID0gW25vZGVdO1xuICAgIEFyZ3MucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgfVxuXG4gIGNvbnN0IGh0bWwgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IEFyZ3MudmFsdWUgfHwgW11cbiAgICA6IGNvbnN0cnVjdG9yLl9odG1sO1xuXG4gICQkLmFyZ3MgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoQXJncyk7XG4gICQkLmxvY2FscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShsb2NhbHMpO1xuICAkJC5nbG9iYWxzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGdsb2JhbHMsICdnbG9iYWxzJywgcGFyZW50U2NvcGUpO1xuXG4gIGlmIChuYW1lID09PSAnI2QtaXRlbScpIHtcbiAgICBjb25zdCBzY29wZVZhbHVlcyA9IHtcbiAgICAgIFtub2RlLml0ZW1OYW1lXTogbm9kZS5pdGVtLFxuICAgICAgW25vZGUuaW5kZXhOYW1lXTogbm9kZS5pbmRleFxuICAgIH07XG4gICAgY29uc3Qgc2NvcGUgPSBwYXJlbnRTY29wZS4kJC5uYW1lID09PSAnI2QtaXRlbSdcbiAgICAgID8gcGFyZW50U2NvcGUuJCQuc2NvcGVcbiAgICAgIDogcGFyZW50U2NvcGU7XG5cbiAgICAkJC5ucyA9IHBhcmVudFNjb3BlLiQkLm5zO1xuICAgICQkLnByaXZhdGVTY29wZSA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShzY29wZVZhbHVlcyk7XG4gICAgY29uc3RydWN0UHVibGljU2NvcGUoJCQuc2NvcGUgPSBjcmVhdGUoc2NvcGUpLCBzY29wZVZhbHVlcywgJCQucHJpdmF0ZVNjb3BlKTtcbiAgfVxuXG4gIGlmIChuYW1lID09PSAnZC1lYWNoJykge1xuICAgICQkLnNjb3BlID0gY3JlYXRlKHBhcmVudFNjb3BlLiQkLm5hbWUgPT09ICcjZC1pdGVtJyA/IHBhcmVudFNjb3BlLiQkLnNjb3BlIDogcGFyZW50U2NvcGUsIHtcbiAgICAgIFtBcmdzLml0ZW0gfHwgJyRpdGVtJ106IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW0FyZ3MuaW5kZXggfHwgJyRpbmRleCddOiB7XG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0UHVibGljU2NvcGUoQXJncywgQXJncywgJCQuYXJncyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGdsb2JhbHMsIGdsb2JhbHMsICQkLmdsb2JhbHMpO1xuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShibG9ja0luc3RhbmNlLCBsb2NhbHMsICQkLmxvY2Fscyk7XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyQ29uc3RydWN0KCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnN0cnVjdDpgLCBlcnIpO1xuICB9XG5cbiAgcHJldkJsb2NrID0gdW5kZWZpbmVkO1xuICBwYXJlbnRTY29wZSA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy5wYXJlbnRTY29wZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcbiAgcGFyZW50VGVtcGxhdGUgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IEFyZ3MucGFyZW50VGVtcGxhdGVcbiAgICA6IGJsb2NrSW5zdGFuY2U7XG5cbiAgaXRlcmF0ZUFycmF5KGh0bWwsIChjaGlsZCkgPT4ge1xuICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgcGFyZW50OiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrOiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0pO1xuICB9KTtcblxuICB0cnkge1xuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJSZW5kZXIoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyUmVuZGVyOmAsIGVycik7XG4gIH1cblxuICByZXR1cm4gYmxvY2tJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWl4aW4oeyBuYW1lLCBNaXhpbiwgZHluYW1pYywgdmFsdWUsIGFyZ3MsIGNvbW1lbnQsIGVsZW0sIHBhcmVudEJsb2NrLCBwYXJlbnRTY29wZSwgcGFyZW50VGVtcGxhdGUgfSkge1xuICBjb25zdCBtaXhpbiA9IG5ldyBNaXhpbih7XG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICBkeW5hbWljLFxuICAgIGFyZ3MsXG4gICAgY29tbWVudCxcbiAgICBlbGVtLFxuICAgIHBhcmVudEJsb2NrLFxuICAgIHBhcmVudFNjb3BlLFxuICAgIHBhcmVudFRlbXBsYXRlXG4gIH0pO1xuXG4gIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gbWl4aW4udmFsdWUgPSBtaXhpbi5ldmFsdWF0ZUFuZFdhdGNoKChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIG1peGluLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1peGluLmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtaXhpbi5hZnRlclVwZGF0ZSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbWl4aW47XG59XG5cbmZ1bmN0aW9uIGlzSW5zdGFuY2VPZihDbGFzcywgU3ViY2xhc3MpIHtcbiAgcmV0dXJuIENsYXNzOjppc1Byb3RvdHlwZU9mKFN1YmNsYXNzKSAmJiBDbGFzcy5wcm90b3R5cGU6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MucHJvdG90eXBlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSkge1xuICBpdGVyYXRlQXJyYXkod2F0Y2hlcnNUb1JlbW92ZSwgcmVtb3ZlV2F0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IGNyZWF0ZShcbiAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgID8gcGFyZW50U2NvcGUuJCQuZ2xvYmFsc1xuICAgICAgICA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IHtcbiAgICAgICAgdGVtcDogW10sXG4gICAgICAgIHBlcm06IFtdXG4gICAgICB9XG4gICAgfTtcbiAgfSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCBtYXBPYmplY3Qoc2NvcGVWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcbiAgICBjb25zdCB7IHdhdGNoZXJzIH0gPSBzY29wZTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKGdldHRpbmcuaW5kZXhPZih3YXRjaGVycy50ZW1wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGdldHRpbmcucHVzaCh3YXRjaGVycy50ZW1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gc2NvcGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRUZW1wV2F0Y2hlcnMgPSB3YXRjaGVycy50ZW1wLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc2NvcGUudmFsdWU7XG5cbiAgICAgICAgd2F0Y2hlcnMudGVtcCA9IFtdO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheShvbGRUZW1wV2F0Y2hlcnMsIHJlbW92ZVRlbXBXYXRjaGVyKTtcbiAgICAgICAgY2hhbmdlZC5wdXNoKHtcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB3YXMgPSBbXTtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgICAgIH0gPSBjaGFuZ2VkW2ldO1xuXG4gICAgICAgICAgICBpdGVyYXRlQXJyYXkoc2NvcGUud2F0Y2hlcnMucGVybSwgKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB3YXMuaW5kZXhPZih3YXRjaGVyKTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgd2FzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0ub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoYW5nZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWQgPSBudWxsO1xuXG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHdhcywgKHdhdGNoZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG9sZFZhbHVlXG4gICAgICAgICAgICB9ID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICB3YXRjaGVyKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hGb3JBbGxMb2NhbHMoYmxvY2ssIHdhdGNoZXIpIHtcbiAgaXRlcmF0ZU9iamVjdChibG9jay4kJC5sb2NhbHMsICh7IHdhdGNoZXJzIH0pID0+IHtcbiAgICB3YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXRjaEZvckFsbEdsb2JhbHMoYmxvY2ssIHdhdGNoZXIpIHtcbiAgY29uc3Qge1xuICAgIGdsb2JhbHMsXG4gICAgd2F0Y2hlcnNUb1JlbW92ZVxuICB9ID0gYmxvY2suJCQ7XG5cbiAgZm9yIChjb25zdCBnbG9iIGluIGdsb2JhbHMpIHtcbiAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgY29uc3Qgd2F0Y2hlcnMgPSBnbG9iYWxzW2dsb2JdLndhdGNoZXJzLnBlcm07XG5cbiAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgIHdhdGNoZXJzVG9SZW1vdmUucHVzaCh7XG4gICAgICB3YXRjaGVyLFxuICAgICAgd2F0Y2hlcnNcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXRjaEZvckFsbEFyZ3MoYmxvY2ssIHdhdGNoZXIpIHtcbiAgaXRlcmF0ZU9iamVjdChibG9jay4kJC5hcmdzLCAoeyB3YXRjaGVycyB9KSA9PiB7XG4gICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KSB7XG4gIGl0ZXJhdGVBcnJheShrZXlzKGFyZ3NPYmplY3QpLCAoYXJnKSA9PiB7XG4gICAgaWYgKCEoYXJnIGluIGFyZ3MpKSB7XG4gICAgICBhcmdzT2JqZWN0W2FyZ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcblxuICBmb3IgKGNvbnN0IGFyZyBpbiBhcmdzKSB7XG4gICAgYXJnc09iamVjdFthcmddID0gYXJnc1thcmddO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3RBcmdzKGFyZ3MpIHtcbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIGFkZEFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN0QXR0cnMoYXR0cnMsIG1peGlucywgbWl4aW5EZWZhdWx0T3B0cykge1xuICByZXR1cm4gY29sbGVjdEZyb21PYmplY3QoYXR0cnMsIChldmVudHVhbEF0dHJzLCB2YWx1ZSwgYXR0cikgPT4ge1xuICAgIGlmIChEX1JFU1RfUkVHRVgudGVzdChhdHRyKSkge1xuICAgICAgcmV0dXJuIGFzc2lnbihldmVudHVhbEF0dHJzLCB0cmFuc2Zvcm1SZXN0QXR0cnModmFsdWUsIG1peGlucywgbWl4aW5EZWZhdWx0T3B0cykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gbWl4aW5NYXRjaChtaXhpbnMsIGF0dHIpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudHVhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICB0eXBlOiAnbWl4aW4nLFxuICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgLi4ubWl4aW5EZWZhdWx0T3B0c1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50dWFsQXR0cnNbYXR0cl0gPSB7XG4gICAgICB0eXBlOiAnYXR0cicsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtaXhpbk1hdGNoKG1peGlucywgYXR0cikge1xuICBsZXQgbWF0Y2g7XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIG1peGlucykge1xuICAgIGNvbnN0IE1peGluID0gbWl4aW5zW25hbWVdO1xuICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSBhdHRyLm1hdGNoKE1peGluLl9tYXRjaCk7XG5cbiAgICBpZiAobG9jYWxNYXRjaCkge1xuICAgICAgY29uc3QgYXJnc01hdGNoID0gbG9jYWxNYXRjaFsxXTtcbiAgICAgIGxldCBhcmdzO1xuXG4gICAgICBpZiAoYXJnc01hdGNoID09PSAnJykge1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NNYXRjaCkge1xuICAgICAgICBhcmdzID0gYXJnc01hdGNoLnNwbGl0KENPTU1BX1JFR0VYKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNvbW1lbnQ6IGxvY2FsTWF0Y2hbMl0sXG4gICAgICAgIE1peGluLFxuICAgICAgICBuYW1lXG4gICAgICB9O1xuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBhdHRyc09iamVjdCwgZWxlbSwgZmlyc3RUaW1lKSB7XG4gIGl0ZXJhdGVPYmplY3QoYXR0cnNPYmplY3QsICh7IHR5cGUsIHZhbHVlIH0sIGF0dHIpID0+IHtcbiAgICBpZiAoIWF0dHJzW2F0dHJdKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLiQkLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgYXR0cnNPYmplY3RbYXR0cl07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBtaXhpbnMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0c1xuICAgIH0gPSBhdHRyc1thdHRyXTtcbiAgICBsZXQgbmV4dFR5cGU7XG4gICAgbGV0IG5leHREeW5hbWljO1xuICAgIGxldCBuZXh0VmFsdWU7XG5cbiAgICBpZiAoYXR0cnNPYmplY3RbYXR0cl0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZTogcHJldlR5cGUsXG4gICAgICAgIHZhbHVlOiBwcmV2VmFsdWVcbiAgICAgIH0gPSBhdHRyc09iamVjdFthdHRyXTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBpZiAocHJldlR5cGUgPT09ICdtaXhpbicpIHtcbiAgICAgICAgICBwcmV2VmFsdWUuJCQucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGVsZW0uYXR0cihhdHRyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1peGluID0gcHJldlZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWl4aW4uJCQuaXNEeW5hbWljID0gZHluYW1pYztcblxuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW1peGluLiQkLmV2YWx1YXRlZCAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtaXhpbi4kJC5wYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGR5bmFtaWNcbiAgICAgICAgICAgIH0gPSBhdHRyc1thdHRyXTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtaXhpbik7XG5cbiAgICAgICAgICBtaXhpbi4kJC5ldmFsdWF0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRWYWx1ZSA9IG1peGluO1xuICAgICAgfVxuXG4gICAgICBuZXh0VHlwZSA9IHR5cGU7XG4gICAgICBuZXh0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcblxuICAgICAgICBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkTWl4aW4gPSAoKSA9PiB7XG4gICAgICAgICAgb3B0cy5keW5hbWljID0gZHluYW1pYztcblxuICAgICAgICAgIGNvbnN0IG1peGluID0gY3JlYXRlTWl4aW4ob3B0cyk7XG5cbiAgICAgICAgICBpZiAoIWR5bmFtaWMgJiYgb3B0cy5NaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBvcHRzO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZHluYW1pY1xuICAgICAgICAgICAgICB9ID0gYXR0cnNbYXR0cl07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtaXhpbik7XG5cbiAgICAgICAgICAgIG1peGluLiQkLmV2YWx1YXRlZCA9IHRydWU7XG4gICAgICAgICAgICBtaXhpbi4kJC52YWx1ZSA9IGZpcnN0VmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZHluYW1pYyxcbiAgICAgICAgICAgICAgdmFsdWU6IG1peGluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgbWl4aW5zLnB1c2goYnVpbGRNaXhpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRNaXhpbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRUeXBlID0gdHlwZTtcbiAgICAgIG5leHREeW5hbWljID0gZHluYW1pYztcbiAgICB9XG5cbiAgICBhdHRyc09iamVjdFthdHRyXSA9IHtcbiAgICAgIHR5cGU6IG5leHRUeXBlLFxuICAgICAgZHluYW1pYzogbmV4dER5bmFtaWMsXG4gICAgICB2YWx1ZTogbmV4dFZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChmaXJzdFRpbWUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KG1peGlucywgKGJ1aWxkTWl4aW4pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgb3B0c1xuICAgICAgICB9ID0gYnVpbGRNaXhpbigpO1xuXG4gICAgICAgIGF0dHJzT2JqZWN0W2F0dHJdID0gb3B0cztcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIHZhbHVlKSB7XG4gIGNvbnN0IG9sZFZhbHVlID0gbWl4aW4uJCQudmFsdWU7XG5cbiAgbWl4aW4uJCQudmFsdWUgPSB2YWx1ZTtcblxuICBpdGVyYXRlQXJyYXkobWl4aW4uJCQud2F0Y2hlcnMsICh3YXRjaGVyKSA9PiB7XG4gICAgd2F0Y2hlcih2YWx1ZSwgb2xkVmFsdWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0TWl4aW5SZWdFeHAobmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7IGVzY2FwZVJlZ2V4KG5hbWUpIH0oPzpcXFxcKChbXlxcXFwpXSopXFxcXCkpPyg/OiMoW1xcXFxzXFxcXFNdKikpPyRgKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kQmxvY2soY2xzKSB7XG4gIHNldFByb3RvKGNscywgQmxvY2spO1xuICBzZXRQcm90byhjbHMucHJvdG90eXBlLCBCbG9jay5wcm90b3R5cGUpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRUZW1wbGF0ZXModGVtcGxhdGUsIHRlbXBsYXRlcykge1xuICBjb25zdCB7IHZhcnMsIHZhbHVlIH0gPSB0ZW1wbGF0ZTtcbiAgY29uc3QgbmV3VGVtcGxhdGVzID0gY3JlYXRlKG51bGwpO1xuICBjb25zdCBuZXdWYXJzID0gdG9PYmplY3RLZXlzKHZhcnMpO1xuXG4gIGFzc2lnbihuZXdUZW1wbGF0ZXMsIHRlbXBsYXRlcyk7XG4gIGl0ZXJhdGVBcnJheSh2YWx1ZSwgZm9yRWFjaE5vZGUpO1xuXG4gIGZ1bmN0aW9uIGZvckVhY2hOb2RlKHsgdHlwZSwgdmFsdWUsIGNoaWxkcmVuIH0sIGluZGV4LCB0cmVlKSB7XG4gICAgaWYgKHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICBpZiAobmV3VGVtcGxhdGVzW3ZhbHVlXSkge1xuICAgICAgICB0cmVlW2luZGV4XSA9IG5ld1RlbXBsYXRlc1t2YWx1ZV0udmFsdWU7XG4gICAgICAgIGFzc2lnbihuZXdWYXJzLCB0b09iamVjdEtleXMobmV3VGVtcGxhdGVzW3ZhbHVlXS52YXJzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgZm9yRWFjaE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhcnMubGVuZ3RoID0gMDtcbiAgdmFycy5wdXNoKC4uLmtleXMobmV3VmFycykpO1xuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuZnVuY3Rpb24gd3JhcEJsb2NrKGJsb2NrLCB3cmFwcGVyKSB7XG4gIGNvbnN0IHJldHVyblZhbHVlID0gd3JhcHBlcihibG9jayk7XG5cbiAgcmV0dXJuIGlzSW5zdGFuY2VPZihCbG9jaywgcmV0dXJuVmFsdWUpXG4gICAgPyByZXR1cm5WYWx1ZVxuICAgIDogYmxvY2s7XG59XG5cbmZ1bmN0aW9uIHdyYXBNaXhpbihtaXhpbiwgd3JhcHBlcikge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHdyYXBwZXIobWl4aW4pO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoTWl4aW4sIHJldHVyblZhbHVlKVxuICAgID8gcmV0dXJuVmFsdWVcbiAgICA6IG1peGluO1xufVxuXG5mdW5jdGlvbiByZW1vdmVXaXRoUGFyZW50U2lnbmFsKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSh0cnVlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSgpO1xufVxuXG5mdW5jdGlvbiBjbGVhblByb3BlcnR5KHZhbHVlLCBhcmcsIG9iamVjdCkge1xuICBkZWxldGUgb2JqZWN0W2FyZ107XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVdhdGNoZXIoeyB3YXRjaGVyLCB3YXRjaGVycyB9KSB7XG4gIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVycywgd2F0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRlbXBXYXRjaGVyKHdhdGNoZXIpIHtcbiAgd2F0Y2hlci5vblJlbW92ZSgpO1xuICB3YXRjaGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFkZEFyZ3MoYXJncywgdmFsdWUsIGFyZykge1xuICBpZiAoRF9SRVNUX1JFR0VYLnRlc3QoYXJnKSkge1xuICAgIGFzc2lnbihhcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyh2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbYXJnXSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEJsb2NrLCBNaXhpbiwgaW5pdEFwcCwgcmVtb3ZlQXBwLCBpbnNlcnRUZW1wbGF0ZXMgfTtcbiIsIi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xuLyogZXNsaW50IG5vLW5lZ2F0ZWQtY29uZGl0aW9uOiAwICovXG5leHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuIiwiZXhwb3J0IGNvbnN0IHtcbiAgY3JlYXRlLFxuICBrZXlzLFxuICBnZXRQcm90b3R5cGVPZjogZ2V0UHJvdG9cbn0gPSBPYmplY3Q7XG5cbmV4cG9ydCBjb25zdCBzZXRQcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoKHRhcmdldCwgcHJvdG8pID0+IHtcbiAgLyogZXNsaW50IG5vLXByb3RvOiAwICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBwcm90bztcbn0pO1xuIl0sIm5hbWVzIjpbImNvbGxlY3RGcm9tQXJyYXkiLCJhcnJheSIsImNhbGxiYWNrIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJpbmRleCIsImZpbmRJbkFycmF5IiwiaSIsImxlbmd0aCIsIml0ZXJhdGVBcnJheSIsInJlbW92ZUFycmF5RWxlbSIsImVsZW0iLCJpbmRleE9mIiwic3BsaWNlIiwidG9PYmplY3RLZXlzIiwiYWRkS2V5IiwidmFycyIsInZhcmlhYmxlIiwiYXNzaWduIiwidGFyZ2V0Iiwib2JqZWN0cyIsImFyZ3VtZW50cyIsInNvdXJjZSIsImtleSIsImNvbGxlY3RGcm9tT2JqZWN0Iiwib2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJoYXMiLCJpdGVyYXRlT2JqZWN0IiwibWFwT2JqZWN0IiwibmV3T2JqZWN0IiwiZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJuYW1lIiwiZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsInNsaWNlIiwic2V0VG9TdHJpbmdUYWciLCJ0YWciLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJpc0Z1bmN0aW9uIiwiaXNOaWwiLCJpc1N0cmluZyIsImVzY2FwZVJlZ2V4Iiwic3RyaW5nIiwicmVwbGFjZSIsInJlZ2V4cFNwZWNpYWxzUmVnZXhwIiwidG9DYW1lbENhc2UiLCJEQVNIRURfU1lNQk9MX1JFR0VYIiwiY2FwaXRhbGl6ZSIsInRvSHlwaGVuQ2FzZSIsIlVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYIiwiaHlwaGVuaXplIiwibWF0Y2giLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwidG9FbGVtIiwiaXNFbGVtIiwiRWxlbSIsImlzSFRNTERvY3VtZW50IiwiaXNFbGVtZW50c0NvbGxlY3Rpb24iLCJIVE1MX0NPTExFQ1RJT05fUkVHRVgiLCJ0ZXN0IiwiaXNBcnJheSIsImlzVmFsaWROb2RlIiwiRUxFTUVOVF9SRUdFWCIsImdldE5hbWUiLCJub2RlTmFtZSIsImdldEF0dHJOUyIsImF0dHIiLCJYTUxfTlMiLCJYX0xJTktfQVRUUl9SRUdFWCIsImNsb3Nlc3QiLCJYX0xJTktfTlMiLCJjcmVhdGVIaWRlU3R5bGVOb2RlIiwiaGVhZCIsImZpbmQiLCJISURFX0NMQVNTIiwiY3JlYXRlIiwicHJvcCIsInRleHQiLCJhZGRBdHRyIiwiYXR0cnMiLCJhZGRDU1NQcm9wIiwiY3NzIiwicHJvcGVydHkiLCJzcGxpdCIsIkNTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCIsImFkZERhdGFBdHRyIiwiZGF0YSIsImhpZGUiLCJvd25lckRvY3VtZW50IiwiYWRkQ2xhc3MiLCJhZGROZXh0IiwiYWRkIiwibmV4dFNpYmxpbmciLCJhZGRQYXJlbnQiLCJwYXJlbnROb2RlIiwiYWRkUHJldiIsInByZXZpb3VzU2libGluZyIsInJlbW92ZSIsInBhcmVudCIsInJlbW92ZUNoaWxkIiwic2hvdyIsInJlbW92ZUNsYXNzIiwic2VsZWN0b3IiLCJiYXNlIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiU3RyaW5nIiwicmVnaXN0ZXJEQmxvY2siLCJCbG9jayIsIkRCbG9jayIsInRoaXMiLCIkJCIsInBhcmVudFNjb3BlIiwicGFyZW50UGFyZW50U2NvcGUiLCJwYXJlbnRQYXJlbnRUZW1wbGF0ZSIsInBhcmVudFRlbXBsYXRlIiwiY2hpbGRyZW4iLCJhcmdzQ2hpbGRyZW4iLCJvd25DaGlsZHJlbiIsImRCbG9ja05hbWUiLCJmb3VuZCIsIlBhcmVudFNjb3BlIiwiUGFyZW50VGVtcGxhdGUiLCJkQmxvY2tzIiwiZWxlbXMiLCJ0ZW1wbGF0ZSIsInJlZ2lzdGVyREVhY2giLCJjcmVhdGVCbG9jayIsInJlbmRlclNldCIsIl90aGlzMiIsIml0ZW1zQnlVSURzIiwicGFyZW50RWxlbSIsInNjb3BlIiwiaXRlbU5hbWUiLCJpbmRleE5hbWUiLCJVSUQiLCJzb3J0QnkiLCJhcmdzIiwibmV3SXRlbXNCeVVJRHMiLCJuZXdVSURzQ291bnRlciIsIm5ld1VJRHMiLCJzZXQiLCJmaWx0ZXJCeSIsImlzQXJyIiwiaXRlcmF0ZSIsInNvcnQiLCJmaWx0ZXIiLCJpdGVtIiwidWlkIiwiZXZhbHVhdGUiLCJpdGVtcyIsInByZXZCbG9jayIsImJsb2NrIiwic2hpZnQiLCJpbnNlcnRBZnRlckl0IiwiY29udGVudCIsInB1c2giLCJvcHRzIiwiX3RoaXMiLCJ1bmRlZmluZWQiLCJldmFsdWF0ZUFuZFdhdGNoIiwid2F0Y2hBcmdzIiwicmVnaXN0ZXJERWxlbWVudHMiLCJtaXhpbnMiLCJ3YXRjaGVyc1RvUmVtb3ZlIiwicmVtb3ZlV2l0aFBhcmVudFNpZ25hbCIsInJlbW92ZUNvbnRlbnQiLCJ3YXRjaGVycyIsIndhdGNoZXIiLCJmb3JERWxlbWVudHMiLCJjaGlsZCIsInJlZ2lzdGVyRElmIiwiRElmIiwiSW5maW5pdHkiLCJ2YWx1ZXMiLCJtYXAiLCJjb25kIiwiaWYiLCJuZXdWYWx1ZSIsIkJvb2xlYW4iLCJyZWdpc3RlckRJdGVtIiwiREl0ZW0iLCJyZWdpc3RlckRTd2l0Y2giLCJEU3dpdGNoIiwid2FzRGVmYXVsdCIsInZhbCIsImVxdWFscyIsInZhbHVlMSIsInZhbHVlMiIsInJlZ2lzdGVyREF0dHIiLCJNaXhpbiIsInJlbW92ZUF0dHIiLCJhcHBseSIsImtleXMiLCJyZWdpc3RlckRCaW5kIiwib2ZmIiwib24iLCJqb2luIiwiZXJyb3IiLCJyZWdpc3RlckRDbGFzcyIsImNsYXNzZXMiLCJuZXdDbGFzc2VzIiwiRU1QVFlfU1BBQ0VfUkVHRVgiLCJjbHMiLCJyZWdpc3RlckRFbGVtIiwiREVsZW0iLCJldmFsdWF0ZU9uY2UiLCJyZWdpc3RlckRIaWRlIiwicmVnaXN0ZXJETm9kZSIsIkROb2RlIiwibm9kZSIsInJlZ2lzdGVyRE9uIiwiRE9uIiwicmVnaXN0ZXJEU2hvdyIsInJlZ2lzdGVyRFN0eWxlIiwib2xkVmFsdWUiLCJDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWCIsInJlbW92ZUNTUyIsInJlZ2lzdGVyRFZhbHVlIiwiRFZhbHVlIiwidHlwZSIsImluaXRpYWxTY29wZVZhbHVlIiwiZ2V0UHJvcCIsIm9wdGlvbnMiLCJnZXRFdmFsRnVuY3Rpb24iLCJjdXJyZW50VmFsdWUiLCJzZXRQcm9wIiwiaW5pdGlhbEVsZW1WYWx1ZSIsImlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIiwiaXNDaGVja2JveCIsImNoYW5nZVNjb3BlIiwib2ZmRWxlbUxpc3RlbmVyIiwiZ2V0TGlzdGVuZXJOYW1lIiwiZSIsIm9mZkZvcm1MaXN0ZW5lciIsImZvckVhY2giLCJvcHRpb24iLCJzZWxlY3RlZCIsImdldFZhbHVlRm9yU2V0dGluZyIsImluaXQiLCJnZXRWYWx1ZUZvckdldHRpbmciLCJoYXNBdHRyIiwiaW5wdXRWYWx1ZSIsImlzUmFkaW8iLCJpc011bHRpcGxlIiwiYWRkVmFsdWUiLCJjb25jYXQiLCJpbml0QXBwIiwiaHRtbCIsIkVycm9yIiwiUm9vdEJsb2NrIiwiX3ZhcnMiLCJfaHRtbCIsInJlbW92ZUFwcCIsIkR3YXluZVJvb3RCbG9jayIsInJlZ2lzdGVyQnVpbHRJbnMiLCJwcm90byIsInJlZ2lzdGVyIiwiX21hdGNoIiwiY29uc3RydWN0TWl4aW5SZWdFeHAiLCJDb25zdHJ1Y3RvciIsInBhcmVudEJsb2NrIiwiZG9jIiwibmFtZXNwYWNlVVJJIiwiU1ZHX05TIiwibG9jYWxCbG9ja3MiLCJucyIsIl9ibG9ja3MiLCJibG9ja3MiLCJsb2NhbE1peGlucyIsIl9taXhpbnMiLCJlbXB0eUNoaWxkcmVuIiwiZW1wdHlBdHRycyIsImNvbnN0cnVjdG9yIiwiZEJsb2NrTWF0Y2giLCJkQmxvY2tBcmdzIiwiZEJsb2NrQ2hpbGRyZW4iLCJkRWxlbWVudHNOYW1lIiwiTkFNRURfRF9CTE9DS19SRUdFWCIsImJsb2NrSW5zdGFuY2UiLCJlcnIiLCJlbGVtZW50IiwiY3VycmVudEF0dHJzIiwid2FzRFJlc3QiLCJtaXhpbkRlZmF1bHRPcHRzIiwiaXNEUmVzdCIsIkRfUkVTVF9SRUdFWCIsImxvY2FsQXR0cnMiLCJyZXN0QXR0cnMiLCJjbGVhblByb3BlcnR5IiwidHJhbnNmb3JtUmVzdEF0dHJzIiwibWl4aW5NYXRjaCIsImNyZWF0ZU1peGlucyIsImNhbGN1bGF0ZUF0dHJzIiwiaXNQYXJlbnRCbG9jayIsImluc2VydEFmdGVyIiwiYWRkQ29udGVudCIsImluc2VydEluU3RhcnRPZkl0IiwiaW50byIsIkFyZ3MiLCJnbG9iYWxzIiwibG9jYWxzIiwibmV3TmFtZSIsImNvbnN0cnVjdFByaXZhdGVTY29wZSIsInNjb3BlVmFsdWVzIiwicHJpdmF0ZVNjb3BlIiwiYWZ0ZXJDb25zdHJ1Y3QiLCJhZnRlclJlbmRlciIsImNyZWF0ZU1peGluIiwiZHluYW1pYyIsImNvbW1lbnQiLCJtaXhpbiIsImFmdGVyVXBkYXRlIiwiaXNJbnN0YW5jZU9mIiwiQ2xhc3MiLCJTdWJjbGFzcyIsImlzUHJvdG90eXBlT2YiLCJyZW1vdmVXYXRjaGVycyIsInJlbW92ZVdhdGNoZXIiLCJjb25zdHJ1Y3RQdWJsaWNTY29wZSIsImV2YWxNb2RlIiwiZ2V0dGluZyIsInRlbXAiLCJjaGFuZ2VkIiwib2xkVGVtcFdhdGNoZXJzIiwicmVtb3ZlVGVtcFdhdGNoZXIiLCJ3YXMiLCJwZXJtIiwid2F0Y2hGb3JBbGxMb2NhbHMiLCJ3YXRjaEZvckFsbEdsb2JhbHMiLCJnbG9iIiwid2F0Y2hGb3JBbGxBcmdzIiwiY2FsY3VsYXRlQXJncyIsImFyZ3NPYmplY3QiLCJhcmciLCJ0cmFuc2Zvcm1SZXN0QXJncyIsImFkZEFyZ3MiLCJldmVudHVhbEF0dHJzIiwibG9jYWxNYXRjaCIsImFyZ3NNYXRjaCIsIkNPTU1BX1JFR0VYIiwiYXR0cnNPYmplY3QiLCJmaXJzdFRpbWUiLCJuZXh0VHlwZSIsIm5leHREeW5hbWljIiwibmV4dFZhbHVlIiwicHJldlR5cGUiLCJwcmV2VmFsdWUiLCJpc0R5bmFtaWMiLCJldmFsdWF0ZWQiLCJidWlsZE1peGluIiwiZmlyc3RWYWx1ZSIsImV4ZWN1dGVNaXhpbldhdGNoZXJzIiwiUmVnRXhwIiwiZXh0ZW5kQmxvY2siLCJpbnNlcnRUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZXMiLCJmb3JFYWNoTm9kZSIsInRyZWUiLCJ0cmltIiwibmV3VGVtcGxhdGVzIiwibmV3VmFycyIsIndyYXBCbG9jayIsIndyYXBwZXIiLCJyZXR1cm5WYWx1ZSIsIndyYXBNaXhpbiIsIm9uUmVtb3ZlIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImRlZmluZVByb3BlcnRpZXMiLCJPYmplY3QiLCJBcnJheSIsInJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzIiwicyIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJzZXRQcm90byIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsIkVWRU5UX1JFR0VYIiwiZW1wdHlDb2xsZWN0aW9uIiwiaW5jbHVkZXMiLCJsaXN0IiwiY2xhc3NMaXN0IiwiYXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZU5TIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZE5vZGVzIiwiY29sbGVjdCIsImlzIiwiZWxlbWVudHMiLCJjYiIsImNvbnRhaW5zIiwiZWwiLCJpc1RleHQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJzdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRQcm9wZXJ0eVByaW9yaXR5IiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImNzc1RleHQiLCJkYXRhc2V0IiwiZXZlbnQiLCJkZXRhaWxzIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJyZWFsRGV0YWlscyIsImZpbmFsRXZlbnQiLCJFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImZpbHRlckZuIiwiaGFzQXR0cmlidXRlTlMiLCJoYXNBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJuZXh0IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJlbmQiLCJmaXJzdENoaWxkIiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsImNhbGwiLCJsaXN0ZW5lciIsIm5ld0V2ZW50cyIsImFsbExpc3RlbmVycyIsImxpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsImZpcnN0IiwibWV0aG9kIiwicHJldiIsImJhYmVsSGVscGVycy5nZXQiLCJ0ZXh0Q29udGVudCIsImNvbmRpdGlvbiIsIl9hcmd1bWVudHM1IiwidG9nZ2xlIiwiX2FyZ3VtZW50czYiLCJzcGVjaWVzIiwiYm9keSIsInJvb3RCbG9ja3MiLCJyb290TWl4aW5zIiwiYmxvY2tIb29rcyIsIm1peGluSG9va3MiLCJUQUdfTkFNRV9SRUdFWCIsIkFUVFJfTkFNRV9SRUdFWCIsIldBVENIRURfQVJHX1BSRUZJWF9SRUdFWCIsIldBVENIRURfR0xPQkFMX1BSRUZJWF9SRUdFWCIsImFmdGVyRWxlbSIsIm9yaWdpbmFsQXJncyIsImNoaWxkcmVuQmxvY2tzIiwiZnVuYyIsIm9uQ2hhbmdlIiwidGFyZ2V0QmxvY2siLCJmb3JESXRlbSIsImZvckRFYWNoIiwib25DaGFuZ2VGbGFnIiwicmVzdWx0IiwiZXhwcmVzc2lvbiIsIm9yaWdpbmFsIiwib25FdmFsRXJyb3IiLCJsb2NhbFdhdGNoZXJzIiwibmV3UmVzdWx0IiwiaXNSZW1vdmVkIiwid2F0Y2hlckJsb2NrIiwiaXNQYXJlbnRTaWduYWwiLCJiZWZvcmVSZW1vdmUiLCJfdGhpczciLCJjb250ZW50VG9BZGQiLCJub3RSZWN1cnNpdmUiLCJjb250ZW50VG9Nb3ZlIiwiYWZ0ZXIiLCJpbmRleFRvUHV0IiwibW92ZUNvbnRlbnQiLCJjb250ZW50VG9SZW1vdmUiLCJjb250ZW50VG9JbnNlcnQiLCJtb3ZlRmxhZyIsInRyeVRvQWRkT3JNb3ZlIiwiZGVmYXVsdExvY2FscyIsImRlZmF1bHRBcmdzIiwibG9jYWxBcmdzIiwicmVzdEFyZ3MiLCJpc0RFbGVtZW50cyIsImhvb2siLCJ3YXJuIiwicmVkdWNlIiwiY3VycmVudFJldHVyblZhbHVlIiwid3JhcHBlcnMiLCJvbGRXYXRjaGVyIiwiX3RoaXM4IiwiQmxvY2tzIiwiX3RoaXM5IiwiX3ZhbHVlIiwiTWl4aW5zIl0sIm1hcHBpbmdzIjoieUJBQU8sU0FBU0EsR0FBaUJDLEVBQU9DLE1BQVVDLHNFQUNuQ0YsRUFBTyxTQUFDRyxFQUFPQyxLQUNqQkYsRUFBY0MsRUFBT0MsRUFBT0osS0FHaENFLEVBR1QsUUFBZ0JHLEdBQVlMLEVBQU9DLE9BQzVCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsSUFBSyxJQUNoREgsR0FBUUgsRUFBTU0sTUFFaEJMLEVBQVNFLEVBQU9HLEVBQUdOLGNBRWRNLFlBT2IsUUFBZ0JFLEdBQWFSLEVBQU9DLE9BQzdCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsTUFDeENOLEVBQU1NLEdBQUlBLEVBQUdOLEdBSTFCLFFBQWdCUyxHQUFnQlQsRUFBT1UsTUFDL0JOLEdBQVFKLEVBQU1XLFFBQVFELElBRWIsSUFBWE4sS0FDSVEsT0FBT1IsRUFBTyxHQUl4QixRQUFnQlMsR0FBYWIsU0FDcEJELEdBQWlCQyxFQUFPYyxHQUdqQyxRQUFTQSxHQUFPQyxFQUFNQyxLQUNmQSxJQUFZLEVDM0JuQixRQUFnQkMsR0FBT0MsOEJBQVdDLDREQUNuQkMsVUFBVyxTQUFDQyxFQUFRakIsR0FDM0JBLEtBQ1lpQixFQUFRLFNBQUNsQixFQUFPbUIsS0FDckJBLEdBQU9uQixNQUtiZSxFQUdULFFBQWdCSyxHQUFrQkMsRUFBUXZCLE1BQVVDLHNFQUNwQ3NCLEVBQVEsU0FBQ3JCLEVBQU9tQixLQUNuQnBCLEVBQWNDLEVBQU9t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"}