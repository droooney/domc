{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/is.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/escapeRegex.js","../src/utils/noop.js","../src/utils/toCase.js","../src/utils/toStringTag.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/is.js","../src/helpers/Elem/getEvent.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/matches.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/constructMixinRegex.js","../src/helpers/Block/mixinMatch.js","../src/helpers/Block/transformRestAttrs.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/normalizeArgs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/remove.js","../src/helpers/Block/wrap.js","../src/mixins/d-style.js","../src/mixins/d-value.js","../src/insertTemplates.js","../src/initApp.js","../src/removeApp.js","../src/utils/objectStatics.js","../src/global.js","../src/constants.js","../src/Elem.js","../src/utils/setSymbolSpecies.js","../src/Mixin.js","../src/Block.js","../src/blocks/d-block.js","../src/blocks/d-item.js","../src/blocks/d-each.js","../src/blocks/d-elements.js","../src/blocks/d-if.js","../src/blocks/d-switch.js","../src/mixins/d-bind.js","../src/mixins/d-class.js","../src/mixins/d-elem.js","../src/mixins/d-hide.js","../src/mixins/d-node.js","../src/mixins/d-on.js","../src/mixins/d-show.js","../src/helpers/Block/registerBuiltins.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","export const { isArray } = Array;\n\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\nexport function isNil(value) {\n  /* eslint-disable eqeqeq */\n  return value == null;\n  /* eslint-enable eqeqeq */\n}\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n","import { iterateArray } from './array';\n\nconst {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  iterateArray(arguments, (source, index) => {\n    if (index) {\n      iterateObject(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\nconst regexpSpecialsRegexp = new RegExp(\n  regexpSpecialCharacters\n    .map((s) => `\\\\${ s }`)\n    .join('|'),\n  'g'\n);\n\nexport function escapeRegex(string) {\n  return string.replace(regexpSpecialsRegexp, '\\\\$&');\n}\n","export function noop() {}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","import { definePrototypeProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nconst { toString } = {};\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(klass, tag) {\n  if (Symbol.toStringTag) {\n    definePrototypeProperties(klass.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_FIND_REGEX = /^xlink:\\w/;\nconst X_LINK_ATTR_REPLACE_REGEX = /^xlink:/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst Null = {\n  ns: null\n};\n\nexport function getAttrNS(attr, elem) {\n  const isXmlNs = attr === 'xmlns';\n\n  if (isXmlNs || attr === 'xmlns:xlink') {\n    if (elem.nodeName !== 'SVG') {\n      return Null;\n    }\n\n    return {\n      ns: XML_NS,\n      name: isXmlNs\n        ? 'xmlns'\n        : 'xlink'\n    };\n  }\n\n  if (X_LINK_ATTR_FIND_REGEX.test(attr)) {\n    if (!new Elem(elem).closest('svg').length) {\n      return Null;\n    }\n\n    return {\n      ns: X_LINK_NS,\n      name: attr.replace(X_LINK_ATTR_REPLACE_REGEX, '')\n    };\n  }\n\n  return Null;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { Elem } from '../../Elem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\nconst DOCUMENT_REGEX = /Document$/;\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isDocument(value) {\n  return DOCUMENT_REGEX.test(toStringTag(value));\n}\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || DOCUMENT_REGEX.test(tag)\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","import { assign, toStringTag } from '../../utils';\nimport { isDocument } from './is';\n\nconst EVENT_REGEX = /Event$/;\n\nexport function getEvent(event, bubbles, cancelable, realDetails, elem) {\n  let finalEvent = event;\n\n  if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n    try {\n      finalEvent = new Event(finalEvent, { bubbles, cancelable });\n      assign(finalEvent, realDetails);\n    } catch (err) {\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      finalEvent = document.createEvent('Event');\n      finalEvent.initEvent(event, bubbles, cancelable);\n\n      assign(finalEvent, realDetails);\n    }\n  }\n\n  return finalEvent;\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { isDocument } from './is';\n\nconst { indexOf } = [];\n\nexport function getMatchesFunction(elem) {\n  return (\n    elem.matches\n    || elem.matchesSelector\n    || elem.webkitMatchesSelector\n    || elem.mozMatchesSelector\n    || elem.msMatchesSelector\n    || elem.oMatchesSelector\n    || matches\n  );\n}\n\nfunction matches(selector) {\n  const document = isDocument(this)\n    ? this\n    : this.ownerDocument;\n\n  return document.querySelectorAll(selector)::indexOf(this) !== -1;\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './is';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\nimport { document } from './constants';\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, iterateObject, keys } from '../../utils';\n\nexport function calculateArgs(normalizedArgs, args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  iterateObject(normalizedArgs, (value, arg) => {\n    argsObject[arg] = value;\n  });\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { escapeRegex } from '../../utils';\n\nexport function constructMixinRegex(name) {\n  return new RegExp(`^${ escapeRegex(name) }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n","const COMMA_REGEX = /,/;\n\nexport function mixinMatch(mixins, attr) {\n  let match;\n\n  /* eslint-disable guard-for-in */\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (argsMatch === '') {\n        args = [];\n      } else if (argsMatch) {\n        args = argsMatch.split(COMMA_REGEX);\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n  /* eslint-enable guard-for-in */\n\n  return match;\n}\n","import { collectFromObject, assign } from '../../utils';\nimport { D_REST_REGEX } from '../../constants';\nimport { mixinMatch } from './mixinMatch';\n\nexport function transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return collectFromObject(attrs, (eventualAttrs, value, attr) => {\n    if (D_REST_REGEX.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  });\n}\n\nexport function transformRestArgs(args) {\n  return collectFromObject(args, addArgs);\n}\n\nfunction addArgs(args, value, arg) {\n  if (D_REST_REGEX.test(arg)) {\n    assign(args, transformRestArgs(value));\n  } else {\n    args[arg] = value;\n  }\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","import { iterateObject, iterateArray } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\n\nexport function calculateAttrs(normalizedAttrs, attrs, attrsObject, elem, firstTime) {\n  iterateObject(attrsObject, ({ type, value }, attr) => {\n    if (!(attr in attrs)) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = [];\n\n  iterateObject(normalizedAttrs, ({ type, dynamic, value, opts }, attr) => {\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue,\n        dynamic: prevDynamic\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        let mixin = prevValue;\n        let created;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n\n          created = true;\n          opts.dynamic = dynamic;\n          mixin = new opts.Mixin(opts);\n        } else {\n          mixin.$$.isDynamic = dynamic;\n        }\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(\n            value,\n            constructMixinWatcher(mixin, attr, attrs),\n            mixin\n          );\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        } else if (prevDynamic && opts.Mixin.evaluate) {\n          executeMixinWatchers(mixin, mixin.$$.parentScope.$$.evaluate(value));\n        }\n\n        nextValue = mixin;\n\n        if (created) {\n          mixin.$$.setAfterUpdate();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = new opts.Mixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(\n              value,\n              constructMixinWatcher(mixin, attr, attrs),\n              mixin\n            );\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n          mixin.$$.setAfterUpdate();\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  });\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, (buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n\nfunction constructMixinWatcher(mixin, attr, attrs) {\n  return function (newValue) {\n    const {\n      type,\n      dynamic\n    } = attrs[attr];\n\n    if (type === 'mixin' && !dynamic) {\n      executeMixinWatchers(mixin, newValue);\n    }\n  };\n}\n","import { iterateArray, iterateObject } from '../../utils';\n\nexport function normalizeArgs(argsChain) {\n  const newArgs = {};\n\n  iterateArray(argsChain, (args) => {\n    iterateObject(args, (value, arg) => {\n      newArgs[arg] = value;\n    });\n  });\n\n  return newArgs;\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: []\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { gettingVars, evalMode } from '../../Block';\nimport { removeTempWatcher } from './removeWatcher';\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (gettingVars.indexOf(scope.watchers) === -1) {\n            gettingVars.push(scope.watchers);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        const oldTempWatchers = scope.watchers.slice();\n\n        scope.watchers = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n      }\n    };\n  }));\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil\n} from '../../utils';\nimport { isDocument } from '../Elem';\nimport { Elem } from '../../Elem';\nimport {\n  SVG_NS, D_REST_REGEX\n} from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { transformRestAttrs } from './transformRestAttrs';\nimport { calculateAttrs } from './calculateAttrs';\nimport { normalizeArgs } from './normalizeArgs';\nimport { mixinMatch } from './mixinMatch';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { Block } from '../../Block';\n\nconst NAMED_D_BLOCK_REGEX = /^d-block:([\\s\\S]+)$/;\nconst emptyArray = [];\n\nexport function createBlock({ node, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = isDocument(parentElem[0])\n    ? parentElem\n    : new Elem(parentElem[0].ownerDocument);\n  const elem = parentElem[0].namespaceURI === SVG_NS\n    ? doc.create('svg')\n    : doc;\n  const localBlocks = parentTemplate ? parentTemplate.$$.ns._blocks : Block._blocks;\n  const localMixins = parentTemplate ? parentTemplate.$$.ns._mixins : Block._mixins;\n  const args = node.attrs || {};\n  const name = node.name || 'UnknownBlock';\n  let { children } = node;\n  let constructor = node.Constructor || (node.name && localBlocks[node.name]);\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n\n  if (name === 'd-block' && args.name) {\n    dBlockArgs = except(args, 'name');\n  } else if (name === 'd-block' && args.Constructor) {\n    dBlockArgs = except(args, 'Constructor');\n  } else if ((dBlockMatch = name.match(NAMED_D_BLOCK_REGEX)) || name === 'd-block') {\n    constructor = Block._blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        dBlockArgs,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const { value } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = create(null);\n    let attrs = create(null);\n    let wasDRest;\n    const attrsChain = [attrs];\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    iterateObject(args, (value, attr) => {\n      const isDRest = D_REST_REGEX.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? create(attrs)\n        : attrs;\n\n      if (attrs !== localAttrs) {\n        attrsChain.push(localAttrs);\n      }\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localAttrs, cleanProperty);\n          assign(localAttrs, transformRestAttrs(\n            value,\n            localMixins,\n            mixinDefaultOpts\n          ));\n          calculateAttrs(normalizeArgs(attrsChain), attrs, currentAttrs, element, false);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(normalizeArgs(attrsChain), attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    parentBlock.$$.mixinsToBuild.push(calculateAttrs(normalizeArgs(attrsChain), attrs, currentAttrs, element, true));\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        element.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      element.text(`${ text }`);\n    }\n\n    const isParentBlock = parent instanceof Block;\n    const childBlocks = [];\n\n    /* istanbul ignore if */\n    if (name === 'iframe' && !('src' in attrs)) {\n      element.on('load', () => {\n        const document = element[0].contentDocument;\n        const doc = new Elem(document);\n\n        new Elem(document.documentElement).remove();\n        iterateChildren(childBlocks, true);\n\n        function iterateChildren(children, isRoot) {\n          iterateArray(children, (child) => {\n            if (child instanceof Block) {\n              if (isRoot) {\n                child.$$.parentElem = doc;\n                child.$$.parent = doc;\n                child.$$.content.into(doc);\n              }\n\n              iterateChildren(child.$$.children, false);\n            } else {\n              child.into(doc);\n            }\n          });\n        }\n      });\n    }\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    if (children) {\n      let prevBlock;\n      let parentElem = element;\n\n      /* istanbul ignore if */\n      if (name === 'template') {\n        parentElem = new Elem(element[0].content = element[0].content || doc[0].createDocumentFragment());\n      } else if (name === 'iframe') {\n        if ('src' in attrs) {\n          children = emptyArray;\n        } else {\n          const document = element[0].contentDocument;\n\n          new Elem(document.documentElement).remove();\n\n          parentElem = new Elem(document);\n        }\n      }\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n        childBlocks.push(prevBlock);\n      });\n    }\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  const html = name === 'd-elements'\n    ? Args.value || []\n    : constructor.template.value || constructor.template;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  iterateArray(blockInstance.$$.mixinsToBuild, (executeBuilders) => {\n    executeBuilders();\n  });\n  blockInstance.$$.mixinsToBuild = [];\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /\\s*;\\s*/;\nconst CSS_STYLE_SEPARATOR_REGEX = /\\s*:\\s*/;\n\nrootMixins['d-style'] = class DStyle extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean)\n          .map(constructStyleFromString),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        css\n      } = this;\n\n      elem.removeCSS.apply(elem, keys(css));\n    }\n  }\n};\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n\nfunction constructStyleFromString(style) {\n  const split = style.split(CSS_STYLE_SEPARATOR_REGEX);\n\n  return [\n    split[0].trim(),\n    split[1].trim()\n  ];\n}\n","import {\n  isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-value'] = class DValue extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.children().filter('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      this.value = args[0];\n    }\n\n    if (!isFunction(this.value)) {\n      initialScopeValue = this.scope.$$.evaluate((scope) => scope[this.value], (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue, false);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), changeScope);\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.offElemListener();\n    }\n\n    this.offFormListener();\n  }\n};\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      values = values || [];\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        return values.indexOf(inputValue) === -1\n          ? values.concat(inputValue)\n          : values;\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n","import {\n  toObjectKeys,\n  assign, keys, create\n} from './utils';\n\nexport function insertTemplates(template, templates) {\n  const {\n    vars,\n    value\n  } = template;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n  iterateAndChangeChildren(value);\n\n  function iterateAndChangeChildren(nodes = []) {\n    for (let i = 0; i < nodes.length; i++) {\n      const {\n        name,\n        value,\n        children\n      } = nodes[i];\n\n      if (name === '#comment') {\n        const trimmed = value.trim();\n\n        if (newTemplates[trimmed]) {\n          const newTemplate = newTemplates[trimmed].value;\n\n          nodes.splice(i, 1, ...newTemplate);\n          assign(newVars, toObjectKeys(newTemplates[trimmed].vars));\n\n          i += newTemplate.length - 1;\n        }\n      } else {\n        iterateAndChangeChildren(children);\n      }\n    }\n  }\n\n  vars.length = 0;\n  vars.push(...keys(newVars));\n\n  return template;\n}\n","import { isArray, isString } from './utils';\nimport { createBlock, isInstanceOf } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function initApp\n * @public\n * @param {Template|ScopelessTemplate|String|typeof Block} block - Root template (may be scopeless),\n * string defining a name of the root block or a block subclass.\n * @param {Elem|Element} container - Container of the app.\n * @returns {Block|void} Root block if the app has benn registered and undefined if not.\n * @description Method for initializing app.\n *\n * @example\n * import { initApp, doc } from 'dwayne';\n *\n * initApp(html`<App/>`, doc.create('div'));\n * initApp(htmlScopeless`<App/>`, doc.create('div'));\n * initApp('App', doc.create('div'));\n * initApp(App, doc.create('div'));\n */\nexport function initApp(block, container) {\n  const parentElem = new Elem(container).elem(0);\n  let Constructor = block;\n\n  if (!parentElem.length) {\n    console.error('No valid element to insert the app into was given! (initApp)');\n\n    return;\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    console.error('There already exists a Dwayne app inside the given element! (initApp)');\n\n    return;\n  }\n\n  if (isString(block)) {\n    Constructor = class RootBlock extends Block {\n      static template = {\n        vars: [],\n        value: [{\n          name: block\n        }]\n      };\n    };\n  }\n\n  if (isArray(block)) {\n    Constructor = class RootBlock extends Block {\n      static template = {\n        vars: [],\n        value: block\n      };\n    };\n  }\n\n  if (block && !isInstanceOf(Block, block) && isArray(block.vars) && isArray(block.value)) {\n    Constructor = class RootBlock extends Block {\n      static template = block;\n    };\n  }\n\n  if (!isInstanceOf(Block, Constructor)) {\n    console.error('No valid root block to insert the app into was given! (initApp)');\n\n    return;\n  }\n\n  const rootBlock = createBlock({\n    node: {\n      name: '#RootBlock',\n      Constructor\n    },\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', rootBlock)\n    .attr('dwayne-root', '');\n\n  return rootBlock;\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function removeApp\n * @public\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for removing app.\n *\n * @example\n * import { removeApp, find } from 'dwayne';\n *\n * removeApp(find('.root'));\n */\nexport function removeApp(container) {\n  const elem = new Elem(container).elem(0);\n\n  if (!elem.length) {\n    console.error('No valid element to remove the app from was given! (removeApp)');\n\n    return;\n  }\n\n  container = elem[0];\n\n  const { DwayneRootBlock } = container;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    console.error('No app registered inside the given element! (removeApp)');\n\n    return;\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete container.DwayneRootBlock;\n}\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint-disable no-proto */\n  target.__proto__ = proto;\n  /* eslint-enable no-proto */\n});\n","/* eslint-disable no-nested-ternary */\n/* eslint-disable no-negated-condition */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n/* eslint-enable no-nested-ternary */\n/* eslint-enable no-negated-condition */\n","import { create } from './utils/objectStatics';\n\nexport const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const D_REST_REGEX = /^d-rest(?:#|$)/;\n\nexport const rootBlocks = create(null);\nexport const rootMixins = create(null);\nexport const {\n  document = {},\n  Symbol = {}\n} = global;\n","import {\n  isNil, isString,\n  definePrototypeProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, setSymbolSpecies,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isDocument, isValidNode, getMatchesFunction,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, getEvent, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback CollectCallback\n * @public\n * @param {AddCallback} add - Add element to the eventual set function.\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback AddCallback\n * @public\n * @param {...(Element|Node|elem)} elem - Element to add.\n */\n\n/**\n * @callback ElemMethod\n * @public\n * @this Elem\n */\n\nconst EVENT_SEPARATOR_REGEX = /[,| ] */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array.<Element|Node>\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  /**\n   * @function Elem.addMethods\n   * @public\n   * @param {String|Object.<String, ElemMethod>} methodName - Name of the method or object of\n   * method names and methods.\n   * @param {ElemMethod} [method] - If the first argument is a string this should be the method itself.\n   * @returns {typeof Elem}\n   */\n  static addMethods(methodName, method) {\n    if (arguments.length >= 2) {\n      methodName = { [methodName]: method };\n    }\n\n    definePrototypeProperties(this.prototype, methodName);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @function Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add(...elements) {\n    const elems = this.slice();\n\n    iterateArray(elements, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @function Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @function Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromArray(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const {\n        ns,\n        name\n      } = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, name)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const { ns } = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @function Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @function Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  /**\n   * @function Elem#collect\n   * @public\n   * @param {CollectCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns eventual set.\n   * @description Method for collecting elements into a new set.\n   *\n   * @example\n   * const parents = elem.collect((add, elem) => {\n   *   add(elem.parentNode);\n   * });\n   */\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @function Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @function Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        el = type === 'svg'\n          ? document.createElementNS(SVG_NS, type)\n          : document.createElement(type);\n      }\n\n      if (!isDocument(elem)) {\n        new Elem(el).into(elem);\n      }\n\n      add(el);\n    });\n  }\n\n  /**\n   * @function Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @function Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @function Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details;\n\n    return this.forEach((elem) => {\n      elem.dispatchEvent(getEvent(\n        event,\n        bubbles,\n        cancelable,\n        realDetails,\n        elem\n      ));\n    });\n  }\n\n  /**\n   * @function Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @function Elem#filter\n   * @public\n   * @param {IterationCallback|String} filter - Filter function or a selector.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filter) {\n    if (isString(filter)) {\n      const selector = filter;\n\n      filter = (elem) => (\n        new Elem(elem).is(selector)\n      );\n    }\n\n    return this.collect((add, elem, index) => {\n      if (filter(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @function Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @function Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @function Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const { ns } = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @function Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @function Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @function Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  /**\n   * @function Elem#includes\n   * @public\n   * @param {Element|node} elem - Element to search.\n   * @return {Boolean} If the element is in the set.\n   * @description The same as Array#includes.\n   */\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @function Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @function Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @function Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (!element) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @function Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = getMatchesFunction(elem);\n\n    return elem::matches(selector);\n  }\n\n  /**\n   * @function Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @function Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @function Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @function Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @function Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @function Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @function Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @function Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr(...attributes) {\n    return this.forEach((elem) => {\n      iterateArray(attributes, (attr) => {\n        const { ns } = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @function Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @function Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS(...props) {\n    return this.forEach((elem) => {\n      iterateArray(props, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @function Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @function Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  /**\n   * @function Elem#slice\n   * @public\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n   * @returns {Elem}\n   * @description The same as Array#slice but for Elem.\n   */\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @function Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @function Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @function Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !classList.contains(cls) : condition) {\n        elem.addClass(cls);\n      } else {\n        elem.removeClass(cls);\n      }\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\nsetSymbolSpecies(Elem, Array);\n\nexport { Elem };\n","import { defineProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nexport function setSymbolSpecies(klass, species) {\n  if (Symbol.species) {\n    defineProperties(klass, {\n      [Symbol.species]: {\n        get() {\n          return species;\n        }\n      }\n    });\n  }\n}\n","import {\n  defineFrozenProperties, getProto,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\nconst toStringTag = '[object Mixin]';\n\n/**\n * @class Mixin\n * @public\n * @param {Object} opts - Mixin options.\n * @returns {Mixin} Instance of Mixin.\n */\nclass Mixin {\n  /**\n   * @member {Boolean} [Mixin.evaluate = true]\n   * @type {Boolean}\n   * @public\n   * @description If the mixin value should be evaluated and watched or not.\n   */\n  static evaluate = true;\n\n  /**\n   * @function Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n    const { constructor } = getProto(this);\n    const afterUpdate = (newValue, oldValue) => {\n      this.$$.value = newValue;\n\n      try {\n        this.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    };\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Mixin#$$\n       * @type {Object}\n       * @protected\n       * @property {Function} Mixin#$$.evaluate - Evaluate function.\n       * @property {Boolean} Mixin#$$.isDynamic - If the mixin is dynamic.\n       * @property {Boolean} Mixin#$$.isRemoved - If the block is removed.\n       * @property {String} Mixin#$$.name - Mixin name.\n       * @property {Block|void} Mixin#$$.parentBlock - Parent block.\n       * @property {Block|void} Mixin#$$.parentScope - Parent scope.\n       * @property {Block|void} Mixin#$$.parentTemplate - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing mixin.\n       */\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          isParentSignal = !!isParentSignal;\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove(isParentSignal);\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        },\n        setAfterUpdate: () => {\n          if (constructor.evaluate) {\n            afterUpdate(this.$$.evaluate(afterUpdate));\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {String} [Mixin#comment]\n     * @type {String}\n     * @public\n     */\n    this.comment = comment;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    parentBlock.$$.mixins.push(this);\n  }\n\n  afterUpdate() {}\n\n  /**\n   * @function Mixin#beforeRemove\n   * @public\n   * @param {Boolean} isElementRemoved - If element removed as well.\n   * @description Is called before the mixin removal.\n   */\n  beforeRemove(isElementRemoved) {}\n\n  /**\n   * @function Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, isArray,\n  setToStringTag, hasOwnProperty,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  constructMixinRegex, isInstanceOf, normalizeArgs,\n  removeWatchers, removeWithParentSignal, cleanProperty,\n  transformRestArgs, calculateArgs, wrapBlock\n} from './helpers/Block';\nimport {\n  D_REST_REGEX,\n  rootBlocks, rootMixins\n} from './constants';\nimport { Mixin } from './Mixin';\n\n/**\n * @typedef {Object} Template\n * @public\n * @property {String[]} vars - Template used vars.\n * @property {Object[]} value - Template itself.\n */\n\n/**\n * @typedef {Object[]} ScopelessTemplate\n * @public\n */\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {Function} func - Function which caused eval error.\n * @property {String} original - Evaluated expression original js.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {Mixin} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {typeof Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {typeof Mixin} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\n/**\n * @callback RemoveHook\n * @public\n */\n\nconst blockHooks = [];\nconst mixinHooks = [];\nconst TAG_NAME_REGEX = /^[a-z][a-z\\d\\-_.:!@#$%^&*()[\\]{}='\"\\\\]*$/i;\nconst ATTR_NAME_REGEX = /^[^\\u0000-\\u0020\\s'\">/=]+$/;\nconst toStringTag = '[object Block]';\nconst afterElem = new Elem();\nconst emptyObject = {};\nlet evalMode = false;\nlet gettingVars = [];\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Block options.\n * @returns {Block} Instance of Block.\n *\n * @example\n * import { Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/> ({ this.times })';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     this.interval = setInterval(() => {\n *       this.times++;\n *     });\n *   }\n *\n *   beforeRemove() {\n *     clearInterval(this.interval);\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', html`Hello, {args.text}!`);\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  /**\n   * @member {Object.<String, typeof Block>} Block._blocks\n   * @type {Object.<String, typeof Block>}\n   * @protected\n   * @description Block namespace blocks.\n   */\n  static _blocks = create(rootBlocks);\n\n  /**\n   * @member {Object.<String, typeof Mixin>} Block._mixins\n   * @type {Object.<String, typeof Mixin>}\n   * @protected\n   * @description Block namespace mixins.\n   */\n  static _mixins = create(rootMixins);\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {Object} [Block.template = { vars: [], value: [] }]\n   * @type {Object}\n   * @public\n   * @description Block template.\n   */\n  static template = {\n    vars: [],\n    value: []\n  };\n\n  /**\n   * @function Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.original || err.func }\" in context of ${ err.block.$$.name }):`, err);\n  }\n\n  /**\n   * @function Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterBlock(hook) {\n    blockHooks.push(hook);\n\n    return () => {\n      removeArrayElem(blockHooks, hook);\n    };\n  }\n\n  /**\n   * @function Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterMixin(hook) {\n    mixinHooks.push(hook);\n\n    return () => {\n      removeArrayElem(mixinHooks, hook);\n    };\n  }\n\n  /**\n   * @function Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Template|ScopelessTemplate|typeof Block} Subclass - Subclass of Block or template string of it.\n   * @returns {typeof Block|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        static template = constructor.template;\n\n        constructor(opts) {\n          super(opts);\n          this::constructor(opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass)) {\n      Subclass = class extends Block {\n        static template = {\n          vars: [],\n          value: Subclass\n        };\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass.vars) && isArray(Subclass.value)) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      console.warn(`Block must be a template (array or an object from an html loader), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (name === 'd-elements') {\n      console.warn('The \"d-elements\" block is a built-in block so the block will not be registered (Block.block)');\n\n      return;\n    }\n\n    if (!TAG_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_blocks')) {\n      this._blocks = create(getProto(this)._blocks);\n    }\n\n    if (!hasOwnProperty(this, 'defaultLocals')) {\n      this.defaultLocals = {};\n    }\n\n    if (!hasOwnProperty(this, 'defaultArgs')) {\n      this.defaultArgs = create(null);\n    }\n\n    try {\n      Subclass = blockHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Block, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterBlock\" hook:', err);\n    }\n\n    Subclass._blocks = hasOwnProperty(Subclass, '_blocks')\n      ? Subclass._blocks\n      : create(this._blocks);\n    Subclass._mixins = hasOwnProperty(Subclass, '_mixins')\n      ? Subclass._mixins\n      : create(this._mixins);\n\n    if (hasOwnProperty(Subclass, 'defaultArgs')) {\n      setProto(Subclass.defaultArgs, null);\n    }\n\n    this._blocks[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @function Block.get\n   * @public\n   * @param {String} name - Block name.\n   * @returns {typeof Block|undefined} Returns registered Block with specified name.\n   */\n  static get(name) {\n    return this._blocks[name];\n  }\n\n  /**\n   * @function Block.getMixin\n   * @public\n   * @param {String} name - Mixin name.\n   * @returns {typeof Mixin|undefined} Returns registered Mixin with specified name.\n   */\n  static getMixin(name) {\n    return this._mixins[name];\n  }\n\n  /**\n   * @function Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {typeof Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {typeof Mixin|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          this::afterUpdate(newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin or is not an afterUpdate function, so it will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (name === 'd-rest') {\n      console.warn('The \"d-rest\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)');\n\n      return;\n    }\n\n    if (!ATTR_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_mixins')) {\n      this._mixins = create(getProto(this)._mixins);\n    }\n\n    try {\n      Subclass = mixinHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Mixin, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterMixin\" hook:', err);\n    }\n\n    Subclass._match = constructMixinRegex(name);\n\n    this._mixins[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @function Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      dBlockArgs,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const { constructor } = getProto(this);\n    const childrenBlocks = [];\n    const mixins = [];\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} Block#$$.args - Private args scope.\n       * @property {Block[]} Block#$$.children - Child blocks.\n       * @property {Elem} Block#$$.content - Content elements.\n       * @property {Object|void} Block#$$.dBlockArgs - d-block args.\n       * @property {String|void} Block#$$.dBlockName - d-block name.\n       * @property {Block[]} Block#$$.dBlocks - d-block's within the block.\n       * @property {Function} Block#$$.evaluate - Evaluate function.\n       * @property {Object} Block#$$.globals - Private globals scope.\n       * @property {Object[]} Block#$$.htmlChildren - Block html children.\n       * @property {Boolean} Block#$$.isRemoved - If the block is removed.\n       * @property {Boolean} Block#$$.isRendered - If the block is rendered.\n       * @property {Object} Block#$$.locals - Private locals scope.\n       * @property {Mixin[]} Block#$$.mixins - Child mixins.\n       * @property {Function[]} Block#$$.mixinsToBuild - Pending mixins builders.\n       * @property {String} Block#$$.name - Block name.\n       * @property {typeof Block} Block#$$.ns - Block constructor.\n       * @property {Block|Elem|void} Block#$$.parent - Parent block or elem.\n       * @property {Block|void} Block#$$.parentBlock - Parent block.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Block|void} Block#$$.parentScope - Parent scope.\n       * @property {Block|void} Block#$$.parentTemplate - Parent template.\n       * @property {Block|Elem|void} Block#$$.prevBlock - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing the block.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlockArgs,\n        dBlocks: [],\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        htmlChildren: children || [],\n        children: childrenBlocks,\n        mixins,\n        mixinsToBuild: [],\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forDElements, forDItem) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = name === '#d-item' && !forDItem\n            ? this.$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : emptyObject;\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              evalMode = true;\n              gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.func = func;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error(`Uncaught error in ${ name }.onEvalError:`, e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(gettingVars, (watchers) => {\n                const watcher = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved && !this.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(mixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered && !this.$$.isRemoved) {\n            try {\n              this.afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterDOMChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor.template.vars || [], (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    const { defaultArgs } = constructor;\n    let args = create(defaultArgs || null);\n    let wasDRest;\n    const argsChain = [];\n\n    if (defaultArgs) {\n      argsChain.push(defaultArgs);\n    }\n\n    argsChain.push(args);\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isDRest = D_REST_REGEX.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? create(args)\n        : args;\n\n      if (args !== localArgs) {\n        argsChain.push(localArgs);\n      }\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, transformRestArgs(value));\n          calculateArgs(normalizeArgs(argsChain), args, argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return assign(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      localArgs[arg] = parentScope.$$.evaluate(value, (value) => {\n        localArgs[arg] = value;\n        calculateArgs(normalizeArgs(argsChain), args, argsObject);\n      }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(normalizeArgs(argsChain), args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @function Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @function Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed. Note that\n   * it's important not to modify the DOM structure within the block. You can only insert\n   * elements to empty elements (which Dwayne considers empty) and remove ones from them.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @function Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @function Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @function Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @function Block#getName\n   * @public\n   * @returns {String}\n   * @description Returns Block name.\n   */\n  getName() {\n    return this.$$.name;\n  }\n\n  /**\n   * @function Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @function Block#getParentScope\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentScope() {\n    return this.$$.parentScope;\n  }\n\n  /**\n   * @function Block#getParentTemplate\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentTemplate() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @function Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block, gettingVars, evalMode };\n","import { findInArray, isFunction } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchNameArgs = js`args.name`;\nconst watchConstructorArgs = js`args.Constructor`;\n\nclass DBlock extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{ParentScope}\"\n      parentTemplate=\"{ParentTemplate}\"\n    />\n  `;\n\n  afterConstruct(opts) {\n    const {\n      parentScope: {\n        $$: {\n          parentScope: parentParentScope,\n          parentTemplate: parentParentTemplate,\n          htmlChildren: children\n        }\n      },\n      htmlChildren: ownChildren,\n      parentScope,\n      parentTemplate,\n      dBlockName: DBlockName\n    } = this.$$;\n    const {\n      name,\n      Constructor\n    } = this.args;\n    let found;\n\n    this.ParentScope = parentScope;\n    this.ParentTemplate = parentTemplate;\n\n    if (name) {\n      this.constructDynamicNameBlock(\n        this.evaluate(watchNameArgs, this.constructDynamicNameBlock)\n      );\n\n      return;\n    }\n\n    if (Constructor) {\n      this.constructDynamicConstructorBlock(\n        this.evaluate(watchConstructorArgs, this.constructDynamicConstructorBlock)\n      );\n\n      return;\n    }\n\n    if (ownChildren.length) {\n      parentTemplate.$$.dBlocks.push(this);\n\n      return;\n    }\n\n    this.ParentScope = parentParentScope;\n    this.ParentTemplate = parentParentTemplate;\n\n    if (DBlockName) {\n      found = findInArray(children, ({ name: nodeName }) => nodeName === `d-block:${ DBlockName }`);\n\n      if (!found) {\n        found = findInArray(parentTemplate.$$.dBlocks, ({ $$: { dBlockName } }) => dBlockName === DBlockName);\n\n        if (found) {\n          this.ParentScope = parentTemplate;\n          this.ParentTemplate = parentTemplate;\n          found.value = {\n            children: found.value.$$.htmlChildren\n          };\n        }\n      }\n\n      this.elems = found\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = children;\n    }\n  }\n\n  constructDynamicNameBlock = (name) => {\n    const {\n      htmlChildren,\n      dBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      name,\n      attrs: dBlockArgs,\n      children: htmlChildren\n    }];\n  };\n\n  constructDynamicConstructorBlock = (Constructor) => {\n    if (!isFunction(Constructor)) {\n      this.elems = null;\n\n      return;\n    }\n\n    const {\n      htmlChildren,\n      dBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      Constructor,\n      attrs: dBlockArgs,\n      children: htmlChildren\n    }];\n  };\n}\n\nrootBlocks['d-block'] = DBlock;\n\nexport { DBlock };\n","import { Block } from '../Block';\n\nconst template = html`\n  <d-elements\n    value=\"{$$.htmlChildren}\"\n    parentScope=\"{this}\"\n    parentTemplate=\"{$$.parentTemplate}\"\n  />\n`;\n\nclass DItem extends Block {\n  static template = template;\n}\n\nexport { DItem };\n","import {\n  iterateArray, iterateObject,\n  isArray, isFunction, create\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\nimport { DItem } from './d-item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nrootBlocks['d-each'] = class DEach extends Block {\n  static defaultArgs = {\n    uid(item, index) {\n      return index;\n    }\n  };\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item = '$item',\n        index = '$index'\n      }\n    } = this;\n\n    this.itemName = item;\n    this.indexName = index;\n    this.itemsByUIDs = create(null);\n  }\n\n  afterConstruct() {\n    this.renderSet(this.evaluate(watchArgs, this.renderSet));\n  }\n\n  renderSet = (args) => {\n    let set = args[0];\n    let filterBy = args[1];\n    const sortBy = args[2];\n\n    const {\n      htmlChildren,\n      parentScope,\n      parentElem,\n      parentTemplate\n    } = this.$$;\n    const {\n      args: {\n        uid: UID\n      },\n      itemsByUIDs,\n      itemName,\n      indexName\n    } = this;\n    const newItemsByUIDs = create(null);\n    const newUIDsByIndexes = create(null);\n    const newUIDs = create(null);\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      const uid = UID(item, index, set, parentScope);\n\n      if (uid in newUIDsByIndexes) {\n        console.error(`UIDs can't be same for multiple items! In UID function: \"${ UID.original || UID }\"`);\n      }\n\n      newUIDsByIndexes[uid] = index;\n      newUIDs[index] = uid;\n    });\n\n    iterateObject(itemsByUIDs, (block, uid) => {\n      if (!(uid in newUIDsByIndexes)) {\n        remove(block);\n      }\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (newUIDsByIndexes[uid] !== index) {\n        return;\n      }\n\n      const prevUIDBlock = itemsByUIDs[uid];\n\n      if (prevUIDBlock) {\n        block = prevUIDBlock;\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        if (block.$$.prevBlock !== prevBlock) {\n          const { content } = block.$$;\n\n          if (prevBlock) {\n            prevBlock.$$.insertAfterIt(content, true);\n          } else {\n            this.$$.insertInStartOfIt(content, true);\n          }\n        }\n      } else {\n        block = createBlock({\n          node: {\n            itemName,\n            indexName,\n            item,\n            index,\n            name: '#d-item',\n            Constructor: DItem,\n            children: htmlChildren\n          },\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      newItemsByUIDs[uid] = block;\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.itemsByUIDs = newItemsByUIDs;\n  };\n};\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-elements'] = class DElements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, (value) => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n        if (forDElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n      iterateArray(this.$$.mixinsToBuild, (executeBuilders) => {\n        executeBuilders();\n      });\n      this.$$.mixinsToBuild = [];\n    }, this, true);\n  }\n};\n","import { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.if`;\n\nrootBlocks['d-if'] = class DIf extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    this.condition = false;\n    this.constructElems(this.evaluate(watchArgs, this.constructElems));\n  }\n\n  constructElems = (condition) => {\n    condition = !!condition;\n\n    if (this.condition !== condition) {\n      this.condition = condition;\n      this.elems = condition\n        ? this.$$.htmlChildren\n        : null;\n    }\n  };\n};\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`[\n  args.value,\n  args.compareFn\n]`;\n\nrootBlocks['d-switch'] = class DSwitch extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n  static defaultArgs = {\n    compareFn(switchValue, caseValue) {\n      return (\n        switchValue === caseValue\n        || (switchValue !== switchValue && caseValue !== caseValue)\n      );\n    }\n  };\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren,\n        parentScope\n      },\n      args,\n      args: { value }\n    } = this;\n    let wasDefault = false;\n\n    this.values = htmlChildren\n      .filter(({ name }) => {\n        if (name !== 'd-case' && name !== 'd-default') {\n          return;\n        }\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (name === 'd-default') {\n          wasDefault = true;\n        }\n\n        return true;\n      })\n      .map((child, i) => {\n        const {\n          name,\n          attrs = {},\n          children\n        } = child;\n        let val;\n\n        if (name !== 'd-default') {\n          val = parentScope.$$.evaluate(attrs.if, (newValue) => {\n            this.values[i].value = newValue;\n\n            if (i > this.index) {\n              return;\n            }\n\n            const found = findInArray(this.values, ({ name, value }) => (\n              name === 'd-default'\n              || this.args.compareFn(args.value, value)\n            ));\n\n            this.index = found\n              ? found.key\n              : Infinity;\n            this.elems = found\n              ? found.value.children\n              : null;\n          }, this);\n        }\n\n        if (this.index === Infinity && (\n          name === 'd-default'\n          || this.args.compareFn(value, val)\n        )) {\n          this.index = i;\n          this.elems = children;\n        }\n\n        return {\n          name,\n          children,\n          value: val\n        };\n      });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, (args) => {\n      const newValue = args[0];\n      const compareFn = args[1];\n\n      this.index = Infinity;\n\n      this.values.some(({ name, value, children }, i) => {\n        if (\n          name === 'd-default'\n          || compareFn(newValue, value)\n        ) {\n          this.index = i;\n          this.elems = children;\n\n          return true;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n};\n","import { isFunction, noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-bind'] = class DBind extends Mixin {\n  off = noop;\n\n  afterUpdate(value) {\n    this.off();\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n};\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nrootMixins['d-class'] = class DClass extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        classes\n      } = this;\n\n      elem.removeClass.apply(elem, classes);\n    }\n  }\n};\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-elem'] = class DElem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nclass DHide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n}\n\nrootMixins['d-hide'] = DHide;\n\nexport { DHide };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-node'] = class DNode extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n};\n","import { noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-on'] = class DOn extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-show'] = class DShow extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n};\n","import { iterateObject } from '../../utils';\nimport { rootMixins } from '../../constants';\nimport { constructMixinRegex } from './constructMixinRegex';\n\niterateObject(rootMixins, (Mixin, name) => {\n  Mixin._match = constructMixinRegex(name);\n});\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\nimport { document } from './constants';\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","isFunction","isNil","isString","assign","target","arguments","source","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","escapeRegex","string","replace","regexpSpecialsRegexp","noop","toCamelCase","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","toStringTag","toString","setToStringTag","klass","tag","Symbol","prototype","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","isXmlNs","nodeName","Null","XML_NS","X_LINK_ATTR_FIND_REGEX","test","Elem","closest","X_LINK_NS","X_LINK_ATTR_REPLACE_REGEX","isDocument","DOCUMENT_REGEX","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isValidNode","ELEMENT_REGEX","getEvent","event","bubbles","cancelable","realDetails","finalEvent","EVENT_REGEX","Event","err","document","ownerDocument","createEvent","initEvent","hide","addClass","getMatchesFunction","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","this","querySelectorAll","remove","parent","removeChild","show","removeClass","toElem","base","String","calculateArgs","normalizedArgs","args","argsObject","keys","arg","undefined","cleanProperty","constructMixinRegex","RegExp","mixinMatch","mixins","Mixin","localMatch","_match","argsMatch","COMMA_REGEX","transformRestAttrs","mixinDefaultOpts","eventualAttrs","D_REST_REGEX","transformRestArgs","addArgs","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","calculateAttrs","normalizedAttrs","attrsObject","firstTime","type","removeAttr","dynamic","opts","nextType","nextDynamic","nextValue","prevType","prevValue","prevDynamic","created","isDynamic","evaluated","evaluate","newValue","parentScope","constructMixinWatcher","setAfterUpdate","buildMixin","firstValue","push","normalizeArgs","argsChain","newArgs","constructPrivateScope","scope","globals","removeTempWatcher","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","evalMode","gettingVars","oldTempWatchers","createBlock","node","parentElem","parentBlock","parentTemplate","prevBlock","doc","namespaceURI","SVG_NS","localBlocks","ns","_blocks","Block","localMixins","_mixins","children","constructor","Constructor","dBlockMatch","dBlockName","dBlockArgs","NAMED_D_BLOCK_REGEX","blockInstance","error","element","currentAttrs","wasDRest","attrsChain","isDRest","localAttrs","restAttrs","mixinsToBuild","isParentBlock","childBlocks","on","iterateChildren","isRoot","child","content","into","contentDocument","documentElement","insertAfterIt","insertAfter","addContent","insertInStartOfIt","createDocumentFragment","emptyArray","Args","locals","html","template","itemName","item","indexName","afterConstruct","isRendered","executeBuilders","afterRender","isInstanceOf","Class","Subclass","isPrototypeOf","removeWithParentSignal","wrapBlock","block","wrapper","returnValue","wrapMixin","constructStyleFromString","style","CSS_STYLE_SEPARATOR_REGEX","trim","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","values","options","init","isMultiple","addValue","concat","getListenerName","selected","insertTemplates","templates","iterateAndChangeChildren","nodes","trimmed","newTemplates","newTemplate","newVars","initApp","container","rootBlock","removeApp","DwayneRootBlock","Array","defineProperties","Object","regexpSpecialCharacters","map","s","join","getProto","getPrototypeOf","setProto","setPrototypeOf","proto","__proto__","window","global","self","rootBlocks","rootMixins","CSS_IMPORTANT_REGEX","emptyCollection","_this","includes","methodName","method","elems","elements","classes","forEach","list","classList","cls","attributes","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","cb","contains","el","isText","createTextNode","createComment","createElementNS","createElement","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","details","dispatchEvent","filter","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","props","first","prev","babelHelpers.get","apply","textContent","condition","_arguments","_arguments2","species","comment","afterUpdate","_value","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","isElementRemoved","blockHooks","mixinHooks","TAG_NAME_REGEX","ATTR_NAME_REGEX","afterElem","emptyObject","originalArgs","childrenBlocks","func","onChange","targetBlock","forDElements","forDItem","_this7","onChangeFlag","result","original","onEvalError","e","localWatchers","watcherBlock","newResult","removeContent","newContent","afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","warn","currentReturnValue","watchNameArgs","watchConstructorArgs","DBlock","constructDynamicNameBlock","htmlChildren","constructDynamicConstructorBlock","parentParentScope","parentParentTemplate","ownChildren","DBlockName","found","ParentScope","ParentTemplate","dBlocks","DItem","watchArgs","itemsByUIDs","renderSet","set","filterBy","sortBy","_this2","UID","uid","newItemsByUIDs","newUIDsByIndexes","newUIDs","isArr","iterate","sort","prevUIDBlock","constructElems","Infinity","wasDefault","val","if","compareFn","some","switchValue","caseValue","off","newClasses","DHide","Boolean","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvaXMuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL2VzY2FwZVJlZ2V4LmpzIiwiLi4vc3JjL3V0aWxzL25vb3AuanMiLCIuLi9zcmMvdXRpbHMvdG9DYXNlLmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRBdHRyLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRDU1NQcm9wLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGREYXRhQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkTmV4dC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUGFyZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRQcmV2LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9jcmVhdGVIaWRlU3R5bGVOb2RlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRBdHRyTlMuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRFdmVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaGlkZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vbWF0Y2hlcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9zaG93LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS90b0VsZW0uanMiLCIuLi9zcmMvZmluZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jbGVhblByb3BlcnR5LmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0TWl4aW5SZWdleC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL21peGluTWF0Y2guanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay90cmFuc2Zvcm1SZXN0QXR0cnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9leGVjdXRlTWl4aW5XYXRjaGVycy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUF0dHJzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svbm9ybWFsaXplQXJncy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NvbnN0cnVjdFByaXZhdGVTY29wZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlbW92ZVdhdGNoZXIuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jb25zdHJ1Y3RQdWJsaWNTY29wZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NyZWF0ZUJsb2NrLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svaXNJbnN0YW5jZU9mLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svd3JhcC5qcyIsIi4uL3NyYy9taXhpbnMvZC1zdHlsZS5qcyIsIi4uL3NyYy9taXhpbnMvZC12YWx1ZS5qcyIsIi4uL3NyYy9pbnNlcnRUZW1wbGF0ZXMuanMiLCIuLi9zcmMvaW5pdEFwcC5qcyIsIi4uL3NyYy9yZW1vdmVBcHAuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0U3RhdGljcy5qcyIsIi4uL3NyYy9nbG9iYWwuanMiLCIuLi9zcmMvY29uc3RhbnRzLmpzIiwiLi4vc3JjL0VsZW0uanMiLCIuLi9zcmMvdXRpbHMvc2V0U3ltYm9sU3BlY2llcy5qcyIsIi4uL3NyYy9NaXhpbi5qcyIsIi4uL3NyYy9CbG9jay5qcyIsIi4uL3NyYy9ibG9ja3MvZC1ibG9jay5qcyIsIi4uL3NyYy9ibG9ja3MvZC1pdGVtLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWVhY2guanMiLCIuLi9zcmMvYmxvY2tzL2QtZWxlbWVudHMuanMiLCIuLi9zcmMvYmxvY2tzL2QtaWYuanMiLCIuLi9zcmMvYmxvY2tzL2Qtc3dpdGNoLmpzIiwiLi4vc3JjL21peGlucy9kLWJpbmQuanMiLCIuLi9zcmMvbWl4aW5zL2QtY2xhc3MuanMiLCIuLi9zcmMvbWl4aW5zL2QtZWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvZC1oaWRlLmpzIiwiLi4vc3JjL21peGlucy9kLW5vZGUuanMiLCIuLi9zcmMvbWl4aW5zL2Qtb24uanMiLCIuLi9zcmMvbWl4aW5zL2Qtc2hvdy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlZ2lzdGVyQnVpbHRpbnMuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiZXhwb3J0IGNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSB9IGZyb20gJy4vYXJyYXknO1xuXG5jb25zdCB7XG4gIGhhc093blByb3BlcnR5OiBoYXNcbn0gPSB7fTtcbmNvbnN0IHsgc2xpY2UgfSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoc291cmNlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaXRlcmF0ZU9iamVjdChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0RnJvbU9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBrZXksIG9iamVjdCk7XG4gIH0pO1xuXG4gIHJldHVybiBpbml0aWFsVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGNlcHQob2JqZWN0KSB7XG4gIGNvbnN0IG5ld09iamVjdCA9IHt9O1xuICBjb25zdCBwYXRocyA9IGFyZ3VtZW50czo6c2xpY2UoMSk7XG5cbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHBhdGhzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIG5ld09iamVjdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdDo6aGFzKGtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpdGVyYXRlT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5ld09iamVjdCA9IHt9O1xuXG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIG5ld09iamVjdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuL29iamVjdCc7XG5cbmV4cG9ydCBjb25zdCB7IGRlZmluZVByb3BlcnRpZXMgfSA9IE9iamVjdDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lRnJvemVuUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgaXRlcmF0ZU9iamVjdChwcm9wZXJ0aWVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9KTtcbn1cbiIsImNvbnN0IHJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gW1xuICAnLicsXG4gICcrJywgJyonLCAnPycsXG4gICcoJywgJyknLFxuICAnWycsICddJyxcbiAgJ3snLCAnfScsXG4gICc8JywgJz4nLFxuICAnXicsICckJyxcbiAgJyEnLFxuICAnPScsXG4gICc6JyxcbiAgJy0nLFxuICAnfCcsXG4gICcsJyxcbiAgJ1xcXFwnXG5dO1xuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxuICByZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xuICAgIC5tYXAoKHMpID0+IGBcXFxcJHsgcyB9YClcbiAgICAuam9pbignfCcpLFxuICAnZydcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImltcG9ydCB7IGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHt9O1xuXG4vKipcbiAqIEBmdW5jdGlvbiB0b1N0cmluZ1RhZ1xuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gZ2V0IHRvU3RyaW5nVGFnIG9mLlxuICogQHJldHVybnMge1N0cmluZ30gQ3V0IHN0cmluZy5cbiAqIEBkZXNjcmlwdGlvbiBDdXQgXCJUeXBlXCIgc3RyaW5nIGZyb20gXCJbb2JqZWN0IFR5cGVdXCIgc3RyaW5nIHRoYXQgZ290dGVuIGZyb20ge30udG9TdHJpbmcsY2FsbChvYmplY3QpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3Q6OnRvU3RyaW5nKCkuc2xpY2UoOCwgLTEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG9TdHJpbmdUYWcoa2xhc3MsIHRhZykge1xuICBpZiAoU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyhrbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiB0YWdcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZEF0dHIoYXR0cnMsIGF0dHIpIHtcbiAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG59XG4iLCJpbXBvcnQgeyB0b0NhbWVsQ2FzZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuY29uc3QgQ1NTX1BST1BfVkFMVUVfU0VQQVJBVE9SX1JFR0VYID0gLzogLztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENTU1Byb3AoY3NzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHZhbHVlLnNwbGl0KENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCk7XG5cbiAgICBjc3NbdG9DYW1lbENhc2UocHJvcGVydHlbMF0pXSA9IHByb3BlcnR5WzFdO1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkRGF0YUF0dHIoZGF0YSwgdmFsdWUsIGtleSkge1xuICBkYXRhW2tleV0gPSB2YWx1ZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGROZXh0KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5uZXh0U2libGluZyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUGFyZW50KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wYXJlbnROb2RlKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRQcmV2KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wcmV2aW91c1NpYmxpbmcpO1xufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpIHtcbiAgY29uc3Qgc3R5bGUgPSBoZWFkLmZpbmQoYHN0eWxlIyR7IEhJREVfQ0xBU1MgfWApO1xuXG4gIGlmIChzdHlsZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoZWFkXG4gICAgLmNyZWF0ZSgnc3R5bGUnKVxuICAgIC5wcm9wKCdpZCcsIEhJREVfQ0xBU1MpXG4gICAgLnRleHQoYC4keyBISURFX0NMQVNTIH17ZGlzcGxheTpub25lICFpbXBvcnRhbnQ7fWApO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5jb25zdCBYX0xJTktfQVRUUl9GSU5EX1JFR0VYID0gL154bGluazpcXHcvO1xuY29uc3QgWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCA9IC9eeGxpbms6LztcbmNvbnN0IFhNTF9OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XG5jb25zdCBYX0xJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBOdWxsID0ge1xuICBuczogbnVsbFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJOUyhhdHRyLCBlbGVtKSB7XG4gIGNvbnN0IGlzWG1sTnMgPSBhdHRyID09PSAneG1sbnMnO1xuXG4gIGlmIChpc1htbE5zIHx8IGF0dHIgPT09ICd4bWxuczp4bGluaycpIHtcbiAgICBpZiAoZWxlbS5ub2RlTmFtZSAhPT0gJ1NWRycpIHtcbiAgICAgIHJldHVybiBOdWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuczogWE1MX05TLFxuICAgICAgbmFtZTogaXNYbWxOc1xuICAgICAgICA/ICd4bWxucydcbiAgICAgICAgOiAneGxpbmsnXG4gICAgfTtcbiAgfVxuXG4gIGlmIChYX0xJTktfQVRUUl9GSU5EX1JFR0VYLnRlc3QoYXR0cikpIHtcbiAgICBpZiAoIW5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJ3N2ZycpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIE51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5zOiBYX0xJTktfTlMsXG4gICAgICBuYW1lOiBhdHRyLnJlcGxhY2UoWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCwgJycpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBOdWxsO1xufVxuIiwiaW1wb3J0IHsgdG9TdHJpbmdUYWcsIGlzQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmNvbnN0IEhUTUxfQ09MTEVDVElPTl9SRUdFWCA9IC9eKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0KSQvO1xuY29uc3QgRE9DVU1FTlRfUkVHRVggPSAvRG9jdW1lbnQkLztcbmNvbnN0IEVMRU1FTlRfUkVHRVggPSAvRWxlbWVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEb2N1bWVudCh2YWx1ZSkge1xuICByZXR1cm4gRE9DVU1FTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRzQ29sbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIEhUTUxfQ09MTEVDVElPTl9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKHZhbHVlKSlcbiAgICB8fCBpc0VsZW0odmFsdWUpXG4gICAgfHwgaXNBcnJheSh2YWx1ZSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROb2RlKHZhbHVlKSB7XG4gIGNvbnN0IHRhZyA9IHRvU3RyaW5nVGFnKHZhbHVlKTtcblxuICByZXR1cm4gKFxuICAgIEVMRU1FTlRfUkVHRVgudGVzdCh0YWcpXG4gICAgfHwgRE9DVU1FTlRfUkVHRVgudGVzdCh0YWcpXG4gICAgfHwgdGFnID09PSAnVGV4dCdcbiAgICB8fCB0YWcgPT09ICdEb2N1bWVudEZyYWdtZW50J1xuICAgIHx8IHRhZyA9PT0gJ0NvbW1lbnQnXG4gICk7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24sIHRvU3RyaW5nVGFnIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4vaXMnO1xuXG5jb25zdCBFVkVOVF9SRUdFWCA9IC9FdmVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHJlYWxEZXRhaWxzLCBlbGVtKSB7XG4gIGxldCBmaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgaWYgKCFFVkVOVF9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKGZpbmFsRXZlbnQpKSkge1xuICAgIHRyeSB7XG4gICAgICBmaW5hbEV2ZW50ID0gbmV3IEV2ZW50KGZpbmFsRXZlbnQsIHsgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbiAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBmaW5hbEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBmaW5hbEV2ZW50LmluaXRFdmVudChldmVudCwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cbiAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsRXZlbnQ7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVIaWRlU3R5bGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVIaWRlU3R5bGVOb2RlJztcbmltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaGlkZShlbGVtKSB7XG4gIGNyZWF0ZUhpZGVTdHlsZU5vZGUobmV3IEVsZW0oZWxlbS5vd25lckRvY3VtZW50LmhlYWQpKTtcbiAgbmV3IEVsZW0oZWxlbSkuYWRkQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0RvY3VtZW50IH0gZnJvbSAnLi9pcyc7XG5cbmNvbnN0IHsgaW5kZXhPZiB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSkge1xuICByZXR1cm4gKFxuICAgIGVsZW0ubWF0Y2hlc1xuICAgIHx8IGVsZW0ubWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm1vek1hdGNoZXNTZWxlY3RvclxuICAgIHx8IGVsZW0ubXNNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm9NYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBtYXRjaGVzXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcbiAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KHRoaXMpXG4gICAgPyB0aGlzXG4gICAgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOjppbmRleE9mKHRoaXMpICE9PSAtMTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWxlbSkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93KGVsZW0pIHtcbiAgbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0VsZW0gfSBmcm9tICcuL2lzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvRWxlbShlbGVtKSB7XG4gIHJldHVybiBpc0VsZW0oZWxlbSlcbiAgICA/IGVsZW1cbiAgICA6IG5ldyBFbGVtKGVsZW0pO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZmluZFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBbYmFzZSA9IGRvY3VtZW50XSAtIEJhc2UgdG8gZmluZCBpbi5cbiAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICogW0RvY3VtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGJhc2UgPSBkb2N1bWVudCkge1xuICByZXR1cm4gbmV3IEVsZW0oYmFzZS5xdWVyeVNlbGVjdG9yQWxsKFN0cmluZyhzZWxlY3RvcikpKTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCwga2V5cyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFyZ3Mobm9ybWFsaXplZEFyZ3MsIGFyZ3MsIGFyZ3NPYmplY3QpIHtcbiAgaXRlcmF0ZUFycmF5KGtleXMoYXJnc09iamVjdCksIChhcmcpID0+IHtcbiAgICBpZiAoIShhcmcgaW4gYXJncykpIHtcbiAgICAgIGFyZ3NPYmplY3RbYXJnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIGl0ZXJhdGVPYmplY3Qobm9ybWFsaXplZEFyZ3MsICh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgYXJnc09iamVjdFthcmddID0gdmFsdWU7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsZWFuUHJvcGVydHkodmFsdWUsIGFyZywgb2JqZWN0KSB7XG4gIGRlbGV0ZSBvYmplY3RbYXJnXTtcbn1cbiIsImltcG9ydCB7IGVzY2FwZVJlZ2V4IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHsgZXNjYXBlUmVnZXgobmFtZSkgfSg/OlxcXFwoKFteXFxcXCldKilcXFxcKSk/KD86IyhbXFxcXHNcXFxcU10qKSk/JGApO1xufVxuIiwiY29uc3QgQ09NTUFfUkVHRVggPSAvLC87XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbk1hdGNoKG1peGlucywgYXR0cikge1xuICBsZXQgbWF0Y2g7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4gIGZvciAoY29uc3QgbmFtZSBpbiBtaXhpbnMpIHtcbiAgICBjb25zdCBNaXhpbiA9IG1peGluc1tuYW1lXTtcbiAgICBjb25zdCBsb2NhbE1hdGNoID0gYXR0ci5tYXRjaChNaXhpbi5fbWF0Y2gpO1xuXG4gICAgaWYgKGxvY2FsTWF0Y2gpIHtcbiAgICAgIGNvbnN0IGFyZ3NNYXRjaCA9IGxvY2FsTWF0Y2hbMV07XG4gICAgICBsZXQgYXJncztcblxuICAgICAgaWYgKGFyZ3NNYXRjaCA9PT0gJycpIHtcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChhcmdzTWF0Y2gpIHtcbiAgICAgICAgYXJncyA9IGFyZ3NNYXRjaC5zcGxpdChDT01NQV9SRUdFWCk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0ge1xuICAgICAgICBhcmdzLFxuICAgICAgICBjb21tZW50OiBsb2NhbE1hdGNoWzJdLFxuICAgICAgICBNaXhpbixcbiAgICAgICAgbmFtZVxuICAgICAgfTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuIiwiaW1wb3J0IHsgY29sbGVjdEZyb21PYmplY3QsIGFzc2lnbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IERfUkVTVF9SRUdFWCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBtaXhpbk1hdGNoIH0gZnJvbSAnLi9taXhpbk1hdGNoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3RBdHRycyhhdHRycywgbWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzKSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChhdHRycywgKGV2ZW50dWFsQXR0cnMsIHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgaWYgKERfUkVTVF9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgICByZXR1cm4gYXNzaWduKGV2ZW50dWFsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyh2YWx1ZSwgbWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBtaXhpbk1hdGNoKG1peGlucywgYXR0cik7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGV2ZW50dWFsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgIHR5cGU6ICdtaXhpbicsXG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIG9wdHM6IHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAuLi5taXhpbkRlZmF1bHRPcHRzXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnR1YWxBdHRyc1thdHRyXSA9IHtcbiAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SZXN0QXJncyhhcmdzKSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChhcmdzLCBhZGRBcmdzKTtcbn1cblxuZnVuY3Rpb24gYWRkQXJncyhhcmdzLCB2YWx1ZSwgYXJnKSB7XG4gIGlmIChEX1JFU1RfUkVHRVgudGVzdChhcmcpKSB7XG4gICAgYXNzaWduKGFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1thcmddID0gdmFsdWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSkge1xuICBjb25zdCBvbGRWYWx1ZSA9IG1peGluLiQkLnZhbHVlO1xuXG4gIG1peGluLiQkLnZhbHVlID0gdmFsdWU7XG5cbiAgaXRlcmF0ZUFycmF5KG1peGluLiQkLndhdGNoZXJzLCAod2F0Y2hlcikgPT4ge1xuICAgIHdhdGNoZXIodmFsdWUsIG9sZFZhbHVlKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBleGVjdXRlTWl4aW5XYXRjaGVycyB9IGZyb20gJy4vZXhlY3V0ZU1peGluV2F0Y2hlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXR0cnMobm9ybWFsaXplZEF0dHJzLCBhdHRycywgYXR0cnNPYmplY3QsIGVsZW0sIGZpcnN0VGltZSkge1xuICBpdGVyYXRlT2JqZWN0KGF0dHJzT2JqZWN0LCAoeyB0eXBlLCB2YWx1ZSB9LCBhdHRyKSA9PiB7XG4gICAgaWYgKCEoYXR0ciBpbiBhdHRycykpIHtcbiAgICAgIGlmICh0eXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUuJCQucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBhdHRyc09iamVjdFthdHRyXTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG1peGlucyA9IFtdO1xuXG4gIGl0ZXJhdGVPYmplY3Qobm9ybWFsaXplZEF0dHJzLCAoeyB0eXBlLCBkeW5hbWljLCB2YWx1ZSwgb3B0cyB9LCBhdHRyKSA9PiB7XG4gICAgbGV0IG5leHRUeXBlO1xuICAgIGxldCBuZXh0RHluYW1pYztcbiAgICBsZXQgbmV4dFZhbHVlO1xuXG4gICAgaWYgKGF0dHJzT2JqZWN0W2F0dHJdKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGU6IHByZXZUeXBlLFxuICAgICAgICB2YWx1ZTogcHJldlZhbHVlLFxuICAgICAgICBkeW5hbWljOiBwcmV2RHluYW1pY1xuICAgICAgfSA9IGF0dHJzT2JqZWN0W2F0dHJdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ21peGluJykge1xuICAgICAgICAgIHByZXZWYWx1ZS4kJC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG1peGluID0gcHJldlZhbHVlO1xuICAgICAgICBsZXQgY3JlYXRlZDtcblxuICAgICAgICBpZiAocHJldlR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcblxuICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgIG9wdHMuZHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgICAgbWl4aW4gPSBuZXcgb3B0cy5NaXhpbihvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaXhpbi4kJC5pc0R5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtaXhpbi4kJC5ldmFsdWF0ZWQgJiYgb3B0cy5NaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbWl4aW4uJCQucGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNvbnN0cnVjdE1peGluV2F0Y2hlcihtaXhpbiwgYXR0ciwgYXR0cnMpLFxuICAgICAgICAgICAgbWl4aW5cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgbWl4aW4uJCQuZXZhbHVhdGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldkR5bmFtaWMgJiYgb3B0cy5NaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBtaXhpbi4kJC5wYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG5cbiAgICAgICAgaWYgKGNyZWF0ZWQpIHtcbiAgICAgICAgICBtaXhpbi4kJC5zZXRBZnRlclVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRUeXBlID0gdHlwZTtcbiAgICAgIG5leHREeW5hbWljID0gZHluYW1pYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuXG4gICAgICAgIG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVpbGRNaXhpbiA9ICgpID0+IHtcbiAgICAgICAgICBvcHRzLmR5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgICAgICAgY29uc3QgbWl4aW4gPSBuZXcgb3B0cy5NaXhpbihvcHRzKTtcblxuICAgICAgICAgIGlmICghZHluYW1pYyAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IG9wdHM7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RNaXhpbldhdGNoZXIobWl4aW4sIGF0dHIsIGF0dHJzKSxcbiAgICAgICAgICAgICAgbWl4aW5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG1peGluLiQkLmV2YWx1YXRlZCA9IHRydWU7XG4gICAgICAgICAgICBtaXhpbi4kJC52YWx1ZSA9IGZpcnN0VmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG4gICAgICAgICAgbWl4aW4uJCQuc2V0QWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkeW5hbWljLFxuICAgICAgICAgICAgICB2YWx1ZTogbWl4aW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICBtaXhpbnMucHVzaChidWlsZE1peGluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsZE1peGluKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFR5cGUgPSB0eXBlO1xuICAgICAgbmV4dER5bmFtaWMgPSBkeW5hbWljO1xuICAgIH1cblxuICAgIGF0dHJzT2JqZWN0W2F0dHJdID0ge1xuICAgICAgdHlwZTogbmV4dFR5cGUsXG4gICAgICBkeW5hbWljOiBuZXh0RHluYW1pYyxcbiAgICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgICB9O1xuICB9KTtcblxuICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIChidWlsZE1peGluKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhdHRyLFxuICAgICAgICAgIG9wdHNcbiAgICAgICAgfSA9IGJ1aWxkTWl4aW4oKTtcblxuICAgICAgICBhdHRyc09iamVjdFthdHRyXSA9IG9wdHM7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdE1peGluV2F0Y2hlcihtaXhpbiwgYXR0ciwgYXR0cnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBkeW5hbWljXG4gICAgfSA9IGF0dHJzW2F0dHJdO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQXJncyhhcmdzQ2hhaW4pIHtcbiAgY29uc3QgbmV3QXJncyA9IHt9O1xuXG4gIGl0ZXJhdGVBcnJheShhcmdzQ2hhaW4sIChhcmdzKSA9PiB7XG4gICAgaXRlcmF0ZU9iamVjdChhcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgbmV3QXJnc1thcmddID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdBcmdzO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlLCBjb2xsZWN0RnJvbU9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IGNyZWF0ZShcbiAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgID8gcGFyZW50U2NvcGUuJCQuZ2xvYmFsc1xuICAgICAgICA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IFtdXG4gICAgfTtcbiAgfSwgc2NvcGUpO1xufVxuIiwiaW1wb3J0IHsgcmVtb3ZlQXJyYXlFbGVtLCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUZW1wV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHdhdGNoZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcbiAgaXRlcmF0ZUFycmF5KHdhdGNoZXJzVG9SZW1vdmUsIHJlbW92ZVdhdGNoZXIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVXYXRjaGVyKHsgd2F0Y2hlciwgd2F0Y2hlcnMgfSkge1xuICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgbWFwT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBnZXR0aW5nVmFycywgZXZhbE1vZGUgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyByZW1vdmVUZW1wV2F0Y2hlciB9IGZyb20gJy4vcmVtb3ZlV2F0Y2hlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCBtYXBPYmplY3Qoc2NvcGVWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKGdldHRpbmdWYXJzLmluZGV4T2Yoc2NvcGUud2F0Y2hlcnMpID09PSAtMSkge1xuICAgICAgICAgICAgZ2V0dGluZ1ZhcnMucHVzaChzY29wZS53YXRjaGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHNjb3BlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2xkVGVtcFdhdGNoZXJzID0gc2NvcGUud2F0Y2hlcnMuc2xpY2UoKTtcblxuICAgICAgICBzY29wZS53YXRjaGVycyA9IFtdO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheShvbGRUZW1wV2F0Y2hlcnMsIHJlbW92ZVRlbXBXYXRjaGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSk7XG59XG4iLCJpbXBvcnQge1xuICBleGNlcHQsIGNyZWF0ZSwgYXNzaWduLFxuICBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXksXG4gIGlzTmlsXG59IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGlzRG9jdW1lbnQgfSBmcm9tICcuLi9FbGVtJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcbmltcG9ydCB7XG4gIFNWR19OUywgRF9SRVNUX1JFR0VYXG59IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjbGVhblByb3BlcnR5IH0gZnJvbSAnLi9jbGVhblByb3BlcnR5JztcbmltcG9ydCB7IHRyYW5zZm9ybVJlc3RBdHRycyB9IGZyb20gJy4vdHJhbnNmb3JtUmVzdEF0dHJzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUF0dHJzIH0gZnJvbSAnLi9jYWxjdWxhdGVBdHRycyc7XG5pbXBvcnQgeyBub3JtYWxpemVBcmdzIH0gZnJvbSAnLi9ub3JtYWxpemVBcmdzJztcbmltcG9ydCB7IG1peGluTWF0Y2ggfSBmcm9tICcuL21peGluTWF0Y2gnO1xuaW1wb3J0IHsgY29uc3RydWN0UHJpdmF0ZVNjb3BlIH0gZnJvbSAnLi9jb25zdHJ1Y3RQcml2YXRlU2NvcGUnO1xuaW1wb3J0IHsgY29uc3RydWN0UHVibGljU2NvcGUgfSBmcm9tICcuL2NvbnN0cnVjdFB1YmxpY1Njb3BlJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuXG5jb25zdCBOQU1FRF9EX0JMT0NLX1JFR0VYID0gL15kLWJsb2NrOihbXFxzXFxTXSspJC87XG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCbG9jayh7IG5vZGUsIHBhcmVudCwgcGFyZW50RWxlbSwgcGFyZW50QmxvY2ssIHBhcmVudFNjb3BlLCBwYXJlbnRUZW1wbGF0ZSwgcHJldkJsb2NrIH0pIHtcbiAgY29uc3QgZG9jID0gaXNEb2N1bWVudChwYXJlbnRFbGVtWzBdKVxuICAgID8gcGFyZW50RWxlbVxuICAgIDogbmV3IEVsZW0ocGFyZW50RWxlbVswXS5vd25lckRvY3VtZW50KTtcbiAgY29uc3QgZWxlbSA9IHBhcmVudEVsZW1bMF0ubmFtZXNwYWNlVVJJID09PSBTVkdfTlNcbiAgICA/IGRvYy5jcmVhdGUoJ3N2ZycpXG4gICAgOiBkb2M7XG4gIGNvbnN0IGxvY2FsQmxvY2tzID0gcGFyZW50VGVtcGxhdGUgPyBwYXJlbnRUZW1wbGF0ZS4kJC5ucy5fYmxvY2tzIDogQmxvY2suX2Jsb2NrcztcbiAgY29uc3QgbG9jYWxNaXhpbnMgPSBwYXJlbnRUZW1wbGF0ZSA/IHBhcmVudFRlbXBsYXRlLiQkLm5zLl9taXhpbnMgOiBCbG9jay5fbWl4aW5zO1xuICBjb25zdCBhcmdzID0gbm9kZS5hdHRycyB8fCB7fTtcbiAgY29uc3QgbmFtZSA9IG5vZGUubmFtZSB8fCAnVW5rbm93bkJsb2NrJztcbiAgbGV0IHsgY2hpbGRyZW4gfSA9IG5vZGU7XG4gIGxldCBjb25zdHJ1Y3RvciA9IG5vZGUuQ29uc3RydWN0b3IgfHwgKG5vZGUubmFtZSAmJiBsb2NhbEJsb2Nrc1tub2RlLm5hbWVdKTtcbiAgbGV0IGRCbG9ja01hdGNoO1xuICBsZXQgZEJsb2NrTmFtZTtcbiAgbGV0IGRCbG9ja0FyZ3M7XG5cbiAgaWYgKG5hbWUgPT09ICdkLWJsb2NrJyAmJiBhcmdzLm5hbWUpIHtcbiAgICBkQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICduYW1lJyk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2QtYmxvY2snICYmIGFyZ3MuQ29uc3RydWN0b3IpIHtcbiAgICBkQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICdDb25zdHJ1Y3RvcicpO1xuICB9IGVsc2UgaWYgKChkQmxvY2tNYXRjaCA9IG5hbWUubWF0Y2goTkFNRURfRF9CTE9DS19SRUdFWCkpIHx8IG5hbWUgPT09ICdkLWJsb2NrJykge1xuICAgIGNvbnN0cnVjdG9yID0gQmxvY2suX2Jsb2Nrc1snZC1ibG9jayddO1xuICAgIGRCbG9ja05hbWUgPSBkQmxvY2tNYXRjaCA/IGRCbG9ja01hdGNoWzFdIDogbnVsbDtcbiAgfVxuXG4gIGxldCBibG9ja0luc3RhbmNlO1xuXG4gIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgIHRyeSB7XG4gICAgICBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrQXJncyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgcHJldkJsb2NrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluIG5ldyAkeyBuYW1lIH06YCwgZXJyKTtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtLmNyZWF0ZShuYW1lKTtcbiAgICBjb25zdCBjdXJyZW50QXR0cnMgPSBjcmVhdGUobnVsbCk7XG4gICAgbGV0IGF0dHJzID0gY3JlYXRlKG51bGwpO1xuICAgIGxldCB3YXNEUmVzdDtcbiAgICBjb25zdCBhdHRyc0NoYWluID0gW2F0dHJzXTtcbiAgICBjb25zdCBtaXhpbkRlZmF1bHRPcHRzID0ge1xuICAgICAgZWxlbTogZWxlbWVudCxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH07XG5cbiAgICBpdGVyYXRlT2JqZWN0KGFyZ3MsICh2YWx1ZSwgYXR0cikgPT4ge1xuICAgICAgY29uc3QgaXNEUmVzdCA9IERfUkVTVF9SRUdFWC50ZXN0KGF0dHIpO1xuICAgICAgY29uc3QgbG9jYWxBdHRycyA9IGlzRFJlc3QgfHwgd2FzRFJlc3RcbiAgICAgICAgPyBjcmVhdGUoYXR0cnMpXG4gICAgICAgIDogYXR0cnM7XG5cbiAgICAgIGlmIChhdHRycyAhPT0gbG9jYWxBdHRycykge1xuICAgICAgICBhdHRyc0NoYWluLnB1c2gobG9jYWxBdHRycyk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzID0gbG9jYWxBdHRycztcblxuICAgICAgaWYgKGlzRFJlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdEF0dHJzID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGl0ZXJhdGVPYmplY3QobG9jYWxBdHRycywgY2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbG9jYWxNaXhpbnMsXG4gICAgICAgICAgICBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgKSk7XG4gICAgICAgICAgY2FsY3VsYXRlQXR0cnMobm9ybWFsaXplQXJncyhhdHRyc0NoYWluKSwgYXR0cnMsIGN1cnJlbnRBdHRycywgZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgICAgd2FzRFJlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBdHRycywgdHJhbnNmb3JtUmVzdEF0dHJzKFxuICAgICAgICAgIHJlc3RBdHRycywgbG9jYWxNaXhpbnMsIG1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gbWl4aW5NYXRjaChsb2NhbE1peGlucywgYXR0cik7XG5cbiAgICAgIHdhc0RSZXN0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICAgIHR5cGU6ICdtaXhpbicsXG4gICAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAgIC4uLm1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICB0eXBlOiAnYXR0cicsXG4gICAgICAgIHZhbHVlOiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxjdWxhdGVBdHRycyhub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLCBhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH0sIHBhcmVudEJsb2NrKVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHBhcmVudEJsb2NrLiQkLm1peGluc1RvQnVpbGQucHVzaChjYWxjdWxhdGVBdHRycyhub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLCBhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCB0cnVlKSk7XG5cbiAgICBpZiAobmFtZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgZWxlbWVudC50ZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgbGV0IHRleHQgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC50ZXh0KGAkeyB2YWx1ZSB9YCk7XG4gICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgIGlmIChpc05pbCh0ZXh0KSkge1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQudGV4dChgJHsgdGV4dCB9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuICAgIGNvbnN0IGNoaWxkQmxvY2tzID0gW107XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAobmFtZSA9PT0gJ2lmcmFtZScgJiYgISgnc3JjJyBpbiBhdHRycykpIHtcbiAgICAgIGVsZW1lbnQub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbWVudFswXS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuICAgICAgICBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnJlbW92ZSgpO1xuICAgICAgICBpdGVyYXRlQ2hpbGRyZW4oY2hpbGRCbG9ja3MsIHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVDaGlsZHJlbihjaGlsZHJlbiwgaXNSb290KSB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC4kJC5wYXJlbnRFbGVtID0gZG9jO1xuICAgICAgICAgICAgICAgIGNoaWxkLiQkLnBhcmVudCA9IGRvYztcbiAgICAgICAgICAgICAgICBjaGlsZC4kJC5jb250ZW50LmludG8oZG9jKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGl0ZXJhdGVDaGlsZHJlbihjaGlsZC4kJC5jaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGQuaW50byhkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgZWxlbWVudC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChlbGVtZW50LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZXQgcHJldkJsb2NrO1xuICAgICAgbGV0IHBhcmVudEVsZW0gPSBlbGVtZW50O1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChuYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShlbGVtZW50WzBdLmNvbnRlbnQgPSBlbGVtZW50WzBdLmNvbnRlbnQgfHwgZG9jWzBdLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAgIGlmICgnc3JjJyBpbiBhdHRycykge1xuICAgICAgICAgIGNoaWxkcmVuID0gZW1wdHlBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGVsZW1lbnRbMF0uY29udGVudERvY3VtZW50O1xuXG4gICAgICAgICAgbmV3IEVsZW0oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5yZW1vdmUoKTtcblxuICAgICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRCbG9ja3MucHVzaChwcmV2QmxvY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBjb25zdCB7XG4gICAgJCQsXG4gICAgYXJnczogQXJncyxcbiAgICBnbG9iYWxzLFxuICAgIC4uLmxvY2Fsc1xuICB9ID0gYmxvY2tJbnN0YW5jZTtcblxuICBjb25zdCBodG1sID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnZhbHVlIHx8IFtdXG4gICAgOiBjb25zdHJ1Y3Rvci50ZW1wbGF0ZS52YWx1ZSB8fCBjb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcblxuICAkJC5hcmdzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKEFyZ3MpO1xuICAkJC5sb2NhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUobG9jYWxzKTtcbiAgJCQuZ2xvYmFscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShnbG9iYWxzLCAnZ2xvYmFscycsIHBhcmVudFNjb3BlKTtcblxuICBpZiAobmFtZSA9PT0gJyNkLWl0ZW0nKSB7XG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcbiAgICAgIFtub2RlLmluZGV4TmFtZV06IG5vZGUuaW5kZXhcbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gcGFyZW50U2NvcGUuJCQubmFtZSA9PT0gJyNkLWl0ZW0nXG4gICAgICA/IHBhcmVudFNjb3BlLiQkLnNjb3BlXG4gICAgICA6IHBhcmVudFNjb3BlO1xuXG4gICAgJCQubnMgPSBwYXJlbnRTY29wZS4kJC5ucztcbiAgICAkJC5wcml2YXRlU2NvcGUgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoc2NvcGVWYWx1ZXMpO1xuICAgIGNvbnN0cnVjdFB1YmxpY1Njb3BlKCQkLnNjb3BlID0gY3JlYXRlKHNjb3BlKSwgc2NvcGVWYWx1ZXMsICQkLnByaXZhdGVTY29wZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShBcmdzLCBBcmdzLCAkJC5hcmdzKTtcbiAgY29uc3RydWN0UHVibGljU2NvcGUoZ2xvYmFscywgZ2xvYmFscywgJCQuZ2xvYmFscyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGJsb2NrSW5zdGFuY2UsIGxvY2FscywgJCQubG9jYWxzKTtcblxuICB0cnkge1xuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJDb25zdHJ1Y3QoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyQ29uc3RydWN0OmAsIGVycik7XG4gIH1cblxuICBwcmV2QmxvY2sgPSB1bmRlZmluZWQ7XG4gIHBhcmVudFNjb3BlID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnBhcmVudFNjb3BlXG4gICAgOiBibG9ja0luc3RhbmNlO1xuICBwYXJlbnRUZW1wbGF0ZSA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy5wYXJlbnRUZW1wbGF0ZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcblxuICBpdGVyYXRlQXJyYXkoaHRtbCwgKGNoaWxkKSA9PiB7XG4gICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXJlbnQ6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50QmxvY2s6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgcHJldkJsb2NrXG4gICAgfSk7XG4gIH0pO1xuXG4gIGJsb2NrSW5zdGFuY2UuJCQuaXNSZW5kZXJlZCA9IHRydWU7XG5cbiAgaXRlcmF0ZUFycmF5KGJsb2NrSW5zdGFuY2UuJCQubWl4aW5zVG9CdWlsZCwgKGV4ZWN1dGVCdWlsZGVycykgPT4ge1xuICAgIGV4ZWN1dGVCdWlsZGVycygpO1xuICB9KTtcbiAgYmxvY2tJbnN0YW5jZS4kJC5taXhpbnNUb0J1aWxkID0gW107XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyUmVuZGVyKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclJlbmRlcjpgLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIGJsb2NrSW5zdGFuY2U7XG59XG4iLCJjb25zdCB7IGlzUHJvdG90eXBlT2YgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKENsYXNzLCBTdWJjbGFzcykge1xuICByZXR1cm4gQ2xhc3M6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MpICYmIENsYXNzLnByb3RvdHlwZTo6aXNQcm90b3R5cGVPZihTdWJjbGFzcy5wcm90b3R5cGUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwoY2hpbGQpIHtcbiAgY2hpbGQuJCQucmVtb3ZlKHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgaXNJbnN0YW5jZU9mIH0gZnJvbSAnLi9pc0luc3RhbmNlT2YnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uLy4uL01peGluJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBCbG9jayhibG9jaywgd3JhcHBlcikge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHdyYXBwZXIoYmxvY2spO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIHJldHVyblZhbHVlKVxuICAgID8gcmV0dXJuVmFsdWVcbiAgICA6IGJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1peGluKG1peGluLCB3cmFwcGVyKSB7XG4gIGNvbnN0IHJldHVyblZhbHVlID0gd3JhcHBlcihtaXhpbik7XG5cbiAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgcmV0dXJuVmFsdWUpXG4gICAgPyByZXR1cm5WYWx1ZVxuICAgIDogbWl4aW47XG59XG4iLCJpbXBvcnQge1xuICBpc1N0cmluZywgaXRlcmF0ZU9iamVjdCwga2V5cyxcbiAgY29sbGVjdEZyb21PYmplY3QsIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVggPSAvXFxzKjtcXHMqLztcbmNvbnN0IENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVggPSAvXFxzKjpcXHMqLztcblxucm9vdE1peGluc1snZC1zdHlsZSddID0gY2xhc3MgRFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xuICBjc3MgPSB7fTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNzc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21PYmplY3QoYXJncywgKGNzcywgcHJvcCkgPT4ge1xuICAgICAgICBjc3NbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21BcnJheShcbiAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgIC5tYXAoY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nKSxcbiAgICAgICAgYWRkQ1NTUHJvcFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNzcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIW5ld1ZhbHVlW3Byb3BdKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ1NTKHByb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVsZW0uY3NzKG5ld1ZhbHVlKTtcblxuICAgIHRoaXMuY3NzID0gbmV3VmFsdWU7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBjc3NcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBlbGVtLnJlbW92ZUNTUy5hcHBseShlbGVtLCBrZXlzKGNzcykpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gYWRkQ1NTUHJvcChjc3MsIGl0ZW0pIHtcbiAgY29uc3QgW3Byb3AsIHZhbHVlXSA9IGl0ZW07XG5cbiAgY3NzW3Byb3BdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyhzdHlsZSkge1xuICBjb25zdCBzcGxpdCA9IHN0eWxlLnNwbGl0KENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gIHJldHVybiBbXG4gICAgc3BsaXRbMF0udHJpbSgpLFxuICAgIHNwbGl0WzFdLnRyaW0oKVxuICBdO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNGdW5jdGlvbiwgaXNOaWwsXG4gIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLXZhbHVlJ10gPSBjbGFzcyBEVmFsdWUgZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuYW1lID0gZWxlbS5uYW1lKCk7XG4gICAgY29uc3QgdHlwZSA9IGVsZW0ucHJvcCgndHlwZScpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuICAgIGxldCBpbml0aWFsU2NvcGVWYWx1ZSA9IG51bGw7XG5cbiAgICB0aGlzLnByb3AgPSBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gZWxlbS5jaGlsZHJlbigpLmZpbHRlcignb3B0aW9uJyk7XG4gICAgdGhpcy5zY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHRoaXMuc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbih0aGlzLnZhbHVlKSkge1xuICAgICAgaW5pdGlhbFNjb3BlVmFsdWUgPSB0aGlzLnNjb3BlLiQkLmV2YWx1YXRlKChzY29wZSkgPT4gc2NvcGVbdGhpcy52YWx1ZV0sIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICB0aGlzLnNldFByb3AobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsRWxlbVZhbHVlID0gdGhpcy5nZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlLCB0cnVlKTtcbiAgICBjb25zdCBpc0luaXRpYWxTY29wZVZhbHVlTnVsbCA9IGlzTmlsKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICBjb25zdCBpc0NoZWNrYm94ID0gdHlwZSA9PT0gJ2NoZWNrYm94JztcbiAgICBjb25zdCBjaGFuZ2VTY29wZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5nZXRQcm9wKHRoaXMuY3VycmVudFZhbHVlLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG4gICAgfTtcblxuICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxFbGVtVmFsdWU7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG5cbiAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xuICAgICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxTY29wZVZhbHVlO1xuICAgICAgdGhpcy5zZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lciA9IGVsZW0ub24oZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpLCBjaGFuZ2VTY29wZSk7XG4gICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIgPSBlbGVtLmNsb3Nlc3QoJ2Zvcm0nKS5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KGNoYW5nZVNjb3BlLCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNoYW5nZVNjb3BlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjb3BlLFxuICAgICAgdmFsdWUsXG4gICAgICBjdXJyZW50VmFsdWVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NvcGVbdmFsdWVdID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb3AodmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChwcm9wID09PSAndGV4dCcpIHtcbiAgICAgIGVsZW0udGV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jykge1xuICAgICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnByb3AocHJvcCwgZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBub2RlLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvcCh2YWx1ZXMsIGluaXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiBwcm9wID09PSAndGV4dCdcbiAgICAgID8gZWxlbS50ZXh0KClcbiAgICAgIDogZ2V0VmFsdWVGb3JHZXR0aW5nKG5hbWUsIGVsZW0ucHJvcChwcm9wKSwgdHlwZSwgbm9kZS52YWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jyk7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5vZmZFbGVtTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lcigpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignbXVsdGlwbGUnKVxuICAgICAgICA/ICdtdWx0aXBsZS1zZWxlY3QnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgcmV0dXJuICdmaWxlcyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICAgICAgPyAnY2hlY2tlZCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBlbGVtLmhhc0F0dHIoJ2NvbnRlbnRFZGl0YWJsZScpXG4gICAgICAgID8gJ3RleHQnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlKSB7XG4gIGlmIChuYW1lICE9PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgaXNSYWRpbyA9IHR5cGUgPT09ICdyYWRpbyc7XG5cbiAgaWYgKCFpc1JhZGlvICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gaXNSYWRpb1xuICAgID8gdmFsdWUgPT09IGlucHV0VmFsdWVcbiAgICA6IHZhbHVlLmluZGV4T2YoaW5wdXRWYWx1ZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUsIHZhbHVlcywgb3B0aW9ucywgaW5pdCwgaXNNdWx0aXBsZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShvcHRpb25zLCBhZGRWYWx1ZSwgW10pO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgIT09ICdyYWRpbycgJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgID8gaW5wdXRWYWx1ZVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtdO1xuXG4gICAgICBpZiAoIXZhbHVlICYmIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKSA9PT0gLTFcbiAgICAgICAgICA/IHZhbHVlcy5jb25jYXQoaW5wdXRWYWx1ZSlcbiAgICAgICAgICA6IHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIC4uLnZhbHVlcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyTmFtZShuYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIHJldHVybiAnY2hhbmdlJztcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHR5cGUgPT09ICdyYWRpbydcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICB8fCB0eXBlID09PSAnY29sb3InXG4gICAgICAgIHx8IHR5cGUgPT09ICdmaWxlJ1xuICAgICAgKVxuICAgICAgICA/ICdjaGFuZ2UnXG4gICAgICAgIDogJ2NoYW5nZSBpbnB1dCc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuICdpbnB1dCc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKHZhbHVlcywgeyBzZWxlY3RlZCwgdmFsdWUgfSkge1xuICBpZiAoc2VsZWN0ZWQgJiYgdmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgdG9PYmplY3RLZXlzLFxuICBhc3NpZ24sIGtleXMsIGNyZWF0ZVxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFRlbXBsYXRlcyh0ZW1wbGF0ZSwgdGVtcGxhdGVzKSB7XG4gIGNvbnN0IHtcbiAgICB2YXJzLFxuICAgIHZhbHVlXG4gIH0gPSB0ZW1wbGF0ZTtcbiAgY29uc3QgbmV3VGVtcGxhdGVzID0gY3JlYXRlKG51bGwpO1xuICBjb25zdCBuZXdWYXJzID0gdG9PYmplY3RLZXlzKHZhcnMpO1xuXG4gIGFzc2lnbihuZXdUZW1wbGF0ZXMsIHRlbXBsYXRlcyk7XG4gIGl0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbih2YWx1ZSk7XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuKG5vZGVzID0gW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICAgIGlmIChuZXdUZW1wbGF0ZXNbdHJpbW1lZF0pIHtcbiAgICAgICAgICBjb25zdCBuZXdUZW1wbGF0ZSA9IG5ld1RlbXBsYXRlc1t0cmltbWVkXS52YWx1ZTtcblxuICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uZXdUZW1wbGF0ZSk7XG4gICAgICAgICAgYXNzaWduKG5ld1ZhcnMsIHRvT2JqZWN0S2V5cyhuZXdUZW1wbGF0ZXNbdHJpbW1lZF0udmFycykpO1xuXG4gICAgICAgICAgaSArPSBuZXdUZW1wbGF0ZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhcnMubGVuZ3RoID0gMDtcbiAgdmFycy5wdXNoKC4uLmtleXMobmV3VmFycykpO1xuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cbiIsImltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVCbG9jaywgaXNJbnN0YW5jZU9mIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi9CbG9jayc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gaW5pdEFwcFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtUZW1wbGF0ZXxTY29wZWxlc3NUZW1wbGF0ZXxTdHJpbmd8dHlwZW9mIEJsb2NrfSBibG9jayAtIFJvb3QgdGVtcGxhdGUgKG1heSBiZSBzY29wZWxlc3MpLFxuICogc3RyaW5nIGRlZmluaW5nIGEgbmFtZSBvZiB0aGUgcm9vdCBibG9jayBvciBhIGJsb2NrIHN1YmNsYXNzLlxuICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGNvbnRhaW5lciAtIENvbnRhaW5lciBvZiB0aGUgYXBwLlxuICogQHJldHVybnMge0Jsb2NrfHZvaWR9IFJvb3QgYmxvY2sgaWYgdGhlIGFwcCBoYXMgYmVubiByZWdpc3RlcmVkIGFuZCB1bmRlZmluZWQgaWYgbm90LlxuICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaW5pdGlhbGl6aW5nIGFwcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaW5pdEFwcCwgZG9jIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiBpbml0QXBwKGh0bWxgPEFwcC8+YCwgZG9jLmNyZWF0ZSgnZGl2JykpO1xuICogaW5pdEFwcChodG1sU2NvcGVsZXNzYDxBcHAvPmAsIGRvYy5jcmVhdGUoJ2RpdicpKTtcbiAqIGluaXRBcHAoJ0FwcCcsIGRvYy5jcmVhdGUoJ2RpdicpKTtcbiAqIGluaXRBcHAoQXBwLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0QXBwKGJsb2NrLCBjb250YWluZXIpIHtcbiAgY29uc3QgcGFyZW50RWxlbSA9IG5ldyBFbGVtKGNvbnRhaW5lcikuZWxlbSgwKTtcbiAgbGV0IENvbnN0cnVjdG9yID0gYmxvY2s7XG5cbiAgaWYgKCFwYXJlbnRFbGVtLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHBhcmVudEVsZW0ucHJvcCgnRHdheW5lUm9vdEJsb2NrJykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdUaGVyZSBhbHJlYWR5IGV4aXN0cyBhIER3YXluZSBhcHAgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAoaW5pdEFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhibG9jaykpIHtcbiAgICBDb25zdHJ1Y3RvciA9IGNsYXNzIFJvb3RCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICAgICAgdmFyczogW10sXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IGJsb2NrXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBpZiAoaXNBcnJheShibG9jaykpIHtcbiAgICBDb25zdHJ1Y3RvciA9IGNsYXNzIFJvb3RCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICAgICAgdmFyczogW10sXG4gICAgICAgIHZhbHVlOiBibG9ja1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGJsb2NrICYmICFpc0luc3RhbmNlT2YoQmxvY2ssIGJsb2NrKSAmJiBpc0FycmF5KGJsb2NrLnZhcnMpICYmIGlzQXJyYXkoYmxvY2sudmFsdWUpKSB7XG4gICAgQ29uc3RydWN0b3IgPSBjbGFzcyBSb290QmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAgICBzdGF0aWMgdGVtcGxhdGUgPSBibG9jaztcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFpc0luc3RhbmNlT2YoQmxvY2ssIENvbnN0cnVjdG9yKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIHJvb3QgYmxvY2sgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgcm9vdEJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgIG5vZGU6IHtcbiAgICAgIG5hbWU6ICcjUm9vdEJsb2NrJyxcbiAgICAgIENvbnN0cnVjdG9yXG4gICAgfSxcbiAgICBwYXJlbnQ6IHBhcmVudEVsZW0sXG4gICAgcGFyZW50RWxlbVxuICB9KTtcblxuICBwYXJlbnRFbGVtXG4gICAgLnByb3AoJ0R3YXluZVJvb3RCbG9jaycsIHJvb3RCbG9jaylcbiAgICAuYXR0cignZHdheW5lLXJvb3QnLCAnJyk7XG5cbiAgcmV0dXJuIHJvb3RCbG9jaztcbn1cbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi9CbG9jayc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gcmVtb3ZlQXBwXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIG9mIHRoZSBhcHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHJlbW92aW5nIGFwcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcmVtb3ZlQXBwLCBmaW5kIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiByZW1vdmVBcHAoZmluZCgnLnJvb3QnKSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBcHAoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW0gPSBuZXcgRWxlbShjb250YWluZXIpLmVsZW0oMCk7XG5cbiAgaWYgKCFlbGVtLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhcHAgZnJvbSB3YXMgZ2l2ZW4hIChyZW1vdmVBcHApJyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb250YWluZXIgPSBlbGVtWzBdO1xuXG4gIGNvbnN0IHsgRHdheW5lUm9vdEJsb2NrIH0gPSBjb250YWluZXI7XG5cbiAgaWYgKCEoRHdheW5lUm9vdEJsb2NrIGluc3RhbmNlb2YgQmxvY2spKSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gYXBwIHJlZ2lzdGVyZWQgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAocmVtb3ZlQXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgRHdheW5lUm9vdEJsb2NrLiQkLnJlbW92ZSgpO1xuICBlbGVtLnJlbW92ZUF0dHIoJ2R3YXluZS1yb290Jyk7XG5cbiAgZGVsZXRlIGNvbnRhaW5lci5Ed2F5bmVSb290QmxvY2s7XG59XG4iLCJleHBvcnQgY29uc3Qge1xuICBjcmVhdGUsXG4gIGtleXMsXG4gIGdldFByb3RvdHlwZU9mOiBnZXRQcm90b1xufSA9IE9iamVjdDtcblxuZXhwb3J0IGNvbnN0IHNldFByb3RvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgodGFyZ2V0LCBwcm90bykgPT4ge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gcHJvdG87XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn0pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmVzdGVkLXRlcm5hcnkgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5lZ2F0ZWQtY29uZGl0aW9uICovXG5leHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuLyogZXNsaW50LWVuYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqL1xuLyogZXNsaW50LWVuYWJsZSBuby1uZWdhdGVkLWNvbmRpdGlvbiAqL1xuIiwiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi91dGlscy9vYmplY3RTdGF0aWNzJztcblxuZXhwb3J0IGNvbnN0IEhJREVfQ0xBU1MgPSAnX19kd2F5bmUtaGlkZGVuX18nO1xuZXhwb3J0IGNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgY29uc3QgRF9SRVNUX1JFR0VYID0gL15kLXJlc3QoPzojfCQpLztcblxuZXhwb3J0IGNvbnN0IHJvb3RCbG9ja3MgPSBjcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3Qgcm9vdE1peGlucyA9IGNyZWF0ZShudWxsKTtcbmV4cG9ydCBjb25zdCB7XG4gIGRvY3VtZW50ID0ge30sXG4gIFN5bWJvbCA9IHt9XG59ID0gZ2xvYmFsO1xuIiwiaW1wb3J0IHtcbiAgaXNOaWwsIGlzU3RyaW5nLFxuICBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzLFxuICBjb2xsZWN0RnJvbUFycmF5LCBjb2xsZWN0RnJvbU9iamVjdCxcbiAgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICB0b0h5cGhlbkNhc2UsIHNldFN5bWJvbFNwZWNpZXMsXG4gIHNldFRvU3RyaW5nVGFnLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGlzRG9jdW1lbnQsIGlzVmFsaWROb2RlLCBnZXRNYXRjaGVzRnVuY3Rpb24sXG4gIGFkZEF0dHIsIGFkZENTU1Byb3AsIGFkZERhdGFBdHRyLFxuICBhZGROZXh0LCBhZGRQYXJlbnQsIGFkZFByZXYsXG4gIHRvRWxlbSwgaXNFbGVtZW50c0NvbGxlY3Rpb24sXG4gIGdldEF0dHJOUywgZ2V0RXZlbnQsIGhpZGUsIHNob3csIHJlbW92ZVxufSBmcm9tICcuL2hlbHBlcnMvRWxlbSc7XG5pbXBvcnQgeyBTVkdfTlMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnLi9maW5kJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7U3RyaW5nfSBFbGVtRXZlbnRTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBBIHN0cmluZyBjb250YWluaW5nIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBjb21tYSB3aXRoIHplcm8gb3IgbW9yZSBzcGFjZXMgb3IganVzdCBzcGFjZXMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbUxpc3RlbmVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0V2ZW50fSBlIC0gRmlyZWQgZXZlbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBFbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbVJlbW92ZUxpc3RlbmVyc1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsuLi5FbGVtRXZlbnRTdHJpbmd9IGV2ZW50cyAtIElmIGF0IGxlYXN0IG9uZSBhcmd1bWVudCBwcmVzZW50IG9ubHkgcmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgc3BlY2lmaWVkXG4gKiBieSB0aGUgZXZlbnRzIGluIHRoZSBhcmd1bWVudHMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSXRlcmF0aW9uQ2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBub2RlIC0gSXRlcmF0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJdGVyYXRpb24gaW5kZXguXG4gKiBAcGFyYW0ge0VsZW19IGVsZW0gLSBJbml0aWFsIHNldC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBDb2xsZWN0Q2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QWRkQ2FsbGJhY2t9IGFkZCAtIEFkZCBlbGVtZW50IHRvIHRoZSBldmVudHVhbCBzZXQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gbm9kZSAtIEl0ZXJhdGlvbiBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSXRlcmF0aW9uIGluZGV4LlxuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gSW5pdGlhbCBzZXQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQWRkQ2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Li4uKEVsZW1lbnR8Tm9kZXxlbGVtKX0gZWxlbSAtIEVsZW1lbnQgdG8gYWRkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1NZXRob2RcbiAqIEBwdWJsaWNcbiAqIEB0aGlzIEVsZW1cbiAqL1xuXG5jb25zdCBFVkVOVF9TRVBBUkFUT1JfUkVHRVggPSAvWyx8IF0gKi87XG5jb25zdCBDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWCA9IC87ID8vO1xuY29uc3QgQ1NTX0lNUE9SVEFOVF9SRUdFWCA9IC8gPyFpbXBvcnRhbnQkLztcbmNvbnN0IGVtcHR5Q29sbGVjdGlvbiA9IFtdO1xuXG4vKipcbiAqIEBjbGFzcyBFbGVtXG4gKiBAZXh0ZW5kcyBBcnJheS48RWxlbWVudHxOb2RlPlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gW2VsZW0gPSBbXV0gLSBBbiBlbGVtZW50IG9yIGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RWxlbX0gSW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFuIGVsZW1lbnRzIHNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG4gKiBuZXcgRWxlbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2xzJykpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xzJykpO1xuICovXG5jbGFzcyBFbGVtIGV4dGVuZHMgQXJyYXkge1xuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0uYWRkTWV0aG9kc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBFbGVtTWV0aG9kPn0gbWV0aG9kTmFtZSAtIE5hbWUgb2YgdGhlIG1ldGhvZCBvciBvYmplY3Qgb2ZcbiAgICogbWV0aG9kIG5hbWVzIGFuZCBtZXRob2RzLlxuICAgKiBAcGFyYW0ge0VsZW1NZXRob2R9IFttZXRob2RdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIHRoaXMgc2hvdWxkIGJlIHRoZSBtZXRob2QgaXRzZWxmLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW19XG4gICAqL1xuICBzdGF0aWMgYWRkTWV0aG9kcyhtZXRob2ROYW1lLCBtZXRob2QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBtZXRob2ROYW1lID0geyBbbWV0aG9kTmFtZV06IG1ldGhvZCB9O1xuICAgIH1cblxuICAgIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXModGhpcy5wcm90b3R5cGUsIG1ldGhvZE5hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbGVtID0gZW1wdHlDb2xsZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgfVxuXG4gICAgc2V0UHJvdG8odGhpcywgRWxlbS5wcm90b3R5cGUpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICB0aGlzLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2FkZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uKEVsZW18RWxlbWVudHxFbGVtZW50W10pfSBlbGVtZW50cyAtIEVhY2ggYXJndW1lbnQgaXMgYSBFbGVtLCBvciBFbGVtZW50LCBvciBhcnJheSBvZiBFbGVtZW50cy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIG5ldyBlbGVtZW50cyB0byB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtMS5maW5kKCcuY2xzMScpXG4gICAqICAgLmFkZChlbGVtMi5maW5kKCcuY2xzMicpKVxuICAgKiAgIC5oaWRlKCk7XG4gICAqL1xuICBhZGQoLi4uZWxlbWVudHMpIHtcbiAgICBjb25zdCBlbGVtcyA9IHRoaXMuc2xpY2UoKTtcblxuICAgIGl0ZXJhdGVBcnJheShlbGVtZW50cywgKGVsZW0pID0+IHtcbiAgICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgICAgZWxlbSA9IFtlbGVtXTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICAgIGlmICghZWxlbXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICBlbGVtcy5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNhZGRDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBjbGFzc2VzIHRvIHRoZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ3JlZCcsICdyb3VuZCcpO1xuICAgKi9cbiAgYWRkQ2xhc3MoLi4uY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGNsYXNzZXMsIChjbHMpID0+IGxpc3QuYWRkKGNscykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2F0dHJdIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAgICogaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGF0dHJpYnV0ZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiByZXR1cm5lZCwgaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cjEnLCAndmFsdWUxJyk7IC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCdhdHRyMScpOyAgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5hdHRyKHtcbiAgICogICBhdHRyMTogJ3ZhbHVlMycsICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIGF0dHIyOiAndmFsdWUyJyAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCk7ICAgICAgICAgICAgICAgICAgLy8geyBhdHRyMTogJ3ZhbHVlMycsIGF0dHIyOiAndmFsdWUyJyB9XG4gICAqL1xuICBhdHRyKGF0dHIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGVsZW0uYXR0cmlidXRlcywgYWRkQXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhhdHRyKSkge1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5zLFxuICAgICAgICBuYW1lXG4gICAgICB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgICByZXR1cm4gbnNcbiAgICAgICAgPyBlbGVtLmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKVxuICAgICAgICA6IGVsZW0uZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGF0dHIgPSB7IFthdHRyXTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KGF0dHIsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlO1xuXG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhrZXksIGVsZW0pO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTlMobnMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNjaGlsZHJlblxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBELVdyYXAgb2YgdGhlIGNoaWxkcmVuIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgZWxlbWVudCdzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBjaGlsZHJlbiA9IGVsZW0uY2hpbGRyZW4oKTtcbiAgICovXG4gIGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzLmxlbmd0aCA/IHRoaXNbMF0uY2hpbGROb2RlcyA6IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNjbG9zZXN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjY2xvc2VzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdH0uXG4gICAqL1xuICBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jY29sbGVjdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Q29sbGVjdENhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgZXZlbnR1YWwgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjb2xsZWN0aW5nIGVsZW1lbnRzIGludG8gYSBuZXcgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBwYXJlbnRzID0gZWxlbS5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICogICBhZGQoZWxlbS5wYXJlbnROb2RlKTtcbiAgICogfSk7XG4gICAqL1xuICBjb2xsZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBjYiA9IDo6ZWxlbWVudHMucHVzaDtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNiLCBlbGVtLCBpbmRleCwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVsZW0oZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2NvbnRhaW5zXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGZpbmQgb3V0IGlmIGl0J3Mgd2l0aGluIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGlmIHRoZSBhcmd1bWVudCB3aXRoaW4gdGhpcyBlbGVtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIGV4dGVuc2lvbiBmb3JcbiAgICogW05vZGUjY29udGFpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbnRhaW5zfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jb250YWlucyhlbGVtMik7ICAgLy8gdHJ1ZXxmYWxzZVxuICAgKi9cbiAgY29udGFpbnMoZWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbMF07XG4gICAgY29uc3QgY2hpbGQgPSB0b0VsZW0oZWxlbWVudClbMF07XG5cbiAgICByZXR1cm4gIXBhcmVudCB8fCAhY2hpbGRcbiAgICAgID8gZmFsc2VcbiAgICAgIDogcGFyZW50LmNvbnRhaW5zKGNoaWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNjcmVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFR5cGUgb2YgY3JlYXRlZCBlbGVtZW50LiBJZiB0eXBlIGlzIFwiI3RleHRcIiBhIHRleHQgbm9kZSBpcyBjcmVhdGVkLlxuICAgKiBJZiB0eXBlIGlzIFwiI2NvbW1lbnRcIiBhIGNvbW1lbnQgbm9kZSBpcyBjcmVhdGVkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBlbGVtZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGVsZW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZSgnZGl2Jyk7XG4gICAqL1xuICBjcmVhdGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgbGV0IGVsID0gbnVsbDtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHR5cGUgPT09ICcjdGV4dCc7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBpZiAoaXNUZXh0IHx8IHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgZWwgPSBpc1RleHRcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IHR5cGUgPT09ICdzdmcnXG4gICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0RvY3VtZW50KGVsZW0pKSB7XG4gICAgICAgIG5ldyBFbGVtKGVsKS5pbnRvKGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBhZGQoZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBzdHlsZXMuIFN1cHBvcnRzICFpbXBvcnRhbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTsgLy8gZGlzcGxheSBzZXQgdG8gJ25vbmUnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBkaXNwbGF5OiAnaW5saW5lJywgICAgICAgICAvLyBkaXNwbGF5IHNldCB0byAnaW5saW5lJ1xuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygpOyAgICAgICAgICAgICAgICAgIC8vIHsgZGlzcGxheTogJ25vbmUnLCBjdXJzb3I6ICdwb2ludGVyJyB9XG4gICAqL1xuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KHN0eWxlLmNzc1RleHQuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpLCBhZGRDU1NQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpICsgKHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpID8gJyAhaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgdmFsdWUucmVwbGFjZShDU1NfSU1QT1JUQU5UX1JFR0VYLCAnJyksXG4gICAgICAgICAgQ1NTX0lNUE9SVEFOVF9SRUdFWC50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2RhdGFcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2tleV0gLSBOYW1lIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSAod2l0aG91dCBkYXRhLSBwcmVmaXgpXG4gICAqIHRvIGdldCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGRhdGFzZXQgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgYXR0cmlidXRlIHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBkYXRhIGF0dHJpYnV0ZXMuIFNlZVxuICAgKiBbSFRNTEVsZW1lbnQjZGF0YXNldF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2RhdGFzZXR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmRhdGEoJ3NvbWVLZXkxJywgJ3ZhbHVlJyk7IC8vIGF0dHJpYnV0ZSBkYXRhLXNvbWUta2V5MSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScpOyAgICAgICAgICAvLyAndmFsdWUxJ1xuICAgKiBlbGVtLmRhdGEoe1xuICAgKiAgIHNvbWVLZXkxOiAndmFsdWUzJywgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBkYXRhLXNvbWUta2V5MSBzZXQgdG8gJ3ZhbHVlMydcbiAgICogICBzb21lS2V5MjogJ3ZhbHVlMicgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmRhdGEoKTsgICAgICAgICAgICAgICAgICAgIC8vIHsgc29tZUtleTE6ICd2YWx1ZTMnLCBzb21lS2V5MjogJ3ZhbHVlMicgfVxuICAgKi9cbiAgZGF0YShrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhc2V0IH0gPSB0aGlzWzBdIHx8IHt9O1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21PYmplY3QoZGF0YXNldCwgYWRkRGF0YUF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzU3RyaW5nKGtleSkpIHtcbiAgICAgIGlmICghZGF0YXNldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhc2V0W2tleV07XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAga2V5ID0geyBba2V5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KGtleSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgZWxlbS5kYXRhc2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2Rpc3BhdGNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR9IGV2ZW50IC0gRXZlbnQgb3IgYSBzdHJpbmcgKG5ldyBFdmVudChldmVudCkgaXMgY3JlYXRlZCkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlscyA9IHt9XSAtIE9iamVjdCB0aGF0IGlzIGFzc2lnbmVkIHRvIHRoZSBldmVudC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnQvRXZlbnRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFdmVudFRhcmdldCNkaXNwYXRjaEV2ZW50XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvZGlzcGF0Y2hFdmVudH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJyk7XG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJywgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsbGFibGU6IGZhbHNlLCBkYXRhOiAxIH0pO1xuICAgKiBlbGVtLmRpc3BhdGNoKG5ldyBDdXN0b21FdmVudCgnY3VzdG9tLWV2ZW50JykpO1xuICAgKi9cbiAgZGlzcGF0Y2goZXZlbnQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1YmJsZXMgPSB0cnVlLFxuICAgICAgY2FuY2VsYWJsZSA9IHRydWUsXG4gICAgICAuLi5yZWFsRGV0YWlsc1xuICAgIH0gPSBkZXRhaWxzO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGdldEV2ZW50KFxuICAgICAgICBldmVudCxcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZSxcbiAgICAgICAgcmVhbERldGFpbHMsXG4gICAgICAgIGVsZW1cbiAgICAgICkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2VsZW1cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4ID0gMF0gLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvZiB0aGUgc2V0IHRvIGdldC4gTmVnYXRpdmUgaW5kZXggbWVhbnMgZWxlbS5sZW5ndGggKyBpbmRleC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmVsZW0oMSk7IC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDFcbiAgICogZWxlbS5lbGVtKCk7ICAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAwXG4gICAqL1xuICBlbGVtKGluZGV4ID0gMCkge1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggKyBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW0odGhpc1tpbmRleF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2ZpbHRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t8U3RyaW5nfSBmaWx0ZXIgLSBGaWx0ZXIgZnVuY3Rpb24gb3IgYSBzZWxlY3Rvci5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaWx0ZXJpbmcgZWxlbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZmlsdGVyKChlbGVtKSA9PiBuZXcgRWxlbShlbGVtKS5jbG9zZXN0KCcucGFyZW50JykpO1xuICAgKi9cbiAgZmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChpc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGZpbHRlcjtcblxuICAgICAgZmlsdGVyID0gKGVsZW0pID0+IChcbiAgICAgICAgbmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChmaWx0ZXIoZWxlbSwgaW5kZXgsIHRoaXMpKSB7XG4gICAgICAgIGFkZChlbGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNmaW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXG4gICAqL1xuICBmaW5kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBhZGQoZmluZChzZWxlY3RvciwgZWxlbSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2ZvckVhY2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZmluZCgnLmNscycpLmZvckVhY2goKGVsZW1lbnQsIGluZGV4LCBzZXQpID0+IHtcbiAgICogICAvLyBkbyBzb21ldGhpbmdcbiAgICogfSk7XG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgaXRlcmF0ZUFycmF5KHRoaXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2hhc0F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHInLCAndmFsdWUnKS5oYXNBdHRyKCdhdHRyJyk7IC8vIHRydWVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdhdHRyJykuaGFzQXR0cignYXR0cicpOyAgICAvLyBmYWxzZVxuICAgKi9cbiAgaGFzQXR0cihhdHRyKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG5zIH0gPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICByZXR1cm4gbnNcbiAgICAgID8gZWxlbS5oYXNBdHRyaWJ1dGVOUyhucywgYXR0cilcbiAgICAgIDogZWxlbS5oYXNBdHRyaWJ1dGUoYXR0cik7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jaGFzQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gTmFtZSBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3MuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcyBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgICAgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKS5oYXNDbGFzcygnY2xzJyk7IC8vIGZhbHNlXG4gICAqL1xuICBoYXNDbGFzcyhjbHMpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNscylcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jaGlkZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBIaWRlcyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5oaWRlKCk7XG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goaGlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jaHRtbFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFtodG1sXSAtIEhUTUwgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IEhUTUwuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCBIVE1MIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgSFRNTCBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIGh0bWwgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgSFRNTC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5odG1sKCc8ZGl2PjE8L2Rpdj4nKTtcbiAgICogZWxlbS5odG1sKCk7IC8vICc8ZGl2PjE8L2Rpdj4nXG4gICAqL1xuICBodG1sKGh0bWwpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICByZXR1cm4gZWxlbVxuICAgICAgICA/IGVsZW0uaW5uZXJIVE1MXG4gICAgICAgIDogJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2luY2x1ZGVzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtZW50fG5vZGV9IGVsZW0gLSBFbGVtZW50IHRvIHNlYXJjaC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBzYW1lIGFzIEFycmF5I2luY2x1ZGVzLlxuICAgKi9cbiAgaW5jbHVkZXMoZWxlbSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbSkgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI2luc2VydEFmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYWZ0ZXIgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jaW5zZXJ0QmVmb3JlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYmVmb3JlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUHV0cyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGJlZm9yZSB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50LlxuICAgKiBUaGUgZWxlbWVudHMgcmVtYWluIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmluc2VydEJlZm9yZShlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGluc2VydEJlZm9yZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50WzBdO1xuICAgIHBhcmVudCA9IHBhcmVudFswXTtcblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jaW50b1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBwdXQgdGhpcyBlbGVtZW50cyBpbnRvLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgdGhleSBhcmUgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjYXBwZW5kQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2FwcGVuZENoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnRvKGVsZW0yKTtcbiAgICogZWxlbS5pbnRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnRvKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnRvKGVsZW1lbnQsIGVuZCA9IHRydWUpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWVuZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXNbaV0sIGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jaXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSk7XG5cbiAgICByZXR1cm4gZWxlbTo6bWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jbmFtZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8dm9pZH0gbm9kZU5hbWUgKGxvd2VyY2FzZWQpIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgbmFtZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZSgnZGl2JykubmFtZSgpIC8vICdkaXYnXG4gICAqL1xuICBuYW1lKCkge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgcmV0dXJuIGVsZW1cbiAgICAgID8gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNuZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5uZXh0KCk7IC8vIGZpbmRzIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZE5leHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI29uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtRXZlbnRTdHJpbmd8T2JqZWN0LjxFbGVtRXZlbnRTdHJpbmd8RWxlbUxpc3RlbmVyPn0gZXZlbnQgLSBFaXRoZXIgYSB7QGxpbmsgRWxlbUV2ZW50U3RyaW5nfSBzdHJpbmdcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggZXZlbnQga2V5cyAoYSBrZXkgaXMgYWxzbyBFbGVtRXZlbnRTdHJpbmcpIGFuZCBsaXN0ZW5lcnMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0VsZW1MaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBtdXN0IGJlIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yXG4gICAqIHNwZWNpZmllZCBldmVudChzKS5cbiAgICogQHJldHVybnMge0VsZW1SZW1vdmVMaXN0ZW5lcnN9IEZ1bmN0aW9uIHRoYXQgdGFrZXMgb3B0aW9uYWwgZXZlbnQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oXG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnLFxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcbiAgICogKTtcbiAgICogZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdjbGljaycpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScsICdpbnB1dCcpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICovXG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChpc1N0cmluZyhldmVudCkpIHtcbiAgICAgIGV2ZW50ID0geyBbZXZlbnRdOiBsaXN0ZW5lciB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0V2ZW50cyA9IHt9O1xuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IHt9O1xuXG4gICAgaXRlcmF0ZU9iamVjdChldmVudCwgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAobmV3RXZlbnRzW2V2ZW50XSA9IG5ld0V2ZW50c1tldmVudF0gfHwgW10pLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3RXZlbnRzLCAobGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICBpdGVyYXRlQXJyYXkobGlzdGVuZXJzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgKGFsbExpc3RlbmVyc1tldmVudF0gPSBhbGxMaXN0ZW5lcnNbZXZlbnRdIHx8IFtdKS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkoZXZlbnQuc3BsaXQoRVZFTlRfU0VQQVJBVE9SX1JFR0VYKSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuXG4gICAgICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGFsbExpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZU9iamVjdChhbGxMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcnMsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHJlbW92ZUxpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcblxuICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI3BhcmVudFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCByZXR1cm5zIHdyYXAgb2YgdGhlIHNldCBvZiB0aGUgcGFyZW50IGVsZW1lbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKi9cbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkUGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNwcmV2XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJldigpOyAvLyBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBwcmV2KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkUHJldik7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jcHJvcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCAqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBhc3NpZ25lZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cbiAgICogQHJldHVybnMge0VsZW18Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3Mgc2V0dGVyIG9yIGEgdmFsdWUgaWYgZ2V0dGVyLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgaXMgZWl0aGVyIGEgcHJvcGVydHkgZ2V0dGVyIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIG9yIGEgc2V0dGVyIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJywgZmFsc2UpO1xuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScpOyAvLyBmYWxzZVxuICAgKi9cbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3ApID0+IHtcbiAgICAgICAgZWxlbVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAqIE5vdGU6IGl0IGRvZXNuJ3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2V0IHNvIHdhdGNoIG91dCBmb3IgdGhlIG1lbW9yeSBsZWFrcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmUoKTtcbiAgICovXG4gIHJlbW92ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKHJlbW92ZSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jcmVtb3ZlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdmb28nLCAnYmFyJywgJ2JheicpO1xuICAgKi9cbiAgcmVtb3ZlQXR0ciguLi5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGF0dHJpYnV0ZXMsIChhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBhdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jcmVtb3ZlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGNsYXNzZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4gbGlzdC5yZW1vdmUoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jcmVtb3ZlQ1NTXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IHByb3BzIC0gQ1NTIHByb3BlcnRpZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIENTUyBwcm9wZXJ0aWVzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUNTUygnZGlzcGxheScsICdwb3NpdGlvbicsICdtYXJnaW4nKTtcbiAgICovXG4gIHJlbW92ZUNTUyguLi5wcm9wcykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShwcm9wcywgKGNzcykgPT4ge1xuICAgICAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHRvSHlwaGVuQ2FzZShjc3MpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI3JlcGxhY2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gcmVwbGFjZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHdpdGggYSBzZXQgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudCAoRWxlbWVudCBvciBFbGVtKS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBzaW1pbGFyIHRvXG4gICAqIFtOb2RlI3JlcGxhY2VDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvcmVwbGFjZUNoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZXBsYWNlKGVsZW0yKTtcbiAgICogZWxlbS5yZXBsYWNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5yZXBsYWNlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICByZXBsYWNlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpO1xuXG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmVsZW0oMCk7XG4gICAgY29uc3QgcGFyZW50ID0gZmlyc3QucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBlbGVtID0gcGFyZW50O1xuICAgIGxldCBtZXRob2QgPSAnaW50byc7XG4gICAgY29uc3QgbmV4dCA9IGZpcnN0Lm5leHQoKVswXTtcbiAgICBjb25zdCBwcmV2ID0gZmlyc3QucHJldigpWzBdO1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIGVsZW0gPSBuZXh0O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEJlZm9yZSc7XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbGVtID0gcHJldjtcbiAgICAgIG1ldGhvZCA9ICdpbnNlcnRBZnRlcic7XG4gICAgfVxuXG4gICAgZmlyc3QucmVtb3ZlKCk7XG5cbiAgICBlbGVtZW50W21ldGhvZF0oZWxlbSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jc2hvd1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTaG93cyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICogSWYgYW4gZWxlbWVudCB3YXMgaGlkZGVuIHVzaW5nIHtAbGluayBFbGVtI2hpZGV9IHByZXZpb3VzIGRpc3BsYXkgaXMgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnNob3coKTtcbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChzaG93KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSNzbGljZVxuICAgKiBAcHVibGljXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2VcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgc2FtZSBhcyBBcnJheSNzbGljZSBidXQgZm9yIEVsZW0uXG4gICAqL1xuICBzbGljZSgpIHtcbiAgICByZXR1cm4gbmV3IEVsZW0oc3VwZXIuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEVsZW0jdGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFt0ZXh0XSAtIFRleHQgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IHRleHQuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCB0ZXh0IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgdGV4dHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSB0ZXh0IGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIHRleHQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udGV4dCgnMTIzJyk7XG4gICAqIGVsZW0udGV4dCgpOyAvLyAnMTIzJ1xuICAgKi9cbiAgdGV4dCh0ZXh0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wKCd0ZXh0Q29udGVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBFbGVtI3RvZ2dsZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgYXR0cmlidXRlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFlbGVtLmhhc0F0dHIoYXR0cikgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gRWxlbSN0b2dnbGVDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBDbGFzcyB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBjbGFzc1xuICAgKiBhbmQgaWYgZmFsc2V5IG1ldGhvZCByZW1vdmVzIHRoZSBjbGFzcy4gSWYgbm90IHByZXNlbnQgbWV0aG9kIGFkZHNcbiAgICogdGhlIGNsYXNzIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgY2xhc3Nlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQ2xhc3MoY2xzLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gZWxlbTtcblxuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhY2xhc3NMaXN0LmNvbnRhaW5zKGNscykgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKEVsZW0sICdFbGVtJyk7XG5zZXRTeW1ib2xTcGVjaWVzKEVsZW0sIEFycmF5KTtcblxuZXhwb3J0IHsgRWxlbSB9O1xuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gJy4vZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgU3ltYm9sIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFN5bWJvbFNwZWNpZXMoa2xhc3MsIHNwZWNpZXMpIHtcbiAgaWYgKFN5bWJvbC5zcGVjaWVzKSB7XG4gICAgZGVmaW5lUHJvcGVydGllcyhrbGFzcywge1xuICAgICAgW1N5bWJvbC5zcGVjaWVzXToge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNwZWNpZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcywgZ2V0UHJvdG8sXG4gIHJlbW92ZUFycmF5RWxlbSwgc2V0VG9TdHJpbmdUYWdcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB3cmFwTWl4aW4sIHJlbW92ZVdhdGNoZXJzIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcblxuY29uc3QgdG9TdHJpbmdUYWcgPSAnW29iamVjdCBNaXhpbl0nO1xuXG4vKipcbiAqIEBjbGFzcyBNaXhpblxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBNaXhpbiBvcHRpb25zLlxuICogQHJldHVybnMge01peGlufSBJbnN0YW5jZSBvZiBNaXhpbi5cbiAqL1xuY2xhc3MgTWl4aW4ge1xuICAvKipcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gW01peGluLmV2YWx1YXRlID0gdHJ1ZV1cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSBtaXhpbiB2YWx1ZSBzaG91bGQgYmUgZXZhbHVhdGVkIGFuZCB3YXRjaGVkIG9yIG5vdC5cbiAgICovXG4gIHN0YXRpYyBldmFsdWF0ZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBNaXhpbi53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIG1peGluLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIE1peGlufSBOZXcgbWl4aW4uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIG1peGlucy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIG1peGluIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gd3JhcHBlcnMucmVkdWNlKHdyYXBNaXhpbiwgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgY29tbWVudCxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCB3YXRjaGVycyA9IFtdO1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3IgfSA9IGdldFByb3RvKHRoaXMpO1xuICAgIGNvbnN0IGFmdGVyVXBkYXRlID0gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgdGhpcy4kJC52YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IE1peGluIyQkXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gTWl4aW4jJCQuZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gTWl4aW4jJCQuaXNEeW5hbWljIC0gSWYgdGhlIG1peGluIGlzIGR5bmFtaWMuXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IE1peGluIyQkLmlzUmVtb3ZlZCAtIElmIHRoZSBibG9jayBpcyByZW1vdmVkLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IE1peGluIyQkLm5hbWUgLSBNaXhpbiBuYW1lLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBNaXhpbiMkJC5wYXJlbnRCbG9jayAtIFBhcmVudCBibG9jay5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gTWl4aW4jJCQucGFyZW50U2NvcGUgLSBQYXJlbnQgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IE1peGluIyQkLnBhcmVudFRlbXBsYXRlIC0gUGFyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHByb3BlcnR5IHtXYXRjaGVyW119IEJsb2NrIyQkLndhdGNoZXJzIC0gVGVtcG9yYXJ5IHZhcnMgd2F0Y2hlcnMuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBCbG9jayMkJC53YXRjaGVyc1RvUmVtb3ZlIC0gV2F0Y2hlcnMgdG8gcmVtb3ZlIGJlZm9yZSByZW1vdmluZyBtaXhpbi5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgX3ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzRHluYW1pYzogZHluYW1pYyxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgd2F0Y2hlcnMsXG4gICAgICAgIHdhdGNoZXJzVG9SZW1vdmUsXG4gICAgICAgIGlzUmVtb3ZlZDogZmFsc2UsXG4gICAgICAgIGV2YWx1YXRlOiAod2F0Y2hlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzRHluYW1pYyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgX3ZhbHVlXG4gICAgICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gaXNEeW5hbWljXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKF92YWx1ZSk7XG5cbiAgICAgICAgICBpZiAod2F0Y2hlcikge1xuICAgICAgICAgICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChpc1BhcmVudFNpZ25hbCkgPT4ge1xuICAgICAgICAgIGlzUGFyZW50U2lnbmFsID0gISFpc1BhcmVudFNpZ25hbDtcbiAgICAgICAgICB0aGlzLiQkLmlzUmVtb3ZlZCA9IHRydWU7XG5cbiAgICAgICAgICByZW1vdmVXYXRjaGVycyh3YXRjaGVyc1RvUmVtb3ZlKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZVJlbW92ZShpc1BhcmVudFNpZ25hbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlUmVtb3ZlOmAsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCkge1xuICAgICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHBhcmVudEJsb2NrLiQkLm1peGlucywgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRBZnRlclVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGlmIChjb25zdHJ1Y3Rvci5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgYWZ0ZXJVcGRhdGUodGhpcy4kJC5ldmFsdWF0ZShhZnRlclVwZGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IFtNaXhpbiNhcmdzXVxuICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5hcmdzID0gYXJncztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gW01peGluI2NvbW1lbnRdXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jsb2NrfSBbTWl4aW4jcGFyZW50U2NvcGVdXG4gICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudFRlbXBsYXRlXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbX0gTWl4aW4jZWxlbVxuICAgICAqIEB0eXBlIHtFbGVtfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gTWl4aW4jbm9kZVxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGUgPSBlbGVtWzBdO1xuXG4gICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnB1c2godGhpcyk7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBNaXhpbiNiZWZvcmVSZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRWxlbWVudFJlbW92ZWQgLSBJZiBlbGVtZW50IHJlbW92ZWQgYXMgd2VsbC5cbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBiZWZvcmUgdGhlIG1peGluIHJlbW92YWwuXG4gICAqL1xuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge31cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtXYXRjaGVyfSBbY2FsbGJhY2tdIC0gSWYgcHJlc2VudCwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIG1peGluIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoY2FsbGJhY2spO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nVGFnO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKE1peGluLCAnTWl4aW4nKTtcblxuZXhwb3J0IHsgTWl4aW4gfTtcbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcyxcbiAgYXNzaWduLCBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzRnVuY3Rpb24sIGlzQXJyYXksXG4gIHNldFRvU3RyaW5nVGFnLCBoYXNPd25Qcm9wZXJ0eSxcbiAgcmVtb3ZlQXJyYXlFbGVtLCBjcmVhdGUsXG4gIGdldFByb3RvLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGNvbnN0cnVjdE1peGluUmVnZXgsIGlzSW5zdGFuY2VPZiwgbm9ybWFsaXplQXJncyxcbiAgcmVtb3ZlV2F0Y2hlcnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNsZWFuUHJvcGVydHksXG4gIHRyYW5zZm9ybVJlc3RBcmdzLCBjYWxjdWxhdGVBcmdzLCB3cmFwQmxvY2tcbn0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7XG4gIERfUkVTVF9SRUdFWCxcbiAgcm9vdEJsb2Nrcywgcm9vdE1peGluc1xufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4vTWl4aW4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlbXBsYXRlXG4gKiBAcHVibGljXG4gKiBAcHJvcGVydHkge1N0cmluZ1tdfSB2YXJzIC0gVGVtcGxhdGUgdXNlZCB2YXJzLlxuICogQHByb3BlcnR5IHtPYmplY3RbXX0gdmFsdWUgLSBUZW1wbGF0ZSBpdHNlbGYuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0W119IFNjb3BlbGVzc1RlbXBsYXRlXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEV2YWx1YXRpb25FcnJvclxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHdoaWNoIGNhdXNlZCBldmFsIGVycm9yLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG9yaWdpbmFsIC0gRXZhbHVhdGVkIGV4cHJlc3Npb24gb3JpZ2luYWwganMuXG4gKiBAcHJvcGVydHkge0Jsb2NrfSBibG9jayAtIEJsb2NrIGluIGNvbnRleHQgb2Ygd2hpY2ggdGhlIGV4cHJlc3Npb24gaGFzIGJlZW4gZXZhbHVhdGVkIHdpdGggdGhlIGVycm9yLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhdGNoZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdyYXBwZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIEJsb2NrfHR5cGVvZiBNaXhpbn0gQmxvY2sgY2xhc3MgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t9IE5ldyBCbG9jayBjbGFzcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBZnRlclVwZGF0ZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXG4gKiBAcGFyYW0ge01peGlufSBtaXhpbiAtIE1peGluIGluc3RhbmNlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEJsb2NrUmVnaXN0ZXJIb29rXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3R5cGVvZiBCbG9ja30gQmxvY2sgLSBSZWdpc3RlcmluZyBibG9jay5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgbmFtZS5cbiAqIEByZXR1cm5zIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciByZWdpc3RlcmluZyB0aGUgYmxvY2suXG4gKiBJZiBCbG9jayBzdWJjbGFzcyByZXR1cm5lZCBpdCdzIHJlZ2lzdGVyZWQgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCBibG9jaywgb3RoZXJ3aXNlXG4gKiB0aGUgaW5pdGlhbCBibG9jayBpcyB1c2VkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1peGluUmVnaXN0ZXJIb29rXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3R5cGVvZiBNaXhpbn0gTWl4aW4gLSBSZWdpc3RlcmluZyBtaXhpbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTWl4aW4gbmFtZS5cbiAqIEByZXR1cm5zIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciByZWdpc3RlcmluZyB0aGUgbWl4aW4uXG4gKiBJZiBNaXhpbiBzdWJjbGFzcyByZXR1cm5lZCBpdCdzIHJlZ2lzdGVyZWQgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCBtaXhpbiwgb3RoZXJ3aXNlXG4gKiB0aGUgaW5pdGlhbCBtaXhpbiBpcyB1c2VkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlbW92ZUhvb2tcbiAqIEBwdWJsaWNcbiAqL1xuXG5jb25zdCBibG9ja0hvb2tzID0gW107XG5jb25zdCBtaXhpbkhvb2tzID0gW107XG5jb25zdCBUQUdfTkFNRV9SRUdFWCA9IC9eW2Etel1bYS16XFxkXFwtXy46IUAjJCVeJiooKVtcXF17fT0nXCJcXFxcXSokL2k7XG5jb25zdCBBVFRSX05BTUVfUkVHRVggPSAvXlteXFx1MDAwMC1cXHUwMDIwXFxzJ1wiPi89XSskLztcbmNvbnN0IHRvU3RyaW5nVGFnID0gJ1tvYmplY3QgQmxvY2tdJztcbmNvbnN0IGFmdGVyRWxlbSA9IG5ldyBFbGVtKCk7XG5jb25zdCBlbXB0eU9iamVjdCA9IHt9O1xubGV0IGV2YWxNb2RlID0gZmFsc2U7XG5sZXQgZ2V0dGluZ1ZhcnMgPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgQmxvY2tcbiAqIEBleHRlbmRzIG51bGxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQmxvY2sgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtCbG9ja30gSW5zdGFuY2Ugb2YgQmxvY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEJsb2NrLCBpbml0QXBwIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiBjbGFzcyBBcHAgZXh0ZW5kcyBCbG9jayB7XG4gKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8SGVsbG8gdGV4dD1cInt0ZXh0fVwiLz4gKHsgdGhpcy50aW1lcyB9KSc7XG4gKlxuICogICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gKiAgICAgc3VwZXIob3B0cyk7XG4gKlxuICogICAgIHRoaXMudGV4dCA9ICd3b3JsZCc7XG4gKiAgICAgdGhpcy50aW1lcyA9IDA7XG4gKlxuICogICAgIHRoaXMuc2V0SW50ZXJ2YWwoKTtcbiAqICAgfVxuICpcbiAqICAgc2V0SW50ZXJ2YWwoKSB7XG4gKiAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAqICAgICAgIHRoaXMudGltZXMrKztcbiAqICAgICB9KTtcbiAqICAgfVxuICpcbiAqICAgYmVmb3JlUmVtb3ZlKCkge1xuICogICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBCbG9jay5ibG9jaygnQXBwJywgQXBwKTtcbiAqIEJsb2NrLmJsb2NrKCdIZWxsbycsIGh0bWxgSGVsbG8sIHthcmdzLnRleHR9IWApO1xuICpcbiAqIGluaXRBcHAoJ0FwcCcsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykpO1xuICovXG5jbGFzcyBCbG9jayB7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPFN0cmluZywgdHlwZW9mIEJsb2NrPn0gQmxvY2suX2Jsb2Nrc1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIHR5cGVvZiBCbG9jaz59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIG5hbWVzcGFjZSBibG9ja3MuXG4gICAqL1xuICBzdGF0aWMgX2Jsb2NrcyA9IGNyZWF0ZShyb290QmxvY2tzKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0LjxTdHJpbmcsIHR5cGVvZiBNaXhpbj59IEJsb2NrLl9taXhpbnNcbiAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCB0eXBlb2YgTWl4aW4+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBuYW1lc3BhY2UgbWl4aW5zLlxuICAgKi9cbiAgc3RhdGljIF9taXhpbnMgPSBjcmVhdGUocm9vdE1peGlucyk7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLmRlZmF1bHRBcmdzID0gbnVsbF1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgZGVmYXVsdCBhcmdzLlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRBcmdzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2suZGVmYXVsdExvY2FscyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRlZmF1bHQgbG9jYWxzLlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRMb2NhbHMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay50ZW1wbGF0ZSA9IHsgdmFyczogW10sIHZhbHVlOiBbXSB9XVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayB0ZW1wbGF0ZS5cbiAgICovXG4gIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICB2YXJzOiBbXSxcbiAgICB2YWx1ZTogW11cbiAgfTtcblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEJsb2NrLm9uRXZhbEVycm9yXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFdmFsdWF0aW9uRXJyb3J9IGVyciAtIFRoZSBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYW4gZXZhbHVhdGlvbiBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBzdGF0aWMgb25FdmFsRXJyb3IoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXZhbCBlcnJvciAoZXZhbHVhdGluZyBcIiR7IGVyci5vcmlnaW5hbCB8fCBlcnIuZnVuYyB9XCIgaW4gY29udGV4dCBvZiAkeyBlcnIuYmxvY2suJCQubmFtZSB9KTpgLCBlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBCbG9jay5iZWZvcmVSZWdpc3RlckJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtCbG9ja1JlZ2lzdGVySG9va30gaG9vayAtIEJsb2NrIHJlZ2lzdGVyIGhvb2suXG4gICAqIEByZXR1cm5zIHtSZW1vdmVIb29rfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZVJlZ2lzdGVyQmxvY2soaG9vaykge1xuICAgIGJsb2NrSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW1vdmVBcnJheUVsZW0oYmxvY2tIb29rcywgaG9vayk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2suYmVmb3JlUmVnaXN0ZXJNaXhpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TWl4aW5SZWdpc3Rlckhvb2t9IGhvb2sgLSBNaXhpbiByZWdpc3RlciBob29rLlxuICAgKiBAcmV0dXJucyB7UmVtb3ZlSG9va31cbiAgICovXG4gIHN0YXRpYyBiZWZvcmVSZWdpc3Rlck1peGluKGhvb2spIHtcbiAgICBtaXhpbkhvb2tzLnB1c2goaG9vayk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlQXJyYXlFbGVtKG1peGluSG9va3MsIGhvb2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEJsb2NrLmJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge1RlbXBsYXRlfFNjb3BlbGVzc1RlbXBsYXRlfHR5cGVvZiBCbG9ja30gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBCbG9jayBvciB0ZW1wbGF0ZSBzdHJpbmcgb2YgaXQuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t8dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgQmxvY2sgb3IgdW5kZWZpbmVkIGlmIHRoZSBibG9jayBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgYmxvY2sgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGlzLlxuICAgKi9cbiAgc3RhdGljIGJsb2NrKG5hbWUsIFN1YmNsYXNzKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oU3ViY2xhc3MpICYmICFpc0luc3RhbmNlT2YoQmxvY2ssIFN1YmNsYXNzKSkge1xuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBTdWJjbGFzcztcblxuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgICAgc3RhdGljIHRlbXBsYXRlID0gY29uc3RydWN0b3IudGVtcGxhdGU7XG5cbiAgICAgICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICAgIHRoaXM6OmNvbnN0cnVjdG9yKG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgaXNBcnJheShTdWJjbGFzcykpIHtcbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICB2YWx1ZTogU3ViY2xhc3NcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiBpc0FycmF5KFN1YmNsYXNzLnZhcnMpICYmIGlzQXJyYXkoU3ViY2xhc3MudmFsdWUpKSB7XG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgICBzdGF0aWMgdGVtcGxhdGUgPSBTdWJjbGFzcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0luc3RhbmNlT2YoQmxvY2ssIFN1YmNsYXNzKSkge1xuICAgICAgY29uc29sZS53YXJuKGBCbG9jayBtdXN0IGJlIGEgdGVtcGxhdGUgKGFycmF5IG9yIGFuIG9iamVjdCBmcm9tIGFuIGh0bWwgbG9hZGVyKSwgYSBmdW5jdGlvbiBvciBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBCbG9jayBjbGFzcyAobmFtZTogXCIkeyBuYW1lIH1cIikgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdkLWVsZW1lbnRzJykge1xuICAgICAgY29uc29sZS53YXJuKCdUaGUgXCJkLWVsZW1lbnRzXCIgYmxvY2sgaXMgYSBidWlsdC1pbiBibG9jayBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2suYmxvY2spJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIVRBR19OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTmFtZSBcIiR7IG5hbWUgfVwiIGlzIG5vdCBhbGxvd2VkIGZvciBibG9ja3Mgc28gdGhlIGJsb2NrIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnX2Jsb2NrcycpKSB7XG4gICAgICB0aGlzLl9ibG9ja3MgPSBjcmVhdGUoZ2V0UHJvdG8odGhpcykuX2Jsb2Nrcyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdExvY2FscycpKSB7XG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdkZWZhdWx0QXJncycpKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBcmdzID0gY3JlYXRlKG51bGwpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBTdWJjbGFzcyA9IGJsb2NrSG9va3MucmVkdWNlKChyZXR1cm5WYWx1ZSwgaG9vaykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50UmV0dXJuVmFsdWUgPSBob29rKHJldHVyblZhbHVlLCBuYW1lLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gaXNJbnN0YW5jZU9mKEJsb2NrLCBjdXJyZW50UmV0dXJuVmFsdWUpXG4gICAgICAgICAgPyBjdXJyZW50UmV0dXJuVmFsdWVcbiAgICAgICAgICA6IHJldHVyblZhbHVlO1xuICAgICAgfSwgU3ViY2xhc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgZXJyb3IgaW4gXCJiZWZvcmVSZWdpc3RlckJsb2NrXCIgaG9vazonLCBlcnIpO1xuICAgIH1cblxuICAgIFN1YmNsYXNzLl9ibG9ja3MgPSBoYXNPd25Qcm9wZXJ0eShTdWJjbGFzcywgJ19ibG9ja3MnKVxuICAgICAgPyBTdWJjbGFzcy5fYmxvY2tzXG4gICAgICA6IGNyZWF0ZSh0aGlzLl9ibG9ja3MpO1xuICAgIFN1YmNsYXNzLl9taXhpbnMgPSBoYXNPd25Qcm9wZXJ0eShTdWJjbGFzcywgJ19taXhpbnMnKVxuICAgICAgPyBTdWJjbGFzcy5fbWl4aW5zXG4gICAgICA6IGNyZWF0ZSh0aGlzLl9taXhpbnMpO1xuXG4gICAgaWYgKGhhc093blByb3BlcnR5KFN1YmNsYXNzLCAnZGVmYXVsdEFyZ3MnKSkge1xuICAgICAgc2V0UHJvdG8oU3ViY2xhc3MuZGVmYXVsdEFyZ3MsIG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMuX2Jsb2Nrc1tuYW1lXSA9IFN1YmNsYXNzO1xuXG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBCbG9jay5nZXRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG5hbWUuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t8dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgQmxvY2sgd2l0aCBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEJsb2NrLmdldE1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBNaXhpbiBuYW1lLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIE1peGlufHVuZGVmaW5lZH0gUmV0dXJucyByZWdpc3RlcmVkIE1peGluIHdpdGggc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0TWl4aW4obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9taXhpbnNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEJsb2NrLm1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge3R5cGVvZiBNaXhpbnxBZnRlclVwZGF0ZX0gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBNaXhpbiBvciBBZnRlclVwZGF0ZSBjYWxsYmFjay5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbnx1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBCbG9jayBvciB1bmRlZmluZWQgaWYgdGhlIGJsb2NrIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBtaXhpbiBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgbWl4aW4obmFtZSwgU3ViY2xhc3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgIWlzSW5zdGFuY2VPZihNaXhpbiwgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zdCBhZnRlclVwZGF0ZSA9IFN1YmNsYXNzO1xuXG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICAgICAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICB0aGlzOjphZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNJbnN0YW5jZU9mKE1peGluLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgY2xhc3MgZG9lcyBub3QgZXh0ZW5kIE1peGluIG9yIGlzIG5vdCBhbiBhZnRlclVwZGF0ZSBmdW5jdGlvbiwgc28gaXQgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2QtcmVzdCcpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIFwiZC1yZXN0XCIgbWl4aW4gaXMgYSBidWlsdC1pbiBtaXhpbiBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIUFUVFJfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5hbWUgXCIkeyBuYW1lIH1cIiBpcyBub3QgYWxsb3dlZCBmb3IgbWl4aW5zIHNvIHRoZSBtaXhpbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ19taXhpbnMnKSkge1xuICAgICAgdGhpcy5fbWl4aW5zID0gY3JlYXRlKGdldFByb3RvKHRoaXMpLl9taXhpbnMpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBTdWJjbGFzcyA9IG1peGluSG9va3MucmVkdWNlKChyZXR1cm5WYWx1ZSwgaG9vaykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50UmV0dXJuVmFsdWUgPSBob29rKHJldHVyblZhbHVlLCBuYW1lLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gaXNJbnN0YW5jZU9mKE1peGluLCBjdXJyZW50UmV0dXJuVmFsdWUpXG4gICAgICAgICAgPyBjdXJyZW50UmV0dXJuVmFsdWVcbiAgICAgICAgICA6IHJldHVyblZhbHVlO1xuICAgICAgfSwgU3ViY2xhc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgZXJyb3IgaW4gXCJiZWZvcmVSZWdpc3Rlck1peGluXCIgaG9vazonLCBlcnIpO1xuICAgIH1cblxuICAgIFN1YmNsYXNzLl9tYXRjaCA9IGNvbnN0cnVjdE1peGluUmVnZXgobmFtZSk7XG5cbiAgICB0aGlzLl9taXhpbnNbbmFtZV0gPSBTdWJjbGFzcztcblxuICAgIHJldHVybiBTdWJjbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2sud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBibG9jay5cbiAgICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IGJsb2NrLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBibG9ja3MgaW50byBhbm90aGVyIGJsb2Nrcy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIGJsb2NrIHdpdGggYSBuZXcgb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2PjEyMzwvZGl2Pic7XG4gICAqIH1cbiAgICpcbiAgICogTXlCbG9jay53cmFwKChCbG9jaykgPT4ge1xuICAgKiAgIHJldHVybiBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICogICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGA8c2VjdGlvbiBjbGFzcz1cIndyYXBwZXJcIj4keyBCbG9jay50ZW1wbGF0ZSB9PC9zZWN0aW9uPmA7XG4gICAqXG4gICAqICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAqICAgICAgIHN1cGVyKG9wdHMpO1xuICAgKlxuICAgKiAgICAgICB0aGlzLmFkZGl0aW9uYWxWYXIgPSAnYWRkaXRpb25hbCc7XG4gICAqICAgICB9XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqL1xuICBzdGF0aWMgd3JhcCguLi53cmFwcGVycykge1xuICAgIHJldHVybiB3cmFwcGVycy5yZWR1Y2Uod3JhcEJsb2NrLCB0aGlzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYXJnczogb3JpZ2luYWxBcmdzLFxuICAgICAgZEJsb2NrTmFtZSxcbiAgICAgIGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBwcmV2QmxvY2tcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvciB9ID0gZ2V0UHJvdG8odGhpcyk7XG4gICAgY29uc3QgY2hpbGRyZW5CbG9ja3MgPSBbXTtcbiAgICBjb25zdCBtaXhpbnMgPSBbXTtcbiAgICBjb25zdCBpc1BhcmVudEJsb2NrID0gcGFyZW50IGluc3RhbmNlb2YgQmxvY2s7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayMkJFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBCbG9jayMkJC5hcmdzIC0gUHJpdmF0ZSBhcmdzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja1tdfSBCbG9jayMkJC5jaGlsZHJlbiAtIENoaWxkIGJsb2Nrcy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gQmxvY2sjJCQuY29udGVudCAtIENvbnRlbnQgZWxlbWVudHMuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdHx2b2lkfSBCbG9jayMkJC5kQmxvY2tBcmdzIC0gZC1ibG9jayBhcmdzLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd8dm9pZH0gQmxvY2sjJCQuZEJsb2NrTmFtZSAtIGQtYmxvY2sgbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2tbXX0gQmxvY2sjJCQuZEJsb2NrcyAtIGQtYmxvY2sncyB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gQmxvY2sjJCQuZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBCbG9jayMkJC5nbG9iYWxzIC0gUHJpdmF0ZSBnbG9iYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gQmxvY2sjJCQuaHRtbENoaWxkcmVuIC0gQmxvY2sgaHRtbCBjaGlsZHJlbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gQmxvY2sjJCQuaXNSZW1vdmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbW92ZWQuXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IEJsb2NrIyQkLmlzUmVuZGVyZWQgLSBJZiB0aGUgYmxvY2sgaXMgcmVuZGVyZWQuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQubG9jYWxzIC0gUHJpdmF0ZSBsb2NhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge01peGluW119IEJsb2NrIyQkLm1peGlucyAtIENoaWxkIG1peGlucy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gQmxvY2sjJCQubWl4aW5zVG9CdWlsZCAtIFBlbmRpbmcgbWl4aW5zIGJ1aWxkZXJzLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IEJsb2NrIyQkLm5hbWUgLSBCbG9jayBuYW1lLlxuICAgICAgICogQHByb3BlcnR5IHt0eXBlb2YgQmxvY2t9IEJsb2NrIyQkLm5zIC0gQmxvY2sgY29uc3RydWN0b3IuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfEVsZW18dm9pZH0gQmxvY2sjJCQucGFyZW50IC0gUGFyZW50IGJsb2NrIG9yIGVsZW0uXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudEJsb2NrIC0gUGFyZW50IGJsb2NrLlxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBwYXJlbnRFbGVtIC0gUGFyZW50IGVsZW1lbnQuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudFNjb3BlIC0gUGFyZW50IHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBCbG9jayMkJC5wYXJlbnRUZW1wbGF0ZSAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8RWxlbXx2b2lkfSBCbG9jayMkJC5wcmV2QmxvY2sgLSBQYXJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcHJvcGVydHkge1dhdGNoZXJbXX0gQmxvY2sjJCQud2F0Y2hlcnMgLSBUZW1wb3JhcnkgdmFycyB3YXRjaGVycy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IEJsb2NrIyQkLndhdGNoZXJzVG9SZW1vdmUgLSBXYXRjaGVycyB0byByZW1vdmUgYmVmb3JlIHJlbW92aW5nIHRoZSBibG9jay5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrQXJncyxcbiAgICAgICAgZEJsb2NrczogW10sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgY29udGVudDogbmV3IEVsZW0oKSxcbiAgICAgICAgbnM6IGNvbnN0cnVjdG9yLFxuICAgICAgICBodG1sQ2hpbGRyZW46IGNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5CbG9ja3MsXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgbWl4aW5zVG9CdWlsZDogW10sXG4gICAgICAgIHByZXZCbG9jayxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgaXNSZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGV2YWx1YXRlOiAoZnVuYywgb25DaGFuZ2UsIHRhcmdldEJsb2NrLCBmb3JERWxlbWVudHMsIGZvckRJdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JERWxlbWVudHMgPSAhIWZvckRFbGVtZW50cztcbiAgICAgICAgICBmb3JESXRlbSA9ICEhZm9yREl0ZW07XG5cbiAgICAgICAgICBjb25zdCBzY29wZSA9IG5hbWUgPT09ICcjZC1pdGVtJyAmJiAhZm9yREl0ZW1cbiAgICAgICAgICAgID8gdGhpcy4kJC5zY29wZVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgd2F0Y2hlcnNUb1JlbW92ZSB9ID0gdGFyZ2V0QmxvY2sgPyB0YXJnZXRCbG9jay4kJCA6IGVtcHR5T2JqZWN0O1xuICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlRmxhZyA9ICEhb25DaGFuZ2U7XG5cbiAgICAgICAgICBjb25zdCBldmFsdWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChvbkNoYW5nZUZsYWcpIHtcbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBnZXR0aW5nVmFycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHNjb3BlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBlcnIuZnVuYyA9IGZ1bmM7XG4gICAgICAgICAgICAgIGVyci5vcmlnaW5hbCA9IGZ1bmMub3JpZ2luYWw7XG4gICAgICAgICAgICAgIGVyci5ibG9jayA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29uc3RydWN0b3Iub25FdmFsRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9Lm9uRXZhbEVycm9yOmAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2VGbGFnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2F0Y2hlcnMgPSBbXTtcblxuICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkoZ2V0dGluZ1ZhcnMsICh3YXRjaGVycykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhdGNoZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkobG9jYWxXYXRjaGVycywgKHdhdGNoZXJCbG9jaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICB9ID0gd2F0Y2hlckJsb2NrO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVyc1RvUmVtb3ZlLCB3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc3VsdCA9IGV2YWx1YXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHQgIT09IHJlc3VsdCAmJiAhdGFyZ2V0QmxvY2suJCQuaXNSZW1vdmVkICYmICF0aGlzLiQkLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdSZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICBmb3JERWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbG9jYWxXYXRjaGVycy5wdXNoKHdhdGNoZXJCbG9jayk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZS5wdXNoKHdhdGNoZXJCbG9jayk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZ2V0dGluZ1ZhcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKGlzUGFyZW50U2lnbmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICBpdGVyYXRlQXJyYXkoY2hpbGRyZW5CbG9ja3MsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlUmVtb3ZlOmAsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgcGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5jaGlsZHJlbiwgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jb250ZW50LnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjaGFuZ2VDb250ZW50OiAobmV3Q29udGVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuY29udGVudCA9IG5ld0NvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodGhpcy4kJC5pc1JlbmRlcmVkICYmICF0aGlzLiQkLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5hZnRlckRPTUNoYW5nZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckRPTUNoYW5nZTpgLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29udGVudDogKGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkQ29udGVudCA9IHRoaXMuJCQuY29udGVudDtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9sZENvbnRlbnQuaW5kZXhPZihjb250ZW50VG9BZGRbMF0ucHJldmlvdXNTaWJsaW5nKSArIDE7XG4gICAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50VG9BZGQuYWRkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoY29udGVudFRvQWRkLCBvbGRDb250ZW50LnNsaWNlKGluZGV4KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KG5ld0NvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgIW5vdFJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvQWRkLCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZUNvbnRlbnQ6IChjb250ZW50VG9Nb3ZlLCBhZnRlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvbGRDb250ZW50LmluZGV4T2YoY29udGVudFRvTW92ZVswXSk7XG4gICAgICAgICAgY29uc3QgaW5kZXhUb1B1dCA9IG9sZENvbnRlbnQuaW5kZXhPZihhZnRlclswXSkgKyAxO1xuICAgICAgICAgIGxldCBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKGluZGV4VG9QdXQgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50VG9Nb3ZlLmFkZChcbiAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGluZGV4VG9QdXQpIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBvbGRDb250ZW50XG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleFRvUHV0KVxuICAgICAgICAgICAgICAuYWRkKFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUb01vdmUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoLCBpbmRleFRvUHV0KSxcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQobmV3Q29udGVudCk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiBpbmRleFRvUHV0KSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvTW92ZSwgYWZ0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ29udGVudDogKGNvbnRlbnRUb1JlbW92ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQuZmlsdGVyKChlbGVtKSA9PiAoXG4gICAgICAgICAgICBjb250ZW50VG9SZW1vdmUuaW5kZXhPZihlbGVtKSA9PT0gLTFcbiAgICAgICAgICApKSk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQoY29udGVudFRvUmVtb3ZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEluU3RhcnRPZkl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcblxuICAgICAgICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcblxuICAgICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSBwYXJlbnQuJCQ7XG5cbiAgICAgICAgICAgIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgICAgbGV0IG5vdFJlY3Vyc2l2ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICAgICAgbm90UmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgdGhpcy4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRBZnRlckl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcbiAgICAgICAgICBsZXQgdHJ5VG9BZGRPck1vdmU7XG5cbiAgICAgICAgICBpZiAodGhpcy4kJC5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLiQkLmNvbnRlbnQuZWxlbSgtMSk7XG4gICAgICAgICAgICB0cnlUb0FkZE9yTW92ZSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIoYWZ0ZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmIHRyeVRvQWRkT3JNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0ZXJhdGVPYmplY3QoY29uc3RydWN0b3IuZGVmYXVsdExvY2FscywgKHZhbHVlLCB2YXJpYWJsZSkgPT4ge1xuICAgICAgdGhpc1t2YXJpYWJsZV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBpdGVyYXRlQXJyYXkoY29uc3RydWN0b3IudGVtcGxhdGUudmFycyB8fCBbXSwgKHZhcmlhYmxlKSA9PiB7XG4gICAgICB0aGlzW3ZhcmlhYmxlXSA9IHRoaXNbdmFyaWFibGVdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJnc09iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB7IGRlZmF1bHRBcmdzIH0gPSBjb25zdHJ1Y3RvcjtcbiAgICBsZXQgYXJncyA9IGNyZWF0ZShkZWZhdWx0QXJncyB8fCBudWxsKTtcbiAgICBsZXQgd2FzRFJlc3Q7XG4gICAgY29uc3QgYXJnc0NoYWluID0gW107XG5cbiAgICBpZiAoZGVmYXVsdEFyZ3MpIHtcbiAgICAgIGFyZ3NDaGFpbi5wdXNoKGRlZmF1bHRBcmdzKTtcbiAgICB9XG5cbiAgICBhcmdzQ2hhaW4ucHVzaChhcmdzKTtcblxuICAgIGl0ZXJhdGVPYmplY3Qob3JpZ2luYWxBcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgY29uc3QgaXNEUmVzdCA9IERfUkVTVF9SRUdFWC50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBsb2NhbEFyZ3MgPSBpc0RSZXN0IHx8IHdhc0RSZXN0XG4gICAgICAgID8gY3JlYXRlKGFyZ3MpXG4gICAgICAgIDogYXJncztcblxuICAgICAgaWYgKGFyZ3MgIT09IGxvY2FsQXJncykge1xuICAgICAgICBhcmdzQ2hhaW4ucHVzaChsb2NhbEFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gbG9jYWxBcmdzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXJncyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXJncywgY2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgYXNzaWduKGxvY2FsQXJncywgdHJhbnNmb3JtUmVzdEFyZ3ModmFsdWUpKTtcbiAgICAgICAgICBjYWxjdWxhdGVBcmdzKG5vcm1hbGl6ZUFyZ3MoYXJnc0NoYWluKSwgYXJncywgYXJnc09iamVjdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXJncywgdHJhbnNmb3JtUmVzdEFyZ3MocmVzdEFyZ3MpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNERWxlbWVudHMgPSBuYW1lID09PSAnZC1lbGVtZW50cyc7XG4gICAgICBjb25zdCBmb3JERWxlbWVudHMgPSBpc0RFbGVtZW50cyAmJiBhcmcgPT09ICd2YWx1ZSc7XG5cbiAgICAgIHdhc0RSZXN0ID0gZmFsc2U7XG5cbiAgICAgIGxvY2FsQXJnc1thcmddID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICBsb2NhbEFyZ3NbYXJnXSA9IHZhbHVlO1xuICAgICAgICBjYWxjdWxhdGVBcmdzKG5vcm1hbGl6ZUFyZ3MoYXJnc0NoYWluKSwgYXJncywgYXJnc09iamVjdCk7XG4gICAgICB9LCB0aGlzLCBmb3JERWxlbWVudHMsIGlzREVsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLm5hbWUgPT09ICcjZC1pdGVtJyk7XG4gICAgfSk7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNhcmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhcmdzOiBhcmdzT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjZ2xvYmFsc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZ2xvYmFsczogY3JlYXRlKFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgICAgID8gcGFyZW50U2NvcGUuZ2xvYmFsc1xuICAgICAgICAgIDogbnVsbFxuICAgICAgKVxuICAgIH0pO1xuXG4gICAgY2FsY3VsYXRlQXJncyhub3JtYWxpemVBcmdzKGFyZ3NDaGFpbiksIGFyZ3MsIGFyZ3NPYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudEJsb2NrKSB7XG4gICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2sjYWZ0ZXJDb25zdHJ1Y3RcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGNvbnN0cnVjdGlvbiAoaW5jbHVkaW5nIGFsbCBzY29wZXMpXG4gICAqIGJ1dCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBibG9jayBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7fVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2sjYWZ0ZXJET01DaGFuZ2VcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIERPTSBzdHJ1Y3R1cmUgaGFzIGNoYW5nZWQuIE5vdGUgdGhhdFxuICAgKiBpdCdzIGltcG9ydGFudCBub3QgdG8gbW9kaWZ5IHRoZSBET00gc3RydWN0dXJlIHdpdGhpbiB0aGUgYmxvY2suIFlvdSBjYW4gb25seSBpbnNlcnRcbiAgICogZWxlbWVudHMgdG8gZW1wdHkgZWxlbWVudHMgKHdoaWNoIER3YXluZSBjb25zaWRlcnMgZW1wdHkpIGFuZCByZW1vdmUgb25lcyBmcm9tIHRoZW0uXG4gICAqL1xuICBhZnRlckRPTUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBCbG9jayNhZnRlclJlbmRlclxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAqL1xuICBhZnRlclJlbmRlcigpIHt9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBCbG9jayNiZWZvcmVSZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGJlZm9yZSB0aGUgYmxvY2sgcmVtb3ZhbC5cbiAgICovXG4gIGJlZm9yZVJlbW92ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBCbG9jayNnZXRET01cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgRE9NIGNvbnRlbnRzIG9mIHRoZSBibG9jay5cbiAgICovXG4gIGdldERPTSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5jb250ZW50LnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIEJsb2NrI2dldE5hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBCbG9jayBuYW1lLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBCbG9jayNnZXRQYXJlbnRFbGVtXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW18dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgcGFyZW50IEVsZW0uXG4gICAqL1xuICBnZXRQYXJlbnRFbGVtKCkge1xuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudEVsZW0uc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2sjZ2V0UGFyZW50U2NvcGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QmxvY2t8dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYmxvY2sgaW4gd2hpY2ggdGVtcGxhdGUgdGhlIGJsb2NrIGlzIGxvY2F0ZWQgaW4uXG4gICAqL1xuICBnZXRQYXJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRTY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2sjZ2V0UGFyZW50VGVtcGxhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QmxvY2t8dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYmxvY2sgaW4gd2hpY2ggdGVtcGxhdGUgdGhlIGJsb2NrIGlzIGxvY2F0ZWQgaW4uXG4gICAqL1xuICBnZXRQYXJlbnRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQmxvY2sjZXZhbHVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gW2NhbGxiYWNrXSAtIElmIHByZXNlbnQsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7QmxvY2t8TWl4aW59IFt0YXJnZXQgPSB0aGlzXSAtIFdoYXQgYmxvY2sgb3IgbWl4aW4gcmVxdWVzdHMgdGhlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGlvbiByZXN1bHQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiBpbiBjb250ZXh0IG9mIHRoZSBibG9jayBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCA9IHRoaXMpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZShmdW5jLCBjYWxsYmFjaywgdGFyZ2V0KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZztcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhCbG9jaywgJ0Jsb2NrJyk7XG5zZXRQcm90byhCbG9jay5wcm90b3R5cGUsIG51bGwpO1xuXG5leHBvcnQgeyBCbG9jaywgZ2V0dGluZ1ZhcnMsIGV2YWxNb2RlIH07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHdhdGNoTmFtZUFyZ3MgPSBqc2BhcmdzLm5hbWVgO1xuY29uc3Qgd2F0Y2hDb25zdHJ1Y3RvckFyZ3MgPSBqc2BhcmdzLkNvbnN0cnVjdG9yYDtcblxuY2xhc3MgREJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7UGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwie1BhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcblxuICBhZnRlckNvbnN0cnVjdChvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGU6IHtcbiAgICAgICAgJCQ6IHtcbiAgICAgICAgICBwYXJlbnRTY29wZTogcGFyZW50UGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGU6IHBhcmVudFBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIGh0bWxDaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGh0bWxDaGlsZHJlbjogb3duQ2hpbGRyZW4sXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZEJsb2NrTmFtZTogREJsb2NrTmFtZVxuICAgIH0gPSB0aGlzLiQkO1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBDb25zdHJ1Y3RvclxuICAgIH0gPSB0aGlzLmFyZ3M7XG4gICAgbGV0IGZvdW5kO1xuXG4gICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdER5bmFtaWNOYW1lQmxvY2soXG4gICAgICAgIHRoaXMuZXZhbHVhdGUod2F0Y2hOYW1lQXJncywgdGhpcy5jb25zdHJ1Y3REeW5hbWljTmFtZUJsb2NrKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5jb25zdHJ1Y3REeW5hbWljQ29uc3RydWN0b3JCbG9jayhcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSh3YXRjaENvbnN0cnVjdG9yQXJncywgdGhpcy5jb25zdHJ1Y3REeW5hbWljQ29uc3RydWN0b3JCbG9jaylcbiAgICAgICk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3duQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBwYXJlbnRUZW1wbGF0ZS4kJC5kQmxvY2tzLnB1c2godGhpcyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50UGFyZW50U2NvcGU7XG4gICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFBhcmVudFRlbXBsYXRlO1xuXG4gICAgaWYgKERCbG9ja05hbWUpIHtcbiAgICAgIGZvdW5kID0gZmluZEluQXJyYXkoY2hpbGRyZW4sICh7IG5hbWU6IG5vZGVOYW1lIH0pID0+IG5vZGVOYW1lID09PSBgZC1ibG9jazokeyBEQmxvY2tOYW1lIH1gKTtcblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICBmb3VuZCA9IGZpbmRJbkFycmF5KHBhcmVudFRlbXBsYXRlLiQkLmRCbG9ja3MsICh7ICQkOiB7IGRCbG9ja05hbWUgfSB9KSA9PiBkQmxvY2tOYW1lID09PSBEQmxvY2tOYW1lKTtcblxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICAgICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgICAgICAgIGZvdW5kLnZhbHVlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGZvdW5kLnZhbHVlLiQkLmh0bWxDaGlsZHJlblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kXG4gICAgICAgID8gZm91bmQudmFsdWUuY2hpbGRyZW5cbiAgICAgICAgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0RHluYW1pY05hbWVCbG9jayA9IChuYW1lKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgZEJsb2NrQXJnc1xuICAgIH0gPSB0aGlzLiQkO1xuXG4gICAgdGhpcy5lbGVtcyA9IFt7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cnM6IGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbjogaHRtbENoaWxkcmVuXG4gICAgfV07XG4gIH07XG5cbiAgY29uc3RydWN0RHluYW1pY0NvbnN0cnVjdG9yQmxvY2sgPSAoQ29uc3RydWN0b3IpID0+IHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aGlzLmVsZW1zID0gbnVsbDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIGRCbG9ja0FyZ3NcbiAgICB9ID0gdGhpcy4kJDtcblxuICAgIHRoaXMuZWxlbXMgPSBbe1xuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBhdHRyczogZEJsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBodG1sQ2hpbGRyZW5cbiAgICB9XTtcbiAgfTtcbn1cblxucm9vdEJsb2Nrc1snZC1ibG9jayddID0gREJsb2NrO1xuXG5leHBvcnQgeyBEQmxvY2sgfTtcbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuXG5jb25zdCB0ZW1wbGF0ZSA9IGh0bWxgXG4gIDxkLWVsZW1lbnRzXG4gICAgdmFsdWU9XCJ7JCQuaHRtbENoaWxkcmVufVwiXG4gICAgcGFyZW50U2NvcGU9XCJ7dGhpc31cIlxuICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gIC8+XG5gO1xuXG5jbGFzcyBESXRlbSBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gdGVtcGxhdGU7XG59XG5cbmV4cG9ydCB7IERJdGVtIH07XG4iLCJpbXBvcnQge1xuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzQXJyYXksIGlzRnVuY3Rpb24sIGNyZWF0ZVxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyByZW1vdmUsIGNyZWF0ZUJsb2NrIH0gZnJvbSAnLi4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgREl0ZW0gfSBmcm9tICcuL2QtaXRlbSc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYFtcbiAgYXJncy5zZXQsXG4gIGFyZ3MuZmlsdGVyQnksXG4gIGFyZ3Muc29ydEJ5XG5dYDtcblxucm9vdEJsb2Nrc1snZC1lYWNoJ10gPSBjbGFzcyBERWFjaCBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGRlZmF1bHRBcmdzID0ge1xuICAgIHVpZChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzOiB7XG4gICAgICAgIGl0ZW0gPSAnJGl0ZW0nLFxuICAgICAgICBpbmRleCA9ICckaW5kZXgnXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG5cbiAgICB0aGlzLml0ZW1OYW1lID0gaXRlbTtcbiAgICB0aGlzLmluZGV4TmFtZSA9IGluZGV4O1xuICAgIHRoaXMuaXRlbXNCeVVJRHMgPSBjcmVhdGUobnVsbCk7XG4gIH1cblxuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICB0aGlzLnJlbmRlclNldCh0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgdGhpcy5yZW5kZXJTZXQpKTtcbiAgfVxuXG4gIHJlbmRlclNldCA9IChhcmdzKSA9PiB7XG4gICAgbGV0IHNldCA9IGFyZ3NbMF07XG4gICAgbGV0IGZpbHRlckJ5ID0gYXJnc1sxXTtcbiAgICBjb25zdCBzb3J0QnkgPSBhcmdzWzJdO1xuXG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9ID0gdGhpcy4kJDtcbiAgICBjb25zdCB7XG4gICAgICBhcmdzOiB7XG4gICAgICAgIHVpZDogVUlEXG4gICAgICB9LFxuICAgICAgaXRlbXNCeVVJRHMsXG4gICAgICBpdGVtTmFtZSxcbiAgICAgIGluZGV4TmFtZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0l0ZW1zQnlVSURzID0gY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IG5ld1VJRHNCeUluZGV4ZXMgPSBjcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbmV3VUlEcyA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBpc0FyciA9IGlzQXJyYXkoc2V0KTtcbiAgICBjb25zdCBpdGVyYXRlID0gaXNBcnJcbiAgICAgID8gaXRlcmF0ZUFycmF5XG4gICAgICA6IGl0ZXJhdGVPYmplY3Q7XG5cbiAgICBpZiAoaXNBcnIgJiYgaXNGdW5jdGlvbihzb3J0QnkpKSB7XG4gICAgICBzZXQgPSBzZXRcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnNvcnQoc29ydEJ5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXJCeSkpIHtcbiAgICAgIGZpbHRlckJ5ID0gW2ZpbHRlckJ5XTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShmaWx0ZXJCeSkpIHtcbiAgICAgIGl0ZXJhdGVBcnJheShmaWx0ZXJCeSwgKGZpbHRlcikgPT4ge1xuICAgICAgICBzZXQgPSBzZXQuZmlsdGVyKGZpbHRlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpdGVyYXRlKHNldCwgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB1aWQgPSBVSUQoaXRlbSwgaW5kZXgsIHNldCwgcGFyZW50U2NvcGUpO1xuXG4gICAgICBpZiAodWlkIGluIG5ld1VJRHNCeUluZGV4ZXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVUlEcyBjYW4ndCBiZSBzYW1lIGZvciBtdWx0aXBsZSBpdGVtcyEgSW4gVUlEIGZ1bmN0aW9uOiBcIiR7IFVJRC5vcmlnaW5hbCB8fCBVSUQgfVwiYCk7XG4gICAgICB9XG5cbiAgICAgIG5ld1VJRHNCeUluZGV4ZXNbdWlkXSA9IGluZGV4O1xuICAgICAgbmV3VUlEc1tpbmRleF0gPSB1aWQ7XG4gICAgfSk7XG5cbiAgICBpdGVyYXRlT2JqZWN0KGl0ZW1zQnlVSURzLCAoYmxvY2ssIHVpZCkgPT4ge1xuICAgICAgaWYgKCEodWlkIGluIG5ld1VJRHNCeUluZGV4ZXMpKSB7XG4gICAgICAgIHJlbW92ZShibG9jayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgaXRlcmF0ZShzZXQsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdWlkID0gbmV3VUlEc1tpbmRleF07XG4gICAgICBsZXQgYmxvY2s7XG5cbiAgICAgIGlmIChuZXdVSURzQnlJbmRleGVzW3VpZF0gIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJldlVJREJsb2NrID0gaXRlbXNCeVVJRHNbdWlkXTtcblxuICAgICAgaWYgKHByZXZVSURCbG9jaykge1xuICAgICAgICBibG9jayA9IHByZXZVSURCbG9jaztcbiAgICAgICAgYmxvY2suJCQuc2NvcGVbaW5kZXhOYW1lXSA9IGluZGV4O1xuICAgICAgICBibG9jay4kJC5zY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuXG4gICAgICAgIGlmIChibG9jay4kJC5wcmV2QmxvY2sgIT09IHByZXZCbG9jaykge1xuICAgICAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gYmxvY2suJCQ7XG5cbiAgICAgICAgICBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50LCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIGl0ZW1OYW1lLFxuICAgICAgICAgICAgaW5kZXhOYW1lLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgbmFtZTogJyNkLWl0ZW0nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3I6IERJdGVtLFxuICAgICAgICAgICAgY2hpbGRyZW46IGh0bWxDaGlsZHJlblxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2s6IHRoaXMsXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBuZXdJdGVtc0J5VUlEc1t1aWRdID0gYmxvY2s7XG4gICAgICBibG9jay4kJC5wcmV2QmxvY2sgPSBwcmV2QmxvY2s7XG4gICAgICBwcmV2QmxvY2sgPSBibG9jaztcbiAgICB9KTtcblxuICAgIHRoaXMuaXRlbXNCeVVJRHMgPSBuZXdJdGVtc0J5VUlEcztcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIHJlbW92ZUFycmF5RWxlbSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNyZWF0ZUJsb2NrIH0gZnJvbSAnLi4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi9FbGVtJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BhcmdzLnZhbHVlYDtcblxucm9vdEJsb2Nrc1snZC1lbGVtZW50cyddID0gY2xhc3MgREVsZW1lbnRzIGV4dGVuZHMgQmxvY2sge1xuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICBjb25zdCB7IHBhcmVudEVsZW0gfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICB0aGlzLiQkLmV2YWx1YXRlKHdhdGNoQXJncywgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtaXhpbnMsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IHRoaXMuJCQ7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG5cbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kJC5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy4kJC5taXhpbnMgPSBbXTtcbiAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JERWxlbWVudHMgfSkgPT4ge1xuICAgICAgICBpZiAoZm9yREVsZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiQkLmNvbnRlbnQgPSBuZXcgRWxlbSgpO1xuXG4gICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICBpdGVyYXRlQXJyYXkodmFsdWUgfHwgW10sIChjaGlsZCkgPT4ge1xuICAgICAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2s6IHRoaXMsXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpdGVyYXRlQXJyYXkodGhpcy4kJC5taXhpbnNUb0J1aWxkLCAoZXhlY3V0ZUJ1aWxkZXJzKSA9PiB7XG4gICAgICAgIGV4ZWN1dGVCdWlsZGVycygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiQkLm1peGluc1RvQnVpbGQgPSBbXTtcbiAgICB9LCB0aGlzLCB0cnVlKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MuaWZgO1xuXG5yb290QmxvY2tzWydkLWlmJ10gPSBjbGFzcyBESWYgZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyB0ZW1wbGF0ZSA9IGh0bWxgXG4gICAgPGQtZWxlbWVudHNcbiAgICAgIHZhbHVlPVwie2VsZW1zfVwiXG4gICAgICBwYXJlbnRTY29wZT1cInskJC5wYXJlbnRTY29wZX1cIlxuICAgICAgcGFyZW50VGVtcGxhdGU9XCJ7JCQucGFyZW50VGVtcGxhdGV9XCJcbiAgICAvPlxuICBgO1xuXG4gIGFmdGVyQ29uc3RydWN0KCkge1xuICAgIHRoaXMuY29uZGl0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jb25zdHJ1Y3RFbGVtcyh0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgdGhpcy5jb25zdHJ1Y3RFbGVtcykpO1xuICB9XG5cbiAgY29uc3RydWN0RWxlbXMgPSAoY29uZGl0aW9uKSA9PiB7XG4gICAgY29uZGl0aW9uID0gISFjb25kaXRpb247XG5cbiAgICBpZiAodGhpcy5jb25kaXRpb24gIT09IGNvbmRpdGlvbikge1xuICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICB0aGlzLmVsZW1zID0gY29uZGl0aW9uXG4gICAgICAgID8gdGhpcy4kJC5odG1sQ2hpbGRyZW5cbiAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYFtcbiAgYXJncy52YWx1ZSxcbiAgYXJncy5jb21wYXJlRm5cbl1gO1xuXG5yb290QmxvY2tzWydkLXN3aXRjaCddID0gY2xhc3MgRFN3aXRjaCBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICA8ZC1lbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG4gIHN0YXRpYyBkZWZhdWx0QXJncyA9IHtcbiAgICBjb21wYXJlRm4oc3dpdGNoVmFsdWUsIGNhc2VWYWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgc3dpdGNoVmFsdWUgPT09IGNhc2VWYWx1ZVxuICAgICAgICB8fCAoc3dpdGNoVmFsdWUgIT09IHN3aXRjaFZhbHVlICYmIGNhc2VWYWx1ZSAhPT0gY2FzZVZhbHVlKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgaW5kZXggPSBJbmZpbml0eTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICAkJDoge1xuICAgICAgICBodG1sQ2hpbGRyZW4sXG4gICAgICAgIHBhcmVudFNjb3BlXG4gICAgICB9LFxuICAgICAgYXJncyxcbiAgICAgIGFyZ3M6IHsgdmFsdWUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB3YXNEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICB0aGlzLnZhbHVlcyA9IGh0bWxDaGlsZHJlblxuICAgICAgLmZpbHRlcigoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKG5hbWUgIT09ICdkLWNhc2UnICYmIG5hbWUgIT09ICdkLWRlZmF1bHQnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhc0RlZmF1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgICB3YXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJzID0ge30sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBsZXQgdmFsO1xuXG4gICAgICAgIGlmIChuYW1lICE9PSAnZC1kZWZhdWx0Jykge1xuICAgICAgICAgIHZhbCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGF0dHJzLmlmLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzW2ldLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gZmluZEluQXJyYXkodGhpcy52YWx1ZXMsICh7IG5hbWUsIHZhbHVlIH0pID0+IChcbiAgICAgICAgICAgICAgbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICAgICAgfHwgdGhpcy5hcmdzLmNvbXBhcmVGbihhcmdzLnZhbHVlLCB2YWx1ZSlcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gZm91bmRcbiAgICAgICAgICAgICAgPyBmb3VuZC5rZXlcbiAgICAgICAgICAgICAgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZFxuICAgICAgICAgICAgICA/IGZvdW5kLnZhbHVlLmNoaWxkcmVuXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBJbmZpbml0eSAmJiAoXG4gICAgICAgICAgbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKHZhbHVlLCB2YWwpXG4gICAgICAgICkpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgKGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gYXJnc1swXTtcbiAgICAgIGNvbnN0IGNvbXBhcmVGbiA9IGFyZ3NbMV07XG5cbiAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcblxuICAgICAgdGhpcy52YWx1ZXMuc29tZSgoeyBuYW1lLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICB8fCBjb21wYXJlRm4obmV3VmFsdWUsIHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmluZGV4ID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLWJpbmQnXSA9IGNsYXNzIERCaW5kIGV4dGVuZHMgTWl4aW4ge1xuICBvZmYgPSBub29wO1xuXG4gIGFmdGVyVXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5vZmYoKTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLm9mZiA9IHRoaXMuZWxlbS5vbih0aGlzLmFyZ3Muam9pbignLCcpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmID0gbm9vcDtcblxuICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtYmluZFwiIG1peGluIHdpdGggYW4gZXZlbnQgbmFtZXMgKGxpa2UgXCJkLWJpbmQoY2xpY2spXCIgb3IgXCJkLWJpbmQoa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5vZmYoKTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQge1xuICBpc0FycmF5LCBpc1N0cmluZyxcbiAgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0XG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IEVNUFRZX1NQQUNFX1JFR0VYID0gL1xccysvO1xuXG5yb290TWl4aW5zWydkLWNsYXNzJ10gPSBjbGFzcyBEQ2xhc3MgZXh0ZW5kcyBNaXhpbiB7XG4gIGNsYXNzZXMgPSBbXTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgY2xhc3Nlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBbXTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlXG4gICAgICAgID8gYXJnc1xuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc3BsaXQoRU1QVFlfU1BBQ0VfUkVHRVgpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgaXRlcmF0ZUFycmF5KGNsYXNzZXMsIChjbHMpID0+IHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlLmluZGV4T2YoY2xzKSA9PT0gLTEpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZUFycmF5KG5ld1ZhbHVlLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyhjbHMpKSB7XG4gICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZUFycmF5KGNsYXNzZXMsIChjbHMpID0+IHtcbiAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCAhbmV3VmFsdWVbY2xzXSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlT2JqZWN0KG5ld1ZhbHVlLCAodmFsLCBjbHMpID0+IHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGFzc2VzID0gbmV3Q2xhc3NlcztcbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGNsYXNzZXNcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBlbGVtLnJlbW92ZUNsYXNzLmFwcGx5KGVsZW0sIGNsYXNzZXMpO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLWVsZW0nXSA9IGNsYXNzIERFbGVtIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBlbGVtXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHNjb3BlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogcGFyZW50VGVtcGxhdGU7XG4gICAgICB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShlbGVtKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgc2NvcGVbdmFsdWVdID0gZWxlbTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jbGFzcyBESGlkZSBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5lbGVtLnNob3coKTtcbiAgICB9XG4gIH1cbn1cblxucm9vdE1peGluc1snZC1oaWRlJ10gPSBESGlkZTtcblxuZXhwb3J0IHsgREhpZGUgfTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLW5vZGUnXSA9IGNsYXNzIEROb2RlIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBub2RlXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHNjb3BlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogcGFyZW50VGVtcGxhdGU7XG4gICAgICB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgc2NvcGVbdmFsdWVdID0gbm9kZTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1vbiddID0gY2xhc3MgRE9uIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLm9mZiA9IHRoaXMuZWxlbS5vbih0aGlzLmFyZ3Muam9pbignLCcpLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZXZhbHVhdGUoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZiA9IG5vb3A7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3ZpZGUgXCJkLW9uXCIgbWl4aW4gd2l0aCBhbiBldmVudCBuYW1lcyAobGlrZSBcImQtb24oY2xpY2spXCIgb3IgXCJkLW9uKGtleXVwLCBrZXlwcmVzcylcIikhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICBpZiAoIWlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICAgIHRoaXMub2ZmKCk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1zaG93J10gPSBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5lbGVtLnNob3coKTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RNaXhpblJlZ2V4IH0gZnJvbSAnLi9jb25zdHJ1Y3RNaXhpblJlZ2V4JztcblxuaXRlcmF0ZU9iamVjdChyb290TWl4aW5zLCAoTWl4aW4sIG5hbWUpID0+IHtcbiAgTWl4aW4uX21hdGNoID0gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKTtcbn0pO1xuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBjcmVhdGVIaWRlU3R5bGVOb2RlIH0gZnJvbSAnLi9oZWxwZXJzL0VsZW0nO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBkb2NcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBkb2MgPSBuZXcgRWxlbShkb2N1bWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBodG1sXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWwgPSBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gYm9keVxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5ib2R5LlxuICovXG5leHBvcnQgY29uc3QgYm9keSA9IG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gaGVhZFxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5oZWFkLlxuICovXG5leHBvcnQgY29uc3QgaGVhZCA9IG5ldyBFbGVtKGRvY3VtZW50LmhlYWQpO1xuXG5jcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpO1xuIl0sIm5hbWVzIjpbImNvbGxlY3RGcm9tQXJyYXkiLCJhcnJheSIsImNhbGxiYWNrIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJpbmRleCIsImZpbmRJbkFycmF5IiwiaSIsImxlbmd0aCIsIml0ZXJhdGVBcnJheSIsInJlbW92ZUFycmF5RWxlbSIsImVsZW0iLCJpbmRleE9mIiwic3BsaWNlIiwidG9PYmplY3RLZXlzIiwiYWRkS2V5IiwidmFycyIsInZhcmlhYmxlIiwiaXNGdW5jdGlvbiIsImlzTmlsIiwiaXNTdHJpbmciLCJhc3NpZ24iLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJrZXkiLCJjb2xsZWN0RnJvbU9iamVjdCIsIm9iamVjdCIsImV4Y2VwdCIsIm5ld09iamVjdCIsInBhdGhzIiwic2xpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsIml0ZXJhdGVPYmplY3QiLCJtYXBPYmplY3QiLCJkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0eSIsImRlZmluZUZyb3plblByb3BlcnRpZXMiLCJlc2NhcGVSZWdleCIsInN0cmluZyIsInJlcGxhY2UiLCJyZWdleHBTcGVjaWFsc1JlZ2V4cCIsIm5vb3AiLCJ0b0NhbWVsQ2FzZSIsIkRBU0hFRF9TWU1CT0xfUkVHRVgiLCJjYXBpdGFsaXplIiwidG9IeXBoZW5DYXNlIiwiVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVgiLCJoeXBoZW5pemUiLCJtYXRjaCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwic2V0VG9TdHJpbmdUYWciLCJrbGFzcyIsInRhZyIsIlN5bWJvbCIsInByb3RvdHlwZSIsImFkZEF0dHIiLCJhdHRycyIsImF0dHIiLCJhZGRDU1NQcm9wIiwiY3NzIiwicHJvcGVydHkiLCJzcGxpdCIsIkNTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCIsImFkZERhdGFBdHRyIiwiZGF0YSIsImFkZE5leHQiLCJhZGQiLCJuZXh0U2libGluZyIsImFkZFBhcmVudCIsInBhcmVudE5vZGUiLCJhZGRQcmV2IiwicHJldmlvdXNTaWJsaW5nIiwiY3JlYXRlSGlkZVN0eWxlTm9kZSIsImhlYWQiLCJmaW5kIiwiSElERV9DTEFTUyIsImNyZWF0ZSIsInByb3AiLCJ0ZXh0IiwiZ2V0QXR0ck5TIiwiaXNYbWxOcyIsIm5vZGVOYW1lIiwiTnVsbCIsIlhNTF9OUyIsIlhfTElOS19BVFRSX0ZJTkRfUkVHRVgiLCJ0ZXN0IiwiRWxlbSIsImNsb3Nlc3QiLCJYX0xJTktfTlMiLCJYX0xJTktfQVRUUl9SRVBMQUNFX1JFR0VYIiwiaXNEb2N1bWVudCIsIkRPQ1VNRU5UX1JFR0VYIiwiaXNFbGVtIiwiaXNFbGVtZW50c0NvbGxlY3Rpb24iLCJIVE1MX0NPTExFQ1RJT05fUkVHRVgiLCJpc0FycmF5IiwiaXNWYWxpZE5vZGUiLCJFTEVNRU5UX1JFR0VYIiwiZ2V0RXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwicmVhbERldGFpbHMiLCJmaW5hbEV2ZW50IiwiRVZFTlRfUkVHRVgiLCJFdmVudCIsImVyciIsImRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiaGlkZSIsImFkZENsYXNzIiwiZ2V0TWF0Y2hlc0Z1bmN0aW9uIiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsInNlbGVjdG9yIiwidGhpcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZW1vdmUiLCJwYXJlbnQiLCJyZW1vdmVDaGlsZCIsInNob3ciLCJyZW1vdmVDbGFzcyIsInRvRWxlbSIsImJhc2UiLCJTdHJpbmciLCJjYWxjdWxhdGVBcmdzIiwibm9ybWFsaXplZEFyZ3MiLCJhcmdzIiwiYXJnc09iamVjdCIsImtleXMiLCJhcmciLCJ1bmRlZmluZWQiLCJjbGVhblByb3BlcnR5IiwiY29uc3RydWN0TWl4aW5SZWdleCIsIlJlZ0V4cCIsIm1peGluTWF0Y2giLCJtaXhpbnMiLCJNaXhpbiIsImxvY2FsTWF0Y2giLCJfbWF0Y2giLCJhcmdzTWF0Y2giLCJDT01NQV9SRUdFWCIsInRyYW5zZm9ybVJlc3RBdHRycyIsIm1peGluRGVmYXVsdE9wdHMiLCJldmVudHVhbEF0dHJzIiwiRF9SRVNUX1JFR0VYIiwidHJhbnNmb3JtUmVzdEFyZ3MiLCJhZGRBcmdzIiwiZXhlY3V0ZU1peGluV2F0Y2hlcnMiLCJtaXhpbiIsIm9sZFZhbHVlIiwiJCQiLCJ3YXRjaGVycyIsIndhdGNoZXIiLCJjYWxjdWxhdGVBdHRycyIsIm5vcm1hbGl6ZWRBdHRycyIsImF0dHJzT2JqZWN0IiwiZmlyc3RUaW1lIiwidHlwZSIsInJlbW92ZUF0dHIiLCJkeW5hbWljIiwib3B0cyIsIm5leHRUeXBlIiwibmV4dER5bmFtaWMiLCJuZXh0VmFsdWUiLCJwcmV2VHlwZSIsInByZXZWYWx1ZSIsInByZXZEeW5hbWljIiwiY3JlYXRlZCIsImlzRHluYW1pYyIsImV2YWx1YXRlZCIsImV2YWx1YXRlIiwibmV3VmFsdWUiLCJwYXJlbnRTY29wZSIsImNvbnN0cnVjdE1peGluV2F0Y2hlciIsInNldEFmdGVyVXBkYXRlIiwiYnVpbGRNaXhpbiIsImZpcnN0VmFsdWUiLCJwdXNoIiwibm9ybWFsaXplQXJncyIsImFyZ3NDaGFpbiIsIm5ld0FyZ3MiLCJjb25zdHJ1Y3RQcml2YXRlU2NvcGUiLCJzY29wZSIsImdsb2JhbHMiLCJyZW1vdmVUZW1wV2F0Y2hlciIsInJlbW92ZVdhdGNoZXJzIiwid2F0Y2hlcnNUb1JlbW92ZSIsInJlbW92ZVdhdGNoZXIiLCJjb25zdHJ1Y3RQdWJsaWNTY29wZSIsInNjb3BlVmFsdWVzIiwicHJpdmF0ZVNjb3BlIiwiZXZhbE1vZGUiLCJnZXR0aW5nVmFycyIsIm9sZFRlbXBXYXRjaGVycyIsImNyZWF0ZUJsb2NrIiwibm9kZSIsInBhcmVudEVsZW0iLCJwYXJlbnRCbG9jayIsInBhcmVudFRlbXBsYXRlIiwicHJldkJsb2NrIiwiZG9jIiwibmFtZXNwYWNlVVJJIiwiU1ZHX05TIiwibG9jYWxCbG9ja3MiLCJucyIsIl9ibG9ja3MiLCJCbG9jayIsImxvY2FsTWl4aW5zIiwiX21peGlucyIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvciIsImRCbG9ja01hdGNoIiwiZEJsb2NrTmFtZSIsImRCbG9ja0FyZ3MiLCJOQU1FRF9EX0JMT0NLX1JFR0VYIiwiYmxvY2tJbnN0YW5jZSIsImVycm9yIiwiZWxlbWVudCIsImN1cnJlbnRBdHRycyIsIndhc0RSZXN0IiwiYXR0cnNDaGFpbiIsImlzRFJlc3QiLCJsb2NhbEF0dHJzIiwicmVzdEF0dHJzIiwibWl4aW5zVG9CdWlsZCIsImlzUGFyZW50QmxvY2siLCJjaGlsZEJsb2NrcyIsIm9uIiwiaXRlcmF0ZUNoaWxkcmVuIiwiaXNSb290IiwiY2hpbGQiLCJjb250ZW50IiwiaW50byIsImNvbnRlbnREb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImluc2VydEFmdGVySXQiLCJpbnNlcnRBZnRlciIsImFkZENvbnRlbnQiLCJpbnNlcnRJblN0YXJ0T2ZJdCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlbXB0eUFycmF5IiwiQXJncyIsImxvY2FscyIsImh0bWwiLCJ0ZW1wbGF0ZSIsIml0ZW1OYW1lIiwiaXRlbSIsImluZGV4TmFtZSIsImFmdGVyQ29uc3RydWN0IiwiaXNSZW5kZXJlZCIsImV4ZWN1dGVCdWlsZGVycyIsImFmdGVyUmVuZGVyIiwiaXNJbnN0YW5jZU9mIiwiQ2xhc3MiLCJTdWJjbGFzcyIsImlzUHJvdG90eXBlT2YiLCJyZW1vdmVXaXRoUGFyZW50U2lnbmFsIiwid3JhcEJsb2NrIiwiYmxvY2siLCJ3cmFwcGVyIiwicmV0dXJuVmFsdWUiLCJ3cmFwTWl4aW4iLCJjb25zdHJ1Y3RTdHlsZUZyb21TdHJpbmciLCJzdHlsZSIsIkNTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgiLCJ0cmltIiwiZ2V0UHJvcCIsImhhc0F0dHIiLCJnZXRWYWx1ZUZvclNldHRpbmciLCJpbnB1dFZhbHVlIiwiaXNSYWRpbyIsImdldFZhbHVlRm9yR2V0dGluZyIsInZhbHVlcyIsIm9wdGlvbnMiLCJpbml0IiwiaXNNdWx0aXBsZSIsImFkZFZhbHVlIiwiY29uY2F0IiwiZ2V0TGlzdGVuZXJOYW1lIiwic2VsZWN0ZWQiLCJpbnNlcnRUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZXMiLCJpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4iLCJub2RlcyIsInRyaW1tZWQiLCJuZXdUZW1wbGF0ZXMiLCJuZXdUZW1wbGF0ZSIsIm5ld1ZhcnMiLCJpbml0QXBwIiwiY29udGFpbmVyIiwicm9vdEJsb2NrIiwicmVtb3ZlQXBwIiwiRHdheW5lUm9vdEJsb2NrIiwiQXJyYXkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiT2JqZWN0IiwicmVnZXhwU3BlY2lhbENoYXJhY3RlcnMiLCJtYXAiLCJzIiwiam9pbiIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJzZXRQcm90byIsInNldFByb3RvdHlwZU9mIiwicHJvdG8iLCJfX3Byb3RvX18iLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwicm9vdEJsb2NrcyIsInJvb3RNaXhpbnMiLCJDU1NfSU1QT1JUQU5UX1JFR0VYIiwiZW1wdHlDb2xsZWN0aW9uIiwiX3RoaXMiLCJpbmNsdWRlcyIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJlbGVtcyIsImVsZW1lbnRzIiwiY2xhc3NlcyIsImZvckVhY2giLCJsaXN0IiwiY2xhc3NMaXN0IiwiY2xzIiwiYXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZU5TIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZE5vZGVzIiwiY29sbGVjdCIsImlzIiwiY2IiLCJjb250YWlucyIsImVsIiwiaXNUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlRWxlbWVudCIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRQcm9wZXJ0eVByaW9yaXR5IiwicmVtb3ZlQ1NTIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImNzc1RleHQiLCJkYXRhc2V0IiwiZGV0YWlscyIsImRpc3BhdGNoRXZlbnQiLCJmaWx0ZXIiLCJoYXNBdHRyaWJ1dGVOUyIsImhhc0F0dHJpYnV0ZSIsImlubmVySFRNTCIsIm5leHQiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImVuZCIsImZpcnN0Q2hpbGQiLCJsaXN0ZW5lciIsIm5ld0V2ZW50cyIsImFsbExpc3RlbmVycyIsImxpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsInByb3BzIiwiZmlyc3QiLCJwcmV2IiwiYmFiZWxIZWxwZXJzLmdldCIsImFwcGx5IiwidGV4dENvbnRlbnQiLCJjb25kaXRpb24iLCJfYXJndW1lbnRzIiwiX2FyZ3VtZW50czIiLCJzcGVjaWVzIiwiY29tbWVudCIsImFmdGVyVXBkYXRlIiwiX3ZhbHVlIiwiY3VycmVudFZhbHVlIiwiaXNQYXJlbnRTaWduYWwiLCJpc1JlbW92ZWQiLCJiZWZvcmVSZW1vdmUiLCJ3cmFwcGVycyIsInJlZHVjZSIsImlzRWxlbWVudFJlbW92ZWQiLCJibG9ja0hvb2tzIiwibWl4aW5Ib29rcyIsIlRBR19OQU1FX1JFR0VYIiwiQVRUUl9OQU1FX1JFR0VYIiwiYWZ0ZXJFbGVtIiwiZW1wdHlPYmplY3QiLCJvcmlnaW5hbEFyZ3MiLCJjaGlsZHJlbkJsb2NrcyIsImZ1bmMiLCJvbkNoYW5nZSIsInRhcmdldEJsb2NrIiwiZm9yREVsZW1lbnRzIiwiZm9yREl0ZW0iLCJfdGhpczciLCJvbkNoYW5nZUZsYWciLCJyZXN1bHQiLCJvcmlnaW5hbCIsIm9uRXZhbEVycm9yIiwiZSIsImxvY2FsV2F0Y2hlcnMiLCJ3YXRjaGVyQmxvY2siLCJuZXdSZXN1bHQiLCJyZW1vdmVDb250ZW50IiwibmV3Q29udGVudCIsImFmdGVyRE9NQ2hhbmdlIiwiY29udGVudFRvQWRkIiwibm90UmVjdXJzaXZlIiwib2xkQ29udGVudCIsImNoYW5nZUNvbnRlbnQiLCJjb250ZW50VG9Nb3ZlIiwiYWZ0ZXIiLCJpbmRleFRvUHV0IiwibW92ZUNvbnRlbnQiLCJjb250ZW50VG9SZW1vdmUiLCJjb250ZW50VG9JbnNlcnQiLCJtb3ZlRmxhZyIsInRyeVRvQWRkT3JNb3ZlIiwiZGVmYXVsdExvY2FscyIsImRlZmF1bHRBcmdzIiwibG9jYWxBcmdzIiwicmVzdEFyZ3MiLCJpc0RFbGVtZW50cyIsImhvb2siLCJ3YXJuIiwiY3VycmVudFJldHVyblZhbHVlIiwid2F0Y2hOYW1lQXJncyIsIndhdGNoQ29uc3RydWN0b3JBcmdzIiwiREJsb2NrIiwiY29uc3RydWN0RHluYW1pY05hbWVCbG9jayIsImh0bWxDaGlsZHJlbiIsImNvbnN0cnVjdER5bmFtaWNDb25zdHJ1Y3RvckJsb2NrIiwicGFyZW50UGFyZW50U2NvcGUiLCJwYXJlbnRQYXJlbnRUZW1wbGF0ZSIsIm93bkNoaWxkcmVuIiwiREJsb2NrTmFtZSIsImZvdW5kIiwiUGFyZW50U2NvcGUiLCJQYXJlbnRUZW1wbGF0ZSIsImRCbG9ja3MiLCJESXRlbSIsIndhdGNoQXJncyIsIml0ZW1zQnlVSURzIiwicmVuZGVyU2V0Iiwic2V0IiwiZmlsdGVyQnkiLCJzb3J0QnkiLCJfdGhpczIiLCJVSUQiLCJ1aWQiLCJuZXdJdGVtc0J5VUlEcyIsIm5ld1VJRHNCeUluZGV4ZXMiLCJuZXdVSURzIiwiaXNBcnIiLCJpdGVyYXRlIiwic29ydCIsInByZXZVSURCbG9jayIsImNvbnN0cnVjdEVsZW1zIiwiSW5maW5pdHkiLCJ3YXNEZWZhdWx0IiwidmFsIiwiaWYiLCJjb21wYXJlRm4iLCJzb21lIiwic3dpdGNoVmFsdWUiLCJjYXNlVmFsdWUiLCJvZmYiLCJuZXdDbGFzc2VzIiwiREhpZGUiLCJCb29sZWFuIiwiaW5pdGlhbFNjb3BlVmFsdWUiLCJzZXRQcm9wIiwiaW5pdGlhbEVsZW1WYWx1ZSIsImlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIiwiaXNDaGVja2JveCIsImNoYW5nZVNjb3BlIiwib2ZmRWxlbUxpc3RlbmVyIiwib2ZmRm9ybUxpc3RlbmVyIiwib3B0aW9uIiwiYm9keSJdLCJtYXBwaW5ncyI6InlCQUFPLFNBQVNBLEdBQWlCQyxFQUFPQyxNQUFVQyxzRUFDbkNGLEVBQU8sU0FBQ0csRUFBT0MsS0FDakJGLEVBQWNDLEVBQU9DLEVBQU9KLEtBR2hDRSxFQUdULFFBQWdCRyxHQUFZTCxFQUFPQyxPQUM1QixHQUFJSyxHQUFJLEVBQUdDLEVBQVNQLEVBQU1PLE9BQVFELEVBQUlDLEVBQVFELElBQUssSUFDaERILEdBQVFILEVBQU1NLE1BRWhCTCxFQUFTRSxFQUFPRyxFQUFHTixjQUVkTSxZQU9iLFFBQWdCRSxHQUFhUixFQUFPQyxPQUM3QixHQUFJSyxHQUFJLEVBQUdDLEVBQVNQLEVBQU1PLE9BQVFELEVBQUlDLEVBQVFELE1BQ3hDTixFQUFNTSxHQUFJQSxFQUFHTixHQUkxQixRQUFnQlMsR0FBZ0JULEVBQU9VLE1BQy9CTixHQUFRSixFQUFNVyxRQUFRRCxJQUViLElBQVhOLEtBQ0lRLE9BQU9SLEVBQU8sR0FJeEIsUUFBZ0JTLEdBQWFiLFNBQ3BCRCxHQUFpQkMsRUFBT2MsR0FHakMsUUFBU0EsR0FBT0MsRUFBTUMsS0FDZkEsSUFBWSxVQ3RDSEMsR0FBV2QsU0FDRCxrQkFBVkEsR0FHaEIsUUFBZ0JlLEdBQU1mLFNBRUosT0FBVEEsRUFJVCxRQUFnQmdCLEdBQVNoQixTQUNDLGdCQUFWQSxHQ05oQixRQUFnQmlCLEdBQU9DLFlBQ1JDLFVBQVcsU0FBQ0MsRUFBUW5CLEdBQzNCQSxLQUNZbUIsRUFBUSxTQUFDcEIsRUFBT3FCLEtBQ3JCQSxHQUFPckIsTUFLYmtCLEVBR1QsUUFBZ0JJLEdBQWtCQyxFQUFRekIsTUFBVUMsc0VBQ3BDd0IsRUFBUSxTQUFDdkIsRUFBT3FCLEtBQ25CdEIsRUFBY0MsRUFBT3FCLEVBQUtFLEtBRzlCeEIsRUFHVCxRQUFnQnlCLEdBQU9ELE1BQ2ZFLE1BQ0FDLEVBQW1CQyxrQkFBTSxZQUVqQkosRUFBUSxTQUFDdkIsRUFBT3FCLElBQ0EsSUFBeEJLLEVBQU1sQixRQUFRYSxPQUNOQSxHQUFPckIsS0FJZHlCLEVBR1QsUUFBZ0JHLEdBQWVMLEVBQVFGLFNBQ3RCUSxXQUFJUixHQUdyQixRQUFnQlMsR0FBY1AsRUFBUXpCLE9BQy9CLEdBQU11QixLQUFPRSxHQUNaSyxFQUFlTCxFQUFRRixNQUNoQkUsRUFBT0YsR0FBTUEsRUFBS0UsR0FLakMsUUFBZ0JRLEdBQVVSLEVBQVF6QixNQUMxQjJCLGVBRVFGLEVBQVEsU0FBQ3ZCLEVBQU9xQixLQUNsQkEsR0FBT3ZCLEVBQVNFLEVBQU9xQixFQUFLRSxLQUdqQ0UsVUN2RE9PLEdBQTBCZCxFQUFRZSxLQUNsQ0EsRUFBWSxTQUFDakMsRUFBT2tDLFVBQ3pCQyxlQUFlakIsRUFBUWdCLHFCQUVsQixjQUNFLGdCQUNFLE1BS3BCLFFBQWdCRSxHQUF1QmxCLEVBQVFlLEtBQy9CQSxFQUFZLFNBQUNqQyxFQUFPa0MsVUFDekJDLGVBQWVqQixFQUFRZ0IscUJBRWxCLGNBQ0UsZ0JBQ0UsTUNFcEIsUUFBZ0JHLEdBQVlDLFNBQ25CQSxHQUFPQyxRQUFRQyxHQUFzQixRQ3hCdkMsUUFBU0MsTUNHaEIsUUFBZ0JDLEdBQVkxQyxTQUNuQkEsR0FBTXVDLFFBQVFJLEdBQXFCQyxHQUc1QyxRQUFnQkMsR0FBYTdDLFNBQ3BCQSxHQUFNdUMsUUFBUU8sR0FBeUJDLEdBR2hELFFBQVNILEdBQVdJLFNBQ1hBLEdBQU0sR0FBR0MsY0FHbEIsUUFBU0YsR0FBVUMsYUFDTEEsRUFBTSxHQUFHRSxjQ0x2QixRQUFnQkMsR0FBWTVCLFNBQ1g2QixZQUFXekIsTUFBTSxHQUFJLEdBR3RDLFFBQWdCMEIsR0FBZUMsRUFBT0MsR0FDaENDLEdBQU9MLGVBQ2lCRyxFQUFNRyxnQkFDN0JELEdBQU9MLFlBQWNJLElDbEJyQixRQUFTRyxHQUFRQyxFQUFPQyxLQUN2QkEsRUFBSzFCLE1BQVEwQixFQUFLNUQsTUNHMUIsUUFBZ0I2RCxHQUFXQyxFQUFLOUQsTUFDMUJBLEVBQU8sSUFDSCtELEdBQVcvRCxFQUFNZ0UsTUFBTUMsTUFFekJ2QixFQUFZcUIsRUFBUyxLQUFPQSxFQUFTLElDUnRDLFFBQVNHLEdBQVlDLEVBQU1uRSxFQUFPcUIsS0FDbENBLEdBQU9yQixFQ0RQLFFBQVNvRSxHQUFRQyxFQUFLOUQsS0FDdkJBLEVBQUsrRCxhQ0RKLFFBQVNDLEdBQVVGLEVBQUs5RCxLQUN6QkEsRUFBS2lFLFlDREosUUFBU0MsR0FBUUosRUFBSzlELEtBQ3ZCQSxFQUFLbUUsaUJDQ0osUUFBU0MsR0FBb0JDLEdBQ3BCQSxFQUFLQyxjQUFlQyxJQUV4QjFFLFVBS1AyRSxPQUFPLFNBQ1BDLEtBQUssS0FBTUYsSUFDWEcsU0FBVUgsaUNDRmYsUUFBZ0JJLEdBQVV0QixFQUFNckQsTUFDeEI0RSxHQUFtQixVQUFUdkIsUUFFWnVCLElBQW9CLGdCQUFUdkIsRUFDUyxRQUFsQnJELEVBQUs2RSxTQUNBQyxPQUlIQyxRQUNFSCxFQUNGLFFBQ0EsU0FJSkksR0FBdUJDLEtBQUs1QixJQUN6QixHQUFJNkIsSUFBS2xGLEdBQU1tRixRQUFRLE9BQU90RixXQUs3QnVGLFFBQ0UvQixFQUFLckIsUUFBUXFELEdBQTJCLEtBSTNDUCxHQzlCVCxRQUFnQlEsR0FBVzdGLFNBQ2xCOEYsSUFBZU4sS0FBS3JDLEVBQVluRCxJQUd6QyxRQUFnQitGLEdBQU8vRixTQUNkQSxhQUFpQnlGLElBRzFCLFFBQWdCTyxHQUFxQmhHLFNBRWpDaUcsSUFBc0JULEtBQUtyQyxFQUFZbkQsS0FDcEMrRixFQUFPL0YsSUFDUGtHLEdBQVFsRyxHQUlmLFFBQWdCbUcsR0FBWW5HLE1BQ3BCdUQsR0FBTUosRUFBWW5ELFNBR3RCb0csSUFBY1osS0FBS2pDLElBQ2hCdUMsR0FBZU4sS0FBS2pDLElBQ1osU0FBUkEsR0FDUSxxQkFBUkEsR0FDUSxZQUFSQSxFQzFCUCxRQUFnQjhDLEdBQVNDLEVBQU9DLEVBQVNDLEVBQVlDLEVBQWFsRyxNQUM1RG1HLEdBQWFKLE1BRVpLLEdBQVluQixLQUFLckMsRUFBWXVELFVBRWpCLEdBQUlFLE9BQU1GLEdBQWNILFVBQVNDLGlCQUN2Q0UsRUFBWUQsR0FDbkIsTUFBT0ksTUFDREMsR0FBV2pCLEVBQVd0RixHQUN4QkEsRUFDQUEsRUFBS3dHLGdCQUVJRCxFQUFTRSxZQUFZLFdBQ3ZCQyxVQUFVWCxFQUFPQyxFQUFTQyxLQUU5QkUsRUFBWUQsU0FJaEJDLEdDcEJGLFFBQVNRLEdBQUszRyxLQUNDLEdBQUlrRixJQUFLbEYsRUFBS3dHLGNBQWNuQyxVQUM1Q2EsSUFBS2xGLEdBQU00RyxTQUFTckMsSUNGMUIsUUFBZ0JzQyxHQUFtQjdHLFNBRS9CQSxHQUFLOEcsU0FDRjlHLEVBQUsrRyxpQkFDTC9HLEVBQUtnSCx1QkFDTGhILEVBQUtpSCxvQkFDTGpILEVBQUtrSCxtQkFDTGxILEVBQUttSCxrQkFDTEwsRUFJUCxRQUFTQSxHQUFRTSxnQkFLZ0QsUUFKOUM5QixFQUFXK0IsTUFDeEJBLEtBQ0FBLEtBQUtiLGVBRU9jLGlCQUFpQkYsR0FBV25ILFdBQVFvSCxNQ3JCL0MsUUFBU0UsR0FBT3ZILE1BQ2Z3SCxHQUFTeEgsRUFBS2lFLFVBRWhCdUQsTUFDS0MsWUFBWXpILEdDRGhCLFFBQVMwSCxHQUFLMUgsTUFDZmtGLElBQUtsRixHQUFNMkgsWUFBWXBELElDRHRCLFFBQVNxRCxHQUFPNUgsU0FDZHdGLEdBQU94RixHQUNWQSxFQUNBLEdBQUlrRixJQUFLbEYsR0NNZixRQUFnQnNFLEdBQUs4QyxNQUFVUywwREFBT3RCLFNBQzdCLElBQUlyQixJQUFLMkMsRUFBS1AsaUJBQWlCUSxPQUFPVixLQ1h4QyxRQUFTVyxHQUFjQyxFQUFnQkMsRUFBTUMsS0FDckNDLEdBQUtELEdBQWEsU0FBQ0UsR0FDeEJBLElBQU9ILE9BQ0FHLE9BQU9DLFFBSVJMLEVBQWdCLFNBQUN2SSxFQUFPMkksS0FDekJBLEdBQU8zSSxJQ1ZmLFFBQVM2SSxHQUFjN0ksRUFBTzJJLEVBQUtwSCxTQUNqQ0EsR0FBT29ILEdDQ1QsUUFBU0csR0FBb0I1RyxTQUMzQixJQUFJNkcsWUFBWTFHLEVBQVlILDZDQ0RyQyxRQUFnQjhHLEdBQVdDLEVBQVFyRixNQUM3QlosY0FHQyxHQUFNZCxLQUFRK0csR0FBUSxJQUNuQkMsR0FBUUQsRUFBTy9HLEdBQ2ZpSCxFQUFhdkYsRUFBS1osTUFBTWtHLEVBQU1FLFdBRWhDRCxFQUFZLElBQ1JFLEdBQVlGLEVBQVcsR0FDekJYLFFBRWMsTUFBZGEsT0FFT0EsTUFDRkEsRUFBVXJGLE1BQU1zRix1QkFLZEgsRUFBVyxnQ0FVbkJuRyxHQzVCRixRQUFTdUcsR0FBbUI1RixFQUFPc0YsRUFBUU8sU0FDekNsSSxHQUFrQnFDLEVBQU8sU0FBQzhGLEVBQWV6SixFQUFPNEQsTUFDakQ4RixHQUFhbEUsS0FBSzVCLFNBQ2IzQyxHQUFPd0ksRUFBZUYsRUFBbUJ2SixFQUFPaUosRUFBUU8sT0FHM0R4RyxHQUFRZ0csRUFBV0MsRUFBUXJGLE1BRTdCWixnQkFDWVksU0FDTixpQkFDRyxvQkFHSlosRUFDQXdHLGVBUUs1RixTQUNOLGtCQU1aLFFBQWdCK0YsR0FBa0JuQixTQUN6QmxILEdBQWtCa0gsRUFBTW9CLEdBR2pDLFFBQVNBLEdBQVFwQixFQUFNeEksRUFBTzJJLEdBQ3hCZSxHQUFhbEUsS0FBS21ELEtBQ2JILEVBQU1tQixFQUFrQjNKLE1BRTFCMkksR0FBTzNJLEVDeENULFFBQVM2SixHQUFxQkMsRUFBTzlKLE1BQ3BDK0osR0FBV0QsRUFBTUUsR0FBR2hLLFFBRXBCZ0ssR0FBR2hLLE1BQVFBLElBRUo4SixFQUFNRSxHQUFHQyxTQUFVLFNBQUNDLEtBQ3ZCbEssRUFBTytKLEtDTFosUUFBU0ksSUFBZUMsRUFBaUJ6RyxFQUFPMEcsRUFBYTlKLEVBQU0rSixLQUMxREQsRUFBYSxXQUFrQnpHLE1BQWYyRyxLQUFBQSxLQUFNdkssSUFBQUEsS0FDNUI0RCxLQUFRRCxLQUNDLFNBQVQ0RyxJQUNHQyxXQUFXNUcsS0FFVm9HLEdBQUdsQyxlQUdKdUMsR0FBWXpHLFNBSWpCcUYsV0FFUW1CLEVBQWlCLFdBQWlDeEcsTUFBOUIyRyxLQUFBQSxLQUFNRSxJQUFBQSxRQUFTekssSUFBQUEsTUFBTzBLLElBQUFBLEtBQ2xEQyxTQUNBQyxTQUNBQyxZQUVBUixFQUFZekcsR0FBTyxPQUtqQnlHLEVBQVl6RyxHQUhSa0gsSUFBTlAsS0FDT1EsSUFBUC9LLE1BQ1NnTCxJQUFUUCxXQUdXLFNBQVRGLEVBQ2UsVUFBYk8sS0FDUWQsR0FBR2xDLFNBR1hpRCxJQUFjL0ssS0FDWDRELEtBQUtBLEVBQU01RCxLQUdOQSxNQUNQLElBQ0Q4SixHQUFRaUIsRUFDUkUsWUFFYSxTQUFiSCxLQUNHTixXQUFXNUcsTUFFTixJQUNMNkcsUUFBVUEsSUFDUCxHQUFJQyxHQUFLeEIsTUFBTXdCLE1BRWpCVixHQUFHa0IsVUFBWVQsRUFHbkJBLElBQ21CWCxFQUFPOUosT0FDdkIsS0FBSzhKLEVBQU1FLEdBQUdtQixXQUFhVCxFQUFLeEIsTUFBTWtDLFNBQVUsSUFDL0NDLEdBQVd2QixFQUFNRSxHQUFHc0IsWUFBWXRCLEdBQUdvQixTQUN2Q3BMLEVBQ0F1TCxHQUFzQnpCLEVBQU9sRyxFQUFNRCxHQUNuQ21HLEtBR0lFLEdBQUdtQixXQUFZLElBRUFyQixFQUFPdUIsT0FDbkJMLElBQWVOLEVBQUt4QixNQUFNa0MsWUFDZHRCLEVBQU9BLEVBQU1FLEdBQUdzQixZQUFZdEIsR0FBR29CLFNBQVNwTCxNQUduRDhKLEVBRVJtQixLQUNJakIsR0FBR3dCLG1CQUlGakIsSUFDR0UsTUFDVCxJQUNRLFNBQVRGLElBQ0czRyxLQUFLQSxFQUFNNUQsS0FFSkEsTUFDUCxJQUNDeUwsR0FBYSxhQUNaaEIsUUFBVUEsS0FFVFgsR0FBUSxHQUFJWSxHQUFLeEIsTUFBTXdCLE9BRXhCRCxHQUFXQyxFQUFLeEIsTUFBTWtDLFNBQVUsSUFFakNFLEdBRUVaLEVBRkZZLFlBQ0F0TCxFQUNFMEssRUFERjFLLE1BRUkwTCxFQUFhSixFQUFZdEIsR0FBR29CLFNBQ2hDcEwsRUFDQXVMLEdBQXNCekIsRUFBT2xHLEVBQU1ELEdBQ25DbUcsS0FHSUUsR0FBR21CLFdBQVksSUFDZm5CLEdBQUdoSyxNQUFRMEwsV0FHUDVCLElBQ05FLEdBQUd3QixzREFPRTFCLElBS1RRLEtBQ0txQixLQUFLRixTQU1MbEIsSUFDR0UsSUFHSjdHLFNBQ0orRyxVQUNHQyxRQUNGQyxLQUlQUCxRQUNLLGNBQ1FyQixFQUFRLFNBQUN3QyxTQUloQkEsSUFGRjdILElBQUFBLEtBQ0E4RyxJQUFBQSxPQUdVOUcsR0FBUThHLEtBTTVCLFFBQVNhLElBQXNCekIsRUFBT2xHLEVBQU1ELFNBQ25DLFVBQVUwSCxTQUlYMUgsRUFBTUMsR0FGUjJHLElBQUFBLEtBQ0FFLElBQUFBLE9BR1csV0FBVEYsR0FBcUJFLEtBQ0ZYLEVBQU91QixJQzVKM0IsUUFBU08sSUFBY0MsTUFDdEJDLGVBRU9ELEVBQVcsU0FBQ3JELEtBQ1RBLEVBQU0sU0FBQ3hJLEVBQU8ySSxLQUNsQkEsR0FBTzNJLE1BSVo4TCxFQ1RGLFFBQVNDLElBQXNCeEssRUFBUWdKLEVBQU1lLE1BQzlDVSxZQUVTLFlBQVR6QixNQUNNeEYsR0FDTnVHLEVBQ0lBLEVBQVl0QixHQUFHaUMsUUFDZixPQUlEM0ssRUFBa0JDLEVBQVEsU0FBQ3lLLEVBQU9oTSxFQUFPcUIsS0FDeENBLDBCQUlMMkssR0NoQkUsUUFBU0UsSUFBa0JoQyxPQUlsQyxRQUFnQmlDLElBQWVDLEtBQ2hCQSxFQUFrQkMsSUFHakMsUUFBU0EsVUFBZ0JuQyxLQUFBQSxZQUFTRCxTQUNOQyxHQ1ByQixRQUFTb0MsSUFBcUJOLEVBQU9PLEVBQWFDLE1BQ3RDUixFQUFPakssRUFBVXdLLEVBQWEsU0FBQ3ZNLEVBQU9xQixNQUMvQzJLLEdBQVFRLEVBQWFuTCx3QkFHWCxjQUNGLHVCQUVOb0wsTUFDMkMsSUFBekNDLEdBQVlsTSxRQUFRd0wsRUFBTS9CLGNBQ2hCMEIsS0FBS0ssRUFBTS9CLFVBSXBCK0IsRUFBTWhNLG9CQUVYQSxNQUNFQSxJQUFVZ00sRUFBTWhNLFVBSWQyTSxHQUFrQlgsRUFBTS9CLFNBQVN0SSxVQUVqQ3NJLGNBQ0FqSyxNQUFRQSxJQUVEMk0sRUFBaUJULFVDUnRDLFFBQWdCVSxVQUFjQyxLQUFBQSxLQUFNOUUsSUFBQUEsT0FBUStFLElBQUFBLFdBQVlDLElBQUFBLFlBQWF6QixJQUFBQSxZQUFhMEIsSUFBQUEsZUFBZ0JDLElBQUFBLFVBQzFGQyxFQUFNckgsRUFBV2lILEVBQVcsSUFDOUJBLEVBQ0EsR0FBSXJILElBQUtxSCxFQUFXLEdBQUcvRixlQUNyQnhHLEVBQU91TSxFQUFXLEdBQUdLLGVBQWlCQyxHQUN4Q0YsRUFBSW5JLE9BQU8sT0FDWG1JLEVBQ0VHLEVBQWNMLEVBQWlCQSxFQUFlaEQsR0FBR3NELEdBQUdDLFFBQVVDLEdBQU1ELFFBQ3BFRSxFQUFjVCxFQUFpQkEsRUFBZWhELEdBQUdzRCxHQUFHSSxRQUFVRixHQUFNRSxRQUNwRWxGLEVBQU9xRSxFQUFLbEosVUFDWnpCLEVBQU8ySyxFQUFLM0ssTUFBUSxlQUNwQnlMLEVBQWFkLEVBQWJjLFNBQ0ZDLEVBQWNmLEVBQUtnQixhQUFnQmhCLEVBQUszSyxNQUFRbUwsRUFBWVIsRUFBSzNLLE1BQ2pFNEwsU0FDQUMsU0FDQUMsUUFFUyxhQUFUOUwsR0FBc0JzRyxFQUFLdEcsT0FDaEJWLEVBQU9nSCxFQUFNLFFBQ1IsWUFBVHRHLEdBQXNCc0csRUFBS3FGLGNBQ3ZCck0sRUFBT2dILEVBQU0saUJBQ2hCc0YsRUFBYzVMLEVBQUtjLE1BQU1pTCxNQUFrQyxZQUFUL0wsT0FDOUNzTCxHQUFNRCxRQUFRLGFBQ2ZPLEVBQWNBLEVBQVksR0FBSyxTQUcxQ0ksYUFFQU4sUUFFZ0IsR0FBSUEsd0lBYXBCLE1BQU8vRyxXQUNDc0gsK0JBQWdDak0sTUFBVTJFLEtBQ3BDLFNBSWIrRyxFQUFhLElBQ1I1TixHQUFVNk0sRUFBVjdNLE1BRUZvTyxFQUFVN04sRUFBS3dFLE9BQU83QyxHQUN0Qm1NLEVBQWV0SixHQUFPLE1BQ3hCcEIsRUFBUW9CLEdBQU8sTUFDZnVKLFNBQ0VDLEdBQWM1SyxHQUNkNkYsUUFDRTRFLHFEQU1NNUYsRUFBTSxTQUFDeEksRUFBTzRELE1BQ3BCNEssR0FBVTlFLEdBQWFsRSxLQUFLNUIsR0FDNUI2SyxFQUFhRCxHQUFXRixFQUMxQnZKLEdBQU9wQixHQUNQQSxLQUVBQSxJQUFVOEssS0FDRDlDLEtBQUs4QyxLQUdWQSxFQUVKRCxFQUFTLElBQ0xFLEdBQVlwRCxFQUFZdEIsR0FBR29CLFNBQVNwTCxFQUFPLFNBQUNBLEtBQ2xDeU8sRUFBWTVGLEtBQ25CNEYsRUFBWWxGLEVBQ2pCdkosRUFDQXlOLEVBQ0FqRSxPQUVhb0MsR0FBYzJDLEdBQWE1SyxFQUFPMEssRUFBY0QsR0FBUyxJQUN2RXJCLGFBRVEsRUFFSjlMLEVBQU93TixFQUFZbEYsRUFDeEJtRixFQUFXakIsRUFBYWpFLE9BSXRCeEcsR0FBUWdHLEVBQVd5RSxFQUFhN0osU0FFM0IsRUFFUFosZ0JBQ1NZLFNBQ0gsaUJBQ0csb0JBR0paLEVBQ0F3RyxlQVFFNUYsU0FDSCxhQUNDMEgsRUFBWXRCLEdBQUdvQixTQUFTcEwsRUFBTyxTQUFDQSxLQUMxQjRELFNBQ0gsbUJBR09nSSxHQUFjMkMsR0FBYTVLLEVBQU8wSyxFQUFjRCxHQUFTLElBQ3ZFckIsUUFJSy9DLEdBQUcyRSxjQUFjaEQsS0FBS3hCLEdBQWV5QixHQUFjMkMsR0FBYTVLLEVBQU8wSyxFQUFjRCxHQUFTLElBRTdGLGFBQVRsTSxLQUNNK0MsS0FBS2pGLEdBR0YsVUFBVGtDLEVBQWtCLElBQ2hCK0MsR0FBT3FHLEVBQVl0QixHQUFHb0IsU0FBU3BMLEVBQU8sU0FBQ0EsR0FDckNlLEVBQU1mLE9BQ0EsTUFHRmlGLFFBQVNqRixJQUNoQitNLEVBRUNoTSxHQUFNa0UsT0FDRCxNQUdEQSxRQUFTQSxNQUdiMkosR0FBZ0I3RyxZQUFrQnlGLElBQ2xDcUIsUUFHTyxXQUFUM00sR0FBdUIsT0FBU3lCLE1BQzFCbUwsR0FBRyxPQUFRLG1CQU9SQyxHQUFnQnBCLEVBQVVxQixLQUNwQnJCLEVBQVUsU0FBQ3NCLEdBQ2xCQSxZQUFpQnpCLEtBQ2Z3QixNQUNJaEYsR0FBRzhDLFdBQWFJLElBQ2hCbEQsR0FBR2pDLE9BQVNtRixJQUNabEQsR0FBR2tGLFFBQVFDLEtBQUtqQyxNQUdSK0IsRUFBTWpGLEdBQUcyRCxVQUFVLE1BRTdCd0IsS0FBS2pDLFFBakJYcEcsR0FBV3NILEVBQVEsR0FBR2dCLGdCQUN0QmxDLEVBQU0sR0FBSXpILElBQUtxQixNQUVqQnJCLElBQUtxQixFQUFTdUksaUJBQWlCdkgsV0FDbkIrRyxHQUFhLEtBb0I3QjVCLFlBQXFCTyxNQUNieEQsR0FBR3NGLGNBQWNsQixHQUFTLEdBQzNCbkIsS0FDRHNDLFlBQVl0QyxHQUVoQjJCLEtBQ0s1RSxHQUFHd0YsV0FBV3BCLElBRWRRLElBQ0Y1RSxHQUFHeUYsa0JBQWtCckIsR0FBUyxLQUU3QmUsS0FBS3JDLEdBQVksR0FHdkJhLEVBQVUsSUFDUlYsVUFDQUgsRUFBYXNCLEtBR0osYUFBVGxNLElBQ1csR0FBSXVELElBQUsySSxFQUFRLEdBQUdjLFFBQVVkLEVBQVEsR0FBR2MsU0FBV2hDLEVBQUksR0FBR3dDLDhCQUNuRSxJQUFhLFdBQVR4TixLQUNMLE9BQVN5QixLQUNBZ00sT0FDTixJQUNDN0ksR0FBV3NILEVBQVEsR0FBR2dCLG1CQUV4QjNKLElBQUtxQixFQUFTdUksaUJBQWlCdkgsV0FFdEIsR0FBSXJDLElBQUtxQixLQUliNkcsRUFBVSxTQUFDc0IsS0FDVnJDLFNBQ0pxQyxTQUNFbkMsNEVBT0VuQixLQUFLc0IsV0FJZG1CLFNBUUxGLEVBSkZsRSxJQUFBQSxHQUNNNEYsSUFBTnBILEtBQ0F5RCxJQUFBQSxRQUNHNEQsZ0NBR0NDLEVBQWdCLGVBQVQ1TixFQUNUME4sRUFBSzVQLFVBQ0w0TixFQUFZbUMsU0FBUy9QLE9BQVM0TixFQUFZbUMsY0FFM0N2SCxLQUFPdUQsR0FBc0I2RCxLQUM3QkMsT0FBUzlELEdBQXNCOEQsS0FDL0I1RCxRQUFVRixHQUFzQkUsRUFBUyxVQUFXWCxHQUUxQyxZQUFUcEosRUFBb0IsT0FDaEJxSyxhQUNITSxFQUFLbUQsU0FBV25ELEVBQUtvRCxXQUNyQnBELEVBQUtxRCxVQUFZckQsRUFBSzVNLFVBRW5CK0wsRUFBZ0MsWUFBeEJWLEVBQVl0QixHQUFHOUgsS0FDekJvSixFQUFZdEIsR0FBR2dDLE1BQ2ZWLElBRURnQyxHQUFLaEMsRUFBWXRCLEdBQUdzRCxLQUNwQmQsYUFBZVQsR0FBc0JRLE1BQ25CdkMsRUFBR2dDLE1BQVFqSCxHQUFPaUgsR0FBUU8sRUFBYXZDLEVBQUd3QyxpQkFHNUNvRCxFQUFNQSxFQUFNNUYsRUFBR3hCLFNBQ2Z5RCxFQUFTQSxFQUFTakMsRUFBR2lDLFlBQ3JCaUMsRUFBZTJCLEVBQVE3RixFQUFHNkYsY0FHL0JNLGlCQUNkLE1BQU90SixXQUNDc0gsMkJBQTRCak0scUJBQXlCMkUsU0FHbkQrQixLQUNXLGVBQVQxRyxFQUNWME4sRUFBS3RFLFlBQ0w0QyxJQUNzQixlQUFUaE0sRUFDYjBOLEVBQUs1QyxlQUNMa0IsSUFFUzRCLEVBQU0sU0FBQ2IsS0FDTnJDLFNBQ0pxQyxTQUNFZiwyQkFFS0EsbURBT0hsRSxHQUFHb0csWUFBYSxJQUVqQmxDLEVBQWNsRSxHQUFHMkUsY0FBZSxTQUFDMEIsV0FHaENyRyxHQUFHMkUsdUJBR0QyQixjQUNkLE1BQU96SixXQUNDc0gsMkJBQTRCak0sa0JBQXNCMkUsU0FHckRxSCxHQy9UVCxRQUFnQnFDLElBQWFDLEVBQU9DLGVBQ3BCQyxXQUFjRCxTQUFtQmhOLFVBQVdpTixXQUFjRCxFQUFTaE4sV0NINUUsUUFBU2tOLElBQXVCMUIsS0FDL0JqRixHQUFHbEMsUUFBTyxHQUdsQixRQUFnQkEsSUFBT21ILEtBQ2ZqRixHQUFHbEMsU0NESixRQUFTOEksSUFBVUMsRUFBT0MsTUFDekJDLEdBQWNELEVBQVFELFNBRXJCTixJQUFhL0MsR0FBT3VELEdBQ3ZCQSxFQUNBRixFQUdOLFFBQWdCRyxJQUFVbEgsRUFBT2dILE1BQ3pCQyxHQUFjRCxFQUFRaEgsU0FFckJ5RyxJQUFhckgsR0FBTzZILEdBQ3ZCQSxFQUNBakgsRUN5Q04sUUFBU2pHLElBQVdDLEVBQUttTSxZQUNEQSxLQUFmakwsT0FBTWhGLFNBRVRnRixHQUFRaEYsRUFHZCxRQUFTaVIsSUFBeUJDLE1BQzFCbE4sR0FBUWtOLEVBQU1sTixNQUFNbU4sV0FHeEJuTixFQUFNLEdBQUdvTixPQUNUcE4sRUFBTSxHQUFHb04sUUMrRGIsUUFBU0MsSUFBUW5QLEVBQU1xSSxFQUFNaEssVUFDbkIyQixPQUNELGVBQ0kzQixHQUFLK1EsUUFBUSxZQUNoQixrQkFDQSxZQUdELGNBQ1UsU0FBVC9HLEVBQ0ssUUFHTyxVQUFUQSxHQUE2QixhQUFUQSxFQUN2QixVQUNBLHNCQUlHaEssR0FBSytRLFFBQVEsbUJBQ2hCLE9BQ0EsU0FLVixRQUFTQyxJQUFtQnJQLEVBQU1sQyxFQUFPdUssRUFBTWlILE1BQ2hDLFVBQVR0UCxRQUNLbEMsTUFHSHlSLEdBQW1CLFVBQVRsSCxRQUVYa0gsSUFBb0IsYUFBVGxILEVBSVRrSCxFQUNIelIsSUFBVXdSLEdBQ3FCLElBQS9CeFIsRUFBTVEsUUFBUWdSLEdBTFR4UixFQVFYLFFBQVMwUixJQUFtQnhQLEVBQU1sQyxFQUFPdUssRUFBTWlILEVBQVlHLEVBQVFDLEVBQVNDLEVBQU1DLFVBQ3hFNVAsT0FDRCxlQUNFNFAsR0FJRWxTLEVBQWlCZ1MsRUFBU0csT0FIeEIvUixNQU1OLFdBQ1UsVUFBVHVLLEdBQTZCLGFBQVRBLFFBQ2Z2SyxNQUdJLFVBQVR1SyxRQUNLdkssR0FDSHdSLEVBQ0EsVUFHR0csT0FFSjNSLEdBQVM2UixRQUNMRixNQUdMM1IsU0FDcUMsSUFBaEMyUixFQUFPblIsUUFBUWdSLEdBQ2xCRyxFQUFPSyxPQUFPUixHQUNkRyxLQUdBMVIsR0FBUTBSLEVBQU9uUixRQUFRZ1IsVUFFZCxJQUFYdlIsZUFFRzBSLEVBQU9oUSxNQUFNLEVBQUcxQixPQUNoQjBSLEVBQU9oUSxNQUFNMUIsRUFBUSxLQUlyQjBSLGdCQUlBM1IsSUFLYixRQUFTaVMsSUFBZ0IvUCxFQUFNcUksVUFDckJySSxPQUNELGVBQ0ksYUFHSixjQUVRLFVBQVRxSSxHQUNZLGFBQVRBLEdBQ1MsVUFBVEEsR0FDUyxTQUFUQSxFQUVELFNBQ0EsNkJBSUcsU0FLYixRQUFTd0gsSUFBU0osUUFBVU8sS0FBQUEsU0FBVWxTLElBQUFBLEtBQ2hDa1MsS0FBdUMsSUFBM0JQLEVBQU9uUixRQUFRUixNQUN0QjJMLEtBQUszTCxHQ3JQVCxRQUFTbVMsSUFBZ0JwQyxFQUFVcUMsV0FXL0JDLFNBQ0YsR0FEMkJDLDZEQUN2Qm5TLEVBQUksRUFBR0EsRUFBSW1TLEVBQU1sUyxPQUFRRCxJQUFLLE9BS2pDbVMsRUFBTW5TLEdBSFIrQixJQUFBQSxLQUNBbEMsSUFBQUEsTUFDQTJOLElBQUFBLFlBR1csYUFBVHpMLEVBQXFCLElBQ2pCcVEsR0FBVXZTLEVBQU1vUixVQUVsQm9CLEVBQWFELEdBQVUsSUFDbkJFLEdBQWNELEVBQWFELEdBQVN2UyxRQUVwQ1MsZ0JBQU9OLEVBQUcsYUFBTXNTLE9BQ2ZDLEVBQVNoUyxFQUFhOFIsRUFBYUQsR0FBUzNSLFVBRTlDNlIsRUFBWXJTLE9BQVMsVUFHSHVOLE9BN0I3Qi9NLEdBRUVtUCxFQUZGblAsS0FDQVosRUFDRStQLEVBREYvUCxNQUVJd1MsRUFBZXpOLEdBQU8sTUFDdEIyTixFQUFVaFMsRUFBYUUsWUFFdEI0UixFQUFjSixLQUNJcFMsS0EyQnBCSSxPQUFTLElBQ1R1TCxnQkFBUWpELEdBQUtnSyxLQUVYM0MsRUN0QlQsUUFBZ0I0QyxJQUFROUIsRUFBTytCLE1BQ3ZCOUYsR0FBYSxHQUFJckgsSUFBS21OLEdBQVdyUyxLQUFLLEdBQ3hDc04sRUFBY2dELE1BRWIvRCxFQUFXMU0sMkJBQ04rTixNQUFNLG1FQUtackIsRUFBVzlILEtBQUssdUNBQ1ZtSixNQUFNLDRFQUtabk4sRUFBUzZQLEdBQVEsaUpBQ21CckQsTUFDN0J1QywrQkFHR2MsWUFNVjNLLEdBQVEySyxHQUFRLGlKQUNvQnJELE1BQzdCdUMsd0JBRUVjLFVBS1RBLElBQVVOLEdBQWEvQyxHQUFPcUQsSUFBVTNLLEdBQVEySyxFQUFNalEsT0FBU3NGLEdBQVEySyxFQUFNN1EsT0FBUSxpSkFDakR3TixNQUM3QnVDLFNBQVdjLFVBSWpCTixHQUFhL0MsR0FBT0ssdUJBQ2ZNLE1BQU0sc0VBS1YwRSxHQUFZakcsZUFFUixtQ0FHQUUsMEJBS1A5SCxLQUFLLGtCQUFtQjZOLEdBQ3hCalAsS0FBSyxjQUFlLElBRWhCaVAsRUNwRVQsUUFBZ0JDLElBQVVGLE1BQ2xCclMsR0FBTyxHQUFJa0YsSUFBS21OLEdBQVdyUyxLQUFLLE9BRWpDQSxFQUFLSCwyQkFDQStOLE1BQU0sb0VBS0o1TixFQUFLLFNBRVdxUyxFQUFwQkcsSUFBQUEscUJBRUZBLFlBQTJCdkYseUJBQ3ZCVyxNQUFNLDZEQUtBbkUsR0FBR2xDLFdBQ2QwQyxXQUFXLHFCQUVUb0ksR0FBVUcsbUIxQ3JDSjdNLElBQVk4TSxNQUFaOU0sY0NHR3JFLE1BQWhCRCxlQUVNRCxNQUFBQSxNQ0hPc1IsR0FBcUJDLE9BQXJCRCxpQkNGVEUsSUFDSixJQUNBLElBQUssSUFBSyxJQUNWLElBQUssSUFDTCxJQUFLLElBQ0wsSUFBSyxJQUNMLElBQUssSUFDTCxJQUFLLElBQ0wsSUFDQSxJQUNBLElBQ0EsSUFDQSxJQUNBLElBQ0EsTUFFSTNRLEdBQXVCLEdBQUl1RyxRQUMvQm9LLEdBQ0dDLElBQUksU0FBQ0MsY0FBWUEsSUFDakJDLEtBQUssS0FDUixLd0NuQkF2TyxHQUdFbU8sT0FIRm5PLE9BQ0EyRCxHQUVFd0ssT0FGRnhLLEtBQ2dCNkssR0FDZEwsT0FERk0sZUFHV0MsR0FBV1AsT0FBT1EsZ0JBQW1CLFNBQUN4UyxFQUFReVMsS0FFbERDLFVBQVlELE1DTlksbUJBQVhFLFFBQXlCQSxPQUEyQixtQkFBWEMsUUFBeUJBLE9BQXlCLG1CQUFUQyxNQUF1QkEsUUNBbEhqUCxHQUFhLG9CQUNic0ksR0FBUyw2QkFDVDFELEdBQWUsaUJBRWZzSyxHQUFhalAsR0FBTyxNQUNwQmtQLEdBQWFsUCxHQUFPLFNBSTdCK08sU0FGRmhOLFNBQUFBLDJCQUNBdEQsT0FBQUEsaWdFeENWSWIsR0FBc0IsVUFDdEJHLEdBQTBCLGVDRXhCTSxNQUFBQSxTRURGYSxHQUFpQyxLTUFqQ3NCLEdBQXlCLFlBQ3pCSyxHQUE0QixVQUM1Qk4sR0FBUyxnQ0FDVEssR0FBWSwrQkFDWk4sT0FDQSxNQ0pBWSxHQUF3Qiw4QkFDeEJILEdBQWlCLFlBQ2pCTSxHQUFnQixXQ0ZoQk8sR0FBYyxTRURabkcsTUFBQUEsUTRCb0VGMFQsR0FBc0IsZ0JBQ3RCQyxNQWVBMU8sK0JBbUJRbEYsMERBQU80VCxzRkFHWm5PLEdBQXFCekYsUUFDaEJBLFNBR0trRixFQUFLaEMsYUFFUGxELEVBQU0sU0FBQ0EsR0FDYnlGLEVBQXFCekYsUUFDaEJBLE1BR0dBLEVBQU0sU0FBQ0EsSUFDYjZULEVBQUtDLFNBQVM5VCxJQUFTNEYsRUFBWTVGLE1BQ2pDb0wsS0FBS3BMLG9FQTFCQStULEVBQVlDLFNBQ3hCcFQsV0FBVWYsUUFBVSxZQUNOa1UsRUFBYUMsTUFHTDNNLEtBQUtuRSxVQUFXNlEsR0FFbkMxTSxrREFzQ0Q0TSxHQUFRNU0sS0FBS2pHLDJCQURkOFMsa0RBR1FBLEVBQVUsU0FBQ2xVLEdBQ2pCeUYsRUFBcUJ6RixRQUNoQkEsTUFHR0EsRUFBTSxTQUFDQSxJQUNiaVUsRUFBTUgsU0FBUzlULElBQVM0RixFQUFZNUYsTUFDakNvTCxLQUFLcEwsT0FLVmlVLGdFQWFHRSwrQ0FDSDlNLE1BQUsrTSxRQUFRLFNBQUNwVSxNQUNicVUsR0FBT3JVLEVBQUtzVSxZQUVMSCxFQUFTLFNBQUNJLFNBQVFGLEdBQUt2USxJQUFJeVEsb0NBeUJ2Q2xSLEVBQU01RCxNQUNITyxHQUFPcUgsS0FBSyxPQUViekcsVUFBVWYsYUFDUkcsR0FJRVgsRUFBaUJXLEVBQUt3VSxXQUFZclIsU0FHdkN2QyxVQUFVZixRQUFVLEdBQUtZLEVBQVM0QyxHQUFPLEtBQ3RDckQsUUFDSSxZQU1MMkUsRUFBVXRCLEVBQU1yRCxHQUZsQitNLElBQUFBLEdBQ0FwTCxJQUFBQSxXQUdLb0wsR0FDSC9NLEVBQUt5VSxlQUFlMUgsRUFBSXBMLEdBQ3hCM0IsRUFBSzBVLGFBQWFyUixTQUdwQnpDLFdBQVVmLFFBQVUsWUFDWndELEVBQU81RCxJQUdaNEgsS0FBSytNLFFBQVEsU0FBQ3BVLEtBQ0xxRCxFQUFNLFNBQUM1RCxFQUFPcUIsTUFDdEJOLEVBQU1mLEtBQW9CLElBQVZBLFFBQ1gsSUFBSXlGLEdBQUtsRixHQUFNaUssV0FBV25KLE1BR2pCLElBQVZyQixFQUFpQixHQUFLQSxRQUVma0YsRUFBVTdELEVBQUtkLEdBQXRCK00sSUFBQUEsRUFFSkEsS0FDRzRILGVBQWU1SCxFQUFJak0sRUFBS3JCLEtBRXhCbVYsYUFBYTlULEVBQUtyQixnREFnQnRCLElBQUl5RixHQUFLbUMsS0FBS3hILE9BQVN3SCxLQUFLLEdBQUd3TiwrQ0FXaEN6TixTQUNDQyxNQUFLeU4sUUFBUSxTQUFDaFIsRUFBSzlELFFBQ2pCQSxHQUFNLElBQ1AsR0FBSWtGLEdBQUtsRixHQUFNK1UsR0FBRzNOLFNBQ2J0RCxHQUFJOUQsS0FHTkEsRUFBS2lFLDhDQWlCVjFFLGNBQ0EyVSxLQUNBYyxFQUFPZCxFQUFTOUksVUFBVDhJLGVBRVJFLFFBQVEsU0FBQ3BVLEVBQU1OLEtBQ1RzVixFQUFJaFYsRUFBTU4sT0FHZCxHQUFJd0YsR0FBS2dQLG9DQWNUckcsTUFDRHJHLEdBQVNILEtBQUssR0FDZHFILEVBQVE5RyxFQUFPaUcsR0FBUyxZQUV0QnJHLElBQVdrSCxJQUVmbEgsRUFBT3lOLFNBQVN2RyxrQ0FlZjFFLFNBQ0UzQyxNQUFLeU4sUUFBUSxTQUFDaFIsRUFBSzlELE1BQ3BCa1YsR0FBSyxLQUNIQyxFQUFrQixVQUFUbkwsRUFDVHpELEVBQVdqQixFQUFXdEYsR0FDeEJBLEVBQ0FBLEVBQUt3RyxnQkFFTDJPLEdBQW1CLGFBQVRuTCxFQUNQbUwsRUFDRDVPLEVBQVM2TyxlQUFlLElBQ3hCN08sRUFBUzhPLGNBQWMsSUFFYixRQUFUckwsRUFDRHpELEVBQVMrTyxnQkFBZ0J6SSxHQUFRN0MsR0FDakN6RCxFQUFTZ1AsY0FBY3ZMLEdBR3hCMUUsRUFBV3RGLE9BQ1ZrRixHQUFLZ1EsR0FBSXRHLEtBQUs1TyxLQUdoQmtWLGlDQXVCSjFSLEVBQVUvRCxTQUNNNEgsS0FBSyxPQUFmc0osSUFBQUEsWUFFSC9QLFdBQVVmLE9BUVhlLFVBQVVmLFFBQVUsR0FBS1ksRUFBUytDLEdBQy9CbU4sS0FJTXJPLEVBQWFrQixHQUVqQm1OLEVBQU02RSxpQkFBaUJoUyxJQUFhbU4sRUFBTThFLG9CQUFvQmpTLEdBQVksY0FBZ0IsS0FMeEYsSUFRUDVDLFVBQVVmLFFBQVUsWUFDUjJELEVBQVcvRCxJQUdwQjRILEtBQUsrTSxRQUFRLFNBQUNwVSxLQUNMd0QsRUFBVSxTQUFDL0QsRUFBTytELFFBQ25CbEIsRUFBYWtCLEdBRXBCaEQsRUFBTWYsS0FBb0IsSUFBVkEsUUFDWCxJQUFJeUYsR0FBS2xGLEdBQU0wVixVQUFVbFMsS0FHN0JtTixNQUFNZ0YsZUFBZW5TLEtBQ3JCbU4sTUFBTWlGLFlBQ1RwUyxFQUNBL0QsRUFBTXVDLFFBQVEyUixHQUFxQixJQUNuQ0EsR0FBb0IxTyxLQUFLeEYsR0FBUyxZQUFjLFNBakMvQ2tSLEVBSUV0UixFQUFpQnNSLEVBQU1rRixRQUFRcFMsTUE3VFQsT0E2VDRDSCxtQ0F1RHhFeEMsRUFBS3JCLFNBQ1k0SCxLQUFLLE9BQWpCeU8sSUFBQUEsWUFFSGxWLFVBQVVmLGFBQ1JpVyxHQUlFL1UsRUFBa0IrVSxFQUFTblMsU0FHWCxJQUFyQi9DLFVBQVVmLFFBQWdCWSxFQUFTSyxHQUFNLEtBQ3RDZ1YsZUFJRUEsR0FBUWhWLFNBR2JGLFdBQVVmLFFBQVUsWUFDYmlCLEVBQU1yQixJQUdWNEgsS0FBSytNLFFBQVEsU0FBQ3BVLEtBQ0xjLEVBQUssU0FBQ3JCLEVBQU9xQixLQUNwQmdWLFFBQVFoVixHQUFPckIsdUNBb0JqQnNHLE1BQU9nUSwrREFLVkEsRUFIRi9QLFFBQUFBLGtCQUdFK1AsRUFGRjlQLFdBQUFBLGdCQUNHQyxLQUNENlAsa0NBRUcxTyxNQUFLK00sUUFBUSxTQUFDcFUsS0FDZGdXLGNBQWNsUSxFQUNqQkMsRUFDQUMsRUFDQUMsRUFDQUMsRUFDQWxHLHdDQWVETiwwREFBUSxRQUNQQSxHQUFRLE1BQ0YySCxLQUFLeEgsT0FBU0gsR0FHakIsR0FBSXdGLEdBQUttQyxLQUFLM0gsbUNBYWhCdVcsaUJBQ0R4VixFQUFTd1YsR0FBUyxJQUNkN08sR0FBVzZPLElBRVIsU0FBQ2pXLFNBQ1IsSUFBSWtGLEdBQUtsRixHQUFNK1UsR0FBRzNOLFVBSWZDLE1BQUt5TixRQUFRLFNBQUNoUixFQUFLOUQsRUFBTU4sR0FDMUJ1VyxFQUFPalcsRUFBTU4sUUFDWE0sa0NBYUxvSCxTQUNJQyxNQUFLeU4sUUFBUSxTQUFDaFIsRUFBSzlELEtBQ3BCc0UsRUFBSzhDLEVBQVVwSCxzQ0FnQmZULHVCQUNPOEgsS0FBTSxTQUFDNUgsRUFBT3FCLEtBQ2hCckIsRUFBT3FCLE9BR1h1RyxxQ0FjRGhFLE1BQ0FyRCxHQUFPcUgsS0FBSyxPQUVickgsU0FDSSxRQUdNMkUsRUFBVXRCLEVBQU1yRCxHQUF2QitNLElBQUFBLFNBRURBLEdBQ0gvTSxFQUFLa1csZUFBZW5KLEVBQUkxSixHQUN4QnJELEVBQUttVyxhQUFhOVMsb0NBY2ZrUixNQUNEdlUsR0FBT3FILEtBQUssV0FFWHJILEdBQ0hBLEVBQUtzVSxVQUFVVyxTQUFTVix3Q0FjckJsTixNQUFLK00sUUFBUXpOLGdDQWVqQjRJLE9BQ0UzTyxVQUFVZixPQUFRLElBQ2ZHLEdBQU9xSCxLQUFLLFNBRVhySCxHQUNIQSxFQUFLb1csVUFDTCxTQUdDL08sTUFBSytNLFFBQVEsU0FBQ3BVLEtBQ2RvVyxVQUFZN0cscUNBV1p2UCxVQUN3QixJQUF4QnFILEtBQUtwSCxRQUFRRCx1Q0FnQlY2TixLQUNBakcsRUFBT2lHLEdBQVM3TixLQUFLLE1BRTNCd0gsR0FBU3FHLEVBQVFyRyxlQUVoQkEsR0FBTzNILFVBSUZnTyxFQUFRd0ksT0FBTyxLQUNoQjdPLEVBQU8sR0FFVEgsS0FBSytNLFFBQVEsU0FBQ3BVLE1BQ2ZBLElBQVM2TixnQkFDREEsRUFBUTlKLFlBS2hCOEosS0FDS3lJLGFBQWF0VyxFQUFNNk4sS0FFbkIwSSxZQUFZdlcsTUFoQmRxSCwwQ0FrQ0V3RyxLQUNEakcsRUFBT2lHLEdBQVM3TixLQUFLLE1BRTNCd0gsR0FBU3FHLEVBQVFyRyxlQUVoQkEsR0FBTzNILFVBSUZnTyxFQUFRLEtBQ1RyRyxFQUFPLEdBRVRILEtBQUsrTSxRQUFRLFNBQUNwVSxLQUNac1csYUFBYXRXLEVBQU02TixNQVBuQnhHLGtDQXlCTndHLE1BQVMySSxxRUFDRjVPLEVBQU9pRyxHQUFTLFVBR2pCeEcsVUFHSm1QLEdBQU8zSSxFQUFRNEksV0FBWSxLQUN6QixHQUFJN1csR0FBSXlILEtBQUt4SCxPQUFTLEVBQUdELEdBQUssRUFBR0EsTUFDNUIwVyxhQUFhalAsS0FBS3pILEdBQUlpTyxFQUFRNEksa0JBR2pDcFAsWUFHRkEsTUFBSytNLFFBQVEsU0FBQ3BVLEtBQ1h1VyxZQUFZdlcsZ0NBbUJyQm9ILE9BQ0lDLEtBQUt4SCxjQUNELEtBR0hHLEdBQU9xSCxLQUFLLFNBQ0ZSLEdBQW1CN0csVUFFZG9ILHFDQWFmcEgsR0FBT3FILEtBQUssU0FFWHJILEdBQ0hBLEVBQUs2RSxTQUFTbEMsa0JBQ2QwRix3Q0FhR2hCLE1BQUt5TixRQUFRalIsOEJBcUNuQmtDLEVBQU8yUSxHQUNKalcsRUFBU3NGLGFBQ0FBLEVBQVEyUSxPQUdmQyxNQUNBQyxjQUVRN1EsRUFBTyxTQUFDMlEsRUFBVTNRLEtBQ2pCQSxFQUFNdEMsTUEzeUJLLFdBMnlCeUIsU0FBQ3NDLElBQy9DNFEsRUFBVTVRLEdBQVM0USxFQUFVNVEsUUFBY3FGLEtBQUtzTCxZQUloRHRDLFFBQVEsU0FBQ3BVLEtBQ0UyVyxFQUFXLFNBQUNFLEVBQVc5USxLQUN0QjhRLEVBQVcsU0FBQ0gsS0FDbEJJLGlCQUFpQi9RLEVBQU8yUSxHQUFVLElBQ3RDRSxFQUFhN1EsR0FBUzZRLEVBQWE3USxRQUFjcUYsS0FBSyxhQUNoRDJMLG9CQUFvQmhSLEVBQU8yUSxXQU1qQyxTQUE4QjNRLEdBQy9CbkYsVUFBVWYsU0FDQ2UsVUFBVyxTQUFDbUYsS0FDVkEsRUFBTXRDLE1BOXpCQyxXQTh6QjZCLFNBQUNzQyxNQUMxQ2lSLEdBQWtCSixFQUFhN1EsRUFFakNpUixPQUNXQSxFQUFpQixTQUFDQyxTQUFtQkEsYUFFM0NMLEdBQWE3USxVQUtaNlEsRUFBYyxTQUFDSSxFQUFpQmpSLEtBQy9CaVIsRUFBaUIsU0FBQ0MsU0FBbUJBLGFBRTNDTCxHQUFhN1EsNkNBYW5Cc0IsTUFBS3lOLFFBQVE5USx3Q0FhYnFELE1BQUt5TixRQUFRNVEsZ0NBaUJqQlYsRUFBVS9ELFNBQ1RtQixXQUFVZixRQUFVLEdBQUtZLEVBQVMrQyxHQUM3QjZELEtBQUssR0FBS0EsS0FBSyxHQUFHN0QsT0FBWTZFLElBR25DekgsVUFBVWYsUUFBVSxZQUNSMkQsRUFBVy9ELElBR3BCNEgsS0FBSytNLFFBQVEsU0FBQ3BVLEtBQ0x3RCxFQUFVLFNBQUMvRCxFQUFPZ0YsS0FDekJBLEdBQVFoRiw4Q0FnQlY0SCxNQUFLK00sUUFBUTdNLG1FQWFSaU4sK0NBQ0xuTixNQUFLK00sUUFBUSxTQUFDcFUsS0FDTndVLEVBQVksU0FBQ25SLFNBQ1RzQixFQUFVdEIsRUFBTXJELEdBQXZCK00sSUFBQUEsRUFFSkEsS0FDR21LLGtCQUFrQm5LLEVBQUkxSixLQUV0QjhULGdCQUFnQjlULHdFQWdCZDhRLCtDQUNOOU0sTUFBSytNLFFBQVEsU0FBQ3BVLE1BQ2JxVSxHQUFPclUsRUFBS3NVLFlBRUxILEVBQVMsU0FBQ0ksU0FBUUYsR0FBSzlNLE9BQU9nTixzRUFjbEM2QywrQ0FDSi9QLE1BQUsrTSxRQUFRLFNBQUNwVSxLQUNOb1gsRUFBTyxTQUFDN1QsS0FDZG9OLE1BQU1nRixlQUFlclQsRUFBYWlCLHdDQW1CckNzSyxLQUNJakcsRUFBT2lHLE1BRVh3SixHQUFRaFEsS0FBS3JILEtBQUssR0FDbEJ3SCxFQUFTNlAsRUFBTTdQLGFBRWhCQSxFQUFPM0gsYUFDSHdILFNBR0xySCxHQUFPd0gsRUFDUHdNLEVBQVMsT0FDUHFDLEVBQU9nQixFQUFNaEIsT0FBTyxHQUNwQmlCLEVBQU9ELEVBQU1DLE9BQU8sRUFFdEJqQixNQUNLQSxJQUNFLGdCQUNBaUIsTUFDRkEsSUFDRSxpQkFHTC9QLFdBRUV5TSxHQUFRaFUsd0NBY1RxSCxNQUFLK00sUUFBUTFNLHlDQVdiLElBQUl4QyxHQUFLcVMsMkVBQVlDLE1BQU1uUSxLQUFNekcseUNBZXJDOEQsU0FDRTlELFdBQVVmLE9BSVJ3SCxLQUFLK00sUUFBUSxTQUFDcFUsS0FDZHlYLFlBQWMvUyxJQUpaMkMsS0FBSzVDLEtBQUssa0RBc0JWcEIsRUFBTXFVLHlCQUNSclEsTUFBSytNLFFBQVEsU0FBQ3BVLEtBQ1osR0FBSWtGLEdBQUtsRixJQUVaMlgsRUFBVTlYLE9BQVMsR0FBS0csRUFBSytRLFFBQVExTixHQUFRcVUsS0FDMUNyVSxLQUFLQSxFQUFNLE1BRVg0RyxXQUFXNUcseUNBbUJWa1IsRUFBS21ELHlCQUNSclEsTUFBSytNLFFBQVEsU0FBQ3BVLFNBQ0dBLEVBQWRzVSxJQUFBQSxZQUVELEdBQUlwUCxHQUFLbEYsSUFFWjRYLEVBQVUvWCxPQUFTLEdBQUt5VSxFQUFVVyxTQUFTVixHQUFPbUQsS0FDL0M5USxTQUFTMk4sS0FFVDVNLFlBQVk0TSxZQXprQ045QixNQStrQ25CM1AsR0FBZW9DLEdBQU0sUUNscUNkLFNBQTBCbkMsRUFBTzhVLEdBQ2xDNVUsR0FBTzRVLFlBQ1E5VSxRQUNkRSxHQUFPNFUsOEJBRUdBLFFEOHBDQTNTLEdBQU11TixNcEJ0cUN2QixJQUFNMUosSUFBYyxJUW1CZDJFLEdBQXNCLHNCQUN0QjBCLFlDcEJFZSxNQUFBQSxjYWNGeEgseUJBcUJRd0IsNEJBRVJ4SSxHQVNFd0ksRUFURnhJLEtBQ0FsQyxFQVFFMEssRUFSRjFLLE1BQ0F5SyxFQU9FQyxFQVBGRCxRQUNBbEssRUFNRW1LLEVBTkZuSyxLQUNBaUksRUFLRWtDLEVBTEZsQyxLQUNBNlAsRUFJRTNOLEVBSkYyTixRQUNBdEwsRUFHRXJDLEVBSEZxQyxZQUNBekIsRUFFRVosRUFGRlksWUFDQTBCLEVBQ0V0QyxFQURGc0MsZUFFSVosS0FDQW5DLE9BQ2tCc0osR0FBUzNMLE1BQXpCZ0csSUFBQUEsWUFDRjBLLEVBQWMsU0FBQ2pOLEVBQVV0QixLQUN4QkMsR0FBR2hLLE1BQVFxTCxRQUdUaU4sWUFBWWpOLEVBQVV0QixHQUMzQixNQUFPbEQsV0FDQ3NILDJCQUE0QmpNLGtCQUFzQjJFLE9BSXZDZSx3QkFpQlg1SCxvQkFFR3lLLHdGQU1BLFdBQ0QsU0FBQ1AsU0FLTGtLLEVBQUtwSyxHQUhQa0IsSUFBQUEsVUFDQWxMLElBQUFBLE1BQ0F1WSxJQUFBQSxPQUVJQyxFQUFldE4sRUFDakJsTCxFQUNBc0wsRUFBWXRCLEdBQUdvQixTQUFTbU4sU0FFeEJyTyxNQUNPeUIsS0FBS3pCLEdBR1RzTyxVQUVELFNBQUNDLE9BQ1lBLElBQ2R6TyxHQUFHME8sV0FBWSxLQUVMdE0sU0FHUnVNLGFBQWFGLEdBQ2xCLE1BQU81UixXQUNDc0gsMkJBQTRCak0sbUJBQXVCMkUsR0FHeEQ0UixLQUNhMUwsRUFBWS9DLEdBQUdmLDBCQUduQixXQUNWMkUsRUFBWXhDLFlBQ0ZnSixFQUFLcEssR0FBR29CLFNBQVNrTixhQVdoQzlQLEtBQU9BLE9BT1A2UCxRQUFVQSxPQU9WL00sWUFBY0EsT0FPZDBCLGVBQWlCQSxPQU9qQnpNLEtBQU9BLE9BT1BzTSxLQUFPdE0sRUFBSyxLQUVMeUosR0FBR2YsT0FBTzBDLEtBQUsvRCxnRkF6SWRnUiwrQ0FDTkEsR0FBU0MsT0FBTzdILEdBQVdwSiwwRkFtSnZCa1IscUNBU0poWixTQUNBOEgsTUFBS29DLEdBQUdvQixTQUFTdEwsNENBdkxSLHlCQVFkb0osSUFPR2tDLFVBQVcsRUFnTHBCL0gsRUFBZTZGLEdBQU8sUUM5R3RCLElBQU02UCxPQUNBQyxNQUNBQyxHQUFpQiw0Q0FDakJDLEdBQWtCLDhCQUVsQkMsR0FBWSxHQUFJMVQsSUFDaEIyVCxNQUNGM00sSUFBVyxFQUNYQyxNQXdDRWMseUJBNlJROUMsNEJBRVJ4SSxHQVdFd0ksRUFYRnhJLEtBQ01tWCxFQVVKM08sRUFWRmxDLEtBQ0F1RixFQVNFckQsRUFURnFELFdBQ0FDLEVBUUV0RCxFQVJGc0QsV0FDQUwsRUFPRWpELEVBUEZpRCxTQUNBNUYsRUFNRTJDLEVBTkYzQyxPQUNBK0UsRUFLRXBDLEVBTEZvQyxXQUNBQyxFQUlFckMsRUFKRnFDLFlBQ0F6QixFQUdFWixFQUhGWSxZQUNBMEIsRUFFRXRDLEVBRkZzQyxlQUNBQyxFQUNFdkMsRUFERnVDLFVBRUliLE9BQ2tCbUgsR0FBUzNMLE1BQXpCZ0csSUFBQUEsWUFDRjBMLEtBQ0FyUSxLQUNBMkYsRUFBZ0I3RyxZQUFrQnlGLEtBRWpCNUYsaUlBd0NWLEdBQUluQyxPQUNUbUksZUFDVUQsZUFDSjJMLHNFQUtDLGNBQ0MsV0FDRixTQUFDQyxFQUFNQyxFQUFVQyxFQUFhQyxFQUFjQyxPQUMvQzdZLEVBQVd5WSxTQUNQQSxPQUdRRyxNQUNKQyxLQUVQM04sR0FBaUIsWUFBVDlKLEdBQXVCeVgsSUFDakNDLEVBQUs1UCxHQUFHZ0MsUUFFaUJ5TixFQUFjQSxFQUFZelAsR0FBS29QLEdBQXBEaE4sSUFBQUEsaUJBQ0Z5TixJQUFpQkwsUUFFTixTQUFYcE8sUUFDQTBPLFNBRUFELFNBQ1MsZUFLRk4sRUFBS3ZOLEdBQ2QsTUFBT25GLFFBQ0gwUyxLQUFPQSxJQUNQUSxTQUFXUixFQUFLUSxXQUNoQmxKLFFBRUEvUCxFQUFXOE0sRUFBWW9NLG1CQUVYQSxZQUFZblQsR0FDeEIsTUFBT29ULFdBQ0M5TCwyQkFBNEJqTSxrQkFBc0IrWCxPQUs1REosRUFBYyxJQUNWSyxRQUVPeE4sR0FBYSxTQUFDekMsTUFDbkJDLEdBQVUsYUFDRGdRLEVBQWUsU0FBQ0MsTUFFekJqUSxHQUVFaVEsRUFGRmpRLFFBQ0FELEVBQ0VrUSxFQURGbFEsV0FHY21DLEVBQWtCK04sS0FDbEJsUSxFQUFVQyxRQUd0QmtRLEdBQVloUCxHQUVkZ1AsS0FBY04sR0FBV0wsRUFBWXpQLEdBQUcwTyxXQUFja0IsRUFBSzVQLEdBQUcwTyxhQUN2RDBCLEVBQVdOLElBR2xCSywwQ0FNUXhPLEtBQUt3TyxLQUNGeE8sS0FBS3dPLEtBQ2J4TyxLQUFLekIsU0FHTCxjQUlONFAsY0FLSCxTQUFDckIsS0FDRnpPLEdBQUcwTyxXQUFZLEtBRUx0TSxLQUVGa04sRUFBZ0IzSSxNQUNoQjFILEVBQVEwSCxVQUdkZ0ksZUFDTCxNQUFPOVIsV0FDQ3NILDJCQUE0QmpNLG1CQUF1QjJFLElBR3hENFIsR0FBa0I3SixLQUNkNUUsR0FBR3FRLGNBQWNULEVBQUs1UCxHQUFHa0YsVUFHN0J1SixHQUFrQjFMLEtBQ0xBLEVBQVkvQyxHQUFHMkQsY0FHNUIzRCxHQUFHa0YsUUFBUXBILHdCQUVILFNBQUN3UyxRQUNUdFEsR0FBR2tGLFFBQVVvTCxFQUVkVixFQUFLNVAsR0FBR29HLGFBQWV3SixFQUFLNVAsR0FBRzBPLGdCQUUxQjZCLGlCQUNMLE1BQU8xVCxXQUNDc0gsMkJBQTRCak0scUJBQXlCMkUsZ0JBSXZELFNBQUMyVCxFQUFjQyxNQUNuQkMsR0FBYWQsRUFBSzVQLEdBQUdrRixRQUNyQmpQLEVBQVF5YSxFQUFXbGEsUUFBUWdhLEVBQWEsR0FBRzlWLGlCQUFtQixFQUNoRTRWLFdBRVUsSUFBVnJhLEVBQ1d1YSxFQUFhblcsSUFBSXFXLEdBRWpCQSxFQUNWL1ksTUFBTSxFQUFHMUIsR0FDVG9FLElBQUltVyxFQUFjRSxFQUFXL1ksTUFBTTFCLE1BR25DK0osR0FBRzJRLGNBQWNMLEdBRWxCMUwsSUFBa0I2TCxLQUNielEsR0FBR3dGLFdBQVdnTCxFQUFjQyxnQkFHMUIsU0FBQ0csRUFBZUMsTUFDckJILEdBQWFkLEVBQUs1UCxHQUFHa0YsUUFDckJqUCxFQUFReWEsRUFBV2xhLFFBQVFvYSxFQUFjLElBQ3pDRSxFQUFhSixFQUFXbGEsUUFBUXFhLEVBQU0sSUFBTSxFQUM5Q1AsV0FFZSxJQUFmUSxFQUNXRixFQUFjdlcsSUFDekJxVyxFQUFXL1ksTUFBTW1aLEVBQVk3YSxHQUM3QnlhLEVBQVcvWSxNQUFNMUIsRUFBUTJhLEVBQWN4YSxTQUVoQ0gsRUFBUTZhLEVBQ0pKLEVBQ1YvWSxNQUFNLEVBQUdtWixHQUNUelcsSUFDQ3VXLEVBQ0FGLEVBQVcvWSxNQUFNbVosRUFBWTdhLEdBQzdCeWEsRUFBVy9ZLE1BQU0xQixFQUFRMmEsRUFBY3hhLFNBRzlCc2EsRUFDVi9ZLE1BQU0sRUFBRzFCLEdBQ1RvRSxJQUNDcVcsRUFBVy9ZLE1BQU0xQixFQUFRMmEsRUFBY3hhLE9BQVEwYSxHQUMvQ0YsRUFDQUYsRUFBVy9ZLE1BQU1tWixNQUlsQjlRLEdBQUcyUSxjQUFjTCxHQUVsQjFMLEdBQWlCa00sS0FDWjlRLEdBQUcrUSxZQUFZSCxFQUFlQyxrQkFHMUIsU0FBQ0csS0FDVGhSLEdBQUcyUSxjQUFjZixFQUFLNVAsR0FBR2tGLFFBQVFzSCxPQUFPLFNBQUNqVyxVQUNULElBQW5DeWEsRUFBZ0J4YSxRQUFRRCxNQUd0QnFPLEtBQ0s1RSxHQUFHcVEsY0FBY1csc0JBR1QsU0FBQ0MsRUFBaUJDLE1BQzNCak8sR0FBYzJNLEVBQUs1UCxHQUFuQmlELFVBQ0o0TixFQUFRMUIsTUFFUmxNLFlBQXFCTyxLQUNmUCxFQUFVakQsR0FBR3NGLGNBQWMyTCxFQUFpQkMsT0FDL0MsSUFBSWpPLElBQ0RBLElBQ1FzQyxZQUFZdEMsR0FFeEIyQixJQUNFc00sSUFDS2xSLEdBQUcrUSxZQUFZRSxFQUFpQkosS0FFaEM3USxHQUFHd0YsV0FBV3lMLEdBQWlCLFFBR3JDLElBQUlyTSxFQUFlLElBQ2hCM0IsR0FBY2xGLEVBQU9pQyxHQUFyQmlELGFBRUpBLEVBQVcsSUFDVHdOLFNBRUF4TixhQUFxQk8sTUFDZlAsRUFBVWpELEdBQUdzRixjQUFjMkwsRUFBaUJDLE1BQ3JDLE1BRVBqTyxLQUNPLElBQ0NzQyxZQUFZdEMsSUFHMUJpTyxJQUNLbFIsR0FBRytRLFlBQVlFLEVBQWlCSixLQUVoQzdRLEdBQUd3RixXQUFXeUwsRUFBaUJSLFVBR2hDMVMsRUFBT2lDLEdBQUd5RixrQkFBa0J3TCxFQUFpQkMsVUFHdkMvTCxLQUFLckMsR0FBWSxTQUcvQm9PLEtBQ0dsUixHQUFHK1EsWUFBWUUsRUFBaUJKLEtBRWhDN1EsR0FBR3dGLFdBQVd5TCxHQUFpQixHQUcvQkosaUJBRU0sU0FBQ0ksRUFBaUJDLE1BQ3ZCak8sR0FBYzJNLEVBQUs1UCxHQUFuQmlELFVBQ0o0TixFQUFRMUIsR0FDUmdDLGVBRUF2QixHQUFLNVAsR0FBR2tGLFFBQVE5TyxVQUNWd1osRUFBSzVQLEdBQUdrRixRQUFRM08sTUFBTSxNQUNiLElBQ0RnUCxZQUFZc0wsSUFDbkI1TixZQUFxQk8sS0FDdEJQLEVBQVVqRCxHQUFHc0YsY0FBYzJMLEVBQWlCQyxHQUMzQ2pPLEtBQ0RBLEtBQ1MsSUFDRHNDLFlBQVl0QyxJQUNuQjJCLElBQ0Q3RyxFQUFPaUMsR0FBR3lGLGtCQUFrQndMLEVBQWlCQyxLQUVyQy9MLEtBQUtyQyxHQUFZLEdBRy9COEIsR0FBaUJ1TSxJQUNmRCxJQUNLbFIsR0FBRytRLFlBQVlFLEVBQWlCSixLQUVoQzdRLEdBQUd3RixXQUFXeUwsSUFJbEJKLFFBS0NqTixFQUFZd04sY0FBZSxTQUFDcGIsRUFBT2EsS0FDMUNBLEdBQVliLE1BRU40TixFQUFZbUMsU0FBU25QLFNBQVksU0FBQ0MsS0FDeENBLEdBQVkrWSxFQUFLL1ksUUFHbEI0SCxHQUFhMUQsR0FBTyxNQUNsQnNXLEVBQWdCek4sRUFBaEJ5TixZQUNKN1MsRUFBT3pELEdBQU9zVyxHQUFlLE1BQzdCL00sU0FDRXpDLElBRUZ3UCxNQUNRMVAsS0FBSzBQLEtBR1AxUCxLQUFLbkQsS0FFRDZRLEVBQWMsU0FBQ3JaLEVBQU8ySSxNQUM1QjZGLEdBQVU5RSxHQUFhbEUsS0FBS21ELEdBQzVCMlMsRUFBWTlNLEdBQVdGLEVBQ3pCdkosR0FBT3lELEdBQ1BBLEtBRUFBLElBQVM4UyxLQUNEM1AsS0FBSzJQLEtBR1ZBLEVBRUg5TSxFQUFTLElBQ0wrTSxHQUFXalEsRUFBWXRCLEdBQUdvQixTQUFTcEwsRUFBTyxTQUFDQSxLQUNqQ3NiLEVBQVd6UyxLQUNsQnlTLEVBQVczUixFQUFrQjNKLE1BQ3RCNEwsR0FBY0MsR0FBWXJELEVBQU1DLGlCQUdyQyxFQUVKeEgsRUFBT3FhLEVBQVczUixFQUFrQjRSLE9BR3ZDQyxHQUF1QixlQUFUdFosRUFDZHdYLEVBQWU4QixHQUF1QixVQUFSN1MsS0FFekIsSUFFREEsR0FBTzJDLEVBQVl0QixHQUFHb0IsU0FBU3BMLEVBQU8sU0FBQ0EsS0FDckMySSxHQUFPM0ksSUFDSDRMLEdBQWNDLEdBQVlyRCxFQUFNQyxNQUN2Q2lSLEVBQWM4QixHQUF1QyxZQUF4QnpPLEVBQVkvQyxHQUFHOUgsVUFHaEMwRixXQU1mYSxVQU9HMUQsR0FDUHVHLEVBQ0lBLEVBQVlXLFFBQ1osVUFJTUwsR0FBY0MsR0FBWXJELEVBQU1DLEdBRTFDc0UsS0FDVS9DLEdBQUcyRCxTQUFTaEMsS0FBSy9ELDBEQXRvQmRmLFdBQ1RzSCxrQ0FBa0N0SCxFQUFJa1QsVUFBWWxULEVBQUkwUyx5QkFBeUIxUyxFQUFJZ0ssTUFBTTdHLEdBQUc5SCxVQUFXMkUsK0NBU3RGNFUsYUFDZDlQLEtBQUs4UCxHQUVULGFBQ1cxQyxHQUFZMEMsZ0RBVUxBLGFBQ2Q5UCxLQUFLOFAsR0FFVCxhQUNXekMsR0FBWXlDLGtDQVluQnZaLEVBQU11TyxpQkFDYjNQLEVBQVcyUCxLQUFjRixHQUFhL0MsRUFBT2lELEdBQVcsU0FDcEQ3QyxFQUFjNkMsNkJBS04vRiw4RUFDSkEsb0JBQ1lBLHVCQUxHOEMsS0FDaEJ1QyxTQUFXbkMsRUFBWW1DLGlCQVM3QmpQLEVBQVcyUCxJQUFhdkssR0FBUXVLLEdBQVcsaUpBQ3JCakQsS0FDaEJ1Qyx3QkFFRVUsV0FLUjNQLEVBQVcyUCxJQUFhdkssR0FBUXVLLEVBQVM3UCxPQUFTc0YsR0FBUXVLLEVBQVN6USxPQUFRLGlKQUNyRHdOLEtBQ2hCdUMsU0FBV1UsVUFJakJGLEdBQWEvQyxFQUFPaUQsdUJBQ2ZpTCxrSUFBbUl4Wix5QkFLaEksZUFBVEEsc0JBQ013WixLQUFLLG9HQUtWekMsR0FBZXpULEtBQUt0RCx1QkFDZndaLGNBQWV4WixrRkFLcEJOLEdBQWVnRyxLQUFNLGtCQUNuQjJGLFFBQVV4SSxHQUFPd08sR0FBUzNMLE1BQU0yRixVQUdsQzNMLEVBQWVnRyxLQUFNLHdCQUNuQndULGtCQUdGeFosRUFBZWdHLEtBQU0sc0JBQ25CeVQsWUFBY3RXLEdBQU8sYUFJZmdVLEdBQVdGLE9BQU8sU0FBQzlILEVBQWEwSyxNQUNuQ0UsR0FBcUJGLEVBQUsxSyxFQUFhN08sV0FFdENxTyxJQUFhL0MsRUFBT21PLEdBQ3ZCQSxFQUNBNUssR0FDSE4sR0FDSCxNQUFPNUosV0FDQ3NILE1BQU0sZ0RBQWlEdEgsWUFHeEQwRyxRQUFVM0wsRUFBZTZPLEVBQVUsV0FDeENBLEVBQVNsRCxRQUNUeEksR0FBTzZDLEtBQUsyRixXQUNQRyxRQUFVOUwsRUFBZTZPLEVBQVUsV0FDeENBLEVBQVMvQyxRQUNUM0ksR0FBTzZDLEtBQUs4RixTQUVaOUwsRUFBZTZPLEVBQVUsbUJBQ2xCQSxFQUFTNEssWUFBYSxXQUc1QjlOLFFBQVFyTCxHQUFRdU8sRUFFZEEsOEJBU0V2TyxTQUNGMEYsTUFBSzJGLFFBQVFyTCxvQ0FTTkEsU0FDUDBGLE1BQUs4RixRQUFReEwsaUNBV1RBLEVBQU11TyxpQkFDYjNQLEVBQVcyUCxLQUFjRixHQUFhckgsR0FBT3VILEdBQVcsSUFDcEQ2SCxHQUFjN0gsNktBR05wRixFQUFVdEIsZUFDRnNCLEVBQVV0QixFQUFVbkMsYUFGakJzQixRQU90QnFILEdBQWFySCxHQUFPdUgsdUJBQ2ZpTCxhQUFjeFosb0hBS1gsV0FBVEEsc0JBQ013WixLQUFLLGdHQUtWeEMsR0FBZ0IxVCxLQUFLdEQsdUJBQ2hCd1osY0FBZXhaLGtGQUtwQk4sR0FBZWdHLEtBQU0sa0JBQ25COEYsUUFBVTNJLEdBQU93TyxHQUFTM0wsTUFBTThGLGdCQUkxQnNMLEdBQVdILE9BQU8sU0FBQzlILEVBQWEwSyxNQUNuQ0UsR0FBcUJGLEVBQUsxSyxFQUFhN08sV0FFdENxTyxJQUFhckgsR0FBT3lTLEdBQ3ZCQSxFQUNBNUssR0FDSE4sR0FDSCxNQUFPNUosV0FDQ3NILE1BQU0sZ0RBQWlEdEgsWUFHeER1QyxPQUFTTixFQUFvQjVHLFFBRWpDd0wsUUFBUXhMLEdBQVF1TyxFQUVkQSw0REE0Qk1tSSwrQ0FDTkEsR0FBU0MsT0FBT2pJLEdBQVdoSix3TkF1YzNCQSxNQUFLb0MsR0FBR2tGLFFBQVF2TixnREFVaEJpRyxNQUFLb0MsR0FBRzlILG1EQVVSMEYsTUFBS29DLEdBQUc4QyxXQUFXbkwsdURBVW5CaUcsTUFBS29DLEdBQUdzQiw4REFVUjFELE1BQUtvQyxHQUFHZ0QsZ0RBWVJ1TSxFQUFNelosTUFBVW9CLDBEQUFTMEcsV0FDekJBLE1BQUtvQyxHQUFHb0IsU0FBU21PLEVBQU16WixFQUFVb0IsNENBbDBCeEIseUJBNENkc00sSUFPR0QsUUFBVXhJLEdBQU9pUCxJQVBwQnhHLEdBZUdFLFFBQVUzSSxHQUFPa1AsSUFmcEJ6RyxHQXVCRzZOLFlBQWMsS0F2QmpCN04sR0ErQkc0TixjQUFnQixLQS9CbkI1TixHQXVDR3VDLDRCQXV2QlQxTSxFQUFlbUssR0FBTyxTQUN0QmlHLEdBQVNqRyxHQUFNL0osVUFBVyxLQ2w2QjFCLElBQU1tWSxvQ0FDQUMsMENBRUFDLHNOQWdGSkMsMEJBQTRCLFNBQUM3WixTQUl2QmtTLEVBQUtwSyxHQUZQZ1MsSUFBQUEsYUFDQWhPLElBQUFBLGFBR0d3RyxxQkFFSXhHLFdBQ0dnTyxPQUlkQyxpQ0FBbUMsU0FBQ3BPLE9BQzdCL00sRUFBVytNLGlCQUNUMkcsTUFBUSxZQVFYSixFQUFLcEssR0FGUGdTLElBQUFBLGFBQ0FoTyxJQUFBQSxhQUdHd0csNEJBRUl4RyxXQUNHZ08sMkVBbkdDdFIsU0FhVDlDLEtBQUtvQyxPQVhQc0IsWUFDRXRCLEdBQ2VrUyxJQUFiNVEsWUFDZ0I2USxJQUFoQm5QLGVBQ2NXLElBQWRxTyxhQUdVSSxJQUFkSixhQUNBMVEsSUFBQUEsWUFDQTBCLElBQUFBLGVBQ1lxUCxJQUFadE8sYUFLRW5HLEtBQUtZLEtBRlB0RyxJQUFBQSxLQUNBMkwsSUFBQUEsWUFFRXlPLHFCQUVDQyxZQUFjalIsT0FDZGtSLGVBQWlCeFAsRUFFbEI5SyxZQUNHNlosMEJBQ0huVSxLQUFLd0QsU0FBU3dRLEdBQWVoVSxLQUFLbVUsNEJBTWxDbE8sWUFDR29PLGlDQUNIclUsS0FBS3dELFNBQVN5USxHQUFzQmpVLEtBQUtxVSxtQ0FNekNHLEVBQVloYyxjQUNDNEosR0FBR3lTLFFBQVE5USxLQUFLL0QsWUFLNUIyVSxZQUFjTDs2UEFDZE0sZUFBaUJMLE9BRWxCRSxLQUNNbmMsRUFBWXlOLEVBQVUscUJBQUd6TCxrQkFBOENtYSxJQUUxRUMsTUFDS3BjLEVBQVk4TSxFQUFlaEQsR0FBR3lTLFFBQVMscUJBQUd6UyxHQUFNK0QsYUFBa0NzTyxZQUduRkUsWUFBY3ZQLE9BQ2R3UCxlQUFpQnhQLElBQ2hCaE4sZ0JBQ01zYyxFQUFNdGMsTUFBTWdLLEdBQUdnUyxvQkFLMUJ4SCxNQUFROEgsRUFDVEEsRUFBTXRjLE1BQU0yTixTQUNaLFdBRUM2RyxNQUFRN0csV0E1RUVILEdBQWZzTyxJQUNHL0wsaU9BZ0hUaUUsR0FBVyxXQUFhOEgsRUN0SHhCLElBQU0vTCx1TEFRQTJNLHVJQUFjbFAsR0FBZGtQLElBQ0czTSxTQUFXQSxnQkNGZDRNLGdFQU1OM0ksSUFBVyx3Q0FPR3RKLDhFQUNKQSx1QkFHSmxDLFNBQ0V5SCxLQUFBQSxhQUFPLGNBQ1BoUSxNQUFBQSxhQUFRLG9CQUlQK1AsU0FBV0MsSUFDWEMsVUFBWWpRLElBQ1oyYyxZQUFjN1gsR0FBTyx5RUFJckI4WCxVQUFValYsS0FBS3dELFNBQVN1UixHQUFXL1UsS0FBS2lWLG1CQXZCTnJQLE9BQ2xDNk4sMEJBQ0RwTCxFQUFNaFEsU0FDREEsbUNBdUJYNGMsVUFBWSxTQUFDclUsTUFDUHNVLEdBQU10VSxFQUFLLEdBQ1h1VSxFQUFXdlUsRUFBSyxHQUNkd1UsRUFBU3hVLEVBQUssS0FPaEJ5VSxFQUFLalQsR0FKUGdTLElBQUFBLGFBQ0ExUSxJQUFBQSxZQUNBd0IsSUFBQUEsV0FDQUUsSUFBQUEsZUFJT2tRLElBRFAxVSxLQUNFMlUsSUFFRlAsSUFBQUEsWUFDQTVNLElBQUFBLFNBQ0FFLElBQUFBLFVBRUlrTixFQUFpQnJZLEdBQU8sTUFDeEJzWSxFQUFtQnRZLEdBQU8sTUFDMUJ1WSxFQUFVdlksR0FBTyxNQUNqQndZLEVBQVFyWCxHQUFRNFcsR0FDaEJVLEVBQVVELEVBQ1psZCxFQUNBeUIsQ0FFQXliLElBQVN6YyxFQUFXa2MsT0FDaEJGLEVBQ0huYixRQUNBOGIsS0FBS1QsSUFHTmxjLEVBQVdpYyxRQUNEQSxJQUdWN1csR0FBUTZXLE1BQ0dBLEVBQVUsU0FBQ3ZHLEtBQ2hCc0csRUFBSXRHLE9BQU9BLE9BSWJzRyxFQUFLLFNBQUM3TSxFQUFNaFEsTUFDWmtkLEdBQU1ELEVBQUlqTixFQUFNaFEsRUFBTzZjLEVBQUt4UixFQUU5QjZSLEtBQU9FLFlBQ0RsUCxvRUFBbUUrTyxFQUFJbkQsVUFBWW1ELFVBRzVFQyxHQUFPbGQsSUFDaEJBLEdBQVNrZCxNQUdMUCxFQUFhLFNBQUMvTCxFQUFPc00sR0FDM0JBLElBQU9FLE9BQ0p4TSxRQUlQNUQsWUFFSTZQLEVBQUssU0FBQzdNLEVBQU1oUSxNQUNaa2QsR0FBTUcsRUFBUXJkLEdBQ2hCNFEsWUFFQXdNLEVBQWlCRixLQUFTbGQsTUFJeEJ5ZCxHQUFlZCxFQUFZTyxNQUU3Qk8sUUFDTUEsSUFDRjFULEdBQUdnQyxNQUFNa0UsR0FBYWpRLElBQ3RCK0osR0FBR2dDLE1BQU1nRSxHQUFZQyxFQUV2QlksRUFBTTdHLEdBQUdpRCxZQUFjQSxFQUFXLElBQzVCaUMsR0FBWTJCLEVBQU03RyxHQUFsQmtGLE9BRUpqQyxLQUNRakQsR0FBR3NGLGNBQWNKLEdBQVMsS0FFL0JsRixHQUFHeUYsa0JBQWtCUCxHQUFTLFdBSS9CdEMscURBTUUsc0JBQ084UCxZQUNIVixzRkFXRG1CLEdBQU90TSxJQUNoQjdHLEdBQUdpRCxVQUFZQSxJQUNUNEQsT0FHVCtMLFlBQWNRLE9DbEp2QixJQUFNVCxvQ0FFTjNJLElBQVcsdU1BRUNsSCxFQUFlbEYsS0FBS29DLEdBQXBCOEMsYUFJSmxGLEtBQUtZLEtBRlA4QyxJQUFBQSxZQUNBMEIsSUFBQUEsb0JBR0doRCxHQUFHb0IsU0FBU3VSLEdBQVcsU0FBQzNjLFNBT3ZCaWQsRUFBS2pULEdBTFAyRCxJQUFBQSxTQUNBMUUsSUFBQUEsT0FDQWxCLElBQUFBLE9BQ0FxRSxJQUFBQSxpQkFDQThDLElBQUFBLFVBR1d2QixFQUFVZ0QsTUFDVjFILEVBQVEwSCxNQUNiN0ksU0FFSkMsWUFBa0J5RixPQUNieEQsR0FBR3FRLGNBQWNuTCxLQUdyQmxGLEdBQUcyRCxjQUNIM0QsR0FBR2YsWUFDSGUsR0FBR29DLGlCQUFtQkEsRUFBaUJvSyxPQUFPLGVBQUd2TSxLQUFBQSxTQUFVQyxJQUFBQSxhQUFTd1Asb0JBRTlELElBR096UCxFQUFVQyxPQUV2QkYsR0FBR2tGLFFBQVUsR0FBSXpKLE9BRWxCd0gsWUFFU2pOLE1BQWEsU0FBQ2lQLEtBQ2JyQyxTQUNKcUMsdUZBU0dnTyxFQUFLalQsR0FBRzJFLGNBQWUsU0FBQzBCLFdBR2hDckcsR0FBRzJFLGtCQUNQL0csTUFBTSxVQXJEc0M0RixjQ0w3Q21QLGdDQUVOM0ksSUFBVyxrT0FjVDJKLGVBQWlCLFNBQUMxRixPQUNGQSxFQUVWN0QsRUFBSzZELFlBQWNBLE1BQ2hCQSxVQUFZQSxJQUNaekQsTUFBUXlELEVBQ1Q3RCxFQUFLcEssR0FBR2dTLGFBQ1Isb0ZBWEQvRCxXQUFZLE9BQ1owRixlQUFlL1YsS0FBS3dELFNBQVN1UixHQUFXL1UsS0FBSytWLHdCQVhmblEsT0FDOUJ1QyxzTkNGSDRNLHFEQUtOM0ksSUFBVywwQ0FtQkd0Siw4RUFDSkEsTUFIUnpLLE1BQVEyZCxFQUFBQSxVQU1KNVQsR0FDRWdTLElBQUFBLGFBQ0ExUSxJQUFBQSxZQUVGOUMsSUFBQUEsS0FDUXhJLElBQVJ3SSxLQUFReEksTUFFTjZkLEdBQWEsV0FFWmxNLE9BQVNxSyxFQUNYeEYsT0FBTyxlQUFHdFUsS0FBQUEsU0FDSSxXQUFUQSxHQUE4QixjQUFUQSxLQUlyQjJiLFFBSVMsY0FBVDNiLE9BQ1csSUFHUixJQUVSa1IsSUFBSSxTQUFDbkUsRUFBTzlPLE1BRVQrQixHQUdFK00sRUFIRi9NLE9BR0UrTSxFQUZGdEwsTUFBQUEsa0JBQ0FnSyxFQUNFc0IsRUFERnRCLFNBRUVtUSxlQUVTLGNBQVQ1YixNQUNJb0osRUFBWXRCLEdBQUdvQixTQUFTekgsRUFBTW9hLEdBQUksU0FBQzFTLFFBQ2xDc0csT0FBT3hSLEdBQUdILE1BQVFxTCxJQUVuQmxMLEVBQUlpVSxFQUFLblUsV0FJUHFjLEdBQVFwYyxFQUFZa1UsRUFBS3pDLE9BQVEsZUFBR3pQLEtBQUFBLEtBQU1sQyxJQUFBQSxZQUNyQyxjQUFUa0MsR0FDR2tTLEVBQUs1TCxLQUFLd1YsVUFBVXhWLEVBQUt4SSxNQUFPQSxPQUdoQ0MsTUFBUXFjLEVBQ1RBLEVBQU1qYixJQUNOdWMsRUFBQUEsSUFDQ3BKLE1BQVE4SCxFQUNUQSxFQUFNdGMsTUFBTTJOLFNBQ1osV0FJSnlHLEVBQUtuVSxRQUFVMmQsRUFBQUEsR0FDUixjQUFUMWIsSUFDR2tTLEVBQUs1TCxLQUFLd1YsVUFBVWhlLEVBQU84ZCxPQUV6QjdkLE1BQVFFLElBQ1JxVSxNQUFRN0csNEJBTU5tUSxtRkFNUjFTLFNBQVN1UixHQUFXLFNBQUNuVSxNQUNsQjZDLEdBQVc3QyxFQUFLLEdBQ2hCd1YsRUFBWXhWLEVBQUssS0FFbEJ2SSxNQUFRMmQsRUFBQUEsSUFFUmpNLE9BQU9zTSxLQUFLLFdBQTRCOWQsTUFBekIrQixLQUFBQSxLQUFNbEMsSUFBQUEsTUFBTzJOLElBQUFBLFlBRXBCLGNBQVR6TCxHQUNHOGIsRUFBVTNTLEVBQVVyTCxZQUVsQkMsTUFBUUUsSUFDUnFVLE1BQVE3RyxHQUVOLElBSVBzUCxFQUFLaGQsUUFBVTJkLEVBQUFBLE1BQ1pwSixNQUFRLGVBbEgwQmhILE9BQ3RDdUMsMk1BT0FzTCxnQ0FDSzZDLEVBQWFDLFNBRW5CRCxLQUFnQkMsR0FDWkQsSUFBZ0JBLEdBQWVDLElBQWNBLFFDakJ6RGxLLEdBQVcsNk5BQ1RtSyxJQUFNM2IscUVBRU16QyxRQUNMb2UsTUFFQXRkLEVBQVdkLEtBSVo0SCxLQUFLWSxVQUNGNFYsSUFBTXhXLEtBQUtySCxLQUFLdU8sR0FBR2xILEtBQUtZLEtBQUs4SyxLQUFLLEtBQU10VCxTQUV4Q29lLElBQU0zYixVQUVIMEwsTUFBTSwwSUFJTDJLLEdBQ05BLFFBQ0VzRixhQXJCZ0NsVixHQ0szQytLLElBQVcsOE5BQ1RTLDhFQUVZckosTUFFUjlLLEdBR0VxSCxLQUhGckgsS0FDQWlJLEVBRUVaLEtBRkZZLEtBQ0FrTSxFQUNFOU0sS0FERjhNLFFBRUkySixJQUVGN1YsT0FDUzZDLEVBQ1A3QyxNQUlGeEgsRUFBU3FLLE9BQ0FBLEVBQVNySCxNQXBCQSxRQXVCbEJrQyxHQUFRbUYsTUFDR3FKLEVBQVMsU0FBQ0ksSUFDVSxJQUEzQnpKLEVBQVM3SyxRQUFRc1UsTUFDZDVNLFlBQVk0TSxPQUdSekosRUFBVSxTQUFDeUosR0FDbEI5VCxFQUFTOFQsT0FDQW5KLEtBQUttSixLQUNYM04sU0FBUzJOLFVBSUxKLEVBQVMsU0FBQ0ksR0FDaEJ6SixHQUFhQSxFQUFTeUosTUFDcEI1TSxZQUFZNE0sT0FHUHpKLEVBQVUsU0FBQ3lTLEVBQUtoSixHQUN4QmdKLE1BQ1NuUyxLQUFLbUosS0FDWDNOLFNBQVMyTixZQUtmSixRQUFVMkosdUNBR0p2RixPQUNOQSxFQUFrQixJQUVuQnZZLEdBRUVxSCxLQUZGckgsS0FDQW1VLEVBQ0U5TSxLQURGOE0sVUFHR3hNLFlBQVk2UCxNQUFNeFgsRUFBTW1VLFdBekRVeEwsYUNUN0MrSyxJQUtXLHdDQUdHdkosOEVBQ0pBLElBR0psQyxJQUFBQSxLQUNBd0UsSUFBQUEsZUFDQXpNLElBQUFBLEtBRUV5TCxFQUFRZ0IsRUFDUmhOLEVBQVFvVSxFQUFLaEosaUJBRWI1QyxPQUNNeEksWUFBaUJ3TixJQUNyQnhOLEVBQ0FnTixJQUNJeEUsRUFBSyxJQUdYMUgsRUFBV2QsS0FDUE8sR0FDR1MsRUFBU2hCLE9BQ1pBLEdBQVNPLHVCQXhCc0IySSxPQUNsQ2tDLFVBQVcsU0NIZGtULDZLQUNRdGUsTUFDRk8sR0FBU3FILEtBQVRySCxJQUVKUCxLQUNHa0gsU0FFQWUsNENBSUk2USxHQUNOQSxRQUNFdlksS0FBSzBILGNBYklpQixHQWtCcEIrSyxJQUFXLFVBQVlxSyxZQ3JCdkJySyxJQUtXLHdDQUdHdkosOEVBQ0pBLElBR0psQyxJQUFBQSxLQUNBd0UsSUFBQUEsZUFDQUgsSUFBQUEsS0FFRWIsRUFBUWdCLEVBQ1JoTixFQUFRb1UsRUFBS2hKLGlCQUViNUMsT0FDTXhJLFlBQWlCd04sSUFDckJ4TixFQUNBZ04sSUFDSXhFLEVBQUssSUFHWDFILEVBQVdkLEtBQ1A2TSxHQUNHN0wsRUFBU2hCLE9BQ1pBLEdBQVM2TSx1QkF4QnNCM0QsT0FDbENrQyxVQUFXLGVDTnBCNkksSUFJVyxzQ0FHR3ZKLDhFQUNKQSxVQUVGMEosR0FBSzVMLE9BQ0Y0VixJQUFNaEssRUFBSzdULEtBQUt1TyxHQUFHc0YsRUFBSzVMLEtBQUs4SyxLQUFLLEtBQU0sYUFDdENsSSxnQkFHRmdULElBQU0zYixVQUVIMEwsTUFBTSx3SkFJTDJLLEdBQ05BLFFBQ0VzRixhQW5CNEJsVixPQUM5QmtDLFVBQVcsTUNGcEI2SSxHQUFXLG1MQUNHalUsTUFDRk8sR0FBU3FILEtBQVRySCxJQUVKUCxLQUNHaUksU0FFQWYsNENBSUk0UixHQUNOQSxRQUNFdlksS0FBSzBILGNBYjJCaUIsR3hCSTNDLElBQ01pSSxJQUE0QixTQUVsQzhDLElBQVcsOE5BQ1RuUSwwRUFFWXVILEVBQVV0QixNQUVsQnhKLEdBR0VxSCxLQUhGckgsS0FDQWlJLEVBRUVaLEtBRkZZLEtBQ0ExRSxFQUNFOEQsS0FERjlELEdBR0UwRSxPQUNTbEgsRUFBa0JrSCxFQUFNLFNBQUMxRSxFQUFLa0IsS0FDbkNBLEdBQVFxRyxLQUlackssRUFBU3FLLE9BQ0F6TCxFQUNUeUwsRUFDR3JILE1BdEJ3QixXQXVCeEJ3UyxPQUFPK0gsU0FDUG5MLElBQUluQyxJQUNQcE4sT0FJVUMsRUFBSyxTQUFDOUQsRUFBT2dGLEdBQ3BCcUcsRUFBU3JHLE1BQ1BpUixVQUFValIsT0FHZGxCLElBQUl1SCxRQUVKdkgsSUFBTXVILHVDQUdBeU4sT0FDTkEsRUFBa0IsSUFFbkJ2WSxHQUVFcUgsS0FGRnJILEtBQ0F1RCxFQUNFOEQsS0FERjlELE1BR0dtUyxVQUFVOEIsTUFBTXhYLEVBQU1tSSxHQUFLNUUsWUEzQ09vRixhQ1Y3QytLLElBUVcseUNBR0d2Siw4RUFDSkEsSUFHSmxDLElBQUFBLEtBQ0F3RSxJQUFBQSxlQUNBek0sSUFBQUEsS0FFSTJCLEVBQU8zQixFQUFLMkIsT0FDWnFJLEVBQU9oSyxFQUFLeUUsS0FBSyxRQUNqQmhGLEVBQVFvVSxFQUFLaEosV0FDZm9ULEVBQW9CLE9BRW5CeFosS0FBT3FNLEdBQVFuUCxFQUFNcUksRUFBTWhLLEtBQzNCMkIsS0FBT0EsSUFDUHFJLEtBQU9BLElBQ1B2SyxNQUFRQSxJQUNSNFIsUUFBVXJSLEVBQUtvTixXQUFXNkksT0FBTyxZQUNqQ3hLLE1BQVFnQixFQUVUeEUsTUFDR3dELE1BQVFoTSxZQUFpQndOLElBQzFCeE4sRUFDQWdOLElBQ0NoTixNQUFRd0ksRUFBSyxJQUdmMUgsRUFBV3NULEVBQUtwVSxXQUNDb1UsRUFBS3BJLE1BQU1oQyxHQUFHb0IsU0FBUyxTQUFDWSxTQUFVQSxHQUFNb0ksRUFBS3BVLFFBQVEsU0FBQ3FMLEdBQ3BFK0ksRUFBS29FLGVBQWlCbk4sTUFDbkJtTixhQUFlbk4sSUFDZm9ULFFBQVFwVCxZQUticVQsR0FBbUJ0SyxFQUFLL0MsUUFBUW1OLEdBQW1CLEdBQ25ERyxFQUEwQjVkLEVBQU15ZCxHQUNoQ0ksRUFBc0IsYUFBVHJVLEVBQ2JzVSxFQUFjLGFBQ2JyRyxhQUFlcEUsRUFBSy9DLFFBQVErQyxFQUFLb0UsY0FBYyxLQUMvQ3FHLHFCQUdIRixJQUEyQkMsS0FDeEJwRyxhQUFla0csSUFDZkcsZUFFQUYsR0FBMkJDLEtBQ3pCSCxRQUFRRCxPQUdWaEcsYUFBZWdHLElBQ2ZDLFFBQVFELE1BR1ZNLGdCQUFrQnZlLEVBQUt1TyxHQUFHbUQsR0FBZ0IvUCxFQUFNcUksR0FBT3NVLEtBQ3ZERSxnQkFBa0J4ZSxFQUFLbUYsUUFBUSxRQUFRb0osR0FBRyxRQUFTLHNCQUMzQytQLEVBQWEsbUVBTXhCN1MsR0FHRXBFLEtBSEZvRSxNQUNBaE0sRUFFRTRILEtBRkY1SCxNQUNBd1ksRUFDRTVRLEtBREY0USxZQUdFMVgsR0FBV2QsS0FDUHdZLEtBRUF4WSxHQUFTd1ksa0NBSVh4WSxNQUVKTyxHQU1FcUgsS0FORnJILEtBQ0EyQixFQUtFMEYsS0FMRjFGLEtBQ0E4QyxFQUlFNEMsS0FKRjVDLEtBQ0F1RixFQUdFM0MsS0FIRjJDLEtBQ0FzQyxFQUVFakYsS0FGRmlGLEtBQ0ErRSxFQUNFaEssS0FERmdLLE9BR1csVUFBVDVNLElBQ0dDLEtBQUtqRixHQUNRLG9CQUFUZ0YsSUFDRDJQLFFBQVEsU0FBQ3FLLEtBQ1I5TSxVQUE0QyxJQUFqQ2xTLEVBQU1RLFFBQVF3ZSxFQUFPaGYsV0FHcENnRixLQUFLQSxFQUFNdU0sR0FBbUJyUCxFQUFNbEMsRUFBT3VLLEVBQU1zQyxFQUFLN00sd0NBSXZEMlIsRUFBUUUsTUFFWnRSLEdBTUVxSCxLQU5GckgsS0FDQTJCLEVBS0UwRixLQUxGMUYsS0FDQThDLEVBSUU0QyxLQUpGNUMsS0FDQXVGLEVBR0UzQyxLQUhGMkMsS0FDQXNDLEVBRUVqRixLQUZGaUYsS0FDQStFLEVBQ0VoSyxLQURGZ0ssY0FHYyxTQUFUNU0sRUFDSHpFLEVBQUswRSxPQUNMeU0sR0FBbUJ4UCxFQUFNM0IsRUFBS3lFLEtBQUtBLEdBQU91RixFQUFNc0MsRUFBSzdNLE1BQU8yUixFQUFRQyxFQUFTQyxFQUFlLG9CQUFUN00sd0NBRzVFOFQsR0FDTkEsUUFDRWdHLHVCQUdGQyx5QkF4SG9DN1YsT0FDcENrQyxVQUFXLE13QkxwQnRKLEVBQWNtUyxHQUFZLFNBQUMvSyxFQUFPaEgsS0FDMUJrSCxPQUFTTixFQUFvQjVHLElDS3JDLElBQWFnTCxJQUFNLEdBQUl6SCxJQUFLcUIsSUFRZmdKLEdBQU8sR0FBSXJLLElBQUtxQixHQUFTdUksaUJBUXpCNFAsR0FBTyxHQUFJeFosSUFBS3FCLEdBQVNtWSxNQVF6QnJhLEdBQU8sR0FBSWEsSUFBS3FCLEdBQVNsQyxLQUV0Q0QsR0FBb0JDIn0="}