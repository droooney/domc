{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/is.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/noop.js","../src/utils/toCase.js","../src/utils/toStringTag.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/is.js","../src/helpers/Elem/getEvent.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/matches.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/normalizeArgs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/getDefaultArgs.js","../src/helpers/Block/remove.js","../src/helpers/Block/wrap.js","../src/mixins/Style.js","../src/mixins/Value.js","../src/insertHtml.js","../src/initApp.js","../src/removeApp.js","../src/global.js","../src/constants.js","../src/utils/objectStatics.js","../src/Elem.js","../src/utils/setSymbolSpecies.js","../src/helpers/Block/InternalMixin.js","../src/Mixin.js","../src/Block.js","../src/blocks/Case.js","../src/blocks/Elements.js","../src/blocks/Children.js","../src/blocks/DynamicBlock.js","../src/blocks/Item.js","../src/blocks/Each.js","../src/blocks/If.js","../src/blocks/Switch.js","../src/mixins/Bind.js","../src/mixins/Class.js","../src/mixins/Elem.js","../src/mixins/Hide.js","../src/mixins/Node.js","../src/mixins/On.js","../src/mixins/Rest.js","../src/mixins/Show.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","export const { isArray } = Array;\n\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\nexport function isNil(value) {\n  /* eslint-disable eqeqeq */\n  return value == null;\n  /* eslint-enable eqeqeq */\n}\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n","const {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  for (let i = 1, length = arguments.length; i < length; i++) {\n    iterateObject(arguments[i], (value, key) => {\n      target[key] = value;\n    });\n  }\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","export function noop() {}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","import { definePrototypeProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nconst { toString } = {};\n\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(klass, tag) {\n  if (Symbol.toStringTag) {\n    definePrototypeProperties(klass.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_FIND_REGEX = /^xlink:\\w/;\nconst X_LINK_ATTR_REPLACE_REGEX = /^xlink:/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst Null = {\n  ns: null\n};\n\nexport function getAttrNS(attr, elem) {\n  const isXmlNs = attr === 'xmlns';\n\n  if (isXmlNs || attr === 'xmlns:xlink') {\n    if (elem.nodeName !== 'SVG') {\n      return Null;\n    }\n\n    return {\n      ns: XML_NS,\n      name: isXmlNs\n        ? 'xmlns'\n        : 'xlink'\n    };\n  }\n\n  if (X_LINK_ATTR_FIND_REGEX.test(attr)) {\n    if (!new Elem(elem).closest('svg').length) {\n      return Null;\n    }\n\n    return {\n      ns: X_LINK_NS,\n      name: attr.replace(X_LINK_ATTR_REPLACE_REGEX, '')\n    };\n  }\n\n  return Null;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { Elem } from '../../Elem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\nconst DOCUMENT_REGEX = /Document$/;\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isDocument(value) {\n  return DOCUMENT_REGEX.test(toStringTag(value));\n}\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || DOCUMENT_REGEX.test(tag)\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","import { assign, toStringTag } from '../../utils';\nimport { isDocument } from './is';\n\nconst EVENT_REGEX = /Event$/;\n\nexport function getEvent(event, bubbles, cancelable, realDetails, elem) {\n  let finalEvent = event;\n\n  if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n    try {\n      finalEvent = new Event(finalEvent, { bubbles, cancelable });\n      assign(finalEvent, realDetails);\n    } catch (err) {\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      finalEvent = document.createEvent('Event');\n      finalEvent.initEvent(event, bubbles, cancelable);\n\n      assign(finalEvent, realDetails);\n    }\n  }\n\n  return finalEvent;\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { isDocument } from './is';\n\nconst { indexOf } = [];\n\nexport function getMatchesFunction(elem) {\n  return (\n    elem.matches\n    || elem.matchesSelector\n    || elem.webkitMatchesSelector\n    || elem.mozMatchesSelector\n    || elem.msMatchesSelector\n    || elem.oMatchesSelector\n    || matches\n  );\n}\n\nfunction matches(selector) {\n  const document = isDocument(this)\n    ? this\n    : this.ownerDocument;\n\n  return document.querySelectorAll(selector)::indexOf(this) !== -1;\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './is';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\nimport { document } from './constants';\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, iterateObject, keys } from '../../utils';\n\nexport function calculateArgs(normalizedArgs, args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  iterateObject(normalizedArgs, (value, arg) => {\n    argsObject[arg] = value;\n  });\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","import { iterateObject, iterateArray, hasOwnProperty } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\nimport { InternalMixin } from './InternalMixin';\n\nexport function calculateAttrs({\n  newAttrs, currentAttrs, currentMixins,\n  elem, parentBlock, firstTime\n}) {\n  iterateObject(currentAttrs, (value, attr) => {\n    if (!hasOwnProperty(newAttrs, attr)) {\n      if (value instanceof InternalMixin) {\n        currentMixins[attr].$$.remove();\n        delete currentMixins[attr];\n      } else {\n        elem.removeAttr(attr);\n      }\n\n      delete currentAttrs[attr];\n    }\n  });\n\n  const mixins = [];\n\n  iterateObject(newAttrs, (value, attr) => {\n    const prevValue = currentAttrs[attr];\n\n    if (prevValue === value) {\n      return;\n    }\n\n    if (value instanceof InternalMixin) {\n      const {\n        parentScope,\n        Mixin,\n        value: evalFn\n      } = value;\n\n      if (prevValue) {\n        const mixin = currentMixins[attr];\n        const { $$ } = mixin;\n        let newValue;\n\n        $$.internal = value;\n\n        if ($$.internals.indexOf(value) === -1) {\n          $$.internals.push(value);\n\n          if (Mixin.evaluate) {\n            newValue = parentScope.$$.evaluate(\n              evalFn,\n              constructMixinWatcher(mixin, value),\n              mixin\n            );\n          }\n        } else if (Mixin.evaluate) {\n          newValue = parentScope.$$.evaluate(evalFn);\n        }\n\n        if (Mixin.evaluate) {\n          executeMixinWatchers(mixin, newValue);\n        }\n      } else {\n        const buildMixin = () => {\n          const mixin = new Mixin({\n            ...value,\n            parentBlock,\n            elem,\n            internal: value\n          });\n          const { $$ } = mixin;\n\n          $$.internal = value;\n          $$.internals = [value];\n          currentMixins[attr] = mixin;\n\n          if (Mixin.evaluate) {\n            const afterUpdate = (newValue, oldValue) => {\n              try {\n                mixin.afterUpdate(newValue, oldValue);\n              } catch (err) {\n                console.error(`Uncaught error in ${ $$.name }#afterUpdate:`, err);\n              }\n            };\n\n            $$.value = parentScope.$$.evaluate(\n              evalFn,\n              constructMixinWatcher(mixin, value),\n              mixin\n            );\n            afterUpdate($$.evaluate(afterUpdate));\n          }\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n    } else {\n      elem.attr(attr, value);\n    }\n\n    currentAttrs[attr] = value;\n  });\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, buildMixin);\n    };\n  }\n}\n\nfunction constructMixinWatcher(mixin, internalMixin) {\n  return function (newValue) {\n    if (mixin.$$.internal === internalMixin) {\n      executeMixinWatchers(mixin, newValue);\n    }\n  };\n}\n\nfunction buildMixin(builder) {\n  builder();\n}\n","import { iterateArray, iterateObject } from '../../utils';\n\nexport function normalizeArgs(argsChain) {\n  const newArgs = {};\n\n  iterateArray(argsChain, (args) => {\n    iterateObject(args, (value, arg) => {\n      newArgs[arg] = value;\n    });\n  });\n\n  return newArgs;\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: []\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { gettingVars, evalMode } from '../../Block';\nimport { removeTempWatcher } from './removeWatcher';\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (gettingVars.indexOf(scope.watchers) === -1) {\n            gettingVars.push(scope.watchers);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        const oldTempWatchers = scope.watchers.slice();\n\n        scope.watchers = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n      }\n    };\n  }));\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil, isString, isArray\n} from '../../utils';\nimport { isDocument } from '../Elem';\nimport { Elem } from '../../Elem';\nimport { SVG_NS, blocks, mixins } from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { calculateAttrs } from './calculateAttrs';\nimport { normalizeArgs } from './normalizeArgs';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { isInstanceOf } from './isInstanceOf';\nimport { InternalMixin } from './InternalMixin';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nconst emptyArray = [];\n\nexport function createBlock({ node, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = isDocument(parentElem[0])\n    ? parentElem\n    : new Elem(parentElem[0].ownerDocument);\n  const args = node.args || {};\n  const { type } = node;\n  const isElements = type === blocks.Elements;\n  let { children } = node;\n  let constructor = !isString(type) && type;\n  let DynamicBlockArgs;\n\n  if (type === blocks.DynamicBlock) {\n    DynamicBlockArgs = except(args, 'type');\n  }\n\n  if (isArray(constructor)) {\n    constructor = class extends Block {\n      static html = constructor;\n    };\n  }\n\n  if (!isInstanceOf(Block, constructor) && !isString(type)) {\n    throw new Error(`Wrong block type given: ${ type }`);\n  }\n\n  if (!constructor) {\n    const { value } = node;\n    const elem = (\n      parentElem[0].namespaceURI === SVG_NS\n        ? doc.create('svg')\n        : doc\n    ).create(type);\n    const currentAttrs = create(null);\n    const currentMixins = create(null);\n    let attrs = create(null);\n    let wasRest;\n    const attrsChain = [attrs];\n\n    iterateObject(args, (value, attr) => {\n      const isRest = value.mixin === mixins.Rest;\n      const localAttrs = isRest || wasRest\n        ? create(attrs)\n        : attrs;\n\n      if (attrs !== localAttrs) {\n        attrsChain.push(localAttrs);\n      }\n\n      attrs = localAttrs;\n\n      if (isRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localAttrs, cleanProperty);\n          assign(localAttrs, value);\n          calculateAttrs({\n            newAttrs: normalizeArgs(attrsChain),\n            currentAttrs,\n            currentMixins,\n            elem,\n            parentBlock,\n            firstTime: false\n          });\n        }, parentBlock);\n\n        wasRest = true;\n\n        return assign(localAttrs, restAttrs);\n      }\n\n      wasRest = false;\n\n      if (isInstanceOf(Mixin, value.mixin)) {\n        localAttrs[attr] = new InternalMixin({\n          Mixin: value.mixin,\n          args: value.args,\n          parentScope,\n          parentTemplate,\n          value\n        });\n\n        return;\n      }\n\n      localAttrs[attr] = parentScope.$$.evaluate(value, (value) => {\n        localAttrs[attr] = value;\n        calculateAttrs({\n          newAttrs: normalizeArgs(attrsChain),\n          currentAttrs,\n          currentMixins,\n          elem,\n          parentBlock,\n          firstTime: false\n        });\n      }, parentBlock);\n    });\n\n    parentBlock.$$.mixinsToBuild.push(calculateAttrs({\n      newAttrs: normalizeArgs(attrsChain),\n      currentAttrs,\n      currentMixins,\n      elem,\n      parentBlock,\n      firstTime: true\n    }));\n\n    if (type === '#comment') {\n      elem.text(value);\n    }\n\n    if (type === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        elem.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      elem.text(`${ text }`);\n    }\n\n    const isParentBlock = parent instanceof Block;\n    const childBlocks = [];\n\n    /* istanbul ignore if */\n    if (type === 'iframe' && !('src' in attrs)) {\n      elem.on('load', () => {\n        const document = elem[0].contentDocument;\n        const doc = new Elem(document);\n\n        new Elem(document.documentElement).remove();\n        iterateChildren(childBlocks, true);\n\n        function iterateChildren(children, isRoot) {\n          iterateArray(children, (child) => {\n            if (child instanceof Block) {\n              if (isRoot) {\n                child.$$.parentElem = doc;\n                child.$$.parent = doc;\n                child.$$.content.into(doc);\n              }\n\n              iterateChildren(child.$$.children, false);\n            } else {\n              child.into(doc);\n            }\n          });\n        }\n      });\n    }\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(elem, false);\n    } else if (prevBlock) {\n      elem.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(elem);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(elem, false);\n    } else {\n      elem.into(parentElem, false);\n    }\n\n    if (children) {\n      let prevBlock;\n      let parentElem = elem;\n\n      /* istanbul ignore if */\n      if (type === 'template') {\n        parentElem = new Elem(elem[0].content = elem[0].content || doc[0].createDocumentFragment());\n      } else if (type === 'iframe') {\n        if ('src' in attrs) {\n          children = emptyArray;\n        } else {\n          const document = elem[0].contentDocument;\n\n          new Elem(document.documentElement).remove();\n\n          parentElem = new Elem(document);\n        }\n      }\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n        childBlocks.push(prevBlock);\n      });\n    }\n\n    return elem;\n  }\n\n  const blockInstance = new constructor({\n    args,\n    DynamicBlockArgs,\n    children,\n    parent,\n    parentElem,\n    parentBlock,\n    parentScope,\n    parentTemplate,\n    prevBlock\n  });\n  const {\n    $$,\n    $$: { name },\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  const html = isElements\n    ? Args.value || []\n    : constructor.html;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (type === blocks.Item) {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.Constructor === blocks.Item\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = isElements\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = isElements\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  iterateArray(blockInstance.$$.mixinsToBuild, (executeBuilders) => {\n    executeBuilders();\n  });\n  blockInstance.$$.mixinsToBuild = [];\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","import { iterateObject, create } from '../../utils';\n\nexport function getDefaultArgs(argsDescriptions) {\n  const newArgs = create(null);\n\n  iterateObject(argsDescriptions, ({ default: def }, arg) => {\n    newArgs[arg] = def;\n  });\n\n  return newArgs;\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /\\s*;\\s*/;\nconst CSS_STYLE_SEPARATOR_REGEX = /\\s*:\\s*/;\n\nclass Style extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean)\n          .map(constructStyleFromString),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        css\n      } = this;\n\n      elem.removeCSS.apply(elem, keys(css));\n    }\n  }\n}\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n\nfunction constructStyleFromString(style) {\n  const split = style.split(CSS_STYLE_SEPARATOR_REGEX);\n\n  return [\n    split[0].trim(),\n    split[1].trim()\n  ];\n}\n\nexport { Style };\n","import {\n  isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\n\nclass Value extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.children().filter('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      this.value = args[0];\n    }\n\n    if (!isFunction(this.value)) {\n      initialScopeValue = this.scope.$$.evaluate((scope) => scope[this.value], (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue, false);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), changeScope);\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.offElemListener();\n    }\n\n    this.offFormListener();\n  }\n}\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      values = values || [];\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        return values.indexOf(inputValue) === -1\n          ? values.concat(inputValue)\n          : values;\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n\nexport { Value };\n","import {\n  toObjectKeys,\n  assign, keys, create\n} from './utils';\n\nexport function insertHtml(html, templates) {\n  const {\n    vars = []\n  } = html;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n\n  (function iterateAndChangeChildren(nodes = []) {\n    for (let i = 0; i < nodes.length; i++) {\n      const {\n        type,\n        value,\n        children\n      } = nodes[i];\n\n      if (type === '#comment') {\n        const trimmed = value.trim();\n\n        if (newTemplates[trimmed]) {\n          const newTemplate = newTemplates[trimmed];\n\n          nodes.splice(i, 1, ...newTemplate);\n          assign(newVars, toObjectKeys(newTemplates[trimmed].vars));\n\n          i += newTemplate.length - 1;\n        }\n      } else {\n        iterateAndChangeChildren(children);\n      }\n    }\n  })(html);\n\n  html.vars = keys(newVars);\n\n  return html;\n}\n","import { isArray } from './utils';\nimport { createBlock, isInstanceOf } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function initApp\n * @public\n * @param {Template|typeof Block} html - Root template or root block constructor.\n * @param {Elem|Element} container - Container of the app.\n * @returns {Block|void} Root block if the app has been registered and undefined if not.\n * @description Method for initializing app.\n *\n * @example\n * import { initApp, doc } from 'dwayne';\n *\n * initApp(html`<App/>`, doc.create('div'));\n * initApp(htmlScopeless`<App/>`, doc.create('div'));\n * initApp('App', doc.create('div'));\n * initApp(App, doc.create('div'));\n */\nexport function initApp(html, container) {\n  const parentElem = new Elem(container).elem(0);\n\n  if (!parentElem.length) {\n    console.error('No valid element to insert the app into was given! (initApp)');\n\n    return;\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    console.error('There already exists a Dwayne app inside the given element! (initApp)');\n\n    return;\n  }\n\n  let RootBlock = html;\n\n  if (isArray(html)) {\n    RootBlock = class RootBlock extends Block {\n      static html = html;\n    };\n  }\n\n  if (!isInstanceOf(Block, RootBlock)) {\n    console.error('No valid root block was given! (initApp)');\n\n    return;\n  }\n\n  const rootBlock = createBlock({\n    node: {\n      type: RootBlock\n    },\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', rootBlock)\n    .attr('dwayne-root', '');\n\n  return rootBlock;\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function removeApp\n * @public\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for removing app.\n *\n * @example\n * import { removeApp, find } from 'dwayne';\n *\n * removeApp(find('.root'));\n */\nexport function removeApp(container) {\n  const elem = new Elem(container).elem(0);\n\n  if (!elem.length) {\n    console.error('No valid element to remove the app from was given! (removeApp)');\n\n    return;\n  }\n\n  container = elem[0];\n\n  const { DwayneRootBlock } = container;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    console.error('No app registered inside the given element! (removeApp)');\n\n    return;\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete container.DwayneRootBlock;\n}\n","/* eslint-disable no-nested-ternary */\n/* eslint-disable no-negated-condition */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n/* eslint-enable no-nested-ternary */\n/* eslint-enable no-negated-condition */\n","export const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\n\nexport const blocks = {};\nexport const mixins = {};\nexport const {\n  document = {},\n  Symbol = {}\n} = global;\nexport const version = '4.0.0';\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint-disable no-proto */\n  target.__proto__ = proto;\n  /* eslint-enable no-proto */\n});\n","import {\n  isNil, isString,\n  definePrototypeProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, setSymbolSpecies,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isDocument, isValidNode, getMatchesFunction,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, getEvent, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback CollectCallback\n * @public\n * @param {AddCallback} add - Add element to the eventual set function.\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback AddCallback\n * @public\n * @param {...(Element|Node|elem)} elem - Element to add.\n */\n\n/**\n * @callback ElemMethod\n * @public\n * @this Elem\n */\n\nconst EVENT_SEPARATOR_REGEX = /[,| ] */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array.<Element|Node>\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  /**\n   * @method Elem.addMethods\n   * @public\n   * @param {String|Object.<String, ElemMethod>} methodName - Name of the method or object of\n   * method names and methods.\n   * @param {ElemMethod} [method] - If the first argument is a string this should be the method itself.\n   * @returns {typeof Elem}\n   */\n  static addMethods(methodName, method) {\n    if (arguments.length >= 2) {\n      methodName = { [methodName]: method };\n    }\n\n    definePrototypeProperties(this.prototype, methodName);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add(...elements) {\n    const elems = this.slice();\n\n    iterateArray(elements, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, object of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromArray(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const {\n        ns,\n        name\n      } = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, name)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const { ns } = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} Set of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  /**\n   * @method Elem#collect\n   * @public\n   * @param {CollectCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns eventual set.\n   * @description Method for collecting elements into a new set.\n   *\n   * @example\n   * const parents = elem.collect((add, elem) => {\n   *   add(elem.parentNode);\n   * });\n   */\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        el = type === 'svg'\n          ? document.createElementNS(SVG_NS, type)\n          : document.createElement(type);\n      }\n\n      if (!isDocument(elem)) {\n        new Elem(el).into(elem);\n      }\n\n      add(el);\n    });\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, object of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, object of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details;\n\n    return this.forEach((elem) => {\n      elem.dispatchEvent(getEvent(\n        event,\n        bubbles,\n        cancelable,\n        realDetails,\n        elem\n      ));\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback|String} filter - Filter function or a selector.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filter) {\n    if (isString(filter)) {\n      const selector = filter;\n\n      filter = (elem) => (\n        new Elem(elem).is(selector)\n      );\n    }\n\n    return this.collect((add, elem, index) => {\n      if (filter(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const { ns } = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  /**\n   * @method Elem#includes\n   * @public\n   * @param {Element|node} elem - Element to search.\n   * @return {Boolean} If the element is in the set.\n   * @description The same as Array#includes.\n   */\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (!element) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = getMatchesFunction(elem);\n\n    return elem::matches(selector);\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr(...attributes) {\n    return this.forEach((elem) => {\n      iterateArray(attributes, (attr) => {\n        const { ns } = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(classes, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS(...props) {\n    return this.forEach((elem) => {\n      iterateArray(props, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  /**\n   * @method Elem#slice\n   * @public\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n   * @returns {Elem}\n   * @description The same as Array#slice but for Elem.\n   */\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !classList.contains(cls) : condition) {\n        elem.addClass(cls);\n      } else {\n        elem.removeClass(cls);\n      }\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\nsetSymbolSpecies(Elem, Array);\n\nexport { Elem };\n","import { defineProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nexport function setSymbolSpecies(klass, species) {\n  if (Symbol.species) {\n    defineProperties(klass, {\n      [Symbol.species]: {\n        get() {\n          return species;\n        }\n      }\n    });\n  }\n}\n","import { assign } from '../../utils';\n\nclass InternalMixin {\n  constructor(opts) {\n    assign(this, opts);\n  }\n}\n\nexport { InternalMixin };\n","import {\n  defineFrozenProperties, getProto,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\nconst toStringTag = '[object Mixin]';\n\n/**\n * @class Mixin\n * @public\n * @param {Object} opts - Mixin options.\n * @returns {Mixin} Instance of Mixin.\n */\nclass Mixin {\n  /**\n   * @member {Boolean} [Mixin.evaluate = true]\n   * @type {Boolean}\n   * @public\n   * @description If the mixin value should be evaluated and watched or not.\n   */\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      internal,\n      elem,\n      args,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n    const { constructor } = getProto(this);\n    const name = constructor.displayName || constructor.name;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Mixin#$$\n       * @type {Object}\n       * @protected\n       * @property {Function} Mixin#$$.evaluate - Evaluate function.\n       * @property {Boolean} Mixin#$$.isRemoved - If the block is removed.\n       * @property {InternalMixin} Mixin#$$.internal - Current internal mixin instance.\n       * @property {InternalMixin[]} Mixin#$$.internals - Array of internal mixins bound to the the mixin.\n       * @property {String} Mixin#$$.name - Mixin name.\n       * @property {Block|void} Mixin#$$.parentBlock - Parent block.\n       * @property {Block|void} Mixin#$$.parentScope - Parent scope.\n       * @property {Block|void} Mixin#$$.parentTemplate - Parent template.\n       * @property {*} Mixin#$$.value - Current value.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing mixin.\n       */\n      $$: {\n        name,\n        internal,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            value,\n            internal\n          } = this.$$;\n          const currentValue = constructor.evaluate\n            ? value\n            : parentScope.$$.evaluate(internal.value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          isParentSignal = !!isParentSignal;\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove(isParentSignal);\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    /**\n     * @member {String} [Mixin#name]\n     * @type {String}\n     * @public\n     */\n    this.name = name;\n\n    parentBlock.$$.mixins.push(this);\n  }\n\n  afterUpdate() {}\n\n  /**\n   * @method Mixin#beforeRemove\n   * @public\n   * @param {Boolean} isElementRemoved - If element removed as well.\n   * @description Is called before the mixin removal.\n   */\n  beforeRemove(isElementRemoved) {}\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, setToStringTag,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  normalizeArgs, removeWatchers, removeWithParentSignal,\n  cleanProperty, InternalMixin, calculateArgs,\n  wrapBlock, getDefaultArgs, isInstanceOf\n} from './helpers/Block';\nimport { blocks, mixins } from './constants';\nimport { Mixin } from './Mixin';\n\n/**\n * @typedef {BlockNode[]} Template\n * @public\n * @property {String[]} vars - Template used vars.\n */\n\n/**\n * @typedef {Object} BlockNode\n * @public\n * @property {String|typeof Block} type - Block type.\n * @property {Object} [args] - Block args.\n * @property {BlockNode[]} children - Block children.\n * @property {*} value - Text or comment node value.\n */\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {Function} func - Function which caused eval error.\n * @property {String} original - Evaluated expression original js.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\nconst toStringTag = '[object Block]';\nconst afterElem = new Elem();\nconst emptyObject = {};\nlet evalMode = false;\nlet gettingVars = [];\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Block options.\n * @returns {Block} Instance of Block.\n *\n * @example\n * import { Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static html = html`<Hello text=\"{text}\"/> ({ this.times })`;\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     this.interval = setInterval(() => {\n *       this.times++;\n *     });\n *   }\n *\n *   beforeRemove() {\n *     clearInterval(this.interval);\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', html`Hello, {args.text}!`);\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  /**\n   * @member {Object} [Block.args = null]\n   * @type {Object}\n   * @public\n   * @description Block args description.\n   */\n  static args = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {String} [Block.displayName = null]\n   * @type {String}\n   * @public\n   * @description Block display name.\n   */\n  static displayName = null;\n\n  /**\n   * @member {Template} [Block.html = []]\n   * @type {Template}\n   * @public\n   * @description Block template.\n   */\n  static html = [];\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.original || err.func }\" in context of ${ err.block.$$.name }):`, err);\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      args: originalArgs,\n      DynamicBlockArgs,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const { constructor } = getProto(this);\n    const name = constructor.displayName || constructor.name;\n    const childrenBlocks = [];\n    const childrenMixins = [];\n    const isParentBlock = parent instanceof Block;\n    const isElements = constructor === blocks.Elements;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} Block#$$.args - Private args scope.\n       * @property {Block[]} Block#$$.children - Child blocks.\n       * @property {Elem} Block#$$.content - Content elements.\n       * @property {Object|void} Block#$$.DynamicBlockArgs - DynamicBlock args.\n       * @property {Function} Block#$$.evaluate - Evaluate function.\n       * @property {Object} Block#$$.globals - Private globals scope.\n       * @property {Object[]} Block#$$.htmlChildren - Block html children.\n       * @property {Boolean} Block#$$.isRemoved - If the block is removed.\n       * @property {Boolean} Block#$$.isRendered - If the block is rendered.\n       * @property {Object} Block#$$.locals - Private locals scope.\n       * @property {Mixin[]} Block#$$.mixins - Child mixins.\n       * @property {Function[]} Block#$$.mixinsToBuild - Pending mixins builders.\n       * @property {String} Block#$$.name - Block name.\n       * @property {typeof Block} Block#$$.Constructor - Block constructor.\n       * @property {Block|Elem|void} Block#$$.parent - Parent block or elem.\n       * @property {Block|void} Block#$$.parentBlock - Parent block.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Block|void} Block#$$.parentScope - Parent scope.\n       * @property {Block|void} Block#$$.parentTemplate - Parent template.\n       * @property {Block|Elem|void} Block#$$.prevBlock - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing the block.\n       */\n      $$: {\n        name,\n        DynamicBlockArgs,\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        Constructor: constructor,\n        htmlChildren: children || [],\n        children: childrenBlocks,\n        mixins: childrenMixins,\n        mixinsToBuild: [],\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forElements, forItem) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forElements = !!forElements;\n\n          const scope = constructor === blocks.Item && !forItem\n            ? this.$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : emptyObject;\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              evalMode = true;\n              gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.func = func;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error(`Uncaught error in ${ name }.onEvalError:`, e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(gettingVars, (watchers) => {\n                const watcher = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved && !this.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forElements,\n                  watcher,\n                  watchers\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(childrenMixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered && !this.$$.isRemoved) {\n            try {\n              this.afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterDOMChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor.html.vars || [], (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    const {\n      args: argsDescriptions\n    } = constructor;\n    const defaultArgs = getDefaultArgs(argsDescriptions);\n    let args = create(defaultArgs);\n    let wasRest;\n    const argsChain = [defaultArgs, args];\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isRest = value.mixin === mixins.Rest;\n      const localArgs = isRest || wasRest\n        ? create(args)\n        : args;\n\n      if (args !== localArgs) {\n        argsChain.push(localArgs);\n      }\n\n      args = localArgs;\n\n      if (isRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, value);\n          calculateArgs(normalizeArgs(argsChain), args, argsObject);\n        }, this);\n\n        wasRest = true;\n\n        return assign(localArgs, restArgs);\n      }\n\n      wasRest = false;\n\n      if (isInstanceOf(Mixin, value.mixin)) {\n        localArgs[arg] = new InternalMixin({\n          Mixin: value.mixin,\n          args: value.args,\n          value,\n          parentScope,\n          parentTemplate\n        });\n\n        return;\n      }\n\n      const forElements = isElements && arg === 'value';\n\n      localArgs[arg] = parentScope.$$.evaluate(value, (value) => {\n        localArgs[arg] = value;\n        calculateArgs(normalizeArgs(argsChain), args, argsObject);\n      }, this, forElements, isElements && parentBlock.$$.Constructor === blocks.Item);\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(normalizeArgs(argsChain), args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed. Note that\n   * it's important not to modify the DOM structure within the block. You can only insert\n   * elements to empty elements (which Dwayne considers empty) and remove ones from them.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#getName\n   * @public\n   * @returns {String}\n   * @description Returns Block name.\n   */\n  getName() {\n    return this.$$.name;\n  }\n\n  /**\n   * @method Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @method Block#getParentScope\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentScope() {\n    return this.$$.parentScope;\n  }\n\n  /**\n   * @method Block#getParentTemplate\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getParentTemplate() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block, gettingVars, evalMode };\n","import { Block } from '../Block';\n\nclass Case extends Block {}\n\nexport { Case };\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { blocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nclass Elements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, (value) => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forElements }) => {\n        if (forElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n      iterateArray(this.$$.mixinsToBuild, (executeBuilders) => {\n        executeBuilders();\n      });\n      this.$$.mixinsToBuild = [];\n    }, this, true);\n  }\n}\n\nblocks.Elements = Elements;\n\nexport { Elements };\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { Elements } from './Elements';\n\nclass Children extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentTemplate.$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate.$$.parentTemplate}\"\n    />\n  `;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      parentTemplate: {\n        $$: { htmlChildren }\n      }\n    } = this.$$;\n    const { name } = this.args;\n    let found;\n\n    if (name) {\n      found = findInArray(htmlChildren, ({ type, args }) => (\n        type === Children\n        && args\n        && args.name === name\n      ));\n\n      this.elems = found\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = htmlChildren;\n    }\n  }\n}\n\nexport { Children };\n\n","import { Block } from '../Block';\nimport { blocks } from '../constants';\nimport { Elements } from './Elements';\n\nconst watchArgs = js`args.type`;\n\nclass DynamicBlock extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    this.construct(\n      this.evaluate(watchArgs, this.construct)\n    );\n  }\n\n  construct = (type) => {\n    const {\n      htmlChildren,\n      DynamicBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      type,\n      args: DynamicBlockArgs,\n      children: htmlChildren\n    }];\n  };\n}\n\nblocks.DynamicBlock = DynamicBlock;\n\nexport { DynamicBlock };\n","import { Block } from '../Block';\nimport { Elements } from './Elements';\nimport { blocks } from '../constants';\n\nclass Item extends Block {\n  static html = html`\n    <Elements\n      value=\"{$$.htmlChildren}\"\n      parentScope=\"{this}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n}\n\nblocks.Item = Item;\n\nexport default Item;\n","import {\n  iterateArray, iterateObject,\n  isArray, isFunction, create\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport Item from './Item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nclass Each extends Block {\n  static args = {\n    uid: {\n      default(item, index) {\n        return index;\n      }\n    }\n  };\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item = '$item',\n        index = '$index'\n      }\n    } = this;\n\n    this.itemName = item;\n    this.indexName = index;\n    this.itemsByUIDs = create(null);\n  }\n\n  afterConstruct() {\n    this.renderSet(\n      this.evaluate(watchArgs, this.renderSet)\n    );\n  }\n\n  renderSet = (args) => {\n    let set = args[0];\n    let filterBy = args[1];\n    const sortBy = args[2];\n\n    const {\n      htmlChildren,\n      parentScope,\n      parentElem,\n      parentTemplate\n    } = this.$$;\n    const {\n      args: {\n        uid: UID\n      },\n      itemsByUIDs,\n      itemName,\n      indexName\n    } = this;\n    const newItemsByUIDs = create(null);\n    const newUIDsByIndexes = create(null);\n    const newUIDs = create(null);\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      const uid = UID(item, index, set, parentScope);\n\n      if (uid in newUIDsByIndexes) {\n        console.error(`UIDs can't be same for multiple items! In UID function: \"${ UID.original || UID }\"`);\n      }\n\n      newUIDsByIndexes[uid] = index;\n      newUIDs[index] = uid;\n    });\n\n    iterateObject(itemsByUIDs, (block, uid) => {\n      if (!(uid in newUIDsByIndexes)) {\n        remove(block);\n      }\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (newUIDsByIndexes[uid] !== index) {\n        return;\n      }\n\n      const prevUIDBlock = itemsByUIDs[uid];\n\n      if (prevUIDBlock) {\n        block = prevUIDBlock;\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        if (block.$$.prevBlock !== prevBlock) {\n          const { content } = block.$$;\n\n          if (prevBlock) {\n            prevBlock.$$.insertAfterIt(content, true);\n          } else {\n            this.$$.insertInStartOfIt(content, true);\n          }\n        }\n      } else {\n        block = createBlock({\n          node: {\n            type: Item,\n            itemName,\n            indexName,\n            item,\n            index,\n            children: htmlChildren\n          },\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      newItemsByUIDs[uid] = block;\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.itemsByUIDs = newItemsByUIDs;\n  };\n}\n\nexport { Each };\n","import { Block } from '../Block';\nimport { Elements } from './Elements';\n\nconst watchArgs = js`args.if`;\n\nclass If extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    this.condition = false;\n    this.constructElems(this.evaluate(watchArgs, this.constructElems));\n  }\n\n  constructElems = (condition) => {\n    condition = !!condition;\n\n    if (this.condition !== condition) {\n      this.condition = condition;\n      this.elems = condition\n        ? this.$$.htmlChildren\n        : null;\n    }\n  };\n}\n\nexport { If };\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { Elements } from './Elements';\nimport { Case } from './Case';\n\nconst watchArgs = js`[\n  args.value,\n  args.compareFn\n]`;\n\nclass Switch extends Block {\n  static html = html`\n    <Elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n  static args = {\n    default: {\n      default: false\n    },\n    compareFn: {\n      default(switchValue, caseValue) {\n        return (\n          switchValue === caseValue\n          || (switchValue !== switchValue && caseValue !== caseValue)\n        );\n      }\n    }\n  };\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren,\n        parentScope\n      },\n      args: switchArgs,\n      args: { value }\n    } = this;\n    let wasDefault = false;\n\n    this.values = htmlChildren\n      .filter(({ type, args }) => {\n        if (type !== Case) {\n          return;\n        }\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (args && args.default) {\n          wasDefault = true;\n        }\n\n        return true;\n      })\n      .map((child, i) => {\n        const {\n          args = {},\n          children\n        } = child;\n        let val;\n\n        if (!args.default) {\n          val = parentScope.$$.evaluate(args.when, (newValue) => {\n            this.values[i].value = newValue;\n\n            if (i > this.index) {\n              return;\n            }\n\n            const found = findInArray(this.values, ({ args, value }) => (\n              args.default\n              || this.args.compareFn(switchArgs.value, value)\n            ));\n\n            this.index = found\n              ? found.key\n              : Infinity;\n            this.elems = found\n              ? found.value.children\n              : null;\n          }, this);\n        }\n\n        if (this.index === Infinity && (\n          args.default\n          || this.args.compareFn(value, val)\n        )) {\n          this.index = i;\n          this.elems = children;\n        }\n\n        return {\n          args,\n          children,\n          value: val\n        };\n      });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, (args) => {\n      const newValue = args[0];\n      const compareFn = args[1];\n\n      this.index = Infinity;\n\n      this.values.some(({ args, value, children }, i) => {\n        if (\n          args.default\n          || compareFn(newValue, value)\n        ) {\n          this.index = i;\n          this.elems = children;\n\n          return true;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n}\n\nexport { Switch };\n","import { isFunction, noop } from '../utils';\nimport { Mixin } from '../Mixin';\n\nclass Bind extends Mixin {\n  off = noop;\n\n  afterUpdate(value) {\n    this.off();\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"Bind\" mixin with event name args (like \"Bind(click)\" or \"Bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n}\n\nexport { Bind };\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nclass Class extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      const {\n        elem,\n        classes\n      } = this;\n\n      elem.removeClass.apply(elem, classes);\n    }\n  }\n}\n\nexport { Class };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\n\nclass Elem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n}\n\nexport { Elem as ElemMixin };\n","import { Mixin } from '../Mixin';\n\nclass Hide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n}\n\nexport { Hide };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\n\nclass Node extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n}\n\nexport { Node as NodeMixin };\n","import { noop } from '../utils';\nimport { Mixin } from '../Mixin';\n\nclass On extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"On\" mixin with event name args (like \"On(click)\" or \"On(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.off();\n    }\n  }\n}\n\nexport { On };\n","import { Mixin } from '../Mixin';\nimport { mixins } from '../constants';\n\nclass Rest extends Mixin {}\n\nmixins.Rest = Rest;\n\nexport { Rest };\n","import { Mixin } from '../Mixin';\n\nclass Show extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove(isElementRemoved) {\n    if (!isElementRemoved) {\n      this.elem.show();\n    }\n  }\n}\n\nexport { Show };\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\nimport { document } from './constants';\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","isFunction","isNil","isString","assign","target","arguments","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","noop","toCamelCase","replace","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","toStringTag","toString","setToStringTag","klass","tag","Symbol","prototype","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","isXmlNs","nodeName","Null","XML_NS","X_LINK_ATTR_FIND_REGEX","test","Elem","closest","X_LINK_NS","X_LINK_ATTR_REPLACE_REGEX","isDocument","DOCUMENT_REGEX","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isValidNode","ELEMENT_REGEX","getEvent","event","bubbles","cancelable","realDetails","finalEvent","EVENT_REGEX","Event","err","document","ownerDocument","createEvent","initEvent","hide","addClass","getMatchesFunction","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","this","querySelectorAll","remove","parent","removeChild","show","removeClass","toElem","base","String","calculateArgs","normalizedArgs","args","argsObject","keys","arg","undefined","cleanProperty","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","calculateAttrs","newAttrs","currentAttrs","currentMixins","parentBlock","firstTime","InternalMixin","removeAttr","mixins","prevValue","parentScope","Mixin","evalFn","newValue","internal","internals","push","evaluate","constructMixinWatcher","buildMixin","afterUpdate","error","internalMixin","builder","normalizeArgs","argsChain","newArgs","constructPrivateScope","type","scope","globals","removeTempWatcher","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","evalMode","gettingVars","oldTempWatchers","isInstanceOf","Class","Subclass","isPrototypeOf","createBlock","node","parentElem","parentTemplate","prevBlock","doc","isElements","blocks","Elements","children","constructor","DynamicBlockArgs","DynamicBlock","Block","html","Error","namespaceURI","SVG_NS","wasRest","attrsChain","isRest","Rest","localAttrs","restAttrs","mixinsToBuild","isParentBlock","childBlocks","on","iterateChildren","isRoot","child","content","into","contentDocument","documentElement","insertAfterIt","insertAfter","addContent","insertInStartOfIt","createDocumentFragment","emptyArray","blockInstance","Args","locals","Item","itemName","item","indexName","Constructor","afterConstruct","isRendered","executeBuilders","afterRender","getDefaultArgs","argsDescriptions","def","default","removeWithParentSignal","wrapBlock","block","wrapper","returnValue","wrapMixin","constructStyleFromString","style","CSS_STYLE_SEPARATOR_REGEX","trim","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","values","options","init","isMultiple","addValue","concat","getListenerName","selected","insertHtml","templates","newTemplates","newVars","iterateAndChangeChildren","nodes","trimmed","newTemplate","initApp","container","RootBlock","rootBlock","removeApp","DwayneRootBlock","window","global","self","Array","defineProperties","Object","getProto","getPrototypeOf","setProto","setPrototypeOf","proto","__proto__","CSS_IMPORTANT_REGEX","emptyCollection","_this","includes","methodName","method","elems","elements","classes","forEach","list","classList","cls","attributes","ns","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","cb","element","contains","el","isText","createTextNode","createComment","createElementNS","createElement","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","details","dispatchEvent","filter","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","props","first","prev","babelHelpers.get","apply","textContent","condition","_arguments","_arguments2","species","opts","displayName","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","isElementRemoved","afterElem","emptyObject","originalArgs","childrenBlocks","childrenMixins","func","onChange","targetBlock","forElements","forItem","onChangeFlag","result","original","onEvalError","e","localWatchers","watcherBlock","newResult","removeContent","newContent","afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","Case","watchArgs","_this2","Children","htmlChildren","found","construct","Each","itemsByUIDs","renderSet","set","filterBy","sortBy","UID","uid","newItemsByUIDs","newUIDsByIndexes","newUIDs","isArr","iterate","sort","prevUIDBlock","If","constructElems","Switch","Infinity","switchArgs","wasDefault","map","val","when","compareFn","some","switchValue","caseValue","Bind","off","join","newClasses","Hide","Node","On","Show","Style","Boolean","Value","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvaXMuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL25vb3AuanMiLCIuLi9zcmMvdXRpbHMvdG9DYXNlLmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRBdHRyLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRDU1NQcm9wLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGREYXRhQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkTmV4dC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUGFyZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRQcmV2LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9jcmVhdGVIaWRlU3R5bGVOb2RlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRBdHRyTlMuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRFdmVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaGlkZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vbWF0Y2hlcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9zaG93LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS90b0VsZW0uanMiLCIuLi9zcmMvZmluZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jbGVhblByb3BlcnR5LmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svZXhlY3V0ZU1peGluV2F0Y2hlcnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jYWxjdWxhdGVBdHRycy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL25vcm1hbGl6ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jb25zdHJ1Y3RQcml2YXRlU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9yZW1vdmVXYXRjaGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0UHVibGljU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9pc0luc3RhbmNlT2YuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jcmVhdGVCbG9jay5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2dldERlZmF1bHRBcmdzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svd3JhcC5qcyIsIi4uL3NyYy9taXhpbnMvU3R5bGUuanMiLCIuLi9zcmMvbWl4aW5zL1ZhbHVlLmpzIiwiLi4vc3JjL2luc2VydEh0bWwuanMiLCIuLi9zcmMvaW5pdEFwcC5qcyIsIi4uL3NyYy9yZW1vdmVBcHAuanMiLCIuLi9zcmMvZ2xvYmFsLmpzIiwiLi4vc3JjL2NvbnN0YW50cy5qcyIsIi4uL3NyYy91dGlscy9vYmplY3RTdGF0aWNzLmpzIiwiLi4vc3JjL0VsZW0uanMiLCIuLi9zcmMvdXRpbHMvc2V0U3ltYm9sU3BlY2llcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL0ludGVybmFsTWl4aW4uanMiLCIuLi9zcmMvTWl4aW4uanMiLCIuLi9zcmMvQmxvY2suanMiLCIuLi9zcmMvYmxvY2tzL0Nhc2UuanMiLCIuLi9zcmMvYmxvY2tzL0VsZW1lbnRzLmpzIiwiLi4vc3JjL2Jsb2Nrcy9DaGlsZHJlbi5qcyIsIi4uL3NyYy9ibG9ja3MvRHluYW1pY0Jsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9JdGVtLmpzIiwiLi4vc3JjL2Jsb2Nrcy9FYWNoLmpzIiwiLi4vc3JjL2Jsb2Nrcy9JZi5qcyIsIi4uL3NyYy9ibG9ja3MvU3dpdGNoLmpzIiwiLi4vc3JjL21peGlucy9CaW5kLmpzIiwiLi4vc3JjL21peGlucy9DbGFzcy5qcyIsIi4uL3NyYy9taXhpbnMvRWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvSGlkZS5qcyIsIi4uL3NyYy9taXhpbnMvTm9kZS5qcyIsIi4uL3NyYy9taXhpbnMvT24uanMiLCIuLi9zcmMvbWl4aW5zL1Jlc3QuanMiLCIuLi9zcmMvbWl4aW5zL1Nob3cuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiZXhwb3J0IGNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbiIsImNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuY29uc3QgeyBzbGljZSB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGZvciAobGV0IGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpdGVyYXRlT2JqZWN0KGFyZ3VtZW50c1tpXSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdEZyb21PYmplY3Qob2JqZWN0LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlID0ge30pIHtcbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY2FsbGJhY2soaW5pdGlhbFZhbHVlLCB2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhjZXB0KG9iamVjdCkge1xuICBjb25zdCBuZXdPYmplY3QgPSB7fTtcbiAgY29uc3QgcGF0aHMgPSBhcmd1bWVudHM6OnNsaWNlKDEpO1xuXG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmIChwYXRocy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBuZXdPYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3Q6OmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXRlcmF0ZU9iamVjdChvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkpIHtcbiAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBjYWxsYmFjaykge1xuICBjb25zdCBuZXdPYmplY3QgPSB7fTtcblxuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBuZXdPYmplY3Rba2V5XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0IH0gZnJvbSAnLi9vYmplY3QnO1xuXG5leHBvcnQgY29uc3QgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImltcG9ydCB7IGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3Q6OnRvU3RyaW5nKCkuc2xpY2UoOCwgLTEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG9TdHJpbmdUYWcoa2xhc3MsIHRhZykge1xuICBpZiAoU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyhrbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiB0YWdcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZEF0dHIoYXR0cnMsIGF0dHIpIHtcbiAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG59XG4iLCJpbXBvcnQgeyB0b0NhbWVsQ2FzZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuY29uc3QgQ1NTX1BST1BfVkFMVUVfU0VQQVJBVE9SX1JFR0VYID0gLzogLztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENTU1Byb3AoY3NzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHZhbHVlLnNwbGl0KENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCk7XG5cbiAgICBjc3NbdG9DYW1lbENhc2UocHJvcGVydHlbMF0pXSA9IHByb3BlcnR5WzFdO1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkRGF0YUF0dHIoZGF0YSwgdmFsdWUsIGtleSkge1xuICBkYXRhW2tleV0gPSB2YWx1ZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGROZXh0KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5uZXh0U2libGluZyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUGFyZW50KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wYXJlbnROb2RlKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRQcmV2KGFkZCwgZWxlbSkge1xuICBhZGQoZWxlbS5wcmV2aW91c1NpYmxpbmcpO1xufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpIHtcbiAgY29uc3Qgc3R5bGUgPSBoZWFkLmZpbmQoYHN0eWxlIyR7IEhJREVfQ0xBU1MgfWApO1xuXG4gIGlmIChzdHlsZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoZWFkXG4gICAgLmNyZWF0ZSgnc3R5bGUnKVxuICAgIC5wcm9wKCdpZCcsIEhJREVfQ0xBU1MpXG4gICAgLnRleHQoYC4keyBISURFX0NMQVNTIH17ZGlzcGxheTpub25lICFpbXBvcnRhbnQ7fWApO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5jb25zdCBYX0xJTktfQVRUUl9GSU5EX1JFR0VYID0gL154bGluazpcXHcvO1xuY29uc3QgWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCA9IC9eeGxpbms6LztcbmNvbnN0IFhNTF9OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XG5jb25zdCBYX0xJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBOdWxsID0ge1xuICBuczogbnVsbFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJOUyhhdHRyLCBlbGVtKSB7XG4gIGNvbnN0IGlzWG1sTnMgPSBhdHRyID09PSAneG1sbnMnO1xuXG4gIGlmIChpc1htbE5zIHx8IGF0dHIgPT09ICd4bWxuczp4bGluaycpIHtcbiAgICBpZiAoZWxlbS5ub2RlTmFtZSAhPT0gJ1NWRycpIHtcbiAgICAgIHJldHVybiBOdWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuczogWE1MX05TLFxuICAgICAgbmFtZTogaXNYbWxOc1xuICAgICAgICA/ICd4bWxucydcbiAgICAgICAgOiAneGxpbmsnXG4gICAgfTtcbiAgfVxuXG4gIGlmIChYX0xJTktfQVRUUl9GSU5EX1JFR0VYLnRlc3QoYXR0cikpIHtcbiAgICBpZiAoIW5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJ3N2ZycpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIE51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5zOiBYX0xJTktfTlMsXG4gICAgICBuYW1lOiBhdHRyLnJlcGxhY2UoWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCwgJycpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBOdWxsO1xufVxuIiwiaW1wb3J0IHsgdG9TdHJpbmdUYWcsIGlzQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmNvbnN0IEhUTUxfQ09MTEVDVElPTl9SRUdFWCA9IC9eKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0KSQvO1xuY29uc3QgRE9DVU1FTlRfUkVHRVggPSAvRG9jdW1lbnQkLztcbmNvbnN0IEVMRU1FTlRfUkVHRVggPSAvRWxlbWVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEb2N1bWVudCh2YWx1ZSkge1xuICByZXR1cm4gRE9DVU1FTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRzQ29sbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIEhUTUxfQ09MTEVDVElPTl9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKHZhbHVlKSlcbiAgICB8fCBpc0VsZW0odmFsdWUpXG4gICAgfHwgaXNBcnJheSh2YWx1ZSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROb2RlKHZhbHVlKSB7XG4gIGNvbnN0IHRhZyA9IHRvU3RyaW5nVGFnKHZhbHVlKTtcblxuICByZXR1cm4gKFxuICAgIEVMRU1FTlRfUkVHRVgudGVzdCh0YWcpXG4gICAgfHwgRE9DVU1FTlRfUkVHRVgudGVzdCh0YWcpXG4gICAgfHwgdGFnID09PSAnVGV4dCdcbiAgICB8fCB0YWcgPT09ICdEb2N1bWVudEZyYWdtZW50J1xuICAgIHx8IHRhZyA9PT0gJ0NvbW1lbnQnXG4gICk7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24sIHRvU3RyaW5nVGFnIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4vaXMnO1xuXG5jb25zdCBFVkVOVF9SRUdFWCA9IC9FdmVudCQvO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHJlYWxEZXRhaWxzLCBlbGVtKSB7XG4gIGxldCBmaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgaWYgKCFFVkVOVF9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKGZpbmFsRXZlbnQpKSkge1xuICAgIHRyeSB7XG4gICAgICBmaW5hbEV2ZW50ID0gbmV3IEV2ZW50KGZpbmFsRXZlbnQsIHsgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbiAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBmaW5hbEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBmaW5hbEV2ZW50LmluaXRFdmVudChldmVudCwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cbiAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsRXZlbnQ7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVIaWRlU3R5bGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVIaWRlU3R5bGVOb2RlJztcbmltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaGlkZShlbGVtKSB7XG4gIGNyZWF0ZUhpZGVTdHlsZU5vZGUobmV3IEVsZW0oZWxlbS5vd25lckRvY3VtZW50LmhlYWQpKTtcbiAgbmV3IEVsZW0oZWxlbSkuYWRkQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0RvY3VtZW50IH0gZnJvbSAnLi9pcyc7XG5cbmNvbnN0IHsgaW5kZXhPZiB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSkge1xuICByZXR1cm4gKFxuICAgIGVsZW0ubWF0Y2hlc1xuICAgIHx8IGVsZW0ubWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm1vek1hdGNoZXNTZWxlY3RvclxuICAgIHx8IGVsZW0ubXNNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm9NYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBtYXRjaGVzXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcbiAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KHRoaXMpXG4gICAgPyB0aGlzXG4gICAgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOjppbmRleE9mKHRoaXMpICE9PSAtMTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWxlbSkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93KGVsZW0pIHtcbiAgbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0VsZW0gfSBmcm9tICcuL2lzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvRWxlbShlbGVtKSB7XG4gIHJldHVybiBpc0VsZW0oZWxlbSlcbiAgICA/IGVsZW1cbiAgICA6IG5ldyBFbGVtKGVsZW0pO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZmluZFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBbYmFzZSA9IGRvY3VtZW50XSAtIEJhc2UgdG8gZmluZCBpbi5cbiAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICogW0RvY3VtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGJhc2UgPSBkb2N1bWVudCkge1xuICByZXR1cm4gbmV3IEVsZW0oYmFzZS5xdWVyeVNlbGVjdG9yQWxsKFN0cmluZyhzZWxlY3RvcikpKTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCwga2V5cyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFyZ3Mobm9ybWFsaXplZEFyZ3MsIGFyZ3MsIGFyZ3NPYmplY3QpIHtcbiAgaXRlcmF0ZUFycmF5KGtleXMoYXJnc09iamVjdCksIChhcmcpID0+IHtcbiAgICBpZiAoIShhcmcgaW4gYXJncykpIHtcbiAgICAgIGFyZ3NPYmplY3RbYXJnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIGl0ZXJhdGVPYmplY3Qobm9ybWFsaXplZEFyZ3MsICh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgYXJnc09iamVjdFthcmddID0gdmFsdWU7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsZWFuUHJvcGVydHkodmFsdWUsIGFyZywgb2JqZWN0KSB7XG4gIGRlbGV0ZSBvYmplY3RbYXJnXTtcbn1cbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSkge1xuICBjb25zdCBvbGRWYWx1ZSA9IG1peGluLiQkLnZhbHVlO1xuXG4gIG1peGluLiQkLnZhbHVlID0gdmFsdWU7XG5cbiAgaXRlcmF0ZUFycmF5KG1peGluLiQkLndhdGNoZXJzLCAod2F0Y2hlcikgPT4ge1xuICAgIHdhdGNoZXIodmFsdWUsIG9sZFZhbHVlKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXksIGhhc093blByb3BlcnR5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZXhlY3V0ZU1peGluV2F0Y2hlcnMgfSBmcm9tICcuL2V4ZWN1dGVNaXhpbldhdGNoZXJzJztcbmltcG9ydCB7IEludGVybmFsTWl4aW4gfSBmcm9tICcuL0ludGVybmFsTWl4aW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXR0cnMoe1xuICBuZXdBdHRycywgY3VycmVudEF0dHJzLCBjdXJyZW50TWl4aW5zLFxuICBlbGVtLCBwYXJlbnRCbG9jaywgZmlyc3RUaW1lXG59KSB7XG4gIGl0ZXJhdGVPYmplY3QoY3VycmVudEF0dHJzLCAodmFsdWUsIGF0dHIpID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KG5ld0F0dHJzLCBhdHRyKSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJuYWxNaXhpbikge1xuICAgICAgICBjdXJyZW50TWl4aW5zW2F0dHJdLiQkLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgY3VycmVudE1peGluc1thdHRyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGN1cnJlbnRBdHRyc1thdHRyXTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG1peGlucyA9IFtdO1xuXG4gIGl0ZXJhdGVPYmplY3QobmV3QXR0cnMsICh2YWx1ZSwgYXR0cikgPT4ge1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9IGN1cnJlbnRBdHRyc1thdHRyXTtcblxuICAgIGlmIChwcmV2VmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJuYWxNaXhpbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgTWl4aW4sXG4gICAgICAgIHZhbHVlOiBldmFsRm5cbiAgICAgIH0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHByZXZWYWx1ZSkge1xuICAgICAgICBjb25zdCBtaXhpbiA9IGN1cnJlbnRNaXhpbnNbYXR0cl07XG4gICAgICAgIGNvbnN0IHsgJCQgfSA9IG1peGluO1xuICAgICAgICBsZXQgbmV3VmFsdWU7XG5cbiAgICAgICAgJCQuaW50ZXJuYWwgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoJCQuaW50ZXJuYWxzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICQkLmludGVybmFscy5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShcbiAgICAgICAgICAgICAgZXZhbEZuLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RNaXhpbldhdGNoZXIobWl4aW4sIHZhbHVlKSxcbiAgICAgICAgICAgICAgbWl4aW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShldmFsRm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVpbGRNaXhpbiA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtaXhpbiA9IG5ldyBNaXhpbih7XG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgIGludGVybmFsOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHsgJCQgfSA9IG1peGluO1xuXG4gICAgICAgICAgJCQuaW50ZXJuYWwgPSB2YWx1ZTtcbiAgICAgICAgICAkJC5pbnRlcm5hbHMgPSBbdmFsdWVdO1xuICAgICAgICAgIGN1cnJlbnRNaXhpbnNbYXR0cl0gPSBtaXhpbjtcblxuICAgICAgICAgIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJVcGRhdGUgPSAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWl4aW4uYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgJCQubmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQkLnZhbHVlID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoXG4gICAgICAgICAgICAgIGV2YWxGbixcbiAgICAgICAgICAgICAgY29uc3RydWN0TWl4aW5XYXRjaGVyKG1peGluLCB2YWx1ZSksXG4gICAgICAgICAgICAgIG1peGluXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWZ0ZXJVcGRhdGUoJCQuZXZhbHVhdGUoYWZ0ZXJVcGRhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgIG1peGlucy5wdXNoKGJ1aWxkTWl4aW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkTWl4aW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRBdHRyc1thdHRyXSA9IHZhbHVlO1xuICB9KTtcblxuICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIGJ1aWxkTWl4aW4pO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0TWl4aW5XYXRjaGVyKG1peGluLCBpbnRlcm5hbE1peGluKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICBpZiAobWl4aW4uJCQuaW50ZXJuYWwgPT09IGludGVybmFsTWl4aW4pIHtcbiAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZE1peGluKGJ1aWxkZXIpIHtcbiAgYnVpbGRlcigpO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQXJncyhhcmdzQ2hhaW4pIHtcbiAgY29uc3QgbmV3QXJncyA9IHt9O1xuXG4gIGl0ZXJhdGVBcnJheShhcmdzQ2hhaW4sIChhcmdzKSA9PiB7XG4gICAgaXRlcmF0ZU9iamVjdChhcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgbmV3QXJnc1thcmddID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdBcmdzO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlLCBjb2xsZWN0RnJvbU9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IGNyZWF0ZShcbiAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgID8gcGFyZW50U2NvcGUuJCQuZ2xvYmFsc1xuICAgICAgICA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IFtdXG4gICAgfTtcbiAgfSwgc2NvcGUpO1xufVxuIiwiaW1wb3J0IHsgcmVtb3ZlQXJyYXlFbGVtLCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUZW1wV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHdhdGNoZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcbiAgaXRlcmF0ZUFycmF5KHdhdGNoZXJzVG9SZW1vdmUsIHJlbW92ZVdhdGNoZXIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVXYXRjaGVyKHsgd2F0Y2hlciwgd2F0Y2hlcnMgfSkge1xuICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgbWFwT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBnZXR0aW5nVmFycywgZXZhbE1vZGUgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyByZW1vdmVUZW1wV2F0Y2hlciB9IGZyb20gJy4vcmVtb3ZlV2F0Y2hlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCBtYXBPYmplY3Qoc2NvcGVWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKGdldHRpbmdWYXJzLmluZGV4T2Yoc2NvcGUud2F0Y2hlcnMpID09PSAtMSkge1xuICAgICAgICAgICAgZ2V0dGluZ1ZhcnMucHVzaChzY29wZS53YXRjaGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHNjb3BlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2xkVGVtcFdhdGNoZXJzID0gc2NvcGUud2F0Y2hlcnMuc2xpY2UoKTtcblxuICAgICAgICBzY29wZS53YXRjaGVycyA9IFtdO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheShvbGRUZW1wV2F0Y2hlcnMsIHJlbW92ZVRlbXBXYXRjaGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSk7XG59XG4iLCJjb25zdCB7IGlzUHJvdG90eXBlT2YgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKENsYXNzLCBTdWJjbGFzcykge1xuICByZXR1cm4gQ2xhc3M6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MpICYmIENsYXNzLnByb3RvdHlwZTo6aXNQcm90b3R5cGVPZihTdWJjbGFzcy5wcm90b3R5cGUpO1xufVxuIiwiaW1wb3J0IHtcbiAgZXhjZXB0LCBjcmVhdGUsIGFzc2lnbixcbiAgaXRlcmF0ZU9iamVjdCwgaXRlcmF0ZUFycmF5LFxuICBpc05pbCwgaXNTdHJpbmcsIGlzQXJyYXlcbn0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuaW1wb3J0IHsgU1ZHX05TLCBibG9ja3MsIG1peGlucyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjbGVhblByb3BlcnR5IH0gZnJvbSAnLi9jbGVhblByb3BlcnR5JztcbmltcG9ydCB7IGNhbGN1bGF0ZUF0dHJzIH0gZnJvbSAnLi9jYWxjdWxhdGVBdHRycyc7XG5pbXBvcnQgeyBub3JtYWxpemVBcmdzIH0gZnJvbSAnLi9ub3JtYWxpemVBcmdzJztcbmltcG9ydCB7IGNvbnN0cnVjdFByaXZhdGVTY29wZSB9IGZyb20gJy4vY29uc3RydWN0UHJpdmF0ZVNjb3BlJztcbmltcG9ydCB7IGNvbnN0cnVjdFB1YmxpY1Njb3BlIH0gZnJvbSAnLi9jb25zdHJ1Y3RQdWJsaWNTY29wZSc7XG5pbXBvcnQgeyBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2lzSW5zdGFuY2VPZic7XG5pbXBvcnQgeyBJbnRlcm5hbE1peGluIH0gZnJvbSAnLi9JbnRlcm5hbE1peGluJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi8uLi9NaXhpbic7XG5cbmNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHsgbm9kZSwgcGFyZW50LCBwYXJlbnRFbGVtLCBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUsIHBhcmVudFRlbXBsYXRlLCBwcmV2QmxvY2sgfSkge1xuICBjb25zdCBkb2MgPSBpc0RvY3VtZW50KHBhcmVudEVsZW1bMF0pXG4gICAgPyBwYXJlbnRFbGVtXG4gICAgOiBuZXcgRWxlbShwYXJlbnRFbGVtWzBdLm93bmVyRG9jdW1lbnQpO1xuICBjb25zdCBhcmdzID0gbm9kZS5hcmdzIHx8IHt9O1xuICBjb25zdCB7IHR5cGUgfSA9IG5vZGU7XG4gIGNvbnN0IGlzRWxlbWVudHMgPSB0eXBlID09PSBibG9ja3MuRWxlbWVudHM7XG4gIGxldCB7IGNoaWxkcmVuIH0gPSBub2RlO1xuICBsZXQgY29uc3RydWN0b3IgPSAhaXNTdHJpbmcodHlwZSkgJiYgdHlwZTtcbiAgbGV0IER5bmFtaWNCbG9ja0FyZ3M7XG5cbiAgaWYgKHR5cGUgPT09IGJsb2Nrcy5EeW5hbWljQmxvY2spIHtcbiAgICBEeW5hbWljQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICd0eXBlJyk7XG4gIH1cblxuICBpZiAoaXNBcnJheShjb25zdHJ1Y3RvcikpIHtcbiAgICBjb25zdHJ1Y3RvciA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgc3RhdGljIGh0bWwgPSBjb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFpc0luc3RhbmNlT2YoQmxvY2ssIGNvbnN0cnVjdG9yKSAmJiAhaXNTdHJpbmcodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGJsb2NrIHR5cGUgZ2l2ZW46ICR7IHR5cGUgfWApO1xuICB9XG5cbiAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgY29uc3QgZWxlbSA9IChcbiAgICAgIHBhcmVudEVsZW1bMF0ubmFtZXNwYWNlVVJJID09PSBTVkdfTlNcbiAgICAgICAgPyBkb2MuY3JlYXRlKCdzdmcnKVxuICAgICAgICA6IGRvY1xuICAgICkuY3JlYXRlKHR5cGUpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBjdXJyZW50TWl4aW5zID0gY3JlYXRlKG51bGwpO1xuICAgIGxldCBhdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgd2FzUmVzdDtcbiAgICBjb25zdCBhdHRyc0NoYWluID0gW2F0dHJzXTtcblxuICAgIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBpc1Jlc3QgPSB2YWx1ZS5taXhpbiA9PT0gbWl4aW5zLlJlc3Q7XG4gICAgICBjb25zdCBsb2NhbEF0dHJzID0gaXNSZXN0IHx8IHdhc1Jlc3RcbiAgICAgICAgPyBjcmVhdGUoYXR0cnMpXG4gICAgICAgIDogYXR0cnM7XG5cbiAgICAgIGlmIChhdHRycyAhPT0gbG9jYWxBdHRycykge1xuICAgICAgICBhdHRyc0NoYWluLnB1c2gobG9jYWxBdHRycyk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzID0gbG9jYWxBdHRycztcblxuICAgICAgaWYgKGlzUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXR0cnMgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZU9iamVjdChsb2NhbEF0dHJzLCBjbGVhblByb3BlcnR5KTtcbiAgICAgICAgICBhc3NpZ24obG9jYWxBdHRycywgdmFsdWUpO1xuICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKHtcbiAgICAgICAgICAgIG5ld0F0dHJzOiBub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLFxuICAgICAgICAgICAgY3VycmVudEF0dHJzLFxuICAgICAgICAgICAgY3VycmVudE1peGlucyxcbiAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgICAgIGZpcnN0VGltZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICAgIHdhc1Jlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBdHRycywgcmVzdEF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgd2FzUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNJbnN0YW5jZU9mKE1peGluLCB2YWx1ZS5taXhpbikpIHtcbiAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IG5ldyBJbnRlcm5hbE1peGluKHtcbiAgICAgICAgICBNaXhpbjogdmFsdWUubWl4aW4sXG4gICAgICAgICAgYXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgY2FsY3VsYXRlQXR0cnMoe1xuICAgICAgICAgIG5ld0F0dHJzOiBub3JtYWxpemVBcmdzKGF0dHJzQ2hhaW4pLFxuICAgICAgICAgIGN1cnJlbnRBdHRycyxcbiAgICAgICAgICBjdXJyZW50TWl4aW5zLFxuICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgICAgZmlyc3RUaW1lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0sIHBhcmVudEJsb2NrKTtcbiAgICB9KTtcblxuICAgIHBhcmVudEJsb2NrLiQkLm1peGluc1RvQnVpbGQucHVzaChjYWxjdWxhdGVBdHRycyh7XG4gICAgICBuZXdBdHRyczogbm9ybWFsaXplQXJncyhhdHRyc0NoYWluKSxcbiAgICAgIGN1cnJlbnRBdHRycyxcbiAgICAgIGN1cnJlbnRNaXhpbnMsXG4gICAgICBlbGVtLFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICB9KSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgZWxlbS50ZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgbGV0IHRleHQgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS50ZXh0KGAkeyB2YWx1ZSB9YCk7XG4gICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgIGlmIChpc05pbCh0ZXh0KSkge1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGVsZW0udGV4dChgJHsgdGV4dCB9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuICAgIGNvbnN0IGNoaWxkQmxvY2tzID0gW107XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZSA9PT0gJ2lmcmFtZScgJiYgISgnc3JjJyBpbiBhdHRycykpIHtcbiAgICAgIGVsZW0ub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbVswXS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuICAgICAgICBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnJlbW92ZSgpO1xuICAgICAgICBpdGVyYXRlQ2hpbGRyZW4oY2hpbGRCbG9ja3MsIHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVDaGlsZHJlbihjaGlsZHJlbiwgaXNSb290KSB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC4kJC5wYXJlbnRFbGVtID0gZG9jO1xuICAgICAgICAgICAgICAgIGNoaWxkLiQkLnBhcmVudCA9IGRvYztcbiAgICAgICAgICAgICAgICBjaGlsZC4kJC5jb250ZW50LmludG8oZG9jKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGl0ZXJhdGVDaGlsZHJlbihjaGlsZC4kJC5jaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGQuaW50byhkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGVsZW0sIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgZWxlbS5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChlbGVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChlbGVtLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZXQgcHJldkJsb2NrO1xuICAgICAgbGV0IHBhcmVudEVsZW0gPSBlbGVtO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0eXBlID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShlbGVtWzBdLmNvbnRlbnQgPSBlbGVtWzBdLmNvbnRlbnQgfHwgZG9jWzBdLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAgIGlmICgnc3JjJyBpbiBhdHRycykge1xuICAgICAgICAgIGNoaWxkcmVuID0gZW1wdHlBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGVsZW1bMF0uY29udGVudERvY3VtZW50O1xuXG4gICAgICAgICAgbmV3IEVsZW0oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5yZW1vdmUoKTtcblxuICAgICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRCbG9ja3MucHVzaChwcmV2QmxvY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICBjb25zdCBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcbiAgICBhcmdzLFxuICAgIER5bmFtaWNCbG9ja0FyZ3MsXG4gICAgY2hpbGRyZW4sXG4gICAgcGFyZW50LFxuICAgIHBhcmVudEVsZW0sXG4gICAgcGFyZW50QmxvY2ssXG4gICAgcGFyZW50U2NvcGUsXG4gICAgcGFyZW50VGVtcGxhdGUsXG4gICAgcHJldkJsb2NrXG4gIH0pO1xuICBjb25zdCB7XG4gICAgJCQsXG4gICAgJCQ6IHsgbmFtZSB9LFxuICAgIGFyZ3M6IEFyZ3MsXG4gICAgZ2xvYmFscyxcbiAgICAuLi5sb2NhbHNcbiAgfSA9IGJsb2NrSW5zdGFuY2U7XG5cbiAgY29uc3QgaHRtbCA9IGlzRWxlbWVudHNcbiAgICA/IEFyZ3MudmFsdWUgfHwgW11cbiAgICA6IGNvbnN0cnVjdG9yLmh0bWw7XG5cbiAgJCQuYXJncyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShBcmdzKTtcbiAgJCQubG9jYWxzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGxvY2Fscyk7XG4gICQkLmdsb2JhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoZ2xvYmFscywgJ2dsb2JhbHMnLCBwYXJlbnRTY29wZSk7XG5cbiAgaWYgKHR5cGUgPT09IGJsb2Nrcy5JdGVtKSB7XG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcbiAgICAgIFtub2RlLmluZGV4TmFtZV06IG5vZGUuaW5kZXhcbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gcGFyZW50U2NvcGUuJCQuQ29uc3RydWN0b3IgPT09IGJsb2Nrcy5JdGVtXG4gICAgICA/IHBhcmVudFNjb3BlLiQkLnNjb3BlXG4gICAgICA6IHBhcmVudFNjb3BlO1xuXG4gICAgJCQucHJpdmF0ZVNjb3BlID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKHNjb3BlVmFsdWVzKTtcbiAgICBjb25zdHJ1Y3RQdWJsaWNTY29wZSgkJC5zY29wZSA9IGNyZWF0ZShzY29wZSksIHNjb3BlVmFsdWVzLCAkJC5wcml2YXRlU2NvcGUpO1xuICB9XG5cbiAgY29uc3RydWN0UHVibGljU2NvcGUoQXJncywgQXJncywgJCQuYXJncyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGdsb2JhbHMsIGdsb2JhbHMsICQkLmdsb2JhbHMpO1xuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShibG9ja0luc3RhbmNlLCBsb2NhbHMsICQkLmxvY2Fscyk7XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyQ29uc3RydWN0KCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnN0cnVjdDpgLCBlcnIpO1xuICB9XG5cbiAgcHJldkJsb2NrID0gdW5kZWZpbmVkO1xuICBwYXJlbnRTY29wZSA9IGlzRWxlbWVudHNcbiAgICA/IEFyZ3MucGFyZW50U2NvcGVcbiAgICA6IGJsb2NrSW5zdGFuY2U7XG4gIHBhcmVudFRlbXBsYXRlID0gaXNFbGVtZW50c1xuICAgID8gQXJncy5wYXJlbnRUZW1wbGF0ZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcblxuICBpdGVyYXRlQXJyYXkoaHRtbCwgKGNoaWxkKSA9PiB7XG4gICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXJlbnQ6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50QmxvY2s6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgcHJldkJsb2NrXG4gICAgfSk7XG4gIH0pO1xuXG4gIGJsb2NrSW5zdGFuY2UuJCQuaXNSZW5kZXJlZCA9IHRydWU7XG5cbiAgaXRlcmF0ZUFycmF5KGJsb2NrSW5zdGFuY2UuJCQubWl4aW5zVG9CdWlsZCwgKGV4ZWN1dGVCdWlsZGVycykgPT4ge1xuICAgIGV4ZWN1dGVCdWlsZGVycygpO1xuICB9KTtcbiAgYmxvY2tJbnN0YW5jZS4kJC5taXhpbnNUb0J1aWxkID0gW107XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyUmVuZGVyKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclJlbmRlcjpgLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIGJsb2NrSW5zdGFuY2U7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBjcmVhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0QXJncyhhcmdzRGVzY3JpcHRpb25zKSB7XG4gIGNvbnN0IG5ld0FyZ3MgPSBjcmVhdGUobnVsbCk7XG5cbiAgaXRlcmF0ZU9iamVjdChhcmdzRGVzY3JpcHRpb25zLCAoeyBkZWZhdWx0OiBkZWYgfSwgYXJnKSA9PiB7XG4gICAgbmV3QXJnc1thcmddID0gZGVmO1xuICB9KTtcblxuICByZXR1cm4gbmV3QXJncztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmVXaXRoUGFyZW50U2lnbmFsKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSh0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICBjaGlsZC4kJC5yZW1vdmUoKTtcbn1cbiIsImltcG9ydCB7IGlzSW5zdGFuY2VPZiB9IGZyb20gJy4vaXNJbnN0YW5jZU9mJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi8uLi9NaXhpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQmxvY2soYmxvY2ssIHdyYXBwZXIpIHtcbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB3cmFwcGVyKGJsb2NrKTtcblxuICByZXR1cm4gaXNJbnN0YW5jZU9mKEJsb2NrLCByZXR1cm5WYWx1ZSlcbiAgICA/IHJldHVyblZhbHVlXG4gICAgOiBibG9jaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNaXhpbihtaXhpbiwgd3JhcHBlcikge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHdyYXBwZXIobWl4aW4pO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoTWl4aW4sIHJldHVyblZhbHVlKVxuICAgID8gcmV0dXJuVmFsdWVcbiAgICA6IG1peGluO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNTdHJpbmcsIGl0ZXJhdGVPYmplY3QsIGtleXMsXG4gIGNvbGxlY3RGcm9tT2JqZWN0LCBjb2xsZWN0RnJvbUFycmF5XG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuXG5jb25zdCBDU1NfU1RZTEVTX1NFUEFSQVRPUl9SRUdFWCA9IC9cXHMqO1xccyovO1xuY29uc3QgQ1NTX1NUWUxFX1NFUEFSQVRPUl9SRUdFWCA9IC9cXHMqOlxccyovO1xuXG5jbGFzcyBTdHlsZSBleHRlbmRzIE1peGluIHtcbiAgY3NzID0ge307XG5cbiAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjc3NcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIChjc3MsIHByb3ApID0+IHtcbiAgICAgICAgY3NzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tQXJyYXkoXG4gICAgICAgIG5ld1ZhbHVlXG4gICAgICAgICAgLnNwbGl0KENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAubWFwKGNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyksXG4gICAgICAgIGFkZENTU1Byb3BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZU9iamVjdChjc3MsICh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCFuZXdWYWx1ZVtwcm9wXSkge1xuICAgICAgICBlbGVtLnJlbW92ZUNTUyhwcm9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtLmNzcyhuZXdWYWx1ZSk7XG5cbiAgICB0aGlzLmNzcyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICBpZiAoIWlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgY3NzXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgZWxlbS5yZW1vdmVDU1MuYXBwbHkoZWxlbSwga2V5cyhjc3MpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ1NTUHJvcChjc3MsIGl0ZW0pIHtcbiAgY29uc3QgW3Byb3AsIHZhbHVlXSA9IGl0ZW07XG5cbiAgY3NzW3Byb3BdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyhzdHlsZSkge1xuICBjb25zdCBzcGxpdCA9IHN0eWxlLnNwbGl0KENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gIHJldHVybiBbXG4gICAgc3BsaXRbMF0udHJpbSgpLFxuICAgIHNwbGl0WzFdLnRyaW0oKVxuICBdO1xufVxuXG5leHBvcnQgeyBTdHlsZSB9O1xuIiwiaW1wb3J0IHtcbiAgaXNGdW5jdGlvbiwgaXNOaWwsXG4gIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgVmFsdWUgZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuYW1lID0gZWxlbS5uYW1lKCk7XG4gICAgY29uc3QgdHlwZSA9IGVsZW0ucHJvcCgndHlwZScpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuICAgIGxldCBpbml0aWFsU2NvcGVWYWx1ZSA9IG51bGw7XG5cbiAgICB0aGlzLnByb3AgPSBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gZWxlbS5jaGlsZHJlbigpLmZpbHRlcignb3B0aW9uJyk7XG4gICAgdGhpcy5zY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHRoaXMuc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbih0aGlzLnZhbHVlKSkge1xuICAgICAgaW5pdGlhbFNjb3BlVmFsdWUgPSB0aGlzLnNjb3BlLiQkLmV2YWx1YXRlKChzY29wZSkgPT4gc2NvcGVbdGhpcy52YWx1ZV0sIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICB0aGlzLnNldFByb3AobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsRWxlbVZhbHVlID0gdGhpcy5nZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlLCB0cnVlKTtcbiAgICBjb25zdCBpc0luaXRpYWxTY29wZVZhbHVlTnVsbCA9IGlzTmlsKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICBjb25zdCBpc0NoZWNrYm94ID0gdHlwZSA9PT0gJ2NoZWNrYm94JztcbiAgICBjb25zdCBjaGFuZ2VTY29wZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5nZXRQcm9wKHRoaXMuY3VycmVudFZhbHVlLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG4gICAgfTtcblxuICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxFbGVtVmFsdWU7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG5cbiAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xuICAgICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxTY29wZVZhbHVlO1xuICAgICAgdGhpcy5zZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lciA9IGVsZW0ub24oZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpLCBjaGFuZ2VTY29wZSk7XG4gICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIgPSBlbGVtLmNsb3Nlc3QoJ2Zvcm0nKS5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KGNoYW5nZVNjb3BlLCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNoYW5nZVNjb3BlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjb3BlLFxuICAgICAgdmFsdWUsXG4gICAgICBjdXJyZW50VmFsdWVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NvcGVbdmFsdWVdID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb3AodmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChwcm9wID09PSAndGV4dCcpIHtcbiAgICAgIGVsZW0udGV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jykge1xuICAgICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnByb3AocHJvcCwgZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBub2RlLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvcCh2YWx1ZXMsIGluaXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiBwcm9wID09PSAndGV4dCdcbiAgICAgID8gZWxlbS50ZXh0KClcbiAgICAgIDogZ2V0VmFsdWVGb3JHZXR0aW5nKG5hbWUsIGVsZW0ucHJvcChwcm9wKSwgdHlwZSwgbm9kZS52YWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jyk7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5vZmZFbGVtTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICByZXR1cm4gZWxlbS5oYXNBdHRyKCdtdWx0aXBsZScpXG4gICAgICAgID8gJ211bHRpcGxlLXNlbGVjdCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICByZXR1cm4gJ2ZpbGVzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICA/ICdjaGVja2VkJ1xuICAgICAgICA6ICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignY29udGVudEVkaXRhYmxlJylcbiAgICAgICAgPyAndGV4dCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUpIHtcbiAgaWYgKG5hbWUgIT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBpc1JhZGlvID0gdHlwZSA9PT0gJ3JhZGlvJztcblxuICBpZiAoIWlzUmFkaW8gJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpc1JhZGlvXG4gICAgPyB2YWx1ZSA9PT0gaW5wdXRWYWx1ZVxuICAgIDogdmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yR2V0dGluZyhuYW1lLCB2YWx1ZSwgdHlwZSwgaW5wdXRWYWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBpc011bHRpcGxlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KG9wdGlvbnMsIGFkZFZhbHVlLCBbXSk7XG4gICAgfVxuXG4gICAgY2FzZSAnaW5wdXQnOiB7XG4gICAgICBpZiAodHlwZSAhPT0gJ3JhZGlvJyAmJiB0eXBlICE9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgPyBpbnB1dFZhbHVlXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW107XG5cbiAgICAgIGlmICghdmFsdWUgJiYgaW5pdCkge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpID09PSAtMVxuICAgICAgICAgID8gdmFsdWVzLmNvbmNhdChpbnB1dFZhbHVlKVxuICAgICAgICAgIDogdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAuLi52YWx1ZXMuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuICdjaGFuZ2UnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZSA9PT0gJ3JhZGlvJ1xuICAgICAgICB8fCB0eXBlID09PSAnY2hlY2tib3gnXG4gICAgICAgIHx8IHR5cGUgPT09ICdjb2xvcidcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2ZpbGUnXG4gICAgICApXG4gICAgICAgID8gJ2NoYW5nZSdcbiAgICAgICAgOiAnY2hhbmdlIGlucHV0JztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gJ2lucHV0JztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUodmFsdWVzLCB7IHNlbGVjdGVkLCB2YWx1ZSB9KSB7XG4gIGlmIChzZWxlY3RlZCAmJiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCB7IFZhbHVlIH07XG4iLCJpbXBvcnQge1xuICB0b09iamVjdEtleXMsXG4gIGFzc2lnbiwga2V5cywgY3JlYXRlXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0SHRtbChodG1sLCB0ZW1wbGF0ZXMpIHtcbiAgY29uc3Qge1xuICAgIHZhcnMgPSBbXVxuICB9ID0gaHRtbDtcbiAgY29uc3QgbmV3VGVtcGxhdGVzID0gY3JlYXRlKG51bGwpO1xuICBjb25zdCBuZXdWYXJzID0gdG9PYmplY3RLZXlzKHZhcnMpO1xuXG4gIGFzc2lnbihuZXdUZW1wbGF0ZXMsIHRlbXBsYXRlcyk7XG5cbiAgKGZ1bmN0aW9uIGl0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbihub2RlcyA9IFtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0gPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHZhbHVlLnRyaW0oKTtcblxuICAgICAgICBpZiAobmV3VGVtcGxhdGVzW3RyaW1tZWRdKSB7XG4gICAgICAgICAgY29uc3QgbmV3VGVtcGxhdGUgPSBuZXdUZW1wbGF0ZXNbdHJpbW1lZF07XG5cbiAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubmV3VGVtcGxhdGUpO1xuICAgICAgICAgIGFzc2lnbihuZXdWYXJzLCB0b09iamVjdEtleXMobmV3VGVtcGxhdGVzW3RyaW1tZWRdLnZhcnMpKTtcblxuICAgICAgICAgIGkgKz0gbmV3VGVtcGxhdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKGh0bWwpO1xuXG4gIGh0bWwudmFycyA9IGtleXMobmV3VmFycyk7XG5cbiAgcmV0dXJuIGh0bWw7XG59XG4iLCJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVCbG9jaywgaXNJbnN0YW5jZU9mIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi9CbG9jayc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gaW5pdEFwcFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtUZW1wbGF0ZXx0eXBlb2YgQmxvY2t9IGh0bWwgLSBSb290IHRlbXBsYXRlIG9yIHJvb3QgYmxvY2sgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIG9mIHRoZSBhcHAuXG4gKiBAcmV0dXJucyB7QmxvY2t8dm9pZH0gUm9vdCBibG9jayBpZiB0aGUgYXBwIGhhcyBiZWVuIHJlZ2lzdGVyZWQgYW5kIHVuZGVmaW5lZCBpZiBub3QuXG4gKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpbml0aWFsaXppbmcgYXBwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpbml0QXBwLCBkb2MgfSBmcm9tICdkd2F5bmUnO1xuICpcbiAqIGluaXRBcHAoaHRtbGA8QXBwLz5gLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKGh0bWxTY29wZWxlc3NgPEFwcC8+YCwgZG9jLmNyZWF0ZSgnZGl2JykpO1xuICogaW5pdEFwcCgnQXBwJywgZG9jLmNyZWF0ZSgnZGl2JykpO1xuICogaW5pdEFwcChBcHAsIGRvYy5jcmVhdGUoJ2RpdicpKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRBcHAoaHRtbCwgY29udGFpbmVyKSB7XG4gIGNvbnN0IHBhcmVudEVsZW0gPSBuZXcgRWxlbShjb250YWluZXIpLmVsZW0oMCk7XG5cbiAgaWYgKCFwYXJlbnRFbGVtLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHBhcmVudEVsZW0ucHJvcCgnRHdheW5lUm9vdEJsb2NrJykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdUaGVyZSBhbHJlYWR5IGV4aXN0cyBhIER3YXluZSBhcHAgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAoaW5pdEFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBSb290QmxvY2sgPSBodG1sO1xuXG4gIGlmIChpc0FycmF5KGh0bWwpKSB7XG4gICAgUm9vdEJsb2NrID0gY2xhc3MgUm9vdEJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgICAgc3RhdGljIGh0bWwgPSBodG1sO1xuICAgIH07XG4gIH1cblxuICBpZiAoIWlzSW5zdGFuY2VPZihCbG9jaywgUm9vdEJsb2NrKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIHJvb3QgYmxvY2sgd2FzIGdpdmVuISAoaW5pdEFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJvb3RCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICBub2RlOiB7XG4gICAgICB0eXBlOiBSb290QmxvY2tcbiAgICB9LFxuICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICBwYXJlbnRFbGVtXG4gIH0pO1xuXG4gIHBhcmVudEVsZW1cbiAgICAucHJvcCgnRHdheW5lUm9vdEJsb2NrJywgcm9vdEJsb2NrKVxuICAgIC5hdHRyKCdkd2F5bmUtcm9vdCcsICcnKTtcblxuICByZXR1cm4gcm9vdEJsb2NrO1xufVxuIiwiaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG4vKipcbiAqIEBmdW5jdGlvbiByZW1vdmVBcHBcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgb2YgdGhlIGFwcC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcmVtb3ZpbmcgYXBwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyByZW1vdmVBcHAsIGZpbmQgfSBmcm9tICdkd2F5bmUnO1xuICpcbiAqIHJlbW92ZUFwcChmaW5kKCcucm9vdCcpKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFwcChjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbSA9IG5ldyBFbGVtKGNvbnRhaW5lcikuZWxlbSgwKTtcblxuICBpZiAoIWVsZW0ubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCB0byByZW1vdmUgdGhlIGFwcCBmcm9tIHdhcyBnaXZlbiEgKHJlbW92ZUFwcCknKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRhaW5lciA9IGVsZW1bMF07XG5cbiAgY29uc3QgeyBEd2F5bmVSb290QmxvY2sgfSA9IGNvbnRhaW5lcjtcblxuICBpZiAoIShEd2F5bmVSb290QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdObyBhcHAgcmVnaXN0ZXJlZCBpbnNpZGUgdGhlIGdpdmVuIGVsZW1lbnQhIChyZW1vdmVBcHApJyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBEd2F5bmVSb290QmxvY2suJCQucmVtb3ZlKCk7XG4gIGVsZW0ucmVtb3ZlQXR0cignZHdheW5lLXJvb3QnKTtcblxuICBkZWxldGUgY29udGFpbmVyLkR3YXluZVJvb3RCbG9jaztcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZWdhdGVkLWNvbmRpdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbi8qIGVzbGludC1lbmFibGUgbm8tbmVzdGVkLXRlcm5hcnkgKi9cbi8qIGVzbGludC1lbmFibGUgbm8tbmVnYXRlZC1jb25kaXRpb24gKi9cbiIsImV4cG9ydCBjb25zdCBISURFX0NMQVNTID0gJ19fZHdheW5lLWhpZGRlbl9fJztcbmV4cG9ydCBjb25zdCBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG5leHBvcnQgY29uc3QgYmxvY2tzID0ge307XG5leHBvcnQgY29uc3QgbWl4aW5zID0ge307XG5leHBvcnQgY29uc3Qge1xuICBkb2N1bWVudCA9IHt9LFxuICBTeW1ib2wgPSB7fVxufSA9IGdsb2JhbDtcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzQuMC4wJztcbiIsImV4cG9ydCBjb25zdCB7XG4gIGNyZWF0ZSxcbiAga2V5cyxcbiAgZ2V0UHJvdG90eXBlT2Y6IGdldFByb3RvXG59ID0gT2JqZWN0O1xuXG5leHBvcnQgY29uc3Qgc2V0UHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCh0YXJnZXQsIHByb3RvKSA9PiB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBwcm90bztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufSk7XG4iLCJpbXBvcnQge1xuICBpc05pbCwgaXNTdHJpbmcsXG4gIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMsXG4gIGNvbGxlY3RGcm9tQXJyYXksIGNvbGxlY3RGcm9tT2JqZWN0LFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIHRvSHlwaGVuQ2FzZSwgc2V0U3ltYm9sU3BlY2llcyxcbiAgc2V0VG9TdHJpbmdUYWcsIHNldFByb3RvXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgaXNEb2N1bWVudCwgaXNWYWxpZE5vZGUsIGdldE1hdGNoZXNGdW5jdGlvbixcbiAgYWRkQXR0ciwgYWRkQ1NTUHJvcCwgYWRkRGF0YUF0dHIsXG4gIGFkZE5leHQsIGFkZFBhcmVudCwgYWRkUHJldixcbiAgdG9FbGVtLCBpc0VsZW1lbnRzQ29sbGVjdGlvbixcbiAgZ2V0QXR0ck5TLCBnZXRFdmVudCwgaGlkZSwgc2hvdywgcmVtb3ZlXG59IGZyb20gJy4vaGVscGVycy9FbGVtJztcbmltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd9IEVsZW1FdmVudFN0cmluZ1xuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIGNvbnRhaW5pbmcgZXZlbnRzIHNlcGFyYXRlZCBieSBhIGNvbW1hIHdpdGggemVybyBvciBtb3JlIHNwYWNlcyBvciBqdXN0IHNwYWNlcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtTGlzdGVuZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBGaXJlZCBldmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtUmVtb3ZlTGlzdGVuZXJzXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gey4uLkVsZW1FdmVudFN0cmluZ30gZXZlbnRzIC0gSWYgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IHByZXNlbnQgb25seSByZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBldmVudHMgaW4gdGhlIGFyZ3VtZW50cy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9IG5vZGUgLSBJdGVyYXRpb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEl0ZXJhdGlvbiBpbmRleC5cbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEluaXRpYWwgc2V0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIENvbGxlY3RDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtBZGRDYWxsYmFja30gYWRkIC0gQWRkIGVsZW1lbnQgdG8gdGhlIGV2ZW50dWFsIHNldCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSBub2RlIC0gSXRlcmF0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJdGVyYXRpb24gaW5kZXguXG4gKiBAcGFyYW0ge0VsZW19IGVsZW0gLSBJbml0aWFsIHNldC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBZGRDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsuLi4oRWxlbWVudHxOb2RlfGVsZW0pfSBlbGVtIC0gRWxlbWVudCB0byBhZGQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWxlbU1ldGhvZFxuICogQHB1YmxpY1xuICogQHRoaXMgRWxlbVxuICovXG5cbmNvbnN0IEVWRU5UX1NFUEFSQVRPUl9SRUdFWCA9IC9bLHwgXSAqLztcbmNvbnN0IENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYID0gLzsgPy87XG5jb25zdCBDU1NfSU1QT1JUQU5UX1JFR0VYID0gLyA/IWltcG9ydGFudCQvO1xuY29uc3QgZW1wdHlDb2xsZWN0aW9uID0gW107XG5cbi8qKlxuICogQGNsYXNzIEVsZW1cbiAqIEBleHRlbmRzIEFycmF5LjxFbGVtZW50fE5vZGU+XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBbZWxlbSA9IFtdXSAtIEFuIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgZWxlbWVudHMgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFbGVtfSBJbnN0YW5jZSBvZiBFbGVtLlxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYW4gZWxlbWVudHMgc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBuZXcgRWxlbShkb2N1bWVudC5ib2R5KTtcbiAqIG5ldyBFbGVtKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jbHMnKSk7XG4gKiBuZXcgRWxlbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjbHMnKSk7XG4gKi9cbmNsYXNzIEVsZW0gZXh0ZW5kcyBBcnJheSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0uYWRkTWV0aG9kc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBFbGVtTWV0aG9kPn0gbWV0aG9kTmFtZSAtIE5hbWUgb2YgdGhlIG1ldGhvZCBvciBvYmplY3Qgb2ZcbiAgICogbWV0aG9kIG5hbWVzIGFuZCBtZXRob2RzLlxuICAgKiBAcGFyYW0ge0VsZW1NZXRob2R9IFttZXRob2RdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIHRoaXMgc2hvdWxkIGJlIHRoZSBtZXRob2QgaXRzZWxmLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW19XG4gICAqL1xuICBzdGF0aWMgYWRkTWV0aG9kcyhtZXRob2ROYW1lLCBtZXRob2QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBtZXRob2ROYW1lID0geyBbbWV0aG9kTmFtZV06IG1ldGhvZCB9O1xuICAgIH1cblxuICAgIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXModGhpcy5wcm90b3R5cGUsIG1ldGhvZE5hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbGVtID0gZW1wdHlDb2xsZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgfVxuXG4gICAgc2V0UHJvdG8odGhpcywgRWxlbS5wcm90b3R5cGUpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICB0aGlzLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLihFbGVtfEVsZW1lbnR8RWxlbWVudFtdKX0gZWxlbWVudHMgLSBFYWNoIGFyZ3VtZW50IGlzIGEgRWxlbSwgb3IgRWxlbWVudCwgb3IgYXJyYXkgb2YgRWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgZWxlbWVudHMgdG8gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbTEuZmluZCgnLmNsczEnKVxuICAgKiAgIC5hZGQoZWxlbTIuZmluZCgnLmNsczInKSlcbiAgICogICAuaGlkZSgpO1xuICAgKi9cbiAgYWRkKC4uLmVsZW1lbnRzKSB7XG4gICAgY29uc3QgZWxlbXMgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICBpdGVyYXRlQXJyYXkoZWxlbWVudHMsIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIWVsZW1zLmluY2x1ZGVzKGVsZW0pICYmIGlzVmFsaWROb2RlKGVsZW0pKSB7XG4gICAgICAgICAgZWxlbXMucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWxlbXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2FkZENsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGNsYXNzZXMgLSBDbGFzc2VzIHRvIGFkZC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIGNsYXNzZXMgdG8gdGhlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygncmVkJywgJ3JvdW5kJyk7XG4gICAqL1xuICBhZGRDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4gbGlzdC5hZGQoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2F0dHJdIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAgICogaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgb2JqZWN0IG9mIGF0dHJpYnV0ZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiByZXR1cm5lZCwgaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cjEnLCAndmFsdWUxJyk7IC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCdhdHRyMScpOyAgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5hdHRyKHtcbiAgICogICBhdHRyMTogJ3ZhbHVlMycsICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIGF0dHIyOiAndmFsdWUyJyAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCk7ICAgICAgICAgICAgICAgICAgLy8geyBhdHRyMTogJ3ZhbHVlMycsIGF0dHIyOiAndmFsdWUyJyB9XG4gICAqL1xuICBhdHRyKGF0dHIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGVsZW0uYXR0cmlidXRlcywgYWRkQXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhhdHRyKSkge1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5zLFxuICAgICAgICBuYW1lXG4gICAgICB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgICByZXR1cm4gbnNcbiAgICAgICAgPyBlbGVtLmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKVxuICAgICAgICA6IGVsZW0uZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGF0dHIgPSB7IFthdHRyXTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KGF0dHIsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlO1xuXG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhrZXksIGVsZW0pO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTlMobnMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY2hpbGRyZW5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGVsZW1lbnQncyBjaGlsZHJlbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgY2hpbGRyZW4gPSBlbGVtLmNoaWxkcmVuKCk7XG4gICAqL1xuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gbmV3IEVsZW0odGhpcy5sZW5ndGggPyB0aGlzWzBdLmNoaWxkTm9kZXMgOiBbXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nsb3Nlc3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBTZXQgb2YgdGhlIGNsb3Nlc3QgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNjbG9zZXN0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0fS5cbiAgICovXG4gIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICAgIGlmIChuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gYWRkKGVsZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY29sbGVjdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Q29sbGVjdENhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgZXZlbnR1YWwgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjb2xsZWN0aW5nIGVsZW1lbnRzIGludG8gYSBuZXcgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBwYXJlbnRzID0gZWxlbS5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICogICBhZGQoZWxlbS5wYXJlbnROb2RlKTtcbiAgICogfSk7XG4gICAqL1xuICBjb2xsZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBjYiA9IDo6ZWxlbWVudHMucHVzaDtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNiLCBlbGVtLCBpbmRleCwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVsZW0oZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjb250YWluc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgYXJndW1lbnQgd2l0aGluIHRoaXMgZWxlbWVudC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBleHRlbnNpb24gZm9yXG4gICAqIFtOb2RlI2NvbnRhaW5zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcbiAgICovXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzWzBdO1xuICAgIGNvbnN0IGNoaWxkID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgcmV0dXJuICFwYXJlbnQgfHwgIWNoaWxkXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIElmIHR5cGUgaXMgXCIjY29tbWVudFwiIGEgY29tbWVudCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSAtIHdyYXAgb2YgdGhlIGNyZWF0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgZWxlbWVudCBpcyBqdXN0IGNyZWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKTtcbiAgICovXG4gIGNyZWF0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBsZXQgZWwgPSBudWxsO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdHlwZSA9PT0gJyN0ZXh0JztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gaXNEb2N1bWVudChlbGVtKVxuICAgICAgICA/IGVsZW1cbiAgICAgICAgOiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIGlmIChpc1RleHQgfHwgdHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgICBlbCA9IGlzVGV4dFxuICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpXG4gICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gdHlwZSA9PT0gJ3N2ZydcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpXG4gICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRG9jdW1lbnQoZWxlbSkpIHtcbiAgICAgICAgbmV3IEVsZW0oZWwpLmludG8oZWxlbSk7XG4gICAgICB9XG5cbiAgICAgIGFkZChlbCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgb2JqZWN0IG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBzdHlsZXMuIFN1cHBvcnRzICFpbXBvcnRhbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTsgLy8gZGlzcGxheSBzZXQgdG8gJ25vbmUnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBkaXNwbGF5OiAnaW5saW5lJywgICAgICAgICAvLyBkaXNwbGF5IHNldCB0byAnaW5saW5lJ1xuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygpOyAgICAgICAgICAgICAgICAgIC8vIHsgZGlzcGxheTogJ25vbmUnLCBjdXJzb3I6ICdwb2ludGVyJyB9XG4gICAqL1xuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KHN0eWxlLmNzc1RleHQuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpLCBhZGRDU1NQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpICsgKHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpID8gJyAhaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgdmFsdWUucmVwbGFjZShDU1NfSU1QT1JUQU5UX1JFR0VYLCAnJyksXG4gICAgICAgICAgQ1NTX0lNUE9SVEFOVF9SRUdFWC50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtrZXldIC0gTmFtZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgKHdpdGhvdXQgZGF0YS0gcHJlZml4KVxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIG9iamVjdCBvZiBkYXRhc2V0IG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgZGF0YSBhdHRyaWJ1dGVzLiBTZWVcbiAgICogW0hUTUxFbGVtZW50I2RhdGFzZXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9kYXRhc2V0fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScsICd2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnKTsgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5kYXRhKHtcbiAgICogICBzb21lS2V5MTogJ3ZhbHVlMycsICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTMnXG4gICAqICAgc29tZUtleTI6ICd2YWx1ZTInICAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCk7ICAgICAgICAgICAgICAgICAgICAvLyB7IHNvbWVLZXkxOiAndmFsdWUzJywgc29tZUtleTI6ICd2YWx1ZTInIH1cbiAgICovXG4gIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGRhdGFzZXQsIGFkZERhdGFBdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YXNldFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChrZXksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGlzcGF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudH0gZXZlbnQgLSBFdmVudCBvciBhIHN0cmluZyAobmV3IEV2ZW50KGV2ZW50KSBpcyBjcmVhdGVkKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0V2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snKTtcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UsIGRhdGE6IDEgfSk7XG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XG4gICAqL1xuICBkaXNwYXRjaChldmVudCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYnViYmxlcyA9IHRydWUsXG4gICAgICBjYW5jZWxhYmxlID0gdHJ1ZSxcbiAgICAgIC4uLnJlYWxEZXRhaWxzXG4gICAgfSA9IGRldGFpbHM7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZ2V0RXZlbnQoXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBidWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlLFxuICAgICAgICByZWFsRGV0YWlscyxcbiAgICAgICAgZWxlbVxuICAgICAgKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2VsZW1cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4ID0gMF0gLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvZiB0aGUgc2V0IHRvIGdldC4gTmVnYXRpdmUgaW5kZXggbWVhbnMgZWxlbS5sZW5ndGggKyBpbmRleC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmVsZW0oMSk7IC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDFcbiAgICogZWxlbS5lbGVtKCk7ICAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAwXG4gICAqL1xuICBlbGVtKGluZGV4ID0gMCkge1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggKyBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW0odGhpc1tpbmRleF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmaWx0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfFN0cmluZ30gZmlsdGVyIC0gRmlsdGVyIGZ1bmN0aW9uIG9yIGEgc2VsZWN0b3IuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmZpbHRlcigoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuY2xvc2VzdCgnLnBhcmVudCcpKTtcbiAgICovXG4gIGZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBmaWx0ZXI7XG5cbiAgICAgIGZpbHRlciA9IChlbGVtKSA9PiAoXG4gICAgICAgIG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZmlsdGVyKGVsZW0sIGluZGV4LCB0aGlzKSkge1xuICAgICAgICBhZGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbmRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cbiAgICovXG4gIGZpbmQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0pID0+IHtcbiAgICAgIGFkZChmaW5kKHNlbGVjdG9yLCBlbGVtKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZvckVhY2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZmluZCgnLmNscycpLmZvckVhY2goKGVsZW1lbnQsIGluZGV4LCBzZXQpID0+IHtcbiAgICogICAvLyBkbyBzb21ldGhpbmdcbiAgICogfSk7XG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgaXRlcmF0ZUFycmF5KHRoaXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoYXNBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgYXR0cmlidXRlLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgcmV0dXJucyBpZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgYXR0cmlidXRlIG9yIG5vdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hdHRyKCdhdHRyJywgJ3ZhbHVlJykuaGFzQXR0cignYXR0cicpOyAvLyB0cnVlXG4gICAqIGVsZW0ucmVtb3ZlQXR0cignYXR0cicpLmhhc0F0dHIoJ2F0dHInKTsgICAgLy8gZmFsc2VcbiAgICovXG4gIGhhc0F0dHIoYXR0cikge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeyBucyB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgcmV0dXJuIG5zXG4gICAgICA/IGVsZW0uaGFzQXR0cmlidXRlTlMobnMsIGF0dHIpXG4gICAgICA6IGVsZW0uaGFzQXR0cmlidXRlKGF0dHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoYXNDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBOYW1lIG9mIHRoZSBjbGFzcy5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGNsYXNzIG9yIG5vdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJykuaGFzQ2xhc3MoJ2NscycpOyAgICAvLyB0cnVlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgLy8gZmFsc2VcbiAgICovXG4gIGhhc0NsYXNzKGNscykge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgcmV0dXJuIGVsZW1cbiAgICAgID8gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoY2xzKVxuICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGlkZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBIaWRlcyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5oaWRlKCk7XG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goaGlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2h0bWxcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBbaHRtbF0gLSBIVE1MIHRvIHdyaXRlIGluc3RlYWQgb2YgY3VycmVudCBIVE1MLlxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgSFRNTCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIEhUTUwgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSBodG1sIGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBvciBzZXRzIEhUTUwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaHRtbCgnPGRpdj4xPC9kaXY+Jyk7XG4gICAqIGVsZW0uaHRtbCgpOyAvLyAnPGRpdj4xPC9kaXY+J1xuICAgKi9cbiAgaHRtbChodG1sKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgICAgcmV0dXJuIGVsZW1cbiAgICAgICAgPyBlbGVtLmlubmVySFRNTFxuICAgICAgICA6ICcnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0uaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaW5jbHVkZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW1lbnR8bm9kZX0gZWxlbSAtIEVsZW1lbnQgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHNhbWUgYXMgQXJyYXkjaW5jbHVkZXMuXG4gICAqL1xuICBpbmNsdWRlcyhlbGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEFmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYWZ0ZXIgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGJlZm9yZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudFswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnRvXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHB1dCB0aGlzIGVsZW1lbnRzIGludG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSB0aGV5IGFyZSBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNhcHBlbmRDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvYXBwZW5kQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmludG8oZWxlbTIpO1xuICAgKiBlbGVtLmludG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmludG8oJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGludG8oZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudClbMF07XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpc1tpXSwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSk7XG5cbiAgICByZXR1cm4gZWxlbTo6bWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfHZvaWR9IG5vZGVOYW1lIChsb3dlcmNhc2VkKSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIG5hbWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGUoJ2RpdicpLm5hbWUoKSAvLyAnZGl2J1xuICAgKi9cbiAgbmFtZSgpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25leHRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm5leHQoKTsgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkTmV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI29uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtRXZlbnRTdHJpbmd8T2JqZWN0LjxFbGVtRXZlbnRTdHJpbmd8RWxlbUxpc3RlbmVyPn0gZXZlbnQgLSBFaXRoZXIgYSB7QGxpbmsgRWxlbUV2ZW50U3RyaW5nfSBzdHJpbmdcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggZXZlbnQga2V5cyAoYSBrZXkgaXMgYWxzbyBFbGVtRXZlbnRTdHJpbmcpIGFuZCBsaXN0ZW5lcnMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0VsZW1MaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBtdXN0IGJlIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yXG4gICAqIHNwZWNpZmllZCBldmVudChzKS5cbiAgICogQHJldHVybnMge0VsZW1SZW1vdmVMaXN0ZW5lcnN9IEZ1bmN0aW9uIHRoYXQgdGFrZXMgb3B0aW9uYWwgZXZlbnQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oXG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnLFxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcbiAgICogKTtcbiAgICogZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdjbGljaycpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScsICdpbnB1dCcpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICovXG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChpc1N0cmluZyhldmVudCkpIHtcbiAgICAgIGV2ZW50ID0geyBbZXZlbnRdOiBsaXN0ZW5lciB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0V2ZW50cyA9IHt9O1xuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IHt9O1xuXG4gICAgaXRlcmF0ZU9iamVjdChldmVudCwgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAobmV3RXZlbnRzW2V2ZW50XSA9IG5ld0V2ZW50c1tldmVudF0gfHwgW10pLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3RXZlbnRzLCAobGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICBpdGVyYXRlQXJyYXkobGlzdGVuZXJzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgKGFsbExpc3RlbmVyc1tldmVudF0gPSBhbGxMaXN0ZW5lcnNbZXZlbnRdIHx8IFtdKS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkoZXZlbnQuc3BsaXQoRVZFTlRfU0VQQVJBVE9SX1JFR0VYKSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuXG4gICAgICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGFsbExpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZU9iamVjdChhbGxMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcnMsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHJlbW92ZUxpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcblxuICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB3cmFwIG9mIHRoZSBzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICovXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZFBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3ByZXZcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5wcmV2KCk7IC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICovXG4gIHByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGRQcmV2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcHJvcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCAqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBhc3NpZ25lZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cbiAgICogQHJldHVybnMge0VsZW18Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3Mgc2V0dGVyIG9yIGEgdmFsdWUgaWYgZ2V0dGVyLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgaXMgZWl0aGVyIGEgcHJvcGVydHkgZ2V0dGVyIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIG9yIGEgc2V0dGVyIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJywgZmFsc2UpO1xuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScpOyAvLyBmYWxzZVxuICAgKi9cbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3ApID0+IHtcbiAgICAgICAgZWxlbVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGZyb20gdGhlIGRvY3VtZW50LlxuICAgKiBOb3RlOiBpdCBkb2Vzbid0IHJlbW92ZSB0aGVtIGZyb20gdGhlIHNldCBzbyB3YXRjaCBvdXQgZm9yIHRoZSBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlKCk7XG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChyZW1vdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVBdHRyKC4uLmF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkoYXR0cmlidXRlcywgKGF0dHIpID0+IHtcbiAgICAgICAgY29uc3QgeyBucyB9ID0gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlTlMobnMsIGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGNsYXNzZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4gbGlzdC5yZW1vdmUoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNTU1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBwcm9wcyAtIENTUyBwcm9wZXJ0aWVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBDU1MgcHJvcGVydGllcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVDU1MoJ2Rpc3BsYXknLCAncG9zaXRpb24nLCAnbWFyZ2luJyk7XG4gICAqL1xuICByZW1vdmVDU1MoLi4ucHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkocHJvcHMsIChjc3MpID0+IHtcbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0b0h5cGhlbkNhc2UoY3NzKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVwbGFjZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byByZXBsYWNlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogd2l0aCBhIHNldCBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50IChFbGVtZW50IG9yIEVsZW0pLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjcmVwbGFjZUNoaWxkXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9yZXBsYWNlQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlcGxhY2UoZWxlbTIpO1xuICAgKiBlbGVtLnJlcGxhY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLnJlcGxhY2UoJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIHJlcGxhY2UoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCk7XG5cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZWxlbSgwKTtcbiAgICBjb25zdCBwYXJlbnQgPSBmaXJzdC5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGVsZW0gPSBwYXJlbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdpbnRvJztcbiAgICBjb25zdCBuZXh0ID0gZmlyc3QubmV4dCgpWzBdO1xuICAgIGNvbnN0IHByZXYgPSBmaXJzdC5wcmV2KClbMF07XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgZWxlbSA9IG5leHQ7XG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QmVmb3JlJztcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsZW0gPSBwcmV2O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEFmdGVyJztcbiAgICB9XG5cbiAgICBmaXJzdC5yZW1vdmUoKTtcblxuICAgIGVsZW1lbnRbbWV0aG9kXShlbGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jc2hvd1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTaG93cyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICogSWYgYW4gZWxlbWVudCB3YXMgaGlkZGVuIHVzaW5nIHtAbGluayBFbGVtI2hpZGV9IHByZXZpb3VzIGRpc3BsYXkgaXMgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnNob3coKTtcbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChzaG93KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jc2xpY2VcbiAgICogQHB1YmxpY1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHNhbWUgYXMgQXJyYXkjc2xpY2UgYnV0IGZvciBFbGVtLlxuICAgKi9cbiAgc2xpY2UoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHN1cGVyLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0ZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW3RleHRdIC0gVGV4dCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgdGV4dC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHRleHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyB0ZXh0cyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIHRleHQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgdGV4dC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50ZXh0KCcxMjMnKTtcbiAgICogZWxlbS50ZXh0KCk7IC8vICcxMjMnXG4gICAqL1xuICB0ZXh0KHRleHQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AoJ3RleHRDb250ZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgYXR0cmlidXRlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFlbGVtLmhhc0F0dHIoYXR0cikgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdG9nZ2xlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gQ2xhc3MgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgY2xhc3NcbiAgICogYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgY2xhc3MuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXG4gICAqIHRoZSBjbGFzcyBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGNsYXNzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLnRvZ2dsZUNsYXNzKCdjbHMnLCBzb21lQ29uZGl0aW9uKTtcbiAgICovXG4gIHRvZ2dsZUNsYXNzKGNscywgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW07XG5cbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIWNsYXNzTGlzdC5jb250YWlucyhjbHMpIDogY29uZGl0aW9uKSB7XG4gICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhFbGVtLCAnRWxlbScpO1xuc2V0U3ltYm9sU3BlY2llcyhFbGVtLCBBcnJheSk7XG5cbmV4cG9ydCB7IEVsZW0gfTtcbiIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTeW1ib2xTcGVjaWVzKGtsYXNzLCBzcGVjaWVzKSB7XG4gIGlmIChTeW1ib2wuc3BlY2llcykge1xuICAgIGRlZmluZVByb3BlcnRpZXMoa2xhc3MsIHtcbiAgICAgIFtTeW1ib2wuc3BlY2llc106IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuY2xhc3MgSW50ZXJuYWxNaXhpbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBhc3NpZ24odGhpcywgb3B0cyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgSW50ZXJuYWxNaXhpbiB9O1xuIiwiaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcywgZ2V0UHJvdG8sXG4gIHJlbW92ZUFycmF5RWxlbSwgc2V0VG9TdHJpbmdUYWdcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB3cmFwTWl4aW4sIHJlbW92ZVdhdGNoZXJzIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcblxuY29uc3QgdG9TdHJpbmdUYWcgPSAnW29iamVjdCBNaXhpbl0nO1xuXG4vKipcbiAqIEBjbGFzcyBNaXhpblxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBNaXhpbiBvcHRpb25zLlxuICogQHJldHVybnMge01peGlufSBJbnN0YW5jZSBvZiBNaXhpbi5cbiAqL1xuY2xhc3MgTWl4aW4ge1xuICAvKipcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gW01peGluLmV2YWx1YXRlID0gdHJ1ZV1cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSBtaXhpbiB2YWx1ZSBzaG91bGQgYmUgZXZhbHVhdGVkIGFuZCB3YXRjaGVkIG9yIG5vdC5cbiAgICovXG4gIHN0YXRpYyBldmFsdWF0ZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTWl4aW4ud3JhcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uV3JhcHBlcn0gd3JhcHBlcnMgLSBGdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCBtaXhpbi5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbn0gTmV3IG1peGluLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3cmFwcGluZyBtaXhpbnMuXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBtaXhpbiB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKC4uLndyYXBwZXJzKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJzLnJlZHVjZSh3cmFwTWl4aW4sIHRoaXMpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsLFxuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3Qgd2F0Y2hlcnMgPSBbXTtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yIH0gPSBnZXRQcm90byh0aGlzKTtcbiAgICBjb25zdCBuYW1lID0gY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZTtcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IE1peGluIyQkXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gTWl4aW4jJCQuZXZhbHVhdGUgLSBFdmFsdWF0ZSBmdW5jdGlvbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gTWl4aW4jJCQuaXNSZW1vdmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbW92ZWQuXG4gICAgICAgKiBAcHJvcGVydHkge0ludGVybmFsTWl4aW59IE1peGluIyQkLmludGVybmFsIC0gQ3VycmVudCBpbnRlcm5hbCBtaXhpbiBpbnN0YW5jZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7SW50ZXJuYWxNaXhpbltdfSBNaXhpbiMkJC5pbnRlcm5hbHMgLSBBcnJheSBvZiBpbnRlcm5hbCBtaXhpbnMgYm91bmQgdG8gdGhlIHRoZSBtaXhpbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBNaXhpbiMkJC5uYW1lIC0gTWl4aW4gbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gTWl4aW4jJCQucGFyZW50QmxvY2sgLSBQYXJlbnQgYmxvY2suXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IE1peGluIyQkLnBhcmVudFNjb3BlIC0gUGFyZW50IHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBNaXhpbiMkJC5wYXJlbnRUZW1wbGF0ZSAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7Kn0gTWl4aW4jJCQudmFsdWUgLSBDdXJyZW50IHZhbHVlLlxuICAgICAgICogQHByb3BlcnR5IHtXYXRjaGVyW119IEJsb2NrIyQkLndhdGNoZXJzIC0gVGVtcG9yYXJ5IHZhcnMgd2F0Y2hlcnMuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBCbG9jayMkJC53YXRjaGVyc1RvUmVtb3ZlIC0gV2F0Y2hlcnMgdG8gcmVtb3ZlIGJlZm9yZSByZW1vdmluZyBtaXhpbi5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaW50ZXJuYWwsXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIHdhdGNoZXJzLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBpc1JlbW92ZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY29uc3RydWN0b3IuZXZhbHVhdGVcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoaW50ZXJuYWwudmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoaXNQYXJlbnRTaWduYWwpID0+IHtcbiAgICAgICAgICBpc1BhcmVudFNpZ25hbCA9ICEhaXNQYXJlbnRTaWduYWw7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoaXNQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5taXhpbnMsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IFtNaXhpbiNhcmdzXVxuICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5hcmdzID0gYXJncztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jsb2NrfSBbTWl4aW4jcGFyZW50U2NvcGVdXG4gICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudFRlbXBsYXRlXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbX0gTWl4aW4jZWxlbVxuICAgICAqIEB0eXBlIHtFbGVtfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gTWl4aW4jbm9kZVxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGUgPSBlbGVtWzBdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBbTWl4aW4jbmFtZV1cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnB1c2godGhpcyk7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTWl4aW4jYmVmb3JlUmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0VsZW1lbnRSZW1vdmVkIC0gSWYgZWxlbWVudCByZW1vdmVkIGFzIHdlbGwuXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYmVmb3JlIHRoZSBtaXhpbiByZW1vdmFsLlxuICAgKi9cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IFtjYWxsYmFja10gLSBJZiBwcmVzZW50LCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgbWl4aW4gdmFsdWUgaXMgY2hhbmdlZC5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIHRoZSBtaXhpbiB2YWx1ZSBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZShjYWxsYmFjayk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWc7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoTWl4aW4sICdNaXhpbicpO1xuXG5leHBvcnQgeyBNaXhpbiB9O1xuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQge1xuICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzLFxuICBhc3NpZ24sIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCxcbiAgaXNGdW5jdGlvbiwgc2V0VG9TdHJpbmdUYWcsXG4gIHJlbW92ZUFycmF5RWxlbSwgY3JlYXRlLFxuICBnZXRQcm90bywgc2V0UHJvdG9cbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge1xuICBub3JtYWxpemVBcmdzLCByZW1vdmVXYXRjaGVycywgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCxcbiAgY2xlYW5Qcm9wZXJ0eSwgSW50ZXJuYWxNaXhpbiwgY2FsY3VsYXRlQXJncyxcbiAgd3JhcEJsb2NrLCBnZXREZWZhdWx0QXJncywgaXNJbnN0YW5jZU9mXG59IGZyb20gJy4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBibG9ja3MsIG1peGlucyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi9NaXhpbic7XG5cbi8qKlxuICogQHR5cGVkZWYge0Jsb2NrTm9kZVtdfSBUZW1wbGF0ZVxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gdmFycyAtIFRlbXBsYXRlIHVzZWQgdmFycy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJsb2NrTm9kZVxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtTdHJpbmd8dHlwZW9mIEJsb2NrfSB0eXBlIC0gQmxvY2sgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYXJnc10gLSBCbG9jayBhcmdzLlxuICogQHByb3BlcnR5IHtCbG9ja05vZGVbXX0gY2hpbGRyZW4gLSBCbG9jayBjaGlsZHJlbi5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWUgLSBUZXh0IG9yIGNvbW1lbnQgbm9kZSB2YWx1ZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFcnJvcn0gRXZhbHVhdGlvbkVycm9yXG4gKiBAcHVibGljXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gd2hpY2ggY2F1c2VkIGV2YWwgZXJyb3IuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gb3JpZ2luYWwgLSBFdmFsdWF0ZWQgZXhwcmVzc2lvbiBvcmlnaW5hbCBqcy5cbiAqIEBwcm9wZXJ0eSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgaW4gY29udGV4dCBvZiB3aGljaCB0aGUgZXhwcmVzc2lvbiBoYXMgYmVlbiBldmFsdWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2F0Y2hlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV3JhcHBlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHt0eXBlb2YgQmxvY2t8dHlwZW9mIE1peGlufSBCbG9jayBjbGFzcyB0byB3cmFwLlxuICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IEJsb2NrIGNsYXNzLlxuICovXG5cbmNvbnN0IHRvU3RyaW5nVGFnID0gJ1tvYmplY3QgQmxvY2tdJztcbmNvbnN0IGFmdGVyRWxlbSA9IG5ldyBFbGVtKCk7XG5jb25zdCBlbXB0eU9iamVjdCA9IHt9O1xubGV0IGV2YWxNb2RlID0gZmFsc2U7XG5sZXQgZ2V0dGluZ1ZhcnMgPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgQmxvY2tcbiAqIEBleHRlbmRzIG51bGxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQmxvY2sgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtCbG9ja30gSW5zdGFuY2Ugb2YgQmxvY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEJsb2NrLCBpbml0QXBwIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiBjbGFzcyBBcHAgZXh0ZW5kcyBCbG9jayB7XG4gKiAgIHN0YXRpYyBodG1sID0gaHRtbGA8SGVsbG8gdGV4dD1cInt0ZXh0fVwiLz4gKHsgdGhpcy50aW1lcyB9KWA7XG4gKlxuICogICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gKiAgICAgc3VwZXIob3B0cyk7XG4gKlxuICogICAgIHRoaXMudGV4dCA9ICd3b3JsZCc7XG4gKiAgICAgdGhpcy50aW1lcyA9IDA7XG4gKlxuICogICAgIHRoaXMuc2V0SW50ZXJ2YWwoKTtcbiAqICAgfVxuICpcbiAqICAgc2V0SW50ZXJ2YWwoKSB7XG4gKiAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAqICAgICAgIHRoaXMudGltZXMrKztcbiAqICAgICB9KTtcbiAqICAgfVxuICpcbiAqICAgYmVmb3JlUmVtb3ZlKCkge1xuICogICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBCbG9jay5ibG9jaygnQXBwJywgQXBwKTtcbiAqIEJsb2NrLmJsb2NrKCdIZWxsbycsIGh0bWxgSGVsbG8sIHthcmdzLnRleHR9IWApO1xuICpcbiAqIGluaXRBcHAoJ0FwcCcsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykpO1xuICovXG5jbGFzcyBCbG9jayB7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay5hcmdzID0gbnVsbF1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgYXJncyBkZXNjcmlwdGlvbi5cbiAgICovXG4gIHN0YXRpYyBhcmdzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2suZGVmYXVsdExvY2FscyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRlZmF1bHQgbG9jYWxzLlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRMb2NhbHMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IFtCbG9jay5kaXNwbGF5TmFtZSA9IG51bGxdXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRpc3BsYXkgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBkaXNwbGF5TmFtZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge1RlbXBsYXRlfSBbQmxvY2suaHRtbCA9IFtdXVxuICAgKiBAdHlwZSB7VGVtcGxhdGV9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIHRlbXBsYXRlLlxuICAgKi9cbiAgc3RhdGljIGh0bWwgPSBbXTtcblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5vbkV2YWxFcnJvclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RXZhbHVhdGlvbkVycm9yfSBlcnIgLSBUaGUgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGFuIGV2YWx1YXRpb24gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgc3RhdGljIG9uRXZhbEVycm9yKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEV2YWwgZXJyb3IgKGV2YWx1YXRpbmcgXCIkeyBlcnIub3JpZ2luYWwgfHwgZXJyLmZ1bmMgfVwiIGluIGNvbnRleHQgb2YgJHsgZXJyLmJsb2NrLiQkLm5hbWUgfSk6YCwgZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLndyYXBcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLldyYXBwZXJ9IHdyYXBwZXJzIC0gRnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgYmxvY2suXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t9IE5ldyBibG9jay5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd3JhcHBpbmcgYmxvY2tzIGludG8gYW5vdGhlciBibG9ja3MuXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBibG9jayB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKC4uLndyYXBwZXJzKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJzLnJlZHVjZSh3cmFwQmxvY2ssIHRoaXMpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3M6IG9yaWdpbmFsQXJncyxcbiAgICAgIER5bmFtaWNCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBwcmV2QmxvY2tcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gW107XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvciB9ID0gZ2V0UHJvdG8odGhpcyk7XG4gICAgY29uc3QgbmFtZSA9IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG4gICAgY29uc3QgY2hpbGRyZW5CbG9ja3MgPSBbXTtcbiAgICBjb25zdCBjaGlsZHJlbk1peGlucyA9IFtdO1xuICAgIGNvbnN0IGlzUGFyZW50QmxvY2sgPSBwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaztcbiAgICBjb25zdCBpc0VsZW1lbnRzID0gY29uc3RydWN0b3IgPT09IGJsb2Nrcy5FbGVtZW50cztcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrIyQkXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IEJsb2NrIyQkLmFyZ3MgLSBQcml2YXRlIGFyZ3Mgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrW119IEJsb2NrIyQkLmNoaWxkcmVuIC0gQ2hpbGQgYmxvY2tzLlxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBCbG9jayMkJC5jb250ZW50IC0gQ29udGVudCBlbGVtZW50cy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fHZvaWR9IEJsb2NrIyQkLkR5bmFtaWNCbG9ja0FyZ3MgLSBEeW5hbWljQmxvY2sgYXJncy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IEJsb2NrIyQkLmV2YWx1YXRlIC0gRXZhbHVhdGUgZnVuY3Rpb24uXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQuZ2xvYmFscyAtIFByaXZhdGUgZ2xvYmFscyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IEJsb2NrIyQkLmh0bWxDaGlsZHJlbiAtIEJsb2NrIGh0bWwgY2hpbGRyZW4uXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IEJsb2NrIyQkLmlzUmVtb3ZlZCAtIElmIHRoZSBibG9jayBpcyByZW1vdmVkLlxuICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBCbG9jayMkJC5pc1JlbmRlcmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbmRlcmVkLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IEJsb2NrIyQkLmxvY2FscyAtIFByaXZhdGUgbG9jYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtNaXhpbltdfSBCbG9jayMkJC5taXhpbnMgLSBDaGlsZCBtaXhpbnMuXG4gICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9uW119IEJsb2NrIyQkLm1peGluc1RvQnVpbGQgLSBQZW5kaW5nIG1peGlucyBidWlsZGVycy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBCbG9jayMkJC5uYW1lIC0gQmxvY2sgbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7dHlwZW9mIEJsb2NrfSBCbG9jayMkJC5Db25zdHJ1Y3RvciAtIEJsb2NrIGNvbnN0cnVjdG9yLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3xFbGVtfHZvaWR9IEJsb2NrIyQkLnBhcmVudCAtIFBhcmVudCBibG9jayBvciBlbGVtLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBCbG9jayMkJC5wYXJlbnRCbG9jayAtIFBhcmVudCBibG9jay5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gcGFyZW50RWxlbSAtIFBhcmVudCBlbGVtZW50LlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3x2b2lkfSBCbG9jayMkJC5wYXJlbnRTY29wZSAtIFBhcmVudCBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gQmxvY2sjJCQucGFyZW50VGVtcGxhdGUgLSBQYXJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfEVsZW18dm9pZH0gQmxvY2sjJCQucHJldkJsb2NrIC0gUGFyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHByb3BlcnR5IHtXYXRjaGVyW119IEJsb2NrIyQkLndhdGNoZXJzIC0gVGVtcG9yYXJ5IHZhcnMgd2F0Y2hlcnMuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBCbG9jayMkJC53YXRjaGVyc1RvUmVtb3ZlIC0gV2F0Y2hlcnMgdG8gcmVtb3ZlIGJlZm9yZSByZW1vdmluZyB0aGUgYmxvY2suXG4gICAgICAgKi9cbiAgICAgICQkOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIER5bmFtaWNCbG9ja0FyZ3MsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgY29udGVudDogbmV3IEVsZW0oKSxcbiAgICAgICAgQ29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuICAgICAgICBodG1sQ2hpbGRyZW46IGNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5CbG9ja3MsXG4gICAgICAgIG1peGluczogY2hpbGRyZW5NaXhpbnMsXG4gICAgICAgIG1peGluc1RvQnVpbGQ6IFtdLFxuICAgICAgICBwcmV2QmxvY2ssXG4gICAgICAgIHdhdGNoZXJzVG9SZW1vdmUsXG4gICAgICAgIGlzUmVtb3ZlZDogZmFsc2UsXG4gICAgICAgIGlzUmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKGZ1bmMsIG9uQ2hhbmdlLCB0YXJnZXRCbG9jaywgZm9yRWxlbWVudHMsIGZvckl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvckVsZW1lbnRzID0gISFmb3JFbGVtZW50cztcblxuICAgICAgICAgIGNvbnN0IHNjb3BlID0gY29uc3RydWN0b3IgPT09IGJsb2Nrcy5JdGVtICYmICFmb3JJdGVtXG4gICAgICAgICAgICA/IHRoaXMuJCQuc2NvcGVcbiAgICAgICAgICAgIDogdGhpcztcbiAgICAgICAgICBjb25zdCB7IHdhdGNoZXJzVG9SZW1vdmUgfSA9IHRhcmdldEJsb2NrID8gdGFyZ2V0QmxvY2suJCQgOiBlbXB0eU9iamVjdDtcbiAgICAgICAgICBjb25zdCBvbkNoYW5nZUZsYWcgPSAhIW9uQ2hhbmdlO1xuXG4gICAgICAgICAgY29uc3QgZXZhbHVhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2VGbGFnKSB7XG4gICAgICAgICAgICAgIGV2YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZ2V0dGluZ1ZhcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhzY29wZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyLmZ1bmMgPSBmdW5jO1xuICAgICAgICAgICAgICBlcnIub3JpZ2luYWwgPSBmdW5jLm9yaWdpbmFsO1xuICAgICAgICAgICAgICBlcnIuYmxvY2sgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5vbkV2YWxFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfS5vbkV2YWxFcnJvcjpgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlRmxhZykge1xuICAgICAgICAgICAgICBjb25zdCBsb2NhbFdhdGNoZXJzID0gW107XG5cbiAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KGdldHRpbmdWYXJzLCAod2F0Y2hlcnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KGxvY2FsV2F0Y2hlcnMsICh3YXRjaGVyQmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgfSA9IHdhdGNoZXJCbG9jaztcblxuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnNUb1JlbW92ZSwgd2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHdhdGNoZXJzLCB3YXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZXN1bHQgPSBldmFsdWF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3UmVzdWx0ICE9PSByZXN1bHQgJiYgIXRhcmdldEJsb2NrLiQkLmlzUmVtb3ZlZCAmJiAhdGhpcy4kJC5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3UmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlckJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgZm9yRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbG9jYWxXYXRjaGVycy5wdXNoKHdhdGNoZXJCbG9jayk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZS5wdXNoKHdhdGNoZXJCbG9jayk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZ2V0dGluZ1ZhcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKGlzUGFyZW50U2lnbmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICBpdGVyYXRlQXJyYXkoY2hpbGRyZW5CbG9ja3MsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbk1peGlucywgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KHRoaXMuJCQuY29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBwYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLCB0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQucmVtb3ZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZUNvbnRlbnQ6IChuZXdDb250ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5jb250ZW50ID0gbmV3Q29udGVudDtcblxuICAgICAgICAgIGlmICh0aGlzLiQkLmlzUmVuZGVyZWQgJiYgIXRoaXMuJCQuaXNSZW1vdmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLmFmdGVyRE9NQ2hhbmdlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyRE9NQ2hhbmdlOmAsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRDb250ZW50OiAoY29udGVudFRvQWRkLCBub3RSZWN1cnNpdmUpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGRDb250ZW50ID0gdGhpcy4kJC5jb250ZW50O1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gb2xkQ29udGVudC5pbmRleE9mKGNvbnRlbnRUb0FkZFswXS5wcmV2aW91c1NpYmxpbmcpICsgMTtcbiAgICAgICAgICBsZXQgbmV3Q29udGVudDtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IGNvbnRlbnRUb0FkZC5hZGQob2xkQ29udGVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBvbGRDb250ZW50XG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleClcbiAgICAgICAgICAgICAgLmFkZChjb250ZW50VG9BZGQsIG9sZENvbnRlbnQuc2xpY2UoaW5kZXgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQobmV3Q29udGVudCk7XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiAhbm90UmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9BZGQsIG5vdFJlY3Vyc2l2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlQ29udGVudDogKGNvbnRlbnRUb01vdmUsIGFmdGVyKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkQ29udGVudCA9IHRoaXMuJCQuY29udGVudDtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9sZENvbnRlbnQuaW5kZXhPZihjb250ZW50VG9Nb3ZlWzBdKTtcbiAgICAgICAgICBjb25zdCBpbmRleFRvUHV0ID0gb2xkQ29udGVudC5pbmRleE9mKGFmdGVyWzBdKSArIDE7XG4gICAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXhUb1B1dCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IGNvbnRlbnRUb01vdmUuYWRkKFxuICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4VG9QdXQsIGluZGV4KSxcbiAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4VG9QdXQpXG4gICAgICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICAgICAgY29udGVudFRvTW92ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4VG9QdXQsIGluZGV4KSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBvbGRDb250ZW50XG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleClcbiAgICAgICAgICAgICAgLmFkZChcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgsIGluZGV4VG9QdXQpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUb01vdmUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudC5zbGljZShpbmRleFRvUHV0KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudChuZXdDb250ZW50KTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmIGluZGV4VG9QdXQpIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9Nb3ZlLCBhZnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDb250ZW50OiAoY29udGVudFRvUmVtb3ZlKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KHRoaXMuJCQuY29udGVudC5maWx0ZXIoKGVsZW0pID0+IChcbiAgICAgICAgICAgIGNvbnRlbnRUb1JlbW92ZS5pbmRleE9mKGVsZW0pID09PSAtMVxuICAgICAgICAgICkpKTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50VG9SZW1vdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0SW5TdGFydE9mSXQ6IChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgbGV0IGFmdGVyID0gYWZ0ZXJFbGVtO1xuXG4gICAgICAgICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHBhcmVudC4kJDtcblxuICAgICAgICAgICAgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgICBsZXQgbm90UmVjdXJzaXZlO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgICAgICAgbm90UmVjdXJzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgICAgICBub3RSZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIG5vdFJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50LiQkLmluc2VydEluU3RhcnRPZkl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICB0aGlzLiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEFmdGVySXQ6IChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgbGV0IGFmdGVyID0gYWZ0ZXJFbGVtO1xuICAgICAgICAgIGxldCB0cnlUb0FkZE9yTW92ZTtcblxuICAgICAgICAgIGlmICh0aGlzLiQkLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuJCQuY29udGVudC5lbGVtKC0xKTtcbiAgICAgICAgICAgIHRyeVRvQWRkT3JNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihhZnRlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICB0cnlUb0FkZE9yTW92ZSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50LiQkLmluc2VydEluU3RhcnRPZkl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50VG9JbnNlcnQuaW50byhwYXJlbnRFbGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgdHJ5VG9BZGRPck1vdmUpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZnRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXRlcmF0ZU9iamVjdChjb25zdHJ1Y3Rvci5kZWZhdWx0TG9jYWxzLCAodmFsdWUsIHZhcmlhYmxlKSA9PiB7XG4gICAgICB0aGlzW3ZhcmlhYmxlXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGl0ZXJhdGVBcnJheShjb25zdHJ1Y3Rvci5odG1sLnZhcnMgfHwgW10sICh2YXJpYWJsZSkgPT4ge1xuICAgICAgdGhpc1t2YXJpYWJsZV0gPSB0aGlzW3ZhcmlhYmxlXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczogYXJnc0Rlc2NyaXB0aW9uc1xuICAgIH0gPSBjb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBkZWZhdWx0QXJncyA9IGdldERlZmF1bHRBcmdzKGFyZ3NEZXNjcmlwdGlvbnMpO1xuICAgIGxldCBhcmdzID0gY3JlYXRlKGRlZmF1bHRBcmdzKTtcbiAgICBsZXQgd2FzUmVzdDtcbiAgICBjb25zdCBhcmdzQ2hhaW4gPSBbZGVmYXVsdEFyZ3MsIGFyZ3NdO1xuXG4gICAgaXRlcmF0ZU9iamVjdChvcmlnaW5hbEFyZ3MsICh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgICBjb25zdCBpc1Jlc3QgPSB2YWx1ZS5taXhpbiA9PT0gbWl4aW5zLlJlc3Q7XG4gICAgICBjb25zdCBsb2NhbEFyZ3MgPSBpc1Jlc3QgfHwgd2FzUmVzdFxuICAgICAgICA/IGNyZWF0ZShhcmdzKVxuICAgICAgICA6IGFyZ3M7XG5cbiAgICAgIGlmIChhcmdzICE9PSBsb2NhbEFyZ3MpIHtcbiAgICAgICAgYXJnc0NoYWluLnB1c2gobG9jYWxBcmdzKTtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IGxvY2FsQXJncztcblxuICAgICAgaWYgKGlzUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXJncyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXJncywgY2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgYXNzaWduKGxvY2FsQXJncywgdmFsdWUpO1xuICAgICAgICAgIGNhbGN1bGF0ZUFyZ3Mobm9ybWFsaXplQXJncyhhcmdzQ2hhaW4pLCBhcmdzLCBhcmdzT2JqZWN0KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgd2FzUmVzdCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbihsb2NhbEFyZ3MsIHJlc3RBcmdzKTtcbiAgICAgIH1cblxuICAgICAgd2FzUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNJbnN0YW5jZU9mKE1peGluLCB2YWx1ZS5taXhpbikpIHtcbiAgICAgICAgbG9jYWxBcmdzW2FyZ10gPSBuZXcgSW50ZXJuYWxNaXhpbih7XG4gICAgICAgICAgTWl4aW46IHZhbHVlLm1peGluLFxuICAgICAgICAgIGFyZ3M6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JFbGVtZW50cyA9IGlzRWxlbWVudHMgJiYgYXJnID09PSAndmFsdWUnO1xuXG4gICAgICBsb2NhbEFyZ3NbYXJnXSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgbG9jYWxBcmdzW2FyZ10gPSB2YWx1ZTtcbiAgICAgICAgY2FsY3VsYXRlQXJncyhub3JtYWxpemVBcmdzKGFyZ3NDaGFpbiksIGFyZ3MsIGFyZ3NPYmplY3QpO1xuICAgICAgfSwgdGhpcywgZm9yRWxlbWVudHMsIGlzRWxlbWVudHMgJiYgcGFyZW50QmxvY2suJCQuQ29uc3RydWN0b3IgPT09IGJsb2Nrcy5JdGVtKTtcbiAgICB9KTtcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrI2FyZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGFyZ3M6IGFyZ3NPYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNnbG9iYWxzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBnbG9iYWxzOiBjcmVhdGUoXG4gICAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgICAgPyBwYXJlbnRTY29wZS5nbG9iYWxzXG4gICAgICAgICAgOiBudWxsXG4gICAgICApXG4gICAgfSk7XG5cbiAgICBjYWxjdWxhdGVBcmdzKG5vcm1hbGl6ZUFyZ3MoYXJnc0NoYWluKSwgYXJncywgYXJnc09iamVjdCk7XG5cbiAgICBpZiAocGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3RcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGNvbnN0cnVjdGlvbiAoaW5jbHVkaW5nIGFsbCBzY29wZXMpXG4gICAqIGJ1dCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBibG9jayBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyRE9NQ2hhbmdlXG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBET00gc3RydWN0dXJlIGhhcyBjaGFuZ2VkLiBOb3RlIHRoYXRcbiAgICogaXQncyBpbXBvcnRhbnQgbm90IHRvIG1vZGlmeSB0aGUgRE9NIHN0cnVjdHVyZSB3aXRoaW4gdGhlIGJsb2NrLiBZb3UgY2FuIG9ubHkgaW5zZXJ0XG4gICAqIGVsZW1lbnRzIHRvIGVtcHR5IGVsZW1lbnRzICh3aGljaCBEd2F5bmUgY29uc2lkZXJzIGVtcHR5KSBhbmQgcmVtb3ZlIG9uZXMgZnJvbSB0aGVtLlxuICAgKi9cbiAgYWZ0ZXJET01DaGFuZ2UoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyUmVuZGVyXG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICovXG4gIGFmdGVyUmVuZGVyKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNiZWZvcmVSZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGJlZm9yZSB0aGUgYmxvY2sgcmVtb3ZhbC5cbiAgICovXG4gIGJlZm9yZVJlbW92ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0RE9NXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIERPTSBjb250ZW50cyBvZiB0aGUgYmxvY2suXG4gICAqL1xuICBnZXRET00oKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuY29udGVudC5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0TmFtZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIEJsb2NrIG5hbWUuXG4gICAqL1xuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiQkLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRFbGVtXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW18dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgcGFyZW50IEVsZW0uXG4gICAqL1xuICBnZXRQYXJlbnRFbGVtKCkge1xuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudEVsZW0uc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldFBhcmVudFNjb3BlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Jsb2NrfHZvaWR9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGJsb2NrIGluIHdoaWNoIHRlbXBsYXRlIHRoZSBibG9jayBpcyBsb2NhdGVkIGluLlxuICAgKi9cbiAgZ2V0UGFyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50U2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRUZW1wbGF0ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBibG9jayBpbiB3aGljaCB0ZW1wbGF0ZSB0aGUgYmxvY2sgaXMgbG9jYXRlZCBpbi5cbiAgICovXG4gIGdldFBhcmVudFRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gW2NhbGxiYWNrXSAtIElmIHByZXNlbnQsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7QmxvY2t8TWl4aW59IFt0YXJnZXQgPSB0aGlzXSAtIFdoYXQgYmxvY2sgb3IgbWl4aW4gcmVxdWVzdHMgdGhlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGlvbiByZXN1bHQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiBpbiBjb250ZXh0IG9mIHRoZSBibG9jayBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCA9IHRoaXMpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZShmdW5jLCBjYWxsYmFjaywgdGFyZ2V0KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZztcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhCbG9jaywgJ0Jsb2NrJyk7XG5zZXRQcm90byhCbG9jay5wcm90b3R5cGUsIG51bGwpO1xuXG5leHBvcnQgeyBCbG9jaywgZ2V0dGluZ1ZhcnMsIGV2YWxNb2RlIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcblxuY2xhc3MgQ2FzZSBleHRlbmRzIEJsb2NrIHt9XG5cbmV4cG9ydCB7IENhc2UgfTtcbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgcmVtb3ZlQXJyYXlFbGVtIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCwgY3JlYXRlQmxvY2sgfSBmcm9tICcuLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgYmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgYXJncy52YWx1ZWA7XG5cbmNsYXNzIEVsZW1lbnRzIGV4dGVuZHMgQmxvY2sge1xuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICBjb25zdCB7IHBhcmVudEVsZW0gfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICB0aGlzLiQkLmV2YWx1YXRlKHdhdGNoQXJncywgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtaXhpbnMsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IHRoaXMuJCQ7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG5cbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kJC5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy4kJC5taXhpbnMgPSBbXTtcbiAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JFbGVtZW50cyB9KSA9PiB7XG4gICAgICAgIGlmIChmb3JFbGVtZW50cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHdhdGNoZXJzLCB3YXRjaGVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kJC5jb250ZW50ID0gbmV3IEVsZW0oKTtcblxuICAgICAgbGV0IHByZXZCbG9jaztcblxuICAgICAgaXRlcmF0ZUFycmF5KHZhbHVlIHx8IFtdLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZUFycmF5KHRoaXMuJCQubWl4aW5zVG9CdWlsZCwgKGV4ZWN1dGVCdWlsZGVycykgPT4ge1xuICAgICAgICBleGVjdXRlQnVpbGRlcnMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kJC5taXhpbnNUb0J1aWxkID0gW107XG4gICAgfSwgdGhpcywgdHJ1ZSk7XG4gIH1cbn1cblxuYmxvY2tzLkVsZW1lbnRzID0gRWxlbWVudHM7XG5cbmV4cG9ydCB7IEVsZW1lbnRzIH07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuL0VsZW1lbnRzJztcblxuY2xhc3MgQ2hpbGRyZW4gZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyBodG1sID0gaHRtbGBcbiAgICA8RWxlbWVudHNcbiAgICAgIHZhbHVlPVwie2VsZW1zfVwiXG4gICAgICBwYXJlbnRTY29wZT1cInskJC5wYXJlbnRUZW1wbGF0ZS4kJC5wYXJlbnRTY29wZX1cIlxuICAgICAgcGFyZW50VGVtcGxhdGU9XCJ7JCQucGFyZW50VGVtcGxhdGUuJCQucGFyZW50VGVtcGxhdGV9XCJcbiAgICAvPlxuICBgO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFRlbXBsYXRlOiB7XG4gICAgICAgICQkOiB7IGh0bWxDaGlsZHJlbiB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3QgeyBuYW1lIH0gPSB0aGlzLmFyZ3M7XG4gICAgbGV0IGZvdW5kO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGZvdW5kID0gZmluZEluQXJyYXkoaHRtbENoaWxkcmVuLCAoeyB0eXBlLCBhcmdzIH0pID0+IChcbiAgICAgICAgdHlwZSA9PT0gQ2hpbGRyZW5cbiAgICAgICAgJiYgYXJnc1xuICAgICAgICAmJiBhcmdzLm5hbWUgPT09IG5hbWVcbiAgICAgICkpO1xuXG4gICAgICB0aGlzLmVsZW1zID0gZm91bmRcbiAgICAgICAgPyBmb3VuZC52YWx1ZS5jaGlsZHJlblxuICAgICAgICA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbXMgPSBodG1sQ2hpbGRyZW47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IENoaWxkcmVuIH07XG5cbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgYmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MudHlwZWA7XG5cbmNsYXNzIER5bmFtaWNCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGh0bWwgPSBodG1sYFxuICAgIDxFbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3QoXG4gICAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgdGhpcy5jb25zdHJ1Y3QpXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdCA9ICh0eXBlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgRHluYW1pY0Jsb2NrQXJnc1xuICAgIH0gPSB0aGlzLiQkO1xuXG4gICAgdGhpcy5lbGVtcyA9IFt7XG4gICAgICB0eXBlLFxuICAgICAgYXJnczogRHluYW1pY0Jsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBodG1sQ2hpbGRyZW5cbiAgICB9XTtcbiAgfTtcbn1cblxuYmxvY2tzLkR5bmFtaWNCbG9jayA9IER5bmFtaWNCbG9jaztcblxuZXhwb3J0IHsgRHluYW1pY0Jsb2NrIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5pbXBvcnQgeyBibG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jbGFzcyBJdGVtIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgaHRtbCA9IGh0bWxgXG4gICAgPEVsZW1lbnRzXG4gICAgICB2YWx1ZT1cInskJC5odG1sQ2hpbGRyZW59XCJcbiAgICAgIHBhcmVudFNjb3BlPVwie3RoaXN9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcbn1cblxuYmxvY2tzLkl0ZW0gPSBJdGVtO1xuXG5leHBvcnQgZGVmYXVsdCBJdGVtO1xuIiwiaW1wb3J0IHtcbiAgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICBpc0FycmF5LCBpc0Z1bmN0aW9uLCBjcmVhdGVcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlLCBjcmVhdGVCbG9jayB9IGZyb20gJy4uL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL0l0ZW0nO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BbXG4gIGFyZ3Muc2V0LFxuICBhcmdzLmZpbHRlckJ5LFxuICBhcmdzLnNvcnRCeVxuXWA7XG5cbmNsYXNzIEVhY2ggZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyBhcmdzID0ge1xuICAgIHVpZDoge1xuICAgICAgZGVmYXVsdChpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3M6IHtcbiAgICAgICAgaXRlbSA9ICckaXRlbScsXG4gICAgICAgIGluZGV4ID0gJyRpbmRleCdcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcblxuICAgIHRoaXMuaXRlbU5hbWUgPSBpdGVtO1xuICAgIHRoaXMuaW5kZXhOYW1lID0gaW5kZXg7XG4gICAgdGhpcy5pdGVtc0J5VUlEcyA9IGNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGFmdGVyQ29uc3RydWN0KCkge1xuICAgIHRoaXMucmVuZGVyU2V0KFxuICAgICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsIHRoaXMucmVuZGVyU2V0KVxuICAgICk7XG4gIH1cblxuICByZW5kZXJTZXQgPSAoYXJncykgPT4ge1xuICAgIGxldCBzZXQgPSBhcmdzWzBdO1xuICAgIGxldCBmaWx0ZXJCeSA9IGFyZ3NbMV07XG4gICAgY29uc3Qgc29ydEJ5ID0gYXJnc1syXTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczoge1xuICAgICAgICB1aWQ6IFVJRFxuICAgICAgfSxcbiAgICAgIGl0ZW1zQnlVSURzLFxuICAgICAgaXRlbU5hbWUsXG4gICAgICBpbmRleE5hbWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdJdGVtc0J5VUlEcyA9IGNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBuZXdVSURzQnlJbmRleGVzID0gY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IG5ld1VJRHMgPSBjcmVhdGUobnVsbCk7XG4gICAgY29uc3QgaXNBcnIgPSBpc0FycmF5KHNldCk7XG4gICAgY29uc3QgaXRlcmF0ZSA9IGlzQXJyXG4gICAgICA/IGl0ZXJhdGVBcnJheVxuICAgICAgOiBpdGVyYXRlT2JqZWN0O1xuXG4gICAgaWYgKGlzQXJyICYmIGlzRnVuY3Rpb24oc29ydEJ5KSkge1xuICAgICAgc2V0ID0gc2V0XG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5zb3J0KHNvcnRCeSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oZmlsdGVyQnkpKSB7XG4gICAgICBmaWx0ZXJCeSA9IFtmaWx0ZXJCeV07XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoZmlsdGVyQnkpKSB7XG4gICAgICBpdGVyYXRlQXJyYXkoZmlsdGVyQnksIChmaWx0ZXIpID0+IHtcbiAgICAgICAgc2V0ID0gc2V0LmZpbHRlcihmaWx0ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZShzZXQsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdWlkID0gVUlEKGl0ZW0sIGluZGV4LCBzZXQsIHBhcmVudFNjb3BlKTtcblxuICAgICAgaWYgKHVpZCBpbiBuZXdVSURzQnlJbmRleGVzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVJRHMgY2FuJ3QgYmUgc2FtZSBmb3IgbXVsdGlwbGUgaXRlbXMhIEluIFVJRCBmdW5jdGlvbjogXCIkeyBVSUQub3JpZ2luYWwgfHwgVUlEIH1cImApO1xuICAgICAgfVxuXG4gICAgICBuZXdVSURzQnlJbmRleGVzW3VpZF0gPSBpbmRleDtcbiAgICAgIG5ld1VJRHNbaW5kZXhdID0gdWlkO1xuICAgIH0pO1xuXG4gICAgaXRlcmF0ZU9iamVjdChpdGVtc0J5VUlEcywgKGJsb2NrLCB1aWQpID0+IHtcbiAgICAgIGlmICghKHVpZCBpbiBuZXdVSURzQnlJbmRleGVzKSkge1xuICAgICAgICByZW1vdmUoYmxvY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHByZXZCbG9jaztcblxuICAgIGl0ZXJhdGUoc2V0LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHVpZCA9IG5ld1VJRHNbaW5kZXhdO1xuICAgICAgbGV0IGJsb2NrO1xuXG4gICAgICBpZiAobmV3VUlEc0J5SW5kZXhlc1t1aWRdICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZXZVSURCbG9jayA9IGl0ZW1zQnlVSURzW3VpZF07XG5cbiAgICAgIGlmIChwcmV2VUlEQmxvY2spIHtcbiAgICAgICAgYmxvY2sgPSBwcmV2VUlEQmxvY2s7XG4gICAgICAgIGJsb2NrLiQkLnNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcbiAgICAgICAgYmxvY2suJCQuc2NvcGVbaXRlbU5hbWVdID0gaXRlbTtcblxuICAgICAgICBpZiAoYmxvY2suJCQucHJldkJsb2NrICE9PSBwcmV2QmxvY2spIHtcbiAgICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IGJsb2NrLiQkO1xuXG4gICAgICAgICAgaWYgKHByZXZCbG9jaykge1xuICAgICAgICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICB0eXBlOiBJdGVtLFxuICAgICAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgICAgICBpbmRleE5hbWUsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBjaGlsZHJlbjogaHRtbENoaWxkcmVuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5ld0l0ZW1zQnlVSURzW3VpZF0gPSBibG9jaztcbiAgICAgIGJsb2NrLiQkLnByZXZCbG9jayA9IHByZXZCbG9jaztcbiAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pdGVtc0J5VUlEcyA9IG5ld0l0ZW1zQnlVSURzO1xuICB9O1xufVxuXG5leHBvcnQgeyBFYWNoIH07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MuaWZgO1xuXG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGh0bWwgPSBodG1sYFxuICAgIDxFbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5jb25kaXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0cnVjdEVsZW1zKHRoaXMuZXZhbHVhdGUod2F0Y2hBcmdzLCB0aGlzLmNvbnN0cnVjdEVsZW1zKSk7XG4gIH1cblxuICBjb25zdHJ1Y3RFbGVtcyA9IChjb25kaXRpb24pID0+IHtcbiAgICBjb25kaXRpb24gPSAhIWNvbmRpdGlvbjtcblxuICAgIGlmICh0aGlzLmNvbmRpdGlvbiAhPT0gY29uZGl0aW9uKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIHRoaXMuZWxlbXMgPSBjb25kaXRpb25cbiAgICAgICAgPyB0aGlzLiQkLmh0bWxDaGlsZHJlblxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBJZiB9O1xuIiwiaW1wb3J0IHsgZmluZEluQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9FbGVtZW50cyc7XG5pbXBvcnQgeyBDYXNlIH0gZnJvbSAnLi9DYXNlJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgW1xuICBhcmdzLnZhbHVlLFxuICBhcmdzLmNvbXBhcmVGblxuXWA7XG5cbmNsYXNzIFN3aXRjaCBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIGh0bWwgPSBodG1sYFxuICAgIDxFbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG4gIHN0YXRpYyBhcmdzID0ge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjb21wYXJlRm46IHtcbiAgICAgIGRlZmF1bHQoc3dpdGNoVmFsdWUsIGNhc2VWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHN3aXRjaFZhbHVlID09PSBjYXNlVmFsdWVcbiAgICAgICAgICB8fCAoc3dpdGNoVmFsdWUgIT09IHN3aXRjaFZhbHVlICYmIGNhc2VWYWx1ZSAhPT0gY2FzZVZhbHVlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICQkOiB7XG4gICAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgICAgcGFyZW50U2NvcGVcbiAgICAgIH0sXG4gICAgICBhcmdzOiBzd2l0Y2hBcmdzLFxuICAgICAgYXJnczogeyB2YWx1ZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHdhc0RlZmF1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMudmFsdWVzID0gaHRtbENoaWxkcmVuXG4gICAgICAuZmlsdGVyKCh7IHR5cGUsIGFyZ3MgfSkgPT4ge1xuICAgICAgICBpZiAodHlwZSAhPT0gQ2FzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3YXNEZWZhdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5kZWZhdWx0KSB7XG4gICAgICAgICAgd2FzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAubWFwKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJncyA9IHt9LFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgbGV0IHZhbDtcblxuICAgICAgICBpZiAoIWFyZ3MuZGVmYXVsdCkge1xuICAgICAgICAgIHZhbCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGFyZ3Mud2hlbiwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc1tpXS52YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZpbmRJbkFycmF5KHRoaXMudmFsdWVzLCAoeyBhcmdzLCB2YWx1ZSB9KSA9PiAoXG4gICAgICAgICAgICAgIGFyZ3MuZGVmYXVsdFxuICAgICAgICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKHN3aXRjaEFyZ3MudmFsdWUsIHZhbHVlKVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZFxuICAgICAgICAgICAgICA/IGZvdW5kLmtleVxuICAgICAgICAgICAgICA6IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kXG4gICAgICAgICAgICAgID8gZm91bmQudmFsdWUuY2hpbGRyZW5cbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5ICYmIChcbiAgICAgICAgICBhcmdzLmRlZmF1bHRcbiAgICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKHZhbHVlLCB2YWwpXG4gICAgICAgICkpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgKGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gYXJnc1swXTtcbiAgICAgIGNvbnN0IGNvbXBhcmVGbiA9IGFyZ3NbMV07XG5cbiAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcblxuICAgICAgdGhpcy52YWx1ZXMuc29tZSgoeyBhcmdzLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXJncy5kZWZhdWx0XG4gICAgICAgICAgfHwgY29tcGFyZUZuKG5ld1ZhbHVlLCB2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3dpdGNoIH07XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBub29wIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5cbmNsYXNzIEJpbmQgZXh0ZW5kcyBNaXhpbiB7XG4gIG9mZiA9IG5vb3A7XG5cbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLm9mZigpO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYgPSBub29wO1xuXG4gICAgICBjb25zb2xlLmVycm9yKCdQcm92aWRlIFwiQmluZFwiIG1peGluIHdpdGggZXZlbnQgbmFtZSBhcmdzIChsaWtlIFwiQmluZChjbGljaylcIiBvciBcIkJpbmQoa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5vZmYoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQmluZCB9O1xuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSwgaXNTdHJpbmcsXG4gIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY29uc3QgRU1QVFlfU1BBQ0VfUkVHRVggPSAvXFxzKy87XG5cbmNsYXNzIENsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICBjbGFzc2VzID0gW107XG5cbiAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNsYXNzZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdDbGFzc2VzID0gW107XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgICA/IGFyZ3NcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNwbGl0KEVNUFRZX1NQQUNFX1JFR0VYKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKGNscykgPT09IC0xKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVBcnJheShuZXdWYWx1ZSwgKGNscykgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcoY2xzKSkge1xuICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmICghbmV3VmFsdWUgfHwgIW5ld1ZhbHVlW2Nsc10pIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZU9iamVjdChuZXdWYWx1ZSwgKHZhbCwgY2xzKSA9PiB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NlcyA9IG5ld0NsYXNzZXM7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBjbGFzc2VzXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgZWxlbS5yZW1vdmVDbGFzcy5hcHBseShlbGVtLCBjbGFzc2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQ2xhc3MgfTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgRWxlbSBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJncyxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZWxlbVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBzY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGUoKTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoZWxlbSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHNjb3BlW3ZhbHVlXSA9IGVsZW07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEVsZW0gYXMgRWxlbU1peGluIH07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgSGlkZSBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgIGlmICghaXNFbGVtZW50UmVtb3ZlZCkge1xuICAgICAgdGhpcy5lbGVtLnNob3coKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgSGlkZSB9O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuXG5jbGFzcyBOb2RlIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBub2RlXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHNjb3BlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogcGFyZW50VGVtcGxhdGU7XG4gICAgICB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgc2NvcGVbdmFsdWVdID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgTm9kZSBhcyBOb2RlTWl4aW4gfTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcblxuY2xhc3MgT24gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksICgpID0+IHtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmID0gbm9vcDtcblxuICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcIk9uXCIgbWl4aW4gd2l0aCBldmVudCBuYW1lIGFyZ3MgKGxpa2UgXCJPbihjbGljaylcIiBvciBcIk9uKGtleXVwLCBrZXlwcmVzcylcIikhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKGlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICBpZiAoIWlzRWxlbWVudFJlbW92ZWQpIHtcbiAgICAgIHRoaXMub2ZmKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IE9uIH07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IG1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNsYXNzIFJlc3QgZXh0ZW5kcyBNaXhpbiB7fVxuXG5taXhpbnMuUmVzdCA9IFJlc3Q7XG5cbmV4cG9ydCB7IFJlc3QgfTtcbiIsImltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuXG5jbGFzcyBTaG93IGV4dGVuZHMgTWl4aW4ge1xuICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgaWYgKCFpc0VsZW1lbnRSZW1vdmVkKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBTaG93IH07XG4iLCJpbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcbmltcG9ydCB7IGNyZWF0ZUhpZGVTdHlsZU5vZGUgfSBmcm9tICcuL2hlbHBlcnMvRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGRvY1xuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGh0bWxcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IG5ldyBFbGVtKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBib2R5XG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmJvZHkuXG4gKi9cbmV4cG9ydCBjb25zdCBib2R5ID0gbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBoZWFkXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFkID0gbmV3IEVsZW0oZG9jdW1lbnQuaGVhZCk7XG5cbmNyZWF0ZUhpZGVTdHlsZU5vZGUoaGVhZCk7XG4iXSwibmFtZXMiOlsiY29sbGVjdEZyb21BcnJheSIsImFycmF5IiwiY2FsbGJhY2siLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZSIsImluZGV4IiwiZmluZEluQXJyYXkiLCJpIiwibGVuZ3RoIiwiaXRlcmF0ZUFycmF5IiwicmVtb3ZlQXJyYXlFbGVtIiwiZWxlbSIsImluZGV4T2YiLCJzcGxpY2UiLCJ0b09iamVjdEtleXMiLCJhZGRLZXkiLCJ2YXJzIiwidmFyaWFibGUiLCJpc0Z1bmN0aW9uIiwiaXNOaWwiLCJpc1N0cmluZyIsImFzc2lnbiIsInRhcmdldCIsImFyZ3VtZW50cyIsImtleSIsImNvbGxlY3RGcm9tT2JqZWN0Iiwib2JqZWN0IiwiZXhjZXB0IiwibmV3T2JqZWN0IiwicGF0aHMiLCJzbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzIiwiaXRlcmF0ZU9iamVjdCIsIm1hcE9iamVjdCIsImRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwibmFtZSIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lRnJvemVuUHJvcGVydGllcyIsIm5vb3AiLCJ0b0NhbWVsQ2FzZSIsInJlcGxhY2UiLCJEQVNIRURfU1lNQk9MX1JFR0VYIiwiY2FwaXRhbGl6ZSIsInRvSHlwaGVuQ2FzZSIsIlVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYIiwiaHlwaGVuaXplIiwibWF0Y2giLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsInNldFRvU3RyaW5nVGFnIiwia2xhc3MiLCJ0YWciLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJhZGRBdHRyIiwiYXR0cnMiLCJhdHRyIiwiYWRkQ1NTUHJvcCIsImNzcyIsInByb3BlcnR5Iiwic3BsaXQiLCJDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgiLCJhZGREYXRhQXR0ciIsImRhdGEiLCJhZGROZXh0IiwiYWRkIiwibmV4dFNpYmxpbmciLCJhZGRQYXJlbnQiLCJwYXJlbnROb2RlIiwiYWRkUHJldiIsInByZXZpb3VzU2libGluZyIsImNyZWF0ZUhpZGVTdHlsZU5vZGUiLCJoZWFkIiwiZmluZCIsIkhJREVfQ0xBU1MiLCJjcmVhdGUiLCJwcm9wIiwidGV4dCIsImdldEF0dHJOUyIsImlzWG1sTnMiLCJub2RlTmFtZSIsIk51bGwiLCJYTUxfTlMiLCJYX0xJTktfQVRUUl9GSU5EX1JFR0VYIiwidGVzdCIsIkVsZW0iLCJjbG9zZXN0IiwiWF9MSU5LX05TIiwiWF9MSU5LX0FUVFJfUkVQTEFDRV9SRUdFWCIsImlzRG9jdW1lbnQiLCJET0NVTUVOVF9SRUdFWCIsImlzRWxlbSIsImlzRWxlbWVudHNDb2xsZWN0aW9uIiwiSFRNTF9DT0xMRUNUSU9OX1JFR0VYIiwiaXNBcnJheSIsImlzVmFsaWROb2RlIiwiRUxFTUVOVF9SRUdFWCIsImdldEV2ZW50IiwiZXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInJlYWxEZXRhaWxzIiwiZmluYWxFdmVudCIsIkVWRU5UX1JFR0VYIiwiRXZlbnQiLCJlcnIiLCJkb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImhpZGUiLCJhZGRDbGFzcyIsImdldE1hdGNoZXNGdW5jdGlvbiIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJzZWxlY3RvciIsInRoaXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlIiwicGFyZW50IiwicmVtb3ZlQ2hpbGQiLCJzaG93IiwicmVtb3ZlQ2xhc3MiLCJ0b0VsZW0iLCJiYXNlIiwiU3RyaW5nIiwiY2FsY3VsYXRlQXJncyIsIm5vcm1hbGl6ZWRBcmdzIiwiYXJncyIsImFyZ3NPYmplY3QiLCJrZXlzIiwiYXJnIiwidW5kZWZpbmVkIiwiY2xlYW5Qcm9wZXJ0eSIsImV4ZWN1dGVNaXhpbldhdGNoZXJzIiwibWl4aW4iLCJvbGRWYWx1ZSIsIiQkIiwid2F0Y2hlcnMiLCJ3YXRjaGVyIiwiY2FsY3VsYXRlQXR0cnMiLCJuZXdBdHRycyIsImN1cnJlbnRBdHRycyIsImN1cnJlbnRNaXhpbnMiLCJwYXJlbnRCbG9jayIsImZpcnN0VGltZSIsIkludGVybmFsTWl4aW4iLCJyZW1vdmVBdHRyIiwibWl4aW5zIiwicHJldlZhbHVlIiwicGFyZW50U2NvcGUiLCJNaXhpbiIsImV2YWxGbiIsIm5ld1ZhbHVlIiwiaW50ZXJuYWwiLCJpbnRlcm5hbHMiLCJwdXNoIiwiZXZhbHVhdGUiLCJjb25zdHJ1Y3RNaXhpbldhdGNoZXIiLCJidWlsZE1peGluIiwiYWZ0ZXJVcGRhdGUiLCJlcnJvciIsImludGVybmFsTWl4aW4iLCJidWlsZGVyIiwibm9ybWFsaXplQXJncyIsImFyZ3NDaGFpbiIsIm5ld0FyZ3MiLCJjb25zdHJ1Y3RQcml2YXRlU2NvcGUiLCJ0eXBlIiwic2NvcGUiLCJnbG9iYWxzIiwicmVtb3ZlVGVtcFdhdGNoZXIiLCJyZW1vdmVXYXRjaGVycyIsIndhdGNoZXJzVG9SZW1vdmUiLCJyZW1vdmVXYXRjaGVyIiwiY29uc3RydWN0UHVibGljU2NvcGUiLCJzY29wZVZhbHVlcyIsInByaXZhdGVTY29wZSIsImV2YWxNb2RlIiwiZ2V0dGluZ1ZhcnMiLCJvbGRUZW1wV2F0Y2hlcnMiLCJpc0luc3RhbmNlT2YiLCJDbGFzcyIsIlN1YmNsYXNzIiwiaXNQcm90b3R5cGVPZiIsImNyZWF0ZUJsb2NrIiwibm9kZSIsInBhcmVudEVsZW0iLCJwYXJlbnRUZW1wbGF0ZSIsInByZXZCbG9jayIsImRvYyIsImlzRWxlbWVudHMiLCJibG9ja3MiLCJFbGVtZW50cyIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJEeW5hbWljQmxvY2tBcmdzIiwiRHluYW1pY0Jsb2NrIiwiQmxvY2siLCJodG1sIiwiRXJyb3IiLCJuYW1lc3BhY2VVUkkiLCJTVkdfTlMiLCJ3YXNSZXN0IiwiYXR0cnNDaGFpbiIsImlzUmVzdCIsIlJlc3QiLCJsb2NhbEF0dHJzIiwicmVzdEF0dHJzIiwibWl4aW5zVG9CdWlsZCIsImlzUGFyZW50QmxvY2siLCJjaGlsZEJsb2NrcyIsIm9uIiwiaXRlcmF0ZUNoaWxkcmVuIiwiaXNSb290IiwiY2hpbGQiLCJjb250ZW50IiwiaW50byIsImNvbnRlbnREb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImluc2VydEFmdGVySXQiLCJpbnNlcnRBZnRlciIsImFkZENvbnRlbnQiLCJpbnNlcnRJblN0YXJ0T2ZJdCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlbXB0eUFycmF5IiwiYmxvY2tJbnN0YW5jZSIsIkFyZ3MiLCJsb2NhbHMiLCJJdGVtIiwiaXRlbU5hbWUiLCJpdGVtIiwiaW5kZXhOYW1lIiwiQ29uc3RydWN0b3IiLCJhZnRlckNvbnN0cnVjdCIsImlzUmVuZGVyZWQiLCJleGVjdXRlQnVpbGRlcnMiLCJhZnRlclJlbmRlciIsImdldERlZmF1bHRBcmdzIiwiYXJnc0Rlc2NyaXB0aW9ucyIsImRlZiIsImRlZmF1bHQiLCJyZW1vdmVXaXRoUGFyZW50U2lnbmFsIiwid3JhcEJsb2NrIiwiYmxvY2siLCJ3cmFwcGVyIiwicmV0dXJuVmFsdWUiLCJ3cmFwTWl4aW4iLCJjb25zdHJ1Y3RTdHlsZUZyb21TdHJpbmciLCJzdHlsZSIsIkNTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgiLCJ0cmltIiwiZ2V0UHJvcCIsImhhc0F0dHIiLCJnZXRWYWx1ZUZvclNldHRpbmciLCJpbnB1dFZhbHVlIiwiaXNSYWRpbyIsImdldFZhbHVlRm9yR2V0dGluZyIsInZhbHVlcyIsIm9wdGlvbnMiLCJpbml0IiwiaXNNdWx0aXBsZSIsImFkZFZhbHVlIiwiY29uY2F0IiwiZ2V0TGlzdGVuZXJOYW1lIiwic2VsZWN0ZWQiLCJpbnNlcnRIdG1sIiwidGVtcGxhdGVzIiwibmV3VGVtcGxhdGVzIiwibmV3VmFycyIsIml0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbiIsIm5vZGVzIiwidHJpbW1lZCIsIm5ld1RlbXBsYXRlIiwiaW5pdEFwcCIsImNvbnRhaW5lciIsIlJvb3RCbG9jayIsInJvb3RCbG9jayIsInJlbW92ZUFwcCIsIkR3YXluZVJvb3RCbG9jayIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJBcnJheSIsImRlZmluZVByb3BlcnRpZXMiLCJPYmplY3QiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwic2V0UHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsInByb3RvIiwiX19wcm90b19fIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsImVtcHR5Q29sbGVjdGlvbiIsIl90aGlzIiwiaW5jbHVkZXMiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiZWxlbXMiLCJlbGVtZW50cyIsImNsYXNzZXMiLCJmb3JFYWNoIiwibGlzdCIsImNsYXNzTGlzdCIsImNscyIsImF0dHJpYnV0ZXMiLCJucyIsImdldEF0dHJpYnV0ZU5TIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZE5vZGVzIiwiY29sbGVjdCIsImlzIiwiY2IiLCJlbGVtZW50IiwiY29udGFpbnMiLCJlbCIsImlzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUVsZW1lbnQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0UHJvcGVydHlQcmlvcml0eSIsInJlbW92ZUNTUyIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJjc3NUZXh0IiwiZGF0YXNldCIsImRldGFpbHMiLCJkaXNwYXRjaEV2ZW50IiwiZmlsdGVyIiwiaGFzQXR0cmlidXRlTlMiLCJoYXNBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJuZXh0IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJlbmQiLCJmaXJzdENoaWxkIiwibGlzdGVuZXIiLCJuZXdFdmVudHMiLCJhbGxMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwcm9wcyIsImZpcnN0IiwicHJldiIsImJhYmVsSGVscGVycy5nZXQiLCJhcHBseSIsInRleHRDb250ZW50IiwiY29uZGl0aW9uIiwiX2FyZ3VtZW50cyIsIl9hcmd1bWVudHMyIiwic3BlY2llcyIsIm9wdHMiLCJkaXNwbGF5TmFtZSIsImN1cnJlbnRWYWx1ZSIsImlzUGFyZW50U2lnbmFsIiwiaXNSZW1vdmVkIiwiYmVmb3JlUmVtb3ZlIiwid3JhcHBlcnMiLCJyZWR1Y2UiLCJpc0VsZW1lbnRSZW1vdmVkIiwiYWZ0ZXJFbGVtIiwiZW1wdHlPYmplY3QiLCJvcmlnaW5hbEFyZ3MiLCJjaGlsZHJlbkJsb2NrcyIsImNoaWxkcmVuTWl4aW5zIiwiZnVuYyIsIm9uQ2hhbmdlIiwidGFyZ2V0QmxvY2siLCJmb3JFbGVtZW50cyIsImZvckl0ZW0iLCJvbkNoYW5nZUZsYWciLCJyZXN1bHQiLCJvcmlnaW5hbCIsIm9uRXZhbEVycm9yIiwiZSIsImxvY2FsV2F0Y2hlcnMiLCJ3YXRjaGVyQmxvY2siLCJuZXdSZXN1bHQiLCJyZW1vdmVDb250ZW50IiwibmV3Q29udGVudCIsImFmdGVyRE9NQ2hhbmdlIiwiY29udGVudFRvQWRkIiwibm90UmVjdXJzaXZlIiwib2xkQ29udGVudCIsImNoYW5nZUNvbnRlbnQiLCJjb250ZW50VG9Nb3ZlIiwiYWZ0ZXIiLCJpbmRleFRvUHV0IiwibW92ZUNvbnRlbnQiLCJjb250ZW50VG9SZW1vdmUiLCJjb250ZW50VG9JbnNlcnQiLCJtb3ZlRmxhZyIsInRyeVRvQWRkT3JNb3ZlIiwiZGVmYXVsdExvY2FscyIsImRlZmF1bHRBcmdzIiwibG9jYWxBcmdzIiwicmVzdEFyZ3MiLCJDYXNlIiwid2F0Y2hBcmdzIiwiX3RoaXMyIiwiQ2hpbGRyZW4iLCJodG1sQ2hpbGRyZW4iLCJmb3VuZCIsImNvbnN0cnVjdCIsIkVhY2giLCJpdGVtc0J5VUlEcyIsInJlbmRlclNldCIsInNldCIsImZpbHRlckJ5Iiwic29ydEJ5IiwiVUlEIiwidWlkIiwibmV3SXRlbXNCeVVJRHMiLCJuZXdVSURzQnlJbmRleGVzIiwibmV3VUlEcyIsImlzQXJyIiwiaXRlcmF0ZSIsInNvcnQiLCJwcmV2VUlEQmxvY2siLCJJZiIsImNvbnN0cnVjdEVsZW1zIiwiU3dpdGNoIiwiSW5maW5pdHkiLCJzd2l0Y2hBcmdzIiwid2FzRGVmYXVsdCIsIm1hcCIsInZhbCIsIndoZW4iLCJjb21wYXJlRm4iLCJzb21lIiwic3dpdGNoVmFsdWUiLCJjYXNlVmFsdWUiLCJCaW5kIiwib2ZmIiwiam9pbiIsIm5ld0NsYXNzZXMiLCJIaWRlIiwiTm9kZSIsIk9uIiwiU2hvdyIsIlN0eWxlIiwiQm9vbGVhbiIsIlZhbHVlIiwiaW5pdGlhbFNjb3BlVmFsdWUiLCJzZXRQcm9wIiwiaW5pdGlhbEVsZW1WYWx1ZSIsImlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIiwiaXNDaGVja2JveCIsImNoYW5nZVNjb3BlIiwib2ZmRWxlbUxpc3RlbmVyIiwib2ZmRm9ybUxpc3RlbmVyIiwib3B0aW9uIiwiYm9keSJdLCJtYXBwaW5ncyI6InlCQUFPLFNBQVNBLEdBQWlCQyxFQUFPQyxNQUFVQyxzRUFDbkNGLEVBQU8sU0FBQ0csRUFBT0MsS0FDakJGLEVBQWNDLEVBQU9DLEVBQU9KLEtBR2hDRSxFQUdULFFBQWdCRyxHQUFZTCxFQUFPQyxPQUM1QixHQUFJSyxHQUFJLEVBQUdDLEVBQVNQLEVBQU1PLE9BQVFELEVBQUlDLEVBQVFELElBQUssSUFDaERILEdBQVFILEVBQU1NLE1BRWhCTCxFQUFTRSxFQUFPRyxFQUFHTixjQUVkTSxZQU9iLFFBQWdCRSxHQUFhUixFQUFPQyxPQUM3QixHQUFJSyxHQUFJLEVBQUdDLEVBQVNQLEVBQU1PLE9BQVFELEVBQUlDLEVBQVFELE1BQ3hDTixFQUFNTSxHQUFJQSxFQUFHTixHQUkxQixRQUFnQlMsR0FBZ0JULEVBQU9VLE1BQy9CTixHQUFRSixFQUFNVyxRQUFRRCxJQUViLElBQVhOLEtBQ0lRLE9BQU9SLEVBQU8sR0FJeEIsUUFBZ0JTLEdBQWFiLFNBQ3BCRCxHQUFpQkMs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"}