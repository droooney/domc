{"version":3,"file":"dwayne.min.js","sources":["../lib/helpers/toStringTag.js","../lib/helpers/checkTypes.js","../lib/D.js","../lib/helpers/iterate.js","../lib/helpers/assign.js","../lib/helpers/constructEvalFunction.js","../lib/helpers/defineProperty.js","../lib/helpers/toArray.js","../lib/helpers/validate.js","../lib/Alphabet.js","../lib/Switcher.js","../lib/Super.js","../lib/Func.js","../lib/Num.js","../lib/Arr.js","../lib/BlobObject.js","../lib/Str.js","../lib/helpers/markupToJSON.js","../lib/Elem.js","../lib/blocks/d-block.js","../lib/blocks/d-each.js","../lib/blocks/d-elements.js","../lib/blocks/d-if.js","../lib/blocks/d-item.js","../lib/blocks/d-switch.js","../lib/mixins/d-attr.js","../lib/mixins/d-bind.js","../lib/mixins/d-class.js","../lib/mixins/d-elem.js","../lib/mixins/d-hide.js","../lib/mixins/d-node.js","../lib/mixins/d-on.js","../lib/mixins/d-show.js","../lib/mixins/d-style.js","../lib/mixins/d-validate.js","../lib/mixins/d-value.js","../lib/helpers/parseJS.js","../lib/Block.js","../lib/constants/formats.js","../lib/Dat.js","../lib/helpers/constructURL.js","../lib/Fetch.js","../lib/Router.js","../lib/constants/global.js","../lib/constants/appliedRegExps.js","../lib/constants/canvasMethods.js","../lib/constants/constructors.js","../lib/constants/elements.js","../lib/constants/htmlAllowedTagSymbols.js","../lib/constants/regexpSpecialCharacters.js","../lib/constants/validateCheckExpressions.js","../lib/helpers/Symbol.js","../lib/Promise.js","../lib/helpers/parseHeaders.js","../lib/helpers/transformData.js","../lib/helpers/resolveURL.js","../browser.js"],"sourcesContent":["/**\n * @module helpers/toStringTag\n * @private\n * @description Exports toStringTag method.\n */\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return {}.toString.call(object).replace(/^\\[object |]$/g, '');\n}\n","/**\n * @module helpers/checkTypes\n * @private\n * @mixin\n * @description Exports is<Type> methods.\n */\n\nimport { toStringTag } from './toStringTag';\n\n/**\n * @function isArray\n * @public\n * @param {*} value - Value to check if it is an array.\n * @returns {Boolean} If the argument is an array or not.\n * \n * @example\n * isArray([]);                             // true\n * isArray(0);                              // true\n * isArray(document.querySelectorAll('*')); // false\n */\nexport function isArray(value) {\n  return toStringTag(value) === 'Array';\n}\n\n/**\n * @function isArrayLike\n * @public\n * @param {*} value - Value to check if it is array-like.\n * @returns {Boolean} If the argument is array-like or not.\n * @description Basically returns if the argument has non-negative integer \"length\" property and isn't a function.\n * \n * @example\n * isArrayLike([]);                             // true\n * isArrayLike('');                             // true\n * isArrayLike(() => {});                       // false\n * isArrayLike(document.querySelectorAll('*')); // true\n */\nexport function isArrayLike(value) {\n  if (!value || isFunction(value)) {\n    return false;\n  }\n  \n  const length = value.length;\n  \n  return isInteger(length) && length >= 0;\n}\n\n/**\n * @function isBoolean\n * @public\n * @param {*} value - Value to check if it is a boolean.\n * @returns {Boolean} If the argument is a boolean or not.\n * \n * @example\n * isBoolean(true);               // true\n * isBoolean(new Boolean(false)); // true\n * isBoolean(null);               // false\n */\nexport function isBoolean(value) {\n  return toStringTag(value) === 'Boolean';\n}\n\n/**\n * @function isDate\n * @public\n * @param {*} value - Value to check if it is a date.\n * @returns {Boolean} If the argument is a date or not.\n * \n * @example\n * isDate(new Date());                 // true\n * isDate('1999-12-31T23:59:59.999Z'); // false\n */\nexport function isDate(value) {\n  return toStringTag(value) === 'Date';\n}\n\n/**\n * @function isDateLike\n * @public\n * @param {*} value - Value to check if it is date-like.\n * @returns {Boolean} If the argument is date-like or not.\n * @description Basically returns if new Date(argument) is not invalid date.\n * \n * @example\n * isDateLike(new Date());                 // true\n * isDateLike('1999-12-31T23:59:59.999Z'); // true\n * isDateLike(0);                          // true\n */\nexport function isDateLike(value) {\n  value = new Date(value);\n  \n  return !isNaN(value.getTime());\n}\n\n/**\n * @function isElement\n * @public\n * @param {*} value - Value to check if it is an element.\n * @returns {Boolean} If the argument is element or not.\n *\n * @example\n * isElement(document.querySelector('html')); // true\n */\nexport function isElement(value) {\n  return /Element$/.test(toStringTag(value));\n}\n\n/**\n * @function isFinite\n * @public\n * @param {*} value - Value to check if it is finite.\n * @returns {Boolean} If the argument is finite or not.\n * \n * @example\n * isFinite(0);        // true\n * isFinite('0');      // false\n * isFinite(Infinity); // false\n * isFinite(NaN);      // false\n */\nexport function isFinite(value) {\n  if (!isNumber(value)) {\n    return false;\n  }\n  \n  value = Number(value);\n\n  return !isNaN(value) && value !== Infinity && value !== -Infinity;\n}\n\n/**\n * @function isFunction\n * @public\n * @param {*} value - Value to check if it is a function.\n * @returns {Boolean} If the argument is a function or not.\n * \n * @example\n * isFunction(() => {});            // true\n * \n * const func = () => {};\n * Object.setPrototypeOf(func, {});\n * isFunction(func);                // true\n */\nexport function isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\n * @function isInteger\n * @public\n * @param {*} value - Value to check if it is an integer.\n * @returns {Boolean} If the argument is an integer or not.\n *\n * @example\n * isInteger(0);             // true\n * isInteger(0.1);           // false\n * isInteger(new Number(0)); // true\n * isInteger('0');           // false\n * isInteger(Infinity);      // false\n * isInteger(NaN);           // false\n */\nexport function isInteger(value) {\n  return isNumber(value) && value % 1 === 0;\n}\n\n/**\n * @function isIntegerLike\n * @public\n * @param {*} value - Value to check if it is integer-like.\n * @returns {Boolean} If the argument is integer-like or not.\n *\n * @example\n * isIntegerLike(0);             // true\n * isIntegerLike(new Number(0)); // true\n * isIntegerLike(0.1);           // false\n * isIntegerLike('0');           // true\n */\nexport function isIntegerLike(value) {\n  value = parseInt(Number(value));\n\n  return !!(value || value === 0);\n}\n\n/**\n * @function isNaN\n * @public\n * @param {*} value - Value to check if it is NaN.\n * @returns {Boolean} If the argument is NaN or not.\n *\n * @example\n * isNaN(0);               // false\n * isNaN('NaN');           // false\n * isNaN(NaN);             // true\n * isNaN(new Number(NaN)); // true\n */\nexport function isNaN(value) {\n  if (!isNumber(value)) {\n    return false;\n  }\n  \n  value = Number(value);\n\n  return value !== value;\n}\n\n/**\n * @function isNull\n * @public\n * @param {*} value - Value to check if it is null.\n * @returns {Boolean} If the argument is null or not.\n *\n * @example\n * isNull(null);      // true\n * isNull(undefined); // false\n */\nexport function isNull(value) {\n  return value === null;\n}\n\n/**\n * @function isNil\n * @public\n * @param {*} value - Value to check if it is null or undefined.\n * @returns {Boolean} If the argument is null or undefined or not.\n *\n * @example\n * isNil(null);      // true\n * isNil(undefined); // true\n * isNil(false);     // false\n */\nexport function isNil(value) {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\n * @function isNumber\n * @public\n * @param {*} value - Value to check if it is a number.\n * @returns {Boolean} If the argument is a number or not.\n *\n * @example\n * isNumber(0);             // true\n * isNumber(new Number(0)); // true\n * isNumber(NaN);           // true\n * isNumber('0');           // false\n */\nexport function isNumber(value) {\n  return toStringTag(value) === 'Number';\n}\n\n/**\n * @function isNumberLike\n * @public\n * @param {*} value - Value to check if it is number-like.\n * @returns {Boolean} If the argument is number-like or not.\n *\n * @example\n * isNumberLike(0);          // true\n * isNumberLike('0');        // true\n * isNumberLike('Infinity'); // true\n * isNumberLike('NaN');      // true\n * isNumberLike(NaN);        // true\n */\nexport function isNumberLike(value) {\n  if (isNaN(value) || value === 'NaN') {\n    return true;\n  }\n  \n  value = Number(value);\n  \n  return !!(value || value === 0);\n}\n\n/**\n * @function isObject\n * @public\n * @param {*} value - Value to check if it is an object.\n * @returns {Boolean} If the argument is an object or not.\n *\n * @example\n * isObject({});   // true\n * isObject(1);    // false\n * isObject(null); // false\n */\nexport function isObject(value) {\n  return !!value && (toStringTag(value) === 'Object' || typeof value === 'object' || value instanceof Object);\n}\n\n/**\n * @function isPlainObject\n * @public\n * @param {*} value - Value to check if it is a plain object.\n * @returns {Boolean} If the argument is a plain object or not.\n *\n * @example\n * const obj = {};\n *\n * ifPlainObject(obj); // true\n *\n * Object.setPrototypeOf(object, null);\n *\n * ifPlainObject(obj); // true\n *\n * Object.setPrototypeOf(object, {});\n *\n * ifPlainObject(obj); // false\n */\nexport function isPlainObject(value) {\n  if (isPrimitive(value)) {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n\n  if (isNull(proto)) {\n    return true;\n  }\n\n  const constructor = proto.constructor;\n\n  return isFunction(constructor) &&\n    constructor instanceof constructor &&\n    isNull(Object.getPrototypeOf(proto));\n}\n\n/**\n * @function isPrimitive\n * @public\n * @param {*} value - Value to check if it is primitive.\n * @returns {Boolean} If the argument is primitive or not.\n *\n * @example\n * isPrimitive(1);             // true\n * isPrimitive({});            // false\n * isPrimitive('');            // true\n * isPrimitive(new Number(0)); // false\n * isPrimitive(true);          // true\n * isPrimitive(Symbol('foo')); // true\n * isPrimitive(null);          // true\n * isPrimitive(undefined);     // true\n */\nexport function isPrimitive(value) {\n  return isNull(value) || /^(number|string|boolean|symbol|undefined)$/.test(typeof value);\n}\n\n/**\n * @function isRegExp\n * @public\n * @param {*} value - Value to check if it is a regular expression.\n * @returns {Boolean} If the argument is a regular expression or not.\n *\n * @example\n * isRegExp(/foo/);             // true\n * isRegExp('/foo/');           // false\n * isRegExp(new RegExp('foo')); // true\n */\nexport function isRegExp(value) {\n  return toStringTag(value) === 'RegExp';\n}\n\n/**\n * @function isString\n * @public\n * @param {*} value - Value to check if it is a string.\n * @returns {Boolean} If the argument is a string or not.\n *\n * @example\n * isString('0');             // true\n * isString(new String('0')); // true\n */\nexport function isString(value) {\n  return toStringTag(value) === 'String';\n}\n\n/**\n * @function isSymbol\n * @public\n * @param {*} value - Value to check if it is a symbol.\n * @returns {Boolean} If the argument is a symbol or not.\n *\n * @example\n * isSymbol(Symbol('1')); // true\n */\nexport function isSymbol(value) {\n  return toStringTag(value) === 'Symbol';\n}\n\n/**\n * @function isUndefined\n * @public\n * @param {*} value - Value to check if it is undefined.\n * @returns {Boolean} If the argument is undefined or not.\n *\n * @example\n * isUndefined(null);      // false\n * isUndefined(undefined); // true\n */\nexport function isUndefined(value) {\n  return typeof value === 'undefined';\n}\n","/**\n * @module D\n * @private\n * @description Exports D function.\n */\n\nimport { constructors } from './constants';\n\n/**\n * @function D\n * @public\n * @param {*} [value] - Any value.\n * @returns {DWrap} Wrap of the argument.\n * @description Function for creating a D-wrap of an object.\n *\n * @example\n * D({});            // Super\n * D(() => {});      // Func\n * D([]);            // Arr\n * D(1);             // Num\n * D('1');           // Str\n * D(new Date());    // Dat\n * D(document.body); // Elem\n */\nfunction D(value) {\n  for (let i = constructors.length - 1; i >= 0; i--) {\n    const levelConstructors = constructors[i];\n\n    for (let k = 0, len = levelConstructors.length; k < len; k++) {\n      const constructor = levelConstructors[k];\n\n      if (value instanceof constructor.cls) {\n        return value;\n      }\n\n      if (constructor.check(value)) {\n        return new constructor.cls(value);\n      }\n    }\n  }\n}\n\nexport * from './helpers/checkTypes';\nexport { D };\n","/**\n * @module helpers/iterate\n * @private\n * @description Exports iterate method.\n */\n\nimport { isArrayLike, isUndefined } from './checkTypes';\n\n/**\n * @callback IterationCallback\n * @param {*} value - Iteration value.\n * @param {String|Number} key - Iteration key.\n * @param {*} object - Initial iterable object.\n */\n\n/**\n * @function iterate\n * @param {(Object|Array|null|undefined)} object - Value to iterate over.\n * @param {IterationCallback} callback - Callback that is called on every iteration.\n * @returns {*} If callback returns not undefined then iterate returns this value.\n * @description Function for iterating over all types of values.\n */\nexport function iterate(object, callback) {\n  const array = isArrayLike(object);\n  const iteratedKeys = {};\n\n  let iterated = 0;\n\n  for (const key in object) {\n    if ({}.hasOwnProperty.call(iteratedKeys, key)) {\n      continue;\n    }\n\n    iteratedKeys[key] = true;\n\n    if ({}.hasOwnProperty.call(object, key)) {\n      if (array && iterated++ >= object.length) {\n        break;\n      }\n\n      const value = callback(object[key], array ? Number(key) : key, object);\n\n      if (!isUndefined(value)) {\n        return value;\n      }\n    }\n  }\n}\n","/**\n * @module helpers/assign\n * @private\n * @description Exports Object.assign-like method.\n */\n\nimport { iterate } from './iterate';\n\n/**\n * @const\n * @function assign\n * @param {Object} target - Object to assign rest of arguments to.\n * @param {...Object} objects - Objects that are assigned to the target.\n * @returns {Object} Target.\n */\nexport function assign(target, ...objects) {\n  iterate(arguments, (source, index) => {\n    if (index) {\n      iterate(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n    \n  return target;\n}\n","/**\n * @module helpers/constructEvalFunction\n * @private\n * @description Exports constructEvalFunction method.\n */\n\n/**\n * @function constructEvalFunction\n * @param {String} code - JS code.\n * @param {String} original - Original JS code.\n * @returns {*} Eval function.\n * @description Function for constructing eval function.\n */\nexport function constructEvalFunction(code, original) {\n  let func;\n\n  try {\n    /* eslint no-new-func: 0 */\n    func = new Function('$', `return ${ code }`);\n    func.expression = code;\n    func.original = original;\n\n    return func;\n  } catch (err) {\n    throw new Error(`Syntax error (in \"${ code }\", original code: \"${ original }\")`);\n  }\n}\n","/**\n * @module helpers/defineProperty\n * @private\n * @description Exports defineProperty and dynamicDefineProperties methods.\n */\n\nimport { iterate } from './iterate';\n\n/**\n * @callback propertyGeneratorCallback\n * @param {String} name - Name of the property.\n * @param {Number} i - Index of the array.\n * @returns {*} Generated property.\n */\n\n/**\n * @function dynamicDefineProperties\n * @param {Object} target - Object to define properties for.\n * @param {Array} properties - Object which keys are properties.\n * @param {propertyGeneratorCallback} propertyGenerator - Callback for every property.\n * @returns {void}\n * @description Function for dynamic creating properties based on name of the method.\n */\nexport function dynamicDefineProperties(target, properties, propertyGenerator) {\n  iterate(properties, (name, i) => {\n    Object.defineProperty(target, name, {\n      value: propertyGenerator(name, i),\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining properties of an object.\n */\nexport function defineProperties(target, properties) {\n  iterate(properties, (value, name) => {\n    if (/^get /.test(name)) {\n      Object.defineProperty(target, name.replace(/^get /, ''), {\n        get: value,\n        set: undefined,\n        enumerable: false,\n        configurable: true\n      });\n\n      return;\n    }\n\n    if (/^set /.test(name)) {\n      Object.defineProperty(target, name.replace(/^set /, ''), {\n        set: value,\n        get: undefined,\n        enumerable: false,\n        configurable: true\n      });\n\n      return;\n    }\n\n    if (/^get\\/set /.test(name)) {\n      Object.defineProperty(target, name.replace(/^get\\/set /, ''), {\n        get: value.get,\n        set: value.set,\n        enumerable: false,\n        configurable: true\n      });\n\n      return;\n    }\n\n    if (name !== 'Symbol.toStringTag') {\n      Object.defineProperty(target, name, {\n        value,\n        writable: true,\n        enumerable: false,\n        configurable: true\n      });\n    }\n  });\n}\n\n/**\n * @function defineUsualProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining usual properties of an object.\n */\nexport function defineUsualProperties(target, properties) {\n  iterate(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: true,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineFrozenProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining frozen properties of an object.\n */\nexport function defineFrozenProperties(target, properties) {\n  iterate(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","/**\n * @module helpers/toArray\n * @private\n * @description Exports toArray method.\n */\n\nimport { isArray, isArrayLike, isString } from './checkTypes';\nimport { iterate } from './iterate';\n\n/**\n * @function toArray\n * @param {*} value - Any value.\n * @param {Boolean} [createNewArray = false] - If it is needed to create new array.\n * @returns {Array} Create array.\n * @description Function for creating an array of any value.\n */\nexport function toArray(value, createNewArray) {\n  if (isArray(value) && !createNewArray) {\n    return value;\n  }\n\n  const array = [];\n\n  if (isArrayLike(value) && !isString(value)) {\n    iterate(value, (value) => {\n      array.push(value);\n    });\n  } else {\n    array.push(value);\n  }\n\n  return array;\n}\n","/**\n * @module helpers/validate\n * @private\n * @description Exports validate method.\n */\n\nimport { validateCheckExpressions } from '../constants';\nimport { iterate } from './iterate';\nimport { isArray } from './checkTypes';\n\nconst numbers = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th'];\n\n/**\n * @function validate\n * @private\n * @param {Object} args - Arguments of function.\n * @param {Object} options - Object with validate parameters.\n * @param {String} [name] - Name of the function what called validate.\n * @returns {void}\n * @description Function for checking arguments of other functions.\n */\nexport function validate(args, options, name) {\n  iterate(options, (array, number) => {\n    if (!isArray(array)) {\n      array = [array];\n    }\n\n    iterate(array, (checker) => {\n      checker = validateCheckExpressions[checker];\n\n      if (!checker.check(args[number])) {\n        throw new checker.error(checker.text.replace('$n', numbers[number]) + (name ? ` (at ${ name })` : ''));\n      }\n    });\n  });\n}\n","/**\n * @module Alphabet\n * @private\n * @mixin\n * @description Exports Alphabet class.\n */\n\nimport { isString, validate, defineProperties, Symbol } from './helpers';\n\n/**\n * @typedef {String} Char\n * @public\n * @description A string of one char.\n */\n\n/**\n * @class Alphabet\n * @public\n * @param {ArrayLike} alphabet - Alphabet to wrap.\n * @returns {Alphabet} Instance of Alphabet.\n * @description Class for alphabet manipulations: add, delete symbols, generate a token from an alphabet,\n * check if an alphabet contains a word.\n *\n * @example\n * new Alphabet(['a', 'b', 'c']);\n */\nclass Alphabet {\n  constructor(alphabet = []) {\n    const a = {};\n\n    for (let i = 0, length = alphabet.length; i < length; i++) {\n      const char = alphabet[i];\n\n      if (!check(char)) {\n        throw new Error('Each element of an array must be a single char! (in Alphabet)');\n      }\n\n      a[char] = char;\n    }\n\n    /**\n     * @member {Object} Alphabet#$$\n     * @public\n     * @description The alphabet.\n     */\n    Object.defineProperty(this, '$$', { value: a });\n  }\n\n  /**\n   * @method Alphabet#add\n   * @public\n   * @param {...Char} chars - Chars to add.\n   * @returns {Alphabet} Returns this.\n   * @description Method for adding new letters to the alphabet.\n   *\n   * @example\n   * const alphabet = new Alphabet(['a', 'b', 'c']);\n   *\n   * alphabet.add('d', 'e');\n   *\n   * alphabet.get().$; // ['a', 'b', 'c', 'd', 'e']\n   */\n  add(...chars) {\n    for (let i = 0, length = chars.length; i < length; i++) {\n      const char = chars[i];\n\n      if (!check(char)) {\n        throw new Error('Each argument must be a single char! (in Alphabet#add)');\n      }\n\n      this.$$[char] = char;\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Alphabet#contains\n   * @public\n   * @param {String} word - Word to check if it is in the alphabet or not.\n   * @returns {Boolean} If the word in the alphabet or not.\n   * @description Method that returns if a word is in alphabet or not.\n   *\n   * @example\n   * const alphabet = new Alphabet(['f', 'b', 'o', 'a', 'r']);\n   *\n   * alphabet.contains('foo'); // true\n   * alphabet.contains('bar'); // true\n   * alphabet.contains('baz'); // false\n   */\n  contains(word) {\n    validate([word], ['string'], 'Alphabet#contains');\n\n    const alphabet = this.$$;\n\n    for (let i = 0, length = word.length; i < length; i++) {\n      if (!alphabet[word[i]]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @method Alphabet#delete\n   * @public\n   * @param {...Char} chars - Chars to delete.\n   * @returns {Alphabet} Returns this.\n   * @description Method for deleting letters from the alphabet.\n   *\n   * @example\n   * const alphabet = new Alphabet(['a', 'b', 'c', 'd']);\n   *\n   * alphabet.delete('a');\n   *\n   * alphabet.get().$; // ['b', 'c', 'd']\n   *\n   * alphabet.delete('b', 'd');\n   *\n   * alphabet.get().$; // ['c']\n   */\n  delete(...chars) {\n    for (let i = 0, length = chars.length; i < length; i++) {\n      const char = chars[i];\n\n      if (!check(char)) {\n        throw new Error('Each argument must be a single char! (in Alphabet#delete)');\n      }\n\n      delete this.$$[char];\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Alphabet#get\n   * @returns {Array} Wrap of an array of alphabet letters.\n   * @description Method for getting array of alphabet letters.\n   *\n   * @example\n   * new Alphabet(['a', 'b', 'c']).get().$; // ['a', 'b', 'c']\n   */\n  get() {\n    return Object.keys(this.$$);\n  }\n\n  /**\n   * @method Alphabet#token\n   * @public\n   * @param {Number} length - Token length.\n   * @returns {String} Token.\n   * @description Method for generating random token with given length.\n   *\n   * @example\n   * new Alphabet(['a', 'b', 'c']).token(4); // 'abcb'\n   */\n  token(length) {\n    validate([length], [['intLike', '>0']], 'Alphabet#token');\n\n    const alphabet = Object.keys(this.$$);\n    const len = alphabet.length;\n    let token = '';\n\n    for (let i = 0; i < length; i++) {\n      token += alphabet[Math.floor(Math.random() * len)];\n    }\n\n    return token;\n  }\n}\n\ndefineProperties(Alphabet.prototype, {\n  [Symbol.toStringTag]: 'Alphabet'\n});\n\nfunction check(char) {\n  return isString(char) && char.length === 1;\n}\n\n/**\n * @function alphabet\n * @public\n * @param {String} string - String to generate an alphabet from.\n * @returns {Alphabet} New instance of Alphabet.\n * @description Function for creating an alphabet from a string that has format like this:\n * '&lt;char1&gt;-&lt;char2&gt; &lt;char3&gt;-&lt;char4&gt;'\n *\n * @example\n * const a1 = alphabet('a-c 1-3');\n * const a2 = alphabet('5-5f-g');\n *\n * a1.get().$; // ['1', '2', '3', 'a', 'b', 'c']\n * a2.get().$; // ['5', 'f', 'g']\n */\nfunction alphabet(string) {\n  validate([string], ['string']);\n\n  const ranges = string.split(/([\\s\\S]-+[\\s\\S])?/g);\n  const length = ranges.length;\n  const alphabet = [];\n\n  for (let i = 0; i < length; i++) {\n    const range = ranges[i];\n\n    if (!range || range === ' ') {\n      continue;\n    }\n\n    if (/-/.test(range) && !/[\\s\\S]-+[\\s\\S]/.test(range)) {\n      throw new Error(`Wrong part of the string (${ range })! (in alphabet)`);\n    }\n\n    if (/-/.test(range)) {\n      const start = range.charCodeAt(0);\n      const end = range.charCodeAt(2);\n\n      if (start > end) {\n        throw new Error('Start of the range must be before its end! (in alphabet)');\n      }\n\n      for (let k = 0, len = end - start + 1; k < len; k++) {\n        alphabet.push(String.fromCharCode(start + k));\n      }\n\n      continue;\n    }\n\n    if (range.length === 1) {\n      alphabet.push(range);\n    }\n  }\n\n  return new Alphabet(alphabet);\n}\n\nexport { Alphabet, alphabet };\n","/**\n * @module Switcher\n * @private\n * @mixin\n * @description Exports Switcher class.\n */\n\nimport {\n  isArray, isFunction, isString, isUndefined,\n  iterate, Symbol, toArray, defineProperties\n} from './helpers';\n\n/**\n * @typedef {'boolean'|'equals'|'strictEquals'|'call'} SwitcherMode\n * @public\n * @description Enum type of switcher modes.\n */\n\n/**\n * @callback SwitcherCallCallback\n * @public\n * @param {*} value - Switcher value.\n * @returns {Boolean|*} On what the callback returns depends if the case is a match (truthy for the match).\n */\n\n/**\n * @callback SwitcherMatchCallback\n * @public\n * @param {...*} args - Arguments from the second argument that switcher was called with.\n * @param {*} value - Switcher value.\n * @param {*} matched - Switcher matched case.\n */\n\n/**\n * @class Switcher\n * @public\n * @param {Object} [cases = {}] - Object of cases.\n * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.\n * @param {*} [defaultValue] - Switcher default value.\n * @returns {Switcher} - Instance of Switcher.\n * @description Switcher class for creating functions working similar to switch (value) {} construction,\n * but with the value assignment. Switcher instance is a function that accepts a value argument and an optional\n * args argument. Args with additional switcher value and matched case\n * are passed into the function of the matched case (if it is a function).\n *\n * @example\n * const switcher = new Switcher();\n * const switcher = new Switcher({\n *   case1: 'value1',\n *   case2: 'value2'\n * });\n * const switcher = new Switcher('strictEquals');\n * const switcher = new Switcher({\n *   case1: 'value1',\n *   case2: 'value2'\n * }, 'strictEquals');\n * const switcher = new Switcher('strictEquals', 'defaultValue');\n * const switcher = new Switcher({\n *   case1: 'value1',\n *   case2: 'value2'\n * }, 'strictEquals', 'defaultValue');\n *\n * // See [switcher]{@link switcher} examples for more information.\n */\nclass Switcher extends Function {\n  constructor(cases = {}, mode = 'equals', defaultValue) {\n    super();\n\n    if (isString(cases)) {\n      if (!isUndefined(arguments[1])) {\n        defaultValue = mode;\n      }\n\n      mode = cases;\n      cases = {};\n    }\n\n    const eventualCases = [];\n\n    iterate(cases, (value, Case) => {\n      eventualCases.push({ case: Case, value });\n    });\n\n    function switcher(value, args = []) {\n      const { mode, default: def, cases } = switcher.$$;\n\n      let ret = iterate(cases, ({ value: val, case: Case }) => {\n        if (\n          (mode === 'boolean' && Case) ||\n          /* eslint eqeqeq: 0 */\n          (mode === 'equals' && Case == value) ||\n          (mode === 'strictEquals' && Case === value) ||\n          (mode === 'call' && Case(value))\n        ) {\n          return { case: Case, value: val };\n        }\n      });\n\n      if (isUndefined(ret)) {\n        ret = { value: def };\n      }\n\n      if (!isFunction(ret.value)) {\n        return ret.value;\n      }\n\n      args = toArray(args, true);\n      args.push(value, ret.case);\n\n      return ret.value.apply(null, args);\n    }\n\n    /**\n     * @member Switcher#$$\n     * @type {Object}\n     * @protected\n     * @property {Array} cases - Array of cases.\n     * @property {SwitcherMode} mode - Switcher mode.\n     * @property {*} default - Switcher default value.\n     * @description Config parameters.\n     */\n    Object.defineProperty(switcher, '$$', {\n      value: {\n        cases: eventualCases,\n        mode,\n        default: defaultValue\n      }\n    });\n    Object.setPrototypeOf(switcher, Switcher.prototype);\n\n    return switcher;\n  }\n\n  /**\n   * @method Switcher#case\n   * @public\n   * @param {*|SwitcherCallCallback|Array.<*|SwitcherCallCallback>} cases - Case or an array of cases.\n   * @param {*|SwitcherMatchCallback} value - Value that has to be assigned or a function\n   * that is called with switcher value, if it's the case.\n   * @returns {Switcher} Returns this.\n   * @description Method for defining new cases.\n   *\n   * @example\n   * const sw = new Switcher()\n   *   .case(1, 'one')\n   *   .case(2, 'two');\n   *\n   * sw(1); // 'one'\n   * sw(2); // 'two'\n   */\n  case(cases, value) {\n    if (!isArray(cases)) {\n      cases = [cases];\n    }\n\n    iterate(cases, (Case) => {\n      this.$$.cases.push({ case: Case, value });\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Switcher#default\n   * @public\n   * @param {*} def - New default value.\n   * @returns {Switcher} Returns this.\n   * @description Method for redefining default switcher value.\n   *\n   * @example\n   * const sw = new Switcher()\n   *   .case(1, 'one')\n   *   .default('three');\n   *\n   * sw(1); // 'one'\n   * sw(2); // 'three'\n   */\n  default(def) {\n    this.$$.default = def;\n\n    return this;\n  }\n\n  /**\n   * @method Switcher#mode\n   * @public\n   * @param {SwitcherMode} mode - New switcher mode.\n   * @returns {Switcher} Returns this.\n   * @description Method for redefining switcher mode.\n   *\n   * @example\n   * const sw = new Switcher()\n   *   .mode('strictEquals')\n   *   .case(1, 'number')\n   *   .case('1', 'string');\n   *\n   * sw(1);   // 'number'\n   * sw('1'); // 'string'\n   */\n  mode(mode) {\n    this.$$.mode = mode;\n\n    return this;\n  }\n}\n\ndefineProperties(Switcher.prototype, {\n  [Symbol.toStringTag]: 'Switcher'\n});\n\n/**\n * @function switcher\n * @public\n * @param {Object} [cases = {}] - Object of cases.\n * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.\n * @param {*} [defaultValue] - Switcher default value.\n * @returns {Switcher} New instance of Switcher.\n * @description Simple wrap of [new Switcher(...)]{@link Switcher}.\n * \n * @example\n * const sw = switcher({\n *   1: 'foo',\n *   2: 'bar'\n * });\n * sw(1); // 'foo'\n * sw(2); // 'bar'\n * sw(3); // undefined\n * \n * @example\n * const sw = switcher()\n *   .case([1, 2], 'foo')\n *   .case(3, 'bar');\n *   \n * sw(1); // 'foo'\n * sw(2); // 'foo'\n * sw(3); // 'bar'\n * \n * @example\n * const sw = switcher('call')\n *   .case(isArray, 'array')\n *   .case(isString, 'string')\n *   .case(isNumber, 'number')\n *   .default('rest');\n *   \n * sw([]);    // 'array'\n * sw('foo'); // 'string'\n * sw(123);   // 'number'\n * sw({});    // 'rest'\n * \n * @example\n * const sw = switcher({\n *   1: (value) => {\n *     console.log(value + 1);\n *   },\n *   2: () => {\n *     console.log(value - 1);\n *   }\n * });\n * \n * sw(1); // 2\n * sw(2); // 1\n * \n * @example\n * const sw = switcher({\n *   first: (array) => array[0],\n *   last: (array) => array[array.length - 1]\n * }, 'equals', (array, index) => array[index]);\n * const array = [1, 2, 3, 4];\n * \n * sw('first', [array]); // 1\n * sw('last', [array]);  // 4\n * sw(1, [array]);       // 2\n * sw(2, [array]);       // 3\n */\nfunction switcher(cases, mode, defaultValue) {\n  return new Switcher(...arguments);\n}\n\n/**\n * @function when\n * @public\n * @param {Boolean|*} condition - Condition used for returning the proper value.\n * @param {*} value1 - Value if the condition is truthy.\n * @param {*} value2 - Value if the condition is falsey.\n * @returns {*} value1 or value2.\n * @description Synonym for\n * [ternary operator]{@link https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Operators/Conditional_Operator}.\n * \n * @example\n * when(true, 'true', 'false'); // 'true'\n */\nfunction when(condition, value1, value2) {\n  return condition ? value1 : value2;\n}\n\nexport { Switcher, switcher, when };\n","/**\n * @module Super\n * @private\n * @mixin\n * @description Exports Super class.\n */\n\nimport { D } from './D';\nimport { switcher } from './Switcher';\nimport { constructors } from './constants/constructors';\nimport {\n  isArray, isArrayLike, isDate, isElement, isFunction, isNil, isNaN, isNull,\n  isObject, isPlainObject, isPrimitive, isRegExp, isString, isUndefined,\n  validate, toStringTag, iterate, Symbol, defineProperties\n} from './helpers';\n\n/**\n * @typedef {Super|Arr|Func|Elem|Str|Num|Dat|BlobObject} DWrap\n * @public\n * @description Any kind of D-Wrap.\n */\n\n/**\n * @typedef {String|Number|null} Key\n * @public\n * @description Key type used in many methods.\n */\n\n/**\n * @typedef {TreeElement[]} Tree\n * @public\n */\n\n/**\n * @typedef {Object} TreeElement\n * @public\n * @property {Key} key - Tree element key.\n * @property {*} value - Tree element value.\n * @description {@link Tree} element.\n */\n\n/**\n * @callback DeepIterationCallback\n * @public\n * @param {*} value - Current iteration value.\n * @param {String|Number} key - Current iteration key/index.\n * @param {*} object - Iteration object.\n * @param {Tree} tree - Tree of { key, value } elements.\n */\n\n/**\n * @callback DeepReduceCallback\n * @public\n * @param {*} previousValue - Previous value.\n * @param {*} value - Current iteration value.\n * @param {String|Number} key - Current iteration key/index.\n * @param {*} object - Iteration object.\n * @param {Tree} tree - Tree of { key, value } elements.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {*} value - Current iteration value.\n * @param {String|Number} key - Current iteration key/index.\n * @param {*} object - Iteration object.\n */\n\n/**\n * @callback JSONCallback\n * @public\n * @param {String|null} key - Current value.\n * @param {*} value - Current key.\n * @param {Object} object - Iteration object.\n */\n\n/**\n * @callback ObjectCallback\n * @public\n * @param {Object} newObject - The new object.\n * @param {*} value - Current iteration value.\n * @param {String|Number} key - Current iteration key/index.\n * @param {*} object - Iteration object.\n */\n\n/**\n * @callback ReduceCallback\n * @public\n * @param {*} previousValue - Previous value.\n * @param {*} value - Current iteration value.\n * @param {String|Number} key - Current iteration key/index.\n * @param {*} object - Iteration object.\n */\n\n/**\n * @callback SuperMethod\n * @public\n * @this {DWrap}\n */\n\nconst cloneSwitcher = switcher('call', (object) => object)\n  .case(\n    (object) => new Super(object) === object,\n    (object) => new (Object.getPrototypeOf(object).constructor)(new Super(object.$).deepClone().$)\n  )\n  .case(isElement, (object, deep) => object.clone(deep))\n  .case(isDate, (object) => new Date(object))\n  .case(isRegExp, (object) => new RegExp(object.source, object.toString().match(/[gimuy]*$/)[0]))\n  .case(isArray, () => [])\n  .case(isPlainObject, () => ({}));\n\n/**\n * @class Super\n * @public\n * @param {*} [object] - An object to wrap.\n * @returns {DWrap} Instance of Super.\n * @description Wrap of any value. And there is no way to create a nested wrap.\n *\n * @example\n * new Super({}); // Super\n */\nclass Super {\n  constructor(object) {\n    if (object instanceof Super) {\n      return object;\n    }\n\n    /**\n     * @member Super#$\n     * @type {*}\n     * @public\n     * @description Wrapped object.\n     */\n    Object.defineProperty(this, '$', { value: object });\n  }\n\n  /**\n   * @method Super.addStaticProperties\n   * @public\n   * @param {String|Object} property - Either a string of a property or an object\n   * with properties keys and values values.\n   * @param {Object} [value] - If a property parameter is a string this has to be a property value.\n   * @returns {this} Returns this.\n   * @description Sets static properties for DWrap constructors.\n   *\n   * @example\n   * Super.addStaticProperties('cool', 42);\n   * Super.addStaticProperties('superCool', 42*42);\n   */\n  static addStaticProperties(property, value) {\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    defineProperties(this, property);\n\n    return this;\n  }\n\n  /**\n   * @method Super.addInstanceProperties\n   * @public\n   * @param {String|Object} property - Either a string of a property or an object\n   * with properties keys and values values.\n   * @param {Object} [value] - If a property parameter is a string this has to be a property value.\n   * @returns {this} Returns this.\n   * @description Sets static properties for DWrap prototypes.\n   *\n   * @example\n   * Super.addInstanceProperties('cool', 42);\n   * Super.addInstanceProperties('superCool', 42*42);\n   */\n  static addInstanceProperties(property, value) {\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    defineProperties(this.prototype, property);\n\n    return this;\n  }\n\n  /**\n   * @method Super#assign\n   * @public\n   * @param {...(Object|Super|*)} objects - Objects to be assigned to the object.\n   * @returns {DWrap} Returns this.\n   * @description Synonym for\n   * [Object.assign]\n   * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2 }).assign({ a: 3 }, { c: 3, d: 4 }, { d: 5 }).$; // { a: 3, b: 2, c: 3, d: 5 }\n   */\n  assign(...objects) {\n    const object = this.$;\n\n    iterate(object && arguments, (o) => {\n      iterate(new Super(o).$, (value, key) => {\n        object[key] = value;\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#average\n   * @public\n   * @param {IterationCallback} [callback = null] - Callback that is passed to {@link Super#sum}.\n   * @returns {Number} Average value.\n   * @description Synonym for object.sum(callback) / object.count.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).average();                         // 2\n   * new Super({ a: 1, b: 2, c: 5 }).average((value) => value * value); // 10\n   */\n  average(callback = null) {\n    validate([callback], ['function||!'], 'Super#average');\n\n    return this.sum(callback) / this.count;\n  }\n\n  /**\n   * @method Super#call\n   * @public\n   * @param {SuperMethod} func - Function to be called with this context.\n   * @param {...*} args - Arguments to be called with.\n   * @returns {*} Return of function call.\n   * @description Synonym for func.call(DObject, ...args);\n   *\n   * @example\n   * new Super({ a: 1 }).call(function (b, c) {\n   *   return this.a + b + c;\n   * }, 2, 3); // 6\n   */\n  call(func, ...args) {\n    validate([func], ['function'], 'Super#call');\n\n    return func.apply(this, args);\n  }\n\n  /**\n   * @method Super#clone\n   * @returns {DWrap} New object.\n   * @description Method assigns properties of the object to an empty one and returns the new one.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2 } }).clone().$; // { a: 1, b: { c: 2 } }\n   */\n  clone() {\n    const object = this.$;\n    const clone = cloneSwitcher(object, [object, false]);\n\n    if (clone !== object) {\n      iterate(object, (value, key) => {\n        clone[key] = value;\n      });\n    }\n\n    return new this.constructor(clone);\n  }\n\n  /**\n   * @member Super#count\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description Returns number of own enumerable keys of the object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2 }).count; // 2\n   */\n  get count() {\n    const object = this.$;\n\n    if (!isObject(object)) {\n      return 0;\n    }\n\n    return isArrayLike(object) ? object.length : Object.keys(object).length;\n  }\n\n  /**\n   * @method Super#create\n   * @public\n   * @param {Object} [descriptors] - Descriptors passed to Object.create.\n   * @returns {DWrap} New instance of D-Wrap.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n   * @description Synonym for\n   * [Object.create]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create}.\n   *\n   * @example\n   * new Super({}).create({\n   *   a: {\n   *     value: 1,\n   *     enumerable: false,\n   *     writable: true,\n   *     configurable: false\n   *   }\n   * }).$; // { a: 1 }\n   */\n  create(descriptors) {\n    return D(isPrimitive(this.$) ? undefined : Object.create(this.$, descriptors));\n  }\n\n  /**\n   * @method Super#deepAssign\n   * @public\n   * @param {...*} objects - Objects to be assigned to the object.\n   * @returns {DWrap} Returns this.\n   * @description Deep analogue of {@link Super#assign}.\n   *\n   * @example\n   * new Super({ a: 1 }).deepAssign(\n   *   {\n   *     b: {\n   *       c: 2\n   *     }\n   *   },\n   *   {\n   *     a: {\n   *       b: 1\n   *     }\n   *   },\n   *   {\n   *     a: {\n   *       c: {\n   *         d: 1\n   *       }\n   *     },\n   *     b: 2\n   *   },\n   *   null\n   * });\n   * // {\n   * //   a: {\n   * //     b: 1,\n   * //     c: {\n   * //       d: 1\n   * //     }\n   * //   },\n   * //   b: 2,\n   * // }\n   */\n  deepAssign(...objects) {\n    const object = this.$;\n\n    if (isPrimitive(object)) {\n      return this;\n    }\n\n    iterate(arguments, (o) => {\n      deepAssign(object, o);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#deepClone\n   * @public\n   * @returns {DWrap} New instance of DWrap.\n   * @description Deep cloning method. Clones plain objects, arrays, regular expressions and elements, the rest stays the same.\n   *\n   * @example\n   * new Super({ a: 1, b: [2, 3], c: { d: 4 } }).deepClone().$;\n   * // {\n   * //   a: 1,\n   * //   b: [2, 3],\n   * //   c: { d: 4 }\n   * // }\n   */\n  deepClone() {\n    return new this.constructor(deepClone(this.$));\n  }\n\n  /**\n   * @method Super#deepEquals\n   * @public\n   * @param {*} [object] - Object to compare to.\n   * @returns {Boolean} - If the objects are deep equal or not.\n   * @description Method for deep comparison of two objects.\n   *\n   * @example\n   * new Super({ a: 1 }).deepEquals({ a: '1' }); // true\n   * new Super(/1/).deepEquals(/1/);             // true\n   */\n  deepEquals(object = null) {\n    return deepEqual(this.$, object, false);\n  }\n\n  /**\n   * @method Super#deepEvery\n   * @public\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy iteration goes on and if falsey it stops.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {Boolean} If all the callback calls returned truthy value.\n   * @description Returns boolean if all the callback calls returned truthy value.\n   * Otherwise false. Deep analogue of {@link Super#every}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepEvery((value) => value < 4); // true\n   * new Super({ a: {}, b: {}, c: {} }).deepEvery(() => false);              // true\n   */\n  deepEvery(callback, n) {\n    if (arguments.length === 1 && !isFunction(callback)) {\n      n = callback;\n      callback = Boolean;\n    } else if (arguments.length === 1) {\n      n = Infinity;\n    } else if (!arguments.length) {\n      n = Infinity;\n      callback = Boolean;\n    }\n\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepEvery');\n\n    n = Number(n);\n\n    return deepEvery(this.$, callback, n, [{ key: null, value: this.$ }]);\n  }\n\n  /**\n   * @method Super#deepFilter\n   * @public\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy the element is included and if falsey it's excluded.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {DWrap} New D-Wrap of filtered object.\n   * @description Returns filtered by the callback object. Deep analogue of {@link Super#filter}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value%2).$;     // { a: 1, b: { d: 3 } }\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value === 1).$; // { a: 1 }\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value > 3).$;   // {}\n   */\n  deepFilter(callback, n) {\n    if (arguments.length === 1 && !isFunction(callback)) {\n      n = callback;\n      callback = Boolean;\n    } else if (arguments.length === 1) {\n      n = Infinity;\n    } else if (!arguments.length) {\n      n = Infinity;\n      callback = Boolean;\n    }\n\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFilter');\n\n    const filtered = deepFilter(this.$, callback, n, [{ key: null, value: this.$ }]);\n\n    return D(isNil(filtered) ? filtered : filtered || {});\n  }\n\n  /**\n   * @method Super#deepFind\n   * @public\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy iteration stops and if falsey it continues.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {Tree|null} Tree of { key, value } if something found and null if not.\n   * @description Returns tree of the elements if something found and null if nothing found.\n   * Deep analogue of {@link Super#find}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFind((value) => value === 2);\n   * // [\n   * //   { key: 'c', value: 2 },\n   * //   { key: 'b', value: { c: 2, d: 3 } },\n   * //   { key: null, value: <initial object> }\n   * // ]\n   */\n  deepFind(callback, n) {\n    if (arguments.length === 1 && !isFunction(callback)) {\n      n = callback;\n      callback = Boolean;\n    } else if (arguments.length === 1) {\n      n = Infinity;\n    } else if (!arguments.length) {\n      n = Infinity;\n      callback = Boolean;\n    }\n\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFind');\n\n    return deepFind(this.$, callback, n, [{ key: null, value: this.$ }]);\n  }\n\n  /**\n   * @method Super#deepForEach\n   * @public\n   * @param {DeepIterationCallback} callback - Called on each iteration.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {DWrap} Returns this.\n   * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;\n   * // { a: 1, b: { c: 4, d: 9 } }\n   */\n  deepForEach(callback, n = Infinity) {\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');\n\n    n = Number(n);\n\n    deepForEach(this.$, callback, n, [{ key: null, value: this.$ }]);\n\n    return this;\n  }\n\n  /**\n   * @method Super#deepForEach\n   * @public\n   * @param {DeepIterationCallback} callback - Called on each iteration.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {DWrap} Returns this.\n   * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.\n   * Unlike {@link Super#deepForEach} the callback is called on every value of every object inside\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;\n   * // { a: 1, b: { c: 4, d: 9 } }\n   */\n  deepForEachEntry(callback, n = Infinity) {\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');\n\n    n = Number(n);\n\n    deepForEachEntry(this.$, callback, n, [{ key: null, value: this.$ }]);\n\n    return this;\n  }\n\n  /**\n   * @method Super#deepFreeze\n   * @public\n   * @returns {DWrap} Returns this.\n   * @description Deep analogue of {@link Super#freeze}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFreeze(); // Super\n   */\n  deepFreeze() {\n    deepFreeze(this.$);\n\n    return this;\n  }\n\n  /**\n   * @method Super#deepMap\n   * @public\n   * @param {DeepIterationCallback} callback - Called on each iteration.\n   * Return value is used for creating a new object.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {DWrap} D-Wrap of the new object.\n   * @description Returns a wrap of a new object using the callback. Deep analogue of {@link Super#map}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepMap((value) => value * value).$;\n   * // { a: 1, b: { c: 4, d: 9 } }\n   */\n  deepMap(callback, n = Infinity) {\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepMap');\n\n    n = Number(n);\n\n    return D(deepMap(this.$, callback, n, [{ key: null, value: this.$ }]));\n  }\n\n  /**\n   * @method Super#deepReduce\n   * @public\n   * @param {DeepReduceCallback} callback - Called on each iteration.\n   * Return value is passed to the next callback call.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @param {*} [IV = <first value>|undefined] - Initial value.\n   * @returns {*} Modified IV.\n   * @description Returns modified IV. Deep analogue of {@link Super#reduce}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepReduce((sum, value) => sum + value * value, Infinity, 0); // 14\n   */\n  deepReduce(callback, n = Infinity, IV) {\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepReduce');\n\n    n = Number(n);\n\n    const object = this.$;\n    const tree = [{ key: null, value: this.$ }];\n\n    if (arguments.length < 3) {\n      return deepReduce(object, callback, n, false, undefined, tree).IV;\n    }\n\n    return deepReduce(object, callback, n, false, { IV }, tree).IV;\n  }\n\n  /**\n   * @method Super#deepSome\n   * @public\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy iteration stops and if falsey it continues.\n   * @param {Number} [n = Infinity] - Iteration depth.\n   * @returns {Boolean} If all the callback calls returned truthy value.\n   * @description Returns true if some of the callback calls returned truthy value.\n   * Otherwise false. Deep analogue of {@link Super#some}.\n   *\n   * @example\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepSome((value) => value > 4); // false\n   * new Super({ a: {}, b: {}, c: {} }).deepSome(() => true);               // false\n   */\n  deepSome(callback, n) {\n    if (arguments.length === 1 && !isFunction(callback)) {\n      n = callback;\n      callback = Boolean;\n    } else if (arguments.length === 1) {\n      n = Infinity;\n    } else if (!arguments.length) {\n      n = Infinity;\n      callback = Boolean;\n    }\n\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepSome');\n\n    n = Number(n);\n\n    return deepSome(this.$, callback, n, [{ key: null, value: this.$ }]);\n  }\n\n  /**\n   * @method Super#deepStrictEquals\n   * @public\n   * @param {*} [object] - Object to compare to.\n   * @returns {Boolean} - If the objects are deep strict equal or not.\n   * @description Method for deep strict comparison of two objects.\n   *\n   * @example\n   * new Super({ a: 1 }).deepStrictEquals({ a: '1' }); // false\n   * new Super(/1/).deepStrictEquals(/1/);             // true\n   */\n  deepStrictEquals(object = null) {\n    return deepEqual(this.$, object, true);\n  }\n\n  /**\n   * @method Super#define\n   * @param {String|Object} property - Either a string of a property or a descriptors object.\n   * @param {Object} [descriptor] - If a property parameter is a string this has to be a property descriptor.\n   * @returns {DWrap} Returns this.\n   * @description Synonym for both\n   * [Object.defineProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty}\n   * and\n   * [Object.defineProperties]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties}.\n   *\n   * @example\n   * new Super({}).define('a', {\n   *   value: 1,\n   *   enumerable: false,\n   *   writable: true,\n   *   configurable: false\n   * }).$; // { a: 1 }\n   * new Super({}).define({\n   *   a: {\n   *     value: 1,\n   *     enumerable: false,\n   *     writable: true,\n   *     configurable: false\n   *   }\n   * }).$; // { a: 1 }\n   */\n  define(property, descriptor) {\n    if (arguments.length >= 2) {\n      property = { [property]: descriptor };\n    }\n\n    property = new Super(property).$;\n\n    if (isObject(this.$)) {\n      Object.defineProperties(this.$, property);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Super#delete\n   * @public\n   * @param {...String} props - List of properties to delete.\n   * @returns {DWrap} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete\n   * @description Synonym for multiple\n   * [\"delete\" operator]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).delete('c', 'a').$; // { b: 2 }\n   */\n  delete(...props) {\n    const object = this.$;\n\n    iterate(object && props, (property) => {\n      delete object[property];\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#equals\n   * @public\n   * @param {*} [object] - Object to compare.\n   * @returns {Boolean} If the objects are equal or not.\n   * @description Returns true if objects are equal using '==' operator and false if not. NaNs are considered to be equal.\n   *\n   * @example\n   * new Super(3).equals('3');   // true\n   * new Super(NaN).equals(NaN); // true\n   */\n  equals(object) {\n    const o = this.$;\n\n    object = new Super(object).$;\n\n    /* eslint eqeqeq: 0 */\n    return o == object || (isNaN(o) && isNaN(object));\n  }\n\n  /**\n   * @method Super#every\n   * @public\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy iteration goes on and if falsey it stops.\n   * @returns {Boolean} If all the callback calls returned truthy value.\n   * @description Returns boolean if all the callback calls returned truthy value.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).every((value) => value < 4); // true\n   * new Super({}).every(() => false);                            // true\n   */\n  every(callback = Boolean) {\n    validate([callback], ['function'], 'Super#every');\n\n    return iterate(this.$, (value, key, object) => {\n      if (!callback(value, key, object)) {\n        return false;\n      }\n    }) !== false;\n  }\n\n  /**\n   * @method Super#except\n   * @public\n   * @param {...String} [props] - Props to filter.\n   * @returns {DWrap} New D-Wrap of filtered object.\n   * @description Returns filter by the props object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).except('a', 'b').$; // { c: 3 }\n   * new Super(null).except('a').$;                      // {}\n   */\n  except(...props) {\n    return this.filter((value, key) => props.indexOf(key) === -1);\n  }\n\n  /**\n   * @method Super#filter\n   * @public\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy the element is included and if falsey it's excluded.\n   * @returns {DWrap} New D-Wrap of filtered object.\n   * @description Returns filtered by the callback object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).filter((value) => value%2).$; // { a: 1, c: 3 }\n   * new Super(null).filter((value) => value%2).$;                 // null\n   */\n  filter(callback = Boolean) {\n    validate([callback], ['function'], 'Super#filter');\n\n    const object = this.$;\n    const array = isArrayLike(object);\n\n    /* eslint no-nested-ternary: 0 */\n    const o = array ? [] : isNil(object) ? object : {};\n\n    iterate(object, (value, key) => {\n      if (callback(value, key, object)) {\n        if (array) {\n          o.push(value);\n        } else {\n          o[key] = value;\n        }\n      }\n    });\n\n    return D(o);\n  }\n\n  /**\n   * @method Super#find\n   * @public\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy iteration stops and if falsey it continues.\n   * @returns {{ key: Key, value: * }|null} { key, value } if found and null if not.\n   * @description Returns found { key, value } if something found and null if nothing found.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).find((value) => value === 2); // { key: 'b', value: 2 }\n   * new Super([1, 2, 3]).find((value) => value === 2);            // { key: 1, value: 2 }\n   */\n  find(callback) {\n    validate([callback], ['function'], 'Super#find');\n\n    return iterate(this.$, (value, key, object) => {\n      if (callback(value, key, object)) {\n        return { key, value };\n      }\n    }) || null;\n  }\n\n  /**\n   * @method Super#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {DWrap} Returns this.\n   * @description Method for iterating over any object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).forEach((value, key, object) => {\n   *   object[key] = value * value;\n   * }).$; // { a: 1, b: { c: 4, d: 5 } }\n   */\n  forEach(callback) {\n    validate([callback], ['function'], 'Super#forEach');\n\n    iterate(this.$, (value, key, object) => {\n      callback(value, key, object);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#freeze\n   * @public\n   * @returns {DWrap} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n   * @description Synonym for\n   * [Object.freeze]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).freeze(); // Super\n   */\n  freeze() {\n    Object.freeze(this.$);\n\n    return this;\n  }\n\n  /**\n   * @method Super#get\n   * @public\n   * @param {String|Object.<String, Function>} property - Either a string of a property or a getters object.\n   * @param {Function} [getter] - If a property parameter is a string this has to be a getter function.\n   * @returns {DWrap} Returns this.\n   * @description Method for defining getters.\n   *\n   * @example\n   * const object1 = new Super({}).get('a', () => 1).$;\n   * object1.a; // 1\n   *\n   * const object2 = new Super({}).get({\n   *   a: () => 2\n   * }).$;\n   * object2.a; // 2\n   */\n  get(property, getter) {\n    if (arguments.length >= 2) {\n      property = { [property]: getter };\n    }\n\n    const object = this.$;\n\n    iterate(isObject(object) && new Super(property).$, (getter, property) => {\n      Object.defineProperty(object, property, { get: getter });\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#has\n   * @public\n   * @param {String|*} key - Property to check.\n   * @returns {Boolean} Returns true if the object has the key and false if not.\n   * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in\n   * @description Synonym for\n   * [\"in\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).has('b'); // true\n   */\n  has(key) {\n    const object = this.$;\n\n    if (!isObject(object)) {\n      return false;\n    }\n\n    return key in object;\n  }\n\n  /**\n   * @method Super#hasOwn\n   * @public\n   * @param {String|*} key - Property to check.\n   * @returns {Boolean} Returns true if the object has its own key and false if not.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\n   * @description Synonym for\n   * [Object#hasOwnProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).hasOwn('b');              // true\n   * new Super({ a: 1, b: 2, c: 3 }).hasOwn('hasOwnProperty'); // false\n   */\n  hasOwn(key) {\n    const object = this.$;\n\n    if (!isObject(object)) {\n      return false;\n    }\n\n    return {}.hasOwnProperty.call(object, key);\n  }\n\n  /**\n   * @method Super#instanceof\n   * @public\n   * @param {Function} constructor - Constructor to check.\n   * @returns {Boolean} If the object is an instance of constructor.\n   * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof\n   * @description Synonym for\n   * [\"instanceof\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}.\n   */\n  instanceof(constructor) {\n    return this.$ instanceof constructor;\n  }\n\n  /**\n   * @method Super#isFrozen\n   * @public\n   * @returns {Boolean} If the object is frozen.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n   * @description Synonym for\n   * [Object.isFrozen]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen}.\n   *\n   * @example\n   * new Super({}).freeze().isFrozen(); // true\n   */\n  isFrozen() {\n    return Object.isFrozen(this.$);\n  }\n\n  /**\n   * @method Super#json\n   * @public\n   * @param {JSONCallback|String[]} [replacer] - See the link.\n   * @param {String|Number} [space] - See the link.\n   * @returns {String} JSON string.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n   * @description Synonym for\n   * [JSON.stringify]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).json(); // '{\"a\":1,\"b\":2,\"c\":3}'\n   * new Super({ a: 1, b: 2, c: 3 }).json('    ');\n   * // {\n   * //     \"a\": 1,\n   * //     \"b\": 2,\n   * //     \"c\": 3\n   * // }\n   * new Super({ a: 1, b: 2, c: 3 }).json((key, value) => {\n   *   if (typeof value === 'number') {\n   *     return value%2 ? key + value0 : undefined;\n   *   }\n   *\n   *   return value;\n   * }, 2);\n   * // {\n   * //   \"a\": \"a1\",\n   * //   \"c\": \"c3\"\n   * // }\n   */\n  json(replacer, space) {\n    if (arguments.length === 1 && !isFunction(replacer) && !isArray(replacer)) {\n      [].unshift.call(arguments, null);\n    }\n\n    [].unshift.call(arguments, this.$);\n\n    return JSON.stringify.apply(JSON, arguments);\n  }\n\n  /**\n   * @method Super#keyOf\n   * @public\n   * @param {*} value - Value to find.\n   * @returns {String|Number|null} A key or an index if found and null if not.\n   * @description Method for finding equal to the argument value in the object. NaNs are considered to be equal.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).keyOf(2);   // 'b'\n   * new Super({ a: 1, b: 2, c: 3 }).keyOf('2'); // 'b'\n   */\n  keyOf(value) {\n    const key = iterate(this.$, (val, key) => {\n      if (val == value || (isNaN(val) && isNaN(value))) {\n        return key;\n      }\n    });\n\n    return isUndefined(key) ? null : key;\n  }\n\n  /**\n   * @method Super#keyOfStrict\n   * @public\n   * @param {*} value - Value to find.\n   * @returns {String|Number|null} A key or an index if found and null if not.\n   * @description Method for finding strict equal to the argument value in the object. NaNs are considered to be equal.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict(2);   // 'b'\n   * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict('2'); // 'b'\n   */\n  keyOfStrict(value) {\n    const key = iterate(this.$, (val, key) => {\n      if (val === value || (isNaN(val) && isNaN(value))) {\n        return key;\n      }\n    });\n\n    return isUndefined(key) ? null : key;\n  }\n\n  /**\n   * @method Super#keys\n   * @public\n   * @returns {DWrap} A wrap of the keys array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n   * @description Synonym for\n   * [Object.keys]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).keys().$; // ['a', 'b', 'c']\n   * new Super(null).keys().$;                 // []\n   */\n  keys() {\n    const object = this.$;\n\n    return D(isObject(object) ? Object.keys(object) : []);\n  }\n\n  /**\n   * @method Super#map\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * Return value is used for creating a new object.\n   * @returns {DWrap} D-Wrap of the new object.\n   * @description Returns a wrap of a new object using the callback.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).map((value) => value * 2).$; // { a: 2, b: 4, c: 6 }\n   * new Super(null).map((value) => value * 2).$;                 // null\n   */\n  map(callback) {\n    validate([callback], ['function'], 'Super#map');\n\n    const object = this.$;\n    const o = isArrayLike(object) ? [] : isNull(object) ? null : {};\n\n    iterate(object, (value, key) => {\n      o[key] = callback(value, key, object);\n    });\n\n    return D(o);\n  }\n\n  /**\n   * @method Super#max\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * Return value is used for comparison with the previous max value.\n   * @returns {{key: Key, value: Number}} Object with max value and key of the max value.\n   * @description Method for finding max value in the object.\n   * If no callback is present comparison is between values of the object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).max();                     // { key: 'c', value: 3 }\n   * new Super({ a: 1, b: 2, c: 3 }).max((value) => 4 - value); // { key: 'a', value: 3 }\n   * new Super({ a: 'a', b: 'b', c: 'c' }).max();               // { key: null, value: -Infinity }\n   */\n  max(callback = null) {\n    validate([callback], ['function||!'], 'Super#max');\n\n    return this.object((max, value, key, object) => {\n      const val = Number(callback ? callback(value, key, object) : value);\n\n      if (val > max.value) {\n        max.key = key;\n        max.value = val;\n      }\n    }, { key: null, value: -Infinity }).$;\n  }\n\n  /**\n   * @method Super#min\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * Return value is used for comparison with the previous min value.\n   * @returns {{key: Key, value: Number}} Object with min value and key of the min value.\n   * @description Method for finding min value in the object.\n   * If no callback is present comparison is between values of the object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).min();                     // { key: 'a', value: 1 }\n   * new Super({ a: 1, b: 2, c: 3 }).min((value) => 4 - value); // { key: 'c', value: 1 }\n   * new Super({ a: 'a', b: 'b', c: 'c' }).min();               // { key: null, value: Infinity }\n   */\n  min(callback = null) {\n    validate([callback], ['function||!'], 'Super#min');\n\n    return this.object((min, value, key, object) => {\n      const val = Number(callback ? callback(value, key, object) : value);\n\n      if (val < min.value) {\n        min.key = key;\n        min.value = val;\n      }\n    }, { key: null, value: Infinity }).$;\n  }\n\n  /**\n   * @method Super#object\n   * @public\n   * @param {ObjectCallback} callback - Called on each iteration.\n   * @param {Object|*} [object = {}] - Object that is passed to the callback.\n   * @returns {DWrap} Wrap of the new object.\n   * @description Type of {@link Super#reduce}.\n   * The object is passed as an argument into the callback. The output is this object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2 }).object((object, value, key) => {\n   *   object[key] = value;\n   *   object[key + key] = value * 2;\n   * }).$; // { a: 1, aa: 2, b: 2, bb: 4 }\n   */\n  object(callback, object = {}) {\n    validate([callback], ['function'], 'Super#object');\n\n    iterate(this.$, (value, key, obj) => {\n      callback(object, value, key, obj);\n    });\n\n    return D(object);\n  }\n\n  /**\n   * @method Super#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {DWrap|*} Returns this if it's a setter or a value if getter.\n   * @description Method for getting and setting properties.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).prop('a');              // 1\n   * new Super({ a: 1, b: 2, c: 3 }).prop('a', 7).$;         // { a: 7, b: 2, c: 3 }\n   * new Super({ a: 1, b: 2, c: 3 }).prop({ a: 7, b: 8 }).$; // { a: 7, b: 8, c: 3 }\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this.$ ? this.$[property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.assign(property);\n  }\n\n  /**\n   * @method Super#propertyDescriptor\n   * @public\n   * @param {String} property - Property of the object.\n   * @returns {Object|undefined} Property descriptor.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n   * @descriptor Synonym for\n   * [Object.getOwnPropertyDescriptor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor}.\n   *\n   * @example\n   * new Super({ a: 1 }).propertyDescriptor('a');\n   * // {\n   * //   value: 1,\n   * //   enumerable: true,\n   * //   writable: true,\n   * //   configurable: true\n   * // }\n   */\n  propertyDescriptor(property) {\n    const object = this.$;\n\n    return isObject(object) ? Object.getOwnPropertyDescriptor(object, property) : undefined;\n  }\n\n  /**\n   * @method Super#propertyNames\n   * @public\n   * @returns {DWrap} D-Wrap of the names array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n   * @descriptor Synonym for\n   * [Object.getOwnPropertyNames]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames}.\n   *\n   * @example\n   * new Super({ a: 1, b: 2 }).define('c', { value: 3 }).$; // ['a', 'b', 'c']\n   */\n  propertyNames() {\n    const object = this.$;\n\n    return D(isObject(object) ? Object.getOwnPropertyNames(object) : []);\n  }\n\n  /**\n   * @method Super#propertySymbols\n   * @public\n   * @returns {DWrap} D-Wrap of the names array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n   * @descriptor Synonym for\n   * [Object.getOwnPropertySymbols]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols}.\n   *\n   * @example\n   * new Super({ [Symbol('foo')]: 1 }).define(Symbol('bar'), { value: 2 }).$; // [Symbol('foo'), Symbol('bar')]\n   */\n  propertySymbols() {\n    const object = this.$;\n\n    return D(isObject(object) ? Object.getOwnPropertySymbols(object) : []);\n  }\n\n  /**\n   * @method Super#proto\n   * @public\n   * @param {*} [proto] - If it's present it's set as a prototype to the object.\n   * @returns {DWrap} In getter mode returns wrap of the prototype and in setter mode returns this.\n   * @description Synonym for both\n   * [Object.getPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf}\n   * and\n   * [Object.setPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf}.\n   */\n  proto(proto) {\n    const object = this.$;\n    const isContextObject = !isNil(object);\n\n    if (arguments.length) {\n      if (isContextObject && (isObject(proto) || isNull(proto))) {\n        Object.setPrototypeOf(object, proto);\n      }\n\n      return this;\n    }\n\n    return isContextObject ? new Super(Object.getPrototypeOf(object)) : new Super();\n  }\n\n  /**\n   * @method Super#reduce\n   * @public\n   * @param {ReduceCallback} callback - Called on each iteration.\n   * Return value is passed to the next callback call.\n   * @param {*} [IV = <first value>|undefined] - Initial value.\n   * @returns {*} Modified IV.\n   * @description Returns modified IV. If the second argument is not present first value in the object is taken\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).reduce((sum, value) => sum + value * value, 0); // 14\n   */\n  reduce(callback, IV) {\n    validate([callback], ['function'], 'Super#reduce');\n\n    const object = this.$;\n\n    let startKey;\n\n    if (arguments.length === 1) {\n      iterate(object, (value, key) => {\n        startKey = key;\n        IV = value;\n\n        return true;\n      });\n    }\n\n    iterate(object, (value, key) => {\n      if (key !== startKey) {\n        IV = callback(IV, value, key, object);\n      }\n    });\n\n    return IV;\n  }\n\n  /**\n   * @method Super#set\n   * @public\n   * @param {String|Object.<String, Function>} property - Either a string of a property or a setters object.\n   * @param {Function} [setter] - If a property parameter is a string this has to be a setter function.\n   * @returns {DWrap} Returns this.\n   * @description Method for defining setters.\n   *\n   * @example\n   * const object = new Super({})\n   *   .get('public', function () {\n   *     return this._private;\n   *   })\n   *   .set('public', function (value) {\n   *     if (typeof value === 'number') {\n   *       this._private = value;\n   *     }\n   *   });\n   * object.prop('public', '1').$; // { public: undefined }\n   * object.prop('public', 1).$;   // { public: 1, _private: 1 }\n   *\n   * new Super({}).set({\n   *   public(value) {\n   *     if (typeof value === 'number') {\n   *       this._private = value;\n   *     }\n   *   }\n   * });\n   */\n  set(property, setter) {\n    if (arguments.length >= 2) {\n      property = { [property]: setter };\n    }\n\n    const object = this.$;\n\n    iterate(isObject(object) && new Super(property).$, (setter, property) => {\n      Object.defineProperty(object, property, { set: setter });\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#some\n   * @public\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\n   * If returns truthy iteration stops and if falsey it continues.\n   * @returns {Boolean} If all the callback calls returned truthy value.\n   * @description Returns true if some of the callback calls returned truthy value. Otherwise false.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).some((value) => value > 4); // false\n   * new Super({}).some(() => true);                             // false\n   */\n  some(callback = Boolean) {\n    validate([callback], ['function'], 'Super#some');\n\n    return iterate(this.$, (value, key, object) => {\n      if (callback(value, key, object)) {\n        return true;\n      }\n    }) || false;\n  }\n\n  /**\n   * @method Super#strictEquals\n   * @public\n   * @param {*} [object] - Object to compare.\n   * @returns {Boolean} If the objects are equal or not.\n   * @description Returns true if objects are equal using '===' operator and false if not.\n   * NaNs are considered to be strict equal.\n   *\n   * @example\n   * new Super(3).strictEquals('3');   // false\n   * new Super(NaN).strictEquals(NaN); // true\n   */\n  strictEquals(object) {\n    const o = this.$;\n\n    object = new Super(object).$;\n\n    return o === object || (isNaN(o) && isNaN(object));\n  }\n\n  /**\n   * @method Super#sum\n   * @public\n   * @param {IterationCallback} [callback = null] - Called on each iteration.\n   * @returns {Number} Sum.\n   * @description Type of {@link Super#reduce}.\n   * If the callback is present it's used for summing. If not the value is used.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).sum();                         // 6\n   * new Super({ a: 1, b: 2, c: 3 }).sum((value) => value * value); // 14\n   */\n  sum(callback = null) {\n    validate([callback], ['function||!'], 'Super#sum');\n\n    return this.reduce((sum, value, key, object) => (\n      sum + Number(callback ? callback(value, key, object) : value)\n    ), 0);\n  }\n\n  toJSON() {\n    return this.$;\n  }\n\n  /**\n   * @member Super#toStringTag\n   * @type {String}\n   * @public\n   * @readonly\n   * @description Returns toString tag of the object.\n   *\n   * @example\n   * new Super({}).toStringTag; // 'Object'\n   * new Super([]).toStringTag; // 'Array'\n   * new Super(1).toStringTag;  // 'Number'\n   */\n  get toStringTag() {\n    return toStringTag(this.$);\n  }\n\n  /**\n   * @member Super#type\n   * @type {String}\n   * @public\n   * @readonly\n   * @description Synonym for\n   * [\"typeof\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}..\n   *\n   * @example\n   * new Super({}).type;   // 'object'\n   * new Super(1).type;    // 'number'\n   * new Super('1').type;  // 'string'\n   * new Super(true).type; // 'boolean'\n   */\n  get type() {\n    return typeof this.$;\n  }\n\n  /**\n   * @method Super#value\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or a values object.\n   * @param {Object.<String, *>} [value] - If a property parameter is a string this has to be a value to be set.\n   * @returns {DWrap} Returns this.\n   * @description Method for defining non-enumerable, non-writable, non-configurable values.\n   * Synonym for object.define(property, { value: value }).\n   *\n   * @example\n   * new Super({}).value('a', 1).$; // { a: 1 }\n   * new Super({}).value({\n   *   a: 1\n   * }).$;                          // { a: 1 }\n   */\n  value(property, value) {\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    const object = this.$;\n\n    iterate(isObject(object) && new Super(property).$, (value, property) => {\n      Object.defineProperty(object, property, { value });\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Super#values\n   * @public\n   * @returns {DWrap} A wrap of the values array.\n   * @description Returns D-Wrap of the values array.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).values().$; // [1, 2, 3]\n   * new Super(null).values().$;                 // []\n   */\n  values() {\n    const array = [];\n\n    iterate(this.$, (value) => {\n      array.push(value);\n    });\n\n    return D(array);\n  }\n\n  /**\n   * @method Super#word\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {String} Concatenated string.\n   * @description Type of {@link Super#reduce}.\n   * If the callback is present it's used for concatenating. If not the value is used.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).word();                         // '123'\n   * new Super({ a: 1, b: 2, c: 3 }).word((value) => value + value); // '112233'\n   */\n  word(callback = null) {\n    validate([callback], ['function||!'], 'Super#word');\n\n    return this.reduce((word, value, key, object) => (\n      word + String(callback ? callback(value, key, object) : value)\n    ), '');\n  }\n}\n\ndefineProperties(Super.prototype, {\n  [Symbol.toStringTag]: 'Super'\n});\n\n/**\n * @function deepAssign\n * @private\n * @param {*} target - Object to assign properties to.\n * @param {*} object - Object to assign properties from.\n * @returns {void}\n */\nfunction deepAssign(target, object) {\n  iterate(object, (value, key) => {\n    if (isPrimitive(target[key]) || !{}.hasOwnProperty.call(target, key)) {\n      target[key] = deepClone(value);\n\n      return;\n    }\n\n    if (!isPrimitive(target[key])) {\n      deepAssign(target[key], value);\n    }\n  });\n}\n\n/**\n * @function deepClone\n * @private\n * @param {*} object - Object to clone.\n * @description Does the deep cloning.\n */\nfunction deepClone(object) {\n  const clone = cloneSwitcher(object, [object, true]);\n\n  if (clone !== object) {\n    iterate(object, (value, key) => {\n      clone[key] = deepClone(value);\n    });\n  }\n\n  return clone;\n}\n\n/**\n * @function deepEqual\n * @private\n * @param {*} o1 - First object to compare.\n * @param {*} o2 - Second object to compare.\n * @param {Boolean} strict - If comparison should be strict or not.\n * @returns {Boolean} - If the object are deep equal or not.\n */\nfunction deepEqual(o1, o2, strict) {\n  if (o1 === o2) {\n    return true;\n  }\n\n  if (isNaN(o1) && isNaN(o2) && isPrimitive(o1) && isPrimitive(o2)) {\n    return true;\n  }\n\n  if (isNaN(o1) || isNaN(o2)) {\n    return false;\n  }\n\n  if (isPrimitive(o1) || isPrimitive(o2)) {\n    return strict ? o1 === o2 : o1 == o2;\n  }\n\n  if (isDate(o1) && isDate(o2)) {\n    return o1.getTime() === o2.getTime();\n  }\n\n  if (isDate(o1) || isDate(o2)) {\n    return false;\n  }\n\n  if (isRegExp(o1) && isRegExp(o2)) {\n    return o1.source === o2.source &&\n      o1.toString().match(/[gimuy]*$/)[0] === o2.toString().match(/[gimuy]*$/)[0] &&\n      o1.lastIndex === o2.lastIndex;\n  }\n\n  if (isRegExp(o1) || isRegExp(o2)) {\n    return false;\n  }\n\n  if ((!isPlainObject(o1) && !isArray(o1)) || (!isPlainObject(o2) && !isArray(o2))) {\n    return false;\n  }\n\n  const p1 = Object.getPrototypeOf(o1);\n  const p2 = Object.getPrototypeOf(o1);\n\n  if (Object.keys(o1).length !== Object.keys(o2).length) {\n    return false;\n  }\n\n  if (p1 && p2 && (toStringTag(p1.constructor) !== toStringTag(p2.constructor))) {\n    return false;\n  }\n\n  return iterate(o1, (value, key) => {\n    if (!(key in o2) || !deepEqual(value, o2[key], strict)) {\n      return false;\n    }\n  }) !== false;\n}\n\n/**\n * @function deepEvery\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * If returns truthy the iteration goes on and if not it stops.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {Boolean} - If all the callback calls returned truthy value.\n */\nfunction deepEvery(object, callback, n, tree) {\n  const end = n === 1;\n\n  return iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    if (\n      end || isPrimitive(value)\n        ? !callback(value, key, object, newTree)\n        : !deepEvery(value, callback, n - 1, newTree)\n    ) {\n      return false;\n    }\n  }) !== false;\n}\n\n/**\n * @function deepFilter\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * If returns truthy the element is included in the output and if not it's excluded.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {*} Filtered object.\n */\nfunction deepFilter(object, callback, n, tree) {\n  const array = isArrayLike(object);\n  const nul = isNil(object);\n  const o = array ? [] : nul ? object : {};\n  const end = n === 1;\n\n  iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    if ((end || isPrimitive(value)) && callback(value, key, object, newTree)) {\n      if (array) {\n        o.push(value);\n      } else {\n        o[key] = value;\n      }\n\n      return;\n    }\n\n    if (!end) {\n      const filtered = deepFilter(value, callback, n - 1, newTree);\n\n      if (filtered) {\n        if (array) {\n          o.push(filtered);\n        } else {\n          o[key] = filtered;\n        }\n      }\n    }\n  });\n\n  if (array) {\n    return o.length ? o : undefined;\n  }\n\n  if (!nul) {\n    return Object.keys(o).length ? o : undefined;\n  }\n\n  return o;\n}\n\n/**\n * @function deepFind\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * If returns truthy the iteration stops and if not it continues.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {Tree|null} - If found the whole tree is returned and if not it's null what's returned.\n */\nfunction deepFind(object, callback, n, tree) {\n  const end = n === 1;\n\n  return iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    if (end || isPrimitive(value)) {\n      if (callback(value, key, object, newTree)) {\n        return newTree;\n      }\n\n      return;\n    }\n\n    const result = deepFind(value, callback, n - 1, newTree);\n\n    if (result) {\n      return result;\n    }\n  }) || null;\n}\n\n/**\n * @function deepForEach\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {void}\n */\nfunction deepForEach(object, callback, n, tree) {\n  const end = n === 1;\n\n  iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    if (end || isPrimitive(value)) {\n      callback(value, key, object, newTree);\n    } else {\n      deepForEach(value, callback, n - 1, newTree);\n    }\n  });\n}\n\n/**\n * @function deepForEachEntry\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {void}\n */\nfunction deepForEachEntry(object, callback, n, tree) {\n  const end = n === 1;\n\n  iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    callback(value, key, object, newTree);\n\n    if (!end && !isPrimitive(value)) {\n      deepForEachEntry(value, callback, n - 1, newTree);\n    }\n  });\n}\n\n/**\n * @function deepFreeze\n * @private\n * @param {*} object - Object to freeze.\n * @returns {void}\n */\nfunction deepFreeze(object) {\n  Object.freeze(object);\n  iterate(object, deepFreeze);\n}\n\n/**\n * @function deepMap\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * Returned value is used to create to new object.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {*} New object.\n */\nfunction deepMap(object, callback, n, tree) {\n  const o = isArrayLike(object) ? [] : isNil(object) ? object : {};\n  const end = n === 1;\n\n  iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    o[key] = end || isPrimitive(value)\n      ? callback(value, key, object, newTree)\n      : deepMap(value, callback, n - 1, newTree);\n  });\n\n  return o;\n}\n\n/**\n * @function deepReduce\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepReduceCallback} callback - Callback that is called on every element.\n * Returned value is used to create to new object.\n * @param {Number} n - Depth of iteration.\n * @param {Boolean} start - If callback was called already or not.\n * @param {{ IV: * }|undefined} IV - If callback was called already or not.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {{ IV: * }} Transformed IV.\n */\nfunction deepReduce(object, callback, n, start, IV, tree) {\n  const end = n === 1;\n\n  iterate(object, (value, key, object) => {\n    if (!IV && (end || isPrimitive(value)) && !start) {\n      IV = { IV: value };\n      start = true;\n\n      return;\n    }\n\n    const newTree = [{ key, value }].concat(tree);\n\n    IV = end || isPrimitive(value)\n      ? { IV: callback(IV.IV, value, key, object, newTree) }\n      : deepReduce(value, callback, n - 1, start, IV, newTree);\n  });\n\n  return IV;\n}\n\n/**\n * @function deepSome\n * @private\n * @param {*} object - Object to iterate over.\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\n * If returns truthy the iteration stops and if not it continues.\n * @param {Number} n - Depth of iteration.\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\n * @returns {Boolean} - If some of the callback calls returned truthy value.\n */\nfunction deepSome(object, callback, n, tree) {\n  const end = n === 1;\n\n  return iterate(object, (value, key, object) => {\n    const newTree = [{ key, value }].concat(tree);\n\n    if (\n      end || isPrimitive(value)\n        ? callback(value, key, object, newTree)\n        : deepSome(value, callback, n - 1, newTree)\n    ) {\n      return true;\n    }\n  }) || false;\n}\n\nconstructors[0].push({\n  check: () => true,\n  cls: Super\n});\n\nexport { Super };\n","/**\n * @module Func\n * @private\n * @mixin\n * @description Exports Func class.\n */\n\nimport { Super } from './Super';\nimport { Promise } from './Promise';\nimport { constructors } from './constants';\nimport { isFunction, validate, toArray, Symbol, defineProperties, iterate } from './helpers';\n\n/**\n * @callback BeforeMiddleware\n * @param {Array} args - Previous arguments.\n * @param {Func} func - This function.\n * @returns {Array} - New arguments.\n */\n\n/**\n * @callback AfterMiddleware\n * @param {*} returnValue - Previous return value.\n * @param {Func} func - This function.\n * @returns {*} - New return value.\n */\n\n/**\n * @class Func\n * @extends Super\n * @public\n * @param {Function} [func = function () {}] - Function to wrap.\n * @returns {Func} Instance of Func.\n * @description A wrap of a function.\n *\n * @example\n * const func = new Func(Math.max);\n *\n * func(1, 4, -2, 5); // 5\n */\nclass Func extends Super {\n  constructor(func = () => {}) {\n    super();\n\n    function proxy() {\n      if (++proxy.$$.called < proxy.$$.canBeCalled) {\n        const { before, after, sync, contextLocked } = proxy.$$;\n        let { context, args } = proxy.$$;\n        let ret;\n\n        context = contextLocked ? context : context || this;\n        args = args.concat(toArray(arguments));\n\n        if (sync) {\n          iterate(before, (middleware) => {\n            args = middleware.call(context, toArray(args), proxy);\n          });\n\n          ret = func.apply(context, toArray(args));\n\n          iterate(after, (middleware) => {\n            ret = middleware.call(context, ret, proxy);\n          });\n\n          return ret;\n        }\n\n        let promise = Promise.resolve(args);\n\n        iterate(before, (middleware) => {\n          promise = promise.then((args) => middleware.call(context, toArray(args), proxy));\n        });\n\n        promise = promise.then((args) => func.apply(context, toArray(args)));\n\n        iterate(after, (middleware) => {\n          promise = promise.then((ret) => middleware.call(context, ret, proxy));\n        });\n\n        return promise;\n      }\n    }\n\n    /**\n     * @member {Object} Func#$$\n     * @type {Object}\n     * @protected\n     * @property {Array} after - After middleware array.\n     * @property {Array} args - Locked and bound arguments.\n     * @property {Array} argsLocked - Locked arguments.\n     * @property {Array} before - Before middleware array.\n     * @property {Number} called - How many times the function was called.\n     * @property {Number} canBeCalled - How many times the function can be actually called.\n     * @property {*} context - Locked or bound context.\n     * @property {Boolean} contextLocked - Is context locked or not.\n     * @property {Boolean} sync - Is function synchronous or not.\n     * @description Config parameters.\n     */\n    Object.defineProperty(proxy, '$$', {\n      value: {\n        after: [],\n        args: [],\n        argsLocked: [],\n        before: [],\n        called: 0,\n        canBeCalled: Infinity,\n        context: null,\n        contextLocked: false,\n        sync: true\n      }\n    });\n\n    /**\n     * @member {Function} Func#$\n     * @type {Function}\n     * @public\n     * @description Original function.\n     */\n    Object.defineProperty(proxy, '$', { value: func });\n    Object.setPrototypeOf(proxy, Func.prototype);\n\n    return proxy;\n  }\n\n  /**\n   * @method Func#after\n   * @public\n   * @param {AfterMiddleware} middleware - After middleware.\n   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put middleware.\n   * Truthy parameter stands for \"to the end\" and falsey for \"to the beginning\".\n   * @returns {Func} Returns this.\n   * @description Adds after middleware.\n   *\n   * @example\n   * const func = new Func((a) => a + 1)\n   *   .after((result) => result * result);\n   *\n   * func(4);  // 25\n   * func(-4); // 9\n   */\n  after(middleware, afterAll = true) {\n    validate([middleware], ['function'], 'Func#after');\n\n    const { after } = this.$$;\n\n    if (afterAll) {\n      after.push(middleware);\n    } else {\n      after.unshift(middleware);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Func#apply\n   * @public\n   * @param {*} [context] - Context to call with.\n   * @param {(Array|Arguments)} [args] - Arguments to call with.\n   * @returns {*} Return of function call.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\n   * @description Synonym for\n   * [Function#apply]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply}.\n   */\n  apply(context, args) {\n    return (() => {}).apply.apply(this, arguments);\n  }\n\n  /**\n   * @method Func#async\n   * @public\n   * @param {Boolean|*} [condition] - If the function should be synchronous or not.\n   * @returns {Func} Returns this.\n   * @description If the function should be synchronous or not.\n   *\n   * @example\n   * const func = new Func((a) => a + 1).async();\n   *\n   * func(4).then((result) => {\n   *   console.log(result); // 5\n   * });\n   */\n  async(condition = true) {\n    this.$$.sync = !condition;\n\n    return this;\n  }\n\n  /**\n   * @method Func#before\n   * @public\n   * @param {BeforeMiddleware} middleware - Before middleware.\n   * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put middleware.\n   * Truthy parameter stands for \"to the beginning\" and falsey for \"to the end\".\n   * @returns {Func} Returns this.\n   * @description Adds before middleware.\n   *\n   * @example\n   * const func = new Func((a) => a + 1)\n   *   .before(([arg]) => [arg * arg]);\n   *\n   * func(4); // 17\n   * func(3); // 10\n   */\n  before(middleware, beforeAll = true) {\n    validate([middleware], ['function'], 'Func#before');\n\n    const { before } = this.$$;\n\n    if (beforeAll) {\n      before.unshift(middleware);\n    } else {\n      before.push(middleware);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Func#bind\n   * @public\n   * @param {*} context - Context to bind.\n   * @param {...(Array|Arguments|*)} args - Arguments to bind.\n   * @returns {Func} Returns this.\n   * @description Composition of {@link Func#bindContext} and {@link Func#bindArgs}.\n   *\n   * @example\n   * const func = new Func(function (a, b) {\n   *   return this.a + a + b;\n   * }).bind({ a: 2 }, 1);\n   *\n   * func(1); // 4\n   * func(3); // 6\n   */\n  bind(context, ...args) {\n    return this\n      .bindContext(context)\n      .bindArgs(args);\n  }\n\n  /**\n   * @method Func#bindArgs\n   * @public\n   * @param {(Array|Arguments)} args - Arguments to bind.\n   * @returns {Func} Returns this.\n   * @description Binds arguments in addition to already locked and bound ones.\n   *\n   * @example\n   * const func = new Func((...args) => {\n   *   let sum = 0;\n   *\n   *   for (let i = 0; i < args.length; i++) {\n   *     sum += args[i];\n   *   }\n   *\n   *   return sum;\n   * });\n   *\n   * func(1, 2, 3); // 6\n   *\n   * func.bindArgs([4]);\n   *\n   * func(1, 2, 3); // 10\n   *\n   * func.bindArgs([5]);\n   *\n   * func(1, 2, 3); // 15\n   */\n  bindArgs(args) {\n    const func = this.$$;\n\n    func.args = func.args.concat(toArray(args));\n\n    return this;\n  }\n\n  /**\n   * @method Func#bindContext\n   * @public\n   * @param {*} context - Context to bind.\n   * @returns {Func} Returns this.\n   * @description Bind new context if it's not already locked.\n   *\n   * @example\n   * const func = new Func(function () {\n   *   return this.a;\n   * }).bindContext({ a: 1 });\n   *\n   * func(); // 1\n   *\n   * func.bindContext({ a: 2 });\n   *\n   * func(); // 2\n   */\n  bindContext(context) {\n    const func = this.$$;\n\n    if (!func.contextLocked) {\n      func.context = context;\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Func#call\n   * @public\n   * @param {*} [context] - Context to call with.\n   * @param {...*} [args] - Arguments to call with.\n   * @returns {*} Return of function call.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call\n   * @description Synonym for\n   * [Function#call]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call}.\n   */\n  call(context, ...args) {\n    return (() => {}).call.apply(this, arguments);\n  }\n\n  /**\n   * @member {Number} Func#called\n   * @public\n   * @readonly\n   * @description Returns how many times the function was called.\n   *\n   * @example\n   * const func = new Func((a) => a + 1);\n   *\n   * func();\n   * func();\n   *\n   * func.called // 2\n   */\n  get called() {\n    return this.$$.called;\n  }\n\n  /**\n   * @method Func#canBeCalled\n   * @public\n   * @param {Number} times - Number of maximum times the function is called (middlewares are also taken for a count).\n   * @returns {Func} Returns this.\n   * @description Method for limiting call times of function.\n   *\n   * @example\n   * const func = new Func((a) => a + 1)\n   *   .canBeCalled(1);\n   *\n   * func(1); // 2\n   * func(1); // undefined\n   */\n  canBeCalled(times) {\n    this.$$.canBeCalled = times;\n\n    return this;\n  }\n\n  /**\n   * @method Func#limitArgsTo\n   * @public\n   * @param {Number} number - Number of arguments to limit to.\n   * @returns {Func} Returns this.\n   * @description Built-in before middleware for limiting number of arguments\n   * that is put to the end of before middlewares.\n   *\n   * @example\n   * const func = new Func((a, b) => [a, b]);\n   *\n   * func(1, 2); // [1, 2]\n   *\n   * func.limitArgsTo(1);\n   *\n   * func(1, 2); // [1, undefined]\n   */\n  limitArgsTo(number) {\n    return this.before((args) => args.slice(0, number), false);\n  }\n\n  /**\n   * @method Func#lock\n   * @public\n   * @param {*} context - Context to lock.\n   * @param {(Array|Arguments|*)} args - Arguments to lock.\n   * @returns {Func} Returns this.\n   * @description Composition of {@link Func#lockContext} and {@link Func#lockArgs}.\n   *\n   * @example\n   * const func = new Func(function (a, b) {\n   *   return this.a + a + b;\n   * }).lock({ a: 2 }, [1]);\n   *\n   * func(1); // 4\n   * func(3); // 6\n   */\n  lock(context, args) {\n    return this\n      .lockContext(context)\n      .lockArgs(args);\n  }\n\n  /**\n   * @method Func#lockArgs\n   * @public\n   * @param {(Array|Arguments|*)} args - Arguments to lock.\n   * @returns {Func} Returns this.\n   * @description Erases bound arguments and adds new arguments to already locked ones.\n   *\n   * @example\n   * const func = new Func((...args) => {\n   *   let sum = 0;\n   *\n   *   for (let i = 0; i < args.length; i++) {\n   *     sum += args[i];\n   *   }\n   *\n   *   return sum;\n   * });\n   *\n   * func(1, 2, 3); // 6\n   *\n   * func.lockArgs([4]);\n   *\n   * func(1, 2, 3); // 10\n   *\n   * func.bindArgs([6, 7]);\n   * func.lockArgs([5]);\n   *\n   * func(1, 2, 3); // 15\n   */\n  lockArgs(args) {\n    const func = this.$$;\n\n    func.args = func.argsLocked = func.argsLocked.concat(toArray(args));\n\n    return this;\n  }\n\n  /**\n   * @method Func#lockContext\n   * @public\n   * @param {*} context - Context to lock.\n   * @returns {Func} Returns this.\n   * @description Locks context if it's not already locked.\n   *\n   * @example\n   * const func = new Func(function () {\n   *   return this.a;\n   * }).lockContext({ a: 1 });\n   *\n   * func(); // 1\n   *\n   * func.lockContext({ a: 2 });\n   *\n   * func(); // 1\n   */\n  lockContext(context) {\n    const func = this.$$;\n\n    if (!func.contextLocked) {\n      func.context = context;\n      func.contextLocked = true;\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Func#timing\n   * @public\n   * @param {String} mark - Argument that is passed to console.time() and console.timeEnd().\n   * By default name of the original function, or if it's not present, 'anonymous' is used.\n   * @returns {Func} Returns this.\n   * @description Built-in before and after middlewares for noting calling time.\n   * In case of asynchronous functions it notes time between calling function and resolving or rejecting the result.\n   *\n   * @example\n   * const func = new Func((a) => a + 1)\n   *   .timing('plus 1');\n   *\n   * func(2); // plus 1: 0.010ms\n   *\n   * const async = new Func(() => new Promise(() => {\n   *     setTimeout(resolve, 1000);\n   *   }))\n   *   .async()\n   *   .timing();\n   *\n   * async();\n   * // After 1 second...\n   * // anonymous: 1000.010ms\n   */\n  timing(mark) {\n    mark = arguments.length ? String(mark) : this.$.name || 'anonymous';\n\n    this.before((args) => {\n      console.time(mark);\n\n      return args;\n    }, false);\n\n    this.after((ret) => {\n      console.timeEnd(mark);\n\n      return ret;\n    }, false);\n\n    return this;\n  }\n\n  toString() {\n    return (() => {}).toString.call(this.$);\n  }\n\n  /**\n   * @method Func#unbind\n   * @public\n   * @returns {Func} Returns this.\n   * @description Composition of {@link Func#unbindContext} and {@link Func#unbindArgs}.\n   *\n   * @example\n   * const func = new Func(function (a) {\n   *   return this.foo + ' & ' +  a;\n   * }).bind({ foo: 2 }, 1);\n   *\n   * func(); // '2 & 1'\n   *\n   * func.unbind();\n   *\n   * func(); // 'undefined & undefined'\n   */\n  unbind() {\n    return this\n      .unbindContext()\n      .unbindArgs();\n  }\n\n  /**\n   * @method Func#unbindArgs\n   * @public\n   * @returns {Func} Returns this.\n   * @description Erases all bound arguments.\n   *\n   * @example\n   * const func = new Func((...args) => {\n   *   let sum = 0;\n   *\n   *   for (let i = 0; i < args.length; i++) {\n   *     sum += args[i];\n   *   }\n   *\n   *   return sum;\n   * }).bindArgs([4, 5]);\n   *\n   * func(1, 2, 3); // 15\n   *\n   * func.unbindArgs();\n   *\n   * func(1, 2, 3); // 6\n   */\n  unbindArgs() {\n    const func = this.$$;\n\n    func.args = func.argsLocked;\n\n    return this;\n  }\n\n  /**\n   * @method Func#unbindContext\n   * @public\n   * @returns {Func} Returns this.\n   * @description Erases context if it's not locked.\n   *\n   * @example\n   * const func = new Func(function () {\n   *   return this.foo;\n   * }).bindContext({ foo: 1 });\n   *\n   * func(); // 1\n   *\n   * func.unbindArgs();\n   *\n   * func(); // undefined\n   */\n  unbindContext() {\n    const func = this.$$;\n\n    if (!func.contextLocked) {\n      func.context = null;\n    }\n\n    return this;\n  }\n}\n\ndefineProperties(Func.prototype, {\n  [Symbol.toStringTag]: 'Func'\n});\n\nconstructors[1].push({\n  check: isFunction,\n  cls: Func\n});\n\n/**\n * @function method\n * @public\n * @param {String} method - Method to call.\n * @param {(Array|Arguments|*)} args - Arguments to call the method with.\n * @returns {Function} Function that calls stated method with given arguments.\n * @description Function that returns the function\n * that calls stated method of its first argument with given arguments.\n *\n * @example\n * [1.2345, 2.789, 3.14].map(method('toFixed', [2])); // ['1.23', '2.79', '3.14']\n */\nfunction method(method, args = []) {\n  return (x) => x[method].apply(x, toArray(args));\n}\n\n/**\n * @function noop\n * @public\n * @returns {void}\n * @description Empty function.\n */\nfunction noop() {}\n\n/**\n * @function prop\n * @public\n * @param {String} prop - Property to return.\n * @returns {Function} Function that returns given property of its first argument.\n * @description Function that return the function that returns given property of its first argument.\n *\n * @example\n * ['foo', '12', '7890'].map(prop('length')); // [3, 2, 4]\n */\nfunction prop(prop) {\n  return ({ [prop]: value }) => value;\n}\n\n/**\n * @function self\n * @public\n * @returns {*} First argument itself.\n * @description Function that returns the first argument.\n *\n * @example\n * [1, 2].map(self);                     // [1, 2]\n * [1, 3, NaN, 0, 7, null].filter(self); // [1, 3, 7]\n */\nfunction self() {\n  return arguments[0];\n}\n\nexport { Func, method, noop, prop, self };\n","/**\n * @module Num\n * @private\n * @mixin\n * @description Exports Num class.\n */\n\nimport { Super } from './Super';\nimport { Func } from './Func';\nimport { Promise } from './Promise';\nimport { constructors } from './constants';\nimport {\n  isNumber, isFinite, toArray,\n  defineProperties, validate, Symbol\n} from './helpers';\n\nconst toRadian = Math.PI / 180;\nconst toDegree = 180 / Math.PI;\nconst ln2 = Math.LN2;\nconst ln10 = Math.LN10;\n\n/**\n * @class Num\n * @extends Super\n * @public\n * @param {Number} [number = 0] - A number to wrap.\n * @returns {Num} Instance of Num.\n * @description Wrap of a number.\n *\n * @example\n * const num = new Num(1);\n */\nclass Num extends Super {\n  constructor(number = 0) {\n    super(+number);\n\n    /**\n     * @member Num#$\n     * @type {Number}\n     * @public\n     * @description Original number.\n     */\n  }\n\n  /**\n   * @member Num#abs\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs\n   * @description Synonym for\n   * [Math.abs]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs}.\n   *\n   * @example\n   * new Num(1).abs;  // 1\n   * new Num(-1).abs; // 1\n   */\n  get abs() {\n    return Math.abs(this.$);\n  }\n\n  /**\n   * @method Num#acos\n   * @public\n   * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\n   * @returns {Number} Arccosine of the number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos\n   * @description Synonym for\n   * [Math.acos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos}.\n   */\n  acos(toDegrees) {\n    return (toDegrees ? toDegree : 1) * Math.acos(this.$);\n  }\n\n  /**\n   * @member Num#acosh\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\n   * @description Synonym for\n   * [Math.acosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh}.\n   */\n  get acosh() {\n    const number = this.$;\n\n    return Math.log(number + Math.sqrt(number * number - 1));\n  }\n\n  /**\n   * @member Num#asinh\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\n   * @description Synonym for\n   * [Math.asinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh}.\n   */\n  get asinh() {\n    const number = this.$;\n\n    return Math.log(number + Math.sqrt(number * number + 1));\n  }\n\n  /**\n   * @method Num#asin\n   * @public\n   * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\n   * @returns {Number} Arcsine of the number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin\n   * @description Synonym for\n   * [Math.asin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin}.\n   */\n  asin(toDegrees) {\n    return (toDegrees ? toDegree : 1) * Math.asin(this.$);\n  }\n\n  /**\n   * @method Num#atan\n   * @public\n   * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\n   * @returns {Number} Arcsine of the number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan\n   * @description Synonym for\n   * [Math.atan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan}.\n   */\n  atan(toDegrees) {\n    return (toDegrees ? toDegree : 1) * Math.atan(this.$);\n  }\n\n  /**\n   * @member Num#atanh\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\n   * @description Synonym for\n   * [Math.atanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh}.\n   */\n  get atanh() {\n    const number = this.$;\n\n    return Math.log((1 + number) / (1 - number)) / 2;\n  }\n\n  /**\n   * @member Num#cbrt\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt\n   * @description Synonym for\n   * [Math.cbrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt}.\n   */\n  get cbrt() {\n    const cbrt = Math.pow(Math.abs(this.$), 1 / 3);\n\n    return this.$ > 0 ? cbrt : -cbrt;\n  }\n\n  /**\n   * @member Num#ceil\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil\n   * @description Synonym for\n   * [Math.ceil]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil}.\n   *\n   * @example\n   * new Num(1.1).ceil;  // 2\n   * new Num(-1.1).ceil; // -1\n   */\n  get ceil() {\n    return Math.ceil(this.$);\n  }\n\n  /**\n   * @method Num#cos\n   * @public\n   * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\n   * @returns {Number} Cosine of the number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos\n   * @description Synonym for\n   * [Math.cos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos}.\n   */\n  cos(asDegrees) {\n    return Math.cos((asDegrees ? toRadian : 1) * this.$);\n  }\n\n  /**\n   * @member Num#cosh\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\n   * @description Synonym for\n   * [Math.cosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh}.\n   */\n  get cosh() {\n    const exp = this.exp;\n\n    return (exp + 1 / exp) / 2;\n  }\n\n  /**\n   * @member Num#cube\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description Cube of the number.\n   *\n   * @example\n   * new Num(2).cube;  // 8\n   * new Num(-3).ceil; // -27\n   */\n  get cube() {\n    return this.$ * this.$ * this.$;\n  }\n\n  /**\n   * @member Num#exp\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp\n   * @description Synonym for\n   * [Math.exp]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp}.\n   */\n  get exp() {\n    return Math.exp(this.$);\n  }\n\n  /**\n   * @member Num#floor\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor\n   * @description Synonym for\n   * [Math.floor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor}.\n   *\n   * @example\n   * new Num(1.1).floor;  // 1\n   * new Num(-1.1).floor; // -2\n   */\n  get floor() {\n    return Math.floor(this.$);\n  }\n\n  /**\n   * @method Num#interval\n   * @public\n   * @param {Function} func - Function that is called every <number> milliseconds.\n   * @param {Array} [args] - Arguments passed to the function.\n   * @returns {Function} Function that aborts the interval. The context of the function (if it's not already bound)\n   * is the object with the abort method.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/setInterval\n   * @description Analogue of the\n   * [setInterval]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setInterval}.\n   *\n   * @example\n   * const times = 0;\n   * new Num(50).interval(function () {\n   *   if (++times === 10) {\n   *     this.abort();\n   *   }\n   * });\n   */\n  interval(func, args = []) {\n    validate([func], ['function'], 'Num#interval');\n\n    func = new Func(func).bindContext({ abort });\n    args = toArray(args);\n\n    const number = this.$;\n\n    let aborted;\n    let timeout = setTimeout(function interval() {\n      if (!aborted) {\n        func.apply(null, args);\n\n        if (!aborted) {\n          timeout = setTimeout(interval, number);\n        }\n      }\n    }, 0);\n\n    return abort;\n\n    function abort() {\n      aborted = true;\n\n      return clearTimeout(timeout);\n    }\n  }\n\n  /**\n   * @member Num#ln\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log\n   * @description Synonym for\n   * [Math.log]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log}.\n   */\n  get ln() {\n    return Math.log(this.$);\n  }\n\n  /**\n   * @method Num#log\n   * @public\n   * @param {Number} number - Number to get logarithm of.\n   * @returns {Number} Logarithm of the argument number to the number base.\n   * @description Returns the logarithm of the argument number to the number base.\n   *\n   * @example\n   * new Num(2).log(16);  // 4\n   * new Num(3).log(243); // 5\n   */\n  log(number) {\n    return Math.log(number) / Math.log(this.$);\n  }\n\n  /**\n   * @member Num#log2\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2\n   * @description Synonym for\n   * [Math.log2]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2}.\n   */\n  get log2() {\n    return this.ln / ln2;\n  }\n\n  /**\n   * @member Num#log10\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\n   * @description Synonym for\n   * [Math.log10]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10}.\n   */\n  get log10() {\n    return this.ln / ln10;\n  }\n\n  /**\n   * @method Num#pow\n   * @public\n   * @param {Number} power - Power the number should be raised to.\n   * @returns {Number} The number to the <power> power.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow\n   * @description Synonym for\n   * [Math.pow]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow}.\n   *\n   * @example\n   * new Num(4).pow(.5); // 2\n   * new Num(3).pow(2);  // 9\n   */\n  pow(power) {\n    return Math.pow(this.$, power);\n  }\n\n  /**\n   * @method Num#root\n   * @public\n   * @param {Number} power - Power the number should be raised to.\n   * @returns {Number} The <power> root of the number.\n   * @description Synonym for number.pow(1 / power);\n   *\n   * @example\n   * new Num(4).root(2);   // 0.5\n   * new Num(243).root(5); // 3\n   */\n  root(power) {\n    return Math.pow(this.$, 1 / power);\n  }\n\n  /**\n   * @member Num#round\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n   * @description Synonym for\n   * [Math.round]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round}.\n   *\n   * @example\n   * new Num(1.1).floor;  // 1\n   * new Num(-1.1).floor; // -1\n   * new Num(1.5).floor;  // 2\n   */\n  get round() {\n    return Math.round(this.$);\n  }\n\n  /**\n   * @member Num#sign\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n   * @description Synonym for\n   * [Math.sign]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign}.\n   */\n  get sign() {\n    const number = this.$;\n\n    if (!number) {\n      return number;\n    }\n\n    return number > 0 ? 1 : -1;\n  }\n\n  /**\n   * @method Num#sin\n   * @public\n   * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\n   * @returns {Number} Sine of the number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin\n   * @description Synonym for\n   * [Math.sin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin}.\n   */\n  sin(asDegrees) {\n    return Math.sin((asDegrees ? toRadian : 1) * this.$);\n  }\n\n  /**\n   * @member Num#sinh\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\n   * @description Synonym for\n   * [Math.sinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh}.\n   */\n  get sinh() {\n    const exp = this.exp;\n\n    return (exp - 1 / exp) / 2;\n  }\n\n  /**\n   * @member Num#sq\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description The square of the number.\n   *\n   * @example\n   * new Num(2).sq;  // 4\n   * new Num(-3).sq; // 9\n   */\n  get sq() {\n    return this.$ * this.$;\n  }\n\n  /**\n   * @member Num#sqrt\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt\n   * @description Synonym for\n   * [Math.sqrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt}.\n   */\n  get sqrt() {\n    return Math.sqrt(this.$);\n  }\n\n  /**\n   * @method Num#tan\n   * @public\n   * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\n   * @returns {Number} Tangent of the number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan\n   * @description Synonym for\n   * [Math.tan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan}.\n   */\n  tan(asDegrees) {\n    return Math.tan((asDegrees ? toRadian : 1) * this.$);\n  }\n\n  /**\n   * @member Num#tanh\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\n   * @description Synonym for\n   * [Math.tanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh}.\n   */\n  get tanh() {\n    const number = this.$;\n\n    if (!isFinite(number)) {\n      return this.sign;\n    }\n\n    const exp = Math.exp(2 * number);\n\n    return (exp - 1) / (exp + 1);\n  }\n\n  /**\n   * @method Num#timeout\n   * @public\n   * @param {*} [value] - Value to be resolved by the promise.\n   * @returns {Promise} Promise that could be aborted.\n   * @see https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout\n   * @description Promise-based analogue of\n   * [setTimeout]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout}.\n   *\n   * @example\n   * new Num(50).timeout('resolved').then((value) => {\n   *   console.log(value); // 'resolved'\n   * });\n   *\n   * const promise = new Num(50).timeout();\n   * promise.abort();\n   */\n  timeout(value) {\n    let timeout;\n    let reject;\n\n    const promise = new Promise((resolve, rej) => {\n      reject = rej;\n      timeout = setTimeout(resolve, this.$, value);\n    });\n\n    promise.abort = function abort() {\n      clearTimeout(timeout);\n\n      reject(new Error('Timeout was aborted'));\n\n      return this;\n    };\n\n    return promise;\n  }\n\n  /**\n   * @method Num#toBase\n   * @public\n   * @param {Number} [base = 10] - Base that the number should inverted to.\n   * @returns {String} A string representation of the number in <base> base.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\n   * @description Synonym for\n   * [Number#toString]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString}.\n   *\n   * @example\n   * new Num(4).toBase(2); // 100\n   * new Num(3).toBase();  // 3\n   */\n  toBase(base = 10) {\n    return this.$.toString(base);\n  }\n\n  /**\n   * @method Num#toExponential\n   * @public\n   * @param {Number} [fractionDigits] - See the link.\n   * @returns {String} A string representation of the number in the exponential format.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential\n   * @description Synonym for\n   * [Number#toExponential]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential}.\n   */\n  toExponential(fractionDigits) {\n    return this.$.toExponential(fractionDigits);\n  }\n\n  /**\n   * @method Num#toFixed\n   * @public\n   * @param {Number} [digits = 0] - See the link.\n   * @returns {String} Fixed-point formatted number.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\n   * @description Synonym for\n   * [Number#toFixed]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed}.\n   */\n  toFixed(digits) {\n    return this.$.toFixed(digits);\n  }\n\n  /**\n   * @method Num#toPrecision\n   * @public\n   * @param {Number} [precision] - See the link.\n   * @returns {String} A string representation of the number to the specified precision.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision\n   * @description Synonym for\n   * [Number#toPrecision]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision}.\n   */\n  toPrecision(precision) {\n    return this.$.toPrecision(precision);\n  }\n\n  valueOf() {\n    return Number(this.$);\n  }\n}\n\ndefineProperties(Num.prototype, {\n  [Symbol.toStringTag]: 'Num'\n});\n\nconstructors[1].push({\n  check: isNumber,\n  cls: Num\n});\n\n/**\n * @function rand\n * @public\n * @param {Number} [start = 0] - Start of the range.\n * @param {Number} [end = 1] - End of the range.\n * @returns {Number} Random number.\n * @description Returns a random number in the range specified by the arguments.\n *\n * @example\n * rand(1, 5); // 2.315\n * rand(1, 5); // 4.356763\n */\nfunction rand(start = 0, end = 1) {\n  return start + (end - start) * Math.random();\n}\n\n/**\n * @function random\n * @public\n * @param {Integer} start - Start of the range.\n * @param {Integer} end - End of the range.\n * @returns {Number} Random integer.\n * @description Returns a random integer number in the range specified by the arguments.\n *\n * @example\n * random(1, 5); // 3\n * random(1, 5); // 1\n */\nfunction random(start, end) {\n  validate([start, end], ['intLike', 'intLike'], 'random');\n\n  if (end <= start) {\n    throw new Error('The second argument must be greater than the first!', 'random');\n  }\n\n  return Math.floor(rand(start, end + 1));\n}\n\nexport { Num, rand, random };\n","/**\n * @module Arr\n * @private\n * @mixin\n * @description Exports Arr class.\n */\n\nimport { random } from './Num';\nimport { Super } from './Super';\nimport { constructors } from './constants';\nimport {\n  isArrayLike, isNaN, isNumber, isString,\n  toArray, validate, iterate as iterator, Symbol, defineProperties\n} from './helpers';\n\n/**\n * @typedef {Array|*} ArrayLike\n * @public\n * @description Array-like type.\n */\n\n/**\n * @callback ArrayCallback\n * @public\n * @param {Number} i - Iteration index.\n */\n\n/**\n * @callback IterateCallback\n * @public\n * @param {Number} i - Iteration index.\n */\n\n/**\n * @callback CompareFunction\n * @public\n * @param {*} x - First value to be compared.\n * @param {*} y - Second value to be compared.\n */\n\n/**\n * @class Arr\n * @extends Super\n * @public\n * @param {Array} [array = []] - An array to wrap.\n * @returns {Arr} Instance of Arr.\n * @description Wrap of an array.\n *\n * @example\n * new Arr([1, 2]);\n */\nclass Arr extends Super {\n  constructor(array = []) {\n    super(toArray(array instanceof Arr ? array.$ : array));\n\n    /**\n     * @member Arr#$\n     * @type {Array}\n     * @public\n     * @description Made array.\n     */\n  }\n\n  /**\n   * @method Arr#concat\n   * @public\n   * @param {...(Array|Arr|*)} values - Arrays or any other values to concat the array with.\n   * @returns {Arr} New instance of Arr.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\n   * @description Synonym for\n   * [Array#concat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat}.\n   */\n  concat(...values) {\n    const array = toArray(this.$, true);\n\n    iterator(arguments, (value) => {\n      value = new Super(value).$;\n\n      if (isArrayLike(value) && !isString(value)) {\n        iterator(value, (value) => {\n          array.push(value);\n        });\n\n        return;\n      }\n\n      array.push(value);\n    });\n\n    return new this.constructor(array);\n  }\n\n  /**\n   * @member Arr#first\n   * @type {*}\n   * @public\n   * @readonly\n   * @description Returns the first element of the array.\n   *\n   * @example\n   * new Arr([1, 2, 3]).first; // 1\n   * new Arr([]).first;        // undefined\n   */\n  get first() {\n    return this.$[0];\n  }\n\n  /**\n   * @method Super#forEachReverse\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Arr} Returns this.\n   * @description Method for iterating over any object.\n   *\n   * @example\n   * new Super({ a: 1, b: 2, c: 3 }).forEach((value, key, object) => {\n   *   object[key] = value * value;\n   * }).$; // { a: 1, b: { c: 4, d: 5 } }\n   */\n  forEachReverse(callback) {\n    validate([callback], ['function'], 'Arr#forEachReverse');\n\n    const array = this.$;\n\n    for (let i = array.length - 1; i >= 0; i--) {\n      callback(array[i], i, array);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Arr#includes\n   * @public\n   * @param {*} value - Value to search.\n   * @returns {Boolean} If the array includes the value.\n   * @description Synonym for array.indexOfStrict(value) !== -1.\n   *\n   * @example\n   * new Arr([1, 2, 3]).includes(1);       // true\n   * new Arr([1, 2, 3]).includes('1');     // false\n   * new Arr([1, 2, 3]).includes(3);       // true\n   * new Arr([1, 2, NaN]).includes(NaN);   // true\n   */\n  includes(value) {\n    return this.indexOfStrict(value) !== -1;\n  }\n\n  /**\n   * @method Arr#indexOf\n   * @public\n   * @param {*} value - Value to search.\n   * @returns {Number} Index of the argument.\n   * @description Almost the same as {@link Super#keyOf}. The difference is that if the value is not found\n   * -1 returned instead of null and if found Number(key) returned.\n   *\n   * @example\n   * new Arr([1, 2, 3]).indexOf(1);       // 0\n   * new Arr([1, 2, 3]).indexOf('1');     // 0\n   * new Arr([1, 2, 3]).indexOf(3);       // -1\n   * new Arr([1, 2, NaN]).indexOf(NaN);   // 2\n   */\n  indexOf(value) {\n    const key = this.keyOf(value);\n\n    return key === null ? -1 : Number(key);\n  }\n\n  /**\n   * @method Arr#indexOfStrict\n   * @public\n   * @param {*} value - Value to search.\n   * @returns {Number} Index of the argument.\n   * @description Almost the same as {@link Super#keyOfStrict}. The difference is that if the value is not found\n   * -1 returned instead of null and if found Number(key) returned.\n   *\n   * @example\n   * new Arr([1, 2, 3]).indexOfStrict(1);       // 0\n   * new Arr([1, 2, 3]).indexOfStrict('1');     // -1\n   * new Arr([1, 2, 3]).indexOfStrict(3);       // -1\n   * new Arr([1, 2, NaN]).indexOfStrict(NaN);   // 2\n   */\n  indexOfStrict(value) {\n    const key = this.keyOfStrict(value);\n\n    return key === null ? -1 : Number(key);\n  }\n\n  /**\n   * @method Arr#join\n   * @public\n   * @param {String} [separator = ','] - See the link.\n   * @returns {String} - String of joined array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join\n   * @description Synonym for\n   * [Array#join]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join}.\n   */\n  join(separator) {\n    return this.$.join.apply(this.$, arguments);\n  }\n\n  /**\n   * @member Arr#last\n   * @type {*}\n   * @public\n   * @readonly\n   * @description The last element of the array.\n   *\n   * @example\n   * new Arr([1, 2, 3]).last; // 3\n   * new Arr([]).last;        // undefined\n   */\n  get last() {\n    const array = this.$;\n\n    return array[array.length - 1];\n  }\n\n  /**\n   * @member Arr#length\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length\n   * @description Synonym for\n   * [Array#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length}.\n   */\n  get length() {\n    return this.$.length;\n  }\n\n  /**\n   * @method Arr#pop\n   * @public\n   * @returns {*} Returns deleted element.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop\n   * @description Synonym for\n   * [Array#pop]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop}.\n   */\n  pop() {\n    return this.$.pop();\n  }\n\n  /**\n   * @method Arr#push\n   * @public\n   * @param {...*} values - See the link.\n   * @this {Arr}\n   * @returns {Arr} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push\n   * @description Synonym for\n   * [Array#push]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push}\n   * besides returning this.\n   */\n  push(...values) {\n    this.$.push.apply(this.$, arguments);\n\n    return this;\n  }\n\n  /**\n   * @method Arr#pushArray\n   * @public\n   * @param {Array} array - Array to push.\n   * @this {Arr}\n   * @returns {Arr} Returns this.\n   * @description Method for pushing an array into another.\n   */\n  pushArray(array) {\n    this.$.push.apply(this.$, array);\n\n    return this;\n  }\n\n  /**\n   * @method Arr#random\n   * @public\n   * @returns {*} Random item of the array.\n   * @description Method for getting random items of the array.\n   *\n   * @example\n   * new Arr([1, 5, 3]).random(); // 3\n   * new Arr([1, 5, 3]).random(); // 5\n   */\n  random() {\n    return this.$[random(0, this.$.length - 1)];\n  }\n\n  /**\n   * @method Arr#reverse\n   * @public\n   * @returns {Arr} A wrap of the reversed array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\n   * @description Synonym for\n   * [Array#reverse]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}.\n   */\n  reverse() {\n    this.$.reverse();\n\n    return this;\n  }\n\n  /**\n   * @method Arr#shift\n   * @public\n   * @returns {*} Returns deleted element.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift\n   * @description Synonym for\n   * [Array#shift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift}.\n   */\n  shift() {\n    return this.$.shift();\n  }\n\n  /**\n   * @method Arr#shuffle\n   * @public\n   * @returns {Arr} Returns this.\n   * @description Method for shuffling.\n   *\n   * @example\n   * new Arr([1, 2, 3, 4]).shuffle().$; // [4, 2, 3, 1]\n   * new Arr([1, 2, 3, 4]).shuffle().$; // [1, 3, 4, 2]\n   */\n  shuffle() {\n    const length = this.$.length;\n\n    return this.forEach((value, index, array) => {\n      const randomIndex = index + Math.floor((length - index) * Math.random());\n\n      array[index] = array[randomIndex];\n      array[randomIndex] = value;\n    });\n  }\n\n  /**\n   * @method Arr#slice\n   * @public\n   * @param {Number} [begin = 0] - See the link.\n   * @param {Number} [end = array.length] - See the link.\n   * @returns {Arr} A wrap of a sliced array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n   * @description Synonym for\n   * [Array#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}.\n   */\n  slice(begin, end) {\n    return new this.constructor(this.$.slice.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Arr#sort\n   * @public\n   * @param {CompareFunction} [compareFunction] - See the link.\n   * @returns {Arr} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n   * @description Synonym for\n   * [Array#sort]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}.\n   */\n  sort(compareFunction) {\n    validate([compareFunction], ['function||!'], 'Arr#sort');\n\n    this.$.sort(compareFunction);\n\n    return this;\n  }\n\n  /**\n   * @method Arr#sortAsc\n   * @public\n   * @returns {Arr} Returns this.\n   * @description Method for ascending sorting. Puts non-numbers first, then NaNs, then sorted values.\n   *\n   * @example\n   * new Arr([NaN, 1, -7, '100', 5]).sortAsc().$; // ['100', NaN, -7, 1, 5]\n   */\n  sortAsc() {\n    return this.sort(asc);\n  }\n\n  /**\n   * @method Arr#sortDesc\n   * @public\n   * @returns {Arr} Returns this.\n   * @description Method for descending sorting. Puts sorted values first, then NaNs, then non-numbers.\n   *\n   * @example\n   * new Arr([NaN, 1, -7, '100', 5]).sortDesc().$; // [5, 1, -7, NaN, '100']\n   */\n  sortDesc() {\n    return this.sort((y, x) => asc(x, y));\n  }\n\n  /**\n   * @method Arr#splice\n   * @public\n   * @param {Number} [start] - See the link.\n   * @param {Number} [deleteCount] - See the link.\n   * @param {...*} [items] - See the link.\n   * @returns {Arr} A wrap of return value of #splice call.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n   * @description Synonym for\n   * [Array#splice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}.\n   */\n  splice(start, deleteCount, ...items) {\n    return new Arr(this.$.splice.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Arr#string\n   * @public\n   * @returns {String} Concatenated array.\n   * @description Synonym for array.join('').\n   *\n   * @example\n   * new Arr([1, 2, 3]).string(); // '123'\n   */\n  string() {\n    return this.join('');\n  }\n\n  /**\n   * @method Arr#unshift\n   * @public\n   * @param {...*} [values] - See the link.\n   * @returns {Arr} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\n   * @description Synonym for\n   * [Array#unshift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}\n   * besides returning this.\n   */\n  unshift(...values) {\n    this.$.unshift.apply(this.$, arguments);\n\n    return this;\n  }\n}\n\ndefineProperties(Arr.prototype, {\n  [Symbol.toStringTag]: 'Arr'\n});\n\n/**\n * @function asc\n * @private\n * @param {*} x - First value to be compared.\n * @param {*} y - Second value to be compared.\n * @returns {Number} Where to put the first element: before or after.\n */\nfunction asc(x, y) {\n  if (!isNumber(x) && !isNumber(y)) {\n    return 0;\n  }\n\n  if (!isNumber(x)) {\n    return -1;\n  }\n\n  if (!isNumber(y)) {\n    return 1;\n  }\n\n  if (isNaN(x) && isNaN(y)) {\n    return 0;\n  }\n\n  if (isNaN(x)) {\n    return -1;\n  }\n\n  if (isNaN(y)) {\n    return 1;\n  }\n\n  return x - y;\n}\n\nconstructors[1].push({\n  check: isArrayLike,\n  cls: Arr\n});\n\n/**\n * @function array\n * @public\n * @param {Number} number - Length of the array.\n * @param {ArrayCallback} [callback] - If it's present it has to be a function\n * that returns the element that is pushed to the new array.\n * @returns {Arr} New instance of Arr.\n * @description Method for creating new array from the length using optional callback.\n *\n * @example\n * array(3).$;               // [0, 1, 2]\n * array(3, (i) => i * 2).$; // [0, 2, 4]\n */\nfunction array(number, callback) {\n  validate([number, callback], [['intLike', '>=0'], 'function||!'], 'array');\n\n  const array = [];\n\n  for (let i = 0; i < number; i++) {\n    array.push(callback ? callback(i) : i);\n  }\n\n  return new Arr(array);\n}\n\n/**\n * @function iterate\n * @public\n * @param {Number} number - Number of iterations.\n * @param {IterateCallback} callback - Callback that is called on each iteration with the iteration index.\n * @returns {void}\n * @description Method for replacing for (...) construction.\n *\n * @example\n * iterate();\n */\nfunction iterate(number, callback) {\n  validate([number, callback], [['intLike', '>=0'], 'function'], 'iterate');\n\n  for (let i = 0; i < number; i++) {\n    callback(i);\n  }\n}\n\nexport { Arr, array, iterate };\n","/**\n * @module BlobObject\n * @private\n * @mixin\n * @description Exports BlobObject class.\n */\n\nimport { Super } from './Super';\nimport { Promise } from './Promise';\nimport { constructors } from './constants';\nimport {\n  isArray, isFunction,\n  toStringTag, Symbol, defineProperties\n} from './helpers';\n\n/**\n * @typedef {{ buffer: String, binary: String, dataURL: String, text: String }} methods\n * @private\n * @description List of read blob methods.\n */\nconst methods = {\n  buffer: 'ArrayBuffer',\n  binary: 'BinaryString',\n  dataURL: 'DataURL',\n  text: 'Text'\n};\nconst { URL } = global;\n\n/**\n * @typedef {('buffer'|'binary'|'dataURL'|'text')} ReadBlobMethod\n * @public\n * @description Enum type of read blob methods.\n */\n\n/**\n * @typedef {ArrayBuffer|ArrayBufferView|Blob|String} BlobParts\n * @public\n * @description Allowed blob parts.\n */\n\n/**\n * @callback ReaderEventListener\n * @public\n * @param {Event} e - Fired event.\n * @param {FileReader} reader - FileReader.\n */\n\n/**\n * @class BlobObject\n * @extends Super\n * @public\n * @param {Blob} blob - Blob to wrap.\n * @returns {BlobObject} Instance of BlobObject.\n * @description Wrap of a blob.\n *\n * @example\n * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }));\n */\nclass BlobObject extends Super {\n  /**\n   * @member BlobObject#$\n   * @type {Blob}\n   * @public\n   * @description Original Blob.\n   */\n\n  /**\n   * @member {String} BlobObject#dataURL\n   * @type {String}\n   * @public\n   * @readonly\n   * @description Returns dataURL representation of the blob.\n   */\n  get dataURL() {\n    return URL.createObjectURL(this.$);\n  }\n\n  /**\n   * @method BlobObject#readAs\n   * @public\n   * @param {ReadBlobMethod} method - Method that is used for reading from blob.\n   * @param {ReaderEventListener} [progress] - Progress listener.\n   * @returns {Promise} Promise that could be aborted.\n   * @description Method for reading from blobs.\n   *\n   * @example\n   * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }))\n   *   .readAs('text')\n   *   .then((value) => {\n   *     console.log(value); // '{\"foo\":\"bar\"}'\n   *   });\n   */\n  readAs(method, progress) {\n    if (!methods[method]) {\n      throw new Error('1st argument must be one of following values: buffer, binary, dataURL, text');\n    }\n\n    let reader = new FileReader();\n    let toReject;\n\n    if (isFunction(progress)) {\n      reader.onprogress = function (e) {\n        progress(e, this);\n      };\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      toReject = reject;\n\n      reader.onerror = ({ target }) => {\n        if (reader) {\n          reject(target.error);\n        }\n      };\n\n      reader.onload = ({ target }) => {\n        resolve(target.result);\n      };\n\n      reader[`readAs${ methods[method] }`](this.$);\n    });\n\n    promise.abort = function abort() {\n      toReject(new Error('Reading was aborted'));\n\n      reader.abort();\n\n      reader = null;\n\n      return this;\n    };\n\n    return promise;\n  }\n\n  /**\n   * @method BlobObject#saveAs\n   * @public\n   * @param {String} [name] - Name that is used for saving file.\n   * @returns {BlobObject} Returns this.\n   * @description Method for saving blobs.\n   *\n   * @example\n   * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }))\n   *   .saveAs('blob.json');\n   */\n  saveAs(name = 'download') {\n    const anchor = document.createElement('a');\n\n    anchor.href = this.dataURL;\n    anchor.setAttribute('download', name);\n    anchor.click();\n\n    return this;\n  }\n}\n\ndefineProperties(BlobObject.prototype, {\n  [Symbol.toStringTag]: 'BlobObject'\n});\n\nconstructors[1].push({\n  check: (blob) => /^(Blob|File)$/.test(toStringTag(blob)),\n  cls: BlobObject\n});\n\n/**\n * @function blob\n * @public\n * @param {(BlobParts[]|BlobParts)} blobParts - Blob parts that are passed to\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.\n * @param {Object} [options] - Options that are passed to\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.\n * @returns {BlobObject} New instance of BlobObject.\n * @description Function for creating blobs not involving BlobObject and Blob constructors.\n */\nfunction blob(blobParts, options = {}) {\n  if (!isArray(blobParts)) {\n    blobParts = [blobParts];\n  }\n\n  return new BlobObject(new Blob(blobParts, options));\n}\n\nexport { BlobObject, blob };\n","/**\n * @module Str\n * @private\n * @mixin\n * @description Exports Str class.\n */\n\nimport { D } from './D';\nimport { Super } from './Super';\nimport { constructors, regexpSpecialCharacters } from './constants';\nimport {\n  isFunction, isNumberLike, isObject, isString,\n  validate, Symbol, defineProperties, iterate\n} from './helpers';\n\nconst htmlSpecials = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;'\n};\nconst regexpSpecialsRegexp = new RegExp(\n  new Super(regexpSpecialCharacters)\n    .word((x) => `\\\\${ x }|`)\n    .replace(/\\|$/, ''),\n  'g'\n);\n\n/**\n * @class Str\n * @extends Super\n * @public\n * @param {String} [string = ''] - A string to wrap.\n * @returns {Str} Instance of Str.\n * @description Wrap of a string.\n *\n * @example\n * const s = new Num('1');\n */\nclass Str extends Super {\n  constructor(string = '') {\n    super(`${ string }`);\n\n    /**\n     * @member Str#$\n     * @type {String}\n     * @public\n     * @description Original string.\n     */\n  }\n\n  /**\n   * @method Str#capitalizeFirst\n   * @public\n   * @returns {Str} Capitalized string.\n   * @description Method capitalizing the first symbol.\n   *\n   * @example\n   * new Str('foo').capitalizeFirst().$; // 'Foo'\n   */\n  capitalizeFirst() {\n    const string = this.$;\n\n    return new Str(string.slice(0, 1).toUpperCase() + string.slice(1));\n  }\n\n  /**\n   * @method Str#endsWith\n   * @public\n   * @param {String} searchString - See the link.\n   * @param {Number} [position = string.length] - See the link.\n   * @returns {Boolean} If the string ends with the argument string.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n   * @description Synonym for\n   * [String#endsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith}.\n   */\n  endsWith(searchString, position) {\n    if (arguments.length < 2) {\n      position = this.$.length;\n    }\n\n    return this\n      .slice(0, position)\n      .revert()\n      .startsWith(new Str(searchString).revert().$);\n  }\n\n  /**\n   * @method Str#escapeHTML\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Methods escaping \"&\", \"<\" and \">\" symbols.\n   *\n   * @example\n   * new Str('\"1 < 2\" & \"7 > 4\" are true expressions.').escapeHTML().$;\n   * // '\"1 &lt; 2\" &amp \"7 &gt; 2\" are true expressions.'\n   */\n  escapeHTML() {\n    let string = this.$;\n\n    iterate(htmlSpecials, (escaped, symbol) => {\n      string = string.replace(new RegExp(symbol, 'g'), escaped);\n    });\n\n    return new Str(string);\n  }\n\n  /**\n   * @method Str#escapeRegExp\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Method escaping RegExp special characters.\n   *\n   * @example\n   * new Str('(213.98 - [] {})').escapeRegExp().$; // '\\(213\\.98 \\- \\[\\] \\{\\}\\)'\n   */\n  escapeRegExp() {\n    return this.replace(regexpSpecialsRegexp, '\\\\$&');\n  }\n\n  /**\n   * @method Str#in\n   * @public\n   * @param {*} object - Object to check the string as a property in.\n   * @returns {Boolean} If it is in the object or not.\n   * @description Returns string in object.\n   *\n   * @example\n   * new Str('a').in({ a: 1 }); // true\n   * new Str('toFixed').in(1);  // false\n   * new Str('a').in(null);     // false\n   */\n  in(object) {\n    if (!isObject(object)) {\n      return false;\n    }\n\n    return this.$ in object;\n  }\n\n  /**\n   * @method Str#indexOf\n   * @public\n   * @param {String} searchValue - See the link.\n   * @param {Number} [fromIndex = 0] - See the link.\n   * @returns {Number} Found index or -1.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\n   * @description Synonym for\n   * [String#indexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf}.\n   */\n  indexOf(searchValue, fromIndex) {\n    return this.$.indexOf.apply(this.$, arguments);\n  }\n\n  /**\n   * @method Str#lastIndexOf\n   * @public\n   * @param {String} searchValue - See the link.\n   * @param {Number} [fromIndex = string.length] - See the link.\n   * @returns {Number} Found index or -1.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf\n   * @description Synonym for\n   * [String#lastIndexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf}.\n   */\n  lastIndexOf(searchValue, fromIndex) {\n    return this.$.lastIndexOf.apply(this.$, arguments);\n  }\n\n  /**\n   * @member Str#length\n   * @type {Number}\n   * @public\n   * @readonly\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length\n   * @description Synonym for\n   * [String#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length}.\n   */\n  get length() {\n    return this.$.length;\n  }\n\n  /**\n   * @method Str#match\n   * @public\n   * @returns {Arr|Super} D-Wrap of found match.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match\n   * @description Synonym for\n   * [String#match]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match}.\n   */\n  match(regexp) {\n    return D(this.$.match.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Str#repeat\n   * @public\n   * @param {Integer} times - Times to repeat the string.\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\n   * @description Synonym for\n   * [String#repeat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat}.\n   *\n   * @example\n   * new Str('123').repeat(2).$; // '123123'\n   * new Str('123').repeat(0).$; // ''\n   */\n  repeat(times) {\n    validate([times], [['intLike', '>=0']], 'Str#repeat');\n\n    times = +times;\n\n    const string = this.$;\n\n    let s = '';\n\n    for (let i = 0; i < times; i++) {\n      s += string;\n    }\n\n    return new Str(s);\n  }\n\n  /**\n   * @method Str#replace\n   * @public\n   * @param {RegExp|String} regexp - See the link.\n   * @param {String|Function} [replacer = ''] - See the link.\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n   * @description Synonym for\n   * [String#replace]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace}\n   * besides that replacer has a default value of ''.\n   */\n  replace(regexp, replacer = '') {\n    return new Str(this.$.replace(regexp, replacer));\n  }\n\n  /**\n   * @method Str#replaceString\n   * @public\n   * @param {String} string - String to replace.\n   * @param {String} [replacer = ''] - String to replace with.\n   * @returns {Str} New instance of Str.\n   * @description Method for global string replaceing.\n   *\n   * @example\n   * new Str('123123').replaceString('1', '4').$; // '423423'\n   * new Str('123123').replaceString('1').$;      // '2323'\n   */\n  replaceString(string, replacer = '') {\n    string = new Super(string).$;\n\n    validate([string], ['string'], 'Str#replaceString');\n\n    return new Str(this.$.split(string).join(replacer));\n  }\n\n  /**\n   * @method Str#revert\n   * @public\n   * @returns {Str} New instance of string.\n   * @description Method for reverting a string.\n   *\n   * @example\n   * new Str('1234').revert().$; // '4321'\n   */\n  revert() {\n    const string = this.$;\n    let str = '';\n\n    for (let i = string.length - 1; i >= 0; i--) {\n      str += string[i];\n    }\n\n    return new Str(str);\n  }\n\n  /**\n   * @method Str#search\n   * @public\n   * @param {RegExp} regexp - See the link.\n   * @returns {Number} Index of the first match, if found, and -1 if not.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search\n   * @description Synonym for\n   * [String#search]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search}.\n   */\n  search(regexp) {\n    validate([regexp], ['regexp']);\n\n    return this.$.search.apply(this.$, arguments);\n  }\n\n  /**\n   * @method Str#slice\n   * @public\n   * @param {Number} [beginSlice = 0] - See the link.\n   * @param {Number} [endSlice = string.length] - See the link.\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice\n   * @description Synonym for\n   * [String#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice}.\n   */\n  slice(beginSlice, endSlice) {\n    return new Str(this.$.slice.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Str#split\n   * @public\n   * @param {RegExp|String} [separator] - See the link.\n   * @returns {Arr|Super} D-Wrap of the array.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split\n   * @description Synonym for\n   * [String#split]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split}.\n   */\n  split(separator) {\n    return D(this.$.split.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Str#startsWith\n   * @public\n   * @param {String} searchString - See the link.\n   * @param {Number} [position = 0] - See the link.\n   * @returns {Boolean} If the string ends with the argument string.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n   * @description Synonym for\n   * [String#startsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith}.\n   */\n  startsWith(searchString, position = 0) {\n    return this.$.indexOf.apply(this.$, arguments) === position;\n  }\n\n  /**\n   * @method Str#substr\n   * @public\n   * @param {Number} [start = 0] - See the link.\n   * @param {Number} [length = string.length] - See the link.\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr\n   * @description Synonym for\n   * [String#substr]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr}.\n   */\n  substr(start, length) {\n    return new Str(this.$.substr.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Str#substring\n   * @public\n   * @param {Number} [indexStart = 0] - See the link.\n   * @param {Number} [indexEnd = string.length] - See the link.\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring\n   * @description Synonym for\n   * [String#substring]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring}.\n   */\n  substring(indexStart, indexEnd) {\n    return new Str(this.$.substring.apply(this.$, arguments));\n  }\n\n  /**\n   * @method Str#toCamelCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Removes following regexp /\\s\\-_\\./ making the string camel cased.\n   *\n   * @example\n   * new Str('spinal-case').toCamelCase().$;  // 'spinalCase'\n   * new Str('_snake_case_').toCamelCase().$; // 'snakeCase'\n   */\n  toCamelCase() {\n    return new Str(trim(this.$)\n      .replace(/[\\s\\-_.]+/g, '-')\n      .replace(/-[^-]/g, (match) => match[1].toUpperCase())\n      .replace(/^[\\S]/, (match) => match.toLowerCase())\n    );\n  }\n\n  /**\n   * @method Str#toCapitalCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Removes following regexp /\\-_\\./ making the string capital letter cased.\n   *\n   * @example\n   * new Str('spinal-case').toCapitalCase().$;  // 'Spinal Case'\n   * new Str('_snake_case_').toCapitalCase().$; // 'Snake Case'\n   */\n  toCapitalCase() {\n    return new Str(trim(this.$)\n      .replace(/[\\s\\-_.]+/g, ' ')\n      .replace(/[\\S]/g, (match) => (\n        match.toLowerCase() === match ? match : ` ${ match }`\n      ))\n      .replace(/\\s[\\S]/g, (match) => match.toUpperCase())\n      .replace(/\\s+/g, ' ')\n      .replace(/^\\s/, '')\n      .replace(/^[\\S]/, (match) => match.toUpperCase())\n    );\n  }\n\n  /**\n   * @method Str#toDotCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Removes following regexp /\\-_\\./ making the string dot cased.\n   *\n   * @example\n   * new Str('spinal-case').toDotCase().$;  // 'spinal.case'\n   * new Str('_snake_case_').toDotCase().$; // 'snake.case'\n   */\n  toDotCase() {\n    return new Str(trim(this.$)\n      .replace(/[\\s\\-_.]+/g, '.')\n      .replace(/[^.]/g, (match) => (\n        match.toLowerCase() === match ? match : `.${ match }`\n      ))\n      .replace(/\\.+/g, '.')\n      .replace(/^\\./, '')\n      .toLowerCase()\n    );\n  }\n\n  /**\n   * @method Str#toHyphenCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Removes following regexp /\\s\\-_\\./ making the string camel cased.\n   *\n   * @example\n   * new Str('camelCase').toSpinalCase().$;    // 'camel-case'\n   * new Str('_snake_case_').toSpinalCase().$; // 'snake-case'\n   */\n  toHyphenCase() {\n    return new Str(trim(this.$)\n      .replace(/[\\s\\-_.]+/g, '-')\n      .replace(/[^-]/g, (match) => (\n        match.toLowerCase() === match ? match : `-${ match }`\n      ))\n      .replace(/-+/g, '-')\n      .replace(/^-/, '')\n      .toLowerCase()\n    );\n  }\n\n  /**\n   * @method Str#toLowerCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase\n   * @description Synonym for\n   * [String#toLowerCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase}.\n   *\n   * @example\n   * new Str('UPPER-CASE').toLowerCase().$;  // 'upper-case'\n   */\n  toLowerCase() {\n    return new Str(this.$.toLowerCase());\n  }\n\n  /**\n   * @method Str#toSnakeCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Removes following regexp /\\s\\-\\./ making the string spinal cased.\n   *\n   * @example\n   * new Str('spinal-case').toSnakeCase().$; // 'spinal_case'\n   * new Str('camelCase').toSnakeCase().$;   // 'camel_case'\n   */\n  toSnakeCase() {\n    return new Str(trim(this.$)\n      .replace(/[\\s\\-_.]+/g, '_')\n      .replace(/[^_]/g, (match) => (\n        match.toLowerCase() === match ? match : `_${ match }`\n      ))\n      .replace(/_+/g, '_')\n      .replace(/^_/, '')\n      .toLowerCase()\n    );\n  }\n\n  /**\n   * @method Str#toSpaceCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @description Removes following regexp /\\-_\\./ making the string space cased.\n   *\n   * @example\n   * new Str('spinal-case').toSpaceCase().$;  // 'spinal case'\n   * new Str('_snake_case_').toSpaceCase().$; // 'snake case'\n   */\n  toSpaceCase() {\n    return new Str(trim(this.$)\n      .replace(/[\\s\\-_.]+/g, ' ')\n      .replace(/[\\S]/g, (match) => (\n        match.toLowerCase() === match ? match : ` ${ match }`\n      ))\n      .replace(/\\s+/g, ' ')\n      .replace(/^\\s/, '')\n      .toLowerCase()\n    );\n  }\n\n  toString() {\n    return this.$;\n  }\n\n  /**\n   * @method Str#toUpperCase\n   * @public\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase\n   * @description Synonym for\n   * [String#toUpperCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase}.\n   *\n   * @example\n   * new Str('lower-case').toUpperCase().$;  // 'LOWER-CASE'\n   */\n  toUpperCase() {\n    return new Str(this.$.toUpperCase());\n  }\n\n  /**\n   * @method Str#trim\n   * @public\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim\n   * @description Synonym for\n   * [String#trim]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim}.\n   */\n  trim() {\n    return new Str(this.$.replace(/^[\\s\\ufeff\\u00a0]+|[\\s\\ufeff\\u00a0]+$/g, ''));\n  }\n\n  /**\n   * @method Str#trimLeft\n   * @public\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft\n   * @description Synonym for\n   * [String#trimLeft]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft}.\n   */\n  trimLeft() {\n    return new Str(this.$.replace(/^[\\s\\ufeff\\u00a0]+/, ''));\n  }\n\n  /**\n   * @method Str#trimRight\n   * @public\n   * @returns {Str} New instance of Str.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight\n   * @description Synonym for\n   * [String#trimRight]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight}.\n   */\n  trimRight() {\n    return new Str(this.$.replace(/[\\s\\ufeff\\u00a0]+$/, ''));\n  }\n}\n\ndefineProperties(Str.prototype, {\n  [Symbol.toStringTag]: 'Str'\n});\n\nconstructors[2].push({\n  check: isString,\n  cls: Str\n});\n\nfunction trim(string) {\n  return string.replace(/^[\\s\\-_.]+|[\\s\\-_.]+$/g, '');\n}\n\n/**\n * @function parseJSON\n * @public\n * @param {String} [json = null] - String to parse.\n * @param {Object} [options] - Options.\n * @param {Boolean|*} [options.numbers] - If it is needed to parse number-like strings as numbers.\n * @param {Boolean|*} [options.dates] - If it is needed to parse date-like string as dates.\n * Date-like string is considered to match ^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ?$\n * @param {JSONCallback} [callback] - Callback that called on every iteration.\n * @returns {DWrap} D-Wrap of found match.\n * @description Method for parsing json.\n *\n * @example\n * parseJSON('{ \"a\": 1 }').$;                                           // { a: 1 }\n * parseJSON('{ \"a\": \"1\" }', { numbers: true }).$;                      // { numbers: true }\n * parseJSON('{ \"a\": \"1999-12-31T23:59:59.999Z\" }', { dates: true }).$; // { a: Date {...} }\n */\nfunction parseJSON(json = null, options = {}, callback) {\n  if (arguments.length <= 1) {\n    return D(JSON.parse(json));\n  }\n\n  if (isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n\n  const { numbers, dates } = options;\n  const parsed = JSON.parse(json, function (key, value) {\n    if (dates && /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ?$/.test(value)) {\n      value = new Date(value);\n    } else if (numbers && isNumberLike(value) && isString(value)) {\n      value = Number(value);\n    }\n\n    return callback ? callback.apply(this, arguments) : value;\n  });\n\n  return D(parsed);\n}\n\nexport { Str, parseJSON };\n","/**\n * @module helpers/markupToJSON\n * @private\n * @description Exports markupToJSON method.\n */\n\nimport { Arr } from '../Arr';\nimport { Str } from '../Str';\nimport { Super } from '../Super';\nimport { switcher } from '../Switcher';\nimport { htmlAllowedTagSymbols, htmlAllowedAttrSymbols, voidElements } from '../constants';\nimport { isUndefined } from './checkTypes';\n\n/**\n * @typedef {Object} MarkupElement\n * @property {'comment'|'text'|'element'} type - Type of the node.\n * @property {MarkupElement} parent - Type of the node.\n * @property {Object.<String, String>} attrs - Node attributes\n * @property {MarkupElement[]} children - Node children.\n */\n\nconst submitString = 'Please, submit an issue at https://github.com/dwaynejs/dwayne/issues/new, if needed.';\nconst NODE_REGEX_SET = new Super({\n  'tag-open': new RegExp(`<(${ htmlAllowedTagSymbols })\\\\s*`, 'i'),\n  'tag-close': constructCloseTagRegExp(htmlAllowedTagSymbols),\n  comment: /<!--((?:-[^\\->]|[^\\->])(?:-?[^-])*[^-]?|)-->/\n});\nconst TAG_OPEN_CLOSE = /^(\\/?)>/;\n// const ATTRIBUTE = /^([^\\u0000-\\u0020\\s\"'>\\/=]+)(?:\\s*=\\s*('[^']*'|\"[^\"]*\"|[^\\s\"'`<>=]+))?\\s*/;\nconst ATTRIBUTE = new RegExp(`^(${ htmlAllowedAttrSymbols })(?:\\\\s*=\\\\s*('[^']*'|\"[^\"]*\"|[^\\\\s\"'\\`<>=]+))?\\\\s*`);\nconst div = document.createElement('div');\nconst nodeSwitcher = switcher('strictEquals', (elem) => elem)\n  .case('tag-open', (elem, node) => {\n    const {\n      value: name,\n      selfClosing\n    } = node;\n\n    node = {\n      name,\n      attrs: new Super(node.attrs).map((value) => (\n        value === true\n          ? value\n          : parseCharacterData(value)\n      )).$,\n      parent: elem,\n      children: new Arr([])\n    };\n\n    elem.children.push(node);\n\n    if (!selfClosing && voidElements.indexOf(name) === -1) {\n      elem = node;\n    }\n\n    return elem;\n  })\n  .case('tag-close', (elem, node) => {\n    if (elem.name === node.value) {\n      elem = elem.parent;\n    }\n\n    return elem;\n  })\n  .case(['comment', 'text'], (elem, node, collapseWhiteSpace, type) => {\n    const element = {\n      name: `#${ type }`,\n      parent: elem,\n      value: node.value\n    };\n\n    if (type === 'text' && elem.name !== 'script' && elem.name !== 'style') {\n      element.value = parseCharacterData(element.value);\n\n      if (collapseWhiteSpace) {\n        element.value = new Str(element.value).trim().$;\n      }\n    }\n\n    if (!collapseWhiteSpace || !/^\\s*$/.test(element.value)) {\n      elem.children.push(element);\n    }\n\n    return elem;\n  });\nconst rawTextSwitcher = switcher('strictEquals', false)\n  .case(['title', 'textarea', 'style', 'script'], true);\n\nclass InternalParsingError {\n  constructor(index) {\n    this.index = index;\n  }\n}\n\nclass ParsingError extends Error {\n  type = 'PARSING_ERROR';\n}\n\n/**\n * @function markupToJSON\n * @private\n * @param {String} markup - Markup to parse to JSON.\n * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be collapsed.\n * @returns {Arr.<MarkupElement>} Markup elements array.\n * @description Function for parsing html and xml to JSON.\n */\nexport default (markup, collapseWhiteSpace) => {\n  collapseWhiteSpace = !!collapseWhiteSpace;\n\n  const elements = new Arr([]);\n  const startMarkup = markup;\n  let found;\n  let globalIndex = 0;\n  let elem = {\n    name: null,\n    children: elements\n  };\n\n  while (markup.length) {\n    try {\n      found = find(markup, elem);\n    } catch (err) {\n      if (!(err instanceof InternalParsingError)) {\n        throwUnexpectedError();\n      }\n\n      throw new ParsingError(`Parsing error near index ${ nearString(startMarkup, globalIndex + err.index) }`);\n    }\n\n    const {\n      type,\n      attrs,\n      selfClosing,\n      index,\n      value\n    } = found;\n\n    globalIndex += index;\n\n    if (!index) {\n      throwUnexpectedError();\n    }\n\n    const node = {\n      type,\n      value\n    };\n\n    if (type === 'tag-open') {\n      node.attrs = attrs;\n      node.selfClosing = selfClosing;\n    }\n\n    elem = nodeSwitcher(node.type, [elem, node, collapseWhiteSpace]);\n\n    markup = markup.slice(index);\n  }\n\n  return elements;\n\n  function throwUnexpectedError() {\n    throw new ParsingError(`Unexpected parsing error near index ${ nearString(startMarkup, globalIndex) }. ${ submitString }`);\n  }\n};\n\nfunction find(markup, elem) {\n  const { name } = elem;\n  let matches;\n\n  if (rawTextSwitcher(name)) {\n    matches = new Super({\n      'tag-close': markup.match(constructCloseTagRegExp(name))\n    });\n  } else {\n    matches = NODE_REGEX_SET.map((regex) => (\n      markup.match(regex)\n    ));\n  }\n\n  let match;\n\n  if (\n    match = matches.find((match) => (\n      match && match.index === 0\n    ))\n  ) {\n    const returning = {\n      type: match.key,\n      index: match.value[0].length,\n      value: match.value[1]\n    };\n    const attrs = {};\n\n    if (match.key === 'tag-open') {\n      const startMarkup = markup;\n      let closeMatch;\n\n      returning.selfClosing = false;\n      returning.attrs = attrs;\n\n      while (\n        (markup = startMarkup.slice(returning.index)) &&\n        !(closeMatch = markup.match(TAG_OPEN_CLOSE))\n      ) {\n        const attr = markup.match(ATTRIBUTE);\n\n        if (!attr) {\n          returning.index += 1;\n\n          continue;\n        }\n\n        attrs[attr[1]] = isUndefined(attr[2])\n          ? true\n          : attr[2].replace(/^(\"|')|(\"|')$/g, '');\n        returning.index += attr[0].length;\n      }\n\n      if (closeMatch) {\n        returning.index += closeMatch[0].length;\n        returning.selfClosing = !!closeMatch[1];\n      }\n    }\n\n    return returning;\n  }\n\n  let { value: index } = matches.min((match) => (\n    match ? match.index : NaN\n  ));\n\n  if (index === Infinity) {\n    index = markup.length;\n  }\n\n  return {\n    type: 'text',\n    index,\n    value: markup.slice(0, index)\n  };\n}\n\nfunction constructCloseTagRegExp(tagName) {\n  return new RegExp(`</(${ tagName })\\\\s*>`, 'i');\n}\n\nfunction nearString(markup, index) {\n  return `${ index } (~~~ \"${ markup.slice(index, index + 15) }\" ~~~, the string itself is \"${ markup }\")`;\n}\n\nfunction parseCharacterData(string) {\n  return string.replace(/&(\\w+|#x?\\d+);/g, (match) => {\n    div.innerHTML = match;\n\n    return div.textContent || div.innerText;\n  });\n}\n","/**\n * @module Elem\n * @private\n * @mixin\n * @description Exports Elem class.\n */\n\nimport { Super } from './Super';\nimport { Arr, array, iterate as times } from './Arr';\nimport { blob } from './BlobObject';\nimport { method } from './Func';\nimport { Promise } from './Promise';\nimport { Str } from './Str';\nimport { switcher } from './Switcher';\nimport {\n  constructors, appliedRegExps, htmlElements, svgElements,\n  canvasGetMethods, canvasRestMethods\n} from './constants';\nimport {\n  isArray, isArrayLike, isElement, isFunction,\n  isInteger, isNil, isNumber, isNull, isString,\n  assign, dynamicDefineProperties, defineProperties, toArray,\n  validate, toStringTag, iterate, Symbol\n} from './helpers';\nimport markupToJSON from './helpers/markupToJSON';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemValueCallback\n * @public\n * @param {String} value - Old value.\n * @param {Elem} elem - Current element.\n * @param {Number} index - Index in the set of the elements.\n */\n\n/**\n * @callback ElemSetOfCallback\n * @public\n * @param {Element} created - Created element.\n * @param {*} value - Value of the iterated element in the object.\n * @param {Key} key - Key of the iterated element in the object.\n * @param {*} object - Object that is iterated over.\n * @param {Element} elem - Current element.\n * @param {Number} index - Index of the current element.\n */\n\n/**\n * @callback ValidateCallback\n * @public\n * @param {*} value - Element value.\n * @param {Element} elem - Element to validate.\n * @param {Number} index - Index of the element.\n */\n\n/**\n * @callback CtxCallback\n * @public\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\nconst nativeDocument = global.document;\nconst emptyDiv = nativeDocument.createElement('div');\nconst eventSeparator = /(?:,| ) */;\nconst textProperty = new Super(Node.prototype).propertyDescriptor('textContent') ? 'textContent' : 'innerText';\nconst classes = {};\nconst attrs = {};\nconst windowsDwayneData = new Arr([]);\nconst inputElements = 'input, select, textarea, datalist, keygen, output';\nconst click = method('click');\nconst svgNS = 'http://www.w3.org/2000/svg';\nconst xmlNS = 'http://www.w3.org/2000/xmlns/';\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xhtmlNS = 'http://www.w3.org/1999/xhtml';\nconst typeSwitcher = switcher('call', (elem, type) => {\n  const ns = type === 'svg'\n    ? svgNS\n    : elem.prop('namespaceURI') || nativeDocument.documentElement.namespaceURI || xhtmlNS;\n\n  return nativeDocument.createElementNS(ns, type);\n})\n  .case(\n    (type) => type === '#comment',\n    () => nativeDocument.createComment('')\n  )\n  .case(\n    (type) => type === '#text',\n    () => nativeDocument.createTextNode('')\n  );\nconst refSwitcher = switcher('strictEquals', 'href')\n  .case(\n    ['img', 'script', 'iframe', 'audio', 'video'],\n    'src'\n  )\n  .case(\n    'form',\n    'action'\n  );\nconst filterSwitcher = switcher('call', (selector) => selector)\n  .case(\n    isString,\n    (selector) => (\n      (elem) => new Elem(elem).is(selector)\n    )\n  )\n  .case(\n    [isArray, isElem],\n    (elems) => {\n      elems = new Arr(elems);\n\n      return (elem) => elems.indexOf(elem) !== -1;\n    }\n  );\nconst innerSwitcher = switcher('strictEquals', 0)\n  .case('padding-box', (paddings) => paddings)\n  .case('border-box', (paddings, borders) => paddings + borders);\nconst outerSwitcher = switcher('strictEquals', (borders, paddings) => borders + paddings)\n  .case('padding-box', (borders) => borders)\n  .case('border-box', 0);\nconst attrNSSwitcher = switcher('call', null)\n  .case((attr) => attr === 'xmlns' || attr === 'xmlns:xlink', (elem) => (\n    elem.name === 'svg'\n      ? xmlNS\n      : null\n  ))\n  .case((attr) => /^xlink:\\w/.test(attr), (elem) => (\n    elem.closest('svg').length\n      ? xlinkNS\n      : null\n  ));\n\n/**\n * @class Elem\n * @extends Arr\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set. Also has all methods from from\n * [CanvasRenderingContext2D]{@link https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D}.\n * Getters methods return the same as methods from CanvasRenderingContext2D and the rest return this.\n * Work for the first canvas element in the set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Arr {\n  constructor(elem = []) {\n    super((() => {\n      let element = elem;\n\n      if (isArrayLike(element) && (\n        isWindow(element) ||\n        isHTMLDocument(element) ||\n        isDocumentFragment(element) ||\n        isElement(element) ||\n        isCommentOrText(element) ||\n        isStyleRule(element)\n      )) {\n        element = [element];\n      }\n\n      return new Arr(toArray(new Super(element).$, true)).object((elems, elem) => {\n        if (elems.indexOf(elem) === -1 && (\n          isElement(elem) ||\n          isWindow(elem) ||\n          isHTMLDocument(elem) ||\n          isDocumentFragment(elem) ||\n          isCommentOrText(elem) ||\n          isStyleRule(elem)\n        )) {\n          return elems.push(elem);\n        }\n\n        if (isElem(elem)) {\n          elems.push.apply(elems, elem.$);\n        }\n      }, []).$;\n    })());\n\n    this.$$ = elem;\n\n    this.forEach(addDwayneData);\n\n    /**\n     * @member {Array.<Node|Window>} Elem#$\n     * @type {Array.<Node|Window>}\n     * @public\n     * @description Constructed element set.\n     */\n\n    /**\n     * @member {*} Elem#$$\n     * @type {*}\n     * @public\n     * @description Initial element set.\n     */\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(String|Elem|Element|Element[])} elements - Each argument is a selector, or Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add(...elements) {\n    iterate(arguments, (elem) => {\n      toFind(elem).forEach((elem) => {\n        if (this.indexOf(elem) === -1) {\n          this.push(elem);\n        }\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterate(isElement(elem) && arguments, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#addComment\n   * @public\n   * @param {String} text - Text of comment to add.\n   * @param {Boolean} end - If the comment should be inserted to the end. If false it's inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method for adding comment to all the elements in the set.\n   *\n   * @example\n   * elem.addHTML('<div>1</div>');\n   */\n  addComment(text, end = true) {\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', `<!--${ text }-->`);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#addHTML\n   * @public\n   * @param {String} html - HTML to add.\n   * @param {Boolean} end - If the HTML should be inserted to the end. If false it's inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method for adding HTML to all the elements in the set.\n   *\n   * @example\n   * elem.addHTML('<div>1</div>');\n   */\n  addHTML(html, end = true) {\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', html);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#addRule\n   * @public\n   * @param {String} name - Name of the rule.\n   * @param {String} selector - Selector for the rule\n   * @param {Object.<String, String>} style - Style for the selector.\n   * @returns {Elem} Returns this.\n   * @description Method for adding css styles into the first style tag in the set.\n   * Note: style element should be inside the document.\n   *\n   * @example\n   * style.addRule('img-size', 'img.square', {\n   *   width: '40px !important',\n   *   height: '40px !important'\n   * });\n   */\n  addRule(name, selector, style) {\n    this.some((elem) => {\n      if (getName(elem) === 'style') {\n        const { sheet } = elem;\n        const { length } = sheet.cssRules;\n        const rules = new Super(style).word((value, property) => (\n          `${ new Str(property).toHyphenCase() }: ${ value };\\n`\n        ));\n\n        sheet.insertRule(\n          `${ selector } {${ rules && '\\n' }${ rules }}`,\n          length\n        );\n        sheet.cssRules[length].dwayneData = { name };\n\n        return true;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#addText\n   * @public\n   * @param {String} text - Text to add.\n   * @param {Boolean} end - If the text should be inserted to the end. If false it's inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method for adding text to all the elements in the set.\n   *\n   * @example\n   * elem.addText('123');\n   */\n  addText(text, end = true) {\n    return this.forEach((elem) => {\n      new Elem(nativeDocument.createTextNode(text)).into(elem, end);\n    });\n  }\n\n  /**\n   * @method Elem#apply\n   * @public\n   * @param {...String} strings - Strings to apply.\n   * @returns {Elem} Returns this.\n   * @description Method that is a shorthand for many other methods.\n   * All shorthands can be separated with space and written within one string.\n   *\n   * @example\n   * elem.apply(\n   *   '#id .c1 .c2 @border(1px solid black) $disabled $attr(some value) *(Click me!)'\n   * );\n   * // shorthand for\n   * // elem\n   * //   .id('id')\n   * //   .addClass('c1', 'c2')\n   * //   .css('border', '1px solid black')\n   * //   .attr({\n   * //     attr, 'some value'\n   * //     disabled: ''\n   * //   })\n   * //   .text('Click me!');\n   * // There is a full list of possible types of syntax below...\n   *\n   * elem.apply('#id');                    // shorthand for elem.id('id');\n   * elem.apply('.c1 .c2');                // shorthand for elem.addClass('c1', 'c2');\n   * elem.apply('-.c1 -.c2');              // shorthand for elem.removeClass('c1', 'c2');\n   * elem.apply('-@float -@display');      // shorthand for elem.removeCSS('float', 'display');\n   * elem.apply('-$a1 -$a2');              // shorthand for elem.removeAttr('a1', 'a2');\n   * elem.apply('*(some text)');           // shorthand for elem.text('some text');\n   * elem.apply('&(<div>1</div>)');        // shorthand for elem.html('<div>1</div>');\n   * elem.apply('@float(right)');          // shorthand for elem.css('float', 'right');\n   * elem.apply('@transform(scale(5px))'); // shorthand for elem.css('transform', 'scale(5px)');\n   * elem.apply('@margin(2px 2px)');       // shorthand for elem.css('margin', '2px 2px');\n   * elem.apply('@marginLeft(2px)');       // shorthand for elem.css('marginLeft', '2px 2px');\n   * elem.apply('@margin-left(2px)');      // shorthand for elem.css('margin-left', '2px 2px');\n   * elem.apply('$attr(some value)');      // shorthand for elem.attr('attr', 'some value');\n   * elem.apply('$attr');                  // shorthand for elem.attr('attr', '');\n   */\n  apply(...strings) {\n    let applied;\n    let setApplied;\n    let callback;\n    let name;\n    let np1;\n    let slice;\n\n    new Str(new Arr(arguments).join(' '))\n      .split(/(\\s+)/)\n      .forEach((string) => {\n        if (!applied) {\n          np1 = string.slice(0, 1);\n          callback = appliedRegExps[np1];\n          slice = 1;\n\n          if (callback && !isFunction(callback)) {\n            callback = callback[string.slice(1, 2)];\n            slice = 2;\n          }\n\n          if (/^\\s+$/.test(string) || !callback) {\n            return;\n          }\n\n          name = string.slice(slice).match(/^[^()]+/);\n\n          if (!name && (np1 !== '*' && np1 !== '&')) {\n            return;\n          }\n\n          applied = {\n            name: name ? name[0] : '',\n            args: string.slice(slice + (name ? name[0] : '').length),\n            callback\n          };\n\n          setApplied = true;\n        }\n\n        if (!setApplied) {\n          applied.args += string;\n        }\n\n        if (!applied.args || /^\\([\\s\\S]+\\)$/.test(applied.args)) {\n          applied.callback(this, applied.name, applied.args.replace(/^\\(|\\)$/g, ''));\n          applied = null;\n        }\n\n        setApplied = false;\n      });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String|ElemValueCallback>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String|ElemValueCallback} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Super|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr().$;                // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = getElem(this);\n\n    if (!arguments.length) {\n      return new Super(elem.attributes).object((o, attr) => {\n        o[attr.name] = attr.value;\n      });\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      const ns = attrNSSwitcher(attr, [new Elem(elem)]);\n\n      return isNull(ns)\n        ? elem.getAttribute(attr)\n        : elem.getAttributeNS(ns, attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem, index) => {\n      if (!isElement(elem)) {\n        return;\n      }\n\n      new Super(attr).forEach((value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        if (isFunction(value)) {\n          value = value(new Elem(elem).attr(key), elem, index);\n        }\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const ns = attrNSSwitcher(key, [new Elem(elem)]);\n\n        if (isNull(ns)) {\n          elem.setAttribute(key, value);\n        } else {\n          elem.setAttributeNS(ns, key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#blob\n   * @public\n   * @param {Object} [options = {}] - Options that are passed into {@link blob}.\n   * @returns {Promise.<BlobObject>} New instance of promise.\n   * @description Returns a {@link BlobObject} Promise. Works with image or canvas first element.\n   *\n   * @example\n   * image.blob().then((blob) => console.log(blob));  // BlobObject\n   * canvas.blob().then((blob) => console.log(blob)); // BlobObject\n   */\n  blob(options = {}) {\n    return new Promise((resolve, reject) => {\n      const elem = this.first();\n      const { name } = elem;\n\n      if (name !== 'img' && name !== 'canvas') {\n        reject(new Error('First element in the set isn\\'t an image or a canvas! (Elem#blob)'));\n      }\n\n      if (name === 'canvas') {\n        return resolve(elem);\n      }\n\n      elem\n        .load()\n        .then(() => {\n          if (elem.isBroken()) {\n            return reject(new Error('The image is broken! (Elem#blob)'));\n          }\n\n          const canvas = new Elem(nativeDocument).canvas();\n          const width = elem.width();\n          const height = elem.height();\n\n          canvas\n            .width(width)\n            .height(height)\n            .drawImage(elem.$[0], 0, 0);\n\n          resolve(canvas);\n        });\n    }).then((canvas) => {\n      const dataURL = canvas.dataURL();\n      const byteString = atob(dataURL.split(',')[1]);\n      const length = byteString.length;\n      const ab = new ArrayBuffer(length);\n      const ia = new Uint8Array(ab);\n\n      times(length, (i) => {\n        ia[i] = byteString.charCodeAt(i);\n      });\n\n      return blob(ab, options);\n    });\n  }\n\n  /**\n   * @method Elem#blur\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur\n   * @description Synonym for\n   * [HTMLElement#blur]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur}.\n   */\n  blur() {\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.blur();\n      }\n    });\n  }\n\n  /**\n   * @method Elem#calcCSS\n   * @param {String} [pseudo] - See the link.\n   * @returns {CSSStyleDeclaration} See the link.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle\n   * @description Synonym for\n   * [getComputedStyle]{@link https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle}.\n   * Returns computed style for the first element in the set or undefined.\n   */\n  calcCSS(pseudo = null) {\n    return getComputedStyle(getElem(this), pseudo);\n  }\n\n  /**\n   * @method Elem#changeRule\n   * @public\n   * @param {String} name - Name of the rule.\n   * @param {Object.<String, String>} style - Style for the selector.\n   * @returns {Elem} Returns this.\n   * @description Method for changing css styles in the first style tag in the set.\n   * Note: style element should be inside the document.\n   *\n   * @example\n   * style.changeRule('img-size', {\n   *   width: '50px !important',\n   *   height: '50px !important'\n   * });\n   */\n  changeRule(name, style) {\n    this.some((elem) => {\n      if (getName(elem) === 'style') {\n        const { value: rule } = new Arr(elem.sheet.cssRules).find((rule) => rule.dwayneData && rule.dwayneData.name === name) || {};\n\n        if (rule) {\n          new Elem(rule).css(style);\n\n          return true;\n        }\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#child\n   * @public\n   * @param {Number|String|Elem|Element|Element[]} element - If the argument is a number a wrap of the set of the children\n   * of this index of each element in the set returned otherwise an element to put into this element, a collection\n   * or a selector of it.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns a wrap of children or inserted elements.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * const child = elem.child(1);\n   *\n   * elem.child(elem2);\n   * elem.child(document.getElementById('id'));\n   * elem.child('#id div.c1');\n   */\n  child(element, end = true) {\n    if (isInteger(element) && element >= 0) {\n      return this.children().elem(element);\n    }\n\n    return toFind(element).into(this, end);\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this.$[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#class\n   * @public\n   * @param {String} [cls] - If it's present it has to contain class attribute to set.\n   * @returns {Arr|Elem} If the argument is present this returned otherwise a wrap of the classes array returned.\n   * @description Method for getting/setting classes.\n   *\n   * @example\n   * elem.class('c1 c2'); // class set to 'c1 c2'\n   * elem.class().$;      // ['c1', 'c2']\n   */\n  class(cls) {\n    if (!arguments.length) {\n      return new Arr(getElem(this).className.split(' '));\n    }\n\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.className = cls;\n      }\n    });\n  }\n\n  /**\n   * @method Elem#click\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click\n   * @description Synonym for\n   * [HTMLElement#click]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click}.\n   */\n  click() {\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.click();\n      }\n    });\n  }\n\n  /**\n   * @method Elem#clone\n   * @public\n   * @param {Boolean|*} [deep = false] - See thee link.\n   * @returns {Elem} New instance of Elem.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode\n   * @description Synonym for\n   * [Node#cloneNode]{@link https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode}.\n   */\n  clone(deep = false) {\n    return this.object((elems, elem) => {\n      elems.add(elem.cloneNode(!!deep));\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.object((elems, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return elems.add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {String|Elem|Element} element - Element to find out if it's within the first element\n   * in the set or a selector of it.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem1.contains(elem2);   // true|false\n   * elem.contains(selector); // true|false\n   */\n  contains(element) {\n    element = toFind(element);\n\n    return getElem(this).contains(getElem(element));\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @param {...String} appliedExpressions - Strings that are passed into {@link Elem#apply}.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div', '#id .c1 .c2 *Some text*');\n   *\n   * // also there are shorthands for almost every HTML-element\n   * elem.div();\n   * elem.input('$type(checkbox) $name(country)');\n   */\n  create(type, ...appliedExpressions) {\n    return this.object((elems, elem) => {\n      const element = new Elem(typeSwitcher(type, [new Elem(elem)]));\n\n      element.into(elem);\n\n      elems.add(element.apply.apply(element, appliedExpressions));\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#createComment\n   * @public\n   * @param {String} text - Text of the comment.\n   * @returns {Elem} New instance of Elem - wrap of the created comments.\n   * @description Method for creating comments inside this element.\n   * If this element is not an Element the comment is just created.\n   *\n   * @example\n   * elem.createComment('comment');\n   */\n  createComment(text) {\n    return this\n      .create('#comment')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#createText\n   * @public\n   * @param {String} text - Text.\n   * @returns {Elem} New instance of Elem - wrap of the created text nodes.\n   * @description Method for creating text nodes inside this element.\n   * If this element is not an Element the text node is just created.\n   *\n   * @example\n   * elem.createText('text');\n   */\n  createText(text) {\n    return this\n      .create('#text')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String|ElemValueCallback>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Super|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css().$;                // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    let style = getElem(this).style;\n\n    if (isStyleRule(this.$[0])) {\n      style = this.$[0].style;\n    }\n\n    if (!arguments.length) {\n      return new Str(style.cssText)\n        .split(/; ?/)\n        .object((o, value) => {\n          if (value) {\n            property = value.split(/: /);\n\n            o[new Str(property[0]).toCamelCase().$] = property[1];\n          }\n        });\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      property = new Str(property).toHyphenCase().$;\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem, index) => {\n      if (!isElement(elem) && !isStyleRule(elem)) {\n        return;\n      }\n\n      new Super(property).forEach((value, property) => {\n        if (isNil(value)) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        property = new Str(property).toHyphenCase().$;\n\n        if (isFunction(value)) {\n          value = value(new Elem(elem).css(property), elem, index);\n        }\n\n        if (isNil(value)) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(/ ?!important$/, ''),\n          /!important$/.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#ctx\n   * @public\n   * @param {String|Object|CtxCallback} [property] - If present and object\n   * it's assigned to the canvas rendering context, if function\n   * it's called with canvas rendering context argument, if string\n   * the value from the second argument is used for assigning\n   * this property to canvas rendering context and if not present\n   * canvas rendering context returned.\n   * @param {*} [value] - See the property argument.\n   * @returns {CanvasRenderingContext2D|Elem}\n   * @description Rendering context of the first canvas in the set.\n   *\n   * @example\n   * canvas.ctx; // CanvasRenderingContext2D\n   */\n  ctx(property, value) {\n    let ctx;\n\n    this.some((elem) => {\n      if (getName(elem) === 'canvas') {\n        ctx = elem.dwayneData.ctx;\n\n        return true;\n      }\n    });\n\n    if (!arguments.length) {\n      return ctx;\n    }\n\n    if (!ctx) {\n      return this;\n    }\n\n    if (isFunction(property)) {\n      property(ctx);\n    } else {\n      if (arguments.length >= 2) {\n        property = { [property]: value };\n      }\n\n      assign(ctx, property);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String|ElemValueCallback>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Super|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data().$;                  // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const dataset = getElem(this).dataset;\n\n    if (!arguments.length) {\n      return new Super(dataset).object((o, value, key) => {\n        o[key] = value;\n      });\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem, index) => {\n      if (!isElement(elem)) {\n        return;\n      }\n\n      iterate(key, (value, key) => {\n        elem.dataset[key] = isFunction(value) ? value(elem.dataset[key], elem, index) : value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dataURL\n   * @param {String} [type = 'image/png'] - See the link\n   * @param {Number} [encoderOptions = 0.92] - See the link.\n   * @returns {String} Data URL for the first canvas element in the set.\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL\n   * @description Synonym for\n   * [HTMLCanvasElement#toDataURL]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL}.\n   *\n   * @example\n   * canvas.dataURL();\n   */\n  dataURL(type, encoderOptions) {\n    const ctx = this.ctx();\n\n    if (!ctx) {\n      return '';\n    }\n\n    return ctx.canvas.toDataURL.apply(ctx.canvas, arguments);\n  }\n\n  /**\n   * @method Elem#deleteRule\n   * @public\n   * @param {String} name - Name of the rule.\n   * @returns {Elem} Returns this.\n   * @description Method for deleting css styles in a style tag.\n   * Note: style element should be inside the document.\n   *\n   * @example\n   * style.deleteRule('img-size');\n   */\n  deleteRule(name) {\n    this.some((elem) => {\n      if (getName(elem) === 'style') {\n        const rule = new Arr(elem.sheet.cssRules).find((rule) => rule.dwayneData && rule.dwayneData.name === name);\n\n        if (rule) {\n          elem.sheet.deleteRule(rule.key);\n\n          return true;\n        }\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [eventInit = {}] - See the link.\n   * @param {Boolean} [eventInit.bubbles = true] - See the link.\n   * @param {Boolean} [eventInit.cancelable = true] - See the link.\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, eventInit = {}, details = {}) {\n    const { bubbles = true, cancelable = true } = eventInit || {};\n    let finalEvent = event;\n\n    if (!/Event$/.test(toStringTag(finalEvent))) {\n      try {\n        finalEvent = new Event(finalEvent, { bubbles, cancelable });\n      } catch (err) {\n        finalEvent = nativeDocument.createEvent('Event');\n        finalEvent.initEvent(event, bubbles, cancelable);\n      }\n\n      assign(finalEvent, details);\n    }\n\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.dispatchEvent(finalEvent);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this.$[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {String|Function|Element[]|Elem} [selector = Boolean] - If it's a string the method filters elements with the selector\n   * otherwise super.filter is called.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   * elem.filter(elemsInArray);\n   * elem.filter(elemsInElem);\n   * elem.filter('.child');\n   */\n  filter(selector = Boolean) {\n    return new Elem(super.filter(filterSwitcher(selector)));\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String|Function} selector - Selector to find.\n   * @returns {Elem|{ key: Key, value: * }|null} New instance of Elem if selector is a string\n   * otherwise super.find is called.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    if (!isString(selector)) {\n      return super.find(selector);\n    }\n\n    return this.object((elems, elem) => {\n      elems.add(find(selector, elem));\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#first\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for elem.elem(0).\n   */\n  first() {\n    return this.elem(0);\n  }\n\n  /**\n   * @method Elem#firstChild\n   * @public\n   * @param {String} [selector = null] - If present, finds first child in every elem that matches the selector.\n   * If not, finds first child of each element in the set.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding first children of each element in the set.\n   *\n   * @example\n   * elem.first();       // finds first child of each element in the elem set\n   * elem.first('.foo'); // find first child that has foo class of each element in the set\n   */\n  firstChild(selector = null) {\n    return this.object((elems, elem) => {\n      const { value: found } = new Elem(elem)\n        .children()\n        .find((elem) => new Elem(elem).is(selector)) || {};\n\n      elems.add(found);\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#focus\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus\n   * @description Synonym for\n   * [HTMLElement#focus]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus}.\n   */\n  focus() {\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.focus();\n      }\n    });\n  }\n\n  /**\n   * @method Elem#getRule\n   * @public\n   * @param {String} name - Name of the rule.\n   * @returns {{ selector: (String|void), rules: Object }} Set of the css rules.\n   * @description Method for getting set of the rules under the name.\n   * Note: style element should be inside the document.\n   *\n   * @example\n   * style.addRule('img-size', 'img.square', {\n   *   width: '40px',\n   *   height: '40px'\n   * });\n   * style.getRule('img-size');\n   * // {\n   * //   selector: 'img.square',\n   * //   rules: {\n   * //     width: '40px',\n   * //     height: '40px'\n   * //   }\n   * // }\n   */\n  getRule(name) {\n    let found = {\n      selector: undefined,\n      rules: {}\n    };\n\n    this.some((elem) => {\n      if (getName(elem) === 'style') {\n        const { value: rule } = new Arr(elem.sheet.cssRules).find((rule) => rule.dwayneData && rule.dwayneData.name === name) || {};\n\n        if (rule) {\n          found = {\n            selector: rule.selectorText,\n            rules: new Elem(rule).css().$\n          };\n\n          return true;\n        }\n      }\n    });\n\n    return found;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = getElem(this);\n    const ns = attrNSSwitcher(attr, [new Elem(elem)]);\n\n    return isNull(ns)\n      ? elem.hasAttribute(attr)\n      : elem.hasAttributeNS(ns, attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    return getElem(this).classList.contains(cls);\n  }\n\n  /**\n   * @method Elem#height\n   * @public\n   * @param {*|ElemValueCallback} [height] - Height to set.\n   * @returns {Elem|String} If no arguments passed height of the first element in the set returned.\n   * Otherwise all elements heights in the set are set to the height argument.\n   * @description Gets or sets height.\n   *\n   * @example\n   * elem.height(123);\n   * elem.height(); // 123\n   */\n  height(height) {\n    return this.prop.apply(this, new Arr(arguments).unshift('height').$);\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      const currentDisplay = elem.css('display');\n\n      if (currentDisplay.indexOf('none')) {\n        elem.prop('dwayneData').previousDisplay = currentDisplay;\n      }\n\n      elem.css('display', 'none !important');\n    });\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|ElemValueCallback|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      return getElem(this).innerHTML;\n    }\n\n    return this.forEach((elem, index) => {\n      if (isElement(elem)) {\n        elem.innerHTML = isFunction(html) ? html(elem.innerHTML, elem, index) : html;\n      }\n    });\n  }\n\n  /**\n   * @method Elem#id\n   * @public\n   * @param {String|*} [id] - Id to set.\n   * @returns {Elem|String} If no arguments passed id of the first element in the set returned.\n   * Otherwise all elements ids in the set are set to the id argument.\n   * @description Gets id or sets ids.\n   *\n   * @example\n   * elem.id('unique');\n   * elem.id(); // 'unique'\n   */\n  id(id) {\n    if (!arguments.length) {\n      return getElem(this).id;\n    }\n\n    return this.forEach((elem) => {\n      if (isElement(elem)) {\n        elem.id = id;\n      }\n    });\n  }\n\n  /**\n   * @member {Number} Elem#innerHeight\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description Getter for finding how much height content of the first element can be.\n   *\n   * @example\n   * elem.css({\n   *   boxSizing: 'border-box',\n   *   height: '200px',\n   *   paddingTop: '2px',\n   *   paddingBottom: '3px',\n   *   borderTop: '1px solid black',\n   *   borderBottom: '4px solid black'\n   * }).innerHeight; // 190\n   * elem\n   *   .css('box-sizing', 'content-box')\n   *   .innerHeight; // 200\n   * elem\n   *   .css('box-sizing', 'padding-box')\n   *   .innerHeight; // 195\n   */\n  get innerHeight() {\n    const elem = this.$[0];\n\n    if (isWindow(elem)) {\n      return elem.innerHeight;\n    }\n\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      boxSizing,\n      height,\n      paddingTop,\n      paddingBottom\n    } = this.calcCSS();\n    const borders = px(borderTopWidth) + px(borderBottomWidth);\n    const paddings = px(paddingTop) + px(paddingBottom);\n\n    return px(height) - innerSwitcher(boxSizing, [paddings, borders]);\n  }\n\n  /**\n   * @member {Number} Elem#innerWidth\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description Getter for finding how much width content of the first element can be.\n   *\n   * @example\n   * elem.css({\n   *   boxSizing: 'border-box',\n   *   width: '200px',\n   *   paddingLeft: '2px',\n   *   paddingRight: '3px',\n   *   borderLeft: '1px solid black',\n   *   borderRight: '4px solid black'\n   * }).innerWidth; // 190\n   * elem\n   *   .css('box-sizing', 'content-box')\n   *   .innerWidth; // 200\n   * elem\n   *   .css('box-sizing', 'padding-box')\n   *   .innerWidth; // 195\n   */\n  get innerWidth() {\n    const elem = this.$[0];\n\n    if (isWindow(elem)) {\n      return elem.innerWidth;\n    }\n\n    const {\n      borderLeftWidth,\n      borderRightWidth,\n      boxSizing,\n      paddingLeft,\n      paddingRight,\n      width\n    } = this.calcCSS();\n    const borders = px(borderLeftWidth) + px(borderRightWidth);\n    const paddings = px(paddingLeft) + px(paddingRight);\n\n    return px(width) - innerSwitcher(boxSizing, [paddings, borders]);\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {String|Elem|Element} element - Element to insert this element after or a selector of it.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toFind(element).first();\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next().$[0];\n    parent = parent.$[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {String|Elem|Element} element - Element to insert this element before or a selector of it.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toFind(element).first();\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.$[0];\n    parent = parent.$[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {String|Elem|Element} element - Element to put this elements into or a selector of it.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toFind(element).$[0];\n\n    if (\n      !element ||\n      isWindow(element) ||\n      isHTMLDocument(element) ||\n      isCommentOrText(element)\n    ) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      return this.forEachReverse((elem) => {\n        element.insertBefore(elem, element.firstChild);\n      });\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * If the selector is undefined or null always returns true. If it's not for not elements\n   * entries returns false.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (isNull(selector)) {\n      return true;\n    }\n\n    const elem = getElem(this);\n    const matches = (\n      elem.matches ||\n      elem.matchesSelector ||\n      elem.webkitMatchesSelector ||\n      elem.mozMatchesSelector ||\n      elem.msMatchesSelector ||\n      elem.oMatchesSelector\n    );\n\n    if (!isElement(this.$[0])) {\n      return false;\n    }\n\n    try {\n      return matches.call(elem, selector);\n    } catch (err) {\n      console.error(`Selector '${ selector }' is not a valid selector (Elem#is)`);\n\n      return false;\n    }\n  }\n\n  /**\n   * @method Elem#isBroken\n   * @public\n   * @returns {Boolean} If the first image in the set is broken.\n   * @description Returns if the first element in the set is broken. Not image and not loaded image is considered proper.\n   *\n   * @example\n   * const img = elem.img().on({\n   *   'load': onload,\n   *   'error': onload\n   * });\n   *\n   * onload = () => {\n   *   console.log(img.isBroken()); // true\n   * };\n   *\n   * img.ref('/some/non-existent/site/not-found.png');\n   */\n  isBroken() {\n    let isBroken = false;\n\n    this.some((elem) => {\n      if (getName(elem) === 'img') {\n        isBroken = !!(elem.complete && (!elem.naturalWidth || !elem.naturalHeight));\n\n        return true;\n      }\n    });\n\n    return isBroken;\n  }\n\n  /**\n   * @method Elem#isWithinDocument\n   * @public\n   * @returns {Boolean} Returns if the first element in the set is within the document or not.\n   * @description Returns if the first element in the set is within the document or not.\n   *\n   * @example\n   * new Elem(document.body).isWithinDocument();  // true\n   * new Elem(document).div().isWithinDocument(); // false\n   */\n  isWithinDocument() {\n    return this.first().closest('html').length !== 0;\n  }\n\n  /**\n   * @method Elem#last\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for elem.elem(-1).\n   */\n  last() {\n    return this.elem(-1);\n  }\n\n  /**\n   * @method Elem#lastChild\n   * @public\n   * @param {String} [selector = null] - If present, finds last child in every elem that matches the selector.\n   * If not, finds last child of each element in the set.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding last children of each element in the set.\n   *\n   * @example\n   * elem.last();       // finds last child of each element in the elem set\n   * elem.last('.foo'); // find last child that has 'foo' class of each element in the set\n   */\n  lastChild(selector = null) {\n    return this.object((elems, elem) => {\n      const { value: found } = new Elem(elem)\n        .children()\n        .reverse()\n        .find((elem) => new Elem(elem).is(selector)) || {};\n\n      elems.add(found);\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#load\n   * @public\n   * @returns {Promise.<{ proper: Elem, broken: Elem }>} Promise with broken and proper images.\n   * @description Loads each image in the set and puts it to the proper or broken array.\n   *\n   * @example\n   * images.load().then(({ broken }) => {\n   *   broken.filter('img').ref('/fallback.png');\n   * });\n   */\n  load() {\n    const images = {\n      proper: new Elem(),\n      broken: new Elem()\n    };\n\n    return Promise.all(\n      this\n        .filter((elem) => getName(elem) === 'img')\n        .map((elem) => {\n          const $elem = new Elem(elem);\n\n          if (elem.complete) {\n            images[$elem.isBroken() ? 'broken' : 'proper'].push(elem);\n\n            return;\n          }\n\n          return new Promise((resolve) => {\n            const removeListeners = $elem.on({\n              load() {\n                images.proper.add(elem);\n\n                removeListeners();\n                resolve();\n              },\n              error() {\n                images.broken.add(elem);\n\n                removeListeners();\n                resolve();\n              }\n            });\n          });\n        })\n        .$\n    ).then(() => images);\n  }\n\n  /**\n   * @method Elem#moveAttr\n   * @public\n   * @param {String} attr - Attribute to move to the first element.\n   * @param {String} [value = ''] - Value to set for the attribute. If not set attribute of the previous element or '' used.\n   * @returns {Elem} Returns this.\n   * @description Method for moving an attribute from previous element to the next one (first element in this set).\n   *\n   * @example\n   * elem1.moveAttr('attr', 'value');     // attribute 'attr' set to 'value' on elem1\n   * elem2.moveAttr('attr');              // attribute 'attr' removed from elem1. set to 'value' on elem2\n   * elem3.moveAttr('attr', 'new value'); // attribute 'attr' removed from elem2. set to 'new value' on elem3\n   */\n  moveAttr(attr, value = '') {\n    const prev = attrs[attr];\n    const elem = this.elem();\n\n    if (prev && elem.length) {\n      if (arguments.length < 2) {\n        value = prev.attr(attr);\n      }\n\n      prev.removeAttr(attr);\n    }\n\n    if (elem.length) {\n      attrs[attr] = elem.attr(attr, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Elem#moveClass\n   * @public\n   * @param {String} cls - Class to move to the first element.\n   * @returns {Elem} Returns this.\n   * @description Method for moving a class from previous element to the next one (first element in this set).\n   *\n   * @example\n   * elem1.moveClass('cls'); // class 'cls' added to elem1\n   * elem2.moveClass('cls'); // class 'cls' removed from elem1. added to elem1\n   */\n  moveClass(cls) {\n    const prev = classes[cls];\n    const elem = this.elem();\n\n    if (prev && elem.length) {\n      prev.removeClass(cls);\n    }\n\n    if (elem.length) {\n      classes[cls] = elem.addClass(cls);\n    }\n\n    return this;\n  }\n\n  /**\n   * @member {String} Elem#name\n   * @type {String}\n   * @public\n   * @readonly\n   * @description nodeName (lowercased) of the first element in the set.\n   *\n   * @example\n   * const elem1 = elem.create('div');\n   * elem1.name // 'div'\n   */\n  get name() {\n    return getName(this.$[0]);\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @param {String} [selector = null] - If present, finds next element to every elem that matches the selector.\n   * If not, finds next element to each element in the set.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next();       // finds next element to each element in the set\n   * elem.next('.foo'); // finds next element to each element that has 'foo' class\n   */\n  next(selector = null) {\n    return this.object((elems, elem) => {\n      /* eslint no-cond-assign: 0 */\n      while (elem = elem.nextSibling) {\n        if (new Elem(elem).is(selector)) {\n          return elems.add(elem);\n        }\n      }\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#off\n   * @public\n   * @param {...ElemEventString} events - Events to remove.\n   * @returns {Elem} Returns this.\n   * @description Method that removes all the listeners from each element in the set specified by the events arguments.\n   *\n   * @example\n   * elem.off('click');\n   * elem.off('click, input');\n   * elem.off('click, input', 'focus');\n   */\n  off(...events) {\n    return this.forEach((elem) => {\n      const { listeners } = elem.dwayneData;\n\n      iterate(arguments, (event) => {\n        iterate(event.split(eventSeparator), (event) => {\n          (listeners[event] || new Super()).forEach(({ removeListener }) => removeListener());\n        });\n      });\n    });\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {String} [selector = null] - Selector to filter event targets.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   * For debugging: If you need to know what listeners are in work (and what selectors filter targets)\n   * you can look at the base property of the only dwayne listener that listens for the event\n   * and find all working listeners in listener.base.dwayneData.listeners[event].$.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   'input, select, textarea, datalist, keygen, output',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   {\n   *     'change, input': (e, elem, index) => console.log(elem.value),\n   *     'blur': () => console.log('blur')\n   *   },\n   *   'input, select, textarea, datalist, keygen, output'\n   * );\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, selector = null, listener) {\n    const allListeners = new Super({});\n\n    if (isFunction(selector)) {\n      listener = selector;\n      selector = null;\n    }\n\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    event = new Super(event).object((listeners, listener, event) => {\n      iterate(event.split(eventSeparator), (event) => {\n        listeners[event] = listener;\n      });\n    });\n\n    this.forEach((elem) => {\n      if (!isElement(elem) && !isWindow(elem) && !isHTMLDocument(elem)) {\n        return;\n      }\n\n      const { listeners } = (windowsDwayneData.find(({ element }) => element === elem) || {}).value || elem.dwayneData;\n\n      event.forEach((listener, event) => {\n        const removeEventListeners = listeners[event] = listeners[event] || new Super({}).define('index', {\n          value: 0,\n          configurable: true,\n          writable: true\n        });\n        const index = removeEventListeners.prop('index');\n\n        if (!removeEventListeners.has('listener')) {\n          const newListener = (e) => {\n            removeEventListeners.forEach(({ selector, listener }) => {\n              if (new Elem(e.target).is(selector)) {\n                listener.call(elem, e, elem, index);\n              }\n            });\n          };\n\n          newListener.base = elem;\n\n          elem.addEventListener(event, newListener, false);\n          removeEventListeners.define('listener', {\n            value: newListener,\n            configurable: true,\n            writable: true\n          });\n        }\n\n        const removeListener = () => {\n          removeEventListeners.delete(index);\n\n          if (!removeEventListeners.count) {\n            elem.removeEventListener(event, removeEventListeners.prop('listener'), false);\n            removeEventListeners.delete('listener');\n          }\n        };\n\n        allListeners.prop(event, (allListeners.prop(event) || new Arr()).push(removeListener));\n\n        removeEventListeners.assign({\n          index: index + 1,\n          [index]: {\n            selector,\n            listener,\n            removeListener\n          }\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterate(arguments, (event) => {\n          iterate(event.split(eventSeparator), (event) => {\n            if (allListeners.has(event)) {\n              allListeners.prop(event).forEach((removeListener) => removeListener());\n              allListeners.delete(event);\n            }\n          });\n        });\n\n        return;\n      }\n\n      allListeners.forEach((removeListeners) => {\n        removeListeners.forEach((removeListener) => removeListener());\n      });\n    };\n  }\n\n  /**\n   * @member {Number} Elem#outerHeight\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description Getter for finding how much height the element actually is.\n   *\n   * @example\n   * elem.css({\n   *   boxSizing: 'border-box',\n   *   height: '200px',\n   *   paddingTop: '2px',\n   *   paddingBottom: '3px',\n   *   borderTop: '1px solid black',\n   *   borderBottom: '4px solid black'\n   *   marginTop: '0px',\n   *   marginBottom: '5px'\n   * }).outerHeight; // 205\n   * elem\n   *   .css('box-sizing', 'content-box')\n   *   .outerHeight; // 215\n   * elem\n   *   .css('box-sizing', 'padding-box')\n   *   .outerHeight; // 210\n   */\n  get outerHeight() {\n    const elem = this.$[0];\n\n    if (isWindow(elem)) {\n      return elem.outerHeight;\n    }\n\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      boxSizing,\n      height,\n      marginTop,\n      marginBottom,\n      paddingTop,\n      paddingBottom\n    } = this.calcCSS();\n    const borders = px(borderTopWidth) + px(borderBottomWidth);\n    const paddings = px(paddingTop) + px(paddingBottom);\n\n    return px(height) + px(marginTop) + px(marginBottom) + outerSwitcher(boxSizing, [borders, paddings]);\n  }\n\n  /**\n   * @member {Number} Elem#outerWidth\n   * @type {Number}\n   * @public\n   * @readonly\n   * @description Getter for finding how much width the element actually is.\n   *\n   * @example\n   * elem.css({\n   *   boxSizing: 'border-box',\n   *   width: '200px',\n   *   paddingLeft: '2px',\n   *   paddingRight: '3px',\n   *   borderLeft: '1px solid black',\n   *   borderRight: '4px solid black'\n   *   marginLeft: '0px',\n   *   marginRight: '5px'\n   * }).outerWidth; // 205\n   * elem\n   *   .css('box-sizing', 'content-box')\n   *   .outerWidth; // 215\n   * elem\n   *   .css('box-sizing', 'padding-box')\n   *   .outerWidth; // 210\n   */\n  get outerWidth() {\n    const elem = this.$[0];\n\n    if (isWindow(elem)) {\n      return elem.outerWidth;\n    }\n\n    const {\n      borderLeftWidth,\n      borderRightWidth,\n      boxSizing,\n      marginLeft,\n      marginRight,\n      paddingLeft,\n      paddingRight,\n      width\n    } = this.calcCSS();\n    const borders = px(borderLeftWidth) + px(borderRightWidth);\n    const paddings = px(paddingLeft) + px(paddingRight);\n\n    return px(width) + px(marginLeft) + px(marginRight) + outerSwitcher(boxSizing, [borders, paddings]);\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.object((elems, elem) => elems.add(elem.parentNode), new Elem());\n  }\n\n  /**\n   * @method Elem#parentTree\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Returns wrap of all parents of each element in the set.\n   *\n   * @example\n   * elem.parentTree(); // Elem\n   */\n  parentTree() {\n    return this.object((elems, elem) => {\n      while (elem = elem.parentNode) {\n        elems.add(elem);\n      }\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @param {String} [selector = null] - If present, finds previous element to every elem that matches the selector.\n   * If not, finds previous element to each element in the set.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.next();       // finds previous element to each element in the set\n   * elem.next('.foo'); // finds previous element to each element that has 'foo' class\n   */\n  prev(selector = null) {\n    return this.object((elems, elem) => {\n      /* eslint no-cond-assign: 0 */\n      while (elem = elem.previousSibling) {\n        if (new Elem(elem).is(selector)) {\n          return elems.add(elem);\n        }\n      }\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, ElemValueCallback|*>} property - Either a string of a property or an assigned object.\n   * @param {ElemValueCallback|*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this.$[0] ? this.$[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem, index) => {\n      iterate(property, (value, prop) => {\n        elem[prop] = isFunction(value) ? value(elem[prop], elem, index) : value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#ref\n   * @public\n   * @param {String|ElemValueCallback} [link] - If it's present link to a resource.\n   * @returns {Elem|String} If the link argument isn't present it's a getter of the 'src' attribute\n   * for the one of following elements: img, script, iframe, audio, video; of the 'action' attribute\n   * for a form element and of the 'href' attribute for the rest. If it's present it's a setter\n   * of the same attribute for all the element in the set.\n   * @description Method for getting resources links and setting them.\n   *\n   * @example\n   * elem.ref('/some/cool/image.png');\n   * elem.ref(); // '/some/cool/image.png'\n   */\n  ref(link) {\n    if (!arguments.length) {\n      return this.attr(refSwitcher(this.name));\n    }\n\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      elem.attr(refSwitcher(elem.name), link);\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach((elem) => {\n      const parent = elem.parentNode;\n\n      if (parent) {\n        parent.removeChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr(...attributes) {\n    return this.forEach((elem) => {\n      if (!isElement(elem)) {\n        return;\n      }\n\n      iterate(arguments, (attr) => {\n        const ns = attrNSSwitcher(attr, [new Elem(elem)]);\n\n        if (isNull(ns)) {\n          elem.removeAttribute(attr);\n        } else {\n          elem.removeAttributeNS(ns, attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass(...classes) {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterate(isElement(elem) && arguments, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS(...props) {\n    return this.forEach((elem) => {\n      if (!isElement(elem)) {\n        return;\n      }\n\n      iterate(arguments, (css) => {\n        elem.style.removeProperty(css);\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {String|Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element, set of elements or a selector of them).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toFind(element);\n\n    const parent = this.first().parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = this.next().first().$[0];\n    const prev = this.prev().first().$[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    this.first().remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#setOf\n   * @public\n   * @param {String} type - HTML element type.\n   * @param {Number|Object|Array.<*>} iterator - A number (how many elements to create inside each element),\n   * an object or an array to iterate over.\n   * @param {ElemSetOfCallback} callback\n   * @returns {Elem} New instance of Elem.\n   * @description Function for creating set of elements inside each element in the set based on an array or an object.\n   *\n   * @example\n   * table.setOf('tr', [[1, 2], [3, 4], [5, 6]], (row, array) => {\n   *   D(row).setOf('td', array, (col, number) => {\n   *     D(col).text(number);\n   *   });\n   * });\n   */\n  setOf(type, iterator, callback) {\n    validate({ 2: callback }, { 2: ['function'] }, 'Elem#setOf');\n\n    iterator = new Super(iterator).$;\n\n    if (isNumber(iterator)) {\n      try {\n        validate({ 1: iterator }, { 1: ['intLike', '>=0'] }, 'Elem#setOf');\n      } catch (e) {\n        throw new Error('2nd argument must be either or non-negative integer, or object! (at Elem#setOf)');\n      }\n\n      iterator = array(iterator).$;\n    }\n\n    return this.object((elems, elem, index) => {\n      iterate(iterator, (value, key) => {\n        const created = new Elem(elem).create(type);\n\n        callback(created.$[0], value, key, iterator, elem, index);\n\n        elems.add(created);\n      });\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach((elem) => {\n      const { dwayneData } = elem;\n\n      elem = new Elem(elem);\n\n      if (elem.css('display').indexOf('none') === 0) {\n        elem.css('display', dwayneData.previousDisplay);\n      }\n\n      dwayneData.previousDisplay = '';\n    });\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|ElemValueCallback|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop(textProperty);\n    }\n\n    return this.forEach((elem, index) => {\n      const txt = elem[textProperty];\n\n      new Elem(elem).prop(\n        textProperty,\n        isFunction(text)\n          ? text(txt, elem, index)\n          : text\n      );\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return (arguments.length < 2 ? !this.hasClass(cls) : condition)\n      ? this.addClass(cls)\n      : this.removeClass(cls);\n  }\n\n  get toStringTag() {\n    return toStringTag(this.$$);\n  }\n\n  /**\n   * @method Elem#up\n   * @public\n   * @param {Integer} [level = 1] - What level up along the tree should be the parent.\n   * @returns {Elem} New instance of Elem.\n   * @description Creates a collection of parents of level &lt;level&gt;.\n   *\n   * @example\n   * elem.up();\n   * elem.up(2);\n   */\n  up(level = 1) {\n    validate([level], [['intLike', '>=0']], 'Elem#up');\n\n    level = Number(level);\n\n    return this.object((elems, elem) => {\n      let n = level;\n\n      while (n-- && elem) {\n        elem = elem.parentNode;\n      }\n\n      elems.add(elem);\n    }, new Elem());\n  }\n\n  /**\n   * @method Elem#validate\n   * @public\n   * @param {ValidateCallback} [validator] - If present, function that validates inputs.\n   * @returns {Elem|Object.<String, Error|*>|null}\n   * If a callback argument provided returns this. If no arguments provided returns either an object\n   * with input names keys and errors values or null if no errors found.\n   * @description If a callback argument provided adds it to the element validators list.\n   * If no arguments provided validates every input element in the set with its own functions.\n   * If an element is a form it validates all input elements inside it. After the validation\n   * fires 'validate' event with 'valid' and 'error' (if form it's errors) properties.\n   *\n   * @example\n   * form.on('input change', 'input', (value, input) => {\n   *   input = D(input);\n   *\n   *   if (Number(value) % 3) {\n   *     input.addClass('invalid');\n   *\n   *     throw new Error('The value should be divided by 3!');\n   *   }\n   *\n   *   input.removeClass('invalid');\n   * });\n   */\n  validate(validator) {\n    validate([validator], ['function||!'], 'Elem#validate');\n\n    if (validator) {\n      return this.forEach(({ dwayneData }) => {\n        dwayneData.validators.push(validator);\n      });\n    }\n\n    const errors = new Super({ errors: null });\n\n    this\n      .filter(`${ inputElements }, form`)\n      .forEach((elem, index) => {\n        if (getName(elem) === 'form') {\n          let formErrors = { errors: null };\n          const form = new Elem(elem);\n          const inputs = form.find(inputElements);\n\n          inputs.forEach((input, index) => {\n            validatorWrap(input, index, formErrors);\n          });\n\n          errors.deepAssign(formErrors);\n\n          formErrors = formErrors.errors;\n\n          form.dispatch('validate', {}, {\n            valid: !formErrors,\n            errors: formErrors\n          });\n\n          return inputs.forEach((input) => {\n            const inputError = (formErrors || {})[input.name];\n\n            new Elem(input).dispatch('validate', {}, {\n              valid: !inputError,\n              error: inputError || null\n            });\n          });\n        }\n\n        let inputError = { errors: null };\n\n        validatorWrap(elem, index, inputError);\n        errors.deepAssign(inputError);\n\n        inputError = (inputError.errors || {})[elem.name];\n\n        new Elem(elem).dispatch('validate', {}, {\n          valid: !inputError,\n          error: inputError || null\n        });\n      });\n\n    function validatorWrap(input, index, errors) {\n      try {\n        if (input.validity && !input.validity.valid) {\n          throw new Error(input.validationMessage);\n        }\n\n        input.dwayneData.validators.forEach((validator) => {\n          validator(input.value, input, index);\n        });\n      } catch (err) {\n        (errors.errors = errors.errors || {})[input.name] = err;\n      }\n    }\n\n    if (errors.every((error) => isNull(error))) {\n      return null;\n    }\n\n    return errors.$.errors;\n  }\n\n  /**\n   * @method Elem#width\n   * @public\n   * @param {*|ElemValueCallback} [width] - Width to set.\n   * @returns {Elem|String} If no arguments passed width of the first element in the set returned.\n   * Otherwise all elements widths in the set are set to the width argument.\n   * @description Gets or sets width.\n   *\n   * @example\n   * elem.width(123);\n   * elem.width(); // 123\n   */\n  width(width) {\n    return this.prop.apply(this, new Arr(arguments).unshift('width').$);\n  }\n}\n\ndefineProperties(Elem.prototype, {\n  [Symbol.toStringTag]: 'Elem'\n});\n\n/**\n * @const {Elem} win\n * @type {Elem}\n * @public\n * @description Elem instance of window.\n */\nconst win = new Elem(global);\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nconst doc = new Elem(nativeDocument);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nconst html = new Elem(nativeDocument.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nconst body = new Elem(nativeDocument.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nconst head = new Elem(nativeDocument.head);\n\nconst elements = new Arr(htmlElements).concat(svgElements).$;\nconst props = new Arr(elements).map((type) => new Str(type).toCamelCase().$).$;\n\ndynamicDefineProperties(Elem.prototype, props, (elem, i) => function () {\n  return this.create.apply(this, new Arr(arguments).unshift(elements[i]).$);\n});\n\ndynamicDefineProperties(Elem.prototype, canvasGetMethods, (method) => function () {\n  const ctx = this.ctx();\n\n  if (ctx) {\n    return ctx[method].apply(ctx, arguments);\n  }\n});\n\ndynamicDefineProperties(Elem.prototype, canvasRestMethods, (method) => function () {\n  const ctx = this.ctx();\n\n  if (ctx) {\n    ctx[method].apply(ctx, arguments);\n  }\n\n  return this;\n});\n\n/**\n * @function toFind\n * @private\n * @param {Element|Elem|String} elem - Element, selector of Elements or Elem.\n * @returns {Elem} Instance of Elem.\n */\nfunction toFind(elem) {\n  if (isElem(elem)) {\n    return elem;\n  }\n\n  if (isString(elem)) {\n    elem = find(elem);\n  }\n\n  return new Elem(elem);\n}\n\n/**\n * @function isElem\n * @private\n * @param {*} value - Value to check if it's Elem.\n * @returns {Boolean} If the value is Elem.\n * @description Returns if the value is Elem or not.\n */\nfunction isElem(value) {\n  return value instanceof Elem;\n}\n\n/**\n * @function isWindow\n * @private\n * @param {*} value - Value to check if it's Window.\n * @returns {Boolean} If the value is Window.\n * @description Returns if the value is Window or not.\n */\nfunction isWindow(value) {\n  return toStringTag(value) === 'Window';\n}\n\n/**\n * @function isHTMLDocument\n * @private\n * @param {*} value - Value to check if it's HTMLDocument.\n * @returns {Boolean} If the value is HTMLDocument.\n * @description Returns if the value is HTMLDocument or not.\n */\nfunction isHTMLDocument(value) {\n  return toStringTag(value) === 'HTMLDocument';\n}\n\n/**\n * @function isDocumentFragment\n * @private\n * @param {*} value - Value to check if it's a DocumentFragment.\n * @returns {Boolean} If the value is a DocumentFragment.\n * @description Returns if the value is a DocumentFragment or not.\n */\nfunction isDocumentFragment(value) {\n  return toStringTag(value) === 'DocumentFragment';\n}\n\n/**\n * @function isStyleRule\n * @private\n * @param {*} value - Value to check if it's a style rule.\n * @returns {Boolean} If the value is a style rule.\n * @description Returns if the value is a style rule or not.\n */\nfunction isStyleRule(value) {\n  return toStringTag(value) === 'CSSStyleRule';\n}\n\n/**\n * @function\n * @private\n * @param {*} value - Value to check if it's Comment or Text.\n * @returns {Boolean} If the value is HTMLDocument.\n * @description Returns if the value is Comment or Text or not.\n */\nfunction isCommentOrText(value) {\n  const tag = toStringTag(value);\n\n  return tag === 'Comment' || tag === 'Text';\n}\n\n/**\n * @function getElem\n * @private\n * @param {Elem} elem - Element to check.\n * @returns {Element} The argument or a fallback if needed.\n */\nfunction getElem(elem) {\n  return isElement(elem.$[0]) ? elem.$[0] : emptyDiv;\n}\n\n/**\n * @function getName\n * @private\n * @param {Element} [elem] - Element which name is needed to know.\n * @returns {String} Element name.\n */\nfunction getName(elem) {\n  return (elem && elem.nodeName && elem.nodeName.toLowerCase()) || '';\n}\n\n/**\n * @function addDwayneData\n * @private\n * @param {Element} elem - Element to add dwayneData to.\n * @returns {void}\n */\nfunction addDwayneData(elem) {\n  if (!{}.hasOwnProperty.call(elem, 'dwayneData') && !isWindow(elem)) {\n    /**\n     * @member Element#dwayneData\n     * @type {Object}\n     * @protected\n     * @property {String} previousDisplay - Parameter used for hiding/showing elements.\n     * @property {Object.<String, Super>} removeListeners - Parameter used for remove event listeners.\n     * @property {CanvasRenderingContext2D} [ctx] - Canvas rendering context.\n     * @property {Arr} validators - Validators assigned to element.\n     * @description D data.\n     */\n    Object.defineProperty(elem, 'dwayneData', {\n      value: {\n        previousDisplay: '',\n        listeners: {},\n        ctx: getName(elem) === 'canvas' && elem.getContext('2d'),\n        validators: new Arr([])\n      }\n    });\n  } else if (isWindow(elem) && !windowsDwayneData.some(({ element }) => element === elem)) {\n    windowsDwayneData.push({\n      element: elem,\n      listeners: {}\n    });\n  }\n}\n\nconstructors[2].push({\n  check: (elem) => (\n    isElement(elem) ||\n    isWindow(elem) ||\n    isHTMLDocument(elem) ||\n    isCommentOrText(elem) ||\n    isDocumentFragment(elem) ||\n    /^(HTMLCollection|NodeList)$/.test(toStringTag(elem))\n  ),\n  cls: Elem\n});\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nfunction find(selector, base = nativeDocument) {\n  return new Elem(\n    isElement(base) || isHTMLDocument(base)\n      ? base.querySelectorAll(String(selector))\n      : []\n  );\n}\n\n/**\n * @function parseHTML\n * @public\n * @param {String} html - HTML to parse.\n * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be\n * collapsed during the parsing.\n * @returns {Elem} New instance of Elem.\n * @description Parses HTML and returns a wrap of #document-fragment containing the contents.\n *\n * @example\n * parseHTML('<div>123</div>'); // Elem\n */\nfunction parseHTML(html, collapseWhiteSpace) {\n  const json = markupToJSON(html, collapseWhiteSpace);\n  const template = doc.template();\n  const elem = new Elem(template.$[0].content);\n\n  json.forEach(function forEachNode(node) {\n    const {\n      name,\n      attrs,\n      value,\n      parent,\n      children\n    } = node;\n\n    const parentNode = parent.elem || elem;\n    const element = parentNode.create(name);\n\n    node.elem = element;\n\n    if (value) {\n      element.text(value);\n    }\n\n    if (attrs) {\n      element.attr(new Super(attrs).map((value) => (\n        value === true ? '' : value\n      )).$);\n    }\n\n    if (name === 'template') {\n      node.elem = new Elem(element.prop('content'));\n    }\n\n    if (children) {\n      children.forEach(forEachNode);\n    }\n  });\n\n  return new Elem(elem);\n}\n\n/**\n * @function px\n * @public\n * @param {String|Number} size - String containing pixels value or a number.\n * @returns {Number} Number of pixels.\n * @description Function for parsing pixel strings.\n *\n * @example\n * px('0px');  // 0\n * px('42px'); // 42\n */\nfunction px(size) {\n  return Number(String(size).replace(/px$/, ''));\n}\n\nexport { Elem, win, doc, html, body, head, find, parseHTML, px };\n","export function registerDBlock(Block) {\n  class DBlock extends Block {\n    static template = ''\n      + '<d-elements'\n      + '  value=\"{elems}\"'\n      + '  parentScope=\"{ParentScope}\"'\n      + '  parentTemplate=\"{ParentTemplate}\"'\n      + '/>';\n\n    afterConstruct() {\n      const {\n        parentScope: {\n          $$: {\n            parentScope: parentParentScope,\n            parentTemplate: parentParentTemplate,\n            argsChildren: children\n          }\n        },\n        argsChildren: ownChildren,\n        parentTemplate,\n        dBlockName\n      } = this.$$;\n      let found;\n\n      if (ownChildren.length) {\n        return;\n      }\n\n      this.ParentScope = parentParentScope;\n      this.ParentTemplate = parentParentTemplate;\n\n      if (dBlockName) {\n        found = children.find(({ name: nodeName }) => nodeName === `d-block:${ dBlockName }`);\n\n        if (!found) {\n          let parent = this;\n\n          /* eslint no-empty: 0 */\n          while (\n            (parent = parent.$$.parentScope)\n            && !(found = parent.$$.dBlocks.find(({ $$: { dBlockName: DBlockName } }) => DBlockName === dBlockName))\n            && parent.$$.parentScope.$$.name === '#d-item'\n          ) {}\n\n          if (found) {\n            this.ParentScope = parent;\n            this.ParentTemplate = parentTemplate;\n            found.value = {\n              children: found.value.$$.argsChildren\n            };\n          }\n        }\n\n        this.elems = found && found.value.children.length\n          ? found.value.children\n          : null;\n      } else {\n        this.elems = children;\n      }\n    }\n  }\n\n  return {\n    name: 'd-block',\n    value: DBlock\n  };\n}\n","import { Arr, array } from '../Arr';\nimport { Super } from '../Super';\nimport {\n  assign, iterate,\n  isArray, isFunction, isNumber\n} from '../helpers';\n\nexport function registerDEach(Block, createBlock) {\n  class DEach extends Block {\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args: {\n          item: itemName = '$item',\n          index: indexName = '$index'\n        }\n      } = this;\n\n      assign(this.$$, {\n        uids: new Super({}),\n        items: new Arr([]),\n        UID: this.args.uid || undefined,\n        itemName,\n        indexName\n      });\n    }\n\n    afterRender() {\n      this.watch('args.set', 'args.sortBy', 'args.filterBy', () => {\n        const {\n          argsChildren,\n          uids,\n          parentScope,\n          parentElem,\n          parentTemplate,\n          scope,\n          itemName,\n          indexName,\n          UID\n        } = this.$$;\n        const {\n          args: { sortBy }\n        } = this;\n        const $uids = uids.$;\n        const newKeys = {};\n        const newUIDs = {};\n        let {\n          set,\n          filterBy\n        } = this.args;\n\n        if (isNumber(set)) {\n          set = array(set).$;\n        }\n\n        if (isArray(set) && isFunction(sortBy)) {\n          set = new Arr(set)\n            .slice()\n            .sort(sortBy)\n            .$;\n        }\n\n        if (isFunction(filterBy)) {\n          filterBy = [filterBy];\n        }\n\n        if (isArray(filterBy)) {\n          iterate(filterBy, (filter) => {\n            set = new Super(set).filter(filter).$;\n          });\n        }\n\n        new Super(set).forEach((item, index) => {\n          scope[itemName] = item;\n          scope[indexName] = index;\n\n          const uid = parentScope.$$.evaluate(UID, null, null, false, false, this);\n\n          newKeys[uid] = newKeys[uid] || {};\n          newKeys[uid][index] = true;\n          newUIDs[index] = uid;\n        });\n\n        scope[itemName] = null;\n        scope[indexName] = null;\n\n        uids.forEach((items, uid) => {\n          if (!newKeys[uid]) {\n            items.forEach((Item) => {\n              Item.$$.remove();\n            });\n\n            return;\n          }\n\n          items.splice(Object.keys(newKeys[uid]).length).forEach((Item) => {\n            Item.$$.remove();\n          });\n        });\n\n        let prevBlock;\n\n        new Super(set).forEach((item, index) => {\n          const uid = newUIDs[index];\n          let block;\n\n          if ($uids[uid] && $uids[uid].length) {\n            block = newKeys[uid][index] = uids.$[uid].shift();\n            block.$$.scope[indexName] = index;\n            block.$$.scope[itemName] = item;\n\n            if (block.$$.prevBlock !== prevBlock) {\n              const { content } = block.$$;\n\n              if (prevBlock) {\n                prevBlock.$$.insertAfterIt(content, true);\n              } else {\n                this.$$.insertInStartOfIt(content, true);\n              }\n            }\n          } else {\n            block = newKeys[uid][index] = createBlock({\n              node: {\n                itemName,\n                indexName,\n                item,\n                index,\n                name: '#d-item',\n                children: argsChildren\n              },\n              parent: this,\n              parentElem,\n              parentBlock: this,\n              parentScope,\n              parentTemplate,\n              prevBlock\n            });\n          }\n\n          block.$$.prevBlock = prevBlock;\n          prevBlock = block;\n        });\n\n        this.$$.uids = new Super(newKeys).map((items) => (\n          new Super(items).values()\n        ));\n      });\n    }\n  }\n\n  return {\n    name: 'd-each',\n    value: DEach\n  };\n}\n","import { Arr } from '../Arr';\nimport { Elem } from '../Elem';\n\nexport function registerDElements(Block, createBlock) {\n  class DElements extends Block {\n    afterConstruct() {\n      const { parentElem } = this.$$;\n      const {\n        parentScope,\n        parentTemplate\n      } = this.args;\n      let firstTime = true;\n\n      this.watch('args.value', () => {\n        if (firstTime) {\n          firstTime = false;\n\n          return;\n        }\n\n        const {\n          children,\n          mixins,\n          parent,\n          watchersToRemove,\n          content\n        } = this.$$;\n        const { value } = this.args;\n\n        children.forEach((child) => {\n          child.$$.remove(true);\n        });\n        mixins.forEach((mixin) => {\n          mixin.$$.remove(true);\n        });\n        content.remove();\n\n        if (parent instanceof Block) {\n          parent.$$.removeContent(content);\n        }\n\n        this.$$.children = new Arr([]);\n        this.$$.mixins = new Arr([]);\n        this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n          if (forDElements) {\n            return true;\n          }\n\n          const index = watchers.indexOf(watcher);\n\n          if (index !== -1) {\n            watchers.splice(index, 1);\n          }\n        });\n        this.$$.content = new Elem();\n\n        let prevBlock;\n\n        new Arr(value || []).forEach((child) => {\n          prevBlock = createBlock({\n            node: child,\n            parent: this,\n            parentElem,\n            parentBlock: this,\n            parentScope,\n            parentTemplate,\n            prevBlock\n          });\n        });\n      });\n    }\n  }\n\n  return {\n    name: 'd-elements',\n    value: DElements\n  };\n}\n","export function registerDIf(Block) {\n  class DIf extends Block {\n    static template = ''\n      + '<d-elements'\n      + '  value=\"{elems}\"'\n      + '  parentScope=\"{$$.parentScope}\"'\n      + '  parentTemplate=\"{$$.parentTemplate}\"'\n      + '/>';\n\n    constructor(opts) {\n      super(opts);\n\n      const { parentScope } = this.$$;\n      let index = Infinity;\n      const values = this.$$.argsChildren.map((child, i) => {\n        const {\n          name,\n          attrs,\n          children\n        } = child;\n        let cond = attrs.if;\n\n        if (name !== 'd-else' && cond) {\n          cond = parentScope.$$.evaluate(cond, (newValue) => {\n            if (!!newValue === values.$[i]) {\n              return;\n            }\n\n            values.$[i] = !!newValue;\n\n            if (i > index) {\n              return;\n            }\n\n            if (i < index) {\n              index = i;\n              this.elems = children;\n\n              return;\n            }\n\n            const found = values.find(Boolean);\n\n            if (found) {\n              index = found.key;\n              this.elems = this.$$.argsChildren.$[found.key].children;\n            } else {\n              index = Infinity;\n              this.elems = null;\n            }\n          }, this);\n        } else {\n          cond = true;\n        }\n\n        if (cond && index === Infinity) {\n          index = i;\n          this.elems = children;\n        }\n\n        return !!cond;\n      });\n    }\n  }\n\n  return {\n    name: 'd-if',\n    value: DIf\n  };\n}\n","export function registerDItem(Block) {\n  class DItem extends Block {\n    static template = ''\n      + '<d-elements'\n      + '  value=\"{$$.argsChildren}\"'\n      + '  parentScope=\"{this}\"'\n      + '  parentTemplate=\"{$$.parentTemplate}\"'\n      + '/>';\n  }\n\n  return {\n    name: '#d-item',\n    value: DItem\n  };\n}\n","import { Arr } from '../Arr';\nimport { Super } from '../Super';\n\nexport function registerDSwitch(Block) {\n  class DSwitch extends Block {\n    static template = ''\n      + '<d-elements'\n      + '  value=\"{elems}\"'\n      + '  parentScope=\"{$$.parentScope}\"'\n      + '  parentTemplate=\"{$$.parentTemplate}\"'\n      + '/>';\n\n    index = Infinity;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        $$: { parentScope },\n        args,\n        args: { value }\n      } = this;\n      let wasDefault;\n\n      this.values = this.$$.argsChildren.object((values, child, i) => {\n        const {\n          name,\n          attrs,\n          children\n        } = child;\n        let val = attrs.if;\n\n        if (wasDefault) {\n          return;\n        }\n\n        if (name !== 'd-case' && name !== 'd-default') {\n          return;\n        }\n\n        if (name === 'd-default') {\n          wasDefault = true;\n        }\n\n        if (name === 'd-default') {\n          val = args.value;\n        } else if (val) {\n          val = parentScope.$$.evaluate(val, (newValue) => {\n            if (this.equals(this.values.$[i].value, newValue)) {\n              return;\n            }\n\n            this.values.$[i].value = newValue;\n\n            if (i > this.index) {\n              return;\n            }\n\n            if (i < this.index) {\n              this.index = i;\n              this.elems = children;\n\n              return;\n            }\n\n            const found = this.values.find(({ value }) => (\n              this.equals(value, args.value)\n            ));\n\n            if (found) {\n              this.index = found.key;\n              this.elems = found.value.children;\n            } else {\n              this.index = Infinity;\n              this.elems = null;\n            }\n          }, this);\n        } else {\n          val = undefined;\n        }\n\n        if (this.equals(val, value) && this.index === Infinity) {\n          this.index = i;\n          this.elems = children;\n        }\n\n        values.push({\n          name,\n          children,\n          value: val\n        });\n      }, new Arr([]));\n    }\n\n    afterConstruct() {\n      let firstTime = true;\n\n      this.watch('args.value', () => {\n        if (firstTime) {\n          firstTime = false;\n\n          return;\n        }\n\n        const {\n          value: newValue\n        } = this.args;\n\n        this.index = Infinity;\n        this.values.forEach(({ name, value, children }, i) => {\n          const val = name === 'd-default'\n            ? newValue\n            : value;\n\n          if (this.equals(val, newValue) && this.index === Infinity) {\n            this.index = i;\n            this.elems = children;\n          }\n        });\n\n        if (this.index === Infinity) {\n          this.elems = null;\n        }\n      });\n    }\n\n    equals(value1, value2) {\n      return new Super(value1).equals(value2);\n    }\n  }\n\n  return {\n    name: 'd-switch',\n    value: DSwitch\n  };\n}\n","import { Super } from '../Super';\n\nexport function registerDAttr(Mixin) {\n  class DAttr extends Mixin {\n    attrs = {};\n\n    afterUpdate(newValue) {\n      const {\n        elem,\n        args,\n        attrs\n      } = this;\n\n      if (args) {\n        newValue = new Super(args).object((attrs, attr) => {\n          attrs[attr] = newValue;\n        });\n      }\n\n      newValue = new Super(newValue || {}).$;\n\n      new Super(attrs).forEach((value, prop) => {\n        if (!newValue[prop]) {\n          elem.removeAttr(prop);\n        }\n      });\n      elem.attr(newValue);\n\n      this.attrs = newValue;\n    }\n\n    beforeRemove() {\n      const {\n        elem,\n        attrs\n      } = this;\n\n      elem.removeAttr.apply(elem, new Super(attrs).keys().$);\n    }\n  }\n\n  return {\n    name: 'd-attr',\n    value: DAttr\n  };\n}\n\n","import { isFunction } from '../helpers';\n\nexport function registerDBind(Mixin) {\n  class DBind extends Mixin {\n    afterUpdate(value) {\n      if (this.off) {\n        this.off();\n      }\n\n      if (!isFunction(value)) {\n        return;\n      }\n\n      if (this.args) {\n        this.off = this.elem.on(this.args.join(','), value);\n      } else {\n        console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n      }\n    }\n\n    beforeRemove() {\n      const { off } = this;\n\n      if (off) {\n        off();\n      }\n    }\n  }\n\n  return {\n    name: 'd-bind',\n    value: DBind\n  };\n}\n","import { Super } from '../Super';\nimport { isArray, isString, iterate } from '../helpers';\n\nexport function registerDClass(Mixin) {\n  class DClass extends Mixin {\n    classes = [];\n\n    afterUpdate(newValue) {\n      const {\n        elem,\n        args,\n        classes\n      } = this;\n      const newClasses = [];\n\n      newValue = new Super(newValue).$;\n\n      if (args) {\n        newValue = newValue\n          ? args\n          : [];\n      }\n\n      if (isString(newValue)) {\n        newValue = newValue.split(/\\s+/);\n      }\n\n      if (isArray(newValue)) {\n        iterate(classes, (cls) => {\n          if (newValue.indexOf(cls) === -1) {\n            elem.removeClass(cls);\n          }\n        });\n        iterate(newValue, (cls) => {\n          if (isString(cls)) {\n            newClasses.push(cls);\n            elem.addClass(cls);\n          }\n        });\n      } else {\n        iterate(classes, (cls) => {\n          if (!newValue || !newValue[cls]) {\n            elem.removeClass(cls);\n          }\n        });\n        iterate(newValue, (val, cls) => {\n          if (val) {\n            newClasses.push(cls);\n            elem.addClass(cls);\n          }\n        });\n      }\n\n      this.classes = newClasses;\n    }\n\n    beforeRemove() {\n      const { elem } = this;\n\n      elem.removeClass.apply(elem, new Super(this.value).keys().$);\n    }\n  }\n\n  return {\n    name: 'd-class',\n    value: DClass\n  };\n}\n","import { isFunction, isString } from '../helpers';\n\nexport function registerDElem(Mixin, createBlock, Block) {\n  class DElem extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args,\n        parentTemplate,\n        elem\n      } = this;\n      let scope = parentTemplate;\n      let value = this.evaluateOnce();\n\n      if (args) {\n        scope = value instanceof Block\n          ? value\n          : parentTemplate;\n        value = args[0];\n      }\n\n      if (isFunction(value)) {\n        value(elem);\n      } else if (isString(value)) {\n        scope[value] = elem;\n      }\n    }\n  }\n\n  return {\n    name: 'd-elem',\n    value: DElem\n  };\n}\n","export function registerDHide(Mixin) {\n  class DHide extends Mixin {\n    afterUpdate(value) {\n      const { elem } = this;\n\n      if (value) {\n        elem.hide();\n      } else {\n        elem.show();\n      }\n    }\n\n    beforeRemove() {\n      this.elem.show();\n    }\n  }\n\n  return {\n    name: 'd-hide',\n    value: DHide\n  };\n}\n","import { isFunction, isString } from '../helpers';\n\nexport function registerDNode(Mixin, createBlock, Block) {\n  class DNode extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args,\n        parentTemplate,\n        node\n      } = this;\n      let scope = parentTemplate;\n      let value = this.evaluateOnce();\n\n      if (args) {\n        scope = value instanceof Block\n          ? value\n          : parentTemplate;\n        value = args[0];\n      }\n\n      if (isFunction(value)) {\n        value(node);\n      } else if (isString(value)) {\n        scope[value] = node;\n      }\n    }\n  }\n\n  return {\n    name: 'd-node',\n    value: DNode\n  };\n}\n","export function registerDOn(Mixin) {\n  class DOn extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      if (this.args) {\n        this.off = this.elem.on(this.args.join(','), () => {\n          this.evaluateOnce();\n        });\n      } else {\n        console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n      }\n    }\n\n    beforeRemove() {\n      const { off } = this;\n\n      if (off) {\n        off();\n      }\n    }\n  }\n\n  return {\n    name: 'd-on',\n    value: DOn\n  };\n}\n","export function registerDShow(Mixin) {\n  class DShow extends Mixin {\n    afterUpdate(value) {\n      const { elem } = this;\n\n      if (value) {\n        elem.show();\n      } else {\n        elem.hide();\n      }\n    }\n\n    beforeRemove() {\n      this.elem.show();\n    }\n  }\n\n  return {\n    name: 'd-show',\n    value: DShow\n  };\n}\n","import { Arr } from '../Arr';\nimport { Super } from '../Super';\nimport { isString } from '../helpers';\n\nexport function registerDStyle(Mixin) {\n  class DStyle extends Mixin {\n    css = {};\n\n    afterUpdate(newValue, oldValue) {\n      const {\n        elem,\n        args,\n        css\n      } = this;\n\n      if (args) {\n        newValue = new Super(args).object((css, prop) => {\n          css[prop] = newValue;\n        });\n      }\n\n      if (isString(newValue)) {\n        newValue = new Arr(newValue.split(/; ?/))\n          .filter()\n          .object((css, item) => {\n            const [prop, value] = item;\n\n            css[prop] = value;\n          });\n      }\n\n      newValue = new Super(newValue || {}).$;\n\n      new Super(css).forEach((value, prop) => {\n        if (!newValue[prop]) {\n          elem.removeCSS(prop);\n        }\n      });\n      elem.css(newValue);\n\n      this.css = newValue;\n    }\n\n    beforeRemove() {\n      const {\n        elem,\n        css\n      } = this;\n\n      elem.removeCSS.apply(elem, new Super(css).keys().$);\n    }\n  }\n\n  return {\n    name: 'd-style',\n    value: DStyle\n  };\n}\n","import { switcher } from '../Switcher';\nimport { isFunction } from '../helpers';\n\nconst listenerSwitcher = switcher('strictEquals', 'input')\n  .case('form', 'input, change')\n  .case('select', 'change')\n  .case('input', (type) => (\n    type === 'radio'\n    || type === 'checkbox'\n    || type === 'color'\n    || type === 'file'\n      ? 'change'\n      : 'change input'\n  ));\n\nexport function registerDValidate(Mixin) {\n  class DValidate extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const { elem } = this;\n      const validator = this.value = this.evaluateOnce();\n\n      if (isFunction(validator)) {\n        elem.validate(validator);\n      } else if (validator === true) {\n        this.off = elem.on(listenerSwitcher(elem.name, [elem.prop('type')]), () => {\n          elem.validate();\n        });\n      }\n    }\n\n    beforeRemove() {\n      const { value } = this;\n\n      if (isFunction(value)) {\n        const { validators } = this.node.dwayneData;\n        const index = validators.indexOf(value);\n\n        if (index !== -1) {\n          validators.splice(index, 1);\n        }\n      } else if (value === true) {\n        this.off();\n      }\n    }\n  }\n\n  return {\n    name: 'd-validate',\n    value: DValidate\n  };\n}\n","import { Arr } from '../Arr';\nimport { switcher } from '../Switcher';\nimport { isArray, isFunction, isNil, constructEvalFunction } from '../helpers';\n\nconst propSwitcher = switcher('strictEquals', (type, elem) => (\n  elem.hasAttr('contenteditable') || elem.hasAttr('contentEditable')\n    ? 'text'\n    : 'value'\n))\n  .case('select', (type, elem) => (\n    elem.hasAttr('multiple')\n      ? 'multiple-select'\n      : 'value'\n  ))\n  .case('input', (type) => {\n    if (type === 'file') {\n      return 'files';\n    }\n\n    return type === 'radio' || type === 'checkbox'\n      ? 'checked'\n      : 'value';\n  });\nconst setValueSwitcher = switcher('strictEquals', (value) => value)\n  .case('input', (value, type, inputValue) => {\n    if (type !== 'radio' && type !== 'checkbox') {\n      return value;\n    }\n\n    if (type === 'radio') {\n      return value === inputValue;\n    }\n\n    return value.indexOf(inputValue) !== -1;\n  });\nconst getValueSwitcher = switcher('strictEquals', (value) => value)\n  .case('select', (value, type, inputValue, values, elem, options, init, isMultiple) => {\n    if (!isMultiple) {\n      return value;\n    }\n\n    return options\n      .object((values, { selected, value }) => {\n        if (selected && values.indexOf(value) === -1) {\n          values.push(value);\n        }\n      }, [])\n      .$;\n  })\n  .case('input', (value, type, inputValue, values, elem, options, init) => {\n    if (type !== 'radio' && type !== 'checkbox') {\n      return value;\n    }\n\n    if (type === 'radio') {\n      return value\n        ? inputValue\n        : null;\n    }\n\n    if (!value && init) {\n      return values;\n    }\n\n    if (value) {\n      if (values) {\n        return values.indexOf(inputValue) === -1\n          ? new Arr(values).concat(inputValue).$\n          : values;\n      }\n\n      return [inputValue];\n    }\n\n    if (!isArray(values)) {\n      return [];\n    }\n\n    const index = values.indexOf(inputValue);\n\n    if (index !== -1) {\n      return [\n        ...new Arr(values).slice(0, index).$,\n        ...new Arr(values).slice(index + 1).$\n      ];\n    }\n\n    return values;\n  });\nconst listenerSwitcher = switcher('strictEquals', 'input')\n  .case('select', 'change')\n  .case('input', (type) => (\n    type === 'radio'\n    || type === 'checkbox'\n    || type === 'color'\n    || type === 'file'\n      ? 'change'\n      : 'change input'\n  ));\n\nexport function registerDValue(Mixin, createBlock, Block) {\n  class DValue extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const {\n        args,\n        parentTemplate,\n        elem,\n        node\n      } = this;\n      const name = elem.name;\n      const type = elem.prop('type');\n      const value = this.evaluateOnce();\n      let initialScopeValue = null;\n\n      this.prop = propSwitcher(name, [type, elem]);\n      this.name = name;\n      this.type = type;\n      this.value = value;\n      this.options = elem.find('option');\n      this.scope = parentTemplate;\n\n      if (args) {\n        this.name = args[0];\n        this.scope = value instanceof Block\n          ? value\n          : parentTemplate;\n      }\n\n      if (!isFunction(value)) {\n        initialScopeValue = this.scope.$$.evaluate(constructEvalFunction(`$.${ value }`, value), (newValue) => {\n          if (this.currentValue !== newValue) {\n            this.currentValue = newValue;\n            this.setProp(newValue);\n          }\n        }, this);\n      }\n\n      const initialElemValue = this.getProp(initialScopeValue, true);\n      const isInitialScopeValueNull = isNil(initialScopeValue);\n      const isCheckbox = type === 'checkbox';\n      const changeScope = () => {\n        this.currentValue = this.getProp(this.currentValue);\n        this.changeScope();\n      };\n\n      if (isInitialScopeValueNull || isCheckbox) {\n        this.currentValue = initialElemValue;\n        this.changeScope();\n\n        if (!isInitialScopeValueNull && isCheckbox) {\n          this.setProp(initialScopeValue);\n        }\n      } else {\n        this.currentValue = initialScopeValue;\n        this.setProp(initialScopeValue);\n      }\n\n      this.offElemListener = elem.on(listenerSwitcher(name, [type]), (e) => {\n        if (e.target === node) {\n          changeScope();\n        }\n      });\n      this.offFormListener = elem.closest('form').on('reset', () => {\n        setTimeout(changeScope, 0);\n      });\n    }\n\n    changeScope() {\n      const {\n        scope,\n        value,\n        currentValue\n      } = this;\n\n      if (isFunction(value)) {\n        value(currentValue);\n      } else {\n        scope[value] = currentValue;\n      }\n    }\n\n    setProp(value) {\n      const {\n        elem,\n        name,\n        prop,\n        type,\n        node,\n        options\n      } = this;\n\n      if (prop === 'text') {\n        elem.text(value);\n      } else if (prop === 'multiple-select') {\n        options.forEach((option) => {\n          option.selected = value.indexOf(option.value) !== -1;\n        });\n      } else {\n        elem.prop(prop, setValueSwitcher(name, [value, type, node.value]));\n      }\n    }\n\n    getProp(values, init) {\n      const {\n        elem,\n        name,\n        prop,\n        type,\n        node,\n        options\n      } = this;\n\n      return prop === 'text'\n        ? elem.text()\n        : getValueSwitcher(name, [elem.prop(prop), type, node.value, values, elem, options, init, prop === 'multiple-select']);\n    }\n\n    beforeRemove() {\n      this.offElemListener();\n      this.offFormListener();\n    }\n  }\n\n  return {\n    name: 'd-value',\n    value: DValue\n  };\n}\n","const emptySpaceRegExp = /^\\s+/;\nconst anyEmptySpaceRegExp = /\\s+/g;\nconst anyEscapedExpressionRegExp = /\\\\[\\s\\S]/g;\nconst anyDoubleQuoteRegExp = /\"/g;\nconst anyNewLineRegExp = /\\r\\n|\\r|\\n/g;\nconst anyCommaEmptySpace = /\\s*,\\s*/;\nconst properEscapedRegExp = /\\\\|u|n|f|r|t|b|v|`[0-7]/;\n\nconst thisRegExp = /^this(?![a-zA-Z_$])/;\nconst simpleExpressionRegExp = /^(?:true|false|null|undefined)(?![a-zA-Z_$])/;\nconst variableRegExp = /^[a-zA-Z_$][a-zA-Z0-9_$]*/;\nconst numberRegExp = /^(?:NaN|-?(?:(?:\\d+|\\d*\\.\\d+)(?:[E|e][+|-]?\\d+)?|Infinity))/;\nconst stringRegExp = /^(?:\"(?:(?:\\\\[\\s\\S])|[^\"\\n\\\\])*\"|'(?:(?:\\\\[\\s\\S])|[^'\\n\\\\])*')/;\nconst regexpRegExp = /^\\/(?:(?:\\\\[\\s\\S])|[^/\\n\\\\])+\\/[gimuy]*/;\nconst arrowFunctionRegExp = /^(?:(?:\\(\\s*((?:[a-zA-Z_$][a-zA-Z0-9_$]*\\s*,\\s*)?(?:[a-zA-Z_$][a-zA-Z0-9_$]*)?)\\s*\\))|([a-zA-Z_$][a-zA-Z0-9_$]*))\\s*=>/;\nconst templateStringContentRegExp = /^(?:(?:\\\\[\\s\\S])|\\$(?!\\{)|[^`$\\\\])+/;\nconst operatorRegExp = /^(?:(?:>>>|>>|<<)=?|&&|\\|\\||,|(?:\\+|-|\\*|\\/|%|&|\\||\\^|<|>|==|!=)=?|=)/;\nconst pointOperatorRegExp = /^\\.([a-zA-Z_$][a-zA-Z0-9_$]*)/;\nconst propertyRegExp = /^((?:\"(?:(?:\\\\[\\s\\S])|[^\"\\n\\\\])*\"|'(?:(?:\\\\[\\s\\S])|[^'\\n\\\\])*'|[a-zA-Z_$][a-zA-Z0-9_$]*))\\s*:/;\nconst shorthandPropertyRegExp = /^([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*(?=,|})(,?)/;\nconst unaryOperatorRegExp = /^(?:-|~|\\+|!)/;\nconst keywordsArray = [\n  'do',\n  'if',\n  'in',\n  'for',\n  'let',\n  'new',\n  'try',\n  'var',\n  'case',\n  'else',\n  'enum',\n  'null',\n  'this',\n  'true',\n  'void',\n  'with',\n  'break',\n  'catch',\n  'class',\n  'const',\n  'false',\n  'super',\n  'throw',\n  'while',\n  'yield',\n  'delete',\n  'export',\n  'import',\n  'public',\n  'return',\n  'static',\n  'switch',\n  'typeof',\n  'default',\n  'extends',\n  'finally',\n  'package',\n  'private',\n  'continue',\n  'debugger',\n  'function',\n  'arguments',\n  'interface',\n  'protected',\n  'implements',\n  'instanceof'\n];\nconst keywordsRegExp = new RegExp(`^(?:${ keywordsArray.join('|') })$`);\n\nconst EXPRESSION = 'expression';\nconst END_OF_FUNC_BODY = 'end of function body';\nconst submitString = 'Please, submit an issue at https://github.com/dwaynejs/dwayne/issues/new, if needed.';\n\nfunction parseJS(string, wholeString, curlyError) {\n  curlyError = !!curlyError;\n\n  const initialString = string;\n  const expected = {\n    expression: true,\n    closingExpressions: [],\n    functionScope: {}\n  };\n  const variables = {};\n  const { closingExpressions } = expected;\n  let expression = '';\n  let index = 0;\n\n  while (string.length) {\n    let spaceMatch;\n    let match;\n    let toConcat = '';\n    let matched;\n    let isEmptySpace;\n    let {\n      type: properType,\n      symbol: properSymbol\n    } = closingExpressions[closingExpressions.length - 1] || {};\n    const firstSymbol = string[0];\n\n    if ((spaceMatch = string.match(emptySpaceRegExp)) && !expected.templateString) {\n      isEmptySpace = true;\n      match = spaceMatch[0];\n    } else {\n      if (expected.expression) {\n        match = string.match(arrowFunctionRegExp);\n\n        if (match) {\n          const vars = (match[2] || match[1]).split(anyCommaEmptySpace);\n          const variables = [];\n          const newFunctionVars = Object.create(expected.functionScope);\n\n          for (let i = 0, length = vars.length; i < length; i++) {\n            const variable = vars[i];\n\n            if (variable) {\n              variables.push(variable);\n              newFunctionVars[variable] = true;\n            }\n          }\n\n          toConcat = `function(${ variables.join(',') }){return `;\n          expected.functionScope = newFunctionVars;\n          closingExpressions.push({\n            type: 'any',\n            symbol: END_OF_FUNC_BODY\n          }, {\n            type: 'any',\n            symbol: EXPRESSION\n          });\n        } else if (firstSymbol === '(') {\n          match = '(';\n          closingExpressions.push({\n            type: 'paren',\n            symbol: ')'\n          });\n        } else if (firstSymbol === '[') {\n          match = '[';\n          closingExpressions.push({\n            type: 'array',\n            symbol: ']'\n          });\n        } else if (firstSymbol === '`') {\n          match = '`';\n          toConcat = '(\"\"';\n          expected.templateString = true;\n          closingExpressions.push({\n            type: 'templateString',\n            symbol: '`'\n          });\n\n          delete expected.expression;\n        } else if (firstSymbol === '{') {\n          match = '{';\n          expected.objectProperty = true;\n          closingExpressions.push({\n            type: 'object',\n            symbol: '}'\n          });\n\n          delete expected.expression;\n        } else {\n          match = string.match(unaryOperatorRegExp);\n\n          if (match) {\n            toConcat = match[0].replace(anyEmptySpaceRegExp, ' ');\n          } else {\n            match = string.match(simpleExpressionRegExp);\n\n            if (!match) {\n              match = string.match(numberRegExp);\n\n              if (!match) {\n                match = string.match(stringRegExp);\n\n                if (!match) {\n                  match = string.match(regexpRegExp);\n\n                  if (!match) {\n                    match = string.match(thisRegExp);\n\n                    if (match) {\n                      toConcat = '$';\n                    } else {\n                      match = string.match(variableRegExp);\n\n                      if (match) {\n                        const variable = match[0];\n\n                        if (!expected.functionScope[variable]) {\n                          variables[variable] = true;\n                        }\n\n                        toConcat = getVariable(variable, expected.functionScope);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (match) {\n              expected.operator = true;\n              matched = EXPRESSION;\n\n              delete expected.expression;\n            }\n          }\n        }\n      } else if (expected.templateString) {\n        match = string.match(templateStringContentRegExp);\n\n        if (match) {\n          const string = match[0]\n            .replace(anyEscapedExpressionRegExp, (match) => {\n              const second = match[1];\n\n              return properEscapedRegExp.test(second)\n                ? match\n                : second;\n            })\n            .replace(anyDoubleQuoteRegExp, '\\\\\"')\n            .replace(anyNewLineRegExp, (match) => {\n              if (match === '\\r\\n') {\n                match = '\\\\r\\\\n';\n              } else if (match === '\\r') {\n                match = '\\\\r';\n              } else {\n                match = '\\\\n';\n              }\n\n              return `\"+\"${ match }\"+\"`;\n            });\n\n          toConcat = `+\"${ string }\"`;\n        } else if (firstSymbol === '`') {\n          match = '`';\n          matched = EXPRESSION;\n          toConcat = ')';\n          expected.operator = true;\n          closingExpressions.pop();\n\n          delete expected.templateString;\n        } else if (string.slice(0, 2) === '${') {\n          match = '${';\n          toConcat = '+(';\n          expected.expression = true;\n          closingExpressions.push({\n            type: 'templateString',\n            symbol: '}'\n          }, {\n            type: 'any',\n            symbol: EXPRESSION\n          });\n\n          delete expected.templateString;\n        }\n      } else if (expected.objectProperty) {\n        match = string.match(propertyRegExp);\n\n        if (match) {\n          if (keywordsRegExp.test(match[1])) {\n            match[1] = `\"${ match[1] }\"`;\n          }\n\n          toConcat = `${ match[1] }:`;\n          expected.expression = true;\n          closingExpressions.push({\n            type: 'any',\n            symbol: EXPRESSION\n          });\n\n          delete expected.objectProperty;\n        } else {\n          match = string.match(shorthandPropertyRegExp);\n\n          if (match) {\n            const variable = match[1];\n\n            if (!expected.functionScope[variable]) {\n              variables[variable] = true;\n            }\n\n            if (keywordsRegExp.test(variable)) {\n              match[1] = `\"${ variable }\"`;\n            }\n\n            toConcat = `${ match[1] }:${ getVariable(variable, expected.functionScope) }${ match[2] }`;\n\n            if (!match[2]) {\n              expected.operator = true;\n\n              delete expected.objectProperty;\n            }\n          }\n        }\n      } else if (expected.operator) {\n        if (firstSymbol === ')' || firstSymbol === ']' || firstSymbol === '}' || firstSymbol === ',') {\n          toConcat = closeFunctionBody(expected);\n\n          ({\n            type: properType,\n            symbol: properSymbol\n          } = closingExpressions[closingExpressions.length - 1] || {});\n        }\n\n        if (firstSymbol === '(') {\n          match = '(';\n          expected.expression = true;\n          closingExpressions.push({\n            type: 'call',\n            symbol: ')'\n          });\n\n          delete expected.operator;\n        } else if (firstSymbol === '?') {\n          match = '?';\n          expected.expression = true;\n          closingExpressions.push({\n            type: 'ternary',\n            symbol: ':'\n          }, {\n            type: 'any',\n            symbol: EXPRESSION\n          });\n\n          delete expected.operator;\n        } else if (firstSymbol === ':' && properSymbol === ':') {\n          match = ':';\n          expected.expression = true;\n          closingExpressions.pop();\n\n          delete expected.operator;\n        } else if (firstSymbol === '[') {\n          match = '[';\n          expected.expression = true;\n          closingExpressions.push({\n            type: 'property',\n            symbol: ']'\n          }, {\n            type: 'any',\n            symbol: EXPRESSION\n          });\n\n          delete expected.operator;\n        } else if (firstSymbol === '}' && properSymbol === '}' && properType === 'templateString') {\n          match = firstSymbol;\n          toConcat += ')';\n          expected.templateString = true;\n          closingExpressions.pop();\n\n          delete expected.operator;\n        } else if (firstSymbol === ']' && properSymbol === ']' && properType === 'property') {\n          match = firstSymbol;\n          toConcat += firstSymbol;\n          matched = EXPRESSION;\n          closingExpressions.pop();\n        } else if (firstSymbol === ')' && properSymbol === ')' && properType === 'paren') {\n          match = firstSymbol;\n          toConcat += firstSymbol;\n          matched = EXPRESSION;\n          closingExpressions.pop();\n        } else if (firstSymbol === ',' && properSymbol === '}' && properType === 'object') {\n          match = firstSymbol;\n          toConcat += firstSymbol;\n          matched = EXPRESSION;\n          expected.objectProperty = true;\n\n          delete expected.operator;\n        } else {\n          match = string.match(pointOperatorRegExp);\n\n          if (match) {\n            matched = EXPRESSION;\n\n            if (keywordsRegExp.test(match[1])) {\n              toConcat += `[\"${ match[1] }\"]`;\n            }\n          } else {\n            match = string.match(operatorRegExp);\n\n            if (match) {\n              toConcat += match[0].replace(anyEmptySpaceRegExp, ' ');\n              expected.expression = true;\n              closingExpressions.push({\n                type: 'any',\n                symbol: EXPRESSION\n              });\n\n              delete expected.operator;\n            }\n          }\n        }\n      }\n\n      if (!match) {\n        if (firstSymbol === ')' || firstSymbol === ']' || firstSymbol === '}') {\n          toConcat += closeFunctionBody(expected);\n\n          ({\n            type: properType,\n            symbol: properSymbol\n          } = closingExpressions[closingExpressions.length - 1] || {});\n        }\n\n        let closingBrace;\n\n        if (properSymbol === ')' && firstSymbol === ')' && properType === 'call') {\n          closingBrace = true;\n\n          delete expected.expression;\n        } else if (properSymbol === ']' && firstSymbol === ']' && properType === 'array') {\n          closingBrace = true;\n\n          delete expected.expression;\n        } else if (firstSymbol === '}' && properSymbol === '}' && properType === 'object') {\n          closingBrace = true;\n\n          delete expected.objectProperty;\n        }\n\n        if (closingBrace) {\n          match = firstSymbol;\n          toConcat += firstSymbol;\n          expected.operator = true;\n          matched = EXPRESSION;\n          closingExpressions.pop();\n        }\n      }\n\n      if (\n        matched === EXPRESSION\n        && closingExpressions.length\n        && closingExpressions[closingExpressions.length - 1].symbol === EXPRESSION\n      ) {\n        closingExpressions.pop();\n      }\n    }\n\n    const noMatch = !match || !match[0];\n    const curlyIndex = string.indexOf('}');\n\n    if (noMatch && (curlyIndex > 0 || curlyError)) {\n      const expressionString = curlyError\n        ? initialString\n        : initialString.slice(0, initialString.length - string.length + curlyIndex);\n\n      throw new Error(\n        `Syntax error near ~~~ \"${ initialString.slice(index, index + 15) }\" ~~~ (index: ${ index }, ${ constructErrorInfo(expressionString, wholeString, closingExpressions, curlyError) }`\n      );\n    } else if (noMatch && curlyIndex === 0) {\n      expression += toConcat;\n\n      break;\n    } else if (noMatch && curlyIndex === -1) {\n      return null;\n    }\n\n    match = typeof match === 'string' ? match : match[0];\n\n    if (!isEmptySpace) {\n      expression += toConcat || match;\n    }\n\n    string = string.slice(match.length);\n    index += match.length;\n  }\n\n  expression += closeFunctionBody(expected);\n\n  if (closingExpressions.length) {\n    const expressionString = initialString.slice(0, initialString.length - string.length);\n\n    throw new Error(`Unexpected end of input (${ constructErrorInfo(expressionString, wholeString, closingExpressions, curlyError) }`);\n  }\n\n  if (!string.length && !curlyError) {\n    return null;\n  }\n\n  return {\n    expression,\n    variables,\n    original: initialString.slice(0, index),\n    rest: string.slice(1)\n  };\n}\n\nfunction getVariable(name, functionScope) {\n  if (functionScope[name]) {\n    return name;\n  }\n\n  return keywordsRegExp.test(name)\n    ? `$[\"${ name }\"]`\n    : `$.${ name }`;\n}\n\nfunction closeFunctionBody(expected) {\n  const { closingExpressions } = expected;\n  let toConcat = '';\n\n  while (\n    closingExpressions[closingExpressions.length - 1]\n    && closingExpressions[closingExpressions.length - 1].symbol === END_OF_FUNC_BODY\n  ) {\n    toConcat += '}';\n    expected.functionScope = Object.getPrototypeOf(expected.functionScope);\n    closingExpressions.pop();\n\n    if (\n      closingExpressions.length\n      && closingExpressions[closingExpressions.length - 1].symbol === EXPRESSION\n    ) {\n      closingExpressions.pop();\n    }\n  }\n\n  return toConcat;\n}\n\nfunction constructErrorInfo(expressionString, wholeString, closingExpressions, curlyError) {\n  let { symbol: last } = closingExpressions[closingExpressions.length - 1] || {};\n  let wholeStringString = '';\n\n  if (last && last !== EXPRESSION && last !== END_OF_FUNC_BODY) {\n    last = `\"${ last }\"`;\n  }\n\n  if (!curlyError) {\n    wholeStringString = `, whole string: \"${ wholeString }\"`;\n  }\n\n  const lastString = last\n    ? `expected ${ last }, `\n    : '';\n\n  return `${ lastString }initial expression: \"${ expressionString }\"${ wholeStringString }). ${ submitString }`;\n}\n\nexport default parseJS;\n","/**\n * @module Block\n * @private\n * @mixin\n * @description Exports Block class.\n */\n\nimport { Arr } from './Arr';\nimport { doc, Elem } from './Elem';\nimport { Str } from './Str';\nimport { Super } from './Super';\nimport {\n  defineUsualProperties, defineFrozenProperties,\n  assign, constructEvalFunction, iterate, validate,\n  isFunction, isNil, isString\n} from './helpers';\nimport * as Blocks from './blocks';\nimport * as Mixins from './mixins';\nimport { htmlAllowedTagSymbols, htmlAllowedAttrSymbols } from './constants';\nimport markupToJSON from './helpers/markupToJSON';\nimport parseJS from './helpers/parseJS';\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {String} expression - Expression which has been evaluated with the error.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback VarsWatcher\n * @public\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {Block} Block class to wrap.\n * @returns {Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {*} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {Block} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\nconst rootBlocks = Object.create(null);\nconst rootMixins = Object.create(null);\nconst {\n  isPrototypeOf,\n  hasOwnProperty\n} = {};\nconst tagName = new RegExp(`^${ htmlAllowedTagSymbols }$`, 'i');\nconst attrName = new RegExp(`^${ htmlAllowedAttrSymbols }$`);\nconst svgNS = 'http://www.w3.org/2000/svg';\nconst curlyBracketRegExp = /\\{/;\nconst dRestRegExp = /^d-rest(?:#|$)/;\nconst afterElem = new Elem();\nlet evalMode;\nlet getting;\nlet changed;\n\n/**\n * @class Block\n * @public\n * @param {Object} opts - Element options.\n * @returns {Block} Instance of Block.\n * @description Class for dynamic templating.\n *\n * @example\n * import { D, Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/>';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world (0)';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     D(1000).interval(() => {\n *       this.text = `world (${ ++this.times })`;\n *     });\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', 'Hello, {args.text}!');\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  static _blocks = Object.create(rootBlocks);\n  static _mixins = Object.create(rootMixins);\n\n  /**\n   * @member {Boolean} [Block.collapseWhiteSpace = true]\n   * @type {Boolean}\n   * @public\n   * @description If the whitespace between html elements and\n   * in the start and the end inside the tag should be omitted during parsing.\n   */\n  static collapseWhiteSpace = true;\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {String} [Block.template = '']\n   * @type {String}\n   * @public\n   * @description Block template.\n   */\n  static template = '';\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.expression }\" in context of block \"${ err.block.$$.name }\"):`, err);\n  }\n\n  static getBlocks() {\n    return new Super({ ...this._blocks });\n  }\n\n  static getMixins() {\n    return new Super({ ...this._mixins });\n  }\n\n  /**\n   * @method Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   */\n  static beforeRegisterBlock(hook) {\n    if (!new Super(this).hasOwn('_blockHooks')) {\n      this._blockHooks = new Arr([]);\n    }\n\n    this._blockHooks.push(hook);\n  }\n\n  /**\n   * @method Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   */\n  static beforeRegisterMixin(hook) {\n    if (!new Super(this).hasOwn('_mixinHooks')) {\n      this._mixinHooks = new Arr([]);\n    }\n\n    this._mixinHooks.push(hook);\n  }\n\n  /**\n   * @method Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {String|Block} Subclass - Subclass of Block or template string of it.\n   * @returns {void}\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    const _this = new Super(this);\n\n    if (isString(Subclass)) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        constructor(opts) {\n          super(opts);\n\n          constructor.call(this, opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass)) {\n      console.warn(`Block must be a string (representing a block template), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      extendBlock(Subclass);\n    }\n\n    if (rootBlocks[name]) {\n      console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!tagName.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!_this.hasOwn('_blocks')) {\n      this._blocks = Object.create(_this.proto().$._blocks);\n    }\n\n    let returnValue;\n\n    try {\n      returnValue = (this._blockHooks || new Arr([])).reduce((Subclass, hook) => {\n        const returnValue = hook(Subclass, name);\n\n        return isInstanceOf(Block, returnValue)\n          ? returnValue\n          : Subclass;\n      }, Subclass);\n    } catch (err) {\n      console.error(`Uncaught error in ${ this._name } \"beforeRegisterBlock\" hook:`, err);\n    }\n\n    if (isInstanceOf(Block, returnValue)) {\n      Subclass = returnValue;\n    }\n\n    const variables = {};\n\n    Subclass._name = name;\n    Subclass._html = transformDIfChildren(\n      transformJSExpressions(\n        markupToJSON(\n          `${ Subclass.template || '' }`,\n          Subclass.collapseWhiteSpace\n        ),\n        variables\n      )\n    );\n    Subclass._variables = new Super(variables)\n      .except('$$', '$')\n      .keys();\n\n    if (new Super(Subclass).hasOwn('defaultArgs')) {\n      new Super(Subclass.defaultArgs).proto(null);\n    }\n\n    this._blocks[name] = Subclass;\n  }\n\n  /**\n   * @method Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {void}\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    const _this = new Super(this);\n\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          afterUpdate.call(this, newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin and will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (rootMixins[name]) {\n      console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!attrName.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!_this.hasOwn('_mixins')) {\n      this._mixins = Object.create(_this.proto().$._mixins);\n    }\n\n    let returnValue;\n\n    try {\n      returnValue = (this._mixinHooks || new Arr([])).reduce((Subclass, hook) => {\n        const returnValue = hook(Subclass, name);\n\n        return isInstanceOf(Mixin, returnValue)\n          ? returnValue\n          : Subclass;\n      }, Subclass);\n    } catch (err) {\n      console.error(`Uncaught error in ${ this._name } \"beforeRegisterMixin\" hook:`, err);\n    }\n\n    if (isInstanceOf(Mixin, returnValue)) {\n      Subclass = returnValue;\n    }\n\n    Subclass._name = name;\n    Subclass._match = constructMixinRegExp(name);\n\n    this._mixins[name] = Subclass;\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return new Arr(arguments).reduce((block, wrapper) => {\n      const returnValue = wrapper(block);\n\n      return isInstanceOf(Block, returnValue)\n        ? returnValue\n        : block;\n    }, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = new Arr([]);\n    const constructor = new Super(this).proto().$.constructor;\n    const childrenBlocks = new Arr([]);\n    const mixins = new Arr([]);\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Block} Block#$\n       * @type {Block}\n       * @public\n       * @description This.\n       */\n      $: this,\n\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} args - Private args scope.\n       * @property {Arr} argsChildren - Block args children.\n       * @property {Arr} children - Child blocks.\n       * @property {Arr} mixins - Child mixins.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Elem} content - Content elements.\n       * @property {Function} evaluate - Evaluate function.\n       * @property {Object} globals - Private globals scope.\n       * @property {Object} locals - Private locals scope.\n       * @property {Arr} watchersToRemove - Watchers to remove before removing element.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlocks: new Arr([]),\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        argsChildren: children || new Arr([]),\n        children: childrenBlocks,\n        mixins,\n        prevBlock,\n        watchersToRemove,\n        evaluate: (func, onChange, instance, forDElements, forDItem, forDEach) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = (name === '#d-item' && !forDItem) || forDEach\n            ? (forDEach || this).$$.scope\n            : this;\n          const { watchersToRemove } = instance ? instance.$$ : {};\n\n          /* eslint no-new-func: 0 */\n          const evaluate = () => {\n            let result;\n\n            if (onChange) {\n              evalMode = true;\n              getting = new Arr([]);\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.expression = func.expression;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                constructor.onEvalError(err);\n              }\n            }\n\n            if (onChange) {\n              const localWatchers = new Arr([]);\n\n              getting.forEach((watchers) => {\n                const watcher = () => {\n                  const newResult = evaluate();\n\n                  if (newResult !== result) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                watcher.onRemove = () => {\n                  localWatchers.forEach((watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n                    const index1 = watchersToRemove.indexOf(watcherBlock);\n                    const index2 = watchers.indexOf(watcher);\n\n                    if (index1 !== -1) {\n                      watchersToRemove.splice(index1, 1);\n                    }\n\n                    if (index2 !== -1) {\n                      watchers.splice(index2, 1);\n                    }\n                  });\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              getting = new Arr([]);\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          removeWatchers(watchersToRemove);\n\n          childrenBlocks.forEach((child) => {\n            child.$$.remove(true);\n          });\n\n          mixins.forEach((mixin) => {\n            mixin.$$.remove(true);\n          });\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            const index = parentBlock.$$.children.indexOf(this);\n\n            if (index !== -1) {\n              parentBlock.$$.children.splice(index, 1);\n            }\n          }\n\n          this.$$.content.remove();\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const index = this.$$.content.indexOf(contentToAdd.$[0].previousSibling) + 1;\n\n          if (index === 0) {\n            this.$$.content = contentToAdd\n              .slice()\n              .pushArray(this.$$.content.$);\n          } else {\n            this.$$.content = this.$$.content\n              .slice(0, index)\n              .pushArray(contentToAdd.$)\n              .pushArray(this.$$.content.slice(index).$);\n          }\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const index = this.$$.content.indexOf(contentToMove.$[0]);\n          const indexToPut = this.$$.content.indexOf(after.$[0]) + 1;\n\n          if (indexToPut === 0) {\n            this.$$.content = contentToMove\n              .slice()\n              .pushArray(this.$$.content.slice(indexToPut, index).$)\n              .pushArray(this.$$.content.slice(index + contentToMove.length).$);\n          } else if (index > indexToPut) {\n            this.$$.content = this.$$.content\n              .slice(0, indexToPut)\n              .pushArray(contentToMove.$)\n              .pushArray(this.$$.content.slice(indexToPut, index).$)\n              .pushArray(this.$$.content.slice(index + contentToMove.length).$);\n          } else {\n            this.$$.content = this.$$.content\n              .slice(0, index)\n              .pushArray(this.$$.content.slice(index + contentToMove.length, indexToPut).$)\n              .pushArray(contentToMove.$)\n              .pushArray(this.$$.content.slice(indexToPut).$);\n          }\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.content = this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          ));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, false);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.last();\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterate(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    constructor._variables.forEach((variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = Object.create(null);\n    const $argsObject = new Super(argsObject);\n    let args = Object.create(constructor.defaultArgs || null);\n    let wasDRest;\n\n    new Super(originalArgs).forEach((value, arg) => {\n      const isDRest = dRestRegExp.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? Object.create(args)\n        : args;\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterate(localArgs, (value, arg) => {\n            delete localArgs[arg];\n          });\n          defineUsualProperties(localArgs, transformRestArgs(value));\n          calculateArgs(args, argsObject, $argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return defineUsualProperties(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      if (name !== 'd-each' || arg !== 'uid') {\n        value = parentScope.$$.evaluate(value, (value) => {\n          localArgs[arg] = value;\n          calculateArgs(args, argsObject, $argsObject);\n        }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n      }\n\n      defineUsualProperties(localArgs, {\n        [arg]: value\n      });\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: Object.create(\n        parentScope\n          ? Object.create(parentScope.globals)\n          : null\n      ),\n\n      /**\n       * @member {Block|undefined} Block#parentScope\n       * @type {Block|undefined}\n       * @public\n       */\n      parentScope,\n\n      /**\n       * @member {Block|undefined} Block#parentTemplate\n       * @type {Block|undefined}\n       * @public\n       */\n      parentTemplate\n    });\n\n    calculateArgs(args, argsObject, $argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#changeLocals\n   * @public\n   * @param {Object} locals - Object to assign to this.\n   * @description Method for simple assigning some locals to this.\n   */\n  changeLocals(locals) {\n    assign(this, locals);\n  }\n\n  /**\n   * @method Block#evaluateAndWatch\n   * @public\n   * @param {String} expression - Expression to evaluate.\n   * @param {Watcher} callback - Callback which is called when the expression value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluateAndWatch(expression, callback) {\n    validate([expression], ['string'], 'Block#evaluateAndWatch');\n\n    const {\n      expression: code,\n      original\n    } = parseJS(expression, expression, true);\n\n    const func = constructEvalFunction(code, original);\n\n    return this.$$.parentScope.$$.evaluate(func, callback, this);\n  }\n\n  /**\n   * @method Block#evaluateOnce\n   * @public\n   * @param {String} expression - Expression to evaluate.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block once.\n   */\n  evaluateOnce(expression) {\n    validate([expression], ['string'], 'Block#evaluateOnce');\n\n    const {\n      expression: code,\n      original\n    } = parseJS(expression, expression, true);\n\n    const func = constructEvalFunction(code, original);\n\n    return this.$$.parentScope.$$.evaluate(func);\n  }\n\n  /**\n   * @method Block#setGlobals\n   * @public\n   * @param {Object} globals - Object which keys are global vars and values are their values.\n   * @description Method for setting global variables (use only in constructor!).\n   */\n  setGlobals(globals) {\n    defineUsualProperties(this.globals, globals);\n  }\n\n  /**\n   * @method Block#watch\n   * @public\n   * @param {...('args'|'globals'|String)} [vars] - Vars to watch (args, globals or locals).\n   * If no specified all locals, args and globals are to be watched.\n   * If the 'args' string all args are to be watched.\n   * If the 'globals' string all globals are to be watched.\n   * @param {VarsWatcher} watcher - Called when watched vars are changed.\n   * @description Method for watching for vars. If no vars passed in arguments\n   * all vars are to be watched. If the 'args' string is in the arguments all args are to be watched.\n   * If the 'globals' string is in the arguments all globals are to be watched.\n   * Otherwise specified vars will be watched.\n   * Watchers should not be put inside the constructor. It is considered best\n   * practice to do it inside the {@link Block#afterConstruct} method.\n   * Note that these expressions (vars, i.e. \"args.arg\") are not to be\n   * evaluated so you cannot put there things like \"a[b]\" or any js code,\n   * only expressions like \"a\", \"b\", \"args.a\", \"args.b\" and \"globals.a\", \"globals.b\".\n   * Also note that if there are more than one var that are changed at once (synchronously)\n   * the watcher is called only once.\n   * Note that the watcher is executed right away because in most cases\n   * this behaviour is very convenient.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div />';\n   *\n   *   afterConstruct() {\n   *     this.watch('a', () => {});\n   *     this.watch('args.a', 'globals.r', () => {});\n   *     this.watch(() => {});\n   *   }\n   * }\n   */\n  watch(...vars) {\n    const oldWatcher = arguments[arguments.length - 1];\n\n    if (!isFunction(oldWatcher)) {\n      console.warn(`The last argument (watcher) wasn't specified (${ this.$$.name }#watch)`);\n\n      return;\n    }\n\n    const watcher = () => {\n      oldWatcher();\n    };\n\n    if (arguments.length === 1) {\n      watchForAllLocals(this, watcher);\n      watchForAllArgs(this, watcher);\n      watchForAllGlobals(this, watcher);\n\n      oldWatcher();\n\n      return;\n    }\n\n    iterate(arguments, (variable) => {\n      if (variable === oldWatcher) {\n        return;\n      }\n\n      variable = `${ variable }`;\n\n      if (variable === '$') {\n        return watchForAllLocals(this, watcher);\n      }\n\n      if (variable === 'args') {\n        return watchForAllArgs(this, watcher);\n      }\n\n      if (variable === 'globals') {\n        return watchForAllGlobals(this, watcher);\n      }\n\n      if (/^args\\./.test(variable)) {\n        variable = variable.replace(/^args\\./, '');\n\n        if (!this.$$.args[variable]) {\n          return;\n        }\n\n        this.$$.args[variable].watchers.perm.push(watcher);\n\n        return;\n      }\n\n      if (/^globals\\./.test(variable)) {\n        variable = variable.replace(/^globals\\./, '');\n\n        if (!this.$$.globals[variable]) {\n          return;\n        }\n\n        const { watchers } = this.$$.globals[variable];\n\n        watchers.perm.push(watcher);\n        this.$$.watchersToRemove.push({\n          watcher,\n          watchers\n        });\n\n        return;\n      }\n\n      if (!this.$$.locals[variable]) {\n        return;\n      }\n\n      this.$$.locals[variable].watchers.perm.push(watcher);\n    });\n\n    oldWatcher();\n  }\n}\n\nnew Super(Block.prototype).proto(null);\n\nregisterBuiltIns(Blocks, rootBlocks, Block);\n\nconst blocks = Block._blocks;\n\nclass Mixin {\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return new Arr(arguments).reduce((block, wrapper) => {\n      const returnValue = wrapper(block);\n\n      return isInstanceOf(Mixin, returnValue)\n        ? returnValue\n        : block;\n    }, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = new Arr([]);\n    const watchers = new Arr([]);\n\n    defineFrozenProperties(this, {\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            const index = parentBlock.$$.mixins.indexOf(this);\n\n            if (index !== -1) {\n              parentBlock.$$.mixins.splice(index, 1);\n            }\n          }\n        }\n      }\n    });\n\n    this.args = args;\n    this.comment = comment;\n    this.parentScope = parentScope;\n    this.parentTemplate = parentTemplate;\n    this.elem = elem;\n    this.node = elem.$[0];\n\n    if (parentBlock) {\n      parentBlock.$$.mixins.push(this);\n    }\n  }\n\n  afterUpdate() {}\n\n  beforeRemove() {}\n\n  /**\n   * @method Block#evaluateAndWatch\n   * @public\n   * @param {Watcher} callback - Callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluateAndWatch(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  /**\n   * @method Block#evaluateOnce\n   * @public\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value once.\n   */\n  evaluateOnce() {\n    return this.$$.evaluate();\n  }\n}\n\nregisterBuiltIns(Mixins, rootMixins, Mixin);\n\nconst mixins = Block._mixins;\n\nfunction initApp(block, node) {\n  if (!blocks[block]) {\n    throw new Error(`No \"${ block }\" block is registered! (initApp)`);\n  }\n\n  const parentElem = new Elem(node);\n\n  parentElem.html('');\n\n  if (!parentElem.length) {\n    throw new Error('No valid element to insert the app into was given! (initApp)');\n  }\n\n  parentElem.$[0].DwayneRootBlock = createBlock({\n    node: {\n      name: block,\n      attrs: {},\n      children: new Arr([])\n    },\n    parent: parentElem,\n    parentElem\n  });\n  parentElem.attr('dwayne-root', block);\n}\n\nfunction removeApp(node) {\n  const elem = new Elem(node);\n\n  elem.html('');\n\n  if (!elem.length) {\n    throw new Error('No valid element to remove the app from was given! (removeApp)');\n  }\n\n  node = elem.$[0];\n\n  if (!node.DwayneRootBlock) {\n    throw new Error('No app registered inside the given element! (removeApp)');\n  }\n\n  delete node.DwayneRootBlock.$$.remove();\n}\n\nfunction registerBuiltIns(set, scope, proto) {\n  iterate(set, (register) => {\n    const {\n      name,\n      value\n    } = register(proto, createBlock, Block);\n\n    if (proto === Block) {\n      const variables = {};\n\n      value._html = transformJSExpressions(\n        markupToJSON(\n          `${ value.template || '' }`,\n          value.collapseWhiteSpace\n        ),\n        variables\n      );\n      value._variables = new Super(variables)\n        .except('$$', '$')\n        .keys();\n    } else {\n      value._match = constructMixinRegExp(name);\n    }\n\n    scope[name] = value;\n  });\n}\n\nfunction createBlock({ node, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const elem = parentElem.prop('namespaceURI') === svgNS\n    ? doc.svg()\n    : new Elem(doc.template().$[0].content);\n  const localBlocks = parentScope ? parentScope.$$.ns._blocks : blocks;\n  const localMixins = parentScope ? parentScope.$$.ns._mixins : mixins;\n  let children = node.children || new Arr([]);\n  let args = node.attrs || {};\n  let name = node.name || 'UnknownBlock';\n  let constructor = node.name && localBlocks[node.name];\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n  let dBlockChildren;\n  let dElementsName;\n\n  if (name === 'd-block' && args.name) {\n    name = 'd-elements';\n    constructor = localBlocks[name];\n    dElementsName = args.name;\n    dBlockArgs = new Super(args).except('name').$;\n    dBlockChildren = children;\n    children = new Arr([]);\n    args = {};\n  } else if (name === 'd-block' && hasOwnProperty.call(args, 'constructor')) {\n    name = 'UnknownBlock';\n    constructor = parentScope.$$.evaluate(args.constructor);\n\n    if (isFunction(constructor)) {\n      args = new Super(args).except('constructor').$;\n    } else {\n      constructor = null;\n    }\n  } else if ((dBlockMatch = name.match(/^d-block:([\\s\\S]+)$/)) || name === 'd-block') {\n    constructor = blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const {\n      value,\n      children\n    } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = Object.create(null);\n    let attrs = Object.create(null);\n    let wasDRest;\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    new Super(args).forEach((value, attr) => {\n      const isDRest = dRestRegExp.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? Object.create(attrs)\n        : attrs;\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          setTimeout(() => {\n            iterate(localAttrs, (value, arg) => {\n              delete localAttrs[arg];\n            });\n            assign(localAttrs, transformRestAttrs(\n              value, localMixins, mixinDefaultOpts\n            ));\n            calculateAttrs(attrs, currentAttrs, element, false);\n          }, 0);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        if (value === true) {\n          value = 'true';\n        }\n\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    const createMixins = calculateAttrs(attrs, currentAttrs, element, true);\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      if (isFunction(value)) {\n        let text = parentScope.$$.evaluate(value, (value) => {\n          if (isNil(value)) {\n            value = '';\n          }\n\n          element.text(`${ value }`);\n        }, parentBlock);\n\n        if (isNil(text)) {\n          text = '';\n        }\n\n        element.text(`${ text }`);\n      } else {\n        element.text(value);\n      }\n    }\n\n    if (children) {\n      const parentElem = name === 'template'\n        ? new Elem(element.$[0].content)\n        : element;\n      let prevBlock;\n\n      children.forEach((child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }\n\n    const isParentBlock = parent instanceof Block;\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    createMixins();\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  if (dBlockMatch || name === 'd-block') {\n    parentScope.$$.dBlocks.push(blockInstance);\n  }\n\n  if (dBlockArgs) {\n    node = {\n      attrs: dBlockArgs,\n      children: dBlockChildren\n    };\n    node.name = parentScope.$$.evaluate(dElementsName, (newName) => {\n      node.name = newName;\n\n      const html = new Arr([node]);\n\n      Args.value = newName === 'd-if'\n        ? transformDIfChildren(html)\n        : html;\n    }, blockInstance, true);\n\n    const html = new Arr([node]);\n\n    Args.value = node.name === 'd-if'\n      ? transformDIfChildren(html)\n      : html;\n    Args.parentScope = parentScope;\n  }\n\n  const html = name === 'd-elements'\n    ? new Arr(Args.value || [])\n    : constructor._html;\n\n  delete locals.$;\n  delete locals.parentScope;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = Object.create(scope), scopeValues, $$.privateScope);\n  }\n\n  if (name === 'd-each') {\n    $$.scope = Object.create(parentScope.$$.name === '#d-item' ? parentScope.$$.scope : parentScope, {\n      [Args.item || '$item']: {\n        value: null,\n        writable: true\n      },\n      [Args.index || '$index']: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  html.forEach((child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n\nfunction createMixin({ name, Mixin, dynamic, value, args, comment, elem, parentBlock, parentScope, parentTemplate }) {\n  const mixin = new Mixin({\n    name,\n    value,\n    dynamic,\n    args,\n    comment,\n    elem,\n    parentBlock,\n    parentScope,\n    parentTemplate\n  });\n\n  if (Mixin.evaluate) {\n    const value = mixin.value = mixin.evaluateAndWatch((newValue, oldValue) => {\n      mixin.value = newValue;\n\n      try {\n        mixin.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    });\n\n    mixin.afterUpdate(value);\n  }\n\n  return mixin;\n}\n\nfunction transformDIfChildren(children) {\n  return new Arr(children || [])\n    .concat({})\n    .object((object, child) => {\n      const { name } = child;\n      const {\n        html,\n        ifElse\n      } = object;\n\n      if (name !== 'd-else-if' && name !== 'd-else') {\n        if (ifElse) {\n          html.push({\n            name: 'd-if',\n            children: ifElse\n          });\n\n          object.ifElse = null;\n        }\n\n        if (name === 'd-if') {\n          object.ifElse = new Arr([child]);\n        } else if (name) {\n          html.push(child);\n        }\n      } else {\n        (ifElse || html).push(child);\n\n        if (name === 'd-else' && ifElse) {\n          html.push({\n            name: 'd-if',\n            children: ifElse\n          });\n\n          object.ifElse = null;\n        }\n      }\n\n      if (name) {\n        child.children = transformDIfChildren(child.children);\n      }\n    }, {\n      html: new Arr([]),\n      ifElse: null\n    }).$.html;\n}\n\nfunction transformJSExpressions(children, variables, exclude = {}) {\n  return new Arr(children || []).object((children, child) => {\n    const {\n      name,\n      attrs,\n      children: ownChildren,\n      value: initialValue\n    } = child;\n    const isDEach = name === 'd-each';\n    let { value } = child;\n    let excludeLocal = {};\n\n    if (isDEach) {\n      excludeLocal = {\n        [child.attrs.item || '$item']: true,\n        [child.attrs.index || '$index']: true\n      };\n    }\n\n    child.attrs = new Super(attrs).map((value, attr) => {\n      if (value === true) {\n        return true;\n      }\n\n      if (value[0] !== '{' || value[value.length - 1] !== '}') {\n        return value;\n      }\n\n      const parsed = parseJS(value.slice(1, -1), value, true);\n\n      if (!parsed) {\n        return value;\n      }\n\n      if (parsed.rest) {\n        throw new Error('Attribute, mixin and argument computed values must be of the format \"{<js_expression>}\"');\n      }\n\n      const isUID = attr === 'uid';\n\n      const usedVariables = new Super(parsed.variables).filter((value, variable) => {\n        if (isDEach && isUID && excludeLocal[variable]) {\n          return;\n        }\n\n        if (!exclude[variable]) {\n          return true;\n        }\n      }).$;\n\n      assign(variables, usedVariables);\n\n      return constructEvalFunction(parsed.expression, parsed.original);\n    }).$;\n\n    if (name !== '#text') {\n      exclude = {\n        ...exclude,\n        ...excludeLocal\n      };\n\n      if (ownChildren) {\n        child.children = transformJSExpressions(ownChildren, variables, exclude);\n      }\n\n      children.push(child);\n\n      return;\n    }\n\n    while (value.length) {\n      const match = value.match(curlyBracketRegExp);\n\n      if (!match) {\n        children.push({\n          name: '#text',\n          value\n        });\n\n        break;\n      }\n\n      const { index } = match;\n\n      if (index) {\n        children.push({\n          name: '#text',\n          value: value.slice(0, index)\n        });\n        value = value.slice(index);\n      }\n\n      const parsed = parseJS(value.slice(1), initialValue);\n\n      if (!parsed) {\n        children.push({\n          name: '#text',\n          value\n        });\n\n        break;\n      }\n\n      const usedVariables = new Super(parsed.variables).filter((value, variable) => {\n        if (!exclude[variable]) {\n          return true;\n        }\n      }).$;\n\n      assign(variables, usedVariables);\n\n      children.push({\n        name: '#text',\n        value: constructEvalFunction(parsed.expression, parsed.original)\n      });\n      value = parsed.rest;\n    }\n  }, new Arr([]));\n}\n\nfunction isInstanceOf(Class, Subclass) {\n  return isPrototypeOf.call(Class, Subclass) && isPrototypeOf.call(Class.prototype, Subclass.prototype);\n}\n\nfunction removeWatchers(watchersToRemove) {\n  watchersToRemove.forEach(({ watcher, watchers }) => {\n    const index = watchers.indexOf(watcher);\n\n    if (index !== -1) {\n      watchers.splice(index, 1);\n    }\n  });\n}\n\nfunction constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = Object.create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return new Super(object).object((scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: {\n        temp: new Arr([]),\n        perm: new Arr([])\n      }\n    };\n  }, scope).$;\n}\n\nfunction constructPublicScope(scope, scopeValues, privateScope) {\n  new Super(scope).define(new Super(scopeValues).map((value, key) => {\n    const scope = privateScope[key];\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (getting.indexOf(scope.watchers.temp) === -1) {\n            getting.push(scope.watchers.temp);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        if (!changed) {\n          changed = [];\n        }\n\n        const oldTempWatchers = scope.watchers.temp.slice();\n        const oldValue = scope.value;\n\n        scope.watchers.temp = new Arr([]);\n        scope.value = value;\n\n        oldTempWatchers.forEach((watcher) => {\n          watcher.onRemove();\n          watcher();\n        });\n        changed.push({\n          scope,\n          oldValue,\n          value\n        });\n\n        setTimeout(() => {\n          if (!changed) {\n            return;\n          }\n\n          const was = new Arr([]);\n          const values = [];\n\n          for (let i = changed.length - 1; i >= 0; i--) {\n            const {\n              scope,\n              value,\n              oldValue\n            } = changed[i];\n\n            scope.watchers.perm.forEach((watcher) => {\n              const index = was.indexOf(watcher);\n\n              if (index === -1) {\n                was.push(watcher);\n                values.push({\n                  value,\n                  oldValue\n                });\n              } else {\n                values[index].oldValue = oldValue;\n              }\n            });\n\n            changed.splice(i, 1);\n          }\n\n          changed = null;\n\n          was.forEach((watcher, i) => {\n            const {\n              value,\n              oldValue\n            } = values[i];\n\n            watcher(value, oldValue);\n          });\n        }, 0);\n      }\n    };\n  }).$);\n}\n\nfunction watchForAllLocals(block, watcher) {\n  iterate(block.$$.locals, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n\nfunction watchForAllGlobals(block, watcher) {\n  const {\n    globals,\n    watchersToRemove\n  } = block.$$;\n\n  for (const global in globals) {\n    /* eslint guard-for-in: 0 */\n    const watchers = globals[global].watchers.perm;\n\n    watchers.push(watcher);\n    watchersToRemove.push({\n      watcher,\n      watchers\n    });\n  }\n}\n\nfunction watchForAllArgs(block, watcher) {\n  iterate(block.$$.args, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n\nfunction calculateArgs(args, argsObject, $argsObject) {\n  $argsObject.propertyNames().forEach((arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  for (const arg in args) {\n    argsObject[arg] = args[arg];\n  }\n}\n\nfunction transformRestArgs(args) {\n  return new Super(args).object((args, value, arg) => {\n    if (dRestRegExp.test(arg)) {\n      assign(args, transformRestArgs(value));\n    } else {\n      args[arg] = value;\n    }\n  }).$;\n}\n\nfunction transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return new Super(attrs).object((eventualAttrs, value, attr) => {\n    if (dRestRegExp.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  }).$;\n}\n\nfunction mixinMatch(mixins, attr) {\n  let match;\n\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (/^\\s*$/.test(argsMatch)) {\n        args = [];\n      } else if (argsMatch) {\n        args = new Str(argsMatch)\n          .split(/,\\s*/)\n          .map((s) => new Str(s).trim().$)\n          .$;\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n\n  return match;\n}\n\nfunction calculateAttrs(attrs, attrsObject, elem, firstTime) {\n  iterate(attrsObject, ({ type, value }, attr) => {\n    if (!attrs[attr]) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = new Arr([]);\n\n  for (const attr in attrs) {\n    const {\n      type,\n      dynamic,\n      value,\n      opts\n    } = attrs[attr];\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        const mixin = prevValue;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n        }\n\n        mixin.$$.isDynamic = dynamic;\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(value, (newValue) => {\n            const {\n              type,\n              dynamic\n            } = attrs[attr];\n\n            if (type === 'mixin' && !dynamic) {\n              executeMixinWatchers(mixin, newValue);\n            }\n          }, mixin);\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        }\n\n        nextValue = mixin;\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = createMixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(value, (newValue) => {\n              const {\n                type,\n                dynamic\n              } = attrs[attr];\n\n              if (type === 'mixin' && !dynamic) {\n                executeMixinWatchers(mixin, newValue);\n              }\n            }, mixin);\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  }\n\n  if (firstTime) {\n    return () => {\n      mixins.forEach((buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n\nfunction executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  mixin.$$.watchers.forEach((watcher) => {\n    watcher(value, oldValue);\n  });\n}\n\nfunction constructMixinRegExp(name) {\n  return new RegExp(`^${ new Str(name).escapeRegExp().$ }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n\nfunction extendBlock(cls) {\n  new Super(cls).proto(Block);\n  new Super(cls.prototype).proto(Block.prototype);\n}\n\nfunction insertTemplates(template, templates) {\n  const { vars, value } = template;\n  const newTemplates = Object.create(null);\n  const newVars = new Super(vars).object((vars, variable) => {\n    vars[variable] = true;\n  });\n\n  assign(newTemplates, templates);\n  iterate(value, forEachNode);\n\n  function forEachNode({ type, value, children }, index, tree) {\n    if (type === '#comment') {\n      value = new Str(value).trim().$;\n\n      if (newTemplates[value]) {\n        tree[index] = newTemplates[value].value;\n        newVars.assign(new Super(newTemplates[value].vars).object((vars, variable) => {\n          vars[variable] = true;\n        }).$);\n      }\n    } else {\n      iterate(children, forEachNode);\n    }\n  }\n\n  vars.length = 0;\n  new Arr(vars).pushArray(newVars.keys().$);\n\n  return template;\n}\n\nexport { Block, Mixin, initApp, removeApp, insertTemplates };\n","/**\n * @module constants/formats\n * @private\n * @description Exports different types of formatting for {@link Date#format}.\n */\n\nimport { Super } from '../Super';\nimport { Str } from '../Str';\n\nconst zero = new Str('0');\nconst daysOfTheWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday'\n];\nconst daysOfTheWeekAliases = new Super(daysOfTheWeekNames).map((value) => value.slice(0, 3)).$;\nconst monthsNames = [\n  'January',\n  'February',\n  'March',\n  'April',\n  'May',\n  'June',\n  'Jule',\n  'August',\n  'September',\n  'October',\n  'November',\n  'December'\n];\nconst monthsAliases = new Super(monthsNames).map((value) => value.slice(0, 3)).$;\n\n/**\n * @callback module:constants/formats~matchCallback\n * @param {Dat} date - D-wrap of a date to apply format to.\n * @param {String} string - Matched applied expression.\n */\n\n/**\n * @typedef {Object} module:constants/formats~formatExpr\n * @property {String} format - Matched format.\n * @property {module:constants/formats~matchCallback} match - Callback if there was a match.\n */\n\n/**\n * @type {module:constants/formats~formatExpr[]}\n * @description Array of different formats.\n */\nexport default [\n  {\n    format: 'ccc',\n    match: (date, utc) => round(date[utc]('c'), 3)\n  },\n  {\n    format: 'c',\n    match: (date, utc) => date[utc]('c')\n  },\n  {\n    format: 'ss',\n    match: (date, utc) => round(date[utc]('s'), 2)\n  },\n  {\n    format: 's',\n    match: (date, utc) => date[utc]('s')\n  },\n  {\n    format: 'mm',\n    match: (date, utc) => round(date[utc]('m'), 2)\n  },\n  {\n    format: 'm',\n    match: (date, utc) => date[utc]('m')\n  },\n  {\n    format: 'hh',\n    match: (date, utc) => round(date[utc]('h'), 2)\n  },\n  {\n    format: 'h',\n    match: (date, utc) => date[utc]('h')\n  },\n  {\n    format: 'dddd',\n    match: (date, utc) => daysOfTheWeekNames[date[utc]('dw')]\n  },\n  {\n    format: 'ddd',\n    match: (date, utc) => daysOfTheWeekAliases[date[utc]('dw')]\n  },\n  {\n    format: 'dd',\n    match: (date, utc) => round(date[utc]('d'), 2)\n  },\n  {\n    format: 'd',\n    match: (date, utc) => date[utc]('d')\n  },\n  {\n    format: 'MMMM',\n    match: (date, utc) => monthsNames[date[utc]('M') - 1]\n  },\n  {\n    format: 'MMM',\n    match: (date, utc) => monthsAliases[date[utc]('M') - 1]\n  },\n  {\n    format: 'MM',\n    match: (date, utc) => round(date[utc]('M'), 2)\n  },\n  {\n    format: 'M',\n    match: (date, utc) => date[utc]('M')\n  },\n  {\n    format: 'yyyy',\n    match: (date, utc) => round(date[utc]('y'), 4)\n  },\n  {\n    format: 'yy',\n    match: (date, utc) => String(date[utc]('y')).slice(-2)\n  },\n  {\n    format: 'y',\n    match: (date, utc) => date[utc]('y')\n  }\n];\n\n/**\n * @function round\n * @private\n * @param {Number} number - Number to round.\n * @param {Number} digits - Number of the digits of the output.\n * @returns {String} String with necessary additional starting zeroes.\n */\nfunction round(number, digits) {\n  const string = String(number);\n  let zeroes = digits - string.length;\n\n  zeroes = zeroes < 0 ? 0 : zeroes;\n\n  return zero.repeat(zeroes).$ + string;\n}\n","/**\n * @module Dat\n * @private\n * @mixin\n * @description Exports Dat class.\n */\n\nimport { Super } from './Super';\nimport { Num } from './Num';\nimport { Str } from './Str';\nimport { switcher } from './Switcher';\nimport { constructors } from './constants';\nimport formats from './constants/formats';\nimport { isDate, iterate, Symbol, defineProperties } from './helpers';\n\n/**\n * @typedef {*} DateLike\n * @public\n */\n\n/**\n * @typedef {'c'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} AddPeriod\n * @public\n */\n\n/**\n * @typedef {'c'|'s'|'m'|'h'|'d'|'dw'|'M'|'y'} GetPeriod\n * @public\n */\n\n/**\n * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} OfOnePeriod\n * @public\n */\n\n/**\n * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} SetPeriod\n * @public\n */\n\n/**\n * @typedef {'ccc'|'c'|'ss'|'s'|'mm'|'m'|'hh'|'h'|'dddd'|'ddd'|'dd'|'d'|'MMMM'|'MMM'|'MM'|'M'|'yyyy'|'yy'|'y'} Format\n * @public\n */\n\nconst coeffs = {\n  c: 1,\n  s: 1000,\n  m: 60000,\n  h: 3600000,\n  d: 86400000,\n  w: 604800000,\n  M: 2592000000,\n  y: 31536000000\n};\n\nconst getSwitcher = switcher({\n  c: (date, utc) => date[`${ utc }Milliseconds`](),\n  s: (date, utc) => date[`${ utc }Seconds`](),\n  m: (date, utc) => date[`${ utc }Minutes`](),\n  h: (date, utc) => date[`${ utc }Hours`](),\n  d: (date, utc) => date[`${ utc }Date`](),\n  dw: (date, utc) => date[`${ utc }Day`](),\n  M: (date, utc) => date[`${ utc }Month`]() + 1,\n  y: (date, utc) => date[`${ utc }FullYear`]()\n}, 'equals', NaN);\nconst setSwitcher = switcher({\n  c: (date, value, utc) => date[`${ utc }Milliseconds`](value),\n  s: (date, value, utc) => date[`${ utc }Seconds`](value),\n  m: (date, value, utc) => date[`${ utc }Minutes`](value),\n  h: (date, value, utc) => date[`${ utc }Hours`](value),\n  d: (date, value, utc) => date[`${ utc }Date`](value),\n  M: (date, value, utc) => date[`${ utc }Month`](value - 1),\n  y: (date, value, utc) => date[`${ utc }FullYear`](value)\n});\n\n/**\n * @class Dat\n * @extends Super\n * @public\n * @param {Date} [date = new Date()] - A date to wrap.\n * @returns {Dat} Instance of Dat.\n * @description Wrap of a date.\n *\n * @example\n * const date = new Dat(new Date());\n */\nclass Dat extends Super {\n  constructor(date = new Date()) {\n    super(date);\n\n    /**\n     * @member Dat#$\n     * @type {Date}\n     * @public\n     * @description Original date.\n     */\n  }\n\n  /**\n   * @method Dat#add\n   * @public\n   * @param {AddPeriod|Object.<AddPeriod, Number>} what - What to add.\n   * @param {Number} [number] - Number of what to add if the first argument is a period string.\n   * @returns {Dat} Returns this.\n   * @description Method for adding amounts of time to the date. Returns new instance of Dat.\n   *\n   * @example\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add('c', 2).toISOString();         // '2000-01-01T00:00:00.001Z'\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add({ c: 2, d: 5 }).toISOString(); // '2000-01-06T00:00:00.001Z'\n   */\n  add(what, number) {\n    if (arguments.length >= 2) {\n      what = { [what]: number };\n    }\n\n    return this.time(this.time() + new Super(what).sum((value, what) => coeffs[what] * value));\n  }\n\n  /**\n   * @method Dat#expires\n   * @public\n   * @param {*} [value = this] - Value to resolve after the date expires.\n   * @returns {Promise} New instance of Promise.\n   * @description Method for defining when the date expires.\n   *\n   * @example\n   * new Dat().add('c', 500).expires('Expired').then((value) => {\n   *   // After 500 milliseconds\n   *   console.log(value); // 'Expired'\n   * });\n   */\n  expires(value) {\n    if (!arguments.length) {\n      value = this;\n    }\n\n    return new Num(this.$ - now()).timeout(value);\n  }\n\n  /**\n   * @method Dat#format\n   * @public\n   * @param {String} string - Template for the output.\n   * @param {String} [prefix = ''] - If needed [all special strings]{@link Format}\n   * are treated as they should be prefix with prefix.\n   * @returns {String} Formatted string.\n   * @description Method for creating formatted output based on a string.\n   *\n   * @example\n   * new Dat('1999-12-31T23:59:59.999Z').format('Seconds: $ss, milliseconds: $ccc.', '$');\n   * // 'Seconds: 59, milliseconds: 999.'\n   */\n  format(string, prefix = '') {\n    string = new Str(new Super(string).$);\n    prefix = String(new Super(prefix).$);\n\n    iterate(formats, (format) => {\n      string = string.replaceString(prefix + format.format, format.match(this, 'get'));\n    });\n\n    return string.$;\n  }\n\n  /**\n   * @method Dat#formatUTC\n   * @public\n   * @param {String} string - See {@link Dat#format}.\n   * @param {String} [prefix = ''] - See {@link Dat#format}.\n   * @returns {String} Formatted string.\n   * @description UTC version of {@link Dat#format}.\n   *\n   * @example\n   * new Dat('1999-07-07T03:09:09.099Z').formatUTC(\n   *   `\n   *     Milliseconds: $ccc|$c.\n   *     Seconds:      $ss|$s.\n   *     Minutes:      $mm|$m.\n   *     Hours:        $hh|$h.\n   *     Day:          $dddd|$ddd|$dd|$d.\n   *     Month:        $MMMM|$MMM|$MM|$M.\n   *     Year:         $yyyy|$yy|$y.\n   *   `,\n   *   '$'\n   * );\n   * // Milliseconds: 099|99.\n   * // Seconds:      09|9.\n   * // Minutes:      09|9.\n   * // Hours:        03|3.\n   * // Day:          Friday|Fri|07|7.\n   * // Month:        July|Jul|07|7.\n   * // Year:         1999|99|1999.\n   */\n  formatUTC(string, prefix = '') {\n    string = new Str(new Super(string).$);\n    prefix = String(new Super(prefix).$);\n\n    iterate(formats, (format) => {\n      string = string.replaceString(prefix + format.format, format.match(this, 'getUTC'));\n    });\n\n    return string.$;\n  }\n\n  /**\n   * @method Dat#get\n   * @public\n   * @param {GetPeriod} what - What to get.\n   * @returns {Number} Number of what to get.\n   * @description Method for getting values such as seconds or minutes.\n   *\n   * @example\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).get('s'); // 59\n   */\n  get(what) {\n    return getSwitcher(what, [this.$, 'get']);\n  }\n\n  /**\n   * @method Dat#getUTC\n   * @public\n   * @param {GetPeriod} what - See {@link Dat#get}.\n   * @returns {Number} Number of what to get.\n   * @description UTC version of {@link Dat#get}.\n   *\n   * @example\n   * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));\n   *\n   * date.getUTC('c');  // 999\n   * date.getUTC('s');  // 59\n   * date.getUTC('m');  // 59\n   * date.getUTC('h');  // 23\n   * date.getUTC('d');  // 31\n   * date.getUTC('dw'); // 5\n   * date.getUTC('M');  // 12\n   * date.getUTC('y');  // 1999\n   */\n  getUTC(what) {\n    return getSwitcher(what, [this.$, 'getUTC']);\n  }\n\n  /**\n   * @method Dat#isAfter\n   * @public\n   * @param {DateLike} date - Date to be compared to this date.\n   * @returns {Boolean} If this date is after the argument one.\n   * @description Finds out if this date is after the argument one.\n   *\n   * @example\n   * new Dat(new Date(333)).isAfter(new Date(334)); // false\n   * new Dat(new Date(333)).isAfter(new Date(332)); // true\n   */\n  isAfter(date) {\n    date = new Date(new Super(date).$);\n\n    return date.getTime() < this.$.getTime();\n  }\n\n  /**\n   * @method Dat#isBefore\n   * @public\n   * @param {DateLike} date - Date to be compared to this date.\n   * @returns {Boolean} If this date is before the argument one.\n   * @description Finds out if this date is before the argument one.\n   *\n   * @example\n   * new Dat(new Date(333)).isBefore(new Date(334)); // true\n   * new Dat(new Date(333)).isBefore(new Date(332)); // false\n   */\n  isBefore(date) {\n    date = new Date(new Super(date).$);\n\n    return date.getTime() > this.$.getTime();\n  }\n\n  /**\n   * @method Dat#isBetween\n   * @public\n   * @param {DateLike} date1 - Start of the range.\n   * @param {DateLike} date2 - End of the range.\n   * @returns {Boolean} If this date is after date1 and before date2.\n   * @description Finds out if this date is after date1 and before date2.\n   *\n   * @example\n   * new Dat(new Date(333)).isBetween(new Date(332), new Date(334)); // true\n   * new Dat(new Date(333)).isBetween(new Date(334), new Date(332)); // false\n   */\n  isBetween(date1, date2) {\n    const time = this.$.getTime();\n\n    date1 = new Date(new Super(date1).$);\n    date2 = new Date(new Super(date2).$);\n\n    return time > date1.getTime() && time < date2.getTime();\n  }\n\n  /**\n   * @method Dat#isInvalid\n   * @public\n   * @returns {Boolean} If the date is invalid.\n   * @description Returns if the date is invalid.\n   *\n   * @example\n   * new Dat(new Date('a')).isInvalid(); // true\n   * new Dat(new Date(1)).isInvalid();   // false\n   */\n  isInvalid() {\n    return this.$.toString() === 'Invalid Date';\n  }\n\n  /**\n   * @method Dat#isPassed\n   * @public\n   * @returns {Boolean} If the date is passed.\n   * @description Returns if the date is passed.\n   *\n   * @example\n   * new Dat(new Date(1)).isPassed(); // true\n   */\n  isPassed() {\n    return this.isBefore(now());\n  }\n\n  /**\n   * @method Dat#ofOne\n   * @public\n   * @param {OfOnePeriod} what - Period to check.\n   * @param {DateLike} date - Date to check.\n   * @returns {Boolean} If two dates are of one second, minute or something else.\n   * @description Returns if two dates are of one second, minute or something else.\n   *\n   * @example\n   * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:59.333Z')); // true\n   * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:58.999Z')); // false\n   */\n  ofOne(what, date) {\n    if (!(what in coeffs) || what === 'w') {\n      return false;\n    }\n\n    date = new Dat(new Date(date));\n\n    let started;\n\n    return iterate(coeffs, (coeff, w) => {\n      if (w === what) {\n        started = true;\n      }\n\n      if (!started || w === 'w') {\n        return;\n      }\n\n      if (started && this.get(w) !== date.get(w)) {\n        return false;\n      }\n    }) !== false;\n  }\n\n  /**\n   * @method Dat#set\n   * @public\n   * @param {SetPeriod|Object.<SetPeriod, Number>} what - What to add.\n   * @param {Number} [number] - Number of what to set if the first argument is a period string.\n   * @returns {Dat} Returns this.\n   * @description Method for setting values such as seconds or minutes.\n   *\n   * @example\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).set('s', 58).get('s');           // 58\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).set({ c: 998, s: 58 }).get('c'); // 998\n   */\n  set(what, number) {\n    const date = this.$;\n\n    if (arguments.length >= 2) {\n      what = { [what]: number };\n    }\n\n    what = new Super(what).$;\n\n    iterate(what, (value, what) => {\n      setSwitcher(what, [date, value, 'set']);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Dat#setUTC\n   * @public\n   * @param {SetPeriod|Object.<SetPeriod, Number>} what - See {@link Dat#set}.\n   * @param {Number} [number] - See {@link Dat#set}.\n   * @returns {Dat} Returns this.\n   * @description UTC version of {@link Dat#set}.\n   *\n   * @example\n   * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));\n   *\n   * date.setUTC('ccc', 998).getUTC('ccc'); // 998\n   * date.setUTC({\n   *   s: 58,\n   *   m: 58,\n   *   h: 22\n   * });\n   *\n   * date.getUTC('s'); // 58\n   * date.getUTC('m'); // 58\n   * date.getUTC('h'); // 23\n   */\n  setUTC(what, number) {\n    const date = this.$;\n\n    if (arguments.length >= 2) {\n      what = { [what]: number };\n    }\n\n    what = new Super(what).$;\n\n    iterate(what, (value, what) => {\n      setSwitcher(what, [date, value, 'setUTC']);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Dat#setUTC\n   * @public\n   * @param {Number} [time] - Time to set.\n   * @returns {Dat|Number} - If the time argument is present this is returned otherwise the time is returned.\n   * @description Synonym for both\n   * [Date#getTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime} and\n   * [Date#setTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime}.\n   */\n  time(time) {\n    const date = this.$;\n\n    if (arguments.length) {\n      date.setTime(time);\n    }\n\n    return date.getTime();\n  }\n\n  toISOString() {\n    return this.$.toISOString();\n  }\n\n  toLocaleString() {\n    return this.$.toLocaleString();\n  }\n\n  toString() {\n    return this.$.toString();\n  }\n\n  valueOf() {\n    return this.$.valueOf();\n  }\n}\ndefineProperties(Dat.prototype, {\n  [Symbol.toStringTag]: 'Dat'\n});\n\nconstructors[1].push({\n  check: isDate,\n  cls: Dat\n});\n\n/**\n * @function now\n * @public\n * @returns {Number} Number of milliseconds.\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now\n * @description Synonym for\n * [Date.now]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now}.\n */\nfunction now() {\n  return Date.now();\n}\n\n/**\n * @function date\n * @public\n * @param {DateLike} [date = new Date()] - Date-like value that is passed to the Date constructor.\n * @returns {Dat} New instance of Dat.\n * @description Synonym for new Dat(new Date(date));\n */\nfunction date(date) {\n  if (!arguments.length) {\n    return new Dat(new Date(now()));\n  }\n\n  date = new Super(date).$;\n\n  return new Dat(new Date(date));\n}\n\nexport { Dat, now, date };\n","/**\n * @module helpers/constructURL\n * @private\n * @description Exports constructURL method.\n */\n\nimport { Arr } from '../Arr';\nimport { Str } from '../Str';\nimport { switcher } from '../Switcher';\nimport { isArray, isObject, isPlainObject } from './checkTypes';\nimport { iterate } from './iterate';\n\n/**\n * @type {RegExp}\n * @description Absolute URL pattern.\n */\nconst absoluteURLRegexp = /^(([a-z][a-z\\d+\\-.]*:)?\\/\\/|data:[a-z]+\\/[a-z]+;base64,)/i;\nconst querySwitcher = switcher('call', () => new Arr([]))\n  .case(isArray, (prefix, query) => {\n    let queryParams = new Arr([]);\n\n    iterate(query, (value) => {\n      if (isPlainObject(value) || isArray(value)) {\n        queryParams = queryParams.concat(querySwitcher(value, [`${ prefix }[]`]));\n\n        return;\n      }\n\n      queryParams.push({\n        param: `${ prefix }[]`,\n        value\n      });\n    });\n\n    return queryParams.$;\n  })\n  .case(isPlainObject, (prefix, query) => {\n    let queryParams = new Arr([]);\n\n    iterate(query, (value, param) => {\n      if (isPlainObject(value) || isArray(value)) {\n        queryParams = queryParams.concat(querySwitcher(value, [prefix ? `${ prefix }[${ param }]` : param]));\n\n        return;\n      }\n\n      queryParams.push({\n        param: prefix ? `${ prefix }[${ param }]` : param,\n        value: isObject(value) ? JSON.stringify(value) : String(value)\n      });\n    });\n\n    return queryParams.$;\n  });\n\n/**\n * @function constructURL\n * @param {String} baseURL - BaseURL of the output URL.\n * @param {String} url - Main part of the output URL.\n * @param {Object} params - Params to replace in the url expressions like \":param\".\n * @param {Object} query - Object with query params.\n * @param {Object} [hash = ''] - URL hash.\n * @param {Object} [encodeOptions = {}] - If you need to encode something.\n * @param {Object} [encodeOptions.params = true] - If you need to encode params.\n * @param {Object} [encodeOptions.query = true] - If you need to encode query params.\n * @returns {String} Constructed URL.\n * @description Function for constructing URL from the base URL, URL, params and query params.\n */\nexport default (baseURL, url, params, query, hash = '', encodeOptions = {}) => {\n  const {\n    params: encodeParams = true,\n    query: encodeQuery = true\n  } = encodeOptions;\n  let URL = isAbsolute(url)\n    ? url\n    : `${ String(baseURL).replace(/\\/+$/, '') }/${ String(url).replace(/^\\/+/, '') }`;\n\n  iterate(params, (value, param) => {\n    URL = new Str(URL).replaceString(`:${ param }`, encode(value, encodeParams)).$;\n  });\n\n  const queryParams = querySwitcher(query, ['']);\n\n  if (queryParams.length) {\n    URL += (URL.indexOf('?') === -1 ? '?' : '&') + queryParams\n      .map(({ param, value }) => `${ encode(param, encodeQuery) }=${ encode(value, encodeQuery) }`)\n      .join('&');\n  }\n\n  return `${ URL }${ hash ? `#${ hash }` : '' }`;\n};\n\n/**\n * @function isAbsolute\n * @param {String} url - URL to check if it is absolute or not.\n * @returns {Boolean} If the argument URL is absolute or not.\n */\nfunction isAbsolute(url) {\n  return absoluteURLRegexp.test(url);\n}\n\n/**\n * @function encode\n * @param {String} string - String to encode using encodeURIComponent.\n * @param {Boolean} isEncoded - If the string should be encoded.\n * @returns {String} Encoded string.\n */\nfunction encode(string, isEncoded) {\n  return isEncoded ? encodeURIComponent(string) : string;\n}\n","/**\n * @module Fetch\n * @private\n * @mixin\n * @description Exports Fetch class.\n */\n\nimport { Promise } from './Promise';\nimport { Super } from './Super';\nimport { Arr } from './Arr';\nimport { Str } from './Str';\nimport {\n  isArray, isFunction, isString,\n  assign, Symbol, validate, iterate, defineProperties\n} from './helpers';\nimport constructURL from './helpers/constructURL';\nimport parseHeaders from './helpers/parseHeaders';\nimport transformData from './helpers/transformData';\n\n/**\n * @typedef {'get'|'post'|'delete'|'head'|'put'|'patch'} FetchMethod\n * @public\n */\n\n/**\n * @typedef {Object} FetchConfig\n * @public\n * @property {Array.<AfterMiddleware|FetchErrorAfterMiddleware>} [after]\n * @property {Object} [auth]\n * @property {String} [auth.username]\n * @property {String} [auth.password]\n * @property {String} [baseURL]\n * @property {Array.<BeforeMiddleware|FetchErrorBeforeMiddleware>} [before]\n * @property {*} [data]\n * @property {Object.<String, String[]>} [headers]\n * @property {FetchMethod} [method]\n * @property {Object} [params]\n * @property {Object} [query]\n * @property {String} [responseType]\n * @property {Number} [timeout]\n * @property {String} [url]\n * @property {Boolean} [withCredentials]\n */\n\n/**\n * @typedef {Object} FetchResponse\n * @public\n * @property {FetchConfig} config\n * @property {*} data\n * @property {Object.<String, String>} headers\n * @property {Number} status\n * @property {String} statusText\n * @property {XMLHttpRequest} xhr\n */\n\n/**\n * @callback FetchAfterMiddleware\n * @public\n * @param {FetchResponse} config - Fetch response.\n */\n\n/**\n * @callback FetchErrorAfterMiddleware\n * @public\n * @param {Error|*} err - Thrown error.\n * @param {FetchResponse} config - Fetch response.\n */\n\n/**\n * @callback FetchBeforeMiddleware\n * @public\n * @param {FetchConfig} config - Fetch config.\n */\n\n/**\n * @callback FetchErrorBeforeMiddleware\n * @public\n * @param {Error|*} err - Thrown error.\n * @param {FetchConfig} config - Fetch config.\n */\n\n/**\n * @callback FetchConfigFunction\n * @public\n * @param {FetchConfig} config\n */\n\nconst defaults = {\n  after: [],\n  auth: {\n    username: '',\n    password: ''\n  },\n  baseURL: global.location.origin,\n  before: [],\n  data: null,\n  headers: {},\n  method: 'get',\n  params: {},\n  query: {},\n  responseType: '',\n  timeout: 0,\n  url: '',\n  withCredentials: false\n};\nconst uploadMethods = new Arr(['post', 'put']);\n\n/**\n * @class Fetch\n * @extends Function\n * @public\n * @param {FetchConfig} [config = {}] - A number to wrap.\n * @returns {Fetch} Instance of Fetch.\n * An instance of Fetch is a function that simply calls #request with the same arguments.\n * @description Class for fetching data.\n *\n * @example\n * const fetch = new Fetch();\n *\n * fetch('/data').then((res) => {\n *   console.log(res);\n * });\n */\nclass Fetch extends Function {\n  constructor(config = {}) {\n    super();\n\n    function fetch() {\n      return fetch.request.apply(fetch, arguments);\n    }\n\n    const conf = new Super({}).deepAssign(defaults, config).$;\n\n    if (conf.before.indexOf(fetchBeforeMiddleware) === -1) {\n      conf.before.push(fetchBeforeMiddleware);\n    }\n\n    /**\n     * @member {FetchConfig} Fetch#$$\n     * @type {FetchConfig}\n     * @public\n     * @description Fetch config.\n     */\n    Object.defineProperty(fetch, '$$', { value: conf });\n    Object.setPrototypeOf(fetch, Fetch.prototype);\n\n    return fetch;\n  }\n\n  /**\n   * @method Fetch#after\n   * @public\n   * @param {FetchAfterMiddleware|FetchErrorAfterMiddleware} middleware - Middleware to add.\n   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put the middleware.\n   * Truthy parameter stands for \"to the end\" and falsey for \"to the beginning\".\n   * @returns {Fetch} Returns this.\n   * @description Middleware that is called after the request.\n   * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.\n   * If the middleware returns a promise it becomes a part of the middleware chain.\n   *\n   * @example\n   * const fetch = new Fetch()\n   *   .after((err, res) => {\n   *     console.log(err);\n   *\n   *     throw err;\n   *   })\n   *   .after((res) => {\n   *     res.json = D(res.data).parseJSON():\n   *   });\n   */\n  after(middleware, afterAll = true) {\n    validate([middleware], ['function'], 'Fetch#after');\n\n    const { after } = this.$$;\n\n    if (afterAll) {\n      after.push(middleware);\n    } else {\n      after.unshift(middleware);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Fetch#before\n   * @public\n   * @param {FetchBeforeMiddleware|FetchErrorBeforeMiddleware} middleware - Middleware to add.\n   * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put the middleware.\n   * Truthy parameter stands for \"to the beginning\" and falsey for \"to the end\".\n   * @returns {Fetch} Returns this.\n   * @description Middleware that is called before the request.\n   * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.\n   * If the middleware returns a promise it becomes a part of the middleware chain.\n   *\n   * @example\n   * const fetch = new Fetch()\n   *   .before((err, req) => {\n   *     console.log(err);\n   *\n   *     throw err;\n   *   })\n   *   .before((req) => {\n   *     if (req.url === '/veryLongRequest') {\n   *       req.timeout = 30000;\n   *     }\n   *   });\n   */\n  before(middleware, beforeAll = true) {\n    validate([middleware], ['function'], 'Fetch#before');\n\n    const { before } = this.$$;\n\n    if (beforeAll) {\n      before.unshift(middleware);\n    } else {\n      before.push(middleware);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Fetch#config\n   * @public\n   * @param {String|FetchConfig|FetchConfigFunction} [property] - If it's a function\n   * it's called with the fetch config argument, if it's a string the value argument\n   * is used for assigning this property to the fetch config\n   * otherwise it's assigned to the fetch config.\n   * @param {*} [value] - See the property argument.\n   * @returns {Fetch|FetchConfig} If the argument is present this is returned otherwise the fetch config is returned.\n   * @description Method for getting and setting config.\n   *\n   * @example\n   * const fetch = new Fetch();\n   *\n   * fetch.config({ baseURL: 5000 });\n   * fetch.config().timeout; // 5000\n   *\n   * fetch.config((config) => {\n   *   config.baseURL += '/api';\n   * });\n   */\n  config(property, value) {\n    const conf = this.$$;\n\n    if (!arguments.length) {\n      return conf;\n    }\n\n    if (isFunction(property)) {\n      property(conf);\n    } else {\n      if (arguments.length >= 2) {\n        property = { [property]: value };\n      }\n\n      new Super(conf).deepAssign(property);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method Fetch#delete\n   * @public\n   * @param {String} [url] - See {@link Fetch#request}.\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\n   * @description Shorthand for #request for delete requests.\n   *\n   * @example\n   * new Fetch().delete('/data').then((res) => {\n   *   console.log(res);\n   * });\n   */\n  delete(url, config = {}) {\n    if (!isString(url)) {\n      config = url;\n      url = undefined;\n    }\n\n    return this.request(url, assign({ method: 'delete' }, config));\n  }\n\n  /**\n   * @method Fetch#get\n   * @public\n   * @param {String} [url] - See {@link Fetch#request}.\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\n   * @description Shorthand for #request for get requests.\n   *\n   * @example\n   * new Fetch().get('/data').then((res) => {\n   *   console.log(res);\n   * });\n   */\n  get(url, config = {}) {\n    if (!isString(url)) {\n      config = url;\n      url = undefined;\n    }\n\n    return this.request(url, assign({ method: 'get' }, config));\n  }\n\n  /**\n   * @method Fetch#head\n   * @public\n   * @param {String} [url] - See {@link Fetch#request}.\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\n   * @description Shorthand for #request for head requests.\n   *\n   * @example\n   * new Fetch().head('/data').then((res) => {\n   *   console.log(res);\n   * });\n   */\n  head(url, config = {}) {\n    if (!isString(url)) {\n      config = url;\n      url = undefined;\n    }\n\n    return this.request(url, assign({ method: 'head' }, config));\n  }\n\n  /**\n   * @method Fetch#headers\n   * @public\n   * @param {String|Object.<String, String|String[]>} header - A header string or an object of the following format:\n   * { [header]: [value1, value2, ...] }.\n   * @param {String|String[]} [value] - Header value. If the first argument is a string\n   * this has to be a header value or an array of header values.\n   * @returns {Fetch} Returns this.\n   * @description Method for setting request headers.\n   *\n   * @example\n   * const fetch = new Fetch()\n   *   .headers('Header1', 'Value')\n   *   .headers('Header2', ['Value1', 'Value2'])\n   *   .headers({\n   *     Header3: ['Value1', 'Value2']\n   *   });\n   */\n  headers(header, value) {\n    const { headers } = this.$$;\n\n    if (arguments.length >= 2) {\n      header = { [header]: value };\n    }\n\n    iterate(header, (value, header) => {\n      const array = headers[header] || [];\n      const toPush = isArray(value) ? value : [value];\n\n      (headers[header] = array).push.apply(array, toPush);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Fetch#instance\n   * @public\n   * @param {FetchConfig} [config] - New config if needed.\n   * @returns {Fetch} New instance of Fetch.\n   * @description Method for creating new fetch instances based on already existent.\n   *\n   * @example\n   * const mainFetch = new Fetch({\n   *   baseURL: '//other.domain.com/api',\n   *   withCredentials: true\n   * });\n   *\n   * const longFetch = mainFetch.instance({\n   *   timeout: 10000\n   * });\n   */\n  instance(config = {}) {\n    const dataConfig = new Super(config).hasOwn('data')\n      ? { data: config.data }\n      : {};\n\n    delete config.data;\n\n    const conf = new Super({})\n      .deepAssign(this.$$, config)\n      .assign(dataConfig)\n      .$;\n\n    return new Fetch(conf);\n  }\n\n  /**\n   * @method Fetch#patch\n   * @public\n   * @param {String} [url] - See {@link Fetch#request}.\n   * @param {*} [data] - Additional parameter for uploading data.\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\n   * @description Shorthand for #request for head requests.\n   *\n   * @example\n   * new Fetch().patch('/data', { user: 'John' }).then((res) => {\n   *   console.log(res);\n   * });\n   */\n  patch(url, data = {}, config = {}) {\n    if (arguments.length && !isString(url)) {\n      config = data;\n      data = url;\n      url = undefined;\n    }\n\n    return this.request(url, assign({ method: 'patch', data }, config));\n  }\n\n  /**\n   * @method Fetch#post\n   * @public\n   * @param {String} [url] - See {@link Fetch#request}.\n   * @param {*} [data] - Additional parameter for uploading data.\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\n   * @description Shorthand for #request for head requests.\n   *\n   * @example\n   * new Fetch().post('/data', { user: 'John' }).then((res) => {\n   *   console.log(res);\n   * });\n   */\n  post(url, data = {}, config = {}) {\n    if (arguments.length && !isString(url)) {\n      config = data;\n      data = url;\n      url = undefined;\n    }\n\n    return this.request(url, assign({ method: 'post', data }, config));\n  }\n\n  /**\n   * @method Fetch#put\n   * @public\n   * @param {String} [url] - See {@link Fetch#request}.\n   * @param {*} [data] - Additional parameter for uploading data.\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\n   * @description Shorthand for #request for head requests.\n   *\n   * @example\n   * new Fetch().put('/data', { user: 'John' }).then((res) => {\n   *   console.log(res);\n   * });\n   */\n  put(url, data = {}, config = {}) {\n    if (arguments.length && !isString(url)) {\n      config = data;\n      data = url;\n      url = undefined;\n    }\n\n    return this.request(url, assign({ method: 'put', data }, config));\n  }\n\n  /**\n   * @method Fetch#request\n   * @public\n   * @param {String} [url] - URL for the request.\n   * @param {FetchConfig} [config] - Additional config for this particular request.\n   * @returns {Promise.<FetchResponse, Error>} Promise that is resolved with the request response.\n   * @description Main function for making requests. All request methods call this method\n   * including the fetch instance itself.\n   *\n   * @example\n   * const fetch = new Fetch();\n   *\n   * fetch.request('/data', { timeout: 1000 }).then((res) => {\n   *   console.log(res);\n   * });\n   *\n   * fetch.request({ timeout: 1000 }).then((res) => {\n   *   console.log(res);\n   * });\n   *\n   * fetch.request().then((res) => {\n   *   console.log(res);\n   * });\n   */\n  request(url, config = {}) {\n    if (arguments.length === 1 && !isString(url)) {\n      config = url;\n    }\n\n    const dataConfig = new Super(config).hasOwn('data')\n      ? { data: config.data }\n      : {};\n    const urlConfig = isString(url)\n      ? { url }\n      : {};\n\n    delete config.data;\n\n    const conf = new Super(this.$$)\n      .deepClone()\n      .deepAssign(urlConfig, config)\n      .assign(dataConfig)\n      .$;\n\n    let xhr;\n    let promise = Promise.resolve();\n\n    iterate(conf.before, (middleware) => {\n      promise = promise.then(() => {\n        if (middleware.length >= 2) {\n          return Promise.resolve();\n        }\n\n        return new Promise((resolve) => {\n          resolve(middleware(conf));\n        });\n      }, (err) => {\n        if (middleware.length < 2) {\n          return Promise.reject(err);\n        }\n\n        return new Promise((resolve) => {\n          resolve(middleware(err, conf));\n        });\n      });\n    });\n\n    promise = promise.then(() => new Promise((resolve, reject) => {\n      const {\n        after,\n        auth: {\n          username,\n          password\n        },\n        data,\n        headers,\n        method,\n        onprogress,\n        responseType,\n        timeout,\n        url,\n        withCredentials\n      } = conf;\n\n      xhr = new XMLHttpRequest();\n\n      xhr.open(method, url, true, username, password);\n\n      iterate(headers, (value, header) => {\n        xhr.setRequestHeader(header, value);\n      });\n\n      if (onprogress) {\n        if (uploadMethods.indexOfStrict(method) === -1) {\n          xhr.onprogress = onprogress;\n        } else {\n          xhr.upload.onprogress = onprogress;\n        }\n      }\n\n      xhr.onabort = () => {\n        const error = new Error('Request was aborted');\n\n        error.type = 'ABORT_ERROR';\n\n        reject(error);\n\n        xhr = null;\n      };\n\n      xhr.onerror = () => {\n        const error = new Error('Network error');\n\n        error.type = 'NETWORK_ERROR';\n\n        reject(error);\n\n        xhr = null;\n      };\n\n      xhr.ontimeout = () => {\n        const error = new Error('Request time exceeded');\n\n        error.type = 'TIMEOUT_ERROR';\n\n        reject(error);\n\n        xhr = null;\n      };\n\n      xhr.onreadystatechange = () => {\n        if (!xhr || !xhr.status || xhr.readyState !== 4) {\n          return;\n        }\n\n        const response = {\n          config: conf,\n          data: !responseType || responseType === 'text' ? xhr.responseText : xhr.response,\n          headers: parseHeaders(xhr.getAllResponseHeaders()),\n          status: xhr.status === 1223 ? 204 : xhr.status,\n          statusText: xhr.status === 1223 ? 'No Content' : xhr.statusText,\n          xhr\n        };\n\n        let promise = Promise.resolve();\n\n        iterate(after, (middleware) => {\n          promise = promise.then(() => {\n            if (middleware.length >= 2) {\n              return Promise.resolve();\n            }\n\n            return new Promise((resolve) => {\n              resolve(middleware(response));\n            });\n          }, (err) => {\n            if (middleware.length < 2) {\n              return Promise.reject(err);\n            }\n\n            return new Promise((resolve) => {\n              resolve(middleware(err, response));\n            });\n          });\n        });\n\n        resolve(promise\n          .then(() => response)\n          .catch((err) => {\n            try {\n              err.response = response;\n            } catch (e) {\n              throw err;\n            }\n\n            throw err;\n          })\n        );\n      };\n\n      xhr.responseType = responseType;\n      xhr.timeout = Number(timeout) || 0;\n      xhr.withCredentials = !!withCredentials;\n\n      xhr.send(data);\n    }));\n\n    promise.abort = function abort() {\n      if (xhr) {\n        xhr.abort();\n      }\n\n      return this;\n    };\n\n    return promise;\n  }\n}\n\ndefineProperties(Fetch.prototype, {\n  [Symbol.toStringTag]: 'Fetch'\n});\n\n/**\n * @function fetchBeforeMiddleware\n * @private\n * @param {FetchConfig} config\n * @description Built-in before middleware for url, data, method, headers construction.\n */\nfunction fetchBeforeMiddleware(config) {\n  const {\n    baseURL,\n    data,\n    headers,\n    method,\n    params,\n    query,\n    url\n  } = config;\n  const METHOD = method.toUpperCase();\n\n  config.method = METHOD;\n  config.url = constructURL(baseURL, url, params, query);\n  config.data = transformData(data, METHOD, headers);\n  config.headers = new Super(headers).object((headers, values, header) => {\n    header = new Str(header)\n      .toCapitalCase()\n      .replace(/\\s+/g, '-')\n      .$;\n\n    headers[header] = values.join(', ');\n  }).$;\n}\n\n/**\n * @const {Fetch} fetch\n * @type {Fetch}\n * @public\n * @description Empty instance of Fetch.\n */\nconst fetch = new Fetch();\n\nexport { Fetch, fetch };\n","/**\n * @module Router\n * @private\n * @mixin\n * @description Exports Router.\n */\n\nimport { Arr } from './Arr';\nimport { Elem, win } from './Elem';\nimport { self } from './Func';\nimport { Str } from './Str';\nimport { Super } from './Super';\nimport { switcher } from './Switcher';\nimport { assign, isNil, isRegExp, isString } from './helpers';\nimport constructURL from './helpers/constructURL';\nimport resolveURL from './helpers/resolveURL';\n\nconst Routes = new Arr([]);\nconst currentRoutes = new Arr([]);\nconst subscribers = {};\nconst {\n  history,\n  location,\n  location: {\n    href: initialURL\n  }\n} = global;\nlet initialized;\nlet pushed;\nlet wasRoot;\nlet wasDefault;\nlet rootRoute;\nlet redirectRoute;\nlet redirectRouteIsNeededToPush = false;\nlet RedirectRoute;\nlet defaultRoute;\nlet DefaultRoute;\nlet currentRoute;\nlet currentRouteParams;\n\nconst pathSwitcher = switcher('call', () => {\n  throw new Error('State path must be a string, a regular expression or undefined! (at registerState)');\n})\n  .case(isRegExp, (path) => ({\n    path: path.source.replace(/\\\\\\//g, '/'),\n    url: path,\n    params: {}\n  }))\n  .case(isNil, () => ({\n    path: '/',\n    url: '/',\n    params: {}\n  }))\n  .case(isString, (path) => {\n    if (path.indexOf('/')) {\n      throw new Error('If route path is a string it must start with \"/\"! (at registerState)');\n    }\n\n    const index = path.indexOf('?');\n    const params = new Super({});\n    let newURL = '';\n    const newPath = new Str(path)\n      .slice(0, index === -1 ? path.length : index)\n      .replace(/^\\/|\\/$/g)\n      .split(/\\//)\n      .map((part, i, array) => {\n        if (!part && array.length > 1) {\n          throw new Error('If route path is a string it must not contain \"//\" or end with \"/\"! (at makeRoute)');\n        }\n\n        const index = part.indexOf(':');\n\n        if (index > 0) {\n          throw new Error('If route path is a string resource part must be either a string or an URL parameter! (at makeRoute)');\n        }\n\n        if (index === -1) {\n          return {\n            url: part,\n            value: part\n          };\n        }\n\n        const {\n          name,\n          regexp = /[^/]*/\n        } = resolveParameter(\n          part.slice(1),\n          'URL parameter must not be an empty string or contain characters besides \"a-zA-Z_$\"! (at makeRoute)',\n          'URL parameter regexp validator must be within parentheses (e.g. :userId(\\\\d+) and not contain ones)! (at makeRoute)'\n        );\n\n        params.$[name] = params.count;\n\n        return {\n          type: 'param',\n          url: `:${ name }`,\n          value: regexp\n        };\n      })\n      .word(({ type, url, value }) => {\n        let newPath;\n\n        if (type === 'param') {\n          newPath = `(${ value.source.replace(/\\\\\\//g, '/') })`;\n        } else {\n          newPath = new Str(value).escapeRegExp().$;\n        }\n\n        newURL += `/${ url }`;\n\n        return `/${ newPath }`;\n      });\n\n    return {\n      path: newPath,\n      url: newURL,\n      params: params.$\n    };\n  });\n\nconst router = {\n  buildURL,\n  go,\n  goToURL,\n  pushURL,\n  redirect,\n  redirectToURL,\n  replaceURL\n};\n\nclass Route {\n  constructor(options) {\n    options = options || {};\n\n    const {\n      name,\n      path = '/',\n      abstract = false,\n      parent,\n      decodeQuery = true,\n      encodeQuery = true,\n      decodeParams = true,\n      encodeParams = true\n    } = options || {};\n    const {\n      url: relativeURL,\n      path: relativePath,\n      params\n    } = pathSwitcher(path);\n    const query = {};\n\n    new Super(this).assign({\n      name,\n      parentName: parent,\n      abstract: !!abstract,\n      children: new Arr([]),\n      decodeParams: !!decodeParams,\n      decodeQuery: !!decodeQuery,\n      encodeParams: !!encodeParams,\n      encodeQuery: !!encodeQuery,\n      params,\n      query,\n      relativePath,\n      relativeURL\n    });\n\n    const index = isString(path)\n      ? path.indexOf('?')\n      : -1;\n\n    if (index !== -1) {\n      new Str(path)\n        .replace(/&$/)\n        .slice(index + 1)\n        .split('&')\n        .forEach((param) => {\n          const {\n            name,\n            regexp = /[\\s\\S]*/\n          } = resolveParameter(\n            param,\n            'Query parameter must not be an empty string or contain characters besides \"a-zA-Z_$\"! (at makeRoute)',\n            'Query parameter regexp validator must be within parentheses (e.g. :userId(\\\\d+)) and not contain them! (at makeRoute)'\n          );\n\n          query[name] = new RegExp(`^${ regexp.source.replace(/\\\\\\//g, '/') }$`);\n        });\n    }\n\n    if (name === defaultRoute && (\n        new Super(params).count\n        || new Super(query).count\n      )) {\n      throw new Error('Default route must not have URL or query params! (at makeRoute)');\n    }\n  }\n}\n\nconst baseRoute = new Route();\n\nfunction initRouter() {\n  if (initialized) {\n    return;\n  }\n\n  initialized = true;\n  RedirectRoute = (Routes.find(({ name }) => name === redirectRoute) || {}).value;\n  DefaultRoute = (Routes.find(({ name }) => name === defaultRoute) || {}).value;\n\n  if (redirectRoute && !RedirectRoute) {\n    throw new Error(`There is no specified fallback route (\"${ redirectRoute }\")! (at initRouter)`);\n  }\n\n  Routes\n    .forEach((route) => {\n      const {\n        parentName,\n        name\n      } = route;\n      const ParentName = parentName || rootRoute;\n      const { value: parent } = Routes.find(({ name }) => name === ParentName) || {};\n\n      if (!parent) {\n        throw new Error(`No such parent route (\"${ ParentName }\") found for the route (\"${ name }\")! (at initRouter)`);\n      }\n\n      if (!parent.abstract && name !== rootRoute) {\n        throw new Error(`Parent route must be abstract (for \"${ name }\")! (at initRouter)`);\n      }\n\n      if (name !== rootRoute) {\n        route.parentName = ParentName;\n      }\n\n      route.parent = name === rootRoute\n        ? baseRoute\n        : parent;\n    })\n    .forEach((route) => {\n      const {\n        name,\n        parent: {\n          params: parentParams,\n          query: parentQuery,\n          path\n        },\n        params,\n        query,\n        relativeURL,\n        relativePath\n      } = route;\n      let proto = route;\n      let count = 0;\n      let newPath = relativePath;\n      let newURL = '';\n\n      if (isRegExp(path)) {\n        throw new Error('URL regexp route cannot be extended! (at initRouter)');\n      }\n\n      while (proto = proto.parent) {\n        count += new Super(proto.params).count;\n        newPath = proto.relativePath + newPath;\n        newURL = proto.relativeURL + newURL;\n\n        proto.children.push(route);\n      }\n\n      newPath = new RegExp(`^${ newPath.replace(/\\/+/g, '/').replace(/\\/$/, '') || '/' }$`);\n      newURL = isRegExp(relativeURL)\n        ? newPath\n        : (newURL + relativeURL).replace(/\\/+/g, '/').replace(/\\/$/, '') || '/';\n\n      new Super(query).proto(parentQuery);\n      new Super(params)\n        .proto(parentParams)\n        .forEach((value, key, params) => {\n          params[key] += count;\n        });\n\n      if (name === defaultRoute && (\n          new Super(params).count\n          || new Super(query).count\n        )) {\n        throw new Error('Default route must not have URL or query params! (at initRouter)');\n      }\n\n      route.url = newURL;\n      route.validatePath = newPath;\n    });\n\n  changeRoute();\n\n  win.on({\n    popstate() {\n      if (location.href !== initialURL) {\n        pushed = true;\n      }\n\n      if (pushed) {\n        changeRoute();\n      }\n    },\n    click(e) {\n      const closestLink = new Elem(e.target).closest('a');\n\n      if (closestLink.length && closestLink.attr('target') !== '_blank' && !closestLink.hasAttr('no-routing')) {\n        const push = !closestLink.hasAttr('replace');\n\n        e.preventDefault();\n\n        forward(closestLink.attr('href') || '', push);\n      }\n    }\n  });\n}\n\nfunction makeRoute(options) {\n  return (Block) => {\n    options = assign({}, options, Block.routerOptions);\n\n    const {\n      name,\n      path,\n      abstract,\n      root,\n      fallbackTo,\n      replace = true,\n      default: isDefault\n    } = options || {};\n\n    if (initialized) {\n      console.warn('Router was already initialized (at makeRoute)');\n\n      return self;\n    }\n\n    if (wasRoot && root) {\n      throw new Error(`There can't be two root routes (\"${ rootRoute }\" and \"${ name }\")! (at makeRoute)`);\n    }\n\n    if (wasDefault && isDefault) {\n      throw new Error(`There can't be two default routes (\"${ defaultRoute }\" and \"${ name }\")! (at makeRoute)`);\n    }\n\n    if (!name) {\n      throw new Error('State must have a non-empty string \"name\" property! (at makeRoute)');\n    }\n\n    if (Routes.some(({ name: Name }) => Name === name)) {\n      throw new Error('State must have unique \"name\" property! (at makeRoute)');\n    }\n\n    if (root) {\n      wasRoot = true;\n      rootRoute = name;\n      options.parent = null;\n\n      if (fallbackTo) {\n        redirectRoute = fallbackTo;\n        redirectRouteIsNeededToPush = !replace;\n      }\n    }\n\n    if (isDefault) {\n      wasDefault = true;\n      defaultRoute = name;\n\n      if (abstract) {\n        throw new Error('Default route can\\'t be abstract! (at makeRoute)');\n      }\n\n      if (isRegExp(path)) {\n        throw new Error('Default route can\\'t have a regexp path! (at makeRoute)');\n      }\n    }\n\n    const route = new Route(options);\n\n    Routes.push(route);\n\n    let unsubscribe;\n    let routeLoaded;\n\n    return class extends Block {\n      /* eslint prefer-template: 0 */\n      static template = '<d-if if=\"{__wasRouteActive__}\">'\n        + '<div'\n        + `  class=\"dwayne-route route-${ name + (abstract ? ' abstract-route' : '') }\"`\n        + '  d-class=\"{{ \\'active-route\\': __isCurrentRoute__ }}\"'\n        + '  d-show=\"{__isCurrentRoute__}\"'\n        + '>'\n        + Block.template\n        + '</div>'\n        + '</d-if>';\n\n      constructor(opts) {\n        super(opts);\n\n        if (root) {\n          initRouter();\n\n          this.globals.router = router;\n        }\n\n        this.__routerInstance__ = route;\n        this.__isCurrentRoute__ = currentRoutes.includes(route);\n        this.__wasRouteActive__ = this.__isCurrentRoute__;\n        this.args.route = currentRouteParams;\n\n        routeLoaded = false;\n        unsubscribe = subscribe(name, (action) => {\n          const isCurrentRoute = action !== 'leave';\n\n          this.__isCurrentRoute__ = isCurrentRoute;\n\n          if (isCurrentRoute) {\n            this.__wasRouteActive__ = true;\n            this.args.route = currentRouteParams;\n          }\n\n          if (action === 'load') {\n            callBeforeLoad(this);\n          } else if (action === 'leave') {\n            callBeforeLeave(this);\n          }\n        });\n\n        if (this.__isCurrentRoute__) {\n          callBeforeLoad(this);\n        }\n      }\n\n      beforeRemove() {\n        unsubscribe();\n        unsubscribe = null;\n        callBeforeLeave(this);\n        super.beforeRemove();\n      }\n    };\n\n    function callBeforeLoad(route) {\n      if (routeLoaded) {\n        return;\n      }\n\n      const block = {\n        $$: {\n          children: new Arr([route])\n        }\n      };\n      let wasRoute;\n\n      block.$$.children.forEach(function beforeLoad(block) {\n        if (block.__routerInstance__) {\n          if (wasRoute) {\n            return;\n          }\n\n          wasRoute = true;\n        }\n\n        const {\n          name,\n          children,\n          mixins\n        } = block.$$;\n\n        if (children) {\n          children.forEach(beforeLoad);\n        }\n\n        if (mixins) {\n          mixins.forEach(beforeLoad);\n        }\n\n        if (block.beforeLoadRoute) {\n          try {\n            block.beforeLoadRoute();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeLoad:`, err);\n          }\n        }\n      });\n\n      routeLoaded = true;\n    }\n\n    function callBeforeLeave(route) {\n      if (!routeLoaded) {\n        return;\n      }\n\n      const block = {\n        $$: {\n          children: new Arr([route])\n        }\n      };\n      let wasRoute;\n\n      block.$$.children.forEach(function beforeLeave(block) {\n        if (block.__routerInstance__) {\n          if (wasRoute) {\n            return;\n          }\n\n          wasRoute = true;\n        }\n\n        const {\n          name,\n          children,\n          mixins\n        } = block.$$;\n\n        if (children) {\n          children.forEach(beforeLeave);\n        }\n\n        if (mixins) {\n          mixins.forEach(beforeLeave);\n        }\n\n        if (block.beforeLeaveRoute) {\n          try {\n            block.beforeLeaveRoute();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeLeave:`, err);\n          }\n        }\n      });\n\n      routeLoaded = false;\n    }\n  };\n}\n\nfunction subscribe(name, callback) {\n  subscribers[name] = callback;\n\n  return () => {\n    delete subscribers[name];\n  };\n}\n\nfunction forward(url, push) {\n  changeHistory(url, push);\n  changeRoute();\n}\n\nfunction changeRoute() {\n  const route = findRouteByURL();\n\n  if (route) {\n    ({\n      route: currentRoute,\n      ...currentRouteParams\n    } = route);\n    assign(currentRouteParams, {\n      name: currentRoute.name,\n      host: location.host,\n      hostname: location.hostname,\n      href: location.href,\n      origin: location.origin,\n      pathname: location.pathname,\n      port: location.port,\n      protocol: location.protocol,\n      search: location.search\n    });\n  } else {\n    if (redirectRoute) {\n      const {\n        url,\n        encodeParams,\n        encodeQuery\n      } = RedirectRoute;\n\n      return forward(constructURL('', url, {}, {}, '', {\n        params: encodeParams,\n        query: encodeQuery\n      }), redirectRouteIsNeededToPush);\n    }\n\n    currentRoute = null;\n    currentRouteParams = null;\n  }\n\n  const routesToLeave = new Arr([]);\n  const routesToLoad = new Arr([]);\n  let parent;\n\n  while (currentRoutes.length && !parent) {\n    const route = currentRoutes.pop();\n\n    if (route.children.includes(currentRoute)) {\n      currentRoutes.push(route);\n      parent = route;\n    } else {\n      routesToLeave.push(route);\n    }\n  }\n\n  if (currentRoute) {\n    let currentParent = currentRoute;\n\n    while (currentParent !== parent && currentParent !== baseRoute) {\n      routesToLoad.unshift(currentParent);\n      currentParent = currentParent.parent;\n    }\n\n    currentRoutes.push(...routesToLoad.$);\n  }\n\n  routesToLeave.forEach(({ name }) => {\n    if (subscribers[name]) {\n      subscribers[name]('leave');\n    }\n  });\n  currentRoutes.forEach((route) => {\n    const { name } = route;\n\n    if (subscribers[name]) {\n      subscribers[name](\n        routesToLoad.includes(route)\n          ? 'load'\n          : 'update'\n      );\n    }\n  });\n}\n\nfunction findRouteByURL() {\n  const pathname = location.pathname || '/';\n  const search = location.search || '';\n  let urlParams;\n\n  Routes.some((route) => {\n    if (route.abstract) {\n      return;\n    }\n\n    const {\n      url: routeURL,\n      validatePath,\n      params,\n      query: requiredQuery,\n      decodeParams,\n      decodeQuery\n    } = route;\n    const resolved = resolveURL(decodeQuery);\n    const query = new Super(resolved.query);\n    const eventualParams = {};\n    const match = (\n      (pathname.replace(/\\/$/, '') || '/') +\n      (isRegExp(routeURL) ? search : '')\n    ).match(validatePath);\n\n    if (!match) {\n      return;\n    }\n\n    /* eslint guard-for-in: 0 */\n    for (const param in requiredQuery) {\n      if (!query.hasOwn(param) || !requiredQuery[param].test(query.$[param])) {\n        return;\n      }\n    }\n\n    match.shift();\n\n    for (const param in params) {\n      eventualParams[param] = decode(match[params[param]], decodeParams);\n    }\n\n    urlParams = {\n      route,\n      params: eventualParams,\n      query: query.$,\n      hash: resolved.hash\n    };\n\n    return true;\n  });\n\n  if (urlParams) {\n    return urlParams;\n  }\n\n  if (!defaultRoute) {\n    return;\n  }\n\n  return {\n    route: DefaultRoute,\n    params: {},\n    ...resolveURL(DefaultRoute.decodeQuery)\n  };\n}\n\nfunction decode(string, decodeParams) {\n  return decodeParams\n    ? decodeURIComponent(string)\n    : string;\n}\n\nfunction changeHistory(url, push) {\n  try {\n    history[push ? 'pushState' : 'replaceState'](null, null, url);\n    pushed = true;\n  } catch (err) {\n    location.href = url;\n  }\n}\n\nfunction resolveParameter(param, nameErrorName, valueErrorName) {\n  const nameMatch = param.match(/^[a-z_$]+/i);\n\n  if (!nameMatch) {\n    throw new Error(nameErrorName);\n  }\n\n  const name = nameMatch[0];\n  const value = param.slice(name.length);\n  let regexp;\n\n  if (value && (value.indexOf('(') || value.indexOf(')') !== value.length - 1)) {\n    throw new Error(valueErrorName);\n  }\n\n  if (value) {\n    regexp = new RegExp(value.slice(1, -1));\n  }\n\n  return {\n    name,\n    regexp\n  };\n}\n\nfunction buildURL(name, options = {}) {\n  const { value: route } = Routes.find(({ name: n }) => n === name) || {};\n\n  if (!route) {\n    throw new Error(`There are no routes with name \"${ name }\"! (at router.buildURL)`);\n  }\n\n  const {\n    url,\n    encodeParams,\n    encodeQuery\n  } = route;\n\n  if (isRegExp(url)) {\n    throw new Error('URL can be built only from the string URLs! (at router.buildURL)');\n  }\n\n  const {\n    params = {},\n    query = {},\n    hash = ''\n  } = options;\n\n  return constructURL('', url, params, query, hash, {\n    params: encodeParams,\n    query: encodeQuery\n  });\n}\n\nfunction go(name, options) {\n  forward(buildURL(name, options), true);\n}\n\nfunction goToURL(url) {\n  forward(url, true);\n}\n\nfunction pushURL(url) {\n  changeHistory(url, true);\n}\n\nfunction redirect(name, options) {\n  forward(buildURL(name, options));\n}\n\nfunction redirectToURL(url) {\n  forward(url);\n}\n\nfunction replaceURL(url) {\n  changeHistory(url);\n}\n\nexport { makeRoute, router };\n","/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n","/**\n * @module constants/appliedRegExps\n * @private\n * @description Exports different types of syntax for {@link Elem#apply}.\n */\n\n/**\n * @callback matchAppliedExprCallback\n * @param {Elem} elem - D-elem of an element to apply expression to.\n * @param {String} string - Matched applied name.\n * @param {String} arg - Argument within the parentheses.\n */\n\n/**\n * @type {Object.<String, matchAppliedExprCallback|Object.<String, matchAppliedExprCallback>>}\n * @description Object of different types of syntax.\n */\n\nexport const appliedRegExps = {\n  '#'(elem, id) {\n    elem.id(id);\n  },\n  '.'(elem, cls) {\n    elem.addClass(cls);\n  },\n  $(elem, attr, value) {\n    elem.attr(attr, value);\n  },\n  '@'(elem, prop, value) {\n    elem.css(prop, value);\n  },\n  '&'(elem, name, html) {\n    elem.html(html);\n  },\n  '*'(elem, name, text) {\n    elem.text(text);\n  },\n  '-': {\n    '.'(elem, cls) {\n      elem.removeClass(cls);\n    },\n    $(elem, attr) {\n      elem.removeAttr(attr);\n    },\n    '@'(elem, prop) {\n      elem.removeCSS(prop);\n    }\n  }\n};\n","/**\n * @module constants/elements\n * @private\n * @description Exports different canvas methods for {@link Elem} for creating html-elements.\n */\n\n/**\n * @const\n * @type {String[]}\n */\nexport const canvasGetMethods = [\n  /**\n   * @member {Function} Elem#createImageData\n   * @type {Function}\n   * @param {...*} args\n   * @returns {ImageData|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createImageData\n   */\n  'createImageData',\n\n  /**\n   * @member {Function} Elem#createLinearGradient\n   * @type {Function}\n   * @param {...*} args\n   * @returns {CanvasGradient|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createLinearGradient\n   */\n  'createLinearGradient',\n\n  /**\n   * @member {Function} Elem#createPattern\n   * @type {Function}\n   * @param {...*} args\n   * @returns {CanvasPattern|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createPattern\n   */\n  'createPattern',\n\n  /**\n   * @member {Function} Elem#createRadialGradient\n   * @type {Function}\n   * @param {...*} args\n   * @returns {CanvasGradient|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createRadialGradient\n   */\n  'createRadialGradient',\n\n  /**\n   * @member {Function} Elem#getImageData\n   * @type {Function}\n   * @param {...*} args\n   * @returns {ImageData|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getImageData\n   */\n  'getImageData',\n\n  /**\n   * @member {Function} Elem#getLineDash\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Number[]|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getLineDash\n   */\n  'getLineDash',\n\n  /**\n   * @member {Function} Elem#isPointInPath\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Boolean|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInPath\n   */\n  'isPointInPath',\n\n  /**\n   * @member {Function} Elem#isPointInStroke\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Boolean|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInStroke\n   */\n  'isPointInStroke',\n\n  /**\n   * @member {Function} Elem#measureText\n   * @type {Function}\n   * @param {...*} args\n   * @returns {TextMetrics|void}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/measureText\n   */\n  'measureText'\n];\n\nexport const canvasRestMethods = [\n  /**\n   * @member {Function} Elem#arc\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arc\n   */\n  'arc',\n\n  /**\n   * @member {Function} Elem#arcTo\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arcTo\n   */\n  'arcTo',\n\n  /**\n   * @member {Function} Elem#beginPath\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/beginPath\n   */\n  'beginPath',\n\n  /**\n   * @member {Function} Elem#bezierCurveTo\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo\n   */\n  'bezierCurveTo',\n\n  /**\n   * @member {Function} Elem#clearRect\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clearRect\n   */\n  'clearRect',\n\n  /**\n   * @member {Function} Elem#clip\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clip\n   */\n  'clip',\n\n  /**\n   * @member {Function} Elem#closePath\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/closePath\n   */\n  'closePath',\n\n  /**\n   * @member {Function} Elem#drawFocusIfNeeded\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawFocusIfNeeded\n   */\n  'drawFocusIfNeeded',\n\n  /**\n   * @member {Function} Elem#drawImage\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawImage\n   */\n  'drawImage',\n\n  /**\n   * @member {Function} Elem#ellipse\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/ellipse\n   */\n  'ellipse',\n\n  /**\n   * @member {Function} Elem#fill\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fill\n   */\n  'fill',\n\n  /**\n   * @member {Function} Elem#fillRect\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillRect\n   */\n  'fillRect',\n\n  /**\n   * @member {Function} Elem#fillText\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillText\n   */\n  'fillText',\n\n  /**\n   * @member {Function} Elem#lineTo\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineTo\n   */\n  'lineTo',\n\n  /**\n   * @member {Function} Elem#moveTo\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/moveTo\n   */\n  'moveTo',\n\n  /**\n   * @member {Function} Elem#putImageData\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/putImageData\n   */\n  'putImageData',\n\n  /**\n   * @member {Function} Elem#quadraticCurveTo\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/quadraticCurveTo\n   */\n  'quadraticCurveTo',\n\n  /**\n   * @member {Function} Elem#rect\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rect\n   */\n  'rect',\n\n  /**\n   * @member {Function} Elem#resetTransform\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/resetTransform\n   */\n  'resetTransform',\n\n  /**\n   * @member {Function} Elem#restore\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/restore\n   */\n  'restore',\n\n  /**\n   * @member {Function} Elem#rotate\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rotate\n   */\n  'rotate',\n\n  /**\n   * @member {Function} Elem#save\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/save\n   */\n  'save',\n\n  /**\n   * @member {Function} Elem#scale\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/scale\n   */\n  'scale',\n\n  /**\n   * @member {Function} Elem#setLineDash\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setLineDash\n   */\n  'setLineDash',\n\n  /**\n   * @member {Function} Elem#setTransform\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setTransform\n   */\n  'setTransform',\n\n  /**\n   * @member {Function} Elem#stroke\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/stroke\n   */\n  'stroke',\n\n  /**\n   * @member {Function} Elem#strokeRect\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeRect\n   */\n  'strokeRect',\n\n  /**\n   * @member {Function} Elem#strokeText\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeText\n   */\n  'strokeText',\n\n  /**\n   * @member {Function} Elem#transform\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/transform\n   */\n  'transform',\n\n  /**\n   * @member {Function} Elem#translate\n   * @type {Function}\n   * @param {...*} args\n   * @returns {Elem}\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/translate\n   */\n  'translate'\n];\n","/**\n * @module constants/constructors\n * @private\n * @description Exports constructors levels.\n */\n\n/**\n * @const\n * @type {Array[]}\n */\nexport const constructors = [\n  [],\n  [],\n  []\n];\n","/**\n * @module constants/elements\n * @private\n * @description Exports methods for {@link Elem} for creating html-elements.\n */\n\n/**\n * @const\n * @type {String[]}\n */\nexport const htmlElements = [\n  /**\n   * @member {Function} Elem#a\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'a',\n\n  /**\n   * @member {Function} Elem#abbr\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'abbr',\n\n  /**\n   * @member {Function} Elem#address\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'address',\n\n  /**\n   * @member {Function} Elem#area\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'area',\n\n  /**\n   * @member {Function} Elem#article\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'article',\n\n  /**\n   * @member {Function} Elem#audio\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'audio',\n\n  /**\n   * @member {Function} Elem#b\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'b',\n\n  /**\n   * @member {Function} Elem#base\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'base',\n\n  /**\n   * @member {Function} Elem#bdi\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'bdi',\n\n  /**\n   * @member {Function} Elem#bdo\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'bdo',\n\n  /**\n   * @member {Function} Elem#blockquote\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'blockquote',\n\n  /**\n   * @member {Function} Elem#body\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'body',\n\n  /**\n   * @member {Function} Elem#br\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'br',\n\n  /**\n   * @member {Function} Elem#button\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'button',\n\n  /**\n   * @member {Function} Elem#canvas\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'canvas',\n\n  /**\n   * @member {Function} Elem#caption\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'caption',\n\n  /**\n   * @member {Function} Elem#cite\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'cite',\n\n  /**\n   * @member {Function} Elem#code\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'code',\n\n  /**\n   * @member {Function} Elem#col\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'col',\n\n  /**\n   * @member {Function} Elem#colgroup\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'colgroup',\n\n  /**\n   * @member {Function} Elem#content\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'content',\n\n  /**\n   * @member {Function} Elem#datalist\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'datalist',\n\n  /**\n   * @member {Function} Elem#dd\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'dd',\n\n  /**\n   * @member {Function} Elem#del\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'del',\n\n  /**\n   * @member {Function} Elem#details\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'details',\n\n  /**\n   * @member {Function} Elem#dfn\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'dfn',\n\n  /**\n   * @member {Function} Elem#dialog\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'dialog',\n\n  /**\n   * @member {Function} Elem#div\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'div',\n\n  /**\n   * @member {Function} Elem#dl\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'dl',\n\n  /**\n   * @member {Function} Elem#dt\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'dt',\n\n  /**\n   * @member {Function} Elem#element\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'element',\n\n  /**\n   * @member {Function} Elem#em\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'em',\n\n  /**\n   * @member {Function} Elem#embed\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'embed',\n\n  /**\n   * @member {Function} Elem#fieldset\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'fieldset',\n\n  /**\n   * @member {Function} Elem#figcaption\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'figcaption',\n\n  /**\n   * @member {Function} Elem#figure\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'figure',\n\n  /**\n   * @member {Function} Elem#footer\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'footer',\n\n  /**\n   * @member {Function} Elem#form\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'form',\n\n  /**\n   * @member {Function} Elem#h1\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'h1',\n\n  /**\n   * @member {Function} Elem#h2\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'h2',\n\n  /**\n   * @member {Function} Elem#h3\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'h3',\n\n  /**\n   * @member {Function} Elem#h4\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'h4',\n\n  /**\n   * @member {Function} Elem#h5\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'h5',\n\n  /**\n   * @member {Function} Elem#h6\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'h6',\n\n  /**\n   * @member {Function} Elem#head\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'head',\n\n  /**\n   * @member {Function} Elem#header\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'header',\n\n  /**\n   * @member {Function} Elem#hgroup\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'hgroup',\n\n  /**\n   * @member {Function} Elem#hr\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'hr',\n\n  /**\n   * @member {Function} Elem#i\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'i',\n\n  /**\n   * @member {Function} Elem#iframe\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'iframe',\n\n  /**\n   * @member {Function} Elem#img\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'img',\n\n  /**\n   * @member {Function} Elem#input\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'input',\n\n  /**\n   * @member {Function} Elem#ins\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'ins',\n\n  /**\n   * @member {Function} Elem#kbd\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'kbd',\n\n  /**\n   * @member {Function} Elem#label\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'label',\n\n  /**\n   * @member {Function} Elem#legend\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'legend',\n\n  /**\n   * @member {Function} Elem#li\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'li',\n\n  /**\n   * @member {Function} Elem#link\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'link',\n\n  /**\n   * @member {Function} Elem#main\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'main',\n\n  /**\n   * @member {Function} Elem#mark\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'mark',\n\n  /**\n   * @member {Function} Elem#menu\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'menu',\n\n  /**\n   * @member {Function} Elem#menuitem\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'menuitem',\n\n  /**\n   * @member {Function} Elem#meta\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'meta',\n\n  /**\n   * @member {Function} Elem#meter\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'meter',\n\n  /**\n   * @member {Function} Elem#nav\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'nav',\n\n  /**\n   * @member {Function} Elem#noscript\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'noscript',\n\n  /**\n   * @member {Function} Elem#ol\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'ol',\n\n  /**\n   * @member {Function} Elem#optgroup\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'optgroup',\n\n  /**\n   * @member {Function} Elem#option\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'option',\n\n  /**\n   * @member {Function} Elem#output\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'output',\n\n  /**\n   * @member {Function} Elem#p\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'p',\n\n  /**\n   * @member {Function} Elem#param\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'param',\n\n  /**\n   * @member {Function} Elem#pre\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'pre',\n\n  /**\n   * @member {Function} Elem#progress\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'progress',\n\n  /**\n   * @member {Function} Elem#q\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'q',\n\n  /**\n   * @member {Function} Elem#rp\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'rp',\n\n  /**\n   * @member {Function} Elem#rt\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'rt',\n\n  /**\n   * @member {Function} Elem#rtc\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'rtc',\n\n  /**\n   * @member {Function} Elem#ruby\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'ruby',\n\n  /**\n   * @member {Function} Elem#s\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  's',\n\n  /**\n   * @member {Function} Elem#samp\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'samp',\n\n  /**\n   * @member {Function} Elem#script\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'script',\n\n  /**\n   * @member {Function} Elem#section\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'section',\n\n  /**\n   * @member {Function} Elem#select\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'select',\n\n  /**\n   * @member {Function} Elem#shadow\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'shadow',\n\n  /**\n   * @member {Function} Elem#small\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'small',\n\n  /**\n   * @member {Function} Elem#source\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'source',\n\n  /**\n   * @member {Function} Elem#span\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'span',\n\n  /**\n   * @member {Function} Elem#strong\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'strong',\n\n  /**\n   * @member {Function} Elem#style\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'style',\n\n  /**\n   * @member {Function} Elem#sub\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'sub',\n\n  /**\n   * @member {Function} Elem#summary\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'summary',\n\n  /**\n   * @member {Function} Elem#sup\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'sup',\n\n  /**\n   * @member {Function} Elem#table\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'table',\n\n  /**\n   * @member {Function} Elem#tbody\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'tbody',\n\n  /**\n   * @member {Function} Elem#td\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'td',\n\n  /**\n   * @member {Function} Elem#template\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'template',\n\n  /**\n   * @member {Function} Elem#textarea\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'textarea',\n\n  /**\n   * @member {Function} Elem#tfoot\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'tfoot',\n\n  /**\n   * @member {Function} Elem#th\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'th',\n\n  /**\n   * @member {Function} Elem#thead\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'thead',\n\n  /**\n   * @member {Function} Elem#time\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'time',\n\n  /**\n   * @member {Function} Elem#title\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'title',\n\n  /**\n   * @member {Function} Elem#tr\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'tr',\n\n  /**\n   * @member {Function} Elem#track\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'track',\n\n  /**\n   * @member {Function} Elem#u\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'u',\n\n  /**\n   * @member {Function} Elem#ul\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'ul',\n\n  /**\n   * @member {Function} Elem#var\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'var',\n\n  /**\n   * @member {Function} Elem#video\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'video',\n\n  /**\n   * @member {Function} Elem#wbr\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'wbr'\n];\n\nexport const svgElements = [\n  /**\n   * @member {Function} Elem#altGlyph\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'altGlyph',\n\n  /**\n   * @member {Function} Elem#altGlyphDef\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'altGlyphDef',\n\n  /**\n   * @member {Function} Elem#altGlyphItem\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'altGlyphItem',\n\n  /**\n   * @member {Function} Elem#animate\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'animate',\n\n  /**\n   * @member {Function} Elem#animateColor\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'animateColor',\n\n  /**\n   * @member {Function} Elem#animateMotion\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'animateMotion',\n\n  /**\n   * @member {Function} Elem#animateTransform\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'animateTransform',\n\n  /**\n   * @member {Function} Elem#circle\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'circle',\n\n  /**\n   * @member {Function} Elem#clipPath\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'clipPath',\n\n  /**\n   * @member {Function} Elem#colorProfile\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'color-profile',\n\n  /**\n   * @member {Function} Elem#cursor\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'cursor',\n\n  /**\n   * @member {Function} Elem#defs\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'defs',\n\n  /**\n   * @member {Function} Elem#desc\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'desc',\n\n  /**\n   * @member {Function} Elem#discard\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'discard',\n\n  /**\n   * @member {Function} Elem#ellipse\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'ellipse',\n\n  /**\n   * @member {Function} Elem#feBlend\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feBlend',\n\n  /**\n   * @member {Function} Elem#feColorMatrix\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feColorMatrix',\n\n  /**\n   * @member {Function} Elem#feComponentTransfer\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feComponentTransfer',\n\n  /**\n   * @member {Function} Elem#feComposite\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feComposite',\n\n  /**\n   * @member {Function} Elem#feConvolveMatrix\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feConvolveMatrix',\n\n  /**\n   * @member {Function} Elem#feDiffuseLighting\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feDiffuseLighting',\n\n  /**\n   * @member {Function} Elem#feDisplacementMap\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feDisplacementMap',\n\n  /**\n   * @member {Function} Elem#feDistantLight\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feDistantLight',\n\n  /**\n   * @member {Function} Elem#feDropShadow\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feDropShadow',\n\n  /**\n   * @member {Function} Elem#feFlood\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feFlood',\n\n  /**\n   * @member {Function} Elem#feFuncA\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feFuncA',\n\n  /**\n   * @member {Function} Elem#feFuncB\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feFuncB',\n\n  /**\n   * @member {Function} Elem#feFuncG\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feFuncG',\n\n  /**\n   * @member {Function} Elem#feFuncR\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feFuncR',\n\n  /**\n   * @member {Function} Elem#feGaussianBlur\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feGaussianBlur',\n\n  /**\n   * @member {Function} Elem#feImage\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feImage',\n\n  /**\n   * @member {Function} Elem#feMerge\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feMerge',\n\n  /**\n   * @member {Function} Elem#feMergeNode\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feMergeNode',\n\n  /**\n   * @member {Function} Elem#feMorphology\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feMorphology',\n\n  /**\n   * @member {Function} Elem#feOffset\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feOffset',\n\n  /**\n   * @member {Function} Elem#fePointLight\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'fePointLight',\n\n  /**\n   * @member {Function} Elem#feSpecularLighting\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feSpecularLighting',\n\n  /**\n   * @member {Function} Elem#feSpotLight\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feSpotLight',\n\n  /**\n   * @member {Function} Elem#feTile\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feTile',\n\n  /**\n   * @member {Function} Elem#feTurbulence\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'feTurbulence',\n\n  /**\n   * @member {Function} Elem#font\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'font',\n\n  /**\n   * @member {Function} Elem#fontFace\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'font-face',\n\n  /**\n   * @member {Function} Elem#fontFaceFormat\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'font-face-format',\n\n  /**\n   * @member {Function} Elem#fontFaceName\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'font-face-name',\n\n  /**\n   * @member {Function} Elem#fontFaceSrc\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'font-face-src',\n\n  /**\n   * @member {Function} Elem#fontFaceUri\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'font-face-uri',\n\n  /**\n   * @member {Function} Elem#foreignObject\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'foreignObject',\n\n  /**\n   * @member {Function} Elem#g\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'g',\n\n  /**\n   * @member {Function} Elem#glyph\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'glyph',\n\n  /**\n   * @member {Function} Elem#glyphRef\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'glyphRef',\n\n  /**\n   * @member {Function} Elem#hatch\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'hatch',\n\n  /**\n   * @member {Function} Elem#hatchpath\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'hatchpath',\n\n  /**\n   * @member {Function} Elem#hkern\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'hkern',\n\n  /**\n   * @member {Function} Elem#image\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'image',\n\n  /**\n   * @member {Function} Elem#line\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'line',\n\n  /**\n   * @member {Function} Elem#linearGradient\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'linearGradient',\n\n  /**\n   * @member {Function} Elem#marker\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'marker',\n\n  /**\n   * @member {Function} Elem#mask\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'mask',\n\n  /**\n   * @member {Function} Elem#mesh\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'mesh',\n\n  /**\n   * @member {Function} Elem#meshgradient\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'meshgradient',\n\n  /**\n   * @member {Function} Elem#meshpatch\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'meshpatch',\n\n  /**\n   * @member {Function} Elem#meshrow\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'meshrow',\n\n  /**\n   * @member {Function} Elem#metadata\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'metadata',\n\n  /**\n   * @member {Function} Elem#missingGlyph\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'missing-glyph',\n\n  /**\n   * @member {Function} Elem#mpath\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'mpath',\n\n  /**\n   * @member {Function} Elem#path\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'path',\n\n  /**\n   * @member {Function} Elem#pattern\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'pattern',\n\n  /**\n   * @member {Function} Elem#polygon\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'polygon',\n\n  /**\n   * @member {Function} Elem#polyline\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'polyline',\n\n  /**\n   * @member {Function} Elem#radialGradient\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'radialGradient',\n\n  /**\n   * @member {Function} Elem#rect\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'rect',\n\n  /**\n   * @member {Function} Elem#set\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'set',\n\n  /**\n   * @member {Function} Elem#solidcolor\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'solidcolor',\n\n  /**\n   * @member {Function} Elem#stop\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'stop',\n\n  /**\n   * @member {Function} Elem#style\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'style',\n\n  /**\n   * @member {Function} Elem#svg\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'svg',\n\n  /**\n   * @member {Function} Elem#switch\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'switch',\n\n  /**\n   * @member {Function} Elem#symbol\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'symbol',\n\n  /**\n   * @member {Function} Elem#textPath\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'textPath',\n\n  /**\n   * @member {Function} Elem#tref\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'tref',\n\n  /**\n   * @member {Function} Elem#tspan\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'tspan',\n\n  /**\n   * @member {Function} Elem#unknown\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'unknown',\n\n  /**\n   * @member {Function} Elem#use\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'use',\n\n  /**\n   * @member {Function} Elem#view\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'view',\n\n  /**\n   * @member {Function} Elem#vkern\n   * @type {Function}\n   * @param {...String} appliedExpressions\n   * @returns {Elem}\n   */\n  'vkern'\n];\n\nexport const voidElements = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n\n  'path',\n  'circle',\n  'ellipse',\n  'line',\n  'rect',\n  'use',\n  'stop',\n  'polyline',\n  'polygon'\n];\n","export const htmlAllowedTagSymbols = '[a-z][a-z\\\\d\\\\-_.:!@#\\\\$%\\\\^&*()\\\\[\\\\]{}\\\\\\\\=\\'\"]*';\nexport const htmlAllowedAttrSymbols = '[^\\\\u0000-\\\\u0020\\\\s\"\\'>/=]+';\n","/**\n * @module constants/regexpSpecialCharacters\n * @private\n * @description Exports special characters for RegExp.\n */\n\n/**\n * @const\n * @name module:constants/regexpSpecialCharacters~regexpSpecialCharacters\n * @type {String[]}\n */\nexport const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\n","/**\n * @module constants/validateCheckExpressions\n * @private\n * @description Exports different types of validate expressions for {@link module:helpers/validate}.\n */\n\nimport * as methods from '../helpers/checkTypes';\n\n/**\n * @callback checkValidityCallback\n * @private\n * @param {*} value - Value to check.\n */\n\n/**\n * @typedef {Object} validateExpr\n * @private\n * @property {String} text - Text of the thrown error.\n * @property {Error} error - Type of the thrown error.\n * @property {checkValidityCallback} check - Callback for checking value.\n */\n\n/**\n * @type {validateExpr[]}\n * @private\n * @description Object of different types of validation.\n */\nexport const validateCheckExpressions = {\n  '>0': {\n    check: (n) => n > 0,\n    text: '$n argument must be positive!',\n    error: RangeError\n  },\n  '>=0': {\n    check: (n) => n >= 0,\n    text: '$n argument must be non-negative!',\n    error: RangeError\n  },\n  '<0': {\n    check: (n) => n < 0,\n    text: '$n argument must be negative!',\n    error: RangeError\n  },\n  '<=0': {\n    check: (n) => n <= 0,\n    text: '$n argument must be non-positive!',\n    error: RangeError\n  },\n  '!!': {\n    check: (v) => !methods.isNil(v),\n    text: '$n argument must be not null or undefined!',\n    error: TypeError\n  },\n  array: {\n    check: methods.isArray,\n    text: '$n argument must be an array!',\n    error: TypeError\n  },\n  'array||!': {\n    check: (a) => methods.isArray(a) || methods.isNil(a),\n    text: '$n argument must be an array, or undefined, or null!',\n    error: TypeError\n  },\n  arrayLike: {\n    check: methods.isArrayLike,\n    text: '$n argument must be array-like!',\n    error: TypeError\n  },\n  'arrayLike||!': {\n    check: (a) => methods.isArrayLike(a) || methods.isNil(a),\n    text: '$n argument must be array-like, or undefined, or null!',\n    error: TypeError\n  },\n  date: {\n    check: methods.isDate,\n    text: '$n argument must be a date!',\n    error: TypeError\n  },\n  'date||!': {\n    check: (d) => methods.isDate(d) || methods.isNil(d),\n    text: '$n argument must be a date, or undefined, or null!',\n    error: TypeError\n  },\n  dateLike: {\n    check: methods.isDateLike,\n    text: '$n argument must be date-like!',\n    error: TypeError\n  },\n  'dateLike||!': {\n    check: (d) => methods.isDateLike(d) || methods.isNil(d),\n    text: '$n argument must be date-like, or undefined, or null!',\n    error: TypeError\n  },\n  function: {\n    check: methods.isFunction,\n    text: '$n argument must be a function!',\n    error: TypeError\n  },\n  'function||!': {\n    check: (f) => methods.isFunction(f) || methods.isNil(f),\n    text: '$n argument must be a function, or undefined, or null!',\n    error: TypeError\n  },\n  int: {\n    check: methods.isInteger,\n    text: '$n argument must be an integer!',\n    error: TypeError\n  },\n  'int||!': {\n    check: (i) => methods.isInteger(i) || methods.isNil(i),\n    text: '$n argument must be an integer, or undefined, or null!',\n    error: TypeError\n  },\n  intLike: {\n    check: methods.isIntegerLike,\n    text: '$n argument must be integer-like!',\n    error: TypeError\n  },\n  'intLike||!': {\n    check: (i) => methods.isIntegerLike(i) || methods.isNil(i),\n    text: '$n argument must be integer-like, or undefined, or null!',\n    error: TypeError\n  },\n  number: {\n    check: methods.isNumber,\n    text: '$n argument must be a number!',\n    error: TypeError\n  },\n  'number||!': {\n    check: (n) => methods.isNumber(n) || methods.isNil(n),\n    text: '$n argument must be a number, or undefined, or null!',\n    error: TypeError\n  },\n  numberLike: {\n    check: methods.isNumberLike,\n    text: '$n argument must be number-like!',\n    error: TypeError\n  },\n  'numberLike||!': {\n    check: (n) => methods.isNumberLike(n) || methods.isNil(n),\n    text: '$n argument must be number-like, or undefined, or null!',\n    error: TypeError\n  },\n  object: {\n    check: methods.isObject,\n    text: '$n argument must be an object!',\n    error: TypeError\n  },\n  'object||!': {\n    check: (o) => methods.isObject(o) || methods.isNil(o),\n    text: '$n argument must be an object, or undefined, or null!',\n    error: TypeError\n  },\n  regexp: {\n    check: methods.isRegExp,\n    text: '$n argument must be a regular expression!',\n    error: TypeError\n  },\n  'regexp||!': {\n    check: (r) => methods.isRegExp(r) || methods.isNil(r),\n    text: '$n argument must be a regular expression, or undefined, or null!',\n    error: TypeError\n  },\n  string: {\n    check: methods.isString,\n    text: '$n argument must be a string!',\n    error: TypeError\n  },\n  'string||!': {\n    check: (s) => methods.isString(s) || methods.isNil(s),\n    text: '$n argument must be a string, or undefined, or null!',\n    error: TypeError\n  }\n};\n","/**\n * @module helpers/Symbol\n * @private\n * @description Exports Symbol class.\n */\n\nexport const Symbol = global.Symbol || {\n  toStringTag: 'Symbol.toStringTag',\n  iterator: Math.random().toString(36)\n};\n","/**\n * @module Promise\n * @private\n * @mixin\n * @description Exports Promise class.\n */\n\nimport { isFunction, defineProperties, Symbol } from './helpers';\n\n/**\n * @callback onFulfilledOrRejected\n * @public\n * @param {*} value - Promise value.\n * @param {Boolean} success - If the previous promise is fulfilled it's true and false if rejected.\n */\n\n/**\n * @callback onRejected\n * @public\n * @param {Error|*} err - Promise error.\n */\n\n/**\n * @callback onFulfilled\n * @public\n * @param {*} value - Promise value.\n */\n\nconst secret = {};\nconst iterator = Symbol.iterator;\n\n/**\n * @class Promise\n * @public\n * @param {Function} executor - Function that takes two arguments: resolve and reject functions.\n * Call the resolve function when you need to fulfill the promise and call the reject one\n * when you need to reject it.\n * @returns {Promise} Instance of Promise.\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\n * @description Class with almost identical API to\n * [ES6 Promise]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.\n * There is a couple differences: set Promise.onError to a function with which you want to\n * subscribe to a promise error and set Promise.onUnhandledRejection to a function with which\n * you want to subscribe to an unhandled error\n * (defaults to console.error.bind(console, '%s %o', 'Uncaught (in promise)')).\n */\nclass Promise {\n  static onError = null;\n  static onUnhandledRejection = console.error.bind(console, '%s %o', 'Uncaught (in promise)');\n\n  constructor(executor) {\n    if (!isFunction(executor)) {\n      throw new TypeError(`Promise resolver ${ {}.toString.call(executor) } is not a function`);\n    }\n\n    let hiddenStatus;\n    let hiddenValue;\n\n    const\tonFulfill = [];\n    const onReject = [];\n    const realPromise = this;\n    const hiddenPromise = {\n      handled: false,\n      get status() {\n        return hiddenStatus;\n      },\n      set status(value) {\n        hiddenStatus = value;\n        realPromise.status = value;\n      },\n      get value() {\n        return hiddenValue;\n      },\n      set value(val) {\n        hiddenValue = val;\n        realPromise.value = val;\n      }\n    };\n\n    hiddenPromise.status = 'pending';\n    hiddenPromise.value = undefined;\n\n    /**\n     * @typedef {Object} hiddenPromise\n     * @private\n     * @property {Boolean|Object} handled - If the promise is handled or not.\n     * @property {'pending'|'fulfilled'|'rejected'} status - Status of the promise.\n     * @property {*} value - Value of the promise.\n     */\n\n    /**\n     * @member {Function} hiddenPromise#handle\n     * @private\n     * @param {('reject'|'resolve')} event - Type of the event to handle.\n     * @param {Function} handler - Handler itself.\n     * @param {Function} resolve - Resolve function.\n     * @param {Function} reject - Reject function.\n     * @param {Object} secret - Secret.\n     * @description Private method for handling promises.\n     */\n\n    /**\n     * @member {hiddenPromise} Promise#$$\n     * @protected\n     */\n    defineProperties(this.$$ = {}, {\n      'get/set handled': {\n        get() {\n          return hiddenPromise.handled;\n        },\n        set(key) {\n          if (key === secret) {\n            hiddenPromise.handled = true;\n          }\n        }\n      },\n      handle(status, f, resolve, reject, key) {\n        if (key === secret) {\n          const proxy = isFunction(f) ? (value) => {\n            try {\n              resolve(f(value));\n            } catch (err) {\n              reject(err);\n            }\n          } : null;\n\n          if (status === 'resolve') {\n            onFulfill.push(proxy || ((value) => resolve(value)));\n          } else if (status === 'reject') {\n            onReject.push(proxy || ((err) => reject(err)));\n          }\n        }\n      },\n      'get status'() {\n        return hiddenPromise.status;\n      },\n      'get value'() {\n        return hiddenPromise.value;\n      }\n    });\n\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n\n    function reject(err) {\n      if (hiddenPromise.status === 'pending') {\n        hiddenPromise.status = 'rejected';\n        hiddenPromise.value = err;\n\n        for (let i = 0, length = onReject.length; i < length; i++) {\n          hiddenPromise.handled = true;\n\n          onReject[i](err);\n        }\n\n        const {\n          onUnhandledRejection,\n          onError\n        } = Promise;\n\n        if (isFunction(onError)) {\n          onError(err);\n        }\n\n        setTimeout(() => {\n          if (!hiddenPromise.handled && isFunction(onUnhandledRejection)) {\n            onUnhandledRejection(err);\n          }\n        }, 1);\n      }\n    }\n\n    function resolve(value) {\n      if (hiddenPromise.status === 'pending') {\n        if (value && isFunction(value.then)) {\n          return value.then((value) => {\n            resolve(value);\n          }, (err) => {\n            reject(err);\n          });\n        }\n\n        hiddenPromise.status = 'fulfilled';\n        hiddenPromise.value = value;\n\n        for (let i = 0, length = onFulfill.length; i < length; i++) {\n          hiddenPromise.handled = true;\n\n          onFulfill[i](value);\n        }\n      }\n    }\n  }\n\n  /**\n   * @method Promise.all\n   * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises\n   * or any values.\n   * @returns {Promise} New instance of Promise.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\n   */\n  static all(iterable) {\n    const array = [];\n\n    let toResolve = 0;\n\n    if (iterable[iterator]) {\n      iterable = iterable[iterator]();\n\n      return new Promise((resolve, reject) => {\n        let next;\n        let i = 0;\n\n        while (!(next = iterable.next()).done) {\n          const promise = Promise.resolve(next.value);\n\n          toResolve++;\n\n          ((i) => {\n            promise.then((value) => {\n              toResolve--;\n              array[i] = value;\n\n              setTimeout(() => {\n                if (next.done && !toResolve) {\n                  resolve(array);\n                }\n              }, 1);\n            }, reject);\n          })(i++);\n        }\n\n        if (!i) {\n          return Promise.resolve([]);\n        }\n      });\n    }\n\n    const length = iterable.length;\n\n    if (!length) {\n      return Promise.resolve([]);\n    }\n\n    toResolve = length;\n\n    return new Promise((resolve, reject) => {\n      for (let i = 0; i < length; i++) {\n        const promise = Promise.resolve(iterable[i]);\n\n        promise.then((value) => {\n          toResolve--;\n          array[i] = value;\n\n          if (!toResolve) {\n            resolve(array);\n          }\n        }, reject);\n      }\n    });\n  }\n\n  /**\n   * @method Promise.race\n   * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises\n   * or any values.\n   * @returns {Promise} New instance of Promise.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\n   */\n  static race(iterable) {\n    if (iterable[iterator]) {\n      iterable = iterable[iterator]();\n\n      return new Promise((resolve, reject) => {\n        let next;\n\n        while (!(next = iterable.next()).done) {\n          next.value.then(resolve, reject);\n        }\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      for (let i = 0, length = iterable.length; i < length; i++) {\n        iterable[i].then(resolve, reject);\n      }\n    });\n  }\n\n  /**\n   * @method Promise.reject\n   * @param {*} value - Value to reject.\n   * @returns {Promise} New instance of Promise.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\n   */\n  static reject(value) {\n    return new Promise((resolve, reject) => {\n      reject(value);\n    });\n  }\n\n  /**\n   * @method Promise.resolve\n   * @param {Promise|Thenable|*} value - Promise, thenable or any value to resolve.\n   * @returns {Promise} New instance of Promise.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\n   */\n  static resolve(value) {\n    if (value && isFunction(value.then)) {\n      return value;\n    }\n\n    return new Promise((resolve) => {\n      resolve(value);\n    });\n  }\n\n  abort() {}\n\n  /**\n   * @method Promise#catch\n   * @param {onRejected} onRejected - onRejected callback.\n   * @returns {Promise} New instance of Promise.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\n   */\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * @method Promise#finally\n   * @public\n   * @param {onFulfilledOrRejected} onFulfilledOrRejected - onFulfilledOrRejected callback.\n   * @returns {Promise}\n   * @description Method for catching both fulfilled and rejected promises.\n   *\n   * @example\n   * spinner.show();\n   * fetchData()\n   *   .then((data) => {\n   *     // do something with data\n   *   })\n   *   .catch((err) => {\n   *     // handle error somehow\n   *   })\n   *   .finally(() => {\n   *     spinner.hide();\n   *   });\n   */\n  finally(onFulfilledOrRejected) {\n    const isFunc = isFunction(onFulfilledOrRejected);\n\n    return this.then((value) => (\n      Promise\n        .resolve(\n          isFunc\n            ? onFulfilledOrRejected(value, true)\n            : 0\n        )\n        .then(() => value)\n    ), (err) => (\n      Promise\n        .resolve(\n          isFunc\n            ? onFulfilledOrRejected(err, false)\n            : 0\n        )\n        .then(() => Promise.reject(err))\n    ));\n  }\n\n  /**\n   * @method Promise#then\n   * @param {onFulfilled} [onFulfilled] - onFulfilled callback.\n   * @param {onRejected} [onRejected] - onRejected callback.\n   * @returns {Promise} New instance of Promise.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n   */\n  then(onFulfilled, onRejected) {\n    const promise = this.$$;\n\n    if (promise.status === 'pending') {\n      return new Promise((resolve, reject) => {\n        promise.handle('reject', onRejected, resolve, reject, secret);\n        promise.handle('resolve', onFulfilled, resolve, reject, secret);\n      });\n    }\n\n    promise.handled = secret;\n\n    const { value } = promise;\n\n    let method;\n    let handler;\n\n    if (promise.status === 'fulfilled') {\n      method = 'resolve';\n      handler = onFulfilled;\n    } else {\n      method = 'reject';\n      handler = onRejected;\n    }\n\n    if (!isFunction(handler)) {\n      return Promise[method](value);\n    }\n\n    try {\n      return Promise.resolve(handler(value));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n}\n\ndefineProperties(Promise.prototype, {\n  [Symbol.toStringTag]: 'Promise'\n});\n\nexport { Promise };\n","/**\n * @module helpers/parseHeaders\n * @private\n * @description Exports parseHeaders method.\n */\n\nimport { Str } from '../Str';\nimport { iterate } from './iterate';\n\n/**\n * @function parseHeaders\n * @param {String} rawHeaders - Raw headers.\n * @returns {Object} Headers object\n * @description Function for parsing raw headers.\n */\nexport default (rawHeaders) => {\n  const headers = {};\n\n  iterate((rawHeaders || '').split('\\n'), (value) => {\n    const index = value.indexOf(':');\n    const key = new Str(value.substring(0, index))\n      .trim()\n      .toCamelCase().$;\n    const val = new Str(value.substring(index + 1)).trim().$;\n\n    if (key) {\n      headers[key] = (headers[key] ? `${ headers[key] }, ` : '') + val;\n    }\n  });\n\n  return headers;\n};\n","/**\n * @module helpers/transformData\n * @private\n * @description Exports transformData method.\n */\n\nimport { Arr } from '../Arr';\nimport { Super } from '../Super';\nimport { isObject, toStringTag } from './';\n\nconst notToTransform = new Arr(['FormData', 'File', 'Blob', 'ArrayBuffer', 'String', 'Number']);\nconst withoutBody = new Arr(['DELETE', 'GET', 'HEAD']);\n\n/**\n * @function transformData\n * @param {*} data - Data to transform\n * @param {String} method - HTTP method.\n * @param {Object} headers - Object with headers.\n * @returns {*} - Transformed data.\n */\nexport default (data, method, headers) => {\n  data = new Super(data).$;\n\n  if (withoutBody.indexOfStrict(method) !== -1) {\n    return null;\n  }\n\n  if (isObject(data) && notToTransform.indexOfStrict(toStringTag(data)) === -1) {\n    if (!headers.contentType) {\n      headers.contentType = ['application/json;charset=utf-8'];\n    }\n\n    return new Super(data).json();\n  }\n\n  return data;\n};\n","/**\n * @module helpers/resolveURL\n * @private\n * @description Exports Object.assign-like method.\n */\n\nimport { Str } from '../Str';\n\nconst { location } = global;\n\nexport default (decodeQuery) => {\n  const {\n    search: query,\n    hash\n  } = location;\n  const params = {\n    query: {},\n    hash: hash.replace(/^#/, '')\n  };\n\n  if (!query) {\n    return params;\n  }\n\n  new Str(query.replace(/^\\?/, ''))\n    .split('&')\n    .forEach((rawParam) => {\n      let [param, value = ''] = rawParam.split('=');\n\n      param = decodeQuery ? decodeURIComponent(param) : param;\n      value = decodeQuery ? decodeURIComponent(value) : value;\n\n      if (!/^[^[]+/.test(param)) {\n        return;\n      }\n\n      let paramName;\n      let paramObject = params.query;\n\n      new Str(param)\n        .match(/^[^[\\]]*|\\[[^[\\]]*]/g)\n        .forEach((name) => {\n          if (name.indexOf('[')) {\n            paramName = name;\n\n            return;\n          }\n\n          name = name.slice(1, -1);\n\n          paramObject = paramObject[paramName] = paramObject[paramName] || (name ? {} : []);\n          paramName = name || paramObject.length;\n        });\n\n      paramObject[paramName] = value;\n    });\n\n  return params;\n};\n","import * as statics from './lib/browser';\nimport { assign } from './lib/helpers/assign';\n\nconst { D } = statics;\n\nassign(D, statics);\n\ndelete D.D;\n\nglobal.D = D;\n"],"names":["toStringTag","object","toString","call","replace","isArray","value","isArrayLike","isFunction","length","isInteger","isBoolean","isDate","isDateLike","Date","isNaN","getTime","isElement","test","isFinite","isNumber","Number","Infinity","isIntegerLike","parseInt","isNull","isNil","isNumberLike","isObject","Object","isPlainObject","isPrimitive","proto","getPrototypeOf","constructor","isRegExp","isString","isSymbol","isUndefined","D","i","constructors","levelConstructors","k","len","cls","check","iterate","callback","array","iteratedKeys","iterated","key","hasOwnProperty","assign","target","objects","arguments","source","index","constructEvalFunction","code","original","func","Function","expression","err","Error","dynamicDefineProperties","properties","propertyGenerator","name","defineProperty","defineProperties","undefined","get","set","defineUsualProperties","defineFrozenProperties","toArray","createNewArray","push","validate","args","options","number","checker","validateCheckExpressions","error","text","numbers","char","alphabet","string","ranges","split","range","start","charCodeAt","end","String","fromCharCode","Alphabet","switcher","cases","mode","defaultValue","Switcher","when","condition","value1","value2","deepAssign","deepClone","clone","cloneSwitcher","deepEqual","o1","o2","strict","match","lastIndex","p1","p2","keys","deepEvery","n","tree","newTree","concat","deepFilter","nul","o","filtered","deepFind","result","deepForEach","deepForEachEntry","deepFreeze","freeze","deepMap","deepReduce","IV","deepSome","method","x","apply","noop","prop","self","rand","Math","random","floor","asc","y","Arr","blob","blobParts","BlobObject","Blob","trim","parseJSON","json","JSON","parse","dates","this","find","markup","elem","matches","rawTextSwitcher","Super","constructCloseTagRegExp","NODE_REGEX_SET","map","regex","returning","attrs","startMarkup","closeMatch","selfClosing","slice","TAG_OPEN_CLOSE","attr","ATTRIBUTE","min","NaN","tagName","RegExp","nearString","parseCharacterData","innerHTML","div","textContent","innerText","toFind","isElem","Elem","isWindow","isHTMLDocument","isDocumentFragment","isStyleRule","isCommentOrText","tag","getElem","$","emptyDiv","getName","nodeName","toLowerCase","addDwayneData","windowsDwayneData","some","element","getContext","selector","base","nativeDocument","querySelectorAll","parseHTML","html","collapseWhiteSpace","markupToJSON","template","doc","content","forEach","forEachNode","node","parent","children","parentNode","create","px","size","registerDBlock","Block","DBlock","$$","parentScope","parentParentScope","parentParentTemplate","parentTemplate","argsChildren","ownChildren","dBlockName","found","ParentScope","ParentTemplate","dBlocks","elems","registerDEach","createBlock","opts","item","itemName","indexName","_this","uid","watch","_this2","uids","parentElem","scope","UID","sortBy","$uids","newKeys","newUIDs","filterBy","sort","filter","evaluate","items","Item","remove","splice","prevBlock","block","shift","insertAfterIt","insertInStartOfIt","values","registerDElements","firstTime","mixins","watchersToRemove","child","mixin","removeContent","watchers","watcher","forDElements","indexOf","registerDIf","DIf","cond","if","newValue","Boolean","registerDItem","DItem","registerDSwitch","DSwitch","wasDefault","val","equals","registerDAttr","Mixin","removeAttr","registerDBind","off","on","join","registerDClass","classes","newClasses","removeClass","addClass","registerDElem","DElem","evaluateOnce","registerDHide","hide","show","registerDNode","DNode","registerDOn","DOn","registerDShow","registerDStyle","css","oldValue","removeCSS","registerDValidate","DValidate","validator","listenerSwitcher","validators","dwayneData","registerDValue","DValue","type","initialScopeValue","propSwitcher","currentValue","setProp","initialElemValue","getProp","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","e","offFormListener","closest","option","selected","setValueSwitcher","init","getValueSwitcher","parseJS","wholeString","curlyError","initialString","expected","variables","closingExpressions","spaceMatch","toConcat","matched","isEmptySpace","properType","properSymbol","symbol","firstSymbol","emptySpaceRegExp","templateString","arrowFunctionRegExp","vars","anyCommaEmptySpace","newFunctionVars","functionScope","variable","END_OF_FUNC_BODY","EXPRESSION","objectProperty","unaryOperatorRegExp","anyEmptySpaceRegExp","simpleExpressionRegExp","numberRegExp","stringRegExp","regexpRegExp","thisRegExp","variableRegExp","getVariable","operator","templateStringContentRegExp","anyEscapedExpressionRegExp","second","properEscapedRegExp","anyDoubleQuoteRegExp","anyNewLineRegExp","pop","propertyRegExp","keywordsRegExp","shorthandPropertyRegExp","closeFunctionBody","pointOperatorRegExp","operatorRegExp","closingBrace","noMatch","curlyIndex","expressionString","constructErrorInfo","last","wholeStringString","submitString","initApp","blocks","DwayneRootBlock","removeApp","registerBuiltIns","register","_html","transformJSExpressions","_variables","except","_match","constructMixinRegExp","parentBlock","svgNS","svg","localBlocks","ns","_blocks","localMixins","_mixins","dBlockMatch","dBlockArgs","dBlockChildren","dElementsName","blockInstance","currentAttrs","wasDRest","mixinDefaultOpts","isDRest","dRestRegExp","localAttrs","restAttrs","arg","transformRestAttrs","mixinMatch","createMixins","calculateAttrs","isParentBlock","insertAfter","addContent","into","Args","globals","locals","newName","transformDIfChildren","constructPrivateScope","scopeValues","privateScope","afterConstruct","afterRender","createMixin","dynamic","comment","evaluateAndWatch","afterUpdate","ifElse","exclude","initialValue","isDEach","excludeLocal","parsed","rest","isUID","usedVariables","curlyBracketRegExp","isInstanceOf","Class","Subclass","isPrototypeOf","prototype","removeWatchers","constructPublicScope","define","evalMode","getting","temp","changed","oldTempWatchers","onRemove","was","perm","watchForAllLocals","watchForAllGlobals","global","watchForAllArgs","calculateArgs","argsObject","$argsObject","propertyNames","transformRestArgs","eventualAttrs","localMatch","argsMatch","Str","s","attrsObject","nextType","nextDynamic","nextValue","prevType","prevValue","isDynamic","evaluated","buildMixin","firstValue","executeMixinWatchers","escapeRegExp","extendBlock","insertTemplates","templates","newTemplates","newVars","pushArray","round","digits","zeroes","zero","repeat","now","date","Dat","isAbsolute","url","absoluteURLRegexp","encode","isEncoded","encodeURIComponent","fetchBeforeMiddleware","config","baseURL","data","headers","params","query","METHOD","toUpperCase","constructURL","transformData","header","toCapitalCase","initRouter","initialized","Routes","redirectRoute","defaultRoute","RedirectRoute","route","parentName","ParentName","rootRoute","abstract","baseRoute","parentParams","parentQuery","path","relativeURL","relativePath","count","newPath","newURL","validatePath","location","href","initialURL","pushed","closestLink","hasAttr","preventDefault","makeRoute","callBeforeLoad","routeLoaded","wasRoute","beforeLoad","__routerInstance__","beforeLoadRoute","callBeforeLeave","beforeLeave","beforeLeaveRoute","routerOptions","root","fallbackTo","isDefault","default","warn","wasRoot","Route","unsubscribe","router","__isCurrentRoute__","currentRoutes","includes","__wasRouteActive__","currentRouteParams","subscribe","action","isCurrentRoute","subscribers","forward","changeRoute","findRouteByURL","currentRoute","host","hostname","origin","pathname","port","protocol","search","encodeParams","encodeQuery","redirectRouteIsNeededToPush","routesToLeave","routesToLoad","currentParent","unshift","urlParams","routeURL","requiredQuery","decodeParams","decodeQuery","resolved","resolveURL","eventualParams","param","hasOwn","decode","hash","DefaultRoute","decodeURIComponent","changeHistory","resolveParameter","nameErrorName","valueErrorName","nameMatch","regexp","buildURL","go","goToURL","pushURL","redirect","redirectToURL","replaceURL","window","appliedRegExps","id","canvasGetMethods","canvasRestMethods","htmlElements","svgElements","voidElements","htmlAllowedTagSymbols","regexpSpecialCharacters","RangeError","v","methods","TypeError","a","d","f","r","Symbol","chars","word","token","def","ret","Case","case","eventualCases","setPrototypeOf","deep","sum","descriptors","property","descriptor","props","getter","isFrozen","replacer","space","stringify","max","obj","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","isContextObject","startKey","setter","reduce","secret","iterator","Promise","executor","reject","hiddenPromise","status","onReject","handled","onUnhandledRejection","onError","resolve","then","onFulfill","hiddenStatus","hiddenValue","realPromise","proxy","onRejected","onFulfilledOrRejected","isFunc","onFulfilled","promise","handle","handler","iterable","toResolve","next","done","console","bind","Func","called","canBeCalled","before","after","sync","contextLocked","context","middleware","afterAll","beforeAll","bindContext","bindArgs","times","lockContext","lockArgs","argsLocked","mark","time","timeEnd","unbindContext","unbindArgs","toRadian","PI","toDegree","ln2","LN2","ln10","LN10","Num","toDegrees","acos","asin","atan","asDegrees","cos","abort","clearTimeout","timeout","aborted","setTimeout","interval","log","power","pow","sin","tan","rej","fractionDigits","toExponential","toFixed","precision","toPrecision","abs","sqrt","cbrt","ceil","exp","ln","sign","indexOfStrict","keyOf","keyOfStrict","separator","reverse","randomIndex","begin","compareFunction","deleteCount","URL","progress","reader","FileReader","toReject","onprogress","onerror","onload","anchor","document","createElement","dataURL","setAttribute","click","createObjectURL","htmlSpecials","regexpSpecialsRegexp","searchString","position","revert","startsWith","escaped","searchValue","fromIndex","lastIndexOf","str","beginSlice","endSlice","substr","indexStart","indexEnd","substring","nodeSwitcher","InternalParsingError","ParsingError","throwUnexpectedError","globalIndex","elements","eventSeparator","textProperty","Node","propertyDescriptor","inputElements","typeSwitcher","documentElement","namespaceURI","createElementNS","createComment","createTextNode","refSwitcher","filterSwitcher","is","innerSwitcher","paddings","borders","outerSwitcher","attrNSSwitcher","list","classList","add","insertAdjacentHTML","style","sheet","cssRules","rules","toHyphenCase","insertRule","strings","applied","setApplied","np1","attributes","getAttribute","getAttributeNS","setAttributeNS","_this4","first","load","isBroken","canvas","width","height","drawImage","byteString","atob","ab","ArrayBuffer","ia","Uint8Array","blur","pseudo","getComputedStyle","rule","childNodes","className","cloneNode","contains","appliedExpressions","getPropertyValue","getPropertyPriority","removeProperty","setProperty","cssText","toCamelCase","ctx","dataset","encoderOptions","toDataURL","deleteRule","event","eventInit","details","bubbles","cancelable","finalEvent","Event","createEvent","initEvent","dispatchEvent","focus","selectorText","hasAttribute","hasAttributeNS","currentDisplay","previousDisplay","nextSibling","insertBefore","appendChild","firstChild","forEachReverse","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","complete","naturalWidth","naturalHeight","images","all","$elem","removeListeners","proper","broken","prev","events","listeners","removeListener","listener","allListeners","removeEventListeners","has","newListener","addEventListener","delete","removeEventListener","previousSibling","link","removeChild","removeAttribute","removeAttributeNS","2","1","created","txt","_arguments6","hasClass","level","validatorWrap","input","errors","validity","valid","validationMessage","formErrors","form","inputs","dispatch","inputError","every","innerHeight","calcCSS","borderTopWidth","borderBottomWidth","boxSizing","paddingTop","paddingBottom","innerWidth","borderLeftWidth","borderRightWidth","paddingLeft","paddingRight","outerHeight","marginTop","marginBottom","outerWidth","marginLeft","marginRight","win","body","head","inputValue","isMultiple","keywordsArray","rootBlocks","rootMixins","attrName","afterElem","originalArgs","childrenBlocks","onChange","instance","forDItem","forDEach","onEvalError","localWatchers","newResult","watcherBlock","index1","index2","isParentSignal","beforeRemove","_this5","contentToAdd","notRecursive","contentToMove","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","_blockHooks","_mixinHooks","returnValue","_name","wrappers","wrapper","oldWatcher","_this6","Blocks","_this7","_value","Mixins","daysOfTheWeekNames","daysOfTheWeekAliases","monthsNames","monthsAliases","utc","coeffs","getSwitcher","setSwitcher","what","prefix","formats","format","replaceString","date1","date2","isBefore","started","coeff","w","setTime","toISOString","toLocaleString","valueOf","querySwitcher","queryParams","encodeOptions","rawHeaders","notToTransform","withoutBody","contentType","defaults","uploadMethods","Fetch","fetch","request","conf","toPush","dataConfig","urlConfig","xhr","auth","username","password","responseType","withCredentials","XMLHttpRequest","open","setRequestHeader","upload","onabort","ontimeout","onreadystatechange","readyState","response","responseText","parseHeaders","getAllResponseHeaders","statusText","catch","send","rawParam","paramName","paramObject","history","pathSwitcher","part","statics"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9saWIvaGVscGVycy90b1N0cmluZ1RhZy5qcyIsIi4uL2xpYi9oZWxwZXJzL2NoZWNrVHlwZXMuanMiLCIuLi9saWIvRC5qcyIsIi4uL2xpYi9oZWxwZXJzL2l0ZXJhdGUuanMiLCIuLi9saWIvaGVscGVycy9hc3NpZ24uanMiLCIuLi9saWIvaGVscGVycy9jb25zdHJ1Y3RFdmFsRnVuY3Rpb24uanMiLCIuLi9saWIvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uL2xpYi9oZWxwZXJzL3RvQXJyYXkuanMiLCIuLi9saWIvaGVscGVycy92YWxpZGF0ZS5qcyIsIi4uL2xpYi9BbHBoYWJldC5qcyIsIi4uL2xpYi9Td2l0Y2hlci5qcyIsIi4uL2xpYi9TdXBlci5qcyIsIi4uL2xpYi9GdW5jLmpzIiwiLi4vbGliL051bS5qcyIsIi4uL2xpYi9BcnIuanMiLCIuLi9saWIvQmxvYk9iamVjdC5qcyIsIi4uL2xpYi9TdHIuanMiLCIuLi9saWIvaGVscGVycy9tYXJrdXBUb0pTT04uanMiLCIuLi9saWIvRWxlbS5qcyIsIi4uL2xpYi9ibG9ja3MvZC1ibG9jay5qcyIsIi4uL2xpYi9ibG9ja3MvZC1lYWNoLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWVsZW1lbnRzLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWlmLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWl0ZW0uanMiLCIuLi9saWIvYmxvY2tzL2Qtc3dpdGNoLmpzIiwiLi4vbGliL21peGlucy9kLWF0dHIuanMiLCIuLi9saWIvbWl4aW5zL2QtYmluZC5qcyIsIi4uL2xpYi9taXhpbnMvZC1jbGFzcy5qcyIsIi4uL2xpYi9taXhpbnMvZC1lbGVtLmpzIiwiLi4vbGliL21peGlucy9kLWhpZGUuanMiLCIuLi9saWIvbWl4aW5zL2Qtbm9kZS5qcyIsIi4uL2xpYi9taXhpbnMvZC1vbi5qcyIsIi4uL2xpYi9taXhpbnMvZC1zaG93LmpzIiwiLi4vbGliL21peGlucy9kLXN0eWxlLmpzIiwiLi4vbGliL21peGlucy9kLXZhbGlkYXRlLmpzIiwiLi4vbGliL21peGlucy9kLXZhbHVlLmpzIiwiLi4vbGliL2hlbHBlcnMvcGFyc2VKUy5qcyIsIi4uL2xpYi9CbG9jay5qcyIsIi4uL2xpYi9jb25zdGFudHMvZm9ybWF0cy5qcyIsIi4uL2xpYi9EYXQuanMiLCIuLi9saWIvaGVscGVycy9jb25zdHJ1Y3RVUkwuanMiLCIuLi9saWIvRmV0Y2guanMiLCIuLi9saWIvUm91dGVyLmpzIiwiLi4vbGliL2NvbnN0YW50cy9nbG9iYWwuanMiLCIuLi9saWIvY29uc3RhbnRzL2FwcGxpZWRSZWdFeHBzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9jYW52YXNNZXRob2RzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9jb25zdHJ1Y3RvcnMuanMiLCIuLi9saWIvY29uc3RhbnRzL2VsZW1lbnRzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9odG1sQWxsb3dlZFRhZ1N5bWJvbHMuanMiLCIuLi9saWIvY29uc3RhbnRzL3JlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzLmpzIiwiLi4vbGliL2NvbnN0YW50cy92YWxpZGF0ZUNoZWNrRXhwcmVzc2lvbnMuanMiLCIuLi9saWIvaGVscGVycy9TeW1ib2wuanMiLCIuLi9saWIvUHJvbWlzZS5qcyIsIi4uL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIi4uL2xpYi9oZWxwZXJzL3RyYW5zZm9ybURhdGEuanMiLCIuLi9saWIvaGVscGVycy9yZXNvbHZlVVJMLmpzIiwiLi4vYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgaGVscGVycy90b1N0cmluZ1RhZ1xuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRvU3RyaW5nVGFnIG1ldGhvZC5cbiAqL1xuXG4vKipcbiAqIEBmdW5jdGlvbiB0b1N0cmluZ1RhZ1xuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gZ2V0IHRvU3RyaW5nVGFnIG9mLlxuICogQHJldHVybnMge1N0cmluZ30gQ3V0IHN0cmluZy5cbiAqIEBkZXNjcmlwdGlvbiBDdXQgXCJUeXBlXCIgc3RyaW5nIGZyb20gXCJbb2JqZWN0IFR5cGVdXCIgc3RyaW5nIHRoYXQgZ290dGVuIGZyb20ge30udG9TdHJpbmcsY2FsbChvYmplY3QpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcob2JqZWN0KSB7XG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iamVjdCkucmVwbGFjZSgvXlxcW29iamVjdCB8XSQvZywgJycpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvY2hlY2tUeXBlc1xuICogQHByaXZhdGVcbiAqIEBtaXhpblxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgaXM8VHlwZT4gbWV0aG9kcy5cbiAqL1xuXG5pbXBvcnQgeyB0b1N0cmluZ1RhZyB9IGZyb20gJy4vdG9TdHJpbmdUYWcnO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0FycmF5XG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYW4gYXJyYXkuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9yIG5vdC5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGlzQXJyYXkoW10pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheSgwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7IC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdBcnJheSc7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzQXJyYXlMaWtlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYXJyYXktbGlrZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYXJyYXktbGlrZSBvciBub3QuXG4gKiBAZGVzY3JpcHRpb24gQmFzaWNhbGx5IHJldHVybnMgaWYgdGhlIGFyZ3VtZW50IGhhcyBub24tbmVnYXRpdmUgaW50ZWdlciBcImxlbmd0aFwiIHByb3BlcnR5IGFuZCBpc24ndCBhIGZ1bmN0aW9uLlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNBcnJheUxpa2UoW10pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheUxpa2UoJycpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheUxpa2UoKCkgPT4ge30pOyAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7IC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgXG4gIHJldHVybiBpc0ludGVnZXIobGVuZ3RoKSAmJiBsZW5ndGggPj0gMDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNCb29sZWFuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBib29sZWFuLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIGJvb2xlYW4gb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNCb29sZWFuKHRydWUpOyAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzQm9vbGVhbihuZXcgQm9vbGVhbihmYWxzZSkpOyAvLyB0cnVlXG4gKiBpc0Jvb2xlYW4obnVsbCk7ICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQm9vbGVhbic7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzRGF0ZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZGF0ZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBkYXRlIG9yIG5vdC5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGlzRGF0ZShuZXcgRGF0ZSgpKTsgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJyk7IC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0RhdGUnO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0RhdGVMaWtlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgZGF0ZS1saWtlLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBkYXRlLWxpa2Ugb3Igbm90LlxuICogQGRlc2NyaXB0aW9uIEJhc2ljYWxseSByZXR1cm5zIGlmIG5ldyBEYXRlKGFyZ3VtZW50KSBpcyBub3QgaW52YWxpZCBkYXRlLlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNEYXRlTGlrZShuZXcgRGF0ZSgpKTsgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzRGF0ZUxpa2UoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpOyAvLyB0cnVlXG4gKiBpc0RhdGVMaWtlKDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlTGlrZSh2YWx1ZSkge1xuICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgXG4gIHJldHVybiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNFbGVtZW50XG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYW4gZWxlbWVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgZWxlbWVudCBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzRWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJykpOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIC9FbGVtZW50JC8udGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0Zpbml0ZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGZpbml0ZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgZmluaXRlIG9yIG5vdC5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGlzRmluaXRlKDApOyAgICAgICAgLy8gdHJ1ZVxuICogaXNGaW5pdGUoJzAnKTsgICAgICAvLyBmYWxzZVxuICogaXNGaW5pdGUoSW5maW5pdHkpOyAvLyBmYWxzZVxuICogaXNGaW5pdGUoTmFOKTsgICAgICAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNGdW5jdGlvbigoKSA9PiB7fSk7ICAgICAgICAgICAgLy8gdHJ1ZVxuICogXG4gKiBjb25zdCBmdW5jID0gKCkgPT4ge307XG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZnVuYywge30pO1xuICogaXNGdW5jdGlvbihmdW5jKTsgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNJbnRlZ2VyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW50ZWdlciBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzSW50ZWdlcigwKTsgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNJbnRlZ2VyKDAuMSk7ICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKG5ldyBOdW1iZXIoMCkpOyAvLyB0cnVlXG4gKiBpc0ludGVnZXIoJzAnKTsgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXIoSW5maW5pdHkpOyAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXIoTmFOKTsgICAgICAgICAgIC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAlIDEgPT09IDA7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzSW50ZWdlckxpa2VcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBpbnRlZ2VyLWxpa2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGludGVnZXItbGlrZSBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzSW50ZWdlckxpa2UoMCk7ICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzSW50ZWdlckxpa2UobmV3IE51bWJlcigwKSk7IC8vIHRydWVcbiAqIGlzSW50ZWdlckxpa2UoMC4xKTsgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXJMaWtlKCcwJyk7ICAgICAgICAgICAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXJMaWtlKHZhbHVlKSB7XG4gIHZhbHVlID0gcGFyc2VJbnQoTnVtYmVyKHZhbHVlKSk7XG5cbiAgcmV0dXJuICEhKHZhbHVlIHx8IHZhbHVlID09PSAwKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOYU5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBOYU4uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIE5hTiBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzTmFOKDApOyAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc05hTignTmFOJyk7ICAgICAgICAgICAvLyBmYWxzZVxuICogaXNOYU4oTmFOKTsgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNOYU4obmV3IE51bWJlcihOYU4pKTsgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc051bGxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBudWxsIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNOdWxsKG51bGwpOyAgICAgIC8vIHRydWVcbiAqIGlzTnVsbCh1bmRlZmluZWQpOyAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOaWxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc05pbChudWxsKTsgICAgICAvLyB0cnVlXG4gKiBpc05pbCh1bmRlZmluZWQpOyAvLyB0cnVlXG4gKiBpc05pbChmYWxzZSk7ICAgICAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzTnVtYmVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBudW1iZXIuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNOdW1iZXIoMCk7ICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzTnVtYmVyKG5ldyBOdW1iZXIoMCkpOyAvLyB0cnVlXG4gKiBpc051bWJlcihOYU4pOyAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNOdW1iZXIoJzAnKTsgICAgICAgICAgIC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnTnVtYmVyJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOdW1iZXJMaWtlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgbnVtYmVyLWxpa2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIG51bWJlci1saWtlIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNOdW1iZXJMaWtlKDApOyAgICAgICAgICAvLyB0cnVlXG4gKiBpc051bWJlckxpa2UoJzAnKTsgICAgICAgIC8vIHRydWVcbiAqIGlzTnVtYmVyTGlrZSgnSW5maW5pdHknKTsgLy8gdHJ1ZVxuICogaXNOdW1iZXJMaWtlKCdOYU4nKTsgICAgICAvLyB0cnVlXG4gKiBpc051bWJlckxpa2UoTmFOKTsgICAgICAgIC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyTGlrZSh2YWx1ZSkge1xuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSAnTmFOJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIFxuICByZXR1cm4gISEodmFsdWUgfHwgdmFsdWUgPT09IDApO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc09iamVjdFxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIG9iamVjdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNPYmplY3Qoe30pOyAgIC8vIHRydWVcbiAqIGlzT2JqZWN0KDEpOyAgICAvLyBmYWxzZVxuICogaXNPYmplY3QobnVsbCk7IC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAodG9TdHJpbmdUYWcodmFsdWUpID09PSAnT2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNQbGFpbk9iamVjdFxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIHBsYWluIG9iamVjdCBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG9iaiA9IHt9O1xuICpcbiAqIGlmUGxhaW5PYmplY3Qob2JqKTsgLy8gdHJ1ZVxuICpcbiAqIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmplY3QsIG51bGwpO1xuICpcbiAqIGlmUGxhaW5PYmplY3Qob2JqKTsgLy8gdHJ1ZVxuICpcbiAqIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmplY3QsIHt9KTtcbiAqXG4gKiBpZlBsYWluT2JqZWN0KG9iaik7IC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cbiAgaWYgKGlzTnVsbChwcm90bykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3I7XG5cbiAgcmV0dXJuIGlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmXG4gICAgY29uc3RydWN0b3IgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvciAmJlxuICAgIGlzTnVsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNQcmltaXRpdmVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBwcmltaXRpdmUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIHByaW1pdGl2ZSBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzUHJpbWl0aXZlKDEpOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1ByaW1pdGl2ZSh7fSk7ICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzUHJpbWl0aXZlKCcnKTsgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1ByaW1pdGl2ZShuZXcgTnVtYmVyKDApKTsgLy8gZmFsc2VcbiAqIGlzUHJpbWl0aXZlKHRydWUpOyAgICAgICAgICAvLyB0cnVlXG4gKiBpc1ByaW1pdGl2ZShTeW1ib2woJ2ZvbycpKTsgLy8gdHJ1ZVxuICogaXNQcmltaXRpdmUobnVsbCk7ICAgICAgICAgIC8vIHRydWVcbiAqIGlzUHJpbWl0aXZlKHVuZGVmaW5lZCk7ICAgICAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNOdWxsKHZhbHVlKSB8fCAvXihudW1iZXJ8c3RyaW5nfGJvb2xlYW58c3ltYm9sfHVuZGVmaW5lZCkkLy50ZXN0KHR5cGVvZiB2YWx1ZSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzUmVnRXhwXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNSZWdFeHAoL2Zvby8pOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1JlZ0V4cCgnL2Zvby8nKTsgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1JlZ0V4cChuZXcgUmVnRXhwKCdmb28nKSk7IC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdSZWdFeHAnO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc1N0cmluZ1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZyBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzU3RyaW5nKCcwJyk7ICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzU3RyaW5nKG5ldyBTdHJpbmcoJzAnKSk7IC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdTdHJpbmcnO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc1N5bWJvbFxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3ltYm9sLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIHN5bWJvbCBvciBub3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzU3ltYm9sKFN5bWJvbCgnMScpKTsgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1N5bWJvbCc7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzVW5kZWZpbmVkXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgdW5kZWZpbmVkLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc1VuZGVmaW5lZChudWxsKTsgICAgICAvLyBmYWxzZVxuICogaXNVbmRlZmluZWQodW5kZWZpbmVkKTsgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgRFxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEQgZnVuY3Rpb24uXG4gKi9cblxuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBEXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7RFdyYXB9IFdyYXAgb2YgdGhlIGFyZ3VtZW50LlxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIEQtd3JhcCBvZiBhbiBvYmplY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIEQoe30pOyAgICAgICAgICAgIC8vIFN1cGVyXG4gKiBEKCgpID0+IHt9KTsgICAgICAvLyBGdW5jXG4gKiBEKFtdKTsgICAgICAgICAgICAvLyBBcnJcbiAqIEQoMSk7ICAgICAgICAgICAgIC8vIE51bVxuICogRCgnMScpOyAgICAgICAgICAgLy8gU3RyXG4gKiBEKG5ldyBEYXRlKCkpOyAgICAvLyBEYXRcbiAqIEQoZG9jdW1lbnQuYm9keSk7IC8vIEVsZW1cbiAqL1xuZnVuY3Rpb24gRCh2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gY29uc3RydWN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbGV2ZWxDb25zdHJ1Y3RvcnMgPSBjb25zdHJ1Y3RvcnNbaV07XG5cbiAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gbGV2ZWxDb25zdHJ1Y3RvcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gbGV2ZWxDb25zdHJ1Y3RvcnNba107XG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yLmNscykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25zdHJ1Y3Rvci5jaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3Rvci5jbHModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMvY2hlY2tUeXBlcyc7XG5leHBvcnQgeyBEIH07XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy9pdGVyYXRlXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgaXRlcmF0ZSBtZXRob2QuXG4gKi9cblxuaW1wb3J0IHsgaXNBcnJheUxpa2UsIGlzVW5kZWZpbmVkIH0gZnJvbSAnLi9jaGVja1R5cGVzJztcblxuLyoqXG4gKiBAY2FsbGJhY2sgSXRlcmF0aW9uQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBJdGVyYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEl0ZXJhdGlvbiBrZXkuXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIEluaXRpYWwgaXRlcmFibGUgb2JqZWN0LlxuICovXG5cbi8qKlxuICogQGZ1bmN0aW9uIGl0ZXJhdGVcbiAqIEBwYXJhbSB7KE9iamVjdHxBcnJheXxudWxsfHVuZGVmaW5lZCl9IG9iamVjdCAtIFZhbHVlIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgaXRlcmF0aW9uLlxuICogQHJldHVybnMgeyp9IElmIGNhbGxiYWNrIHJldHVybnMgbm90IHVuZGVmaW5lZCB0aGVuIGl0ZXJhdGUgcmV0dXJucyB0aGlzIHZhbHVlLlxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBpdGVyYXRpbmcgb3ZlciBhbGwgdHlwZXMgb2YgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXRlcmF0ZShvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5ID0gaXNBcnJheUxpa2Uob2JqZWN0KTtcbiAgY29uc3QgaXRlcmF0ZWRLZXlzID0ge307XG5cbiAgbGV0IGl0ZXJhdGVkID0gMDtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYXRlZEtleXMsIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGl0ZXJhdGVkS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKGFycmF5ICYmIGl0ZXJhdGVkKysgPj0gb2JqZWN0Lmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSBjYWxsYmFjayhvYmplY3Rba2V5XSwgYXJyYXkgPyBOdW1iZXIoa2V5KSA6IGtleSwgb2JqZWN0KTtcblxuICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvYXNzaWduXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgT2JqZWN0LmFzc2lnbi1saWtlIG1ldGhvZC5cbiAqL1xuXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEBmdW5jdGlvbiBhc3NpZ25cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdG8gYXNzaWduIHJlc3Qgb2YgYXJndW1lbnRzIHRvLlxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHMgLSBPYmplY3RzIHRoYXQgYXJlIGFzc2lnbmVkIHRvIHRoZSB0YXJnZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCAuLi5vYmplY3RzKSB7XG4gIGl0ZXJhdGUoYXJndW1lbnRzLCAoc291cmNlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaXRlcmF0ZShzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICAgIFxuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvY29uc3RydWN0RXZhbEZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgY29uc3RydWN0RXZhbEZ1bmN0aW9uIG1ldGhvZC5cbiAqL1xuXG4vKipcbiAqIEBmdW5jdGlvbiBjb25zdHJ1Y3RFdmFsRnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIC0gSlMgY29kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCAtIE9yaWdpbmFsIEpTIGNvZGUuXG4gKiBAcmV0dXJucyB7Kn0gRXZhbCBmdW5jdGlvbi5cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgY29uc3RydWN0aW5nIGV2YWwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RFdmFsRnVuY3Rpb24oY29kZSwgb3JpZ2luYWwpIHtcbiAgbGV0IGZ1bmM7XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQgbm8tbmV3LWZ1bmM6IDAgKi9cbiAgICBmdW5jID0gbmV3IEZ1bmN0aW9uKCckJywgYHJldHVybiAkeyBjb2RlIH1gKTtcbiAgICBmdW5jLmV4cHJlc3Npb24gPSBjb2RlO1xuICAgIGZ1bmMub3JpZ2luYWwgPSBvcmlnaW5hbDtcblxuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN5bnRheCBlcnJvciAoaW4gXCIkeyBjb2RlIH1cIiwgb3JpZ2luYWwgY29kZTogXCIkeyBvcmlnaW5hbCB9XCIpYCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2RlZmluZVByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgZGVmaW5lUHJvcGVydHkgYW5kIGR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzIG1ldGhvZHMuXG4gKi9cblxuaW1wb3J0IHsgaXRlcmF0ZSB9IGZyb20gJy4vaXRlcmF0ZSc7XG5cbi8qKlxuICogQGNhbGxiYWNrIHByb3BlcnR5R2VuZXJhdG9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge051bWJlcn0gaSAtIEluZGV4IG9mIHRoZSBhcnJheS5cbiAqIEByZXR1cm5zIHsqfSBHZW5lcmF0ZWQgcHJvcGVydHkuXG4gKi9cblxuLyoqXG4gKiBAZnVuY3Rpb24gZHluYW1pY0RlZmluZVByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllcyAtIE9iamVjdCB3aGljaCBrZXlzIGFyZSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtwcm9wZXJ0eUdlbmVyYXRvckNhbGxiYWNrfSBwcm9wZXJ0eUdlbmVyYXRvciAtIENhbGxiYWNrIGZvciBldmVyeSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBkeW5hbWljIGNyZWF0aW5nIHByb3BlcnRpZXMgYmFzZWQgb24gbmFtZSBvZiB0aGUgbWV0aG9kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY0RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eUdlbmVyYXRvcikge1xuICBpdGVyYXRlKHByb3BlcnRpZXMsIChuYW1lLCBpKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWU6IHByb3BlcnR5R2VuZXJhdG9yKG5hbWUsIGkpLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgaXRlcmF0ZShwcm9wZXJ0aWVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICBpZiAoL15nZXQgLy50ZXN0KG5hbWUpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLnJlcGxhY2UoL15nZXQgLywgJycpLCB7XG4gICAgICAgIGdldDogdmFsdWUsXG4gICAgICAgIHNldDogdW5kZWZpbmVkLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvXnNldCAvLnRlc3QobmFtZSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUucmVwbGFjZSgvXnNldCAvLCAnJyksIHtcbiAgICAgICAgc2V0OiB2YWx1ZSxcbiAgICAgICAgZ2V0OiB1bmRlZmluZWQsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9eZ2V0XFwvc2V0IC8udGVzdChuYW1lKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZS5yZXBsYWNlKC9eZ2V0XFwvc2V0IC8sICcnKSwge1xuICAgICAgICBnZXQ6IHZhbHVlLmdldCxcbiAgICAgICAgc2V0OiB2YWx1ZS5zZXQsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT09ICdTeW1ib2wudG9TdHJpbmdUYWcnKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lVXN1YWxQcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGFyZ2V0IHRvIGRlZmluZSBwcm9wZXJ0aWVzIGZvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gT2JqZWN0IHdpdGggcHJvcGVydGllcyBuZWVkZWQgdG8gYmUgYXNzaWduIHRvIHRoZSB0YXJnZXQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgZGVmaW5pbmcgdXN1YWwgcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVVc3VhbFByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGUocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG5lZWRlZCB0byBiZSBhc3NpZ24gdG8gdGhlIHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBkZWZpbmluZyBmcm96ZW4gcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlKHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdG9BcnJheVxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRvQXJyYXkgbWV0aG9kLlxuICovXG5cbmltcG9ydCB7IGlzQXJyYXksIGlzQXJyYXlMaWtlLCBpc1N0cmluZyB9IGZyb20gJy4vY2hlY2tUeXBlcyc7XG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gdG9BcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEFueSB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZU5ld0FycmF5ID0gZmFsc2VdIC0gSWYgaXQgaXMgbmVlZGVkIHRvIGNyZWF0ZSBuZXcgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IENyZWF0ZSBhcnJheS5cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYW4gYXJyYXkgb2YgYW55IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgY3JlYXRlTmV3QXJyYXkpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmICFjcmVhdGVOZXdBcnJheSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IGFycmF5ID0gW107XG5cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAhaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgaXRlcmF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL3ZhbGlkYXRlXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgdmFsaWRhdGUgbWV0aG9kLlxuICovXG5cbmltcG9ydCB7IHZhbGlkYXRlQ2hlY2tFeHByZXNzaW9ucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuL2NoZWNrVHlwZXMnO1xuXG5jb25zdCBudW1iZXJzID0gWycxc3QnLCAnMm5kJywgJzNyZCcsICc0dGgnLCAnNXRoJywgJzZ0aCcsICc3dGgnXTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdmFsaWRhdGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50cyBvZiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHdpdGggdmFsaWRhdGUgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBOYW1lIG9mIHRoZSBmdW5jdGlvbiB3aGF0IGNhbGxlZCB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjaGVja2luZyBhcmd1bWVudHMgb2Ygb3RoZXIgZnVuY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoYXJncywgb3B0aW9ucywgbmFtZSkge1xuICBpdGVyYXRlKG9wdGlvbnMsIChhcnJheSwgbnVtYmVyKSA9PiB7XG4gICAgaWYgKCFpc0FycmF5KGFycmF5KSkge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgIH1cblxuICAgIGl0ZXJhdGUoYXJyYXksIChjaGVja2VyKSA9PiB7XG4gICAgICBjaGVja2VyID0gdmFsaWRhdGVDaGVja0V4cHJlc3Npb25zW2NoZWNrZXJdO1xuXG4gICAgICBpZiAoIWNoZWNrZXIuY2hlY2soYXJnc1tudW1iZXJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgY2hlY2tlci5lcnJvcihjaGVja2VyLnRleHQucmVwbGFjZSgnJG4nLCBudW1iZXJzW251bWJlcl0pICsgKG5hbWUgPyBgIChhdCAkeyBuYW1lIH0pYCA6ICcnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEFscGhhYmV0XG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBBbHBoYWJldCBjbGFzcy5cbiAqL1xuXG5pbXBvcnQgeyBpc1N0cmluZywgdmFsaWRhdGUsIGRlZmluZVByb3BlcnRpZXMsIFN5bWJvbCB9IGZyb20gJy4vaGVscGVycyc7XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ30gQ2hhclxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIG9mIG9uZSBjaGFyLlxuICovXG5cbi8qKlxuICogQGNsYXNzIEFscGhhYmV0XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gYWxwaGFiZXQgLSBBbHBoYWJldCB0byB3cmFwLlxuICogQHJldHVybnMge0FscGhhYmV0fSBJbnN0YW5jZSBvZiBBbHBoYWJldC5cbiAqIEBkZXNjcmlwdGlvbiBDbGFzcyBmb3IgYWxwaGFiZXQgbWFuaXB1bGF0aW9uczogYWRkLCBkZWxldGUgc3ltYm9scywgZ2VuZXJhdGUgYSB0b2tlbiBmcm9tIGFuIGFscGhhYmV0LFxuICogY2hlY2sgaWYgYW4gYWxwaGFiZXQgY29udGFpbnMgYSB3b3JkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBuZXcgQWxwaGFiZXQoWydhJywgJ2InLCAnYyddKTtcbiAqL1xuY2xhc3MgQWxwaGFiZXQge1xuICBjb25zdHJ1Y3RvcihhbHBoYWJldCA9IFtdKSB7XG4gICAgY29uc3QgYSA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFscGhhYmV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gYWxwaGFiZXRbaV07XG5cbiAgICAgIGlmICghY2hlY2soY2hhcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgbXVzdCBiZSBhIHNpbmdsZSBjaGFyISAoaW4gQWxwaGFiZXQpJyk7XG4gICAgICB9XG5cbiAgICAgIGFbY2hhcl0gPSBjaGFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gQWxwaGFiZXQjJCRcbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBhbHBoYWJldC5cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJyQkJywgeyB2YWx1ZTogYSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFscGhhYmV0I2FkZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uQ2hhcn0gY2hhcnMgLSBDaGFycyB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtBbHBoYWJldH0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgbmV3IGxldHRlcnMgdG8gdGhlIGFscGhhYmV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldChbJ2EnLCAnYicsICdjJ10pO1xuICAgKlxuICAgKiBhbHBoYWJldC5hZGQoJ2QnLCAnZScpO1xuICAgKlxuICAgKiBhbHBoYWJldC5nZXQoKS4kOyAvLyBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gICAqL1xuICBhZGQoLi4uY2hhcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY2hhcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc1tpXTtcblxuICAgICAgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VhY2ggYXJndW1lbnQgbXVzdCBiZSBhIHNpbmdsZSBjaGFyISAoaW4gQWxwaGFiZXQjYWRkKScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiQkW2NoYXJdID0gY2hhcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFscGhhYmV0I2NvbnRhaW5zXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHdvcmQgLSBXb3JkIHRvIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBhbHBoYWJldCBvciBub3QuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgd29yZCBpbiB0aGUgYWxwaGFiZXQgb3Igbm90LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgcmV0dXJucyBpZiBhIHdvcmQgaXMgaW4gYWxwaGFiZXQgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldChbJ2YnLCAnYicsICdvJywgJ2EnLCAnciddKTtcbiAgICpcbiAgICogYWxwaGFiZXQuY29udGFpbnMoJ2ZvbycpOyAvLyB0cnVlXG4gICAqIGFscGhhYmV0LmNvbnRhaW5zKCdiYXInKTsgLy8gdHJ1ZVxuICAgKiBhbHBoYWJldC5jb250YWlucygnYmF6Jyk7IC8vIGZhbHNlXG4gICAqL1xuICBjb250YWlucyh3b3JkKSB7XG4gICAgdmFsaWRhdGUoW3dvcmRdLCBbJ3N0cmluZyddLCAnQWxwaGFiZXQjY29udGFpbnMnKTtcblxuICAgIGNvbnN0IGFscGhhYmV0ID0gdGhpcy4kJDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSB3b3JkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWFscGhhYmV0W3dvcmRbaV1dKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFscGhhYmV0I2RlbGV0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uQ2hhcn0gY2hhcnMgLSBDaGFycyB0byBkZWxldGUuXG4gICAqIEByZXR1cm5zIHtBbHBoYWJldH0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWxldGluZyBsZXR0ZXJzIGZyb20gdGhlIGFscGhhYmV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldChbJ2EnLCAnYicsICdjJywgJ2QnXSk7XG4gICAqXG4gICAqIGFscGhhYmV0LmRlbGV0ZSgnYScpO1xuICAgKlxuICAgKiBhbHBoYWJldC5nZXQoKS4kOyAvLyBbJ2InLCAnYycsICdkJ11cbiAgICpcbiAgICogYWxwaGFiZXQuZGVsZXRlKCdiJywgJ2QnKTtcbiAgICpcbiAgICogYWxwaGFiZXQuZ2V0KCkuJDsgLy8gWydjJ11cbiAgICovXG4gIGRlbGV0ZSguLi5jaGFycykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjaGFycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuXG4gICAgICBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRWFjaCBhcmd1bWVudCBtdXN0IGJlIGEgc2luZ2xlIGNoYXIhIChpbiBBbHBoYWJldCNkZWxldGUpJyk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLiQkW2NoYXJdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQWxwaGFiZXQjZ2V0XG4gICAqIEByZXR1cm5zIHtBcnJheX0gV3JhcCBvZiBhbiBhcnJheSBvZiBhbHBoYWJldCBsZXR0ZXJzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGFycmF5IG9mIGFscGhhYmV0IGxldHRlcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBBbHBoYWJldChbJ2EnLCAnYicsICdjJ10pLmdldCgpLiQ7IC8vIFsnYScsICdiJywgJ2MnXVxuICAgKi9cbiAgZ2V0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiQkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFscGhhYmV0I3Rva2VuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRva2VuIGxlbmd0aC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVG9rZW4uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdlbmVyYXRpbmcgcmFuZG9tIHRva2VuIHdpdGggZ2l2ZW4gbGVuZ3RoLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQWxwaGFiZXQoWydhJywgJ2InLCAnYyddKS50b2tlbig0KTsgLy8gJ2FiY2InXG4gICAqL1xuICB0b2tlbihsZW5ndGgpIHtcbiAgICB2YWxpZGF0ZShbbGVuZ3RoXSwgW1snaW50TGlrZScsICc+MCddXSwgJ0FscGhhYmV0I3Rva2VuJyk7XG5cbiAgICBjb25zdCBhbHBoYWJldCA9IE9iamVjdC5rZXlzKHRoaXMuJCQpO1xuICAgIGNvbnN0IGxlbiA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICBsZXQgdG9rZW4gPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRva2VuICs9IGFscGhhYmV0W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbildO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEFscGhhYmV0LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0FscGhhYmV0J1xufSk7XG5cbmZ1bmN0aW9uIGNoZWNrKGNoYXIpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKGNoYXIpICYmIGNoYXIubGVuZ3RoID09PSAxO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBhbHBoYWJldFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIFN0cmluZyB0byBnZW5lcmF0ZSBhbiBhbHBoYWJldCBmcm9tLlxuICogQHJldHVybnMge0FscGhhYmV0fSBOZXcgaW5zdGFuY2Ugb2YgQWxwaGFiZXQuXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIGFscGhhYmV0IGZyb20gYSBzdHJpbmcgdGhhdCBoYXMgZm9ybWF0IGxpa2UgdGhpczpcbiAqICcmbHQ7Y2hhcjEmZ3Q7LSZsdDtjaGFyMiZndDsgJmx0O2NoYXIzJmd0Oy0mbHQ7Y2hhcjQmZ3Q7J1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBhMSA9IGFscGhhYmV0KCdhLWMgMS0zJyk7XG4gKiBjb25zdCBhMiA9IGFscGhhYmV0KCc1LTVmLWcnKTtcbiAqXG4gKiBhMS5nZXQoKS4kOyAvLyBbJzEnLCAnMicsICczJywgJ2EnLCAnYicsICdjJ11cbiAqIGEyLmdldCgpLiQ7IC8vIFsnNScsICdmJywgJ2cnXVxuICovXG5mdW5jdGlvbiBhbHBoYWJldChzdHJpbmcpIHtcbiAgdmFsaWRhdGUoW3N0cmluZ10sIFsnc3RyaW5nJ10pO1xuXG4gIGNvbnN0IHJhbmdlcyA9IHN0cmluZy5zcGxpdCgvKFtcXHNcXFNdLStbXFxzXFxTXSk/L2cpO1xuICBjb25zdCBsZW5ndGggPSByYW5nZXMubGVuZ3RoO1xuICBjb25zdCBhbHBoYWJldCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcblxuICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UgPT09ICcgJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKC8tLy50ZXN0KHJhbmdlKSAmJiAhL1tcXHNcXFNdLStbXFxzXFxTXS8udGVzdChyYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcGFydCBvZiB0aGUgc3RyaW5nICgkeyByYW5nZSB9KSEgKGluIGFscGhhYmV0KWApO1xuICAgIH1cblxuICAgIGlmICgvLS8udGVzdChyYW5nZSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuY2hhckNvZGVBdCgwKTtcbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLmNoYXJDb2RlQXQoMik7XG5cbiAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXJ0IG9mIHRoZSByYW5nZSBtdXN0IGJlIGJlZm9yZSBpdHMgZW5kISAoaW4gYWxwaGFiZXQpJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBlbmQgLSBzdGFydCArIDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBhbHBoYWJldC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQgKyBrKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGFscGhhYmV0LnB1c2gocmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQWxwaGFiZXQoYWxwaGFiZXQpO1xufVxuXG5leHBvcnQgeyBBbHBoYWJldCwgYWxwaGFiZXQgfTtcbiIsIi8qKlxuICogQG1vZHVsZSBTd2l0Y2hlclxuICogQHByaXZhdGVcbiAqIEBtaXhpblxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgU3dpdGNoZXIgY2xhc3MuXG4gKi9cblxuaW1wb3J0IHtcbiAgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVW5kZWZpbmVkLFxuICBpdGVyYXRlLCBTeW1ib2wsIHRvQXJyYXksIGRlZmluZVByb3BlcnRpZXNcbn0gZnJvbSAnLi9oZWxwZXJzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J2Jvb2xlYW4nfCdlcXVhbHMnfCdzdHJpY3RFcXVhbHMnfCdjYWxsJ30gU3dpdGNoZXJNb2RlXG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRW51bSB0eXBlIG9mIHN3aXRjaGVyIG1vZGVzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN3aXRjaGVyQ2FsbENhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gU3dpdGNoZXIgdmFsdWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnwqfSBPbiB3aGF0IHRoZSBjYWxsYmFjayByZXR1cm5zIGRlcGVuZHMgaWYgdGhlIGNhc2UgaXMgYSBtYXRjaCAodHJ1dGh5IGZvciB0aGUgbWF0Y2gpLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN3aXRjaGVyTWF0Y2hDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gQXJndW1lbnRzIGZyb20gdGhlIHNlY29uZCBhcmd1bWVudCB0aGF0IHN3aXRjaGVyIHdhcyBjYWxsZWQgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBTd2l0Y2hlciB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gbWF0Y2hlZCAtIFN3aXRjaGVyIG1hdGNoZWQgY2FzZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBTd2l0Y2hlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IFtjYXNlcyA9IHt9XSAtIE9iamVjdCBvZiBjYXNlcy5cbiAqIEBwYXJhbSB7U3dpdGNoZXJNb2RlfSBbbW9kZSA9ICdlcXVhbHMnXSAtIFN3aXRjaGVyIG1vZGUuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIC0gU3dpdGNoZXIgZGVmYXVsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtTd2l0Y2hlcn0gLSBJbnN0YW5jZSBvZiBTd2l0Y2hlci5cbiAqIEBkZXNjcmlwdGlvbiBTd2l0Y2hlciBjbGFzcyBmb3IgY3JlYXRpbmcgZnVuY3Rpb25zIHdvcmtpbmcgc2ltaWxhciB0byBzd2l0Y2ggKHZhbHVlKSB7fSBjb25zdHJ1Y3Rpb24sXG4gKiBidXQgd2l0aCB0aGUgdmFsdWUgYXNzaWdubWVudC4gU3dpdGNoZXIgaW5zdGFuY2UgaXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSB2YWx1ZSBhcmd1bWVudCBhbmQgYW4gb3B0aW9uYWxcbiAqIGFyZ3MgYXJndW1lbnQuIEFyZ3Mgd2l0aCBhZGRpdGlvbmFsIHN3aXRjaGVyIHZhbHVlIGFuZCBtYXRjaGVkIGNhc2VcbiAqIGFyZSBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb24gb2YgdGhlIG1hdGNoZWQgY2FzZSAoaWYgaXQgaXMgYSBmdW5jdGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKCk7XG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XG4gKiAgIGNhc2UxOiAndmFsdWUxJyxcbiAqICAgY2FzZTI6ICd2YWx1ZTInXG4gKiB9KTtcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnKTtcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKHtcbiAqICAgY2FzZTE6ICd2YWx1ZTEnLFxuICogICBjYXNlMjogJ3ZhbHVlMidcbiAqIH0sICdzdHJpY3RFcXVhbHMnKTtcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAnZGVmYXVsdFZhbHVlJyk7XG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XG4gKiAgIGNhc2UxOiAndmFsdWUxJyxcbiAqICAgY2FzZTI6ICd2YWx1ZTInXG4gKiB9LCAnc3RyaWN0RXF1YWxzJywgJ2RlZmF1bHRWYWx1ZScpO1xuICpcbiAqIC8vIFNlZSBbc3dpdGNoZXJde0BsaW5rIHN3aXRjaGVyfSBleGFtcGxlcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgU3dpdGNoZXIgZXh0ZW5kcyBGdW5jdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNhc2VzID0ge30sIG1vZGUgPSAnZXF1YWxzJywgZGVmYXVsdFZhbHVlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChpc1N0cmluZyhjYXNlcykpIHtcbiAgICAgIGlmICghaXNVbmRlZmluZWQoYXJndW1lbnRzWzFdKSkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSBtb2RlO1xuICAgICAgfVxuXG4gICAgICBtb2RlID0gY2FzZXM7XG4gICAgICBjYXNlcyA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50dWFsQ2FzZXMgPSBbXTtcblxuICAgIGl0ZXJhdGUoY2FzZXMsICh2YWx1ZSwgQ2FzZSkgPT4ge1xuICAgICAgZXZlbnR1YWxDYXNlcy5wdXNoKHsgY2FzZTogQ2FzZSwgdmFsdWUgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hlcih2YWx1ZSwgYXJncyA9IFtdKSB7XG4gICAgICBjb25zdCB7IG1vZGUsIGRlZmF1bHQ6IGRlZiwgY2FzZXMgfSA9IHN3aXRjaGVyLiQkO1xuXG4gICAgICBsZXQgcmV0ID0gaXRlcmF0ZShjYXNlcywgKHsgdmFsdWU6IHZhbCwgY2FzZTogQ2FzZSB9KSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAobW9kZSA9PT0gJ2Jvb2xlYW4nICYmIENhc2UpIHx8XG4gICAgICAgICAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xuICAgICAgICAgIChtb2RlID09PSAnZXF1YWxzJyAmJiBDYXNlID09IHZhbHVlKSB8fFxuICAgICAgICAgIChtb2RlID09PSAnc3RyaWN0RXF1YWxzJyAmJiBDYXNlID09PSB2YWx1ZSkgfHxcbiAgICAgICAgICAobW9kZSA9PT0gJ2NhbGwnICYmIENhc2UodmFsdWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4geyBjYXNlOiBDYXNlLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNVbmRlZmluZWQocmV0KSkge1xuICAgICAgICByZXQgPSB7IHZhbHVlOiBkZWYgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJldC52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJldC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IHRvQXJyYXkoYXJncywgdHJ1ZSk7XG4gICAgICBhcmdzLnB1c2godmFsdWUsIHJldC5jYXNlKTtcblxuICAgICAgcmV0dXJuIHJldC52YWx1ZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIFN3aXRjaGVyIyQkXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gY2FzZXMgLSBBcnJheSBvZiBjYXNlcy5cbiAgICAgKiBAcHJvcGVydHkge1N3aXRjaGVyTW9kZX0gbW9kZSAtIFN3aXRjaGVyIG1vZGUuXG4gICAgICogQHByb3BlcnR5IHsqfSBkZWZhdWx0IC0gU3dpdGNoZXIgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29uZmlnIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN3aXRjaGVyLCAnJCQnLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBjYXNlczogZXZlbnR1YWxDYXNlcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHN3aXRjaGVyLCBTd2l0Y2hlci5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIHN3aXRjaGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3dpdGNoZXIjY2FzZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7KnxTd2l0Y2hlckNhbGxDYWxsYmFja3xBcnJheS48KnxTd2l0Y2hlckNhbGxDYWxsYmFjaz59IGNhc2VzIC0gQ2FzZSBvciBhbiBhcnJheSBvZiBjYXNlcy5cbiAgICogQHBhcmFtIHsqfFN3aXRjaGVyTWF0Y2hDYWxsYmFja30gdmFsdWUgLSBWYWx1ZSB0aGF0IGhhcyB0byBiZSBhc3NpZ25lZCBvciBhIGZ1bmN0aW9uXG4gICAqIHRoYXQgaXMgY2FsbGVkIHdpdGggc3dpdGNoZXIgdmFsdWUsIGlmIGl0J3MgdGhlIGNhc2UuXG4gICAqIEByZXR1cm5zIHtTd2l0Y2hlcn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWZpbmluZyBuZXcgY2FzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHN3ID0gbmV3IFN3aXRjaGVyKClcbiAgICogICAuY2FzZSgxLCAnb25lJylcbiAgICogICAuY2FzZSgyLCAndHdvJyk7XG4gICAqXG4gICAqIHN3KDEpOyAvLyAnb25lJ1xuICAgKiBzdygyKTsgLy8gJ3R3bydcbiAgICovXG4gIGNhc2UoY2FzZXMsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0FycmF5KGNhc2VzKSkge1xuICAgICAgY2FzZXMgPSBbY2FzZXNdO1xuICAgIH1cblxuICAgIGl0ZXJhdGUoY2FzZXMsIChDYXNlKSA9PiB7XG4gICAgICB0aGlzLiQkLmNhc2VzLnB1c2goeyBjYXNlOiBDYXNlLCB2YWx1ZSB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3dpdGNoZXIjZGVmYXVsdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gZGVmIC0gTmV3IGRlZmF1bHQgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtTd2l0Y2hlcn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZWRlZmluaW5nIGRlZmF1bHQgc3dpdGNoZXIgdmFsdWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHN3ID0gbmV3IFN3aXRjaGVyKClcbiAgICogICAuY2FzZSgxLCAnb25lJylcbiAgICogICAuZGVmYXVsdCgndGhyZWUnKTtcbiAgICpcbiAgICogc3coMSk7IC8vICdvbmUnXG4gICAqIHN3KDIpOyAvLyAndGhyZWUnXG4gICAqL1xuICBkZWZhdWx0KGRlZikge1xuICAgIHRoaXMuJCQuZGVmYXVsdCA9IGRlZjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3dpdGNoZXIjbW9kZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3dpdGNoZXJNb2RlfSBtb2RlIC0gTmV3IHN3aXRjaGVyIG1vZGUuXG4gICAqIEByZXR1cm5zIHtTd2l0Y2hlcn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZWRlZmluaW5nIHN3aXRjaGVyIG1vZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHN3ID0gbmV3IFN3aXRjaGVyKClcbiAgICogICAubW9kZSgnc3RyaWN0RXF1YWxzJylcbiAgICogICAuY2FzZSgxLCAnbnVtYmVyJylcbiAgICogICAuY2FzZSgnMScsICdzdHJpbmcnKTtcbiAgICpcbiAgICogc3coMSk7ICAgLy8gJ251bWJlcidcbiAgICogc3coJzEnKTsgLy8gJ3N0cmluZydcbiAgICovXG4gIG1vZGUobW9kZSkge1xuICAgIHRoaXMuJCQubW9kZSA9IG1vZGU7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKFN3aXRjaGVyLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1N3aXRjaGVyJ1xufSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uIHN3aXRjaGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gW2Nhc2VzID0ge31dIC0gT2JqZWN0IG9mIGNhc2VzLlxuICogQHBhcmFtIHtTd2l0Y2hlck1vZGV9IFttb2RlID0gJ2VxdWFscyddIC0gU3dpdGNoZXIgbW9kZS5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gLSBTd2l0Y2hlciBkZWZhdWx0IHZhbHVlLlxuICogQHJldHVybnMge1N3aXRjaGVyfSBOZXcgaW5zdGFuY2Ugb2YgU3dpdGNoZXIuXG4gKiBAZGVzY3JpcHRpb24gU2ltcGxlIHdyYXAgb2YgW25ldyBTd2l0Y2hlciguLi4pXXtAbGluayBTd2l0Y2hlcn0uXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzdyA9IHN3aXRjaGVyKHtcbiAqICAgMTogJ2ZvbycsXG4gKiAgIDI6ICdiYXInXG4gKiB9KTtcbiAqIHN3KDEpOyAvLyAnZm9vJ1xuICogc3coMik7IC8vICdiYXInXG4gKiBzdygzKTsgLy8gdW5kZWZpbmVkXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzdyA9IHN3aXRjaGVyKClcbiAqICAgLmNhc2UoWzEsIDJdLCAnZm9vJylcbiAqICAgLmNhc2UoMywgJ2JhcicpO1xuICogICBcbiAqIHN3KDEpOyAvLyAnZm9vJ1xuICogc3coMik7IC8vICdmb28nXG4gKiBzdygzKTsgLy8gJ2JhcidcbiAqIFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN3ID0gc3dpdGNoZXIoJ2NhbGwnKVxuICogICAuY2FzZShpc0FycmF5LCAnYXJyYXknKVxuICogICAuY2FzZShpc1N0cmluZywgJ3N0cmluZycpXG4gKiAgIC5jYXNlKGlzTnVtYmVyLCAnbnVtYmVyJylcbiAqICAgLmRlZmF1bHQoJ3Jlc3QnKTtcbiAqICAgXG4gKiBzdyhbXSk7ICAgIC8vICdhcnJheSdcbiAqIHN3KCdmb28nKTsgLy8gJ3N0cmluZydcbiAqIHN3KDEyMyk7ICAgLy8gJ251bWJlcidcbiAqIHN3KHt9KTsgICAgLy8gJ3Jlc3QnXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzdyA9IHN3aXRjaGVyKHtcbiAqICAgMTogKHZhbHVlKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codmFsdWUgKyAxKTtcbiAqICAgfSxcbiAqICAgMjogKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHZhbHVlIC0gMSk7XG4gKiAgIH1cbiAqIH0pO1xuICogXG4gKiBzdygxKTsgLy8gMlxuICogc3coMik7IC8vIDFcbiAqIFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN3ID0gc3dpdGNoZXIoe1xuICogICBmaXJzdDogKGFycmF5KSA9PiBhcnJheVswXSxcbiAqICAgbGFzdDogKGFycmF5KSA9PiBhcnJheVthcnJheS5sZW5ndGggLSAxXVxuICogfSwgJ2VxdWFscycsIChhcnJheSwgaW5kZXgpID0+IGFycmF5W2luZGV4XSk7XG4gKiBjb25zdCBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAqIFxuICogc3coJ2ZpcnN0JywgW2FycmF5XSk7IC8vIDFcbiAqIHN3KCdsYXN0JywgW2FycmF5XSk7ICAvLyA0XG4gKiBzdygxLCBbYXJyYXldKTsgICAgICAgLy8gMlxuICogc3coMiwgW2FycmF5XSk7ICAgICAgIC8vIDNcbiAqL1xuZnVuY3Rpb24gc3dpdGNoZXIoY2FzZXMsIG1vZGUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN3aXRjaGVyKC4uLmFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIHdoZW5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBjb25kaXRpb24gLSBDb25kaXRpb24gdXNlZCBmb3IgcmV0dXJuaW5nIHRoZSBwcm9wZXIgdmFsdWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlMSAtIFZhbHVlIGlmIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5LlxuICogQHBhcmFtIHsqfSB2YWx1ZTIgLSBWYWx1ZSBpZiB0aGUgY29uZGl0aW9uIGlzIGZhbHNleS5cbiAqIEByZXR1cm5zIHsqfSB2YWx1ZTEgb3IgdmFsdWUyLlxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gKiBbdGVybmFyeSBvcGVyYXRvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvbmwvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0NvbmRpdGlvbmFsX09wZXJhdG9yfS5cbiAqIFxuICogQGV4YW1wbGVcbiAqIHdoZW4odHJ1ZSwgJ3RydWUnLCAnZmFsc2UnKTsgLy8gJ3RydWUnXG4gKi9cbmZ1bmN0aW9uIHdoZW4oY29uZGl0aW9uLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gY29uZGl0aW9uID8gdmFsdWUxIDogdmFsdWUyO1xufVxuXG5leHBvcnQgeyBTd2l0Y2hlciwgc3dpdGNoZXIsIHdoZW4gfTtcbiIsIi8qKlxuICogQG1vZHVsZSBTdXBlclxuICogQHByaXZhdGVcbiAqIEBtaXhpblxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgU3VwZXIgY2xhc3MuXG4gKi9cblxuaW1wb3J0IHsgRCB9IGZyb20gJy4vRCc7XG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4vU3dpdGNoZXInO1xuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMvY29uc3RydWN0b3JzJztcbmltcG9ydCB7XG4gIGlzQXJyYXksIGlzQXJyYXlMaWtlLCBpc0RhdGUsIGlzRWxlbWVudCwgaXNGdW5jdGlvbiwgaXNOaWwsIGlzTmFOLCBpc051bGwsXG4gIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LCBpc1ByaW1pdGl2ZSwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCxcbiAgdmFsaWRhdGUsIHRvU3RyaW5nVGFnLCBpdGVyYXRlLCBTeW1ib2wsIGRlZmluZVByb3BlcnRpZXNcbn0gZnJvbSAnLi9oZWxwZXJzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7U3VwZXJ8QXJyfEZ1bmN8RWxlbXxTdHJ8TnVtfERhdHxCbG9iT2JqZWN0fSBEV3JhcFxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEFueSBraW5kIG9mIEQtV3JhcC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd8TnVtYmVyfG51bGx9IEtleVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEtleSB0eXBlIHVzZWQgaW4gbWFueSBtZXRob2RzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1RyZWVFbGVtZW50W119IFRyZWVcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyZWVFbGVtZW50XG4gKiBAcHVibGljXG4gKiBAcHJvcGVydHkge0tleX0ga2V5IC0gVHJlZSBlbGVtZW50IGtleS5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWUgLSBUcmVlIGVsZW1lbnQgdmFsdWUuXG4gKiBAZGVzY3JpcHRpb24ge0BsaW5rIFRyZWV9IGVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRGVlcEl0ZXJhdGlvbkNhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQ3VycmVudCBpdGVyYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEN1cnJlbnQgaXRlcmF0aW9uIGtleS9pbmRleC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gSXRlcmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7VHJlZX0gdHJlZSAtIFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gZWxlbWVudHMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRGVlcFJlZHVjZUNhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgLSBQcmV2aW91cyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGl0ZXJhdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gQ3VycmVudCBpdGVyYXRpb24ga2V5L2luZGV4LlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBlbGVtZW50cy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQgaXRlcmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgLSBDdXJyZW50IGl0ZXJhdGlvbiBrZXkvaW5kZXguXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIEl0ZXJhdGlvbiBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSlNPTkNhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBrZXkgLSBDdXJyZW50IHZhbHVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIEl0ZXJhdGlvbiBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgT2JqZWN0Q2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPYmplY3QgLSBUaGUgbmV3IG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGl0ZXJhdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gQ3VycmVudCBpdGVyYXRpb24ga2V5L2luZGV4LlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlZHVjZUNhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgLSBQcmV2aW91cyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGl0ZXJhdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gQ3VycmVudCBpdGVyYXRpb24ga2V5L2luZGV4LlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN1cGVyTWV0aG9kXG4gKiBAcHVibGljXG4gKiBAdGhpcyB7RFdyYXB9XG4gKi9cblxuY29uc3QgY2xvbmVTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgKG9iamVjdCkgPT4gb2JqZWN0KVxuICAuY2FzZShcbiAgICAob2JqZWN0KSA9PiBuZXcgU3VwZXIob2JqZWN0KSA9PT0gb2JqZWN0LFxuICAgIChvYmplY3QpID0+IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IpKG5ldyBTdXBlcihvYmplY3QuJCkuZGVlcENsb25lKCkuJClcbiAgKVxuICAuY2FzZShpc0VsZW1lbnQsIChvYmplY3QsIGRlZXApID0+IG9iamVjdC5jbG9uZShkZWVwKSlcbiAgLmNhc2UoaXNEYXRlLCAob2JqZWN0KSA9PiBuZXcgRGF0ZShvYmplY3QpKVxuICAuY2FzZShpc1JlZ0V4cCwgKG9iamVjdCkgPT4gbmV3IFJlZ0V4cChvYmplY3Quc291cmNlLCBvYmplY3QudG9TdHJpbmcoKS5tYXRjaCgvW2dpbXV5XSokLylbMF0pKVxuICAuY2FzZShpc0FycmF5LCAoKSA9PiBbXSlcbiAgLmNhc2UoaXNQbGFpbk9iamVjdCwgKCkgPT4gKHt9KSk7XG5cbi8qKlxuICogQGNsYXNzIFN1cGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IFtvYmplY3RdIC0gQW4gb2JqZWN0IHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RFdyYXB9IEluc3RhbmNlIG9mIFN1cGVyLlxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYW55IHZhbHVlLiBBbmQgdGhlcmUgaXMgbm8gd2F5IHRvIGNyZWF0ZSBhIG5lc3RlZCB3cmFwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBuZXcgU3VwZXIoe30pOyAvLyBTdXBlclxuICovXG5jbGFzcyBTdXBlciB7XG4gIGNvbnN0cnVjdG9yKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdXBlcikge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIFN1cGVyIyRcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIFdyYXBwZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJCcsIHsgdmFsdWU6IG9iamVjdCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyLmFkZFN0YXRpY1Byb3BlcnRpZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gb2JqZWN0XG4gICAqIHdpdGggcHJvcGVydGllcyBrZXlzIGFuZCB2YWx1ZXMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgcHJvcGVydHkgdmFsdWUuXG4gICAqIEByZXR1cm5zIHt0aGlzfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBEV3JhcCBjb25zdHJ1Y3RvcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFN1cGVyLmFkZFN0YXRpY1Byb3BlcnRpZXMoJ2Nvb2wnLCA0Mik7XG4gICAqIFN1cGVyLmFkZFN0YXRpY1Byb3BlcnRpZXMoJ3N1cGVyQ29vbCcsIDQyKjQyKTtcbiAgICovXG4gIHN0YXRpYyBhZGRTdGF0aWNQcm9wZXJ0aWVzKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcGVydHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlci5hZGRJbnN0YW5jZVByb3BlcnRpZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gb2JqZWN0XG4gICAqIHdpdGggcHJvcGVydGllcyBrZXlzIGFuZCB2YWx1ZXMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgcHJvcGVydHkgdmFsdWUuXG4gICAqIEByZXR1cm5zIHt0aGlzfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBEV3JhcCBwcm90b3R5cGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBTdXBlci5hZGRJbnN0YW5jZVByb3BlcnRpZXMoJ2Nvb2wnLCA0Mik7XG4gICAqIFN1cGVyLmFkZEluc3RhbmNlUHJvcGVydGllcygnc3VwZXJDb29sJywgNDIqNDIpO1xuICAgKi9cbiAgc3RhdGljIGFkZEluc3RhbmNlUHJvcGVydGllcyhwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMucHJvdG90eXBlLCBwcm9wZXJ0eSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2Fzc2lnblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uKE9iamVjdHxTdXBlcnwqKX0gb2JqZWN0cyAtIE9iamVjdHMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIG9iamVjdC5cbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbT2JqZWN0LmFzc2lnbl1cbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ259LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyIH0pLmFzc2lnbih7IGE6IDMgfSwgeyBjOiAzLCBkOiA0IH0sIHsgZDogNSB9KS4kOyAvLyB7IGE6IDMsIGI6IDIsIGM6IDMsIGQ6IDUgfVxuICAgKi9cbiAgYXNzaWduKC4uLm9iamVjdHMpIHtcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG5cbiAgICBpdGVyYXRlKG9iamVjdCAmJiBhcmd1bWVudHMsIChvKSA9PiB7XG4gICAgICBpdGVyYXRlKG5ldyBTdXBlcihvKS4kLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2F2ZXJhZ2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBudWxsXSAtIENhbGxiYWNrIHRoYXQgaXMgcGFzc2VkIHRvIHtAbGluayBTdXBlciNzdW19LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBBdmVyYWdlIHZhbHVlLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3Igb2JqZWN0LnN1bShjYWxsYmFjaykgLyBvYmplY3QuY291bnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuYXZlcmFnZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDUgfSkuYXZlcmFnZSgodmFsdWUpID0+IHZhbHVlICogdmFsdWUpOyAvLyAxMFxuICAgKi9cbiAgYXZlcmFnZShjYWxsYmFjayA9IG51bGwpIHtcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9ufHwhJ10sICdTdXBlciNhdmVyYWdlJyk7XG5cbiAgICByZXR1cm4gdGhpcy5zdW0oY2FsbGJhY2spIC8gdGhpcy5jb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2NhbGxcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N1cGVyTWV0aG9kfSBmdW5jIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhpcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgLSBBcmd1bWVudHMgdG8gYmUgY2FsbGVkIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gb2YgZnVuY3Rpb24gY2FsbC5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIGZ1bmMuY2FsbChET2JqZWN0LCAuLi5hcmdzKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSB9KS5jYWxsKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuYSArIGIgKyBjO1xuICAgKiB9LCAyLCAzKTsgLy8gNlxuICAgKi9cbiAgY2FsbChmdW5jLCAuLi5hcmdzKSB7XG4gICAgdmFsaWRhdGUoW2Z1bmNdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNjYWxsJyk7XG5cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2Nsb25lXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IG9iamVjdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBhc3NpZ25zIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCB0byBhbiBlbXB0eSBvbmUgYW5kIHJldHVybnMgdGhlIG5ldyBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiB9IH0pLmNsb25lKCkuJDsgLy8geyBhOiAxLCBiOiB7IGM6IDIgfSB9XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG4gICAgY29uc3QgY2xvbmUgPSBjbG9uZVN3aXRjaGVyKG9iamVjdCwgW29iamVjdCwgZmFsc2VdKTtcblxuICAgIGlmIChjbG9uZSAhPT0gb2JqZWN0KSB7XG4gICAgICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgY2xvbmVba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGNsb25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIFN1cGVyI2NvdW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIgfSkuY291bnQ7IC8vIDJcbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gb2JqZWN0Lmxlbmd0aCA6IE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjY3JlYXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXNjcmlwdG9yc10gLSBEZXNjcmlwdG9ycyBwYXNzZWQgdG8gT2JqZWN0LmNyZWF0ZS5cbiAgICogQHJldHVybnMge0RXcmFwfSBOZXcgaW5zdGFuY2Ugb2YgRC1XcmFwLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtPYmplY3QuY3JlYXRlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHt9KS5jcmVhdGUoe1xuICAgKiAgIGE6IHtcbiAgICogICAgIHZhbHVlOiAxLFxuICAgKiAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAqICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICogICB9XG4gICAqIH0pLiQ7IC8vIHsgYTogMSB9XG4gICAqL1xuICBjcmVhdGUoZGVzY3JpcHRvcnMpIHtcbiAgICByZXR1cm4gRChpc1ByaW1pdGl2ZSh0aGlzLiQpID8gdW5kZWZpbmVkIDogT2JqZWN0LmNyZWF0ZSh0aGlzLiQsIGRlc2NyaXB0b3JzKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwQXNzaWduXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4qfSBvYmplY3RzIC0gT2JqZWN0cyB0byBiZSBhc3NpZ25lZCB0byB0aGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2Fzc2lnbn0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEgfSkuZGVlcEFzc2lnbihcbiAgICogICB7XG4gICAqICAgICBiOiB7XG4gICAqICAgICAgIGM6IDJcbiAgICogICAgIH1cbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGE6IHtcbiAgICogICAgICAgYjogMVxuICAgKiAgICAgfVxuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgYToge1xuICAgKiAgICAgICBjOiB7XG4gICAqICAgICAgICAgZDogMVxuICAgKiAgICAgICB9XG4gICAqICAgICB9LFxuICAgKiAgICAgYjogMlxuICAgKiAgIH0sXG4gICAqICAgbnVsbFxuICAgKiB9KTtcbiAgICogLy8ge1xuICAgKiAvLyAgIGE6IHtcbiAgICogLy8gICAgIGI6IDEsXG4gICAqIC8vICAgICBjOiB7XG4gICAqIC8vICAgICAgIGQ6IDFcbiAgICogLy8gICAgIH1cbiAgICogLy8gICB9LFxuICAgKiAvLyAgIGI6IDIsXG4gICAqIC8vIH1cbiAgICovXG4gIGRlZXBBc3NpZ24oLi4ub2JqZWN0cykge1xuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcblxuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKG8pID0+IHtcbiAgICAgIGRlZXBBc3NpZ24ob2JqZWN0LCBvKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcENsb25lXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0RXcmFwfSBOZXcgaW5zdGFuY2Ugb2YgRFdyYXAuXG4gICAqIEBkZXNjcmlwdGlvbiBEZWVwIGNsb25pbmcgbWV0aG9kLiBDbG9uZXMgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCByZWd1bGFyIGV4cHJlc3Npb25zIGFuZCBlbGVtZW50cywgdGhlIHJlc3Qgc3RheXMgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IFsyLCAzXSwgYzogeyBkOiA0IH0gfSkuZGVlcENsb25lKCkuJDtcbiAgICogLy8ge1xuICAgKiAvLyAgIGE6IDEsXG4gICAqIC8vICAgYjogWzIsIDNdLFxuICAgKiAvLyAgIGM6IHsgZDogNCB9XG4gICAqIC8vIH1cbiAgICovXG4gIGRlZXBDbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoZGVlcENsb25lKHRoaXMuJCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcEVxdWFsc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gW29iamVjdF0gLSBPYmplY3QgdG8gY29tcGFyZSB0by5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG9iamVjdHMgYXJlIGRlZXAgZXF1YWwgb3Igbm90LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWVwIGNvbXBhcmlzb24gb2YgdHdvIG9iamVjdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEgfSkuZGVlcEVxdWFscyh7IGE6ICcxJyB9KTsgLy8gdHJ1ZVxuICAgKiBuZXcgU3VwZXIoLzEvKS5kZWVwRXF1YWxzKC8xLyk7ICAgICAgICAgICAgIC8vIHRydWVcbiAgICovXG4gIGRlZXBFcXVhbHMob2JqZWN0ID0gbnVsbCkge1xuICAgIHJldHVybiBkZWVwRXF1YWwodGhpcy4kLCBvYmplY3QsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBFdmVyeVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogSWYgcmV0dXJucyB0cnV0aHkgaXRlcmF0aW9uIGdvZXMgb24gYW5kIGlmIGZhbHNleSBpdCBzdG9wcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGJvb2xlYW4gaWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXG4gICAqIE90aGVyd2lzZSBmYWxzZS4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZXZlcnl9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA8IDQpOyAvLyB0cnVlXG4gICAqIG5ldyBTdXBlcih7IGE6IHt9LCBiOiB7fSwgYzoge30gfSkuZGVlcEV2ZXJ5KCgpID0+IGZhbHNlKTsgICAgICAgICAgICAgIC8vIHRydWVcbiAgICovXG4gIGRlZXBFdmVyeShjYWxsYmFjaywgbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbiA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIG4gPSBJbmZpbml0eTtcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEV2ZXJ5Jyk7XG5cbiAgICBuID0gTnVtYmVyKG4pO1xuXG4gICAgcmV0dXJuIGRlZXBFdmVyeSh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcEZpbHRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGVsZW1lbnQgaXMgaW5jbHVkZWQgYW5kIGlmIGZhbHNleSBpdCdzIGV4Y2x1ZGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IEQtV3JhcCBvZiBmaWx0ZXJlZCBvYmplY3QuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGZpbHRlcmVkIGJ5IHRoZSBjYWxsYmFjayBvYmplY3QuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2ZpbHRlcn0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSUyKS4kOyAgICAgLy8geyBhOiAxLCBiOiB7IGQ6IDMgfSB9XG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gMSkuJDsgLy8geyBhOiAxIH1cbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcEZpbHRlcigodmFsdWUpID0+IHZhbHVlID4gMykuJDsgICAvLyB7fVxuICAgKi9cbiAgZGVlcEZpbHRlcihjYWxsYmFjaywgbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbiA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIG4gPSBJbmZpbml0eTtcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEZpbHRlcicpO1xuXG4gICAgY29uc3QgZmlsdGVyZWQgPSBkZWVwRmlsdGVyKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XG5cbiAgICByZXR1cm4gRChpc05pbChmaWx0ZXJlZCkgPyBmaWx0ZXJlZCA6IGZpbHRlcmVkIHx8IHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGaW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBJZiByZXR1cm5zIHRydXRoeSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIGZhbHNleSBpdCBjb250aW51ZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbiA9IEluZmluaXR5XSAtIEl0ZXJhdGlvbiBkZXB0aC5cbiAgICogQHJldHVybnMge1RyZWV8bnVsbH0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBpZiBzb21ldGhpbmcgZm91bmQgYW5kIG51bGwgaWYgbm90LlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cmVlIG9mIHRoZSBlbGVtZW50cyBpZiBzb21ldGhpbmcgZm91bmQgYW5kIG51bGwgaWYgbm90aGluZyBmb3VuZC5cbiAgICogRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZmluZH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGaW5kKCh2YWx1ZSkgPT4gdmFsdWUgPT09IDIpO1xuICAgKiAvLyBbXG4gICAqIC8vICAgeyBrZXk6ICdjJywgdmFsdWU6IDIgfSxcbiAgICogLy8gICB7IGtleTogJ2InLCB2YWx1ZTogeyBjOiAyLCBkOiAzIH0gfSxcbiAgICogLy8gICB7IGtleTogbnVsbCwgdmFsdWU6IDxpbml0aWFsIG9iamVjdD4gfVxuICAgKiAvLyBdXG4gICAqL1xuICBkZWVwRmluZChjYWxsYmFjaywgbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbiA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIG4gPSBJbmZpbml0eTtcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEZpbmQnKTtcblxuICAgIHJldHVybiBkZWVwRmluZCh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcEZvckVhY2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbiA9IEluZmluaXR5XSAtIEl0ZXJhdGlvbiBkZXB0aC5cbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGl0ZXJhdGluZyBvdmVyIGFueSBvYmplY3QuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2ZvckVhY2h9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRm9yRWFjaCgodmFsdWUsIGtleSwgb2JqZWN0KSA9PiBvYmplY3Rba2V5XSA9IHZhbHVlICogdmFsdWUpLiQ7XG4gICAqIC8vIHsgYTogMSwgYjogeyBjOiA0LCBkOiA5IH0gfVxuICAgKi9cbiAgZGVlcEZvckVhY2goY2FsbGJhY2ssIG4gPSBJbmZpbml0eSkge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwRm9yRWFjaCcpO1xuXG4gICAgbiA9IE51bWJlcihuKTtcblxuICAgIGRlZXBGb3JFYWNoKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGb3JFYWNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpdGVyYXRpbmcgb3ZlciBhbnkgb2JqZWN0LiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNmb3JFYWNofS5cbiAgICogVW5saWtlIHtAbGluayBTdXBlciNkZWVwRm9yRWFjaH0gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBvbiBldmVyeSB2YWx1ZSBvZiBldmVyeSBvYmplY3QgaW5zaWRlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGb3JFYWNoKCh2YWx1ZSwga2V5LCBvYmplY3QpID0+IG9iamVjdFtrZXldID0gdmFsdWUgKiB2YWx1ZSkuJDtcbiAgICogLy8geyBhOiAxLCBiOiB7IGM6IDQsIGQ6IDkgfSB9XG4gICAqL1xuICBkZWVwRm9yRWFjaEVudHJ5KGNhbGxiYWNrLCBuID0gSW5maW5pdHkpIHtcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEZvckVhY2gnKTtcblxuICAgIG4gPSBOdW1iZXIobik7XG5cbiAgICBkZWVwRm9yRWFjaEVudHJ5KHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGcmVlemVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2ZyZWV6ZX0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBGcmVlemUoKTsgLy8gU3VwZXJcbiAgICovXG4gIGRlZXBGcmVlemUoKSB7XG4gICAgZGVlcEZyZWV6ZSh0aGlzLiQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwTWFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBSZXR1cm4gdmFsdWUgaXMgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gRC1XcmFwIG9mIHRoZSBuZXcgb2JqZWN0LlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHdyYXAgb2YgYSBuZXcgb2JqZWN0IHVzaW5nIHRoZSBjYWxsYmFjay4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjbWFwfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcE1hcCgodmFsdWUpID0+IHZhbHVlICogdmFsdWUpLiQ7XG4gICAqIC8vIHsgYTogMSwgYjogeyBjOiA0LCBkOiA5IH0gfVxuICAgKi9cbiAgZGVlcE1hcChjYWxsYmFjaywgbiA9IEluZmluaXR5KSB7XG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrLCBuXSwgWydmdW5jdGlvbicsIFsnbnVtYmVyTGlrZScsICc+MCddXSwgJ1N1cGVyI2RlZXBNYXAnKTtcblxuICAgIG4gPSBOdW1iZXIobik7XG5cbiAgICByZXR1cm4gRChkZWVwTWFwKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcFJlZHVjZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RGVlcFJlZHVjZUNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogUmV0dXJuIHZhbHVlIGlzIHBhc3NlZCB0byB0aGUgbmV4dCBjYWxsYmFjayBjYWxsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW24gPSBJbmZpbml0eV0gLSBJdGVyYXRpb24gZGVwdGguXG4gICAqIEBwYXJhbSB7Kn0gW0lWID0gPGZpcnN0IHZhbHVlPnx1bmRlZmluZWRdIC0gSW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IE1vZGlmaWVkIElWLlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBtb2RpZmllZCBJVi4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjcmVkdWNlfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcFJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUgKiB2YWx1ZSwgSW5maW5pdHksIDApOyAvLyAxNFxuICAgKi9cbiAgZGVlcFJlZHVjZShjYWxsYmFjaywgbiA9IEluZmluaXR5LCBJVikge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwUmVkdWNlJyk7XG5cbiAgICBuID0gTnVtYmVyKG4pO1xuXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuICAgIGNvbnN0IHRyZWUgPSBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkZWVwUmVkdWNlKG9iamVjdCwgY2FsbGJhY2ssIG4sIGZhbHNlLCB1bmRlZmluZWQsIHRyZWUpLklWO1xuICAgIH1cblxuICAgIHJldHVybiBkZWVwUmVkdWNlKG9iamVjdCwgY2FsbGJhY2ssIG4sIGZhbHNlLCB7IElWIH0sIHRyZWUpLklWO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcFNvbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgZmFsc2V5IGl0IGNvbnRpbnVlcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRydWUgaWYgc29tZSBvZiB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxuICAgKiBPdGhlcndpc2UgZmFsc2UuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI3NvbWV9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwU29tZSgodmFsdWUpID0+IHZhbHVlID4gNCk7IC8vIGZhbHNlXG4gICAqIG5ldyBTdXBlcih7IGE6IHt9LCBiOiB7fSwgYzoge30gfSkuZGVlcFNvbWUoKCkgPT4gdHJ1ZSk7ICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGRlZXBTb21lKGNhbGxiYWNrLCBuKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICBuID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IEJvb2xlYW47XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBuID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgbiA9IEluZmluaXR5O1xuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwU29tZScpO1xuXG4gICAgbiA9IE51bWJlcihuKTtcblxuICAgIHJldHVybiBkZWVwU29tZSh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcFN0cmljdEVxdWFsc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gW29iamVjdF0gLSBPYmplY3QgdG8gY29tcGFyZSB0by5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG9iamVjdHMgYXJlIGRlZXAgc3RyaWN0IGVxdWFsIG9yIG5vdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVlcCBzdHJpY3QgY29tcGFyaXNvbiBvZiB0d28gb2JqZWN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSB9KS5kZWVwU3RyaWN0RXF1YWxzKHsgYTogJzEnIH0pOyAvLyBmYWxzZVxuICAgKiBuZXcgU3VwZXIoLzEvKS5kZWVwU3RyaWN0RXF1YWxzKC8xLyk7ICAgICAgICAgICAgIC8vIHRydWVcbiAgICovXG4gIGRlZXBTdHJpY3RFcXVhbHMob2JqZWN0ID0gbnVsbCkge1xuICAgIHJldHVybiBkZWVwRXF1YWwodGhpcy4kLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZGVmaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhIGRlc2NyaXB0b3JzIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXNjcmlwdG9yXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBib3RoXG4gICAqIFtPYmplY3QuZGVmaW5lUHJvcGVydHlde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9kZWZpbmVQcm9wZXJ0eX1cbiAgICogYW5kXG4gICAqIFtPYmplY3QuZGVmaW5lUHJvcGVydGllc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnRpZXN9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoe30pLmRlZmluZSgnYScsIHtcbiAgICogICB2YWx1ZTogMSxcbiAgICogICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICogICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAqIH0pLiQ7IC8vIHsgYTogMSB9XG4gICAqIG5ldyBTdXBlcih7fSkuZGVmaW5lKHtcbiAgICogICBhOiB7XG4gICAqICAgICB2YWx1ZTogMSxcbiAgICogICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgKiAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAqICAgfVxuICAgKiB9KS4kOyAvLyB7IGE6IDEgfVxuICAgKi9cbiAgZGVmaW5lKHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IGRlc2NyaXB0b3IgfTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eSA9IG5ldyBTdXBlcihwcm9wZXJ0eSkuJDtcblxuICAgIGlmIChpc09iamVjdCh0aGlzLiQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLiQsIHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2RlbGV0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBwcm9wcyAtIExpc3Qgb2YgcHJvcGVydGllcyB0byBkZWxldGUuXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9kZWxldGVcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIG11bHRpcGxlXG4gICAqIFtcImRlbGV0ZVwiIG9wZXJhdG9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvZGVsZXRlfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5kZWxldGUoJ2MnLCAnYScpLiQ7IC8vIHsgYjogMiB9XG4gICAqL1xuICBkZWxldGUoLi4ucHJvcHMpIHtcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG5cbiAgICBpdGVyYXRlKG9iamVjdCAmJiBwcm9wcywgKHByb3BlcnR5KSA9PiB7XG4gICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZXF1YWxzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsqfSBbb2JqZWN0XSAtIE9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIG9iamVjdHMgYXJlIGVxdWFsIG9yIG5vdC5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdHJ1ZSBpZiBvYmplY3RzIGFyZSBlcXVhbCB1c2luZyAnPT0nIG9wZXJhdG9yIGFuZCBmYWxzZSBpZiBub3QuIE5hTnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgZXF1YWwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcigzKS5lcXVhbHMoJzMnKTsgICAvLyB0cnVlXG4gICAqIG5ldyBTdXBlcihOYU4pLmVxdWFscyhOYU4pOyAvLyB0cnVlXG4gICAqL1xuICBlcXVhbHMob2JqZWN0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuJDtcblxuICAgIG9iamVjdCA9IG5ldyBTdXBlcihvYmplY3QpLiQ7XG5cbiAgICAvKiBlc2xpbnQgZXFlcWVxOiAwICovXG4gICAgcmV0dXJuIG8gPT0gb2JqZWN0IHx8IChpc05hTihvKSAmJiBpc05hTihvYmplY3QpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2V2ZXJ5XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBnb2VzIG9uIGFuZCBpZiBmYWxzZXkgaXQgc3RvcHMuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBhbGwgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYm9vbGVhbiBpZiBhbGwgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5ldmVyeSgodmFsdWUpID0+IHZhbHVlIDwgNCk7IC8vIHRydWVcbiAgICogbmV3IFN1cGVyKHt9KS5ldmVyeSgoKSA9PiBmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAgICovXG4gIGV2ZXJ5KGNhbGxiYWNrID0gQm9vbGVhbikge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI2V2ZXJ5Jyk7XG5cbiAgICByZXR1cm4gaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcbiAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSkgIT09IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZXhjZXB0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IFtwcm9wc10gLSBQcm9wcyB0byBmaWx0ZXIuXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IEQtV3JhcCBvZiBmaWx0ZXJlZCBvYmplY3QuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGZpbHRlciBieSB0aGUgcHJvcHMgb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmV4Y2VwdCgnYScsICdiJykuJDsgLy8geyBjOiAzIH1cbiAgICogbmV3IFN1cGVyKG51bGwpLmV4Y2VwdCgnYScpLiQ7ICAgICAgICAgICAgICAgICAgICAgIC8vIHt9XG4gICAqL1xuICBleGNlcHQoLi4ucHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoKHZhbHVlLCBrZXkpID0+IHByb3BzLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZmlsdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBlbGVtZW50IGlzIGluY2x1ZGVkIGFuZCBpZiBmYWxzZXkgaXQncyBleGNsdWRlZC5cbiAgICogQHJldHVybnMge0RXcmFwfSBOZXcgRC1XcmFwIG9mIGZpbHRlcmVkIG9iamVjdC5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgZmlsdGVyZWQgYnkgdGhlIGNhbGxiYWNrIG9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSUyKS4kOyAvLyB7IGE6IDEsIGM6IDMgfVxuICAgKiBuZXcgU3VwZXIobnVsbCkuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUlMikuJDsgICAgICAgICAgICAgICAgIC8vIG51bGxcbiAgICovXG4gIGZpbHRlcihjYWxsYmFjayA9IEJvb2xlYW4pIHtcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNmaWx0ZXInKTtcblxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcbiAgICBjb25zdCBhcnJheSA9IGlzQXJyYXlMaWtlKG9iamVjdCk7XG5cbiAgICAvKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cbiAgICBjb25zdCBvID0gYXJyYXkgPyBbXSA6IGlzTmlsKG9iamVjdCkgPyBvYmplY3QgOiB7fTtcblxuICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgby5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEQobyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNmaW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgZmFsc2V5IGl0IGNvbnRpbnVlcy5cbiAgICogQHJldHVybnMge3sga2V5OiBLZXksIHZhbHVlOiAqIH18bnVsbH0geyBrZXksIHZhbHVlIH0gaWYgZm91bmQgYW5kIG51bGwgaWYgbm90LlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBmb3VuZCB7IGtleSwgdmFsdWUgfSBpZiBzb21ldGhpbmcgZm91bmQgYW5kIG51bGwgaWYgbm90aGluZyBmb3VuZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5maW5kKCh2YWx1ZSkgPT4gdmFsdWUgPT09IDIpOyAvLyB7IGtleTogJ2InLCB2YWx1ZTogMiB9XG4gICAqIG5ldyBTdXBlcihbMSwgMiwgM10pLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gMik7ICAgICAgICAgICAgLy8geyBrZXk6IDEsIHZhbHVlOiAyIH1cbiAgICovXG4gIGZpbmQoY2FsbGJhY2spIHtcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNmaW5kJyk7XG5cbiAgICByZXR1cm4gaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcbiAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiB7IGtleSwgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZm9yRWFjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgYW55IG9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcbiAgICogICBvYmplY3Rba2V5XSA9IHZhbHVlICogdmFsdWU7XG4gICAqIH0pLiQ7IC8vIHsgYTogMSwgYjogeyBjOiA0LCBkOiA1IH0gfVxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI2ZvckVhY2gnKTtcblxuICAgIGl0ZXJhdGUodGhpcy4kLCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNmcmVlemVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZnJlZXplXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbT2JqZWN0LmZyZWV6ZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2ZyZWV6ZX0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuZnJlZXplKCk7IC8vIFN1cGVyXG4gICAqL1xuICBmcmVlemUoKSB7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzLiQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNnZXRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgRnVuY3Rpb24+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGEgZ2V0dGVycyBvYmplY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZXR0ZXJdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhpcyBoYXMgdG8gYmUgYSBnZXR0ZXIgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWZpbmluZyBnZXR0ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBvYmplY3QxID0gbmV3IFN1cGVyKHt9KS5nZXQoJ2EnLCAoKSA9PiAxKS4kO1xuICAgKiBvYmplY3QxLmE7IC8vIDFcbiAgICpcbiAgICogY29uc3Qgb2JqZWN0MiA9IG5ldyBTdXBlcih7fSkuZ2V0KHtcbiAgICogICBhOiAoKSA9PiAyXG4gICAqIH0pLiQ7XG4gICAqIG9iamVjdDIuYTsgLy8gMlxuICAgKi9cbiAgZ2V0KHByb3BlcnR5LCBnZXR0ZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogZ2V0dGVyIH07XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuXG4gICAgaXRlcmF0ZShpc09iamVjdChvYmplY3QpICYmIG5ldyBTdXBlcihwcm9wZXJ0eSkuJCwgKGdldHRlciwgcHJvcGVydHkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7IGdldDogZ2V0dGVyIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNoYXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBrZXkgLSBQcm9wZXJ0eSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyB0aGUga2V5IGFuZCBmYWxzZSBpZiBub3QuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL2luXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbXCJpblwiIG9wZXJhdG9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvaW59LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmhhcygnYicpOyAvLyB0cnVlXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuXG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleSBpbiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNoYXNPd25cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBrZXkgLSBQcm9wZXJ0eSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyBpdHMgb3duIGtleSBhbmQgZmFsc2UgaWYgbm90LlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9oYXNPd25Qcm9wZXJ0eVxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW09iamVjdCNoYXNPd25Qcm9wZXJ0eV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2hhc093blByb3BlcnR5fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5oYXNPd24oJ2InKTsgICAgICAgICAgICAgIC8vIHRydWVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5oYXNPd24oJ2hhc093blByb3BlcnR5Jyk7IC8vIGZhbHNlXG4gICAqL1xuICBoYXNPd24oa2V5KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuXG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjaW5zdGFuY2VvZlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIC0gQ29uc3RydWN0b3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIGNvbnN0cnVjdG9yLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9pbnN0YW5jZW9mXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbXCJpbnN0YW5jZW9mXCIgb3BlcmF0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9pbnN0YW5jZW9mfS5cbiAgICovXG4gIGluc3RhbmNlb2YoY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4kIGluc3RhbmNlb2YgY29uc3RydWN0b3I7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNpc0Zyb3plblxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0IGlzIGZyb3plbi5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNGcm96ZW5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtPYmplY3QuaXNGcm96ZW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0Zyb3plbn0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7fSkuZnJlZXplKCkuaXNGcm96ZW4oKTsgLy8gdHJ1ZVxuICAgKi9cbiAgaXNGcm96ZW4oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbih0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjanNvblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SlNPTkNhbGxiYWNrfFN0cmluZ1tdfSBbcmVwbGFjZXJdIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtzcGFjZV0gLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEpTT04gc3RyaW5nLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5XG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbSlNPTi5zdHJpbmdpZnlde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5qc29uKCk7IC8vICd7XCJhXCI6MSxcImJcIjoyLFwiY1wiOjN9J1xuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmpzb24oJyAgICAnKTtcbiAgICogLy8ge1xuICAgKiAvLyAgICAgXCJhXCI6IDEsXG4gICAqIC8vICAgICBcImJcIjogMixcbiAgICogLy8gICAgIFwiY1wiOiAzXG4gICAqIC8vIH1cbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5qc29uKChrZXksIHZhbHVlKSA9PiB7XG4gICAqICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICogICAgIHJldHVybiB2YWx1ZSUyID8ga2V5ICsgdmFsdWUwIDogdW5kZWZpbmVkO1xuICAgKiAgIH1cbiAgICpcbiAgICogICByZXR1cm4gdmFsdWU7XG4gICAqIH0sIDIpO1xuICAgKiAvLyB7XG4gICAqIC8vICAgXCJhXCI6IFwiYTFcIixcbiAgICogLy8gICBcImNcIjogXCJjM1wiXG4gICAqIC8vIH1cbiAgICovXG4gIGpzb24ocmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzRnVuY3Rpb24ocmVwbGFjZXIpICYmICFpc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgW10udW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgbnVsbCk7XG4gICAgfVxuXG4gICAgW10udW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgdGhpcy4kKTtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeS5hcHBseShKU09OLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIja2V5T2ZcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gZmluZC5cbiAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ8bnVsbH0gQSBrZXkgb3IgYW4gaW5kZXggaWYgZm91bmQgYW5kIG51bGwgaWYgbm90LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIGVxdWFsIHRvIHRoZSBhcmd1bWVudCB2YWx1ZSBpbiB0aGUgb2JqZWN0LiBOYU5zIGFyZSBjb25zaWRlcmVkIHRvIGJlIGVxdWFsLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmtleU9mKDIpOyAgIC8vICdiJ1xuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmtleU9mKCcyJyk7IC8vICdiJ1xuICAgKi9cbiAga2V5T2YodmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBpdGVyYXRlKHRoaXMuJCwgKHZhbCwga2V5KSA9PiB7XG4gICAgICBpZiAodmFsID09IHZhbHVlIHx8IChpc05hTih2YWwpICYmIGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpc1VuZGVmaW5lZChrZXkpID8gbnVsbCA6IGtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2tleU9mU3RyaWN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfG51bGx9IEEga2V5IG9yIGFuIGluZGV4IGlmIGZvdW5kIGFuZCBudWxsIGlmIG5vdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBzdHJpY3QgZXF1YWwgdG8gdGhlIGFyZ3VtZW50IHZhbHVlIGluIHRoZSBvYmplY3QuIE5hTnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgZXF1YWwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkua2V5T2ZTdHJpY3QoMik7ICAgLy8gJ2InXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkua2V5T2ZTdHJpY3QoJzInKTsgLy8gJ2InXG4gICAqL1xuICBrZXlPZlN0cmljdCh2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9IGl0ZXJhdGUodGhpcy4kLCAodmFsLCBrZXkpID0+IHtcbiAgICAgIGlmICh2YWwgPT09IHZhbHVlIHx8IChpc05hTih2YWwpICYmIGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpc1VuZGVmaW5lZChrZXkpID8gbnVsbCA6IGtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI2tleXNcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RFdyYXB9IEEgd3JhcCBvZiB0aGUga2V5cyBhcnJheS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1xuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW09iamVjdC5rZXlzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkua2V5cygpLiQ7IC8vIFsnYScsICdiJywgJ2MnXVxuICAgKiBuZXcgU3VwZXIobnVsbCkua2V5cygpLiQ7ICAgICAgICAgICAgICAgICAvLyBbXVxuICAgKi9cbiAga2V5cygpIHtcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG5cbiAgICByZXR1cm4gRChpc09iamVjdChvYmplY3QpID8gT2JqZWN0LmtleXMob2JqZWN0KSA6IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI21hcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBSZXR1cm4gdmFsdWUgaXMgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RFdyYXB9IEQtV3JhcCBvZiB0aGUgbmV3IG9iamVjdC5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSB3cmFwIG9mIGEgbmV3IG9iamVjdCB1c2luZyB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKiAyKS4kOyAvLyB7IGE6IDIsIGI6IDQsIGM6IDYgfVxuICAgKiBuZXcgU3VwZXIobnVsbCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKiAyKS4kOyAgICAgICAgICAgICAgICAgLy8gbnVsbFxuICAgKi9cbiAgbWFwKGNhbGxiYWNrKSB7XG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbiddLCAnU3VwZXIjbWFwJyk7XG5cbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG4gICAgY29uc3QgbyA9IGlzQXJyYXlMaWtlKG9iamVjdCkgPyBbXSA6IGlzTnVsbChvYmplY3QpID8gbnVsbCA6IHt9O1xuXG4gICAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBvW2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEQobyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNtYXhcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIGNvbXBhcmlzb24gd2l0aCB0aGUgcHJldmlvdXMgbWF4IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7e2tleTogS2V5LCB2YWx1ZTogTnVtYmVyfX0gT2JqZWN0IHdpdGggbWF4IHZhbHVlIGFuZCBrZXkgb2YgdGhlIG1heCB2YWx1ZS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBtYXggdmFsdWUgaW4gdGhlIG9iamVjdC5cbiAgICogSWYgbm8gY2FsbGJhY2sgaXMgcHJlc2VudCBjb21wYXJpc29uIGlzIGJldHdlZW4gdmFsdWVzIG9mIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkubWF4KCk7ICAgICAgICAgICAgICAgICAgICAgLy8geyBrZXk6ICdjJywgdmFsdWU6IDMgfVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLm1heCgodmFsdWUpID0+IDQgLSB2YWx1ZSk7IC8vIHsga2V5OiAnYScsIHZhbHVlOiAzIH1cbiAgICogbmV3IFN1cGVyKHsgYTogJ2EnLCBiOiAnYicsIGM6ICdjJyB9KS5tYXgoKTsgICAgICAgICAgICAgICAvLyB7IGtleTogbnVsbCwgdmFsdWU6IC1JbmZpbml0eSB9XG4gICAqL1xuICBtYXgoY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjbWF4Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKG1heCwgdmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBOdW1iZXIoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpO1xuXG4gICAgICBpZiAodmFsID4gbWF4LnZhbHVlKSB7XG4gICAgICAgIG1heC5rZXkgPSBrZXk7XG4gICAgICAgIG1heC52YWx1ZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LCB7IGtleTogbnVsbCwgdmFsdWU6IC1JbmZpbml0eSB9KS4kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjbWluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciBjb21wYXJpc29uIHdpdGggdGhlIHByZXZpb3VzIG1pbiB2YWx1ZS5cbiAgICogQHJldHVybnMge3trZXk6IEtleSwgdmFsdWU6IE51bWJlcn19IE9iamVjdCB3aXRoIG1pbiB2YWx1ZSBhbmQga2V5IG9mIHRoZSBtaW4gdmFsdWUuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbWluIHZhbHVlIGluIHRoZSBvYmplY3QuXG4gICAqIElmIG5vIGNhbGxiYWNrIGlzIHByZXNlbnQgY29tcGFyaXNvbiBpcyBiZXR3ZWVuIHZhbHVlcyBvZiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLm1pbigpOyAgICAgICAgICAgICAgICAgICAgIC8vIHsga2V5OiAnYScsIHZhbHVlOiAxIH1cbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5taW4oKHZhbHVlKSA9PiA0IC0gdmFsdWUpOyAvLyB7IGtleTogJ2MnLCB2YWx1ZTogMSB9XG4gICAqIG5ldyBTdXBlcih7IGE6ICdhJywgYjogJ2InLCBjOiAnYycgfSkubWluKCk7ICAgICAgICAgICAgICAgLy8geyBrZXk6IG51bGwsIHZhbHVlOiBJbmZpbml0eSB9XG4gICAqL1xuICBtaW4oY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjbWluJyk7XG5cbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKG1pbiwgdmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBOdW1iZXIoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpO1xuXG4gICAgICBpZiAodmFsIDwgbWluLnZhbHVlKSB7XG4gICAgICAgIG1pbi5rZXkgPSBrZXk7XG4gICAgICAgIG1pbi52YWx1ZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LCB7IGtleTogbnVsbCwgdmFsdWU6IEluZmluaXR5IH0pLiQ7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNvYmplY3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdENhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R8Kn0gW29iamVjdCA9IHt9XSAtIE9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gV3JhcCBvZiB0aGUgbmV3IG9iamVjdC5cbiAgICogQGRlc2NyaXB0aW9uIFR5cGUgb2Yge0BsaW5rIFN1cGVyI3JlZHVjZX0uXG4gICAqIFRoZSBvYmplY3QgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IGludG8gdGhlIGNhbGxiYWNrLiBUaGUgb3V0cHV0IGlzIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyIH0pLm9iamVjdCgob2JqZWN0LCB2YWx1ZSwga2V5KSA9PiB7XG4gICAqICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICogICBvYmplY3Rba2V5ICsga2V5XSA9IHZhbHVlICogMjtcbiAgICogfSkuJDsgLy8geyBhOiAxLCBhYTogMiwgYjogMiwgYmI6IDQgfVxuICAgKi9cbiAgb2JqZWN0KGNhbGxiYWNrLCBvYmplY3QgPSB7fSkge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI29iamVjdCcpO1xuXG4gICAgaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSwga2V5LCBvYmopID0+IHtcbiAgICAgIGNhbGxiYWNrKG9iamVjdCwgdmFsdWUsIGtleSwgb2JqKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBEKG9iamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNwcm9wXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsICo+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGFuIGFzc2lnbmVkIG9iamVjdC5cbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmdcbiAgICogdGhpcyBoYXMgdG8gYmUgYW4gYXNzaWduZWQgdmFsdWUgaWYgaXQncyBwcmVzZW50LlxuICAgKiBAcmV0dXJucyB7RFdyYXB8Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3MgYSBzZXR0ZXIgb3IgYSB2YWx1ZSBpZiBnZXR0ZXIuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgYW5kIHNldHRpbmcgcHJvcGVydGllcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5wcm9wKCdhJyk7ICAgICAgICAgICAgICAvLyAxXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkucHJvcCgnYScsIDcpLiQ7ICAgICAgICAgLy8geyBhOiA3LCBiOiAyLCBjOiAzIH1cbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5wcm9wKHsgYTogNywgYjogOCB9KS4kOyAvLyB7IGE6IDcsIGI6IDgsIGM6IDMgfVxuICAgKi9cbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuJCA/IHRoaXMuJFtwcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXNzaWduKHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI3Byb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIFByb3BlcnR5IG9mIHRoZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSBQcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQGRlc2NyaXB0b3IgU3lub255bSBmb3JcbiAgICogW09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3J9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxIH0pLnByb3BlcnR5RGVzY3JpcHRvcignYScpO1xuICAgKiAvLyB7XG4gICAqIC8vICAgdmFsdWU6IDEsXG4gICAqIC8vICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogLy8gICB3cml0YWJsZTogdHJ1ZSxcbiAgICogLy8gICBjb25maWd1cmFibGU6IHRydWVcbiAgICogLy8gfVxuICAgKi9cbiAgcHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuXG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjcHJvcGVydHlOYW1lc1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gRC1XcmFwIG9mIHRoZSBuYW1lcyBhcnJheS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlOYW1lc1xuICAgKiBAZGVzY3JpcHRvciBTeW5vbnltIGZvclxuICAgKiBbT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eU5hbWVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiB9KS5kZWZpbmUoJ2MnLCB7IHZhbHVlOiAzIH0pLiQ7IC8vIFsnYScsICdiJywgJ2MnXVxuICAgKi9cbiAgcHJvcGVydHlOYW1lcygpIHtcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG5cbiAgICByZXR1cm4gRChpc09iamVjdChvYmplY3QpID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSA6IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI3Byb3BlcnR5U3ltYm9sc1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gRC1XcmFwIG9mIHRoZSBuYW1lcyBhcnJheS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlTeW1ib2xzXG4gICAqIEBkZXNjcmlwdG9yIFN5bm9ueW0gZm9yXG4gICAqIFtPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlTeW1ib2xzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgW1N5bWJvbCgnZm9vJyldOiAxIH0pLmRlZmluZShTeW1ib2woJ2JhcicpLCB7IHZhbHVlOiAyIH0pLiQ7IC8vIFtTeW1ib2woJ2ZvbycpLCBTeW1ib2woJ2JhcicpXVxuICAgKi9cbiAgcHJvcGVydHlTeW1ib2xzKCkge1xuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcblxuICAgIHJldHVybiBEKGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkgOiBbXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNwcm90b1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gW3Byb3RvXSAtIElmIGl0J3MgcHJlc2VudCBpdCdzIHNldCBhcyBhIHByb3RvdHlwZSB0byB0aGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RFdyYXB9IEluIGdldHRlciBtb2RlIHJldHVybnMgd3JhcCBvZiB0aGUgcHJvdG90eXBlIGFuZCBpbiBzZXR0ZXIgbW9kZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBib3RoXG4gICAqIFtPYmplY3QuZ2V0UHJvdG90eXBlT2Zde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRQcm90b3R5cGVPZn1cbiAgICogYW5kXG4gICAqIFtPYmplY3Quc2V0UHJvdG90eXBlT2Zde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9zZXRQcm90b3R5cGVPZn0uXG4gICAqL1xuICBwcm90byhwcm90bykge1xuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcbiAgICBjb25zdCBpc0NvbnRleHRPYmplY3QgPSAhaXNOaWwob2JqZWN0KTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNDb250ZXh0T2JqZWN0ICYmIChpc09iamVjdChwcm90bykgfHwgaXNOdWxsKHByb3RvKSkpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iamVjdCwgcHJvdG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNDb250ZXh0T2JqZWN0ID8gbmV3IFN1cGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKSA6IG5ldyBTdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjcmVkdWNlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtSZWR1Y2VDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIFJldHVybiB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIG5leHQgY2FsbGJhY2sgY2FsbC5cbiAgICogQHBhcmFtIHsqfSBbSVYgPSA8Zmlyc3QgdmFsdWU+fHVuZGVmaW5lZF0gLSBJbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gTW9kaWZpZWQgSVYuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIG1vZGlmaWVkIElWLiBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIG5vdCBwcmVzZW50IGZpcnN0IHZhbHVlIGluIHRoZSBvYmplY3QgaXMgdGFrZW5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlICogdmFsdWUsIDApOyAvLyAxNFxuICAgKi9cbiAgcmVkdWNlKGNhbGxiYWNrLCBJVikge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI3JlZHVjZScpO1xuXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuXG4gICAgbGV0IHN0YXJ0S2V5O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBzdGFydEtleSA9IGtleTtcbiAgICAgICAgSVYgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleSAhPT0gc3RhcnRLZXkpIHtcbiAgICAgICAgSVYgPSBjYWxsYmFjayhJViwgdmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBJVjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI3NldFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYSBzZXR0ZXJzIG9iamVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHRlcl0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGlzIGhhcyB0byBiZSBhIHNldHRlciBmdW5jdGlvbi5cbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZmluaW5nIHNldHRlcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG9iamVjdCA9IG5ldyBTdXBlcih7fSlcbiAgICogICAuZ2V0KCdwdWJsaWMnLCBmdW5jdGlvbiAoKSB7XG4gICAqICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZTtcbiAgICogICB9KVxuICAgKiAgIC5zZXQoJ3B1YmxpYycsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgKiAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICogICAgICAgdGhpcy5fcHJpdmF0ZSA9IHZhbHVlO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBvYmplY3QucHJvcCgncHVibGljJywgJzEnKS4kOyAvLyB7IHB1YmxpYzogdW5kZWZpbmVkIH1cbiAgICogb2JqZWN0LnByb3AoJ3B1YmxpYycsIDEpLiQ7ICAgLy8geyBwdWJsaWM6IDEsIF9wcml2YXRlOiAxIH1cbiAgICpcbiAgICogbmV3IFN1cGVyKHt9KS5zZXQoe1xuICAgKiAgIHB1YmxpYyh2YWx1ZSkge1xuICAgKiAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICogICAgICAgdGhpcy5fcHJpdmF0ZSA9IHZhbHVlO1xuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqL1xuICBzZXQocHJvcGVydHksIHNldHRlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiBzZXR0ZXIgfTtcbiAgICB9XG5cbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XG5cbiAgICBpdGVyYXRlKGlzT2JqZWN0KG9iamVjdCkgJiYgbmV3IFN1cGVyKHByb3BlcnR5KS4kLCAoc2V0dGVyLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgc2V0OiBzZXR0ZXIgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI3NvbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogSWYgcmV0dXJucyB0cnV0aHkgaXRlcmF0aW9uIHN0b3BzIGFuZCBpZiBmYWxzZXkgaXQgY29udGludWVzLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRydWUgaWYgc29tZSBvZiB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLiBPdGhlcndpc2UgZmFsc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuc29tZSgodmFsdWUpID0+IHZhbHVlID4gNCk7IC8vIGZhbHNlXG4gICAqIG5ldyBTdXBlcih7fSkuc29tZSgoKSA9PiB0cnVlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gICAqL1xuICBzb21lKGNhbGxiYWNrID0gQm9vbGVhbikge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI3NvbWUnKTtcblxuICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciNzdHJpY3RFcXVhbHNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp9IFtvYmplY3RdIC0gT2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgb3Igbm90LlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cnVlIGlmIG9iamVjdHMgYXJlIGVxdWFsIHVzaW5nICc9PT0nIG9wZXJhdG9yIGFuZCBmYWxzZSBpZiBub3QuXG4gICAqIE5hTnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgc3RyaWN0IGVxdWFsLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoMykuc3RyaWN0RXF1YWxzKCczJyk7ICAgLy8gZmFsc2VcbiAgICogbmV3IFN1cGVyKE5hTikuc3RyaWN0RXF1YWxzKE5hTik7IC8vIHRydWVcbiAgICovXG4gIHN0cmljdEVxdWFscyhvYmplY3QpIHtcbiAgICBjb25zdCBvID0gdGhpcy4kO1xuXG4gICAgb2JqZWN0ID0gbmV3IFN1cGVyKG9iamVjdCkuJDtcblxuICAgIHJldHVybiBvID09PSBvYmplY3QgfHwgKGlzTmFOKG8pICYmIGlzTmFOKG9iamVjdCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjc3VtXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gbnVsbF0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFN1bS5cbiAgICogQGRlc2NyaXB0aW9uIFR5cGUgb2Yge0BsaW5rIFN1cGVyI3JlZHVjZX0uXG4gICAqIElmIHRoZSBjYWxsYmFjayBpcyBwcmVzZW50IGl0J3MgdXNlZCBmb3Igc3VtbWluZy4gSWYgbm90IHRoZSB2YWx1ZSBpcyB1c2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnN1bSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2XG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuc3VtKCh2YWx1ZSkgPT4gdmFsdWUgKiB2YWx1ZSk7IC8vIDE0XG4gICAqL1xuICBzdW0oY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjc3VtJyk7XG5cbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoKHN1bSwgdmFsdWUsIGtleSwgb2JqZWN0KSA9PiAoXG4gICAgICBzdW0gKyBOdW1iZXIoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpXG4gICAgKSwgMCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIFN1cGVyI3RvU3RyaW5nVGFnXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRvU3RyaW5nIHRhZyBvZiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoe30pLnRvU3RyaW5nVGFnOyAvLyAnT2JqZWN0J1xuICAgKiBuZXcgU3VwZXIoW10pLnRvU3RyaW5nVGFnOyAvLyAnQXJyYXknXG4gICAqIG5ldyBTdXBlcigxKS50b1N0cmluZ1RhZzsgIC8vICdOdW1iZXInXG4gICAqL1xuICBnZXQgdG9TdHJpbmdUYWcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nVGFnKHRoaXMuJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBTdXBlciN0eXBlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbXCJ0eXBlb2ZcIiBvcGVyYXRvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL2luc3RhbmNlb2Z9Li5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN1cGVyKHt9KS50eXBlOyAgIC8vICdvYmplY3QnXG4gICAqIG5ldyBTdXBlcigxKS50eXBlOyAgICAvLyAnbnVtYmVyJ1xuICAgKiBuZXcgU3VwZXIoJzEnKS50eXBlOyAgLy8gJ3N0cmluZydcbiAgICogbmV3IFN1cGVyKHRydWUpLnR5cGU7IC8vICdib29sZWFuJ1xuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLiQ7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdXBlciN2YWx1ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCAqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhIHZhbHVlcyBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsICo+fSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhpcyBoYXMgdG8gYmUgYSB2YWx1ZSB0byBiZSBzZXQuXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWZpbmluZyBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlLCBub24tY29uZmlndXJhYmxlIHZhbHVlcy5cbiAgICogU3lub255bSBmb3Igb2JqZWN0LmRlZmluZShwcm9wZXJ0eSwgeyB2YWx1ZTogdmFsdWUgfSkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7fSkudmFsdWUoJ2EnLCAxKS4kOyAvLyB7IGE6IDEgfVxuICAgKiBuZXcgU3VwZXIoe30pLnZhbHVlKHtcbiAgICogICBhOiAxXG4gICAqIH0pLiQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7IGE6IDEgfVxuICAgKi9cbiAgdmFsdWUocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xuXG4gICAgaXRlcmF0ZShpc09iamVjdChvYmplY3QpICYmIG5ldyBTdXBlcihwcm9wZXJ0eSkuJCwgKHZhbHVlLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgdmFsdWUgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN1cGVyI3ZhbHVlc1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gQSB3cmFwIG9mIHRoZSB2YWx1ZXMgYXJyYXkuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIEQtV3JhcCBvZiB0aGUgdmFsdWVzIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnZhbHVlcygpLiQ7IC8vIFsxLCAyLCAzXVxuICAgKiBuZXcgU3VwZXIobnVsbCkudmFsdWVzKCkuJDsgICAgICAgICAgICAgICAgIC8vIFtdXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGl0ZXJhdGUodGhpcy4kLCAodmFsdWUpID0+IHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEQoYXJyYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjd29yZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDb25jYXRlbmF0ZWQgc3RyaW5nLlxuICAgKiBAZGVzY3JpcHRpb24gVHlwZSBvZiB7QGxpbmsgU3VwZXIjcmVkdWNlfS5cbiAgICogSWYgdGhlIGNhbGxiYWNrIGlzIHByZXNlbnQgaXQncyB1c2VkIGZvciBjb25jYXRlbmF0aW5nLiBJZiBub3QgdGhlIHZhbHVlIGlzIHVzZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkud29yZCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTIzJ1xuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLndvcmQoKHZhbHVlKSA9PiB2YWx1ZSArIHZhbHVlKTsgLy8gJzExMjIzMydcbiAgICovXG4gIHdvcmQoY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjd29yZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKCh3b3JkLCB2YWx1ZSwga2V5LCBvYmplY3QpID0+IChcbiAgICAgIHdvcmQgKyBTdHJpbmcoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpXG4gICAgKSwgJycpO1xuICB9XG59XG5cbmRlZmluZVByb3BlcnRpZXMoU3VwZXIucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnU3VwZXInXG59KTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVlcEFzc2lnblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IC0gT2JqZWN0IHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gYXNzaWduIHByb3BlcnRpZXMgZnJvbS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCwgb2JqZWN0KSB7XG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmIChpc1ByaW1pdGl2ZSh0YXJnZXRba2V5XSkgfHwgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlZXBDbG9uZSh2YWx1ZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUHJpbWl0aXZlKHRhcmdldFtrZXldKSkge1xuICAgICAgZGVlcEFzc2lnbih0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZXBDbG9uZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNsb25lLlxuICogQGRlc2NyaXB0aW9uIERvZXMgdGhlIGRlZXAgY2xvbmluZy5cbiAqL1xuZnVuY3Rpb24gZGVlcENsb25lKG9iamVjdCkge1xuICBjb25zdCBjbG9uZSA9IGNsb25lU3dpdGNoZXIob2JqZWN0LCBbb2JqZWN0LCB0cnVlXSk7XG5cbiAgaWYgKGNsb25lICE9PSBvYmplY3QpIHtcbiAgICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGNsb25lW2tleV0gPSBkZWVwQ2xvbmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBkZWVwRXF1YWxcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG8xIC0gRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG8yIC0gU2Vjb25kIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJpY3QgLSBJZiBjb21wYXJpc29uIHNob3VsZCBiZSBzdHJpY3Qgb3Igbm90LlxuICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG9iamVjdCBhcmUgZGVlcCBlcXVhbCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChvMSwgbzIsIHN0cmljdCkge1xuICBpZiAobzEgPT09IG8yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNOYU4obzEpICYmIGlzTmFOKG8yKSAmJiBpc1ByaW1pdGl2ZShvMSkgJiYgaXNQcmltaXRpdmUobzIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNOYU4obzEpIHx8IGlzTmFOKG8yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1ByaW1pdGl2ZShvMSkgfHwgaXNQcmltaXRpdmUobzIpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IG8xID09PSBvMiA6IG8xID09IG8yO1xuICB9XG5cbiAgaWYgKGlzRGF0ZShvMSkgJiYgaXNEYXRlKG8yKSkge1xuICAgIHJldHVybiBvMS5nZXRUaW1lKCkgPT09IG8yLmdldFRpbWUoKTtcbiAgfVxuXG4gIGlmIChpc0RhdGUobzEpIHx8IGlzRGF0ZShvMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNSZWdFeHAobzEpICYmIGlzUmVnRXhwKG8yKSkge1xuICAgIHJldHVybiBvMS5zb3VyY2UgPT09IG8yLnNvdXJjZSAmJlxuICAgICAgbzEudG9TdHJpbmcoKS5tYXRjaCgvW2dpbXV5XSokLylbMF0gPT09IG8yLnRvU3RyaW5nKCkubWF0Y2goL1tnaW11eV0qJC8pWzBdICYmXG4gICAgICBvMS5sYXN0SW5kZXggPT09IG8yLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChpc1JlZ0V4cChvMSkgfHwgaXNSZWdFeHAobzIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCghaXNQbGFpbk9iamVjdChvMSkgJiYgIWlzQXJyYXkobzEpKSB8fCAoIWlzUGxhaW5PYmplY3QobzIpICYmICFpc0FycmF5KG8yKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvMSk7XG4gIGNvbnN0IHAyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG8xKTtcblxuICBpZiAoT2JqZWN0LmtleXMobzEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMobzIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwMSAmJiBwMiAmJiAodG9TdHJpbmdUYWcocDEuY29uc3RydWN0b3IpICE9PSB0b1N0cmluZ1RhZyhwMi5jb25zdHJ1Y3RvcikpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdGUobzEsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIG8yKSB8fCAhZGVlcEVxdWFsKHZhbHVlLCBvMltrZXldLCBzdHJpY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSAhPT0gZmFsc2U7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZXBFdmVyeVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gKiBJZiByZXR1cm5zIHRydXRoeSB0aGUgaXRlcmF0aW9uIGdvZXMgb24gYW5kIGlmIG5vdCBpdCBzdG9wcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBkZWVwRXZlcnkob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xuICBjb25zdCBlbmQgPSBuID09PSAxO1xuXG4gIHJldHVybiBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcblxuICAgIGlmIChcbiAgICAgIGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSlcbiAgICAgICAgPyAhY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0LCBuZXdUcmVlKVxuICAgICAgICA6ICFkZWVwRXZlcnkodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pICE9PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVlcEZpbHRlclxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gKiBJZiByZXR1cm5zIHRydXRoeSB0aGUgZWxlbWVudCBpcyBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0IGFuZCBpZiBub3QgaXQncyBleGNsdWRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBGaWx0ZXJlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZXBGaWx0ZXIob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xuICBjb25zdCBhcnJheSA9IGlzQXJyYXlMaWtlKG9iamVjdCk7XG4gIGNvbnN0IG51bCA9IGlzTmlsKG9iamVjdCk7XG4gIGNvbnN0IG8gPSBhcnJheSA/IFtdIDogbnVsID8gb2JqZWN0IDoge307XG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XG5cbiAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XG5cbiAgICBpZiAoKGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSkpICYmIGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSkpIHtcbiAgICAgIGlmIChhcnJheSkge1xuICAgICAgICBvLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWVuZCkge1xuICAgICAgY29uc3QgZmlsdGVyZWQgPSBkZWVwRmlsdGVyKHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIG5ld1RyZWUpO1xuXG4gICAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgby5wdXNoKGZpbHRlcmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvW2tleV0gPSBmaWx0ZXJlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGFycmF5KSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoID8gbyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghbnVsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmxlbmd0aCA/IG8gOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVlcEZpbmRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxuICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgbm90IGl0IGNvbnRpbnVlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtUcmVlfG51bGx9IC0gSWYgZm91bmQgdGhlIHdob2xlIHRyZWUgaXMgcmV0dXJuZWQgYW5kIGlmIG5vdCBpdCdzIG51bGwgd2hhdCdzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBkZWVwRmluZChvYmplY3QsIGNhbGxiYWNrLCBuLCB0cmVlKSB7XG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XG5cbiAgcmV0dXJuIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XG4gICAgY29uc3QgbmV3VHJlZSA9IFt7IGtleSwgdmFsdWUgfV0uY29uY2F0KHRyZWUpO1xuXG4gICAgaWYgKGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpKSB7XG4gICAgICAgIHJldHVybiBuZXdUcmVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZGVlcEZpbmQodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSkgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVlcEZvckVhY2hcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlZXBGb3JFYWNoKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcblxuICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcblxuICAgIGlmIChlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWVwRm9yRWFjaCh2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBkZWVwRm9yRWFjaEVudHJ5XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWVwRm9yRWFjaEVudHJ5KG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcblxuICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcblxuICAgIGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSk7XG5cbiAgICBpZiAoIWVuZCAmJiAhaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICBkZWVwRm9yRWFjaEVudHJ5KHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIG5ld1RyZWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZXBGcmVlemVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBmcmVlemUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVlcEZyZWV6ZShvYmplY3QpIHtcbiAgT2JqZWN0LmZyZWV6ZShvYmplY3QpO1xuICBpdGVyYXRlKG9iamVjdCwgZGVlcEZyZWV6ZSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRlZXBNYXBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxuICogUmV0dXJuZWQgdmFsdWUgaXMgdXNlZCB0byBjcmVhdGUgdG8gbmV3IG9iamVjdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBOZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWVwTWFwKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcbiAgY29uc3QgbyA9IGlzQXJyYXlMaWtlKG9iamVjdCkgPyBbXSA6IGlzTmlsKG9iamVjdCkgPyBvYmplY3QgOiB7fTtcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcblxuICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcblxuICAgIG9ba2V5XSA9IGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSlcbiAgICAgID8gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0LCBuZXdUcmVlKVxuICAgICAgOiBkZWVwTWFwKHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIG5ld1RyZWUpO1xuICB9KTtcblxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVlcFJlZHVjZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RGVlcFJlZHVjZUNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gKiBSZXR1cm5lZCB2YWx1ZSBpcyB1c2VkIHRvIGNyZWF0ZSB0byBuZXcgb2JqZWN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXJ0IC0gSWYgY2FsbGJhY2sgd2FzIGNhbGxlZCBhbHJlYWR5IG9yIG5vdC5cbiAqIEBwYXJhbSB7eyBJVjogKiB9fHVuZGVmaW5lZH0gSVYgLSBJZiBjYWxsYmFjayB3YXMgY2FsbGVkIGFscmVhZHkgb3Igbm90LlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHt7IElWOiAqIH19IFRyYW5zZm9ybWVkIElWLlxuICovXG5mdW5jdGlvbiBkZWVwUmVkdWNlKG9iamVjdCwgY2FsbGJhY2ssIG4sIHN0YXJ0LCBJViwgdHJlZSkge1xuICBjb25zdCBlbmQgPSBuID09PSAxO1xuXG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XG4gICAgaWYgKCFJViAmJiAoZW5kIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkgJiYgIXN0YXJ0KSB7XG4gICAgICBJViA9IHsgSVY6IHZhbHVlIH07XG4gICAgICBzdGFydCA9IHRydWU7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XG5cbiAgICBJViA9IGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSlcbiAgICAgID8geyBJVjogY2FsbGJhY2soSVYuSVYsIHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSkgfVxuICAgICAgOiBkZWVwUmVkdWNlKHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIHN0YXJ0LCBJViwgbmV3VHJlZSk7XG4gIH0pO1xuXG4gIHJldHVybiBJVjtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVlcFNvbWVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxuICogSWYgcmV0dXJucyB0cnV0aHkgdGhlIGl0ZXJhdGlvbiBzdG9wcyBhbmQgaWYgbm90IGl0IGNvbnRpbnVlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHNvbWUgb2YgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZGVlcFNvbWUob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xuICBjb25zdCBlbmQgPSBuID09PSAxO1xuXG4gIHJldHVybiBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcblxuICAgIGlmIChcbiAgICAgIGVuZCB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSlcbiAgICAgICAgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpXG4gICAgICAgIDogZGVlcFNvbWUodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgfHwgZmFsc2U7XG59XG5cbmNvbnN0cnVjdG9yc1swXS5wdXNoKHtcbiAgY2hlY2s6ICgpID0+IHRydWUsXG4gIGNsczogU3VwZXJcbn0pO1xuXG5leHBvcnQgeyBTdXBlciB9O1xuIiwiLyoqXG4gKiBAbW9kdWxlIEZ1bmNcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEZ1bmMgY2xhc3MuXG4gKi9cblxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcbmltcG9ydCB7IFByb21pc2UgfSBmcm9tICcuL1Byb21pc2UnO1xuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgdmFsaWRhdGUsIHRvQXJyYXksIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllcywgaXRlcmF0ZSB9IGZyb20gJy4vaGVscGVycyc7XG5cbi8qKlxuICogQGNhbGxiYWNrIEJlZm9yZU1pZGRsZXdhcmVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBQcmV2aW91cyBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge0Z1bmN9IGZ1bmMgLSBUaGlzIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FycmF5fSAtIE5ldyBhcmd1bWVudHMuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQWZ0ZXJNaWRkbGV3YXJlXG4gKiBAcGFyYW0geyp9IHJldHVyblZhbHVlIC0gUHJldmlvdXMgcmV0dXJuIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jfSBmdW5jIC0gVGhpcyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHsqfSAtIE5ldyByZXR1cm4gdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRnVuY1xuICogQGV4dGVuZHMgU3VwZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmdW5jID0gZnVuY3Rpb24gKCkge31dIC0gRnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtGdW5jfSBJbnN0YW5jZSBvZiBGdW5jLlxuICogQGRlc2NyaXB0aW9uIEEgd3JhcCBvZiBhIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoTWF0aC5tYXgpO1xuICpcbiAqIGZ1bmMoMSwgNCwgLTIsIDUpOyAvLyA1XG4gKi9cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBTdXBlciB7XG4gIGNvbnN0cnVjdG9yKGZ1bmMgPSAoKSA9PiB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBmdW5jdGlvbiBwcm94eSgpIHtcbiAgICAgIGlmICgrK3Byb3h5LiQkLmNhbGxlZCA8IHByb3h5LiQkLmNhbkJlQ2FsbGVkKSB7XG4gICAgICAgIGNvbnN0IHsgYmVmb3JlLCBhZnRlciwgc3luYywgY29udGV4dExvY2tlZCB9ID0gcHJveHkuJCQ7XG4gICAgICAgIGxldCB7IGNvbnRleHQsIGFyZ3MgfSA9IHByb3h5LiQkO1xuICAgICAgICBsZXQgcmV0O1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0TG9ja2VkID8gY29udGV4dCA6IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KHRvQXJyYXkoYXJndW1lbnRzKSk7XG5cbiAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICBpdGVyYXRlKGJlZm9yZSwgKG1pZGRsZXdhcmUpID0+IHtcbiAgICAgICAgICAgIGFyZ3MgPSBtaWRkbGV3YXJlLmNhbGwoY29udGV4dCwgdG9BcnJheShhcmdzKSwgcHJveHkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0ID0gZnVuYy5hcHBseShjb250ZXh0LCB0b0FycmF5KGFyZ3MpKTtcblxuICAgICAgICAgIGl0ZXJhdGUoYWZ0ZXIsIChtaWRkbGV3YXJlKSA9PiB7XG4gICAgICAgICAgICByZXQgPSBtaWRkbGV3YXJlLmNhbGwoY29udGV4dCwgcmV0LCBwcm94eSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYXJncyk7XG5cbiAgICAgICAgaXRlcmF0ZShiZWZvcmUsIChtaWRkbGV3YXJlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoYXJncykgPT4gbWlkZGxld2FyZS5jYWxsKGNvbnRleHQsIHRvQXJyYXkoYXJncyksIHByb3h5KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKGFyZ3MpID0+IGZ1bmMuYXBwbHkoY29udGV4dCwgdG9BcnJheShhcmdzKSkpO1xuXG4gICAgICAgIGl0ZXJhdGUoYWZ0ZXIsIChtaWRkbGV3YXJlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigocmV0KSA9PiBtaWRkbGV3YXJlLmNhbGwoY29udGV4dCwgcmV0LCBwcm94eSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEZ1bmMjJCRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBhZnRlciAtIEFmdGVyIG1pZGRsZXdhcmUgYXJyYXkuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gYXJncyAtIExvY2tlZCBhbmQgYm91bmQgYXJndW1lbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFyZ3NMb2NrZWQgLSBMb2NrZWQgYXJndW1lbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJlZm9yZSAtIEJlZm9yZSBtaWRkbGV3YXJlIGFycmF5LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjYWxsZWQgLSBIb3cgbWFueSB0aW1lcyB0aGUgZnVuY3Rpb24gd2FzIGNhbGxlZC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY2FuQmVDYWxsZWQgLSBIb3cgbWFueSB0aW1lcyB0aGUgZnVuY3Rpb24gY2FuIGJlIGFjdHVhbGx5IGNhbGxlZC5cbiAgICAgKiBAcHJvcGVydHkgeyp9IGNvbnRleHQgLSBMb2NrZWQgb3IgYm91bmQgY29udGV4dC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbnRleHRMb2NrZWQgLSBJcyBjb250ZXh0IGxvY2tlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzeW5jIC0gSXMgZnVuY3Rpb24gc3luY2hyb25vdXMgb3Igbm90LlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb25maWcgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICckJCcsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGFmdGVyOiBbXSxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGFyZ3NMb2NrZWQ6IFtdLFxuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBjYWxsZWQ6IDAsXG4gICAgICAgIGNhbkJlQ2FsbGVkOiBJbmZpbml0eSxcbiAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgY29udGV4dExvY2tlZDogZmFsc2UsXG4gICAgICAgIHN5bmM6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBGdW5jIyRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hbCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICckJywgeyB2YWx1ZTogZnVuYyB9KTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJveHksIEZ1bmMucHJvdG90eXBlKTtcblxuICAgIHJldHVybiBwcm94eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjYWZ0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0FmdGVyTWlkZGxld2FyZX0gbWlkZGxld2FyZSAtIEFmdGVyIG1pZGRsZXdhcmUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYWZ0ZXJBbGwgPSB0cnVlXSAtIEJvb2xlYW4gcGFyYW1ldGVyIHdoZXJlIHRvIHB1dCBtaWRkbGV3YXJlLlxuICAgKiBUcnV0aHkgcGFyYW1ldGVyIHN0YW5kcyBmb3IgXCJ0byB0aGUgZW5kXCIgYW5kIGZhbHNleSBmb3IgXCJ0byB0aGUgYmVnaW5uaW5nXCIuXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGFmdGVyIG1pZGRsZXdhcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpXG4gICAqICAgLmFmdGVyKChyZXN1bHQpID0+IHJlc3VsdCAqIHJlc3VsdCk7XG4gICAqXG4gICAqIGZ1bmMoNCk7ICAvLyAyNVxuICAgKiBmdW5jKC00KTsgLy8gOVxuICAgKi9cbiAgYWZ0ZXIobWlkZGxld2FyZSwgYWZ0ZXJBbGwgPSB0cnVlKSB7XG4gICAgdmFsaWRhdGUoW21pZGRsZXdhcmVdLCBbJ2Z1bmN0aW9uJ10sICdGdW5jI2FmdGVyJyk7XG5cbiAgICBjb25zdCB7IGFmdGVyIH0gPSB0aGlzLiQkO1xuXG4gICAgaWYgKGFmdGVyQWxsKSB7XG4gICAgICBhZnRlci5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlci51bnNoaWZ0KG1pZGRsZXdhcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyNhcHBseVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gQ29udGV4dCB0byBjYWxsIHdpdGguXG4gICAqIEBwYXJhbSB7KEFycmF5fEFyZ3VtZW50cyl9IFthcmdzXSAtIEFyZ3VtZW50cyB0byBjYWxsIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gb2YgZnVuY3Rpb24gY2FsbC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9hcHBseVxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0Z1bmN0aW9uI2FwcGx5XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9hcHBseX0uXG4gICAqL1xuICBhcHBseShjb250ZXh0LCBhcmdzKSB7XG4gICAgcmV0dXJuICgoKSA9PiB7fSkuYXBwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjYXN5bmNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIHN5bmNocm9ub3VzIG9yIG5vdC5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSBmdW5jdGlvbiBzaG91bGQgYmUgc3luY2hyb25vdXMgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKS5hc3luYygpO1xuICAgKlxuICAgKiBmdW5jKDQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIDVcbiAgICogfSk7XG4gICAqL1xuICBhc3luYyhjb25kaXRpb24gPSB0cnVlKSB7XG4gICAgdGhpcy4kJC5zeW5jID0gIWNvbmRpdGlvbjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyNiZWZvcmVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0JlZm9yZU1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBCZWZvcmUgbWlkZGxld2FyZS5cbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtiZWZvcmVBbGwgPSB0cnVlXSAtIEJvb2xlYW4gcGFyYW1ldGVyIHdoZXJlIHRvIHB1dCBtaWRkbGV3YXJlLlxuICAgKiBUcnV0aHkgcGFyYW1ldGVyIHN0YW5kcyBmb3IgXCJ0byB0aGUgYmVnaW5uaW5nXCIgYW5kIGZhbHNleSBmb3IgXCJ0byB0aGUgZW5kXCIuXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGJlZm9yZSBtaWRkbGV3YXJlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKVxuICAgKiAgIC5iZWZvcmUoKFthcmddKSA9PiBbYXJnICogYXJnXSk7XG4gICAqXG4gICAqIGZ1bmMoNCk7IC8vIDE3XG4gICAqIGZ1bmMoMyk7IC8vIDEwXG4gICAqL1xuICBiZWZvcmUobWlkZGxld2FyZSwgYmVmb3JlQWxsID0gdHJ1ZSkge1xuICAgIHZhbGlkYXRlKFttaWRkbGV3YXJlXSwgWydmdW5jdGlvbiddLCAnRnVuYyNiZWZvcmUnKTtcblxuICAgIGNvbnN0IHsgYmVmb3JlIH0gPSB0aGlzLiQkO1xuXG4gICAgaWYgKGJlZm9yZUFsbCkge1xuICAgICAgYmVmb3JlLnVuc2hpZnQobWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyNiaW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dCB0byBiaW5kLlxuICAgKiBAcGFyYW0gey4uLihBcnJheXxBcmd1bWVudHN8Kil9IGFyZ3MgLSBBcmd1bWVudHMgdG8gYmluZC5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIENvbXBvc2l0aW9uIG9mIHtAbGluayBGdW5jI2JpbmRDb250ZXh0fSBhbmQge0BsaW5rIEZ1bmMjYmluZEFyZ3N9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICogICByZXR1cm4gdGhpcy5hICsgYSArIGI7XG4gICAqIH0pLmJpbmQoeyBhOiAyIH0sIDEpO1xuICAgKlxuICAgKiBmdW5jKDEpOyAvLyA0XG4gICAqIGZ1bmMoMyk7IC8vIDZcbiAgICovXG4gIGJpbmQoY29udGV4dCwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAuYmluZENvbnRleHQoY29udGV4dClcbiAgICAgIC5iaW5kQXJncyhhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjYmluZEFyZ3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHMpfSBhcmdzIC0gQXJndW1lbnRzIHRvIGJpbmQuXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBCaW5kcyBhcmd1bWVudHMgaW4gYWRkaXRpb24gdG8gYWxyZWFkeSBsb2NrZWQgYW5kIGJvdW5kIG9uZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoLi4uYXJncykgPT4ge1xuICAgKiAgIGxldCBzdW0gPSAwO1xuICAgKlxuICAgKiAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgKiAgICAgc3VtICs9IGFyZ3NbaV07XG4gICAqICAgfVxuICAgKlxuICAgKiAgIHJldHVybiBzdW07XG4gICAqIH0pO1xuICAgKlxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyA2XG4gICAqXG4gICAqIGZ1bmMuYmluZEFyZ3MoWzRdKTtcbiAgICpcbiAgICogZnVuYygxLCAyLCAzKTsgLy8gMTBcbiAgICpcbiAgICogZnVuYy5iaW5kQXJncyhbNV0pO1xuICAgKlxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxNVxuICAgKi9cbiAgYmluZEFyZ3MoYXJncykge1xuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xuXG4gICAgZnVuYy5hcmdzID0gZnVuYy5hcmdzLmNvbmNhdCh0b0FycmF5KGFyZ3MpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyNiaW5kQ29udGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgdG8gYmluZC5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEJpbmQgbmV3IGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBsb2NrZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhmdW5jdGlvbiAoKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuYTtcbiAgICogfSkuYmluZENvbnRleHQoeyBhOiAxIH0pO1xuICAgKlxuICAgKiBmdW5jKCk7IC8vIDFcbiAgICpcbiAgICogZnVuYy5iaW5kQ29udGV4dCh7IGE6IDIgfSk7XG4gICAqXG4gICAqIGZ1bmMoKTsgLy8gMlxuICAgKi9cbiAgYmluZENvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xuXG4gICAgaWYgKCFmdW5jLmNvbnRleHRMb2NrZWQpIHtcbiAgICAgIGZ1bmMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBGdW5jI2NhbGxcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIENvbnRleHQgdG8gY2FsbCB3aXRoLlxuICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIEFyZ3VtZW50cyB0byBjYWxsIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gb2YgZnVuY3Rpb24gY2FsbC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9jYWxsXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRnVuY3Rpb24jY2FsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbH0uXG4gICAqL1xuICBjYWxsKGNvbnRleHQsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gKCgpID0+IHt9KS5jYWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciB7TnVtYmVyfSBGdW5jI2NhbGxlZFxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBob3cgbWFueSB0aW1lcyB0aGUgZnVuY3Rpb24gd2FzIGNhbGxlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKChhKSA9PiBhICsgMSk7XG4gICAqXG4gICAqIGZ1bmMoKTtcbiAgICogZnVuYygpO1xuICAgKlxuICAgKiBmdW5jLmNhbGxlZCAvLyAyXG4gICAqL1xuICBnZXQgY2FsbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiQkLmNhbGxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjY2FuQmVDYWxsZWRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZXMgLSBOdW1iZXIgb2YgbWF4aW11bSB0aW1lcyB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIChtaWRkbGV3YXJlcyBhcmUgYWxzbyB0YWtlbiBmb3IgYSBjb3VudCkuXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGxpbWl0aW5nIGNhbGwgdGltZXMgb2YgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpXG4gICAqICAgLmNhbkJlQ2FsbGVkKDEpO1xuICAgKlxuICAgKiBmdW5jKDEpOyAvLyAyXG4gICAqIGZ1bmMoMSk7IC8vIHVuZGVmaW5lZFxuICAgKi9cbiAgY2FuQmVDYWxsZWQodGltZXMpIHtcbiAgICB0aGlzLiQkLmNhbkJlQ2FsbGVkID0gdGltZXM7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjbGltaXRBcmdzVG9cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTnVtYmVyIG9mIGFyZ3VtZW50cyB0byBsaW1pdCB0by5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEJ1aWx0LWluIGJlZm9yZSBtaWRkbGV3YXJlIGZvciBsaW1pdGluZyBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAqIHRoYXQgaXMgcHV0IHRvIHRoZSBlbmQgb2YgYmVmb3JlIG1pZGRsZXdhcmVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEsIGIpID0+IFthLCBiXSk7XG4gICAqXG4gICAqIGZ1bmMoMSwgMik7IC8vIFsxLCAyXVxuICAgKlxuICAgKiBmdW5jLmxpbWl0QXJnc1RvKDEpO1xuICAgKlxuICAgKiBmdW5jKDEsIDIpOyAvLyBbMSwgdW5kZWZpbmVkXVxuICAgKi9cbiAgbGltaXRBcmdzVG8obnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlKChhcmdzKSA9PiBhcmdzLnNsaWNlKDAsIG51bWJlciksIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgdG8gbG9jay5cbiAgICogQHBhcmFtIHsoQXJyYXl8QXJndW1lbnRzfCopfSBhcmdzIC0gQXJndW1lbnRzIHRvIGxvY2suXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBDb21wb3NpdGlvbiBvZiB7QGxpbmsgRnVuYyNsb2NrQ29udGV4dH0gYW5kIHtAbGluayBGdW5jI2xvY2tBcmdzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuYSArIGEgKyBiO1xuICAgKiB9KS5sb2NrKHsgYTogMiB9LCBbMV0pO1xuICAgKlxuICAgKiBmdW5jKDEpOyAvLyA0XG4gICAqIGZ1bmMoMyk7IC8vIDZcbiAgICovXG4gIGxvY2soY29udGV4dCwgYXJncykge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAubG9ja0NvbnRleHQoY29udGV4dClcbiAgICAgIC5sb2NrQXJncyhhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZ1bmMjbG9ja0FyZ3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHN8Kil9IGFyZ3MgLSBBcmd1bWVudHMgdG8gbG9jay5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEVyYXNlcyBib3VuZCBhcmd1bWVudHMgYW5kIGFkZHMgbmV3IGFyZ3VtZW50cyB0byBhbHJlYWR5IGxvY2tlZCBvbmVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKC4uLmFyZ3MpID0+IHtcbiAgICogICBsZXQgc3VtID0gMDtcbiAgICpcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICogICAgIHN1bSArPSBhcmdzW2ldO1xuICAgKiAgIH1cbiAgICpcbiAgICogICByZXR1cm4gc3VtO1xuICAgKiB9KTtcbiAgICpcbiAgICogZnVuYygxLCAyLCAzKTsgLy8gNlxuICAgKlxuICAgKiBmdW5jLmxvY2tBcmdzKFs0XSk7XG4gICAqXG4gICAqIGZ1bmMoMSwgMiwgMyk7IC8vIDEwXG4gICAqXG4gICAqIGZ1bmMuYmluZEFyZ3MoWzYsIDddKTtcbiAgICogZnVuYy5sb2NrQXJncyhbNV0pO1xuICAgKlxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxNVxuICAgKi9cbiAgbG9ja0FyZ3MoYXJncykge1xuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xuXG4gICAgZnVuYy5hcmdzID0gZnVuYy5hcmdzTG9ja2VkID0gZnVuYy5hcmdzTG9ja2VkLmNvbmNhdCh0b0FycmF5KGFyZ3MpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyNsb2NrQ29udGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgdG8gbG9jay5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIExvY2tzIGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBsb2NrZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhmdW5jdGlvbiAoKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuYTtcbiAgICogfSkubG9ja0NvbnRleHQoeyBhOiAxIH0pO1xuICAgKlxuICAgKiBmdW5jKCk7IC8vIDFcbiAgICpcbiAgICogZnVuYy5sb2NrQ29udGV4dCh7IGE6IDIgfSk7XG4gICAqXG4gICAqIGZ1bmMoKTsgLy8gMVxuICAgKi9cbiAgbG9ja0NvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xuXG4gICAgaWYgKCFmdW5jLmNvbnRleHRMb2NrZWQpIHtcbiAgICAgIGZ1bmMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICBmdW5jLmNvbnRleHRMb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyN0aW1pbmdcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFyayAtIEFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRvIGNvbnNvbGUudGltZSgpIGFuZCBjb25zb2xlLnRpbWVFbmQoKS5cbiAgICogQnkgZGVmYXVsdCBuYW1lIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiwgb3IgaWYgaXQncyBub3QgcHJlc2VudCwgJ2Fub255bW91cycgaXMgdXNlZC5cbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEJ1aWx0LWluIGJlZm9yZSBhbmQgYWZ0ZXIgbWlkZGxld2FyZXMgZm9yIG5vdGluZyBjYWxsaW5nIHRpbWUuXG4gICAqIEluIGNhc2Ugb2YgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyBpdCBub3RlcyB0aW1lIGJldHdlZW4gY2FsbGluZyBmdW5jdGlvbiBhbmQgcmVzb2x2aW5nIG9yIHJlamVjdGluZyB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKVxuICAgKiAgIC50aW1pbmcoJ3BsdXMgMScpO1xuICAgKlxuICAgKiBmdW5jKDIpOyAvLyBwbHVzIDE6IDAuMDEwbXNcbiAgICpcbiAgICogY29uc3QgYXN5bmMgPSBuZXcgRnVuYygoKSA9PiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAqICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApO1xuICAgKiAgIH0pKVxuICAgKiAgIC5hc3luYygpXG4gICAqICAgLnRpbWluZygpO1xuICAgKlxuICAgKiBhc3luYygpO1xuICAgKiAvLyBBZnRlciAxIHNlY29uZC4uLlxuICAgKiAvLyBhbm9ueW1vdXM6IDEwMDAuMDEwbXNcbiAgICovXG4gIHRpbWluZyhtYXJrKSB7XG4gICAgbWFyayA9IGFyZ3VtZW50cy5sZW5ndGggPyBTdHJpbmcobWFyaykgOiB0aGlzLiQubmFtZSB8fCAnYW5vbnltb3VzJztcblxuICAgIHRoaXMuYmVmb3JlKChhcmdzKSA9PiB7XG4gICAgICBjb25zb2xlLnRpbWUobWFyayk7XG5cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuYWZ0ZXIoKHJldCkgPT4ge1xuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmspO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICgoKSA9PiB7fSkudG9TdHJpbmcuY2FsbCh0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyN1bmJpbmRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gQ29tcG9zaXRpb24gb2Yge0BsaW5rIEZ1bmMjdW5iaW5kQ29udGV4dH0gYW5kIHtAbGluayBGdW5jI3VuYmluZEFyZ3N9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoZnVuY3Rpb24gKGEpIHtcbiAgICogICByZXR1cm4gdGhpcy5mb28gKyAnICYgJyArICBhO1xuICAgKiB9KS5iaW5kKHsgZm9vOiAyIH0sIDEpO1xuICAgKlxuICAgKiBmdW5jKCk7IC8vICcyICYgMSdcbiAgICpcbiAgICogZnVuYy51bmJpbmQoKTtcbiAgICpcbiAgICogZnVuYygpOyAvLyAndW5kZWZpbmVkICYgdW5kZWZpbmVkJ1xuICAgKi9cbiAgdW5iaW5kKCkge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAudW5iaW5kQ29udGV4dCgpXG4gICAgICAudW5iaW5kQXJncygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyN1bmJpbmRBcmdzXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEVyYXNlcyBhbGwgYm91bmQgYXJndW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKC4uLmFyZ3MpID0+IHtcbiAgICogICBsZXQgc3VtID0gMDtcbiAgICpcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICogICAgIHN1bSArPSBhcmdzW2ldO1xuICAgKiAgIH1cbiAgICpcbiAgICogICByZXR1cm4gc3VtO1xuICAgKiB9KS5iaW5kQXJncyhbNCwgNV0pO1xuICAgKlxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxNVxuICAgKlxuICAgKiBmdW5jLnVuYmluZEFyZ3MoKTtcbiAgICpcbiAgICogZnVuYygxLCAyLCAzKTsgLy8gNlxuICAgKi9cbiAgdW5iaW5kQXJncygpIHtcbiAgICBjb25zdCBmdW5jID0gdGhpcy4kJDtcblxuICAgIGZ1bmMuYXJncyA9IGZ1bmMuYXJnc0xvY2tlZDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRnVuYyN1bmJpbmRDb250ZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIEVyYXNlcyBjb250ZXh0IGlmIGl0J3Mgbm90IGxvY2tlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKGZ1bmN0aW9uICgpIHtcbiAgICogICByZXR1cm4gdGhpcy5mb287XG4gICAqIH0pLmJpbmRDb250ZXh0KHsgZm9vOiAxIH0pO1xuICAgKlxuICAgKiBmdW5jKCk7IC8vIDFcbiAgICpcbiAgICogZnVuYy51bmJpbmRBcmdzKCk7XG4gICAqXG4gICAqIGZ1bmMoKTsgLy8gdW5kZWZpbmVkXG4gICAqL1xuICB1bmJpbmRDb250ZXh0KCkge1xuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xuXG4gICAgaWYgKCFmdW5jLmNvbnRleHRMb2NrZWQpIHtcbiAgICAgIGZ1bmMuY29udGV4dCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0Z1bmMnXG59KTtcblxuY29uc3RydWN0b3JzWzFdLnB1c2goe1xuICBjaGVjazogaXNGdW5jdGlvbixcbiAgY2xzOiBGdW5jXG59KTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gbWV0aG9kXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gTWV0aG9kIHRvIGNhbGwuXG4gKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHN8Kil9IGFyZ3MgLSBBcmd1bWVudHMgdG8gY2FsbCB0aGUgbWV0aG9kIHdpdGguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgY2FsbHMgc3RhdGVkIG1ldGhvZCB3aXRoIGdpdmVuIGFyZ3VtZW50cy5cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZ1bmN0aW9uXG4gKiB0aGF0IGNhbGxzIHN0YXRlZCBtZXRob2Qgb2YgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggZ2l2ZW4gYXJndW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBbMS4yMzQ1LCAyLjc4OSwgMy4xNF0ubWFwKG1ldGhvZCgndG9GaXhlZCcsIFsyXSkpOyAvLyBbJzEuMjMnLCAnMi43OScsICczLjE0J11cbiAqL1xuZnVuY3Rpb24gbWV0aG9kKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gIHJldHVybiAoeCkgPT4geFttZXRob2RdLmFwcGx5KHgsIHRvQXJyYXkoYXJncykpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBub29wXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBFbXB0eSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogQGZ1bmN0aW9uIHByb3BcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIC0gUHJvcGVydHkgdG8gcmV0dXJuLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IHJldHVybnMgZ2l2ZW4gcHJvcGVydHkgb2YgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIHRoYXQgcmV0dXJuIHRoZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZ2l2ZW4gcHJvcGVydHkgb2YgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBbJ2ZvbycsICcxMicsICc3ODkwJ10ubWFwKHByb3AoJ2xlbmd0aCcpKTsgLy8gWzMsIDIsIDRdXG4gKi9cbmZ1bmN0aW9uIHByb3AocHJvcCkge1xuICByZXR1cm4gKHsgW3Byb3BdOiB2YWx1ZSB9KSA9PiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gc2VsZlxuICogQHB1YmxpY1xuICogQHJldHVybnMgeyp9IEZpcnN0IGFyZ3VtZW50IGl0c2VsZi5cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBbMSwgMl0ubWFwKHNlbGYpOyAgICAgICAgICAgICAgICAgICAgIC8vIFsxLCAyXVxuICogWzEsIDMsIE5hTiwgMCwgNywgbnVsbF0uZmlsdGVyKHNlbGYpOyAvLyBbMSwgMywgN11cbiAqL1xuZnVuY3Rpb24gc2VsZigpIHtcbiAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbn1cblxuZXhwb3J0IHsgRnVuYywgbWV0aG9kLCBub29wLCBwcm9wLCBzZWxmIH07XG4iLCIvKipcbiAqIEBtb2R1bGUgTnVtXG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBOdW0gY2xhc3MuXG4gKi9cblxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcbmltcG9ydCB7IEZ1bmMgfSBmcm9tICcuL0Z1bmMnO1xuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBpc051bWJlciwgaXNGaW5pdGUsIHRvQXJyYXksXG4gIGRlZmluZVByb3BlcnRpZXMsIHZhbGlkYXRlLCBTeW1ib2xcbn0gZnJvbSAnLi9oZWxwZXJzJztcblxuY29uc3QgdG9SYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgdG9EZWdyZWUgPSAxODAgLyBNYXRoLlBJO1xuY29uc3QgbG4yID0gTWF0aC5MTjI7XG5jb25zdCBsbjEwID0gTWF0aC5MTjEwO1xuXG4vKipcbiAqIEBjbGFzcyBOdW1cbiAqIEBleHRlbmRzIFN1cGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge051bWJlcn0gW251bWJlciA9IDBdIC0gQSBudW1iZXIgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtOdW19IEluc3RhbmNlIG9mIE51bS5cbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGEgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBudW0gPSBuZXcgTnVtKDEpO1xuICovXG5jbGFzcyBOdW0gZXh0ZW5kcyBTdXBlciB7XG4gIGNvbnN0cnVjdG9yKG51bWJlciA9IDApIHtcbiAgICBzdXBlcigrbnVtYmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgTnVtIyRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzY3JpcHRpb24gT3JpZ2luYWwgbnVtYmVyLlxuICAgICAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2Fic1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWJzXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTWF0aC5hYnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWJzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IE51bSgxKS5hYnM7ICAvLyAxXG4gICAqIG5ldyBOdW0oLTEpLmFiczsgLy8gMVxuICAgKi9cbiAgZ2V0IGFicygpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE51bSNhY29zXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFt0b0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSByZXR1cm4gdmFsdWUgaXMgdHJhbnNmb3JtZWQgaW50byBkZWdyZWVzLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBBcmNjb3NpbmUgb2YgdGhlIG51bWJlci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fjb3NcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmFjb3Nde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWNvc30uXG4gICAqL1xuICBhY29zKHRvRGVncmVlcykge1xuICAgIHJldHVybiAodG9EZWdyZWVzID8gdG9EZWdyZWUgOiAxKSAqIE1hdGguYWNvcyh0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2Fjb3NoXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hY29zaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguYWNvc2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWNvc2h9LlxuICAgKi9cbiAgZ2V0IGFjb3NoKCkge1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcblxuICAgIHJldHVybiBNYXRoLmxvZyhudW1iZXIgKyBNYXRoLnNxcnQobnVtYmVyICogbnVtYmVyIC0gMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2FzaW5oXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hc2luaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguYXNpbmhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXNpbmh9LlxuICAgKi9cbiAgZ2V0IGFzaW5oKCkge1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcblxuICAgIHJldHVybiBNYXRoLmxvZyhudW1iZXIgKyBNYXRoLnNxcnQobnVtYmVyICogbnVtYmVyICsgMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI2FzaW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW3RvRGVncmVlcyA9IGZhbHNlXSBJZiBpdCBpcyB0cnV0aHkgdGhlIHJldHVybiB2YWx1ZSBpcyB0cmFuc2Zvcm1lZCBpbnRvIGRlZ3JlZXMuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEFyY3NpbmUgb2YgdGhlIG51bWJlci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2FzaW5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmFzaW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXNpbn0uXG4gICAqL1xuICBhc2luKHRvRGVncmVlcykge1xuICAgIHJldHVybiAodG9EZWdyZWVzID8gdG9EZWdyZWUgOiAxKSAqIE1hdGguYXNpbih0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI2F0YW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW3RvRGVncmVlcyA9IGZhbHNlXSBJZiBpdCBpcyB0cnV0aHkgdGhlIHJldHVybiB2YWx1ZSBpcyB0cmFuc2Zvcm1lZCBpbnRvIGRlZ3JlZXMuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEFyY3NpbmUgb2YgdGhlIG51bWJlci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2F0YW5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmF0YW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXRhbn0uXG4gICAqL1xuICBhdGFuKHRvRGVncmVlcykge1xuICAgIHJldHVybiAodG9EZWdyZWVzID8gdG9EZWdyZWUgOiAxKSAqIE1hdGguYXRhbih0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2F0YW5oXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hdGFuaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguYXRhbmhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXRhbmh9LlxuICAgKi9cbiAgZ2V0IGF0YW5oKCkge1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcblxuICAgIHJldHVybiBNYXRoLmxvZygoMSArIG51bWJlcikgLyAoMSAtIG51bWJlcikpIC8gMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIE51bSNjYnJ0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jYnJ0XG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTWF0aC5jYnJ0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NicnR9LlxuICAgKi9cbiAgZ2V0IGNicnQoKSB7XG4gICAgY29uc3QgY2JydCA9IE1hdGgucG93KE1hdGguYWJzKHRoaXMuJCksIDEgLyAzKTtcblxuICAgIHJldHVybiB0aGlzLiQgPiAwID8gY2JydCA6IC1jYnJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2NlaWxcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NlaWxcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmNlaWxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2VpbH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBOdW0oMS4xKS5jZWlsOyAgLy8gMlxuICAgKiBuZXcgTnVtKC0xLjEpLmNlaWw7IC8vIC0xXG4gICAqL1xuICBnZXQgY2VpbCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBOdW0jY29zXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFthc0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSBudW1iZXIgaXMgdHJlYXRlZCBhcyBhIGRlZ3JlZSB2YWx1ZS5cbiAgICogQHJldHVybnMge051bWJlcn0gQ29zaW5lIG9mIHRoZSBudW1iZXIuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jb3NcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmNvc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jb3N9LlxuICAgKi9cbiAgY29zKGFzRGVncmVlcykge1xuICAgIHJldHVybiBNYXRoLmNvcygoYXNEZWdyZWVzID8gdG9SYWRpYW4gOiAxKSAqIHRoaXMuJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBOdW0jY29zaFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY29zaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguY29zaF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jb3NofS5cbiAgICovXG4gIGdldCBjb3NoKCkge1xuICAgIGNvbnN0IGV4cCA9IHRoaXMuZXhwO1xuXG4gICAgcmV0dXJuIChleHAgKyAxIC8gZXhwKSAvIDI7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBOdW0jY3ViZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb24gQ3ViZSBvZiB0aGUgbnVtYmVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgTnVtKDIpLmN1YmU7ICAvLyA4XG4gICAqIG5ldyBOdW0oLTMpLmNlaWw7IC8vIC0yN1xuICAgKi9cbiAgZ2V0IGN1YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuJCAqIHRoaXMuJCAqIHRoaXMuJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIE51bSNleHBcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2V4cFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguZXhwXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2V4cH0uXG4gICAqL1xuICBnZXQgZXhwKCkge1xuICAgIHJldHVybiBNYXRoLmV4cCh0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2Zsb29yXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9mbG9vclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguZmxvb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvZmxvb3J9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgTnVtKDEuMSkuZmxvb3I7ICAvLyAxXG4gICAqIG5ldyBOdW0oLTEuMSkuZmxvb3I7IC8vIC0yXG4gICAqL1xuICBnZXQgZmxvb3IoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE51bSNpbnRlcnZhbFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBldmVyeSA8bnVtYmVyPiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgYWJvcnRzIHRoZSBpbnRlcnZhbC4gVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uIChpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kKVxuICAgKiBpcyB0aGUgb2JqZWN0IHdpdGggdGhlIGFib3J0IG1ldGhvZC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NldEludGVydmFsXG4gICAqIEBkZXNjcmlwdGlvbiBBbmFsb2d1ZSBvZiB0aGVcbiAgICogW3NldEludGVydmFsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldEludGVydmFsfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgdGltZXMgPSAwO1xuICAgKiBuZXcgTnVtKDUwKS5pbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAqICAgaWYgKCsrdGltZXMgPT09IDEwKSB7XG4gICAqICAgICB0aGlzLmFib3J0KCk7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICovXG4gIGludGVydmFsKGZ1bmMsIGFyZ3MgPSBbXSkge1xuICAgIHZhbGlkYXRlKFtmdW5jXSwgWydmdW5jdGlvbiddLCAnTnVtI2ludGVydmFsJyk7XG5cbiAgICBmdW5jID0gbmV3IEZ1bmMoZnVuYykuYmluZENvbnRleHQoeyBhYm9ydCB9KTtcbiAgICBhcmdzID0gdG9BcnJheShhcmdzKTtcblxuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcblxuICAgIGxldCBhYm9ydGVkO1xuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiBpbnRlcnZhbCgpIHtcbiAgICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgICBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGludGVydmFsLCBudW1iZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMCk7XG5cbiAgICByZXR1cm4gYWJvcnQ7XG5cbiAgICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIE51bSNsblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbG9nXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTWF0aC5sb2dde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbG9nfS5cbiAgICovXG4gIGdldCBsbigpIHtcbiAgICByZXR1cm4gTWF0aC5sb2codGhpcy4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE51bSNsb2dcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTnVtYmVyIHRvIGdldCBsb2dhcml0aG0gb2YuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IExvZ2FyaXRobSBvZiB0aGUgYXJndW1lbnQgbnVtYmVyIHRvIHRoZSBudW1iZXIgYmFzZS5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGxvZ2FyaXRobSBvZiB0aGUgYXJndW1lbnQgbnVtYmVyIHRvIHRoZSBudW1iZXIgYmFzZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IE51bSgyKS5sb2coMTYpOyAgLy8gNFxuICAgKiBuZXcgTnVtKDMpLmxvZygyNDMpOyAvLyA1XG4gICAqL1xuICBsb2cobnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKG51bWJlcikgLyBNYXRoLmxvZyh0aGlzLiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgTnVtI2xvZzJcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZzJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmxvZzJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbG9nMn0uXG4gICAqL1xuICBnZXQgbG9nMigpIHtcbiAgICByZXR1cm4gdGhpcy5sbiAvIGxuMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIE51bSNsb2cxMFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbG9nMTBcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLmxvZzEwXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZzEwfS5cbiAgICovXG4gIGdldCBsb2cxMCgpIHtcbiAgICByZXR1cm4gdGhpcy5sbiAvIGxuMTA7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBOdW0jcG93XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvd2VyIC0gUG93ZXIgdGhlIG51bWJlciBzaG91bGQgYmUgcmFpc2VkIHRvLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIHRvIHRoZSA8cG93ZXI+IHBvd2VyLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcG93XG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTWF0aC5wb3dde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcG93fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IE51bSg0KS5wb3coLjUpOyAvLyAyXG4gICAqIG5ldyBOdW0oMykucG93KDIpOyAgLy8gOVxuICAgKi9cbiAgcG93KHBvd2VyKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHRoaXMuJCwgcG93ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI3Jvb3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gcG93ZXIgLSBQb3dlciB0aGUgbnVtYmVyIHNob3VsZCBiZSByYWlzZWQgdG8uXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSA8cG93ZXI+IHJvb3Qgb2YgdGhlIG51bWJlci5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIG51bWJlci5wb3coMSAvIHBvd2VyKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IE51bSg0KS5yb290KDIpOyAgIC8vIDAuNVxuICAgKiBuZXcgTnVtKDI0Mykucm9vdCg1KTsgLy8gM1xuICAgKi9cbiAgcm9vdChwb3dlcikge1xuICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLiQsIDEgLyBwb3dlcik7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBOdW0jcm91bmRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTWF0aC5yb3VuZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9yb3VuZH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBOdW0oMS4xKS5mbG9vcjsgIC8vIDFcbiAgICogbmV3IE51bSgtMS4xKS5mbG9vcjsgLy8gLTFcbiAgICogbmV3IE51bSgxLjUpLmZsb29yOyAgLy8gMlxuICAgKi9cbiAgZ2V0IHJvdW5kKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBOdW0jc2lnblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguc2lnbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWdufS5cbiAgICovXG4gIGdldCBzaWduKCkge1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcblxuICAgIGlmICghbnVtYmVyKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXIgPiAwID8gMSA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI3NpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYXNEZWdyZWVzID0gZmFsc2VdIElmIGl0IGlzIHRydXRoeSB0aGUgbnVtYmVyIGlzIHRyZWF0ZWQgYXMgYSBkZWdyZWUgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFNpbmUgb2YgdGhlIG51bWJlci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpblxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguc2luXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3Npbn0uXG4gICAqL1xuICBzaW4oYXNEZWdyZWVzKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKChhc0RlZ3JlZXMgPyB0b1JhZGlhbiA6IDEpICogdGhpcy4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIE51bSNzaW5oXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaW5oXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTWF0aC5zaW5oXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3Npbmh9LlxuICAgKi9cbiAgZ2V0IHNpbmgoKSB7XG4gICAgY29uc3QgZXhwID0gdGhpcy5leHA7XG5cbiAgICByZXR1cm4gKGV4cCAtIDEgLyBleHApIC8gMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIE51bSNzcVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHNxdWFyZSBvZiB0aGUgbnVtYmVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgTnVtKDIpLnNxOyAgLy8gNFxuICAgKiBuZXcgTnVtKC0zKS5zcTsgLy8gOVxuICAgKi9cbiAgZ2V0IHNxKCkge1xuICAgIHJldHVybiB0aGlzLiQgKiB0aGlzLiQ7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBOdW0jc3FydFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc3FydFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGguc3FydF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zcXJ0fS5cbiAgICovXG4gIGdldCBzcXJ0KCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE51bSN0YW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2FzRGVncmVlcyA9IGZhbHNlXSBJZiBpdCBpcyB0cnV0aHkgdGhlIG51bWJlciBpcyB0cmVhdGVkIGFzIGEgZGVncmVlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUYW5nZW50IG9mIHRoZSBudW1iZXIuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtNYXRoLnRhbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW59LlxuICAgKi9cbiAgdGFuKGFzRGVncmVlcykge1xuICAgIHJldHVybiBNYXRoLnRhbigoYXNEZWdyZWVzID8gdG9SYWRpYW4gOiAxKSAqIHRoaXMuJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBOdW0jdGFuaFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdGFuaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW01hdGgudGFuaF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW5ofS5cbiAgICovXG4gIGdldCB0YW5oKCkge1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcblxuICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbjtcbiAgICB9XG5cbiAgICBjb25zdCBleHAgPSBNYXRoLmV4cCgyICogbnVtYmVyKTtcblxuICAgIHJldHVybiAoZXhwIC0gMSkgLyAoZXhwICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBOdW0jdGltZW91dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIFZhbHVlIHRvIGJlIHJlc29sdmVkIGJ5IHRoZSBwcm9taXNlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGNvdWxkIGJlIGFib3J0ZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRUaW1lb3V0XG4gICAqIEBkZXNjcmlwdGlvbiBQcm9taXNlLWJhc2VkIGFuYWxvZ3VlIG9mXG4gICAqIFtzZXRUaW1lb3V0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldFRpbWVvdXR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgTnVtKDUwKS50aW1lb3V0KCdyZXNvbHZlZCcpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2codmFsdWUpOyAvLyAncmVzb2x2ZWQnXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBwcm9taXNlID0gbmV3IE51bSg1MCkudGltZW91dCgpO1xuICAgKiBwcm9taXNlLmFib3J0KCk7XG4gICAqL1xuICB0aW1lb3V0KHZhbHVlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHJlamVjdDtcblxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICByZWplY3QgPSByZWo7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLiQsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHByb21pc2UuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCB3YXMgYWJvcnRlZCcpKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI3RvQmFzZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYmFzZSA9IDEwXSAtIEJhc2UgdGhhdCB0aGUgbnVtYmVyIHNob3VsZCBpbnZlcnRlZCB0by5cbiAgICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlciBpbiA8YmFzZT4gYmFzZS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9TdHJpbmdcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtOdW1iZXIjdG9TdHJpbmdde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b1N0cmluZ30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBOdW0oNCkudG9CYXNlKDIpOyAvLyAxMDBcbiAgICogbmV3IE51bSgzKS50b0Jhc2UoKTsgIC8vIDNcbiAgICovXG4gIHRvQmFzZShiYXNlID0gMTApIHtcbiAgICByZXR1cm4gdGhpcy4kLnRvU3RyaW5nKGJhc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI3RvRXhwb25lbnRpYWxcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlciBpbiB0aGUgZXhwb25lbnRpYWwgZm9ybWF0LlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b0V4cG9uZW50aWFsXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTnVtYmVyI3RvRXhwb25lbnRpYWxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b0V4cG9uZW50aWFsfS5cbiAgICovXG4gIHRvRXhwb25lbnRpYWwoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICByZXR1cm4gdGhpcy4kLnRvRXhwb25lbnRpYWwoZnJhY3Rpb25EaWdpdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTnVtI3RvRml4ZWRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2RpZ2l0cyA9IDBdIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBGaXhlZC1wb2ludCBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b0ZpeGVkXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTnVtYmVyI3RvRml4ZWRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b0ZpeGVkfS5cbiAgICovXG4gIHRvRml4ZWQoZGlnaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuJC50b0ZpeGVkKGRpZ2l0cyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBOdW0jdG9QcmVjaXNpb25cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3ByZWNpc2lvbl0gLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgdG8gdGhlIHNwZWNpZmllZCBwcmVjaXNpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvUHJlY2lzaW9uXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTnVtYmVyI3RvUHJlY2lzaW9uXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9QcmVjaXNpb259LlxuICAgKi9cbiAgdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuJC50b1ByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuJCk7XG4gIH1cbn1cblxuZGVmaW5lUHJvcGVydGllcyhOdW0ucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnTnVtJ1xufSk7XG5cbmNvbnN0cnVjdG9yc1sxXS5wdXNoKHtcbiAgY2hlY2s6IGlzTnVtYmVyLFxuICBjbHM6IE51bVxufSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJhbmRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQgPSAwXSAtIFN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kID0gMV0gLSBFbmQgb2YgdGhlIHJhbmdlLlxuICogQHJldHVybnMge051bWJlcn0gUmFuZG9tIG51bWJlci5cbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBpbiB0aGUgcmFuZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIHJhbmQoMSwgNSk7IC8vIDIuMzE1XG4gKiByYW5kKDEsIDUpOyAvLyA0LjM1Njc2M1xuICovXG5mdW5jdGlvbiByYW5kKHN0YXJ0ID0gMCwgZW5kID0gMSkge1xuICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogTWF0aC5yYW5kb20oKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gcmFuZG9tXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHN0YXJ0IC0gU3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBlbmQgLSBFbmQgb2YgdGhlIHJhbmdlLlxuICogQHJldHVybnMge051bWJlcn0gUmFuZG9tIGludGVnZXIuXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBpbiB0aGUgcmFuZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIHJhbmRvbSgxLCA1KTsgLy8gM1xuICogcmFuZG9tKDEsIDUpOyAvLyAxXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShzdGFydCwgZW5kKSB7XG4gIHZhbGlkYXRlKFtzdGFydCwgZW5kXSwgWydpbnRMaWtlJywgJ2ludExpa2UnXSwgJ3JhbmRvbScpO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIGZpcnN0IScsICdyYW5kb20nKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmZsb29yKHJhbmQoc3RhcnQsIGVuZCArIDEpKTtcbn1cblxuZXhwb3J0IHsgTnVtLCByYW5kLCByYW5kb20gfTtcbiIsIi8qKlxuICogQG1vZHVsZSBBcnJcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEFyciBjbGFzcy5cbiAqL1xuXG5pbXBvcnQgeyByYW5kb20gfSBmcm9tICcuL051bSc7XG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgaXNBcnJheUxpa2UsIGlzTmFOLCBpc051bWJlciwgaXNTdHJpbmcsXG4gIHRvQXJyYXksIHZhbGlkYXRlLCBpdGVyYXRlIGFzIGl0ZXJhdG9yLCBTeW1ib2wsIGRlZmluZVByb3BlcnRpZXNcbn0gZnJvbSAnLi9oZWxwZXJzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXl8Kn0gQXJyYXlMaWtlXG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gQXJyYXktbGlrZSB0eXBlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEFycmF5Q2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gSXRlcmF0aW9uIGluZGV4LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEl0ZXJhdGVDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtOdW1iZXJ9IGkgLSBJdGVyYXRpb24gaW5kZXguXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQ29tcGFyZUZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IHggLSBGaXJzdCB2YWx1ZSB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0geSAtIFNlY29uZCB2YWx1ZSB0byBiZSBjb21wYXJlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBBcnJcbiAqIEBleHRlbmRzIFN1cGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXkgPSBbXV0gLSBBbiBhcnJheSB0byB3cmFwLlxuICogQHJldHVybnMge0Fycn0gSW5zdGFuY2Ugb2YgQXJyLlxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBBcnIoWzEsIDJdKTtcbiAqL1xuY2xhc3MgQXJyIGV4dGVuZHMgU3VwZXIge1xuICBjb25zdHJ1Y3RvcihhcnJheSA9IFtdKSB7XG4gICAgc3VwZXIodG9BcnJheShhcnJheSBpbnN0YW5jZW9mIEFyciA/IGFycmF5LiQgOiBhcnJheSkpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciBBcnIjJFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIE1hZGUgYXJyYXkuXG4gICAgICovXG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjY29uY2F0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4oQXJyYXl8QXJyfCopfSB2YWx1ZXMgLSBBcnJheXMgb3IgYW55IG90aGVyIHZhbHVlcyB0byBjb25jYXQgdGhlIGFycmF5IHdpdGguXG4gICAqIEByZXR1cm5zIHtBcnJ9IE5ldyBpbnN0YW5jZSBvZiBBcnIuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvY29uY2F0XG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbQXJyYXkjY29uY2F0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9jb25jYXR9LlxuICAgKi9cbiAgY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGNvbnN0IGFycmF5ID0gdG9BcnJheSh0aGlzLiQsIHRydWUpO1xuXG4gICAgaXRlcmF0b3IoYXJndW1lbnRzLCAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlID0gbmV3IFN1cGVyKHZhbHVlKS4kO1xuXG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmICFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgaXRlcmF0b3IodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGFycmF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIEFyciNmaXJzdFxuICAgKiBAdHlwZSB7Kn1cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuZmlyc3Q7IC8vIDFcbiAgICogbmV3IEFycihbXSkuZmlyc3Q7ICAgICAgICAvLyB1bmRlZmluZWRcbiAgICovXG4gIGdldCBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy4kWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3VwZXIjZm9yRWFjaFJldmVyc2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpdGVyYXRpbmcgb3ZlciBhbnkgb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmZvckVhY2goKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xuICAgKiAgIG9iamVjdFtrZXldID0gdmFsdWUgKiB2YWx1ZTtcbiAgICogfSkuJDsgLy8geyBhOiAxLCBiOiB7IGM6IDQsIGQ6IDUgfSB9XG4gICAqL1xuICBmb3JFYWNoUmV2ZXJzZShjYWxsYmFjaykge1xuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ0FyciNmb3JFYWNoUmV2ZXJzZScpO1xuXG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLiQ7XG5cbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNhbGxiYWNrKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjaW5jbHVkZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFycmF5IGluY2x1ZGVzIHRoZSB2YWx1ZS5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIGFycmF5LmluZGV4T2ZTdHJpY3QodmFsdWUpICE9PSAtMS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluY2x1ZGVzKDEpOyAgICAgICAvLyB0cnVlXG4gICAqIG5ldyBBcnIoWzEsIDIsIDNdKS5pbmNsdWRlcygnMScpOyAgICAgLy8gZmFsc2VcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluY2x1ZGVzKDMpOyAgICAgICAvLyB0cnVlXG4gICAqIG5ldyBBcnIoWzEsIDIsIE5hTl0pLmluY2x1ZGVzKE5hTik7ICAgLy8gdHJ1ZVxuICAgKi9cbiAgaW5jbHVkZXModmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleE9mU3RyaWN0KHZhbHVlKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjaW5kZXhPZlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEFsbW9zdCB0aGUgc2FtZSBhcyB7QGxpbmsgU3VwZXIja2V5T2Z9LiBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IGlmIHRoZSB2YWx1ZSBpcyBub3QgZm91bmRcbiAgICogLTEgcmV0dXJuZWQgaW5zdGVhZCBvZiBudWxsIGFuZCBpZiBmb3VuZCBOdW1iZXIoa2V5KSByZXR1cm5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2YoMSk7ICAgICAgIC8vIDBcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2YoJzEnKTsgICAgIC8vIDBcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2YoMyk7ICAgICAgIC8vIC0xXG4gICAqIG5ldyBBcnIoWzEsIDIsIE5hTl0pLmluZGV4T2YoTmFOKTsgICAvLyAyXG4gICAqL1xuICBpbmRleE9mKHZhbHVlKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZih2YWx1ZSk7XG5cbiAgICByZXR1cm4ga2V5ID09PSBudWxsID8gLTEgOiBOdW1iZXIoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNpbmRleE9mU3RyaWN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge051bWJlcn0gSW5kZXggb2YgdGhlIGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gQWxtb3N0IHRoZSBzYW1lIGFzIHtAbGluayBTdXBlciNrZXlPZlN0cmljdH0uIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgaWYgdGhlIHZhbHVlIGlzIG5vdCBmb3VuZFxuICAgKiAtMSByZXR1cm5lZCBpbnN0ZWFkIG9mIG51bGwgYW5kIGlmIGZvdW5kIE51bWJlcihrZXkpIHJldHVybmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuaW5kZXhPZlN0cmljdCgxKTsgICAgICAgLy8gMFxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuaW5kZXhPZlN0cmljdCgnMScpOyAgICAgLy8gLTFcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2ZTdHJpY3QoMyk7ICAgICAgIC8vIC0xXG4gICAqIG5ldyBBcnIoWzEsIDIsIE5hTl0pLmluZGV4T2ZTdHJpY3QoTmFOKTsgICAvLyAyXG4gICAqL1xuICBpbmRleE9mU3RyaWN0KHZhbHVlKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZlN0cmljdCh2YWx1ZSk7XG5cbiAgICByZXR1cm4ga2V5ID09PSBudWxsID8gLTEgOiBOdW1iZXIoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNqb2luXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXBhcmF0b3IgPSAnLCddIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIFN0cmluZyBvZiBqb2luZWQgYXJyYXkuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvam9pblxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0FycmF5I2pvaW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2pvaW59LlxuICAgKi9cbiAgam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4kLmpvaW4uYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgQXJyI2xhc3RcbiAgICogQHR5cGUgeyp9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmxhc3Q7IC8vIDNcbiAgICogbmV3IEFycihbXSkubGFzdDsgICAgICAgIC8vIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IGxhc3QoKSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLiQ7XG5cbiAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciBBcnIjbGVuZ3RoXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGVuZ3RoXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbQXJyYXkjbGVuZ3RoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9sZW5ndGh9LlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4kLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNwb3BcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBkZWxldGVkIGVsZW1lbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbQXJyYXkjcG9wXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wb3B9LlxuICAgKi9cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLiQucG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjcHVzaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFsdWVzIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAdGhpcyB7QXJyfVxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcHVzaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0FycmF5I3B1c2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2h9XG4gICAqIGJlc2lkZXMgcmV0dXJuaW5nIHRoaXMuXG4gICAqL1xuICBwdXNoKC4uLnZhbHVlcykge1xuICAgIHRoaXMuJC5wdXNoLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQXJyI3B1c2hBcnJheVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQXJyYXkgdG8gcHVzaC5cbiAgICogQHRoaXMge0Fycn1cbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBwdXNoaW5nIGFuIGFycmF5IGludG8gYW5vdGhlci5cbiAgICovXG4gIHB1c2hBcnJheShhcnJheSkge1xuICAgIHRoaXMuJC5wdXNoLmFwcGx5KHRoaXMuJCwgYXJyYXkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjcmFuZG9tXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMgeyp9IFJhbmRvbSBpdGVtIG9mIHRoZSBhcnJheS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyByYW5kb20gaXRlbXMgb2YgdGhlIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQXJyKFsxLCA1LCAzXSkucmFuZG9tKCk7IC8vIDNcbiAgICogbmV3IEFycihbMSwgNSwgM10pLnJhbmRvbSgpOyAvLyA1XG4gICAqL1xuICByYW5kb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuJFtyYW5kb20oMCwgdGhpcy4kLmxlbmd0aCAtIDEpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNyZXZlcnNlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Fycn0gQSB3cmFwIG9mIHRoZSByZXZlcnNlZCBhcnJheS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZXZlcnNlXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbQXJyYXkjcmV2ZXJzZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmV2ZXJzZX0uXG4gICAqL1xuICByZXZlcnNlKCkge1xuICAgIHRoaXMuJC5yZXZlcnNlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNzaGlmdFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGRlbGV0ZWQgZWxlbWVudC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zaGlmdFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0FycmF5I3NoaWZ0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zaGlmdH0uXG4gICAqL1xuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy4kLnNoaWZ0KCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjc2h1ZmZsZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtBcnJ9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2h1ZmZsaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQXJyKFsxLCAyLCAzLCA0XSkuc2h1ZmZsZSgpLiQ7IC8vIFs0LCAyLCAzLCAxXVxuICAgKiBuZXcgQXJyKFsxLCAyLCAzLCA0XSkuc2h1ZmZsZSgpLiQ7IC8vIFsxLCAzLCA0LCAyXVxuICAgKi9cbiAgc2h1ZmZsZSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiQubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgodmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBpbmRleCArIE1hdGguZmxvb3IoKGxlbmd0aCAtIGluZGV4KSAqIE1hdGgucmFuZG9tKCkpO1xuXG4gICAgICBhcnJheVtpbmRleF0gPSBhcnJheVtyYW5kb21JbmRleF07XG4gICAgICBhcnJheVtyYW5kb21JbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNzbGljZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW4gPSAwXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQgPSBhcnJheS5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7QXJyfSBBIHdyYXAgb2YgYSBzbGljZWQgYXJyYXkuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2VcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtBcnJheSNzbGljZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2V9LlxuICAgKi9cbiAgc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLiQuc2xpY2UuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNzb3J0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtDb21wYXJlRnVuY3Rpb259IFtjb21wYXJlRnVuY3Rpb25dIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0FycmF5I3NvcnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnR9LlxuICAgKi9cbiAgc29ydChjb21wYXJlRnVuY3Rpb24pIHtcbiAgICB2YWxpZGF0ZShbY29tcGFyZUZ1bmN0aW9uXSwgWydmdW5jdGlvbnx8ISddLCAnQXJyI3NvcnQnKTtcblxuICAgIHRoaXMuJC5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNzb3J0QXNjXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhc2NlbmRpbmcgc29ydGluZy4gUHV0cyBub24tbnVtYmVycyBmaXJzdCwgdGhlbiBOYU5zLCB0aGVuIHNvcnRlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBBcnIoW05hTiwgMSwgLTcsICcxMDAnLCA1XSkuc29ydEFzYygpLiQ7IC8vIFsnMTAwJywgTmFOLCAtNywgMSwgNV1cbiAgICovXG4gIHNvcnRBc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydChhc2MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQXJyI3NvcnREZXNjXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZXNjZW5kaW5nIHNvcnRpbmcuIFB1dHMgc29ydGVkIHZhbHVlcyBmaXJzdCwgdGhlbiBOYU5zLCB0aGVuIG5vbi1udW1iZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQXJyKFtOYU4sIDEsIC03LCAnMTAwJywgNV0pLnNvcnREZXNjKCkuJDsgLy8gWzUsIDEsIC03LCBOYU4sICcxMDAnXVxuICAgKi9cbiAgc29ydERlc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydCgoeSwgeCkgPT4gYXNjKHgsIHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciNzcGxpY2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxldGVDb3VudF0gLSBTZWUgdGhlIGxpbmsuXG4gICAqIEBwYXJhbSB7Li4uKn0gW2l0ZW1zXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge0Fycn0gQSB3cmFwIG9mIHJldHVybiB2YWx1ZSBvZiAjc3BsaWNlIGNhbGwuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbQXJyYXkjc3BsaWNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2V9LlxuICAgKi9cbiAgc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICByZXR1cm4gbmV3IEFycih0aGlzLiQuc3BsaWNlLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBBcnIjc3RyaW5nXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cmluZ30gQ29uY2F0ZW5hdGVkIGFycmF5LlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgYXJyYXkuam9pbignJykuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBBcnIoWzEsIDIsIDNdKS5zdHJpbmcoKTsgLy8gJzEyMydcbiAgICovXG4gIHN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5qb2luKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEFyciN1bnNoaWZ0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge0Fycn0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtBcnJheSN1bnNoaWZ0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0fVxuICAgKiBiZXNpZGVzIHJldHVybmluZyB0aGlzLlxuICAgKi9cbiAgdW5zaGlmdCguLi52YWx1ZXMpIHtcbiAgICB0aGlzLiQudW5zaGlmdC5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEFyci5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdBcnInXG59KTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gYXNjXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB4IC0gRmlyc3QgdmFsdWUgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IHkgLSBTZWNvbmQgdmFsdWUgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBXaGVyZSB0byBwdXQgdGhlIGZpcnN0IGVsZW1lbnQ6IGJlZm9yZSBvciBhZnRlci5cbiAqL1xuZnVuY3Rpb24gYXNjKHgsIHkpIHtcbiAgaWYgKCFpc051bWJlcih4KSAmJiAhaXNOdW1iZXIoeSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICghaXNOdW1iZXIoeCkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoIWlzTnVtYmVyKHkpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoaXNOYU4oeCkgJiYgaXNOYU4oeSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChpc05hTih4KSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChpc05hTih5KSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIHggLSB5O1xufVxuXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XG4gIGNoZWNrOiBpc0FycmF5TGlrZSxcbiAgY2xzOiBBcnJcbn0pO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBhcnJheVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAtIExlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5Q2FsbGJhY2t9IFtjYWxsYmFja10gLSBJZiBpdCdzIHByZXNlbnQgaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb25cbiAqIHRoYXQgcmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGlzIHB1c2hlZCB0byB0aGUgbmV3IGFycmF5LlxuICogQHJldHVybnMge0Fycn0gTmV3IGluc3RhbmNlIG9mIEFyci5cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBhcnJheSBmcm9tIHRoZSBsZW5ndGggdXNpbmcgb3B0aW9uYWwgY2FsbGJhY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGFycmF5KDMpLiQ7ICAgICAgICAgICAgICAgLy8gWzAsIDEsIDJdXG4gKiBhcnJheSgzLCAoaSkgPT4gaSAqIDIpLiQ7IC8vIFswLCAyLCA0XVxuICovXG5mdW5jdGlvbiBhcnJheShudW1iZXIsIGNhbGxiYWNrKSB7XG4gIHZhbGlkYXRlKFtudW1iZXIsIGNhbGxiYWNrXSwgW1snaW50TGlrZScsICc+PTAnXSwgJ2Z1bmN0aW9ufHwhJ10sICdhcnJheScpO1xuXG4gIGNvbnN0IGFycmF5ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xuICAgIGFycmF5LnB1c2goY2FsbGJhY2sgPyBjYWxsYmFjayhpKSA6IGkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBBcnIoYXJyYXkpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpdGVyYXRlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0l0ZXJhdGVDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbiB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHJlcGxhY2luZyBmb3IgKC4uLikgY29uc3RydWN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpdGVyYXRlKCk7XG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdGUobnVtYmVyLCBjYWxsYmFjaykge1xuICB2YWxpZGF0ZShbbnVtYmVyLCBjYWxsYmFja10sIFtbJ2ludExpa2UnLCAnPj0wJ10sICdmdW5jdGlvbiddLCAnaXRlcmF0ZScpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICBjYWxsYmFjayhpKTtcbiAgfVxufVxuXG5leHBvcnQgeyBBcnIsIGFycmF5LCBpdGVyYXRlIH07XG4iLCIvKipcbiAqIEBtb2R1bGUgQmxvYk9iamVjdFxuICogQHByaXZhdGVcbiAqIEBtaXhpblxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgQmxvYk9iamVjdCBjbGFzcy5cbiAqL1xuXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBpc0FycmF5LCBpc0Z1bmN0aW9uLFxuICB0b1N0cmluZ1RhZywgU3ltYm9sLCBkZWZpbmVQcm9wZXJ0aWVzXG59IGZyb20gJy4vaGVscGVycyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3sgYnVmZmVyOiBTdHJpbmcsIGJpbmFyeTogU3RyaW5nLCBkYXRhVVJMOiBTdHJpbmcsIHRleHQ6IFN0cmluZyB9fSBtZXRob2RzXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIExpc3Qgb2YgcmVhZCBibG9iIG1ldGhvZHMuXG4gKi9cbmNvbnN0IG1ldGhvZHMgPSB7XG4gIGJ1ZmZlcjogJ0FycmF5QnVmZmVyJyxcbiAgYmluYXJ5OiAnQmluYXJ5U3RyaW5nJyxcbiAgZGF0YVVSTDogJ0RhdGFVUkwnLFxuICB0ZXh0OiAnVGV4dCdcbn07XG5jb25zdCB7IFVSTCB9ID0gZ2xvYmFsO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoJ2J1ZmZlcid8J2JpbmFyeSd8J2RhdGFVUkwnfCd0ZXh0Jyl9IFJlYWRCbG9iTWV0aG9kXG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRW51bSB0eXBlIG9mIHJlYWQgYmxvYiBtZXRob2RzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld3xCbG9ifFN0cmluZ30gQmxvYlBhcnRzXG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gQWxsb3dlZCBibG9iIHBhcnRzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlYWRlckV2ZW50TGlzdGVuZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBGaXJlZCBldmVudC5cbiAqIEBwYXJhbSB7RmlsZVJlYWRlcn0gcmVhZGVyIC0gRmlsZVJlYWRlci5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBCbG9iT2JqZWN0XG4gKiBAZXh0ZW5kcyBTdXBlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtCbG9ifSBibG9iIC0gQmxvYiB0byB3cmFwLlxuICogQHJldHVybnMge0Jsb2JPYmplY3R9IEluc3RhbmNlIG9mIEJsb2JPYmplY3QuXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhIGJsb2IuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBCbG9iT2JqZWN0KG5ldyBCbG9iKFsne1wiZm9vXCI6XCJiYXJcIn0nXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSkpO1xuICovXG5jbGFzcyBCbG9iT2JqZWN0IGV4dGVuZHMgU3VwZXIge1xuICAvKipcbiAgICogQG1lbWJlciBCbG9iT2JqZWN0IyRcbiAgICogQHR5cGUge0Jsb2J9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIE9yaWdpbmFsIEJsb2IuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEJsb2JPYmplY3QjZGF0YVVSTFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBkYXRhVVJMIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBibG9iLlxuICAgKi9cbiAgZ2V0IGRhdGFVUkwoKSB7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2JPYmplY3QjcmVhZEFzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtSZWFkQmxvYk1ldGhvZH0gbWV0aG9kIC0gTWV0aG9kIHRoYXQgaXMgdXNlZCBmb3IgcmVhZGluZyBmcm9tIGJsb2IuXG4gICAqIEBwYXJhbSB7UmVhZGVyRXZlbnRMaXN0ZW5lcn0gW3Byb2dyZXNzXSAtIFByb2dyZXNzIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGNvdWxkIGJlIGFib3J0ZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHJlYWRpbmcgZnJvbSBibG9icy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEJsb2JPYmplY3QobmV3IEJsb2IoWyd7XCJmb29cIjpcImJhclwifSddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSlcbiAgICogICAucmVhZEFzKCd0ZXh0JylcbiAgICogICAudGhlbigodmFsdWUpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJ3tcImZvb1wiOlwiYmFyXCJ9J1xuICAgKiAgIH0pO1xuICAgKi9cbiAgcmVhZEFzKG1ldGhvZCwgcHJvZ3Jlc3MpIHtcbiAgICBpZiAoIW1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCcxc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgZm9sbG93aW5nIHZhbHVlczogYnVmZmVyLCBiaW5hcnksIGRhdGFVUkwsIHRleHQnKTtcbiAgICB9XG5cbiAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBsZXQgdG9SZWplY3Q7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihwcm9ncmVzcykpIHtcbiAgICAgIHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcHJvZ3Jlc3MoZSwgdGhpcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0b1JlamVjdCA9IHJlamVjdDtcblxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgICAgcmVqZWN0KHRhcmdldC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICByZXNvbHZlKHRhcmdldC5yZXN1bHQpO1xuICAgICAgfTtcblxuICAgICAgcmVhZGVyW2ByZWFkQXMkeyBtZXRob2RzW21ldGhvZF0gfWBdKHRoaXMuJCk7XG4gICAgfSk7XG5cbiAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICB0b1JlamVjdChuZXcgRXJyb3IoJ1JlYWRpbmcgd2FzIGFib3J0ZWQnKSk7XG5cbiAgICAgIHJlYWRlci5hYm9ydCgpO1xuXG4gICAgICByZWFkZXIgPSBudWxsO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9iT2JqZWN0I3NhdmVBc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBOYW1lIHRoYXQgaXMgdXNlZCBmb3Igc2F2aW5nIGZpbGUuXG4gICAqIEByZXR1cm5zIHtCbG9iT2JqZWN0fSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHNhdmluZyBibG9icy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEJsb2JPYmplY3QobmV3IEJsb2IoWyd7XCJmb29cIjpcImJhclwifSddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSlcbiAgICogICAuc2F2ZUFzKCdibG9iLmpzb24nKTtcbiAgICovXG4gIHNhdmVBcyhuYW1lID0gJ2Rvd25sb2FkJykge1xuICAgIGNvbnN0IGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgIGFuY2hvci5ocmVmID0gdGhpcy5kYXRhVVJMO1xuICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgbmFtZSk7XG4gICAgYW5jaG9yLmNsaWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEJsb2JPYmplY3QucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnQmxvYk9iamVjdCdcbn0pO1xuXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XG4gIGNoZWNrOiAoYmxvYikgPT4gL14oQmxvYnxGaWxlKSQvLnRlc3QodG9TdHJpbmdUYWcoYmxvYikpLFxuICBjbHM6IEJsb2JPYmplY3Rcbn0pO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBibG9iXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyhCbG9iUGFydHNbXXxCbG9iUGFydHMpfSBibG9iUGFydHMgLSBCbG9iIHBhcnRzIHRoYXQgYXJlIHBhc3NlZCB0b1xuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iL0Jsb2J9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvXG4gKiBbQmxvYl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYn0gY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7QmxvYk9iamVjdH0gTmV3IGluc3RhbmNlIG9mIEJsb2JPYmplY3QuXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGJsb2JzIG5vdCBpbnZvbHZpbmcgQmxvYk9iamVjdCBhbmQgQmxvYiBjb25zdHJ1Y3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGJsb2IoYmxvYlBhcnRzLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFpc0FycmF5KGJsb2JQYXJ0cykpIHtcbiAgICBibG9iUGFydHMgPSBbYmxvYlBhcnRzXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQmxvYk9iamVjdChuZXcgQmxvYihibG9iUGFydHMsIG9wdGlvbnMpKTtcbn1cblxuZXhwb3J0IHsgQmxvYk9iamVjdCwgYmxvYiB9O1xuIiwiLyoqXG4gKiBAbW9kdWxlIFN0clxuICogQHByaXZhdGVcbiAqIEBtaXhpblxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgU3RyIGNsYXNzLlxuICovXG5cbmltcG9ydCB7IEQgfSBmcm9tICcuL0QnO1xuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcbmltcG9ydCB7IGNvbnN0cnVjdG9ycywgcmVnZXhwU3BlY2lhbENoYXJhY3RlcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBpc0Z1bmN0aW9uLCBpc051bWJlckxpa2UsIGlzT2JqZWN0LCBpc1N0cmluZyxcbiAgdmFsaWRhdGUsIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllcywgaXRlcmF0ZVxufSBmcm9tICcuL2hlbHBlcnMnO1xuXG5jb25zdCBodG1sU3BlY2lhbHMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnXG59O1xuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxuICBuZXcgU3VwZXIocmVnZXhwU3BlY2lhbENoYXJhY3RlcnMpXG4gICAgLndvcmQoKHgpID0+IGBcXFxcJHsgeCB9fGApXG4gICAgLnJlcGxhY2UoL1xcfCQvLCAnJyksXG4gICdnJ1xuKTtcblxuLyoqXG4gKiBAY2xhc3MgU3RyXG4gKiBAZXh0ZW5kcyBTdXBlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IFtzdHJpbmcgPSAnJ10gLSBBIHN0cmluZyB0byB3cmFwLlxuICogQHJldHVybnMge1N0cn0gSW5zdGFuY2Ugb2YgU3RyLlxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHMgPSBuZXcgTnVtKCcxJyk7XG4gKi9cbmNsYXNzIFN0ciBleHRlbmRzIFN1cGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nID0gJycpIHtcbiAgICBzdXBlcihgJHsgc3RyaW5nIH1gKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgU3RyIyRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzY3JpcHRpb24gT3JpZ2luYWwgc3RyaW5nLlxuICAgICAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI2NhcGl0YWxpemVGaXJzdFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IENhcGl0YWxpemVkIHN0cmluZy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHN5bWJvbC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignZm9vJykuY2FwaXRhbGl6ZUZpcnN0KCkuJDsgLy8gJ0ZvbydcbiAgICovXG4gIGNhcGl0YWxpemVGaXJzdCgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLiQ7XG5cbiAgICByZXR1cm4gbmV3IFN0cihzdHJpbmcuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjZW5kc1dpdGhcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uID0gc3RyaW5nLmxlbmd0aF0gLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCB0aGUgYXJndW1lbnQgc3RyaW5nLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW1N0cmluZyNlbmRzV2l0aF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRofS5cbiAgICovXG4gIGVuZHNXaXRoKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy4kLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICAgICAgLnNsaWNlKDAsIHBvc2l0aW9uKVxuICAgICAgLnJldmVydCgpXG4gICAgICAuc3RhcnRzV2l0aChuZXcgU3RyKHNlYXJjaFN0cmluZykucmV2ZXJ0KCkuJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjZXNjYXBlSFRNTFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2RzIGVzY2FwaW5nIFwiJlwiLCBcIjxcIiBhbmQgXCI+XCIgc3ltYm9scy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignXCIxIDwgMlwiICYgXCI3ID4gNFwiIGFyZSB0cnVlIGV4cHJlc3Npb25zLicpLmVzY2FwZUhUTUwoKS4kO1xuICAgKiAvLyAnXCIxICZsdDsgMlwiICZhbXAgXCI3ICZndDsgMlwiIGFyZSB0cnVlIGV4cHJlc3Npb25zLidcbiAgICovXG4gIGVzY2FwZUhUTUwoKSB7XG4gICAgbGV0IHN0cmluZyA9IHRoaXMuJDtcblxuICAgIGl0ZXJhdGUoaHRtbFNwZWNpYWxzLCAoZXNjYXBlZCwgc3ltYm9sKSA9PiB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHN5bWJvbCwgJ2cnKSwgZXNjYXBlZCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFN0cihzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI2VzY2FwZVJlZ0V4cFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZXNjYXBpbmcgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignKDIxMy45OCAtIFtdIHt9KScpLmVzY2FwZVJlZ0V4cCgpLiQ7IC8vICdcXCgyMTNcXC45OCBcXC0gXFxbXFxdIFxce1xcfVxcKSdcbiAgICovXG4gIGVzY2FwZVJlZ0V4cCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjaW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayB0aGUgc3RyaW5nIGFzIGEgcHJvcGVydHkgaW4uXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBpdCBpcyBpbiB0aGUgb2JqZWN0IG9yIG5vdC5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgc3RyaW5nIGluIG9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignYScpLmluKHsgYTogMSB9KTsgLy8gdHJ1ZVxuICAgKiBuZXcgU3RyKCd0b0ZpeGVkJykuaW4oMSk7ICAvLyBmYWxzZVxuICAgKiBuZXcgU3RyKCdhJykuaW4obnVsbCk7ICAgICAvLyBmYWxzZVxuICAgKi9cbiAgaW4ob2JqZWN0KSB7XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuJCBpbiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjaW5kZXhPZlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hWYWx1ZSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXggPSAwXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge051bWJlcn0gRm91bmQgaW5kZXggb3IgLTEuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luZGV4T2ZcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjaW5kZXhPZl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luZGV4T2Z9LlxuICAgKi9cbiAgaW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuJC5pbmRleE9mLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciNsYXN0SW5kZXhPZlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hWYWx1ZSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXggPSBzdHJpbmcubGVuZ3RoXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge051bWJlcn0gRm91bmQgaW5kZXggb3IgLTEuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2xhc3RJbmRleE9mXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbU3RyaW5nI2xhc3RJbmRleE9mXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbGFzdEluZGV4T2Z9LlxuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoVmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLiQubGFzdEluZGV4T2YuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIgU3RyI2xlbmd0aFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9sZW5ndGhcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjbGVuZ3RoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbGVuZ3RofS5cbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuJC5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjbWF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QXJyfFN1cGVyfSBELVdyYXAgb2YgZm91bmQgbWF0Y2guXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL21hdGNoXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbU3RyaW5nI21hdGNoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbWF0Y2h9LlxuICAgKi9cbiAgbWF0Y2gocmVnZXhwKSB7XG4gICAgcmV0dXJuIEQodGhpcy4kLm1hdGNoLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjcmVwZWF0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSB0aW1lcyAtIFRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjcmVwZWF0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignMTIzJykucmVwZWF0KDIpLiQ7IC8vICcxMjMxMjMnXG4gICAqIG5ldyBTdHIoJzEyMycpLnJlcGVhdCgwKS4kOyAvLyAnJ1xuICAgKi9cbiAgcmVwZWF0KHRpbWVzKSB7XG4gICAgdmFsaWRhdGUoW3RpbWVzXSwgW1snaW50TGlrZScsICc+PTAnXV0sICdTdHIjcmVwZWF0Jyk7XG5cbiAgICB0aW1lcyA9ICt0aW1lcztcblxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuJDtcblxuICAgIGxldCBzID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcbiAgICAgIHMgKz0gc3RyaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RyKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI3JlcGxhY2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHJlZ2V4cCAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtyZXBsYWNlciA9ICcnXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZVxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW1N0cmluZyNyZXBsYWNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZX1cbiAgICogYmVzaWRlcyB0aGF0IHJlcGxhY2VyIGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgJycuXG4gICAqL1xuICByZXBsYWNlKHJlZ2V4cCwgcmVwbGFjZXIgPSAnJykge1xuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5yZXBsYWNlKHJlZ2V4cCwgcmVwbGFjZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciNyZXBsYWNlU3RyaW5nXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIFN0cmluZyB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGxhY2VyID0gJyddIC0gU3RyaW5nIHRvIHJlcGxhY2Ugd2l0aC5cbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2xvYmFsIHN0cmluZyByZXBsYWNlaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3RyKCcxMjMxMjMnKS5yZXBsYWNlU3RyaW5nKCcxJywgJzQnKS4kOyAvLyAnNDIzNDIzJ1xuICAgKiBuZXcgU3RyKCcxMjMxMjMnKS5yZXBsYWNlU3RyaW5nKCcxJykuJDsgICAgICAvLyAnMjMyMydcbiAgICovXG4gIHJlcGxhY2VTdHJpbmcoc3RyaW5nLCByZXBsYWNlciA9ICcnKSB7XG4gICAgc3RyaW5nID0gbmV3IFN1cGVyKHN0cmluZykuJDtcblxuICAgIHZhbGlkYXRlKFtzdHJpbmddLCBbJ3N0cmluZyddLCAnU3RyI3JlcGxhY2VTdHJpbmcnKTtcblxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5zcGxpdChzdHJpbmcpLmpvaW4ocmVwbGFjZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciNyZXZlcnRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2Ygc3RyaW5nLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZXZlcnRpbmcgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdHIoJzEyMzQnKS5yZXZlcnQoKS4kOyAvLyAnNDMyMSdcbiAgICovXG4gIHJldmVydCgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLiQ7XG4gICAgbGV0IHN0ciA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0cmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc3RyICs9IHN0cmluZ1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0cihzdHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI3NlYXJjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaCwgaWYgZm91bmQsIGFuZCAtMSBpZiBub3QuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NlYXJjaFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW1N0cmluZyNzZWFyY2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zZWFyY2h9LlxuICAgKi9cbiAgc2VhcmNoKHJlZ2V4cCkge1xuICAgIHZhbGlkYXRlKFtyZWdleHBdLCBbJ3JlZ2V4cCddKTtcblxuICAgIHJldHVybiB0aGlzLiQuc2VhcmNoLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciNzbGljZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW5TbGljZSA9IDBdIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZFNsaWNlID0gc3RyaW5nLmxlbmd0aF0gLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NsaWNlXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbU3RyaW5nI3NsaWNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc2xpY2V9LlxuICAgKi9cbiAgc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQuc2xpY2UuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciNzcGxpdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gW3NlcGFyYXRvcl0gLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtBcnJ8U3VwZXJ9IEQtV3JhcCBvZiB0aGUgYXJyYXkuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NwbGl0XG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbU3RyaW5nI3NwbGl0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3BsaXR9LlxuICAgKi9cbiAgc3BsaXQoc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIEQodGhpcy4kLnNwbGl0LmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjc3RhcnRzV2l0aFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmcgLSBTZWUgdGhlIGxpbmsuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb24gPSAwXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBhcmd1bWVudCBzdHJpbmcuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjc3RhcnRzV2l0aF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGh9LlxuICAgKi9cbiAgc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMCkge1xuICAgIHJldHVybiB0aGlzLiQuaW5kZXhPZi5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cykgPT09IHBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI3N1YnN0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQgPSAwXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZW5ndGggPSBzdHJpbmcubGVuZ3RoXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbU3RyaW5nI3N1YnN0cl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N1YnN0cn0uXG4gICAqL1xuICBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5zdWJzdHIuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciNzdWJzdHJpbmdcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4U3RhcnQgPSAwXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleEVuZCA9IHN0cmluZy5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdWJzdHJpbmdcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjc3Vic3RyaW5nXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyaW5nfS5cbiAgICovXG4gIHN1YnN0cmluZyhpbmRleFN0YXJ0LCBpbmRleEVuZCkge1xuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5zdWJzdHJpbmcuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciN0b0NhbWVsQ2FzZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGZvbGxvd2luZyByZWdleHAgL1xcc1xcLV9cXC4vIG1ha2luZyB0aGUgc3RyaW5nIGNhbWVsIGNhc2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvQ2FtZWxDYXNlKCkuJDsgIC8vICdzcGluYWxDYXNlJ1xuICAgKiBuZXcgU3RyKCdfc25ha2VfY2FzZV8nKS50b0NhbWVsQ2FzZSgpLiQ7IC8vICdzbmFrZUNhc2UnXG4gICAqL1xuICB0b0NhbWVsQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvLVteLV0vZywgKG1hdGNoKSA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgLnJlcGxhY2UoL15bXFxTXS8sIChtYXRjaCkgPT4gbWF0Y2gudG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI3RvQ2FwaXRhbENhc2VcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBmb2xsb3dpbmcgcmVnZXhwIC9cXC1fXFwuLyBtYWtpbmcgdGhlIHN0cmluZyBjYXBpdGFsIGxldHRlciBjYXNlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignc3BpbmFsLWNhc2UnKS50b0NhcGl0YWxDYXNlKCkuJDsgIC8vICdTcGluYWwgQ2FzZSdcbiAgICogbmV3IFN0cignX3NuYWtlX2Nhc2VfJykudG9DYXBpdGFsQ2FzZSgpLiQ7IC8vICdTbmFrZSBDYXNlJ1xuICAgKi9cbiAgdG9DYXBpdGFsQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnICcpXG4gICAgICAucmVwbGFjZSgvW1xcU10vZywgKG1hdGNoKSA9PiAoXG4gICAgICAgIG1hdGNoLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoID8gbWF0Y2ggOiBgICR7IG1hdGNoIH1gXG4gICAgICApKVxuICAgICAgLnJlcGxhY2UoL1xcc1tcXFNdL2csIChtYXRjaCkgPT4gbWF0Y2gudG9VcHBlckNhc2UoKSlcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICAgIC5yZXBsYWNlKC9eXFxzLywgJycpXG4gICAgICAucmVwbGFjZSgvXltcXFNdLywgKG1hdGNoKSA9PiBtYXRjaC50b1VwcGVyQ2FzZSgpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjdG9Eb3RDYXNlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFwtX1xcLi8gbWFraW5nIHRoZSBzdHJpbmcgZG90IGNhc2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvRG90Q2FzZSgpLiQ7ICAvLyAnc3BpbmFsLmNhc2UnXG4gICAqIG5ldyBTdHIoJ19zbmFrZV9jYXNlXycpLnRvRG90Q2FzZSgpLiQ7IC8vICdzbmFrZS5jYXNlJ1xuICAgKi9cbiAgdG9Eb3RDYXNlKCkge1xuICAgIHJldHVybiBuZXcgU3RyKHRyaW0odGhpcy4kKVxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICcuJylcbiAgICAgIC5yZXBsYWNlKC9bXi5dL2csIChtYXRjaCkgPT4gKFxuICAgICAgICBtYXRjaC50b0xvd2VyQ2FzZSgpID09PSBtYXRjaCA/IG1hdGNoIDogYC4keyBtYXRjaCB9YFxuICAgICAgKSlcbiAgICAgIC5yZXBsYWNlKC9cXC4rL2csICcuJylcbiAgICAgIC5yZXBsYWNlKC9eXFwuLywgJycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjdG9IeXBoZW5DYXNlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFxzXFwtX1xcLi8gbWFraW5nIHRoZSBzdHJpbmcgY2FtZWwgY2FzZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdHIoJ2NhbWVsQ2FzZScpLnRvU3BpbmFsQ2FzZSgpLiQ7ICAgIC8vICdjYW1lbC1jYXNlJ1xuICAgKiBuZXcgU3RyKCdfc25ha2VfY2FzZV8nKS50b1NwaW5hbENhc2UoKS4kOyAvLyAnc25ha2UtY2FzZSdcbiAgICovXG4gIHRvSHlwaGVuQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvW14tXS9nLCAobWF0Y2gpID0+IChcbiAgICAgICAgbWF0Y2gudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2ggPyBtYXRjaCA6IGAtJHsgbWF0Y2ggfWBcbiAgICAgICkpXG4gICAgICAucmVwbGFjZSgvLSsvZywgJy0nKVxuICAgICAgLnJlcGxhY2UoL14tLywgJycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjdG9Mb3dlckNhc2VcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90b0xvd2VyQ2FzZVxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RvTG93ZXJDYXNlfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFN0cignVVBQRVItQ0FTRScpLnRvTG93ZXJDYXNlKCkuJDsgIC8vICd1cHBlci1jYXNlJ1xuICAgKi9cbiAgdG9Mb3dlckNhc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI3RvU25ha2VDYXNlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFxzXFwtXFwuLyBtYWtpbmcgdGhlIHN0cmluZyBzcGluYWwgY2FzZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBTdHIoJ3NwaW5hbC1jYXNlJykudG9TbmFrZUNhc2UoKS4kOyAvLyAnc3BpbmFsX2Nhc2UnXG4gICAqIG5ldyBTdHIoJ2NhbWVsQ2FzZScpLnRvU25ha2VDYXNlKCkuJDsgICAvLyAnY2FtZWxfY2FzZSdcbiAgICovXG4gIHRvU25ha2VDYXNlKCkge1xuICAgIHJldHVybiBuZXcgU3RyKHRyaW0odGhpcy4kKVxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICdfJylcbiAgICAgIC5yZXBsYWNlKC9bXl9dL2csIChtYXRjaCkgPT4gKFxuICAgICAgICBtYXRjaC50b0xvd2VyQ2FzZSgpID09PSBtYXRjaCA/IG1hdGNoIDogYF8keyBtYXRjaCB9YFxuICAgICAgKSlcbiAgICAgIC5yZXBsYWNlKC9fKy9nLCAnXycpXG4gICAgICAucmVwbGFjZSgvXl8vLCAnJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciN0b1NwYWNlQ2FzZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGZvbGxvd2luZyByZWdleHAgL1xcLV9cXC4vIG1ha2luZyB0aGUgc3RyaW5nIHNwYWNlIGNhc2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3RyKCdzcGluYWwtY2FzZScpLnRvU3BhY2VDYXNlKCkuJDsgIC8vICdzcGluYWwgY2FzZSdcbiAgICogbmV3IFN0cignX3NuYWtlX2Nhc2VfJykudG9TcGFjZUNhc2UoKS4kOyAvLyAnc25ha2UgY2FzZSdcbiAgICovXG4gIHRvU3BhY2VDYXNlKCkge1xuICAgIHJldHVybiBuZXcgU3RyKHRyaW0odGhpcy4kKVxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICcgJylcbiAgICAgIC5yZXBsYWNlKC9bXFxTXS9nLCAobWF0Y2gpID0+IChcbiAgICAgICAgbWF0Y2gudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2ggPyBtYXRjaCA6IGAgJHsgbWF0Y2ggfWBcbiAgICAgICkpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAucmVwbGFjZSgvXlxccy8sICcnKVxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICApO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciN0b1VwcGVyQ2FzZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RvVXBwZXJDYXNlXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdG9VcHBlckNhc2V9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgU3RyKCdsb3dlci1jYXNlJykudG9VcHBlckNhc2UoKS4kOyAgLy8gJ0xPV0VSLUNBU0UnXG4gICAqL1xuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQudG9VcHBlckNhc2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBTdHIjdHJpbVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW1cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjdHJpbV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW19LlxuICAgKi9cbiAgdHJpbSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQucmVwbGFjZSgvXltcXHNcXHVmZWZmXFx1MDBhMF0rfFtcXHNcXHVmZWZmXFx1MDBhMF0rJC9nLCAnJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgU3RyI3RyaW1MZWZ0XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbUxlZnRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjdHJpbUxlZnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltTGVmdH0uXG4gICAqL1xuICB0cmltTGVmdCgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQucmVwbGFjZSgvXltcXHNcXHVmZWZmXFx1MDBhMF0rLywgJycpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFN0ciN0cmltUmlnaHRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltUmlnaHRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtTdHJpbmcjdHJpbVJpZ2h0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbVJpZ2h0fS5cbiAgICovXG4gIHRyaW1SaWdodCgpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQucmVwbGFjZSgvW1xcc1xcdWZlZmZcXHUwMGEwXSskLywgJycpKTtcbiAgfVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKFN0ci5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdTdHInXG59KTtcblxuY29uc3RydWN0b3JzWzJdLnB1c2goe1xuICBjaGVjazogaXNTdHJpbmcsXG4gIGNsczogU3RyXG59KTtcblxuZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eW1xcc1xcLV8uXSt8W1xcc1xcLV8uXSskL2csICcnKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gcGFyc2VKU09OXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gW2pzb24gPSBudWxsXSAtIFN0cmluZyB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufCp9IFtvcHRpb25zLm51bWJlcnNdIC0gSWYgaXQgaXMgbmVlZGVkIHRvIHBhcnNlIG51bWJlci1saWtlIHN0cmluZ3MgYXMgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbb3B0aW9ucy5kYXRlc10gLSBJZiBpdCBpcyBuZWVkZWQgdG8gcGFyc2UgZGF0ZS1saWtlIHN0cmluZyBhcyBkYXRlcy5cbiAqIERhdGUtbGlrZSBzdHJpbmcgaXMgY29uc2lkZXJlZCB0byBtYXRjaCBeXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGRcXGRcXGRaPyRcbiAqIEBwYXJhbSB7SlNPTkNhbGxiYWNrfSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgdGhhdCBjYWxsZWQgb24gZXZlcnkgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0RXcmFwfSBELVdyYXAgb2YgZm91bmQgbWF0Y2guXG4gKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBwYXJzaW5nIGpzb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIHBhcnNlSlNPTigneyBcImFcIjogMSB9JykuJDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geyBhOiAxIH1cbiAqIHBhcnNlSlNPTigneyBcImFcIjogXCIxXCIgfScsIHsgbnVtYmVyczogdHJ1ZSB9KS4kOyAgICAgICAgICAgICAgICAgICAgICAvLyB7IG51bWJlcnM6IHRydWUgfVxuICogcGFyc2VKU09OKCd7IFwiYVwiOiBcIjE5OTktMTItMzFUMjM6NTk6NTkuOTk5WlwiIH0nLCB7IGRhdGVzOiB0cnVlIH0pLiQ7IC8vIHsgYTogRGF0ZSB7Li4ufSB9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTihqc29uID0gbnVsbCwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIEQoSlNPTi5wYXJzZShqc29uKSk7XG4gIH1cblxuICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7IG51bWJlcnMsIGRhdGVzIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb24sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGRhdGVzICYmIC9eXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGRcXGRcXGRaPyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG51bWJlcnMgJiYgaXNOdW1iZXJMaWtlKHZhbHVlKSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBEKHBhcnNlZCk7XG59XG5cbmV4cG9ydCB7IFN0ciwgcGFyc2VKU09OIH07XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy9tYXJrdXBUb0pTT05cbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBtYXJrdXBUb0pTT04gbWV0aG9kLlxuICovXG5cbmltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuLi9TdHInO1xuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4uL1N3aXRjaGVyJztcbmltcG9ydCB7IGh0bWxBbGxvd2VkVGFnU3ltYm9scywgaHRtbEFsbG93ZWRBdHRyU3ltYm9scywgdm9pZEVsZW1lbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi9jaGVja1R5cGVzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXJrdXBFbGVtZW50XG4gKiBAcHJvcGVydHkgeydjb21tZW50J3wndGV4dCd8J2VsZW1lbnQnfSB0eXBlIC0gVHlwZSBvZiB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7TWFya3VwRWxlbWVudH0gcGFyZW50IC0gVHlwZSBvZiB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IGF0dHJzIC0gTm9kZSBhdHRyaWJ1dGVzXG4gKiBAcHJvcGVydHkge01hcmt1cEVsZW1lbnRbXX0gY2hpbGRyZW4gLSBOb2RlIGNoaWxkcmVuLlxuICovXG5cbmNvbnN0IHN1Ym1pdFN0cmluZyA9ICdQbGVhc2UsIHN1Ym1pdCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZHdheW5lanMvZHdheW5lL2lzc3Vlcy9uZXcsIGlmIG5lZWRlZC4nO1xuY29uc3QgTk9ERV9SRUdFWF9TRVQgPSBuZXcgU3VwZXIoe1xuICAndGFnLW9wZW4nOiBuZXcgUmVnRXhwKGA8KCR7IGh0bWxBbGxvd2VkVGFnU3ltYm9scyB9KVxcXFxzKmAsICdpJyksXG4gICd0YWctY2xvc2UnOiBjb25zdHJ1Y3RDbG9zZVRhZ1JlZ0V4cChodG1sQWxsb3dlZFRhZ1N5bWJvbHMpLFxuICBjb21tZW50OiAvPCEtLSgoPzotW15cXC0+XXxbXlxcLT5dKSg/Oi0/W14tXSkqW14tXT98KS0tPi9cbn0pO1xuY29uc3QgVEFHX09QRU5fQ0xPU0UgPSAvXihcXC8/KT4vO1xuLy8gY29uc3QgQVRUUklCVVRFID0gL14oW15cXHUwMDAwLVxcdTAwMjBcXHNcIic+XFwvPV0rKSg/Olxccyo9XFxzKignW14nXSonfFwiW15cIl0qXCJ8W15cXHNcIidgPD49XSspKT9cXHMqLztcbmNvbnN0IEFUVFJJQlVURSA9IG5ldyBSZWdFeHAoYF4oJHsgaHRtbEFsbG93ZWRBdHRyU3ltYm9scyB9KSg/OlxcXFxzKj1cXFxccyooJ1teJ10qJ3xcIlteXCJdKlwifFteXFxcXHNcIidcXGA8Pj1dKykpP1xcXFxzKmApO1xuY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jb25zdCBub2RlU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKGVsZW0pID0+IGVsZW0pXG4gIC5jYXNlKCd0YWctb3BlbicsIChlbGVtLCBub2RlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICBzZWxmQ2xvc2luZ1xuICAgIH0gPSBub2RlO1xuXG4gICAgbm9kZSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICBhdHRyczogbmV3IFN1cGVyKG5vZGUuYXR0cnMpLm1hcCgodmFsdWUpID0+IChcbiAgICAgICAgdmFsdWUgPT09IHRydWVcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBwYXJzZUNoYXJhY3RlckRhdGEodmFsdWUpXG4gICAgICApKS4kLFxuICAgICAgcGFyZW50OiBlbGVtLFxuICAgICAgY2hpbGRyZW46IG5ldyBBcnIoW10pXG4gICAgfTtcblxuICAgIGVsZW0uY2hpbGRyZW4ucHVzaChub2RlKTtcblxuICAgIGlmICghc2VsZkNsb3NpbmcgJiYgdm9pZEVsZW1lbnRzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICBlbGVtID0gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbTtcbiAgfSlcbiAgLmNhc2UoJ3RhZy1jbG9zZScsIChlbGVtLCBub2RlKSA9PiB7XG4gICAgaWYgKGVsZW0ubmFtZSA9PT0gbm9kZS52YWx1ZSkge1xuICAgICAgZWxlbSA9IGVsZW0ucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtO1xuICB9KVxuICAuY2FzZShbJ2NvbW1lbnQnLCAndGV4dCddLCAoZWxlbSwgbm9kZSwgY29sbGFwc2VXaGl0ZVNwYWNlLCB0eXBlKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgIG5hbWU6IGAjJHsgdHlwZSB9YCxcbiAgICAgIHBhcmVudDogZWxlbSxcbiAgICAgIHZhbHVlOiBub2RlLnZhbHVlXG4gICAgfTtcblxuICAgIGlmICh0eXBlID09PSAndGV4dCcgJiYgZWxlbS5uYW1lICE9PSAnc2NyaXB0JyAmJiBlbGVtLm5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgIGVsZW1lbnQudmFsdWUgPSBwYXJzZUNoYXJhY3RlckRhdGEoZWxlbWVudC52YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xsYXBzZVdoaXRlU3BhY2UpIHtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ldyBTdHIoZWxlbWVudC52YWx1ZSkudHJpbSgpLiQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb2xsYXBzZVdoaXRlU3BhY2UgfHwgIS9eXFxzKiQvLnRlc3QoZWxlbWVudC52YWx1ZSkpIHtcbiAgICAgIGVsZW0uY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbTtcbiAgfSk7XG5jb25zdCByYXdUZXh0U3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgZmFsc2UpXG4gIC5jYXNlKFsndGl0bGUnLCAndGV4dGFyZWEnLCAnc3R5bGUnLCAnc2NyaXB0J10sIHRydWUpO1xuXG5jbGFzcyBJbnRlcm5hbFBhcnNpbmdFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbmNsYXNzIFBhcnNpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgdHlwZSA9ICdQQVJTSU5HX0VSUk9SJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gbWFya3VwVG9KU09OXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1hcmt1cCAtIE1hcmt1cCB0byBwYXJzZSB0byBKU09OLlxuICogQHBhcmFtIHtCb29sZWFufSBbY29sbGFwc2VXaGl0ZVNwYWNlID0gZmFsc2VdIC0gSWYgdGhlIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIGNvbGxhcHNlZC5cbiAqIEByZXR1cm5zIHtBcnIuPE1hcmt1cEVsZW1lbnQ+fSBNYXJrdXAgZWxlbWVudHMgYXJyYXkuXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIHBhcnNpbmcgaHRtbCBhbmQgeG1sIHRvIEpTT04uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChtYXJrdXAsIGNvbGxhcHNlV2hpdGVTcGFjZSkgPT4ge1xuICBjb2xsYXBzZVdoaXRlU3BhY2UgPSAhIWNvbGxhcHNlV2hpdGVTcGFjZTtcblxuICBjb25zdCBlbGVtZW50cyA9IG5ldyBBcnIoW10pO1xuICBjb25zdCBzdGFydE1hcmt1cCA9IG1hcmt1cDtcbiAgbGV0IGZvdW5kO1xuICBsZXQgZ2xvYmFsSW5kZXggPSAwO1xuICBsZXQgZWxlbSA9IHtcbiAgICBuYW1lOiBudWxsLFxuICAgIGNoaWxkcmVuOiBlbGVtZW50c1xuICB9O1xuXG4gIHdoaWxlIChtYXJrdXAubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZvdW5kID0gZmluZChtYXJrdXAsIGVsZW0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgSW50ZXJuYWxQYXJzaW5nRXJyb3IpKSB7XG4gICAgICAgIHRocm93VW5leHBlY3RlZEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoYFBhcnNpbmcgZXJyb3IgbmVhciBpbmRleCAkeyBuZWFyU3RyaW5nKHN0YXJ0TWFya3VwLCBnbG9iYWxJbmRleCArIGVyci5pbmRleCkgfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBhdHRycyxcbiAgICAgIHNlbGZDbG9zaW5nLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWx1ZVxuICAgIH0gPSBmb3VuZDtcblxuICAgIGdsb2JhbEluZGV4ICs9IGluZGV4O1xuXG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgdGhyb3dVbmV4cGVjdGVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZSxcbiAgICAgIHZhbHVlXG4gICAgfTtcblxuICAgIGlmICh0eXBlID09PSAndGFnLW9wZW4nKSB7XG4gICAgICBub2RlLmF0dHJzID0gYXR0cnM7XG4gICAgICBub2RlLnNlbGZDbG9zaW5nID0gc2VsZkNsb3Npbmc7XG4gICAgfVxuXG4gICAgZWxlbSA9IG5vZGVTd2l0Y2hlcihub2RlLnR5cGUsIFtlbGVtLCBub2RlLCBjb2xsYXBzZVdoaXRlU3BhY2VdKTtcblxuICAgIG1hcmt1cCA9IG1hcmt1cC5zbGljZShpbmRleCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHM7XG5cbiAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihgVW5leHBlY3RlZCBwYXJzaW5nIGVycm9yIG5lYXIgaW5kZXggJHsgbmVhclN0cmluZyhzdGFydE1hcmt1cCwgZ2xvYmFsSW5kZXgpIH0uICR7IHN1Ym1pdFN0cmluZyB9YCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmQobWFya3VwLCBlbGVtKSB7XG4gIGNvbnN0IHsgbmFtZSB9ID0gZWxlbTtcbiAgbGV0IG1hdGNoZXM7XG5cbiAgaWYgKHJhd1RleHRTd2l0Y2hlcihuYW1lKSkge1xuICAgIG1hdGNoZXMgPSBuZXcgU3VwZXIoe1xuICAgICAgJ3RhZy1jbG9zZSc6IG1hcmt1cC5tYXRjaChjb25zdHJ1Y3RDbG9zZVRhZ1JlZ0V4cChuYW1lKSlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXRjaGVzID0gTk9ERV9SRUdFWF9TRVQubWFwKChyZWdleCkgPT4gKFxuICAgICAgbWFya3VwLm1hdGNoKHJlZ2V4KVxuICAgICkpO1xuICB9XG5cbiAgbGV0IG1hdGNoO1xuXG4gIGlmIChcbiAgICBtYXRjaCA9IG1hdGNoZXMuZmluZCgobWF0Y2gpID0+IChcbiAgICAgIG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwXG4gICAgKSlcbiAgKSB7XG4gICAgY29uc3QgcmV0dXJuaW5nID0ge1xuICAgICAgdHlwZTogbWF0Y2gua2V5LFxuICAgICAgaW5kZXg6IG1hdGNoLnZhbHVlWzBdLmxlbmd0aCxcbiAgICAgIHZhbHVlOiBtYXRjaC52YWx1ZVsxXVxuICAgIH07XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcblxuICAgIGlmIChtYXRjaC5rZXkgPT09ICd0YWctb3BlbicpIHtcbiAgICAgIGNvbnN0IHN0YXJ0TWFya3VwID0gbWFya3VwO1xuICAgICAgbGV0IGNsb3NlTWF0Y2g7XG5cbiAgICAgIHJldHVybmluZy5zZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuaW5nLmF0dHJzID0gYXR0cnM7XG5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgKG1hcmt1cCA9IHN0YXJ0TWFya3VwLnNsaWNlKHJldHVybmluZy5pbmRleCkpICYmXG4gICAgICAgICEoY2xvc2VNYXRjaCA9IG1hcmt1cC5tYXRjaChUQUdfT1BFTl9DTE9TRSkpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IG1hcmt1cC5tYXRjaChBVFRSSUJVVEUpO1xuXG4gICAgICAgIGlmICghYXR0cikge1xuICAgICAgICAgIHJldHVybmluZy5pbmRleCArPSAxO1xuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyc1thdHRyWzFdXSA9IGlzVW5kZWZpbmVkKGF0dHJbMl0pXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiBhdHRyWzJdLnJlcGxhY2UoL14oXCJ8Jyl8KFwifCcpJC9nLCAnJyk7XG4gICAgICAgIHJldHVybmluZy5pbmRleCArPSBhdHRyWzBdLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsb3NlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuaW5nLmluZGV4ICs9IGNsb3NlTWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm5pbmcuc2VsZkNsb3NpbmcgPSAhIWNsb3NlTWF0Y2hbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVybmluZztcbiAgfVxuXG4gIGxldCB7IHZhbHVlOiBpbmRleCB9ID0gbWF0Y2hlcy5taW4oKG1hdGNoKSA9PiAoXG4gICAgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IE5hTlxuICApKTtcblxuICBpZiAoaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgaW5kZXggPSBtYXJrdXAubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgaW5kZXgsXG4gICAgdmFsdWU6IG1hcmt1cC5zbGljZSgwLCBpbmRleClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xvc2VUYWdSZWdFeHAodGFnTmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgPC8oJHsgdGFnTmFtZSB9KVxcXFxzKj5gLCAnaScpO1xufVxuXG5mdW5jdGlvbiBuZWFyU3RyaW5nKG1hcmt1cCwgaW5kZXgpIHtcbiAgcmV0dXJuIGAkeyBpbmRleCB9ICh+fn4gXCIkeyBtYXJrdXAuc2xpY2UoaW5kZXgsIGluZGV4ICsgMTUpIH1cIiB+fn4sIHRoZSBzdHJpbmcgaXRzZWxmIGlzIFwiJHsgbWFya3VwIH1cIilgO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNoYXJhY3RlckRhdGEoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJihcXHcrfCN4P1xcZCspOy9nLCAobWF0Y2gpID0+IHtcbiAgICBkaXYuaW5uZXJIVE1MID0gbWF0Y2g7XG5cbiAgICByZXR1cm4gZGl2LnRleHRDb250ZW50IHx8IGRpdi5pbm5lclRleHQ7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEVsZW1cbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEVsZW0gY2xhc3MuXG4gKi9cblxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcbmltcG9ydCB7IEFyciwgYXJyYXksIGl0ZXJhdGUgYXMgdGltZXMgfSBmcm9tICcuL0Fycic7XG5pbXBvcnQgeyBibG9iIH0gZnJvbSAnLi9CbG9iT2JqZWN0JztcbmltcG9ydCB7IG1ldGhvZCB9IGZyb20gJy4vRnVuYyc7XG5pbXBvcnQgeyBQcm9taXNlIH0gZnJvbSAnLi9Qcm9taXNlJztcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4vU3RyJztcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi9Td2l0Y2hlcic7XG5pbXBvcnQge1xuICBjb25zdHJ1Y3RvcnMsIGFwcGxpZWRSZWdFeHBzLCBodG1sRWxlbWVudHMsIHN2Z0VsZW1lbnRzLFxuICBjYW52YXNHZXRNZXRob2RzLCBjYW52YXNSZXN0TWV0aG9kc1xufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBpc0FycmF5LCBpc0FycmF5TGlrZSwgaXNFbGVtZW50LCBpc0Z1bmN0aW9uLFxuICBpc0ludGVnZXIsIGlzTmlsLCBpc051bWJlciwgaXNOdWxsLCBpc1N0cmluZyxcbiAgYXNzaWduLCBkeW5hbWljRGVmaW5lUHJvcGVydGllcywgZGVmaW5lUHJvcGVydGllcywgdG9BcnJheSxcbiAgdmFsaWRhdGUsIHRvU3RyaW5nVGFnLCBpdGVyYXRlLCBTeW1ib2xcbn0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCBtYXJrdXBUb0pTT04gZnJvbSAnLi9oZWxwZXJzL21hcmt1cFRvSlNPTic7XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ30gRWxlbUV2ZW50U3RyaW5nXG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gQSBzdHJpbmcgY29udGFpbmluZyBldmVudHMgc2VwYXJhdGVkIGJ5IGEgY29tbWEgd2l0aCB6ZXJvIG9yIG1vcmUgc3BhY2VzIG9yIGp1c3Qgc3BhY2VzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1WYWx1ZUNhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBPbGQgdmFsdWUuXG4gKiBAcGFyYW0ge0VsZW19IGVsZW0gLSBDdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBpbiB0aGUgc2V0IG9mIHRoZSBlbGVtZW50cy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtU2V0T2ZDYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fSBjcmVhdGVkIC0gQ3JlYXRlZCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBpdGVyYXRlZCBlbGVtZW50IGluIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0ge0tleX0ga2V5IC0gS2V5IG9mIHRoZSBpdGVyYXRlZCBlbGVtZW50IGluIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0aGF0IGlzIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBDdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFZhbGlkYXRlQ2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBFbGVtZW50IHZhbHVlLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gRWxlbWVudCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBlbGVtZW50LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEN0eENhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ2FudmFzIHJlbmRlcmluZyBjb250ZXh0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1MaXN0ZW5lclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFdmVudH0gZSAtIEZpcmVkIGV2ZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gRWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1SZW1vdmVMaXN0ZW5lcnNcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Li4uRWxlbUV2ZW50U3RyaW5nfSBldmVudHMgLSBJZiBhdCBsZWFzdCBvbmUgYXJndW1lbnQgcHJlc2VudCBvbmx5IHJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIHNwZWNpZmllZFxuICogYnkgdGhlIGV2ZW50cyBpbiB0aGUgYXJndW1lbnRzLlxuICovXG5cbmNvbnN0IG5hdGl2ZURvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuY29uc3QgZW1wdHlEaXYgPSBuYXRpdmVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnN0IGV2ZW50U2VwYXJhdG9yID0gLyg/Oix8ICkgKi87XG5jb25zdCB0ZXh0UHJvcGVydHkgPSBuZXcgU3VwZXIoTm9kZS5wcm90b3R5cGUpLnByb3BlcnR5RGVzY3JpcHRvcigndGV4dENvbnRlbnQnKSA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbmNvbnN0IGNsYXNzZXMgPSB7fTtcbmNvbnN0IGF0dHJzID0ge307XG5jb25zdCB3aW5kb3dzRHdheW5lRGF0YSA9IG5ldyBBcnIoW10pO1xuY29uc3QgaW5wdXRFbGVtZW50cyA9ICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgZGF0YWxpc3QsIGtleWdlbiwgb3V0cHV0JztcbmNvbnN0IGNsaWNrID0gbWV0aG9kKCdjbGljaycpO1xuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuY29uc3QgeG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmNvbnN0IHhodG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCB0eXBlU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsIChlbGVtLCB0eXBlKSA9PiB7XG4gIGNvbnN0IG5zID0gdHlwZSA9PT0gJ3N2ZydcbiAgICA/IHN2Z05TXG4gICAgOiBlbGVtLnByb3AoJ25hbWVzcGFjZVVSSScpIHx8IG5hdGl2ZURvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgfHwgeGh0bWxOUztcblxuICByZXR1cm4gbmF0aXZlRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0eXBlKTtcbn0pXG4gIC5jYXNlKFxuICAgICh0eXBlKSA9PiB0eXBlID09PSAnI2NvbW1lbnQnLFxuICAgICgpID0+IG5hdGl2ZURvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpXG4gIClcbiAgLmNhc2UoXG4gICAgKHR5cGUpID0+IHR5cGUgPT09ICcjdGV4dCcsXG4gICAgKCkgPT4gbmF0aXZlRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpXG4gICk7XG5jb25zdCByZWZTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAnaHJlZicpXG4gIC5jYXNlKFxuICAgIFsnaW1nJywgJ3NjcmlwdCcsICdpZnJhbWUnLCAnYXVkaW8nLCAndmlkZW8nXSxcbiAgICAnc3JjJ1xuICApXG4gIC5jYXNlKFxuICAgICdmb3JtJyxcbiAgICAnYWN0aW9uJ1xuICApO1xuY29uc3QgZmlsdGVyU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsIChzZWxlY3RvcikgPT4gc2VsZWN0b3IpXG4gIC5jYXNlKFxuICAgIGlzU3RyaW5nLFxuICAgIChzZWxlY3RvcikgPT4gKFxuICAgICAgKGVsZW0pID0+IG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKVxuICAgIClcbiAgKVxuICAuY2FzZShcbiAgICBbaXNBcnJheSwgaXNFbGVtXSxcbiAgICAoZWxlbXMpID0+IHtcbiAgICAgIGVsZW1zID0gbmV3IEFycihlbGVtcyk7XG5cbiAgICAgIHJldHVybiAoZWxlbSkgPT4gZWxlbXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gICAgfVxuICApO1xuY29uc3QgaW5uZXJTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAwKVxuICAuY2FzZSgncGFkZGluZy1ib3gnLCAocGFkZGluZ3MpID0+IHBhZGRpbmdzKVxuICAuY2FzZSgnYm9yZGVyLWJveCcsIChwYWRkaW5ncywgYm9yZGVycykgPT4gcGFkZGluZ3MgKyBib3JkZXJzKTtcbmNvbnN0IG91dGVyU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgKGJvcmRlcnMsIHBhZGRpbmdzKSA9PiBib3JkZXJzICsgcGFkZGluZ3MpXG4gIC5jYXNlKCdwYWRkaW5nLWJveCcsIChib3JkZXJzKSA9PiBib3JkZXJzKVxuICAuY2FzZSgnYm9yZGVyLWJveCcsIDApO1xuY29uc3QgYXR0ck5TU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsIG51bGwpXG4gIC5jYXNlKChhdHRyKSA9PiBhdHRyID09PSAneG1sbnMnIHx8IGF0dHIgPT09ICd4bWxuczp4bGluaycsIChlbGVtKSA9PiAoXG4gICAgZWxlbS5uYW1lID09PSAnc3ZnJ1xuICAgICAgPyB4bWxOU1xuICAgICAgOiBudWxsXG4gICkpXG4gIC5jYXNlKChhdHRyKSA9PiAvXnhsaW5rOlxcdy8udGVzdChhdHRyKSwgKGVsZW0pID0+IChcbiAgICBlbGVtLmNsb3Nlc3QoJ3N2ZycpLmxlbmd0aFxuICAgICAgPyB4bGlua05TXG4gICAgICA6IG51bGxcbiAgKSk7XG5cbi8qKlxuICogQGNsYXNzIEVsZW1cbiAqIEBleHRlbmRzIEFyclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gW2VsZW0gPSBbXV0gLSBBbiBlbGVtZW50IG9yIGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RWxlbX0gSW5zdGFuY2Ugb2YgRWxlbS5cbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGFuIGVsZW1lbnRzIHNldC4gQWxzbyBoYXMgYWxsIG1ldGhvZHMgZnJvbSBmcm9tXG4gKiBbQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfS5cbiAqIEdldHRlcnMgbWV0aG9kcyByZXR1cm4gdGhlIHNhbWUgYXMgbWV0aG9kcyBmcm9tIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBhbmQgdGhlIHJlc3QgcmV0dXJuIHRoaXMuXG4gKiBXb3JrIGZvciB0aGUgZmlyc3QgY2FudmFzIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG4gKiBuZXcgRWxlbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2xzJykpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xzJykpO1xuICovXG5jbGFzcyBFbGVtIGV4dGVuZHMgQXJyIHtcbiAgY29uc3RydWN0b3IoZWxlbSA9IFtdKSB7XG4gICAgc3VwZXIoKCgpID0+IHtcbiAgICAgIGxldCBlbGVtZW50ID0gZWxlbTtcblxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGVsZW1lbnQpICYmIChcbiAgICAgICAgaXNXaW5kb3coZWxlbWVudCkgfHxcbiAgICAgICAgaXNIVE1MRG9jdW1lbnQoZWxlbWVudCkgfHxcbiAgICAgICAgaXNEb2N1bWVudEZyYWdtZW50KGVsZW1lbnQpIHx8XG4gICAgICAgIGlzRWxlbWVudChlbGVtZW50KSB8fFxuICAgICAgICBpc0NvbW1lbnRPclRleHQoZWxlbWVudCkgfHxcbiAgICAgICAgaXNTdHlsZVJ1bGUoZWxlbWVudClcbiAgICAgICkpIHtcbiAgICAgICAgZWxlbWVudCA9IFtlbGVtZW50XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBcnIodG9BcnJheShuZXcgU3VwZXIoZWxlbWVudCkuJCwgdHJ1ZSkpLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcbiAgICAgICAgaWYgKGVsZW1zLmluZGV4T2YoZWxlbSkgPT09IC0xICYmIChcbiAgICAgICAgICBpc0VsZW1lbnQoZWxlbSkgfHxcbiAgICAgICAgICBpc1dpbmRvdyhlbGVtKSB8fFxuICAgICAgICAgIGlzSFRNTERvY3VtZW50KGVsZW0pIHx8XG4gICAgICAgICAgaXNEb2N1bWVudEZyYWdtZW50KGVsZW0pIHx8XG4gICAgICAgICAgaXNDb21tZW50T3JUZXh0KGVsZW0pIHx8XG4gICAgICAgICAgaXNTdHlsZVJ1bGUoZWxlbSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIHJldHVybiBlbGVtcy5wdXNoKGVsZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRWxlbShlbGVtKSkge1xuICAgICAgICAgIGVsZW1zLnB1c2guYXBwbHkoZWxlbXMsIGVsZW0uJCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtdKS4kO1xuICAgIH0pKCkpO1xuXG4gICAgdGhpcy4kJCA9IGVsZW07XG5cbiAgICB0aGlzLmZvckVhY2goYWRkRHdheW5lRGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheS48Tm9kZXxXaW5kb3c+fSBFbGVtIyRcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE5vZGV8V2luZG93Pn1cbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnN0cnVjdGVkIGVsZW1lbnQgc2V0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Kn0gRWxlbSMkJFxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbCBlbGVtZW50IHNldC5cbiAgICAgKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYWRkXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi4oU3RyaW5nfEVsZW18RWxlbWVudHxFbGVtZW50W10pfSBlbGVtZW50cyAtIEVhY2ggYXJndW1lbnQgaXMgYSBzZWxlY3Rvciwgb3IgRWxlbSwgb3IgRWxlbWVudCwgb3IgYXJyYXkgb2YgRWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgZWxlbWVudHMgdG8gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbTEuZmluZCgnLmNsczEnKVxuICAgKiAgIC5hZGQoZWxlbTIuZmluZCgnLmNsczInKSlcbiAgICogICAuaGlkZSgpO1xuICAgKi9cbiAgYWRkKC4uLmVsZW1lbnRzKSB7XG4gICAgaXRlcmF0ZShhcmd1bWVudHMsIChlbGVtKSA9PiB7XG4gICAgICB0b0ZpbmQoZWxlbSkuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pbmRleE9mKGVsZW0pID09PSAtMSkge1xuICAgICAgICAgIHRoaXMucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYWRkQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY2xhc3NlcyB0byB0aGUgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmFkZENsYXNzKCdyZWQnLCAncm91bmQnKTtcbiAgICovXG4gIGFkZENsYXNzKC4uLmNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XG5cbiAgICAgIGl0ZXJhdGUoaXNFbGVtZW50KGVsZW0pICYmIGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5hZGQoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2FkZENvbW1lbnRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRleHQgb2YgY29tbWVudCB0byBhZGQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGNvbW1lbnQgc2hvdWxkIGJlIGluc2VydGVkIHRvIHRoZSBlbmQuIElmIGZhbHNlIGl0J3MgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY29tbWVudCB0byBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkSFRNTCgnPGRpdj4xPC9kaXY+Jyk7XG4gICAqL1xuICBhZGRDb21tZW50KHRleHQsIGVuZCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XG4gICAgICAgIGVsZW0uaW5zZXJ0QWRqYWNlbnRIVE1MKGVuZCA/ICdiZWZvcmVlbmQnIDogJ2FmdGVyYmVnaW4nLCBgPCEtLSR7IHRleHQgfS0tPmApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRIVE1MXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgLSBIVE1MIHRvIGFkZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmQgLSBJZiB0aGUgSFRNTCBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgaXQncyBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBIVE1MIHRvIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRIVE1MKCc8ZGl2PjE8L2Rpdj4nKTtcbiAgICovXG4gIGFkZEhUTUwoaHRtbCwgZW5kID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcbiAgICAgICAgZWxlbS5pbnNlcnRBZGphY2VudEhUTUwoZW5kID8gJ2JlZm9yZWVuZCcgOiAnYWZ0ZXJiZWdpbicsIGh0bWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRSdWxlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBydWxlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciBmb3IgdGhlIHJ1bGVcbiAgICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gc3R5bGUgLSBTdHlsZSBmb3IgdGhlIHNlbGVjdG9yLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY3NzIHN0eWxlcyBpbnRvIHRoZSBmaXJzdCBzdHlsZSB0YWcgaW4gdGhlIHNldC5cbiAgICogTm90ZTogc3R5bGUgZWxlbWVudCBzaG91bGQgYmUgaW5zaWRlIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogc3R5bGUuYWRkUnVsZSgnaW1nLXNpemUnLCAnaW1nLnNxdWFyZScsIHtcbiAgICogICB3aWR0aDogJzQwcHggIWltcG9ydGFudCcsXG4gICAqICAgaGVpZ2h0OiAnNDBweCAhaW1wb3J0YW50J1xuICAgKiB9KTtcbiAgICovXG4gIGFkZFJ1bGUobmFtZSwgc2VsZWN0b3IsIHN0eWxlKSB7XG4gICAgdGhpcy5zb21lKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZ2V0TmFtZShlbGVtKSA9PT0gJ3N0eWxlJykge1xuICAgICAgICBjb25zdCB7IHNoZWV0IH0gPSBlbGVtO1xuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc2hlZXQuY3NzUnVsZXM7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gbmV3IFN1cGVyKHN0eWxlKS53b3JkKCh2YWx1ZSwgcHJvcGVydHkpID0+IChcbiAgICAgICAgICBgJHsgbmV3IFN0cihwcm9wZXJ0eSkudG9IeXBoZW5DYXNlKCkgfTogJHsgdmFsdWUgfTtcXG5gXG4gICAgICAgICkpO1xuXG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoXG4gICAgICAgICAgYCR7IHNlbGVjdG9yIH0geyR7IHJ1bGVzICYmICdcXG4nIH0keyBydWxlcyB9fWAsXG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIHNoZWV0LmNzc1J1bGVzW2xlbmd0aF0uZHdheW5lRGF0YSA9IHsgbmFtZSB9O1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2FkZFRleHRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRleHQgdG8gYWRkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSB0ZXh0IHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSBpdCdzIGluc2VydGVkIHRvIHRoZSBzdGFydC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIHRleHQgdG8gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmFkZFRleHQoJzEyMycpO1xuICAgKi9cbiAgYWRkVGV4dCh0ZXh0LCBlbmQgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpLmludG8oZWxlbSwgZW5kKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYXBwbHlcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gc3RyaW5ncyAtIFN0cmluZ3MgdG8gYXBwbHkuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCBpcyBhIHNob3J0aGFuZCBmb3IgbWFueSBvdGhlciBtZXRob2RzLlxuICAgKiBBbGwgc2hvcnRoYW5kcyBjYW4gYmUgc2VwYXJhdGVkIHdpdGggc3BhY2UgYW5kIHdyaXR0ZW4gd2l0aGluIG9uZSBzdHJpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXBwbHkoXG4gICAqICAgJyNpZCAuYzEgLmMyIEBib3JkZXIoMXB4IHNvbGlkIGJsYWNrKSAkZGlzYWJsZWQgJGF0dHIoc29tZSB2YWx1ZSkgKihDbGljayBtZSEpJ1xuICAgKiApO1xuICAgKiAvLyBzaG9ydGhhbmQgZm9yXG4gICAqIC8vIGVsZW1cbiAgICogLy8gICAuaWQoJ2lkJylcbiAgICogLy8gICAuYWRkQ2xhc3MoJ2MxJywgJ2MyJylcbiAgICogLy8gICAuY3NzKCdib3JkZXInLCAnMXB4IHNvbGlkIGJsYWNrJylcbiAgICogLy8gICAuYXR0cih7XG4gICAqIC8vICAgICBhdHRyLCAnc29tZSB2YWx1ZSdcbiAgICogLy8gICAgIGRpc2FibGVkOiAnJ1xuICAgKiAvLyAgIH0pXG4gICAqIC8vICAgLnRleHQoJ0NsaWNrIG1lIScpO1xuICAgKiAvLyBUaGVyZSBpcyBhIGZ1bGwgbGlzdCBvZiBwb3NzaWJsZSB0eXBlcyBvZiBzeW50YXggYmVsb3cuLi5cbiAgICpcbiAgICogZWxlbS5hcHBseSgnI2lkJyk7ICAgICAgICAgICAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uaWQoJ2lkJyk7XG4gICAqIGVsZW0uYXBwbHkoJy5jMSAuYzInKTsgICAgICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmFkZENsYXNzKCdjMScsICdjMicpO1xuICAgKiBlbGVtLmFwcGx5KCctLmMxIC0uYzInKTsgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5yZW1vdmVDbGFzcygnYzEnLCAnYzInKTtcbiAgICogZWxlbS5hcHBseSgnLUBmbG9hdCAtQGRpc3BsYXknKTsgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0ucmVtb3ZlQ1NTKCdmbG9hdCcsICdkaXNwbGF5Jyk7XG4gICAqIGVsZW0uYXBwbHkoJy0kYTEgLSRhMicpOyAgICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLnJlbW92ZUF0dHIoJ2ExJywgJ2EyJyk7XG4gICAqIGVsZW0uYXBwbHkoJyooc29tZSB0ZXh0KScpOyAgICAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLnRleHQoJ3NvbWUgdGV4dCcpO1xuICAgKiBlbGVtLmFwcGx5KCcmKDxkaXY+MTwvZGl2PiknKTsgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5odG1sKCc8ZGl2PjE8L2Rpdj4nKTtcbiAgICogZWxlbS5hcHBseSgnQGZsb2F0KHJpZ2h0KScpOyAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uY3NzKCdmbG9hdCcsICdyaWdodCcpO1xuICAgKiBlbGVtLmFwcGx5KCdAdHJhbnNmb3JtKHNjYWxlKDVweCkpJyk7IC8vIHNob3J0aGFuZCBmb3IgZWxlbS5jc3MoJ3RyYW5zZm9ybScsICdzY2FsZSg1cHgpJyk7XG4gICAqIGVsZW0uYXBwbHkoJ0BtYXJnaW4oMnB4IDJweCknKTsgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmNzcygnbWFyZ2luJywgJzJweCAycHgnKTtcbiAgICogZWxlbS5hcHBseSgnQG1hcmdpbkxlZnQoMnB4KScpOyAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uY3NzKCdtYXJnaW5MZWZ0JywgJzJweCAycHgnKTtcbiAgICogZWxlbS5hcHBseSgnQG1hcmdpbi1sZWZ0KDJweCknKTsgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uY3NzKCdtYXJnaW4tbGVmdCcsICcycHggMnB4Jyk7XG4gICAqIGVsZW0uYXBwbHkoJyRhdHRyKHNvbWUgdmFsdWUpJyk7ICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmF0dHIoJ2F0dHInLCAnc29tZSB2YWx1ZScpO1xuICAgKiBlbGVtLmFwcGx5KCckYXR0cicpOyAgICAgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5hdHRyKCdhdHRyJywgJycpO1xuICAgKi9cbiAgYXBwbHkoLi4uc3RyaW5ncykge1xuICAgIGxldCBhcHBsaWVkO1xuICAgIGxldCBzZXRBcHBsaWVkO1xuICAgIGxldCBjYWxsYmFjaztcbiAgICBsZXQgbmFtZTtcbiAgICBsZXQgbnAxO1xuICAgIGxldCBzbGljZTtcblxuICAgIG5ldyBTdHIobmV3IEFycihhcmd1bWVudHMpLmpvaW4oJyAnKSlcbiAgICAgIC5zcGxpdCgvKFxccyspLylcbiAgICAgIC5mb3JFYWNoKChzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFhcHBsaWVkKSB7XG4gICAgICAgICAgbnAxID0gc3RyaW5nLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIGNhbGxiYWNrID0gYXBwbGllZFJlZ0V4cHNbbnAxXTtcbiAgICAgICAgICBzbGljZSA9IDE7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrW3N0cmluZy5zbGljZSgxLCAyKV07XG4gICAgICAgICAgICBzbGljZSA9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKC9eXFxzKyQvLnRlc3Qoc3RyaW5nKSB8fCAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYW1lID0gc3RyaW5nLnNsaWNlKHNsaWNlKS5tYXRjaCgvXlteKCldKy8pO1xuXG4gICAgICAgICAgaWYgKCFuYW1lICYmIChucDEgIT09ICcqJyAmJiBucDEgIT09ICcmJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcHBsaWVkID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSA/IG5hbWVbMF0gOiAnJyxcbiAgICAgICAgICAgIGFyZ3M6IHN0cmluZy5zbGljZShzbGljZSArIChuYW1lID8gbmFtZVswXSA6ICcnKS5sZW5ndGgpLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2V0QXBwbGllZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNldEFwcGxpZWQpIHtcbiAgICAgICAgICBhcHBsaWVkLmFyZ3MgKz0gc3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhcHBsaWVkLmFyZ3MgfHwgL15cXChbXFxzXFxTXStcXCkkLy50ZXN0KGFwcGxpZWQuYXJncykpIHtcbiAgICAgICAgICBhcHBsaWVkLmNhbGxiYWNrKHRoaXMsIGFwcGxpZWQubmFtZSwgYXBwbGllZC5hcmdzLnJlcGxhY2UoL15cXCh8XFwpJC9nLCAnJykpO1xuICAgICAgICAgIGFwcGxpZWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXBwbGllZCA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2s+fSBbYXR0cl0gLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW2F0dHJOYW1lXTogdmFsdWUsIC4uLiB9IHRvIHNldCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtVmFsdWVDYWxsYmFja30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICAgKiBpdCBzaG91bGQgYmUgYSB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyB7U3VwZXJ8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBhdHRyaWJ1dGVzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQsIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHIxJywgJ3ZhbHVlMScpOyAvLyBhdHRyaWJ1dGUgYXR0cjEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uYXR0cignYXR0cjEnKTsgICAgICAgICAgIC8vICd2YWx1ZTEnXG4gICAqIGVsZW0uYXR0cih7XG4gICAqICAgYXR0cjE6ICd2YWx1ZTMnLCAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMydcbiAgICogICBhdHRyMjogJ3ZhbHVlMicgICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uYXR0cigpLiQ7ICAgICAgICAgICAgICAgIC8vIHsgYXR0cjE6ICd2YWx1ZTMnLCBhdHRyMjogJ3ZhbHVlMicgfVxuICAgKi9cbiAgYXR0cihhdHRyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGVsZW0gPSBnZXRFbGVtKHRoaXMpO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFN1cGVyKGVsZW0uYXR0cmlidXRlcykub2JqZWN0KChvLCBhdHRyKSA9PiB7XG4gICAgICAgIG9bYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKGF0dHIpKSB7XG4gICAgICBjb25zdCBucyA9IGF0dHJOU1N3aXRjaGVyKGF0dHIsIFtuZXcgRWxlbShlbGVtKV0pO1xuXG4gICAgICByZXR1cm4gaXNOdWxsKG5zKVxuICAgICAgICA/IGVsZW0uZ2V0QXR0cmlidXRlKGF0dHIpXG4gICAgICAgIDogZWxlbS5nZXRBdHRyaWJ1dGVOUyhucywgYXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgYXR0ciA9IHsgW2F0dHJdOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5ldyBTdXBlcihhdHRyKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUobmV3IEVsZW0oZWxlbSkuYXR0cihrZXkpLCBlbGVtLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVBdHRyKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZTtcblxuICAgICAgICBjb25zdCBucyA9IGF0dHJOU1N3aXRjaGVyKGtleSwgW25ldyBFbGVtKGVsZW0pXSk7XG5cbiAgICAgICAgaWYgKGlzTnVsbChucykpIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZU5TKG5zLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Jsb2JcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMgPSB7fV0gLSBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCBpbnRvIHtAbGluayBibG9ifS5cbiAgICogQHJldHVybnMge1Byb21pc2UuPEJsb2JPYmplY3Q+fSBOZXcgaW5zdGFuY2Ugb2YgcHJvbWlzZS5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSB7QGxpbmsgQmxvYk9iamVjdH0gUHJvbWlzZS4gV29ya3Mgd2l0aCBpbWFnZSBvciBjYW52YXMgZmlyc3QgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1hZ2UuYmxvYigpLnRoZW4oKGJsb2IpID0+IGNvbnNvbGUubG9nKGJsb2IpKTsgIC8vIEJsb2JPYmplY3RcbiAgICogY2FudmFzLmJsb2IoKS50aGVuKChibG9iKSA9PiBjb25zb2xlLmxvZyhibG9iKSk7IC8vIEJsb2JPYmplY3RcbiAgICovXG4gIGJsb2Iob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmZpcnN0KCk7XG4gICAgICBjb25zdCB7IG5hbWUgfSA9IGVsZW07XG5cbiAgICAgIGlmIChuYW1lICE9PSAnaW1nJyAmJiBuYW1lICE9PSAnY2FudmFzJykge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaXNuXFwndCBhbiBpbWFnZSBvciBhIGNhbnZhcyEgKEVsZW0jYmxvYiknKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnY2FudmFzJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShlbGVtKTtcbiAgICAgIH1cblxuICAgICAgZWxlbVxuICAgICAgICAubG9hZCgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAoZWxlbS5pc0Jyb2tlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVGhlIGltYWdlIGlzIGJyb2tlbiEgKEVsZW0jYmxvYiknKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQpLmNhbnZhcygpO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZWxlbS53aWR0aCgpO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGVsZW0uaGVpZ2h0KCk7XG5cbiAgICAgICAgICBjYW52YXNcbiAgICAgICAgICAgIC53aWR0aCh3aWR0aClcbiAgICAgICAgICAgIC5oZWlnaHQoaGVpZ2h0KVxuICAgICAgICAgICAgLmRyYXdJbWFnZShlbGVtLiRbMF0sIDAsIDApO1xuXG4gICAgICAgICAgcmVzb2x2ZShjYW52YXMpO1xuICAgICAgICB9KTtcbiAgICB9KS50aGVuKChjYW52YXMpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMuZGF0YVVSTCgpO1xuICAgICAgY29uc3QgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVSTC5zcGxpdCgnLCcpWzFdKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVTdHJpbmcubGVuZ3RoO1xuICAgICAgY29uc3QgYWIgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXG4gICAgICB0aW1lcyhsZW5ndGgsIChpKSA9PiB7XG4gICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBibG9iKGFiLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYmx1clxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9ibHVyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbSFRNTEVsZW1lbnQjYmx1cl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2JsdXJ9LlxuICAgKi9cbiAgYmx1cigpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XG4gICAgICAgIGVsZW0uYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjYWxjQ1NTXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHNldWRvXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge0NTU1N0eWxlRGVjbGFyYXRpb259IFNlZSB0aGUgbGluay5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93L2dldENvbXB1dGVkU3R5bGVcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtnZXRDb21wdXRlZFN0eWxlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93L2dldENvbXB1dGVkU3R5bGV9LlxuICAgKiBSZXR1cm5zIGNvbXB1dGVkIHN0eWxlIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGNhbGNDU1MocHNldWRvID0gbnVsbCkge1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGdldEVsZW0odGhpcyksIHBzZXVkbyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NoYW5nZVJ1bGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHJ1bGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IHN0eWxlIC0gU3R5bGUgZm9yIHRoZSBzZWxlY3Rvci5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY2hhbmdpbmcgY3NzIHN0eWxlcyBpbiB0aGUgZmlyc3Qgc3R5bGUgdGFnIGluIHRoZSBzZXQuXG4gICAqIE5vdGU6IHN0eWxlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2lkZSB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLmNoYW5nZVJ1bGUoJ2ltZy1zaXplJywge1xuICAgKiAgIHdpZHRoOiAnNTBweCAhaW1wb3J0YW50JyxcbiAgICogICBoZWlnaHQ6ICc1MHB4ICFpbXBvcnRhbnQnXG4gICAqIH0pO1xuICAgKi9cbiAgY2hhbmdlUnVsZShuYW1lLCBzdHlsZSkge1xuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogcnVsZSB9ID0gbmV3IEFycihlbGVtLnNoZWV0LmNzc1J1bGVzKS5maW5kKChydWxlKSA9PiBydWxlLmR3YXluZURhdGEgJiYgcnVsZS5kd2F5bmVEYXRhLm5hbWUgPT09IG5hbWUpIHx8IHt9O1xuXG4gICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgbmV3IEVsZW0ocnVsZSkuY3NzKHN0eWxlKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY2hpbGRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8RWxlbXxFbGVtZW50fEVsZW1lbnRbXX0gZWxlbWVudCAtIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciBhIHdyYXAgb2YgdGhlIHNldCBvZiB0aGUgY2hpbGRyZW5cbiAgICogb2YgdGhpcyBpbmRleCBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZCBvdGhlcndpc2UgYW4gZWxlbWVudCB0byBwdXQgaW50byB0aGlzIGVsZW1lbnQsIGEgY29sbGVjdGlvblxuICAgKiBvciBhIHNlbGVjdG9yIG9mIGl0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgdGhleSBhcmUgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyBhIHdyYXAgb2YgY2hpbGRyZW4gb3IgaW5zZXJ0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNhcHBlbmRDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvYXBwZW5kQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBjaGlsZCA9IGVsZW0uY2hpbGQoMSk7XG4gICAqXG4gICAqIGVsZW0uY2hpbGQoZWxlbTIpO1xuICAgKiBlbGVtLmNoaWxkKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5jaGlsZCgnI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgY2hpbGQoZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xuICAgIGlmIChpc0ludGVnZXIoZWxlbWVudCkgJiYgZWxlbWVudCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbigpLmVsZW0oZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvRmluZChlbGVtZW50KS5pbnRvKHRoaXMsIGVuZCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NoaWxkcmVuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IEQtV3JhcCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBlbGVtZW50J3MgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbigpO1xuICAgKi9cbiAgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXMubGVuZ3RoID8gdGhpcy4kWzBdLmNoaWxkTm9kZXMgOiBbXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjbHNdIC0gSWYgaXQncyBwcmVzZW50IGl0IGhhcyB0byBjb250YWluIGNsYXNzIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtBcnJ8RWxlbX0gSWYgdGhlIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhpcyByZXR1cm5lZCBvdGhlcndpc2UgYSB3cmFwIG9mIHRoZSBjbGFzc2VzIGFycmF5IHJldHVybmVkLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgY2xhc3Nlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jbGFzcygnYzEgYzInKTsgLy8gY2xhc3Mgc2V0IHRvICdjMSBjMidcbiAgICogZWxlbS5jbGFzcygpLiQ7ICAgICAgLy8gWydjMScsICdjMiddXG4gICAqL1xuICBjbGFzcyhjbHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyKGdldEVsZW0odGhpcykuY2xhc3NOYW1lLnNwbGl0KCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NsaWNrXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2NsaWNrXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbSFRNTEVsZW1lbnQjY2xpY2tde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9jbGlja30uXG4gICAqL1xuICBjbGljaygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XG4gICAgICAgIGVsZW0uY2xpY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY2xvbmVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2RlZXAgPSBmYWxzZV0gLSBTZWUgdGhlZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvY2xvbmVOb2RlXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbTm9kZSNjbG9uZU5vZGVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2Nsb25lTm9kZX0uXG4gICAqL1xuICBjbG9uZShkZWVwID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XG4gICAgICBlbGVtcy5hZGQoZWxlbS5jbG9uZU5vZGUoISFkZWVwKSk7XG4gICAgfSwgbmV3IEVsZW0oKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nsb3Nlc3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBTZWUgdGhlIGxpbmsuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBTZXQgb2YgdGhlIGNsb3Nlc3QgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNjbG9zZXN0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0fS5cbiAgICovXG4gIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1zLmFkZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSwgbmV3IEVsZW0oKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NvbnRhaW5zXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudFxuICAgKiBpbiB0aGUgc2V0IG9yIGEgc2VsZWN0b3Igb2YgaXQuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGlmIHRoZSBhcmd1bWVudCB3aXRoaW4gdGhpcyBlbGVtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIGV4dGVuc2lvbiBmb3JcbiAgICogW05vZGUjY29udGFpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbnRhaW5zfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbTEuY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcbiAgICogZWxlbS5jb250YWlucyhzZWxlY3Rvcik7IC8vIHRydWV8ZmFsc2VcbiAgICovXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9GaW5kKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGdldEVsZW0odGhpcykuY29udGFpbnMoZ2V0RWxlbShlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIElmIHR5cGUgaXMgXCIjY29tbWVudFwiIGEgY29tbWVudCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnMgLSBTdHJpbmdzIHRoYXQgYXJlIHBhc3NlZCBpbnRvIHtAbGluayBFbGVtI2FwcGx5fS5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCBlbGVtZW50cy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY3JlYXRpbmcgZWxlbWVudHMgaW5zaWRlIHRoaXMgZWxlbWVudC5cbiAgICogSWYgdGhpcyBlbGVtZW50IGlzIG5vdCBhbiBFbGVtZW50IHRoZSBlbGVtZW50IGlzIGp1c3QgY3JlYXRlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGUoJ2RpdicsICcjaWQgLmMxIC5jMiAqU29tZSB0ZXh0KicpO1xuICAgKlxuICAgKiAvLyBhbHNvIHRoZXJlIGFyZSBzaG9ydGhhbmRzIGZvciBhbG1vc3QgZXZlcnkgSFRNTC1lbGVtZW50XG4gICAqIGVsZW0uZGl2KCk7XG4gICAqIGVsZW0uaW5wdXQoJyR0eXBlKGNoZWNrYm94KSAkbmFtZShjb3VudHJ5KScpO1xuICAgKi9cbiAgY3JlYXRlKHR5cGUsIC4uLmFwcGxpZWRFeHByZXNzaW9ucykge1xuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgRWxlbSh0eXBlU3dpdGNoZXIodHlwZSwgW25ldyBFbGVtKGVsZW0pXSkpO1xuXG4gICAgICBlbGVtZW50LmludG8oZWxlbSk7XG5cbiAgICAgIGVsZW1zLmFkZChlbGVtZW50LmFwcGx5LmFwcGx5KGVsZW1lbnQsIGFwcGxpZWRFeHByZXNzaW9ucykpO1xuICAgIH0sIG5ldyBFbGVtKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVDb21tZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGNvbW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBjb21tZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGNvbW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZUNvbW1lbnQoJ2NvbW1lbnQnKTtcbiAgICovXG4gIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAuY3JlYXRlKCcjY29tbWVudCcpXG4gICAgICAudGV4dCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlVGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCB0ZXh0IG5vZGVzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyB0ZXh0IG5vZGVzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgdGV4dCBub2RlIGlzIGp1c3QgY3JlYXRlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGVUZXh0KCd0ZXh0Jyk7XG4gICAqL1xuICBjcmVhdGVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpc1xuICAgICAgLmNyZWF0ZSgnI3RleHQnKVxuICAgICAgLnRleHQodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2s+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge1N1cGVyfFN0cmluZ3xFbGVtfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkLCBELVdyYXAgb2YgY3NzIHN0eWxlcyBvZiB0aGUgZWxlbWVudCByZXR1cm5lZCxcbiAgICogaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIHN0eWxlcy4gU3VwcG9ydHMgIWltcG9ydGFudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpOyAvLyBkaXNwbGF5IHNldCB0byAnbm9uZScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5jc3MoJ2Rpc3BsYXknKTsgICAgICAgICAvLyAnbm9uZSdcbiAgICogZWxlbS5jc3Moe1xuICAgKiAgIGRpc3BsYXk6ICdpbmxpbmUnLCAgICAgICAgIC8vIGRpc3BsYXkgc2V0IHRvICdpbmxpbmUnXG4gICAqICAgY3Vyc29yOiAncG9pbnRlcicgICAgICAgICAgLy8gY3Vyc29yIHNldCB0byAncG9pbnRlcidcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCkuJDsgICAgICAgICAgICAgICAgLy8geyBkaXNwbGF5OiAnbm9uZScsIGN1cnNvcjogJ3BvaW50ZXInIH1cbiAgICovXG4gIGNzcyhwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBsZXQgc3R5bGUgPSBnZXRFbGVtKHRoaXMpLnN0eWxlO1xuXG4gICAgaWYgKGlzU3R5bGVSdWxlKHRoaXMuJFswXSkpIHtcbiAgICAgIHN0eWxlID0gdGhpcy4kWzBdLnN0eWxlO1xuICAgIH1cblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBTdHIoc3R5bGUuY3NzVGV4dClcbiAgICAgICAgLnNwbGl0KC87ID8vKVxuICAgICAgICAub2JqZWN0KChvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdCgvOiAvKTtcblxuICAgICAgICAgICAgb1tuZXcgU3RyKHByb3BlcnR5WzBdKS50b0NhbWVsQ2FzZSgpLiRdID0gcHJvcGVydHlbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkgPSBuZXcgU3RyKHByb3BlcnR5KS50b0h5cGhlbkNhc2UoKS4kO1xuXG4gICAgICByZXR1cm4gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgKyAoc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwcm9wZXJ0eSkgPyAnICFpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtKSAmJiAhaXNTdHlsZVJ1bGUoZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuZXcgU3VwZXIocHJvcGVydHkpLmZvckVhY2goKHZhbHVlLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUNTUyhwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0eSA9IG5ldyBTdHIocHJvcGVydHkpLnRvSHlwaGVuQ2FzZSgpLiQ7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZShuZXcgRWxlbShlbGVtKS5jc3MocHJvcGVydHkpLCBlbGVtLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlLnJlcGxhY2UoLyA/IWltcG9ydGFudCQvLCAnJyksXG4gICAgICAgICAgLyFpbXBvcnRhbnQkLy50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjdHhcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8Q3R4Q2FsbGJhY2t9IFtwcm9wZXJ0eV0gLSBJZiBwcmVzZW50IGFuZCBvYmplY3RcbiAgICogaXQncyBhc3NpZ25lZCB0byB0aGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0LCBpZiBmdW5jdGlvblxuICAgKiBpdCdzIGNhbGxlZCB3aXRoIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dCBhcmd1bWVudCwgaWYgc3RyaW5nXG4gICAqIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdXNlZCBmb3IgYXNzaWduaW5nXG4gICAqIHRoaXMgcHJvcGVydHkgdG8gY2FudmFzIHJlbmRlcmluZyBjb250ZXh0IGFuZCBpZiBub3QgcHJlc2VudFxuICAgKiBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHQgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIFNlZSB0aGUgcHJvcGVydHkgYXJndW1lbnQuXG4gICAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8RWxlbX1cbiAgICogQGRlc2NyaXB0aW9uIFJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBmaXJzdCBjYW52YXMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2FudmFzLmN0eDsgLy8gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gICAqL1xuICBjdHgocHJvcGVydHksIHZhbHVlKSB7XG4gICAgbGV0IGN0eDtcblxuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIGN0eCA9IGVsZW0uZHdheW5lRGF0YS5jdHg7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuXG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkoY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICAgIH1cblxuICAgICAgYXNzaWduKGN0eCwgcHJvcGVydHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZ3xFbGVtVmFsdWVDYWxsYmFjaz59IFtrZXldIC0gTmFtZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgKHdpdGhvdXQgZGF0YS0gcHJlZml4KVxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtTdXBlcnxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGRhdGFzZXQgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgYXR0cmlidXRlIHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBkYXRhIGF0dHJpYnV0ZXMuIFNlZVxuICAgKiBbSFRNTEVsZW1lbnQjZGF0YXNldF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2RhdGFzZXR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmRhdGEoJ3NvbWVLZXkxJywgJ3ZhbHVlJyk7IC8vIGF0dHJpYnV0ZSBkYXRhLXNvbWUta2V5MSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScpOyAgICAgICAgICAvLyAndmFsdWUxJ1xuICAgKiBlbGVtLmRhdGEoe1xuICAgKiAgIHNvbWVLZXkxOiAndmFsdWUzJywgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBkYXRhLXNvbWUta2V5MSBzZXQgdG8gJ3ZhbHVlMydcbiAgICogICBzb21lS2V5MjogJ3ZhbHVlMicgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmRhdGEoKS4kOyAgICAgICAgICAgICAgICAgIC8vIHsgc29tZUtleTE6ICd2YWx1ZTMnLCBzb21lS2V5MjogJ3ZhbHVlMicgfVxuICAgKi9cbiAgZGF0YShrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IGdldEVsZW0odGhpcykuZGF0YXNldDtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBTdXBlcihkYXRhc2V0KS5vYmplY3QoKG8sIHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgICByZXR1cm4gZGF0YXNldFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNFbGVtZW50KGVsZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZShrZXksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZShlbGVtLmRhdGFzZXRba2V5XSwgZWxlbSwgaW5kZXgpIDogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGF0YVVSTFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGUgPSAnaW1hZ2UvcG5nJ10gLSBTZWUgdGhlIGxpbmtcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmNvZGVyT3B0aW9ucyA9IDAuOTJdIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBEYXRhIFVSTCBmb3IgdGhlIGZpcnN0IGNhbnZhcyBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0hUTUxDYW52YXNFbGVtZW50I3RvRGF0YVVSTF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNhbnZhcy5kYXRhVVJMKCk7XG4gICAqL1xuICBkYXRhVVJMKHR5cGUsIGVuY29kZXJPcHRpb25zKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHgoKTtcblxuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5jYW52YXMudG9EYXRhVVJMLmFwcGx5KGN0eC5jYW52YXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2RlbGV0ZVJ1bGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHJ1bGUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlbGV0aW5nIGNzcyBzdHlsZXMgaW4gYSBzdHlsZSB0YWcuXG4gICAqIE5vdGU6IHN0eWxlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2lkZSB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLmRlbGV0ZVJ1bGUoJ2ltZy1zaXplJyk7XG4gICAqL1xuICBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcbiAgICAgIGlmIChnZXROYW1lKGVsZW0pID09PSAnc3R5bGUnKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBuZXcgQXJyKGVsZW0uc2hlZXQuY3NzUnVsZXMpLmZpbmQoKHJ1bGUpID0+IHJ1bGUuZHdheW5lRGF0YSAmJiBydWxlLmR3YXluZURhdGEubmFtZSA9PT0gbmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICBlbGVtLnNoZWV0LmRlbGV0ZVJ1bGUocnVsZS5rZXkpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkaXNwYXRjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fSBldmVudCAtIEV2ZW50IG9yIGEgc3RyaW5nIChuZXcgRXZlbnQoZXZlbnQpIGlzIGNyZWF0ZWQpLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50SW5pdCA9IHt9XSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZXZlbnRJbml0LmJ1YmJsZXMgPSB0cnVlXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZXZlbnRJbml0LmNhbmNlbGFibGUgPSB0cnVlXSAtIFNlZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0V2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snKTtcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UgfSk7XG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XG4gICAqL1xuICBkaXNwYXRjaChldmVudCwgZXZlbnRJbml0ID0ge30sIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgYnViYmxlcyA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlIH0gPSBldmVudEluaXQgfHwge307XG4gICAgbGV0IGZpbmFsRXZlbnQgPSBldmVudDtcblxuICAgIGlmICghL0V2ZW50JC8udGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmFsRXZlbnQgPSBuZXcgRXZlbnQoZmluYWxFdmVudCwgeyBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGZpbmFsRXZlbnQgPSBuYXRpdmVEb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ24oZmluYWxFdmVudCwgZGV0YWlscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xuICAgICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZmluYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2VsZW1cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4ID0gMF0gLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvZiB0aGUgc2V0IHRvIGdldC4gTmVnYXRpdmUgaW5kZXggbWVhbnMgZWxlbS5sZW5ndGggKyBpbmRleC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmVsZW0oMSk7IC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDFcbiAgICogZWxlbS5lbGVtKCk7ICAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAwXG4gICAqL1xuICBlbGVtKGluZGV4ID0gMCkge1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggKyBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW0odGhpcy4kW2luZGV4XSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbHRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufEVsZW1lbnRbXXxFbGVtfSBbc2VsZWN0b3IgPSBCb29sZWFuXSAtIElmIGl0J3MgYSBzdHJpbmcgdGhlIG1ldGhvZCBmaWx0ZXJzIGVsZW1lbnRzIHdpdGggdGhlIHNlbGVjdG9yXG4gICAqIG90aGVyd2lzZSBzdXBlci5maWx0ZXIgaXMgY2FsbGVkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbHRlcmluZyBlbGVtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5maWx0ZXIoKGVsZW0pID0+IG5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJy5wYXJlbnQnKSk7XG4gICAqIGVsZW0uZmlsdGVyKGVsZW1zSW5BcnJheSk7XG4gICAqIGVsZW0uZmlsdGVyKGVsZW1zSW5FbGVtKTtcbiAgICogZWxlbS5maWx0ZXIoJy5jaGlsZCcpO1xuICAgKi9cbiAgZmlsdGVyKHNlbGVjdG9yID0gQm9vbGVhbikge1xuICAgIHJldHVybiBuZXcgRWxlbShzdXBlci5maWx0ZXIoZmlsdGVyU3dpdGNoZXIoc2VsZWN0b3IpKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbmRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7RWxlbXx7IGtleTogS2V5LCB2YWx1ZTogKiB9fG51bGx9IE5ldyBpbnN0YW5jZSBvZiBFbGVtIGlmIHNlbGVjdG9yIGlzIGEgc3RyaW5nXG4gICAqIG90aGVyd2lzZSBzdXBlci5maW5kIGlzIGNhbGxlZC5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFbGVtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKi9cbiAgZmluZChzZWxlY3Rvcikge1xuICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZmluZChzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xuICAgICAgZWxlbXMuYWRkKGZpbmQoc2VsZWN0b3IsIGVsZW0pKTtcbiAgICB9LCBuZXcgRWxlbSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZmlyc3RcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBlbGVtLmVsZW0oMCkuXG4gICAqL1xuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtKDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmaXJzdENoaWxkXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RvciA9IG51bGxdIC0gSWYgcHJlc2VudCwgZmluZHMgZmlyc3QgY2hpbGQgaW4gZXZlcnkgZWxlbSB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgKiBJZiBub3QsIGZpbmRzIGZpcnN0IGNoaWxkIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgZmlyc3QgY2hpbGRyZW4gb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZmlyc3QoKTsgICAgICAgLy8gZmluZHMgZmlyc3QgY2hpbGQgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBlbGVtIHNldFxuICAgKiBlbGVtLmZpcnN0KCcuZm9vJyk7IC8vIGZpbmQgZmlyc3QgY2hpbGQgdGhhdCBoYXMgZm9vIGNsYXNzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBmaXJzdENoaWxkKHNlbGVjdG9yID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IGZvdW5kIH0gPSBuZXcgRWxlbShlbGVtKVxuICAgICAgICAuY2hpbGRyZW4oKVxuICAgICAgICAuZmluZCgoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB8fCB7fTtcblxuICAgICAgZWxlbXMuYWRkKGZvdW5kKTtcbiAgICB9LCBuZXcgRWxlbSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZm9jdXNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvZm9jdXNcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtIVE1MRWxlbWVudCNmb2N1c117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2ZvY3VzfS5cbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcbiAgICAgICAgZWxlbS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNnZXRSdWxlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBydWxlLlxuICAgKiBAcmV0dXJucyB7eyBzZWxlY3RvcjogKFN0cmluZ3x2b2lkKSwgcnVsZXM6IE9iamVjdCB9fSBTZXQgb2YgdGhlIGNzcyBydWxlcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBzZXQgb2YgdGhlIHJ1bGVzIHVuZGVyIHRoZSBuYW1lLlxuICAgKiBOb3RlOiBzdHlsZSBlbGVtZW50IHNob3VsZCBiZSBpbnNpZGUgdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZS5hZGRSdWxlKCdpbWctc2l6ZScsICdpbWcuc3F1YXJlJywge1xuICAgKiAgIHdpZHRoOiAnNDBweCcsXG4gICAqICAgaGVpZ2h0OiAnNDBweCdcbiAgICogfSk7XG4gICAqIHN0eWxlLmdldFJ1bGUoJ2ltZy1zaXplJyk7XG4gICAqIC8vIHtcbiAgICogLy8gICBzZWxlY3RvcjogJ2ltZy5zcXVhcmUnLFxuICAgKiAvLyAgIHJ1bGVzOiB7XG4gICAqIC8vICAgICB3aWR0aDogJzQwcHgnLFxuICAgKiAvLyAgICAgaGVpZ2h0OiAnNDBweCdcbiAgICogLy8gICB9XG4gICAqIC8vIH1cbiAgICovXG4gIGdldFJ1bGUobmFtZSkge1xuICAgIGxldCBmb3VuZCA9IHtcbiAgICAgIHNlbGVjdG9yOiB1bmRlZmluZWQsXG4gICAgICBydWxlczoge31cbiAgICB9O1xuXG4gICAgdGhpcy5zb21lKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZ2V0TmFtZShlbGVtKSA9PT0gJ3N0eWxlJykge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBydWxlIH0gPSBuZXcgQXJyKGVsZW0uc2hlZXQuY3NzUnVsZXMpLmZpbmQoKHJ1bGUpID0+IHJ1bGUuZHdheW5lRGF0YSAmJiBydWxlLmR3YXluZURhdGEubmFtZSA9PT0gbmFtZSkgfHwge307XG5cbiAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICBmb3VuZCA9IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBydWxlLnNlbGVjdG9yVGV4dCxcbiAgICAgICAgICAgIHJ1bGVzOiBuZXcgRWxlbShydWxlKS5jc3MoKS4kXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hhc0F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHInLCAndmFsdWUnKS5oYXNBdHRyKCdhdHRyJyk7IC8vIHRydWVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdhdHRyJykuaGFzQXR0cignYXR0cicpOyAgICAvLyBmYWxzZVxuICAgKi9cbiAgaGFzQXR0cihhdHRyKSB7XG4gICAgY29uc3QgZWxlbSA9IGdldEVsZW0odGhpcyk7XG4gICAgY29uc3QgbnMgPSBhdHRyTlNTd2l0Y2hlcihhdHRyLCBbbmV3IEVsZW0oZWxlbSldKTtcblxuICAgIHJldHVybiBpc051bGwobnMpXG4gICAgICA/IGVsZW0uaGFzQXR0cmlidXRlKGF0dHIpXG4gICAgICA6IGVsZW0uaGFzQXR0cmlidXRlTlMobnMsIGF0dHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoYXNDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBOYW1lIG9mIHRoZSBjbGFzcy5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGNsYXNzIG9yIG5vdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJykuaGFzQ2xhc3MoJ2NscycpOyAgICAvLyB0cnVlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgLy8gZmFsc2VcbiAgICovXG4gIGhhc0NsYXNzKGNscykge1xuICAgIHJldHVybiBnZXRFbGVtKHRoaXMpLmNsYXNzTGlzdC5jb250YWlucyhjbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNoZWlnaHRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp8RWxlbVZhbHVlQ2FsbGJhY2t9IFtoZWlnaHRdIC0gSGVpZ2h0IHRvIHNldC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIGhlaWdodCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIGhlaWdodHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSBoZWlnaHQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgaGVpZ2h0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmhlaWdodCgxMjMpO1xuICAgKiBlbGVtLmhlaWdodCgpOyAvLyAxMjNcbiAgICovXG4gIGhlaWdodChoZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLmFwcGx5KHRoaXMsIG5ldyBBcnIoYXJndW1lbnRzKS51bnNoaWZ0KCdoZWlnaHQnKS4kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGlkZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBIaWRlcyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5oaWRlKCk7XG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcblxuICAgICAgY29uc3QgY3VycmVudERpc3BsYXkgPSBlbGVtLmNzcygnZGlzcGxheScpO1xuXG4gICAgICBpZiAoY3VycmVudERpc3BsYXkuaW5kZXhPZignbm9uZScpKSB7XG4gICAgICAgIGVsZW0ucHJvcCgnZHdheW5lRGF0YScpLnByZXZpb3VzRGlzcGxheSA9IGN1cnJlbnREaXNwbGF5O1xuICAgICAgfVxuXG4gICAgICBlbGVtLmNzcygnZGlzcGxheScsICdub25lICFpbXBvcnRhbnQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaHRtbFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfCp9IFtodG1sXSAtIEhUTUwgdG8gd3JpdGUgaW5zdGVhZCBvZiBjdXJyZW50IEhUTUwuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCBIVE1MIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgSFRNTCBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIGh0bWwgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgSFRNTC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5odG1sKCc8ZGl2PjE8L2Rpdj4nKTtcbiAgICogZWxlbS5odG1sKCk7IC8vICc8ZGl2PjE8L2Rpdj4nXG4gICAqL1xuICBodG1sKGh0bWwpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtKHRoaXMpLmlubmVySFRNTDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xuICAgICAgICBlbGVtLmlubmVySFRNTCA9IGlzRnVuY3Rpb24oaHRtbCkgPyBodG1sKGVsZW0uaW5uZXJIVE1MLCBlbGVtLCBpbmRleCkgOiBodG1sO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfCp9IFtpZF0gLSBJZCB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCBpZCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIGlkcyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIGlkIGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0cyBpZCBvciBzZXRzIGlkcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pZCgndW5pcXVlJyk7XG4gICAqIGVsZW0uaWQoKTsgLy8gJ3VuaXF1ZSdcbiAgICovXG4gIGlkKGlkKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0RWxlbSh0aGlzKS5pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XG4gICAgICAgIGVsZW0uaWQgPSBpZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IEVsZW0jaW5uZXJIZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uIEdldHRlciBmb3IgZmluZGluZyBob3cgbXVjaCBoZWlnaHQgY29udGVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCBjYW4gYmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICogICBoZWlnaHQ6ICcyMDBweCcsXG4gICAqICAgcGFkZGluZ1RvcDogJzJweCcsXG4gICAqICAgcGFkZGluZ0JvdHRvbTogJzNweCcsXG4gICAqICAgYm9yZGVyVG9wOiAnMXB4IHNvbGlkIGJsYWNrJyxcbiAgICogICBib3JkZXJCb3R0b206ICc0cHggc29saWQgYmxhY2snXG4gICAqIH0pLmlubmVySGVpZ2h0OyAvLyAxOTBcbiAgICogZWxlbVxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAnY29udGVudC1ib3gnKVxuICAgKiAgIC5pbm5lckhlaWdodDsgLy8gMjAwXG4gICAqIGVsZW1cbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ3BhZGRpbmctYm94JylcbiAgICogICAuaW5uZXJIZWlnaHQ7IC8vIDE5NVxuICAgKi9cbiAgZ2V0IGlubmVySGVpZ2h0KCkge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzLiRbMF07XG5cbiAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcbiAgICAgIHJldHVybiBlbGVtLmlubmVySGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJvcmRlclRvcFdpZHRoLFxuICAgICAgYm9yZGVyQm90dG9tV2lkdGgsXG4gICAgICBib3hTaXppbmcsXG4gICAgICBoZWlnaHQsXG4gICAgICBwYWRkaW5nVG9wLFxuICAgICAgcGFkZGluZ0JvdHRvbVxuICAgIH0gPSB0aGlzLmNhbGNDU1MoKTtcbiAgICBjb25zdCBib3JkZXJzID0gcHgoYm9yZGVyVG9wV2lkdGgpICsgcHgoYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gcHgocGFkZGluZ1RvcCkgKyBweChwYWRkaW5nQm90dG9tKTtcblxuICAgIHJldHVybiBweChoZWlnaHQpIC0gaW5uZXJTd2l0Y2hlcihib3hTaXppbmcsIFtwYWRkaW5ncywgYm9yZGVyc10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge051bWJlcn0gRWxlbSNpbm5lcldpZHRoXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwdWJsaWNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvbiBHZXR0ZXIgZm9yIGZpbmRpbmcgaG93IG11Y2ggd2lkdGggY29udGVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCBjYW4gYmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICogICB3aWR0aDogJzIwMHB4JyxcbiAgICogICBwYWRkaW5nTGVmdDogJzJweCcsXG4gICAqICAgcGFkZGluZ1JpZ2h0OiAnM3B4JyxcbiAgICogICBib3JkZXJMZWZ0OiAnMXB4IHNvbGlkIGJsYWNrJyxcbiAgICogICBib3JkZXJSaWdodDogJzRweCBzb2xpZCBibGFjaydcbiAgICogfSkuaW5uZXJXaWR0aDsgLy8gMTkwXG4gICAqIGVsZW1cbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ2NvbnRlbnQtYm94JylcbiAgICogICAuaW5uZXJXaWR0aDsgLy8gMjAwXG4gICAqIGVsZW1cbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ3BhZGRpbmctYm94JylcbiAgICogICAuaW5uZXJXaWR0aDsgLy8gMTk1XG4gICAqL1xuICBnZXQgaW5uZXJXaWR0aCgpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpcy4kWzBdO1xuXG4gICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgICByZXR1cm4gZWxlbS5pbm5lcldpZHRoO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJvcmRlckxlZnRXaWR0aCxcbiAgICAgIGJvcmRlclJpZ2h0V2lkdGgsXG4gICAgICBib3hTaXppbmcsXG4gICAgICBwYWRkaW5nTGVmdCxcbiAgICAgIHBhZGRpbmdSaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IHRoaXMuY2FsY0NTUygpO1xuICAgIGNvbnN0IGJvcmRlcnMgPSBweChib3JkZXJMZWZ0V2lkdGgpICsgcHgoYm9yZGVyUmlnaHRXaWR0aCk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBweChwYWRkaW5nTGVmdCkgKyBweChwYWRkaW5nUmlnaHQpO1xuXG4gICAgcmV0dXJuIHB4KHdpZHRoKSAtIGlubmVyU3dpdGNoZXIoYm94U2l6aW5nLCBbcGFkZGluZ3MsIGJvcmRlcnNdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaW5zZXJ0QWZ0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIgb3IgYSBzZWxlY3RvciBvZiBpdC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBhZnRlciB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50LlxuICAgKiBUaGUgZWxlbWVudHMgcmVtYWluIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmluc2VydEFmdGVyKGVsZW0yKTtcbiAgICogZWxlbS5pbnNlcnRBZnRlcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGluc2VydEFmdGVyKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9GaW5kKGVsZW1lbnQpLmZpcnN0KCk7XG5cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnQubmV4dCgpLiRbMF07XG4gICAgcGFyZW50ID0gcGFyZW50LiRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gaW5zZXJ0IHRoaXMgZWxlbWVudCBiZWZvcmUgb3IgYSBzZWxlY3RvciBvZiBpdC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0ZpbmQoZWxlbWVudCkuZmlyc3QoKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudC4kWzBdO1xuICAgIHBhcmVudCA9IHBhcmVudC4kWzBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtLCBlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaW50b1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gcHV0IHRoaXMgZWxlbWVudHMgaW50byBvciBhIHNlbGVjdG9yIG9mIGl0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgdGhleSBhcmUgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIHNpbWlsYXIgdG9cbiAgICogW05vZGUjYXBwZW5kQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2FwcGVuZENoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnRvKGVsZW0yKTtcbiAgICogZWxlbS5pbnRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5pbnRvKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnRvKGVsZW1lbnQsIGVuZCA9IHRydWUpIHtcbiAgICBlbGVtZW50ID0gdG9GaW5kKGVsZW1lbnQpLiRbMF07XG5cbiAgICBpZiAoXG4gICAgICAhZWxlbWVudCB8fFxuICAgICAgaXNXaW5kb3coZWxlbWVudCkgfHxcbiAgICAgIGlzSFRNTERvY3VtZW50KGVsZW1lbnQpIHx8XG4gICAgICBpc0NvbW1lbnRPclRleHQoZWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaFJldmVyc2UoKGVsZW0pID0+IHtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2lzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgKiBJZiB0aGUgc2VsZWN0b3IgaXMgdW5kZWZpbmVkIG9yIG51bGwgYWx3YXlzIHJldHVybnMgdHJ1ZS4gSWYgaXQncyBub3QgZm9yIG5vdCBlbGVtZW50c1xuICAgKiBlbnRyaWVzIHJldHVybnMgZmFsc2UuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKGlzTnVsbChzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSBnZXRFbGVtKHRoaXMpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoXG4gICAgICBlbGVtLm1hdGNoZXMgfHxcbiAgICAgIGVsZW0ubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICBlbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIGVsZW0ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIGVsZW0ub01hdGNoZXNTZWxlY3RvclxuICAgICk7XG5cbiAgICBpZiAoIWlzRWxlbWVudCh0aGlzLiRbMF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwoZWxlbSwgc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgU2VsZWN0b3IgJyR7IHNlbGVjdG9yIH0nIGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yIChFbGVtI2lzKWApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpc0Jyb2tlblxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgaW1hZ2UgaW4gdGhlIHNldCBpcyBicm9rZW4uXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgYnJva2VuLiBOb3QgaW1hZ2UgYW5kIG5vdCBsb2FkZWQgaW1hZ2UgaXMgY29uc2lkZXJlZCBwcm9wZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGltZyA9IGVsZW0uaW1nKCkub24oe1xuICAgKiAgICdsb2FkJzogb25sb2FkLFxuICAgKiAgICdlcnJvcic6IG9ubG9hZFxuICAgKiB9KTtcbiAgICpcbiAgICogb25sb2FkID0gKCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGltZy5pc0Jyb2tlbigpKTsgLy8gdHJ1ZVxuICAgKiB9O1xuICAgKlxuICAgKiBpbWcucmVmKCcvc29tZS9ub24tZXhpc3RlbnQvc2l0ZS9ub3QtZm91bmQucG5nJyk7XG4gICAqL1xuICBpc0Jyb2tlbigpIHtcbiAgICBsZXQgaXNCcm9rZW4gPSBmYWxzZTtcblxuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdpbWcnKSB7XG4gICAgICAgIGlzQnJva2VuID0gISEoZWxlbS5jb21wbGV0ZSAmJiAoIWVsZW0ubmF0dXJhbFdpZHRoIHx8ICFlbGVtLm5hdHVyYWxIZWlnaHQpKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpc0Jyb2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaXNXaXRoaW5Eb2N1bWVudFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgd2l0aGluIHRoZSBkb2N1bWVudCBvciBub3QuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgd2l0aGluIHRoZSBkb2N1bWVudCBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpLmlzV2l0aGluRG9jdW1lbnQoKTsgIC8vIHRydWVcbiAgICogbmV3IEVsZW0oZG9jdW1lbnQpLmRpdigpLmlzV2l0aGluRG9jdW1lbnQoKTsgLy8gZmFsc2VcbiAgICovXG4gIGlzV2l0aGluRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3QoKS5jbG9zZXN0KCdodG1sJykubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNsYXN0XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgZWxlbS5lbGVtKC0xKS5cbiAgICovXG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbSgtMSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2xhc3RDaGlsZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3IgPSBudWxsXSAtIElmIHByZXNlbnQsIGZpbmRzIGxhc3QgY2hpbGQgaW4gZXZlcnkgZWxlbSB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgKiBJZiBub3QsIGZpbmRzIGxhc3QgY2hpbGQgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBsYXN0IGNoaWxkcmVuIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmxhc3QoKTsgICAgICAgLy8gZmluZHMgbGFzdCBjaGlsZCBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGVsZW0gc2V0XG4gICAqIGVsZW0ubGFzdCgnLmZvbycpOyAvLyBmaW5kIGxhc3QgY2hpbGQgdGhhdCBoYXMgJ2ZvbycgY2xhc3Mgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICovXG4gIGxhc3RDaGlsZChzZWxlY3RvciA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XG4gICAgICBjb25zdCB7IHZhbHVlOiBmb3VuZCB9ID0gbmV3IEVsZW0oZWxlbSlcbiAgICAgICAgLmNoaWxkcmVuKClcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAuZmluZCgoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB8fCB7fTtcblxuICAgICAgZWxlbXMuYWRkKGZvdW5kKTtcbiAgICB9LCBuZXcgRWxlbSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jbG9hZFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjx7IHByb3BlcjogRWxlbSwgYnJva2VuOiBFbGVtIH0+fSBQcm9taXNlIHdpdGggYnJva2VuIGFuZCBwcm9wZXIgaW1hZ2VzLlxuICAgKiBAZGVzY3JpcHRpb24gTG9hZHMgZWFjaCBpbWFnZSBpbiB0aGUgc2V0IGFuZCBwdXRzIGl0IHRvIHRoZSBwcm9wZXIgb3IgYnJva2VuIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbWFnZXMubG9hZCgpLnRoZW4oKHsgYnJva2VuIH0pID0+IHtcbiAgICogICBicm9rZW4uZmlsdGVyKCdpbWcnKS5yZWYoJy9mYWxsYmFjay5wbmcnKTtcbiAgICogfSk7XG4gICAqL1xuICBsb2FkKCkge1xuICAgIGNvbnN0IGltYWdlcyA9IHtcbiAgICAgIHByb3BlcjogbmV3IEVsZW0oKSxcbiAgICAgIGJyb2tlbjogbmV3IEVsZW0oKVxuICAgIH07XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzXG4gICAgICAgIC5maWx0ZXIoKGVsZW0pID0+IGdldE5hbWUoZWxlbSkgPT09ICdpbWcnKVxuICAgICAgICAubWFwKChlbGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgJGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcblxuICAgICAgICAgIGlmIChlbGVtLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBpbWFnZXNbJGVsZW0uaXNCcm9rZW4oKSA/ICdicm9rZW4nIDogJ3Byb3BlciddLnB1c2goZWxlbSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9ICRlbGVtLm9uKHtcbiAgICAgICAgICAgICAgbG9hZCgpIHtcbiAgICAgICAgICAgICAgICBpbWFnZXMucHJvcGVyLmFkZChlbGVtKTtcblxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VzLmJyb2tlbi5hZGQoZWxlbSk7XG5cbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuJFxuICAgICkudGhlbigoKSA9PiBpbWFnZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNtb3ZlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gQXR0cmlidXRlIHRvIG1vdmUgdG8gdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWUgPSAnJ10gLSBWYWx1ZSB0byBzZXQgZm9yIHRoZSBhdHRyaWJ1dGUuIElmIG5vdCBzZXQgYXR0cmlidXRlIG9mIHRoZSBwcmV2aW91cyBlbGVtZW50IG9yICcnIHVzZWQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIG1vdmluZyBhbiBhdHRyaWJ1dGUgZnJvbSBwcmV2aW91cyBlbGVtZW50IHRvIHRoZSBuZXh0IG9uZSAoZmlyc3QgZWxlbWVudCBpbiB0aGlzIHNldCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0xLm1vdmVBdHRyKCdhdHRyJywgJ3ZhbHVlJyk7ICAgICAvLyBhdHRyaWJ1dGUgJ2F0dHInIHNldCB0byAndmFsdWUnIG9uIGVsZW0xXG4gICAqIGVsZW0yLm1vdmVBdHRyKCdhdHRyJyk7ICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgJ2F0dHInIHJlbW92ZWQgZnJvbSBlbGVtMS4gc2V0IHRvICd2YWx1ZScgb24gZWxlbTJcbiAgICogZWxlbTMubW92ZUF0dHIoJ2F0dHInLCAnbmV3IHZhbHVlJyk7IC8vIGF0dHJpYnV0ZSAnYXR0cicgcmVtb3ZlZCBmcm9tIGVsZW0yLiBzZXQgdG8gJ25ldyB2YWx1ZScgb24gZWxlbTNcbiAgICovXG4gIG1vdmVBdHRyKGF0dHIsIHZhbHVlID0gJycpIHtcbiAgICBjb25zdCBwcmV2ID0gYXR0cnNbYXR0cl07XG4gICAgY29uc3QgZWxlbSA9IHRoaXMuZWxlbSgpO1xuXG4gICAgaWYgKHByZXYgJiYgZWxlbS5sZW5ndGgpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YWx1ZSA9IHByZXYuYXR0cihhdHRyKTtcbiAgICAgIH1cblxuICAgICAgcHJldi5yZW1vdmVBdHRyKGF0dHIpO1xuICAgIH1cblxuICAgIGlmIChlbGVtLmxlbmd0aCkge1xuICAgICAgYXR0cnNbYXR0cl0gPSBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNtb3ZlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gQ2xhc3MgdG8gbW92ZSB0byB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgbW92aW5nIGEgY2xhc3MgZnJvbSBwcmV2aW91cyBlbGVtZW50IHRvIHRoZSBuZXh0IG9uZSAoZmlyc3QgZWxlbWVudCBpbiB0aGlzIHNldCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0xLm1vdmVDbGFzcygnY2xzJyk7IC8vIGNsYXNzICdjbHMnIGFkZGVkIHRvIGVsZW0xXG4gICAqIGVsZW0yLm1vdmVDbGFzcygnY2xzJyk7IC8vIGNsYXNzICdjbHMnIHJlbW92ZWQgZnJvbSBlbGVtMS4gYWRkZWQgdG8gZWxlbTFcbiAgICovXG4gIG1vdmVDbGFzcyhjbHMpIHtcbiAgICBjb25zdCBwcmV2ID0gY2xhc3Nlc1tjbHNdO1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzLmVsZW0oKTtcblxuICAgIGlmIChwcmV2ICYmIGVsZW0ubGVuZ3RoKSB7XG4gICAgICBwcmV2LnJlbW92ZUNsYXNzKGNscyk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW0ubGVuZ3RoKSB7XG4gICAgICBjbGFzc2VzW2Nsc10gPSBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBFbGVtI25hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uIG5vZGVOYW1lIChsb3dlcmNhc2VkKSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBlbGVtMSA9IGVsZW0uY3JlYXRlKCdkaXYnKTtcbiAgICogZWxlbTEubmFtZSAvLyAnZGl2J1xuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIGdldE5hbWUodGhpcy4kWzBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jbmV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3IgPSBudWxsXSAtIElmIHByZXNlbnQsIGZpbmRzIG5leHQgZWxlbWVudCB0byBldmVyeSBlbGVtIHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIElmIG5vdCwgZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm5leHQoKTsgICAgICAgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIGVsZW0ubmV4dCgnLmZvbycpOyAvLyBmaW5kcyBuZXh0IGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IHRoYXQgaGFzICdmb28nIGNsYXNzXG4gICAqL1xuICBuZXh0KHNlbGVjdG9yID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcbiAgICAgIC8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xuICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbXMuYWRkKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbmV3IEVsZW0oKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI29mZlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uRWxlbUV2ZW50U3RyaW5nfSBldmVudHMgLSBFdmVudHMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgcmVtb3ZlcyBhbGwgdGhlIGxpc3RlbmVycyBmcm9tIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IHNwZWNpZmllZCBieSB0aGUgZXZlbnRzIGFyZ3VtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5vZmYoJ2NsaWNrJyk7XG4gICAqIGVsZW0ub2ZmKCdjbGljaywgaW5wdXQnKTtcbiAgICogZWxlbS5vZmYoJ2NsaWNrLCBpbnB1dCcsICdmb2N1cycpO1xuICAgKi9cbiAgb2ZmKC4uLmV2ZW50cykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IHsgbGlzdGVuZXJzIH0gPSBlbGVtLmR3YXluZURhdGE7XG5cbiAgICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaXRlcmF0ZShldmVudC5zcGxpdChldmVudFNlcGFyYXRvciksIChldmVudCkgPT4ge1xuICAgICAgICAgIChsaXN0ZW5lcnNbZXZlbnRdIHx8IG5ldyBTdXBlcigpKS5mb3JFYWNoKCh7IHJlbW92ZUxpc3RlbmVyIH0pID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNvblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbUV2ZW50U3RyaW5nfE9iamVjdC48RWxlbUV2ZW50U3RyaW5nfEVsZW1MaXN0ZW5lcj59IGV2ZW50IC0gRWl0aGVyIGEge0BsaW5rIEVsZW1FdmVudFN0cmluZ30gc3RyaW5nXG4gICAqIG9yIGFuIG9iamVjdCB3aXRoIGV2ZW50IGtleXMgKGEga2V5IGlzIGFsc28gRWxlbUV2ZW50U3RyaW5nKSBhbmQgbGlzdGVuZXJzIHZhbHVlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RvciA9IG51bGxdIC0gU2VsZWN0b3IgdG8gZmlsdGVyIGV2ZW50IHRhcmdldHMuXG4gICAqIEBwYXJhbSB7RWxlbUxpc3RlbmVyfSBbbGlzdGVuZXJdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IG11c3QgYmUgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3JcbiAgICogc3BlY2lmaWVkIGV2ZW50KHMpLlxuICAgKiBAcmV0dXJucyB7RWxlbVJlbW92ZUxpc3RlbmVyc30gRnVuY3Rpb24gdGhhdCB0YWtlcyBvcHRpb25hbCBldmVudCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqIEZvciBkZWJ1Z2dpbmc6IElmIHlvdSBuZWVkIHRvIGtub3cgd2hhdCBsaXN0ZW5lcnMgYXJlIGluIHdvcmsgKGFuZCB3aGF0IHNlbGVjdG9ycyBmaWx0ZXIgdGFyZ2V0cylcbiAgICogeW91IGNhbiBsb29rIGF0IHRoZSBiYXNlIHByb3BlcnR5IG9mIHRoZSBvbmx5IGR3YXluZSBsaXN0ZW5lciB0aGF0IGxpc3RlbnMgZm9yIHRoZSBldmVudFxuICAgKiBhbmQgZmluZCBhbGwgd29ya2luZyBsaXN0ZW5lcnMgaW4gbGlzdGVuZXIuYmFzZS5kd2F5bmVEYXRhLmxpc3RlbmVyc1tldmVudF0uJC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5vbihcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXG4gICAqICAgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBkYXRhbGlzdCwga2V5Z2VuLCBvdXRwdXQnLFxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcbiAgICogKTtcbiAgICogZWxlbS5vbihcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXG4gICAqICAgKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKVxuICAgKiApO1xuICAgKiBlbGVtLm9uKFxuICAgKiAgIHtcbiAgICogICAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcbiAgICogICAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiAgIH0sXG4gICAqICAgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBkYXRhbGlzdCwga2V5Z2VuLCBvdXRwdXQnXG4gICAqICk7XG4gICAqXG4gICAqIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9IGVsZW0ub24oe1xuICAgKiAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcbiAgICogICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcbiAgICogfSk7XG4gICAqXG4gICAqIHJlbW92ZUxpc3RlbmVycygnY2xpY2snKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnLCAnaW5wdXQnKTtcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAqL1xuICBvbihldmVudCwgc2VsZWN0b3IgPSBudWxsLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IG5ldyBTdXBlcih7fSk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgIGxpc3RlbmVyID0gc2VsZWN0b3I7XG4gICAgICBzZWxlY3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKGV2ZW50KSkge1xuICAgICAgZXZlbnQgPSB7IFtldmVudF06IGxpc3RlbmVyIH07XG4gICAgfVxuXG4gICAgZXZlbnQgPSBuZXcgU3VwZXIoZXZlbnQpLm9iamVjdCgobGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgIGl0ZXJhdGUoZXZlbnQuc3BsaXQoZXZlbnRTZXBhcmF0b3IpLCAoZXZlbnQpID0+IHtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmICghaXNFbGVtZW50KGVsZW0pICYmICFpc1dpbmRvdyhlbGVtKSAmJiAhaXNIVE1MRG9jdW1lbnQoZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGxpc3RlbmVycyB9ID0gKHdpbmRvd3NEd2F5bmVEYXRhLmZpbmQoKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50ID09PSBlbGVtKSB8fCB7fSkudmFsdWUgfHwgZWxlbS5kd2F5bmVEYXRhO1xuXG4gICAgICBldmVudC5mb3JFYWNoKChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXJzW2V2ZW50XSB8fCBuZXcgU3VwZXIoe30pLmRlZmluZSgnaW5kZXgnLCB7XG4gICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzLnByb3AoJ2luZGV4Jyk7XG5cbiAgICAgICAgaWYgKCFyZW1vdmVFdmVudExpc3RlbmVycy5oYXMoJ2xpc3RlbmVyJykpIHtcbiAgICAgICAgICBjb25zdCBuZXdMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVycy5mb3JFYWNoKCh7IHNlbGVjdG9yLCBsaXN0ZW5lciB9KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXcgRWxlbShlLnRhcmdldCkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChlbGVtLCBlLCBlbGVtLCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuZXdMaXN0ZW5lci5iYXNlID0gZWxlbTtcblxuICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbmV3TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVycy5kZWZpbmUoJ2xpc3RlbmVyJywge1xuICAgICAgICAgICAgdmFsdWU6IG5ld0xpc3RlbmVyLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzLmRlbGV0ZShpbmRleCk7XG5cbiAgICAgICAgICBpZiAoIXJlbW92ZUV2ZW50TGlzdGVuZXJzLmNvdW50KSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXJzLnByb3AoJ2xpc3RlbmVyJyksIGZhbHNlKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzLmRlbGV0ZSgnbGlzdGVuZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgYWxsTGlzdGVuZXJzLnByb3AoZXZlbnQsIChhbGxMaXN0ZW5lcnMucHJvcChldmVudCkgfHwgbmV3IEFycigpKS5wdXNoKHJlbW92ZUxpc3RlbmVyKSk7XG5cbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuYXNzaWduKHtcbiAgICAgICAgICBpbmRleDogaW5kZXggKyAxLFxuICAgICAgICAgIFtpbmRleF06IHtcbiAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhldmVudCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZShhcmd1bWVudHMsIChldmVudCkgPT4ge1xuICAgICAgICAgIGl0ZXJhdGUoZXZlbnQuc3BsaXQoZXZlbnRTZXBhcmF0b3IpLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxMaXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xuICAgICAgICAgICAgICBhbGxMaXN0ZW5lcnMucHJvcChldmVudCkuZm9yRWFjaCgocmVtb3ZlTGlzdGVuZXIpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuICAgICAgICAgICAgICBhbGxMaXN0ZW5lcnMuZGVsZXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhbGxMaXN0ZW5lcnMuZm9yRWFjaCgocmVtb3ZlTGlzdGVuZXJzKSA9PiB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycy5mb3JFYWNoKChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge051bWJlcn0gRWxlbSNvdXRlckhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb24gR2V0dGVyIGZvciBmaW5kaW5nIGhvdyBtdWNoIGhlaWdodCB0aGUgZWxlbWVudCBhY3R1YWxseSBpcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jc3Moe1xuICAgKiAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgKiAgIGhlaWdodDogJzIwMHB4JyxcbiAgICogICBwYWRkaW5nVG9wOiAnMnB4JyxcbiAgICogICBwYWRkaW5nQm90dG9tOiAnM3B4JyxcbiAgICogICBib3JkZXJUb3A6ICcxcHggc29saWQgYmxhY2snLFxuICAgKiAgIGJvcmRlckJvdHRvbTogJzRweCBzb2xpZCBibGFjaydcbiAgICogICBtYXJnaW5Ub3A6ICcwcHgnLFxuICAgKiAgIG1hcmdpbkJvdHRvbTogJzVweCdcbiAgICogfSkub3V0ZXJIZWlnaHQ7IC8vIDIwNVxuICAgKiBlbGVtXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdjb250ZW50LWJveCcpXG4gICAqICAgLm91dGVySGVpZ2h0OyAvLyAyMTVcbiAgICogZWxlbVxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAncGFkZGluZy1ib3gnKVxuICAgKiAgIC5vdXRlckhlaWdodDsgLy8gMjEwXG4gICAqL1xuICBnZXQgb3V0ZXJIZWlnaHQoKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXMuJFswXTtcblxuICAgIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgICAgcmV0dXJuIGVsZW0ub3V0ZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgYm9yZGVyVG9wV2lkdGgsXG4gICAgICBib3JkZXJCb3R0b21XaWR0aCxcbiAgICAgIGJveFNpemluZyxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1hcmdpblRvcCxcbiAgICAgIG1hcmdpbkJvdHRvbSxcbiAgICAgIHBhZGRpbmdUb3AsXG4gICAgICBwYWRkaW5nQm90dG9tXG4gICAgfSA9IHRoaXMuY2FsY0NTUygpO1xuICAgIGNvbnN0IGJvcmRlcnMgPSBweChib3JkZXJUb3BXaWR0aCkgKyBweChib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBweChwYWRkaW5nVG9wKSArIHB4KHBhZGRpbmdCb3R0b20pO1xuXG4gICAgcmV0dXJuIHB4KGhlaWdodCkgKyBweChtYXJnaW5Ub3ApICsgcHgobWFyZ2luQm90dG9tKSArIG91dGVyU3dpdGNoZXIoYm94U2l6aW5nLCBbYm9yZGVycywgcGFkZGluZ3NdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IEVsZW0jb3V0ZXJXaWR0aFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHVibGljXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb24gR2V0dGVyIGZvciBmaW5kaW5nIGhvdyBtdWNoIHdpZHRoIHRoZSBlbGVtZW50IGFjdHVhbGx5IGlzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNzcyh7XG4gICAqICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAqICAgd2lkdGg6ICcyMDBweCcsXG4gICAqICAgcGFkZGluZ0xlZnQ6ICcycHgnLFxuICAgKiAgIHBhZGRpbmdSaWdodDogJzNweCcsXG4gICAqICAgYm9yZGVyTGVmdDogJzFweCBzb2xpZCBibGFjaycsXG4gICAqICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgYmxhY2snXG4gICAqICAgbWFyZ2luTGVmdDogJzBweCcsXG4gICAqICAgbWFyZ2luUmlnaHQ6ICc1cHgnXG4gICAqIH0pLm91dGVyV2lkdGg7IC8vIDIwNVxuICAgKiBlbGVtXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdjb250ZW50LWJveCcpXG4gICAqICAgLm91dGVyV2lkdGg7IC8vIDIxNVxuICAgKiBlbGVtXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdwYWRkaW5nLWJveCcpXG4gICAqICAgLm91dGVyV2lkdGg7IC8vIDIxMFxuICAgKi9cbiAgZ2V0IG91dGVyV2lkdGgoKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXMuJFswXTtcblxuICAgIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgICAgcmV0dXJuIGVsZW0ub3V0ZXJXaWR0aDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBib3JkZXJMZWZ0V2lkdGgsXG4gICAgICBib3JkZXJSaWdodFdpZHRoLFxuICAgICAgYm94U2l6aW5nLFxuICAgICAgbWFyZ2luTGVmdCxcbiAgICAgIG1hcmdpblJpZ2h0LFxuICAgICAgcGFkZGluZ0xlZnQsXG4gICAgICBwYWRkaW5nUmlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSB0aGlzLmNhbGNDU1MoKTtcbiAgICBjb25zdCBib3JkZXJzID0gcHgoYm9yZGVyTGVmdFdpZHRoKSArIHB4KGJvcmRlclJpZ2h0V2lkdGgpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gcHgocGFkZGluZ0xlZnQpICsgcHgocGFkZGluZ1JpZ2h0KTtcblxuICAgIHJldHVybiBweCh3aWR0aCkgKyBweChtYXJnaW5MZWZ0KSArIHB4KG1hcmdpblJpZ2h0KSArIG91dGVyU3dpdGNoZXIoYm94U2l6aW5nLCBbYm9yZGVycywgcGFkZGluZ3NdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcGFyZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHJldHVybnMgd3JhcCBvZiB0aGUgc2V0IG9mIHRoZSBwYXJlbnQgZWxlbWVudHMgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqL1xuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4gZWxlbXMuYWRkKGVsZW0ucGFyZW50Tm9kZSksIG5ldyBFbGVtKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRUcmVlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB3cmFwIG9mIGFsbCBwYXJlbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnBhcmVudFRyZWUoKTsgLy8gRWxlbVxuICAgKi9cbiAgcGFyZW50VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtcy5hZGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSwgbmV3IEVsZW0oKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3ByZXZcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yID0gbnVsbF0gLSBJZiBwcmVzZW50LCBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGV2ZXJ5IGVsZW0gdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICogSWYgbm90LCBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5uZXh0KCk7ICAgICAgIC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogZWxlbS5uZXh0KCcuZm9vJyk7IC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IHRoYXQgaGFzICdmb28nIGNsYXNzXG4gICAqL1xuICBwcmV2KHNlbGVjdG9yID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcbiAgICAgIC8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xuICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1zLmFkZChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIG5ldyBFbGVtKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwcm9wXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIEVsZW1WYWx1ZUNhbGxiYWNrfCo+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGFuIGFzc2lnbmVkIG9iamVjdC5cbiAgICogQHBhcmFtIHtFbGVtVmFsdWVDYWxsYmFja3wqfSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmdcbiAgICogdGhpcyBoYXMgdG8gYmUgYW4gYXNzaWduZWQgdmFsdWUgaWYgaXQncyBwcmVzZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbXwqfSBSZXR1cm5zIHRoaXMgaWYgaXQncyBzZXR0ZXIgb3IgYSB2YWx1ZSBpZiBnZXR0ZXIuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBnZXR0ZXIgZm9yIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogb3IgYSBzZXR0ZXIgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5wcm9wKCdkcmFnZ2FibGUnLCBmYWxzZSk7XG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJyk7IC8vIGZhbHNlXG4gICAqL1xuICBwcm9wKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kWzBdID8gdGhpcy4kWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlcmF0ZShwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgIGVsZW1bcHJvcF0gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKGVsZW1bcHJvcF0sIGVsZW0sIGluZGV4KSA6IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlZlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbbGlua10gLSBJZiBpdCdzIHByZXNlbnQgbGluayB0byBhIHJlc291cmNlLlxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIHRoZSBsaW5rIGFyZ3VtZW50IGlzbid0IHByZXNlbnQgaXQncyBhIGdldHRlciBvZiB0aGUgJ3NyYycgYXR0cmlidXRlXG4gICAqIGZvciB0aGUgb25lIG9mIGZvbGxvd2luZyBlbGVtZW50czogaW1nLCBzY3JpcHQsIGlmcmFtZSwgYXVkaW8sIHZpZGVvOyBvZiB0aGUgJ2FjdGlvbicgYXR0cmlidXRlXG4gICAqIGZvciBhIGZvcm0gZWxlbWVudCBhbmQgb2YgdGhlICdocmVmJyBhdHRyaWJ1dGUgZm9yIHRoZSByZXN0LiBJZiBpdCdzIHByZXNlbnQgaXQncyBhIHNldHRlclxuICAgKiBvZiB0aGUgc2FtZSBhdHRyaWJ1dGUgZm9yIGFsbCB0aGUgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIHJlc291cmNlcyBsaW5rcyBhbmQgc2V0dGluZyB0aGVtLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlZignL3NvbWUvY29vbC9pbWFnZS5wbmcnKTtcbiAgICogZWxlbS5yZWYoKTsgLy8gJy9zb21lL2Nvb2wvaW1hZ2UucG5nJ1xuICAgKi9cbiAgcmVmKGxpbmspIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIocmVmU3dpdGNoZXIodGhpcy5uYW1lKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xuXG4gICAgICBlbGVtLmF0dHIocmVmU3dpdGNoZXIoZWxlbS5uYW1lKSwgbGluayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGZyb20gdGhlIGRvY3VtZW50LlxuICAgKiBOb3RlOiBpdCBkb2Vzbid0IHJlbW92ZSB0aGVtIGZyb20gdGhlIHNldCBzbyB3YXRjaCBvdXQgZm9yIHRoZSBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlKCk7XG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdmb28nLCAnYmFyJywgJ2JheicpO1xuICAgKi9cbiAgcmVtb3ZlQXR0ciguLi5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGF0dHIpID0+IHtcbiAgICAgICAgY29uc3QgbnMgPSBhdHRyTlNTd2l0Y2hlcihhdHRyLCBbbmV3IEVsZW0oZWxlbSldKTtcblxuICAgICAgICBpZiAoaXNOdWxsKG5zKSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlTlMobnMsIGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGNsYXNzZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlKGlzRWxlbWVudChlbGVtKSAmJiBhcmd1bWVudHMsIChjbHMpID0+IGxpc3QucmVtb3ZlKGNscykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVDU1NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gcHJvcHMgLSBDU1MgcHJvcGVydGllcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgQ1NTIHByb3BlcnRpZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQ1NTKCdkaXNwbGF5JywgJ3Bvc2l0aW9uJywgJ21hcmdpbicpO1xuICAgKi9cbiAgcmVtb3ZlQ1NTKC4uLnByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGNzcykgPT4ge1xuICAgICAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KGNzcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVwbGFjZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gcmVwbGFjZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHdpdGggYSBzZXQgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudCAoRWxlbWVudCwgc2V0IG9mIGVsZW1lbnRzIG9yIGEgc2VsZWN0b3Igb2YgdGhlbSkuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNyZXBsYWNlQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL3JlcGxhY2VDaGlsZH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVwbGFjZShlbGVtMik7XG4gICAqIGVsZW0ucmVwbGFjZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0ucmVwbGFjZSgnI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgcmVwbGFjZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRmluZChlbGVtZW50KTtcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmlyc3QoKS5wYXJlbnQoKTtcblxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGVsZW0gPSBwYXJlbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdpbnRvJztcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0KCkuZmlyc3QoKS4kWzBdO1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLnByZXYoKS5maXJzdCgpLiRbMF07XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgZWxlbSA9IG5leHQ7XG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QmVmb3JlJztcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsZW0gPSBwcmV2O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEFmdGVyJztcbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0KCkucmVtb3ZlKCk7XG5cbiAgICBlbGVtZW50W21ldGhvZF0oZWxlbSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3NldE9mXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBIVE1MIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fEFycmF5LjwqPn0gaXRlcmF0b3IgLSBBIG51bWJlciAoaG93IG1hbnkgZWxlbWVudHMgdG8gY3JlYXRlIGluc2lkZSBlYWNoIGVsZW1lbnQpLFxuICAgKiBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0VsZW1TZXRPZkNhbGxiYWNrfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgc2V0IG9mIGVsZW1lbnRzIGluc2lkZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBiYXNlZCBvbiBhbiBhcnJheSBvciBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRhYmxlLnNldE9mKCd0cicsIFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXSwgKHJvdywgYXJyYXkpID0+IHtcbiAgICogICBEKHJvdykuc2V0T2YoJ3RkJywgYXJyYXksIChjb2wsIG51bWJlcikgPT4ge1xuICAgKiAgICAgRChjb2wpLnRleHQobnVtYmVyKTtcbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqL1xuICBzZXRPZih0eXBlLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YWxpZGF0ZSh7IDI6IGNhbGxiYWNrIH0sIHsgMjogWydmdW5jdGlvbiddIH0sICdFbGVtI3NldE9mJyk7XG5cbiAgICBpdGVyYXRvciA9IG5ldyBTdXBlcihpdGVyYXRvcikuJDtcblxuICAgIGlmIChpc051bWJlcihpdGVyYXRvcikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlKHsgMTogaXRlcmF0b3IgfSwgeyAxOiBbJ2ludExpa2UnLCAnPj0wJ10gfSwgJ0VsZW0jc2V0T2YnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcybmQgYXJndW1lbnQgbXVzdCBiZSBlaXRoZXIgb3Igbm9uLW5lZ2F0aXZlIGludGVnZXIsIG9yIG9iamVjdCEgKGF0IEVsZW0jc2V0T2YpJyk7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yID0gYXJyYXkoaXRlcmF0b3IpLiQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZXJhdGUoaXRlcmF0b3IsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBuZXcgRWxlbShlbGVtKS5jcmVhdGUodHlwZSk7XG5cbiAgICAgICAgY2FsbGJhY2soY3JlYXRlZC4kWzBdLCB2YWx1ZSwga2V5LCBpdGVyYXRvciwgZWxlbSwgaW5kZXgpO1xuXG4gICAgICAgIGVsZW1zLmFkZChjcmVhdGVkKTtcbiAgICAgIH0pO1xuICAgIH0sIG5ldyBFbGVtKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNzaG93XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFNob3dzIGFsbCBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKiBJZiBhbiBlbGVtZW50IHdhcyBoaWRkZW4gdXNpbmcge0BsaW5rIEVsZW0jaGlkZX0gcHJldmlvdXMgZGlzcGxheSBpcyBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uc2hvdygpO1xuICAgKi9cbiAgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCB7IGR3YXluZURhdGEgfSA9IGVsZW07XG5cbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcblxuICAgICAgaWYgKGVsZW0uY3NzKCdkaXNwbGF5JykuaW5kZXhPZignbm9uZScpID09PSAwKSB7XG4gICAgICAgIGVsZW0uY3NzKCdkaXNwbGF5JywgZHdheW5lRGF0YS5wcmV2aW91c0Rpc3BsYXkpO1xuICAgICAgfVxuXG4gICAgICBkd2F5bmVEYXRhLnByZXZpb3VzRGlzcGxheSA9ICcnO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0ZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2t8Kn0gW3RleHRdIC0gVGV4dCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgdGV4dC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHRleHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyB0ZXh0cyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIHRleHQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgdGV4dC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50ZXh0KCcxMjMnKTtcbiAgICogZWxlbS50ZXh0KCk7IC8vICcxMjMnXG4gICAqL1xuICB0ZXh0KHRleHQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AodGV4dFByb3BlcnR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdHh0ID0gZWxlbVt0ZXh0UHJvcGVydHldO1xuXG4gICAgICBuZXcgRWxlbShlbGVtKS5wcm9wKFxuICAgICAgICB0ZXh0UHJvcGVydHksXG4gICAgICAgIGlzRnVuY3Rpb24odGV4dClcbiAgICAgICAgICA/IHRleHQodHh0LCBlbGVtLCBpbmRleClcbiAgICAgICAgICA6IHRleHRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgYXR0cmlidXRlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFlbGVtLmhhc0F0dHIoYXR0cikgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdG9nZ2xlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBDbGFzcyB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBjbGFzc1xuICAgKiBhbmQgaWYgZmFsc2V5IG1ldGhvZCByZW1vdmVzIHRoZSBjbGFzcy4gSWYgbm90IHByZXNlbnQgbWV0aG9kIGFkZHNcbiAgICogdGhlIGNsYXNzIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgY2xhc3Nlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQ2xhc3MoY2xzLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIXRoaXMuaGFzQ2xhc3MoY2xzKSA6IGNvbmRpdGlvbilcbiAgICAgID8gdGhpcy5hZGRDbGFzcyhjbHMpXG4gICAgICA6IHRoaXMucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgfVxuXG4gIGdldCB0b1N0cmluZ1RhZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcodGhpcy4kJCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3VwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGV2ZWwgPSAxXSAtIFdoYXQgbGV2ZWwgdXAgYWxvbmcgdGhlIHRyZWUgc2hvdWxkIGJlIHRoZSBwYXJlbnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9mIHBhcmVudHMgb2YgbGV2ZWwgJmx0O2xldmVsJmd0Oy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS51cCgpO1xuICAgKiBlbGVtLnVwKDIpO1xuICAgKi9cbiAgdXAobGV2ZWwgPSAxKSB7XG4gICAgdmFsaWRhdGUoW2xldmVsXSwgW1snaW50TGlrZScsICc+PTAnXV0sICdFbGVtI3VwJyk7XG5cbiAgICBsZXZlbCA9IE51bWJlcihsZXZlbCk7XG5cbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XG4gICAgICBsZXQgbiA9IGxldmVsO1xuXG4gICAgICB3aGlsZSAobi0tICYmIGVsZW0pIHtcbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgZWxlbXMuYWRkKGVsZW0pO1xuICAgIH0sIG5ldyBFbGVtKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN2YWxpZGF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7VmFsaWRhdGVDYWxsYmFja30gW3ZhbGlkYXRvcl0gLSBJZiBwcmVzZW50LCBmdW5jdGlvbiB0aGF0IHZhbGlkYXRlcyBpbnB1dHMuXG4gICAqIEByZXR1cm5zIHtFbGVtfE9iamVjdC48U3RyaW5nLCBFcnJvcnwqPnxudWxsfVxuICAgKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHByb3ZpZGVkIHJldHVybnMgdGhpcy4gSWYgbm8gYXJndW1lbnRzIHByb3ZpZGVkIHJldHVybnMgZWl0aGVyIGFuIG9iamVjdFxuICAgKiB3aXRoIGlucHV0IG5hbWVzIGtleXMgYW5kIGVycm9ycyB2YWx1ZXMgb3IgbnVsbCBpZiBubyBlcnJvcnMgZm91bmQuXG4gICAqIEBkZXNjcmlwdGlvbiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHByb3ZpZGVkIGFkZHMgaXQgdG8gdGhlIGVsZW1lbnQgdmFsaWRhdG9ycyBsaXN0LlxuICAgKiBJZiBubyBhcmd1bWVudHMgcHJvdmlkZWQgdmFsaWRhdGVzIGV2ZXJ5IGlucHV0IGVsZW1lbnQgaW4gdGhlIHNldCB3aXRoIGl0cyBvd24gZnVuY3Rpb25zLlxuICAgKiBJZiBhbiBlbGVtZW50IGlzIGEgZm9ybSBpdCB2YWxpZGF0ZXMgYWxsIGlucHV0IGVsZW1lbnRzIGluc2lkZSBpdC4gQWZ0ZXIgdGhlIHZhbGlkYXRpb25cbiAgICogZmlyZXMgJ3ZhbGlkYXRlJyBldmVudCB3aXRoICd2YWxpZCcgYW5kICdlcnJvcicgKGlmIGZvcm0gaXQncyBlcnJvcnMpIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGZvcm0ub24oJ2lucHV0IGNoYW5nZScsICdpbnB1dCcsICh2YWx1ZSwgaW5wdXQpID0+IHtcbiAgICogICBpbnB1dCA9IEQoaW5wdXQpO1xuICAgKlxuICAgKiAgIGlmIChOdW1iZXIodmFsdWUpICUgMykge1xuICAgKiAgICAgaW5wdXQuYWRkQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICpcbiAgICogICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIHNob3VsZCBiZSBkaXZpZGVkIGJ5IDMhJyk7XG4gICAqICAgfVxuICAgKlxuICAgKiAgIGlucHV0LnJlbW92ZUNsYXNzKCdpbnZhbGlkJyk7XG4gICAqIH0pO1xuICAgKi9cbiAgdmFsaWRhdGUodmFsaWRhdG9yKSB7XG4gICAgdmFsaWRhdGUoW3ZhbGlkYXRvcl0sIFsnZnVuY3Rpb258fCEnXSwgJ0VsZW0jdmFsaWRhdGUnKTtcblxuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvckVhY2goKHsgZHdheW5lRGF0YSB9KSA9PiB7XG4gICAgICAgIGR3YXluZURhdGEudmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvcnMgPSBuZXcgU3VwZXIoeyBlcnJvcnM6IG51bGwgfSk7XG5cbiAgICB0aGlzXG4gICAgICAuZmlsdGVyKGAkeyBpbnB1dEVsZW1lbnRzIH0sIGZvcm1gKVxuICAgICAgLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChnZXROYW1lKGVsZW0pID09PSAnZm9ybScpIHtcbiAgICAgICAgICBsZXQgZm9ybUVycm9ycyA9IHsgZXJyb3JzOiBudWxsIH07XG4gICAgICAgICAgY29uc3QgZm9ybSA9IG5ldyBFbGVtKGVsZW0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGZvcm0uZmluZChpbnB1dEVsZW1lbnRzKTtcblxuICAgICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcldyYXAoaW5wdXQsIGluZGV4LCBmb3JtRXJyb3JzKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVycm9ycy5kZWVwQXNzaWduKGZvcm1FcnJvcnMpO1xuXG4gICAgICAgICAgZm9ybUVycm9ycyA9IGZvcm1FcnJvcnMuZXJyb3JzO1xuXG4gICAgICAgICAgZm9ybS5kaXNwYXRjaCgndmFsaWRhdGUnLCB7fSwge1xuICAgICAgICAgICAgdmFsaWQ6ICFmb3JtRXJyb3JzLFxuICAgICAgICAgICAgZXJyb3JzOiBmb3JtRXJyb3JzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEVycm9yID0gKGZvcm1FcnJvcnMgfHwge30pW2lucHV0Lm5hbWVdO1xuXG4gICAgICAgICAgICBuZXcgRWxlbShpbnB1dCkuZGlzcGF0Y2goJ3ZhbGlkYXRlJywge30sIHtcbiAgICAgICAgICAgICAgdmFsaWQ6ICFpbnB1dEVycm9yLFxuICAgICAgICAgICAgICBlcnJvcjogaW5wdXRFcnJvciB8fCBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnB1dEVycm9yID0geyBlcnJvcnM6IG51bGwgfTtcblxuICAgICAgICB2YWxpZGF0b3JXcmFwKGVsZW0sIGluZGV4LCBpbnB1dEVycm9yKTtcbiAgICAgICAgZXJyb3JzLmRlZXBBc3NpZ24oaW5wdXRFcnJvcik7XG5cbiAgICAgICAgaW5wdXRFcnJvciA9IChpbnB1dEVycm9yLmVycm9ycyB8fCB7fSlbZWxlbS5uYW1lXTtcblxuICAgICAgICBuZXcgRWxlbShlbGVtKS5kaXNwYXRjaCgndmFsaWRhdGUnLCB7fSwge1xuICAgICAgICAgIHZhbGlkOiAhaW5wdXRFcnJvcixcbiAgICAgICAgICBlcnJvcjogaW5wdXRFcnJvciB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0b3JXcmFwKGlucHV0LCBpbmRleCwgZXJyb3JzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaW5wdXQudmFsaWRpdHkgJiYgIWlucHV0LnZhbGlkaXR5LnZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGlucHV0LnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0LmR3YXluZURhdGEudmFsaWRhdG9ycy5mb3JFYWNoKCh2YWxpZGF0b3IpID0+IHtcbiAgICAgICAgICB2YWxpZGF0b3IoaW5wdXQudmFsdWUsIGlucHV0LCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIChlcnJvcnMuZXJyb3JzID0gZXJyb3JzLmVycm9ycyB8fCB7fSlbaW5wdXQubmFtZV0gPSBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5ldmVyeSgoZXJyb3IpID0+IGlzTnVsbChlcnJvcikpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzLiQuZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN3aWR0aFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7KnxFbGVtVmFsdWVDYWxsYmFja30gW3dpZHRoXSAtIFdpZHRoIHRvIHNldC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHdpZHRoIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgd2lkdGhzIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgd2lkdGggYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgd2lkdGguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ud2lkdGgoMTIzKTtcbiAgICogZWxlbS53aWR0aCgpOyAvLyAxMjNcbiAgICovXG4gIHdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5hcHBseSh0aGlzLCBuZXcgQXJyKGFyZ3VtZW50cykudW5zaGlmdCgnd2lkdGgnKS4kKTtcbiAgfVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEVsZW0ucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnRWxlbSdcbn0pO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gd2luXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIHdpbmRvdy5cbiAqL1xuY29uc3Qgd2luID0gbmV3IEVsZW0oZ2xvYmFsKTtcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGRvY1xuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cbiAqL1xuY29uc3QgZG9jID0gbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gaHRtbFxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuXG4gKi9cbmNvbnN0IGh0bWwgPSBuZXcgRWxlbShuYXRpdmVEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gYm9keVxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5ib2R5LlxuICovXG5jb25zdCBib2R5ID0gbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQuYm9keSk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBoZWFkXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXG4gKi9cbmNvbnN0IGhlYWQgPSBuZXcgRWxlbShuYXRpdmVEb2N1bWVudC5oZWFkKTtcblxuY29uc3QgZWxlbWVudHMgPSBuZXcgQXJyKGh0bWxFbGVtZW50cykuY29uY2F0KHN2Z0VsZW1lbnRzKS4kO1xuY29uc3QgcHJvcHMgPSBuZXcgQXJyKGVsZW1lbnRzKS5tYXAoKHR5cGUpID0+IG5ldyBTdHIodHlwZSkudG9DYW1lbENhc2UoKS4kKS4kO1xuXG5keW5hbWljRGVmaW5lUHJvcGVydGllcyhFbGVtLnByb3RvdHlwZSwgcHJvcHMsIChlbGVtLCBpKSA9PiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZS5hcHBseSh0aGlzLCBuZXcgQXJyKGFyZ3VtZW50cykudW5zaGlmdChlbGVtZW50c1tpXSkuJCk7XG59KTtcblxuZHluYW1pY0RlZmluZVByb3BlcnRpZXMoRWxlbS5wcm90b3R5cGUsIGNhbnZhc0dldE1ldGhvZHMsIChtZXRob2QpID0+IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgY3R4ID0gdGhpcy5jdHgoKTtcblxuICBpZiAoY3R4KSB7XG4gICAgcmV0dXJuIGN0eFttZXRob2RdLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgfVxufSk7XG5cbmR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzKEVsZW0ucHJvdG90eXBlLCBjYW52YXNSZXN0TWV0aG9kcywgKG1ldGhvZCkgPT4gZnVuY3Rpb24gKCkge1xuICBjb25zdCBjdHggPSB0aGlzLmN0eCgpO1xuXG4gIGlmIChjdHgpIHtcbiAgICBjdHhbbWV0aG9kXS5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0pO1xuXG4vKipcbiAqIEBmdW5jdGlvbiB0b0ZpbmRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR8RWxlbXxTdHJpbmd9IGVsZW0gLSBFbGVtZW50LCBzZWxlY3RvciBvZiBFbGVtZW50cyBvciBFbGVtLlxuICogQHJldHVybnMge0VsZW19IEluc3RhbmNlIG9mIEVsZW0uXG4gKi9cbmZ1bmN0aW9uIHRvRmluZChlbGVtKSB7XG4gIGlmIChpc0VsZW0oZWxlbSkpIHtcbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhlbGVtKSkge1xuICAgIGVsZW0gPSBmaW5kKGVsZW0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0VsZW1cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBFbGVtLlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB2YWx1ZSBpcyBFbGVtLlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIHZhbHVlIGlzIEVsZW0gb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc0VsZW0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNXaW5kb3dcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBXaW5kb3cuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIFdpbmRvdy5cbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBXaW5kb3cgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnV2luZG93Jztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNIVE1MRG9jdW1lbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBIVE1MRG9jdW1lbnQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIEhUTUxEb2N1bWVudC5cbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBIVE1MRG9jdW1lbnQgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc0hUTUxEb2N1bWVudCh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSFRNTERvY3VtZW50Jztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0J3MgYSBEb2N1bWVudEZyYWdtZW50LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB2YWx1ZSBpcyBhIERvY3VtZW50RnJhZ21lbnQuXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgYSBEb2N1bWVudEZyYWdtZW50IG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdEb2N1bWVudEZyYWdtZW50Jztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNTdHlsZVJ1bGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBhIHN0eWxlIHJ1bGUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIGEgc3R5bGUgcnVsZS5cbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBhIHN0eWxlIHJ1bGUgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc1N0eWxlUnVsZSh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQ1NTU3R5bGVSdWxlJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBDb21tZW50IG9yIFRleHQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHZhbHVlIGlzIEhUTUxEb2N1bWVudC5cbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBDb21tZW50IG9yIFRleHQgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc0NvbW1lbnRPclRleHQodmFsdWUpIHtcbiAgY29uc3QgdGFnID0gdG9TdHJpbmdUYWcodmFsdWUpO1xuXG4gIHJldHVybiB0YWcgPT09ICdDb21tZW50JyB8fCB0YWcgPT09ICdUZXh0Jztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0RWxlbVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gVGhlIGFyZ3VtZW50IG9yIGEgZmFsbGJhY2sgaWYgbmVlZGVkLlxuICovXG5mdW5jdGlvbiBnZXRFbGVtKGVsZW0pIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbGVtLiRbMF0pID8gZWxlbS4kWzBdIDogZW1wdHlEaXY7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldE5hbWVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtlbGVtXSAtIEVsZW1lbnQgd2hpY2ggbmFtZSBpcyBuZWVkZWQgdG8ga25vdy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEVsZW1lbnQgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZShlbGVtKSB7XG4gIHJldHVybiAoZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgfHwgJyc7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uIGFkZER3YXluZURhdGFcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBFbGVtZW50IHRvIGFkZCBkd2F5bmVEYXRhIHRvLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGFkZER3YXluZURhdGEoZWxlbSkge1xuICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoZWxlbSwgJ2R3YXluZURhdGEnKSAmJiAhaXNXaW5kb3coZWxlbSkpIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIEVsZW1lbnQjZHdheW5lRGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcmV2aW91c0Rpc3BsYXkgLSBQYXJhbWV0ZXIgdXNlZCBmb3IgaGlkaW5nL3Nob3dpbmcgZWxlbWVudHMuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPFN0cmluZywgU3VwZXI+fSByZW1vdmVMaXN0ZW5lcnMgLSBQYXJhbWV0ZXIgdXNlZCBmb3IgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcHJvcGVydHkge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2N0eF0gLSBDYW52YXMgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICogQHByb3BlcnR5IHtBcnJ9IHZhbGlkYXRvcnMgLSBWYWxpZGF0b3JzIGFzc2lnbmVkIHRvIGVsZW1lbnQuXG4gICAgICogQGRlc2NyaXB0aW9uIEQgZGF0YS5cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgJ2R3YXluZURhdGEnLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBwcmV2aW91c0Rpc3BsYXk6ICcnLFxuICAgICAgICBsaXN0ZW5lcnM6IHt9LFxuICAgICAgICBjdHg6IGdldE5hbWUoZWxlbSkgPT09ICdjYW52YXMnICYmIGVsZW0uZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgdmFsaWRhdG9yczogbmV3IEFycihbXSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1dpbmRvdyhlbGVtKSAmJiAhd2luZG93c0R3YXluZURhdGEuc29tZSgoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQgPT09IGVsZW0pKSB7XG4gICAgd2luZG93c0R3YXluZURhdGEucHVzaCh7XG4gICAgICBlbGVtZW50OiBlbGVtLFxuICAgICAgbGlzdGVuZXJzOiB7fVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0cnVjdG9yc1syXS5wdXNoKHtcbiAgY2hlY2s6IChlbGVtKSA9PiAoXG4gICAgaXNFbGVtZW50KGVsZW0pIHx8XG4gICAgaXNXaW5kb3coZWxlbSkgfHxcbiAgICBpc0hUTUxEb2N1bWVudChlbGVtKSB8fFxuICAgIGlzQ29tbWVudE9yVGV4dChlbGVtKSB8fFxuICAgIGlzRG9jdW1lbnRGcmFnbWVudChlbGVtKSB8fFxuICAgIC9eKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0KSQvLnRlc3QodG9TdHJpbmdUYWcoZWxlbSkpXG4gICksXG4gIGNsczogRWxlbVxufSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGZpbmRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtiYXNlID0gZG9jdW1lbnRdIC0gQmFzZSB0byBmaW5kIGluLlxuICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gKiBbRG9jdW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICovXG5mdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBiYXNlID0gbmF0aXZlRG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBFbGVtKFxuICAgIGlzRWxlbWVudChiYXNlKSB8fCBpc0hUTUxEb2N1bWVudChiYXNlKVxuICAgICAgPyBiYXNlLnF1ZXJ5U2VsZWN0b3JBbGwoU3RyaW5nKHNlbGVjdG9yKSlcbiAgICAgIDogW11cbiAgKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gcGFyc2VIVE1MXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbCAtIEhUTUwgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjb2xsYXBzZVdoaXRlU3BhY2UgPSBmYWxzZV0gLSBJZiB0aGUgd2hpdGVzcGFjZSBzaG91bGQgYmVcbiAqIGNvbGxhcHNlZCBkdXJpbmcgdGhlIHBhcnNpbmcuXG4gKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gUGFyc2VzIEhUTUwgYW5kIHJldHVybnMgYSB3cmFwIG9mICNkb2N1bWVudC1mcmFnbWVudCBjb250YWluaW5nIHRoZSBjb250ZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogcGFyc2VIVE1MKCc8ZGl2PjEyMzwvZGl2PicpOyAvLyBFbGVtXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSFRNTChodG1sLCBjb2xsYXBzZVdoaXRlU3BhY2UpIHtcbiAgY29uc3QganNvbiA9IG1hcmt1cFRvSlNPTihodG1sLCBjb2xsYXBzZVdoaXRlU3BhY2UpO1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRvYy50ZW1wbGF0ZSgpO1xuICBjb25zdCBlbGVtID0gbmV3IEVsZW0odGVtcGxhdGUuJFswXS5jb250ZW50KTtcblxuICBqc29uLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaE5vZGUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBhdHRycyxcbiAgICAgIHZhbHVlLFxuICAgICAgcGFyZW50LFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gbm9kZTtcblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnQuZWxlbSB8fCBlbGVtO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJlbnROb2RlLmNyZWF0ZShuYW1lKTtcblxuICAgIG5vZGUuZWxlbSA9IGVsZW1lbnQ7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQudGV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBlbGVtZW50LmF0dHIobmV3IFN1cGVyKGF0dHJzKS5tYXAoKHZhbHVlKSA9PiAoXG4gICAgICAgIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZVxuICAgICAgKSkuJCk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIG5vZGUuZWxlbSA9IG5ldyBFbGVtKGVsZW1lbnQucHJvcCgnY29udGVudCcpKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZm9yRWFjaE5vZGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBweFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzaXplIC0gU3RyaW5nIGNvbnRhaW5pbmcgcGl4ZWxzIHZhbHVlIG9yIGEgbnVtYmVyLlxuICogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIHBpeGVscy5cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgcGFyc2luZyBwaXhlbCBzdHJpbmdzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBweCgnMHB4Jyk7ICAvLyAwXG4gKiBweCgnNDJweCcpOyAvLyA0MlxuICovXG5mdW5jdGlvbiBweChzaXplKSB7XG4gIHJldHVybiBOdW1iZXIoU3RyaW5nKHNpemUpLnJlcGxhY2UoL3B4JC8sICcnKSk7XG59XG5cbmV4cG9ydCB7IEVsZW0sIHdpbiwgZG9jLCBodG1sLCBib2R5LCBoZWFkLCBmaW5kLCBwYXJzZUhUTUwsIHB4IH07XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQmxvY2soQmxvY2spIHtcbiAgY2xhc3MgREJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICcnXG4gICAgICArICc8ZC1lbGVtZW50cydcbiAgICAgICsgJyAgdmFsdWU9XCJ7ZWxlbXN9XCInXG4gICAgICArICcgIHBhcmVudFNjb3BlPVwie1BhcmVudFNjb3BlfVwiJ1xuICAgICAgKyAnICBwYXJlbnRUZW1wbGF0ZT1cIntQYXJlbnRUZW1wbGF0ZX1cIidcbiAgICAgICsgJy8+JztcblxuICAgIGFmdGVyQ29uc3RydWN0KCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJlbnRTY29wZToge1xuICAgICAgICAgICQkOiB7XG4gICAgICAgICAgICBwYXJlbnRTY29wZTogcGFyZW50UGFyZW50U2NvcGUsXG4gICAgICAgICAgICBwYXJlbnRUZW1wbGF0ZTogcGFyZW50UGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgICBhcmdzQ2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhcmdzQ2hpbGRyZW46IG93bkNoaWxkcmVuLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgZEJsb2NrTmFtZVxuICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICBsZXQgZm91bmQ7XG5cbiAgICAgIGlmIChvd25DaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50UGFyZW50U2NvcGU7XG4gICAgICB0aGlzLlBhcmVudFRlbXBsYXRlID0gcGFyZW50UGFyZW50VGVtcGxhdGU7XG5cbiAgICAgIGlmIChkQmxvY2tOYW1lKSB7XG4gICAgICAgIGZvdW5kID0gY2hpbGRyZW4uZmluZCgoeyBuYW1lOiBub2RlTmFtZSB9KSA9PiBub2RlTmFtZSA9PT0gYGQtYmxvY2s6JHsgZEJsb2NrTmFtZSB9YCk7XG5cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgICAgLyogZXNsaW50IG5vLWVtcHR5OiAwICovXG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgKHBhcmVudCA9IHBhcmVudC4kJC5wYXJlbnRTY29wZSlcbiAgICAgICAgICAgICYmICEoZm91bmQgPSBwYXJlbnQuJCQuZEJsb2Nrcy5maW5kKCh7ICQkOiB7IGRCbG9ja05hbWU6IERCbG9ja05hbWUgfSB9KSA9PiBEQmxvY2tOYW1lID09PSBkQmxvY2tOYW1lKSlcbiAgICAgICAgICAgICYmIHBhcmVudC4kJC5wYXJlbnRTY29wZS4kJC5uYW1lID09PSAnI2QtaXRlbSdcbiAgICAgICAgICApIHt9XG5cbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuUGFyZW50U2NvcGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLlBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICAgICAgICBmb3VuZC52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGZvdW5kLnZhbHVlLiQkLmFyZ3NDaGlsZHJlblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1zID0gZm91bmQgJiYgZm91bmQudmFsdWUuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgPyBmb3VuZC52YWx1ZS5jaGlsZHJlblxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWJsb2NrJyxcbiAgICB2YWx1ZTogREJsb2NrXG4gIH07XG59XG4iLCJpbXBvcnQgeyBBcnIsIGFycmF5IH0gZnJvbSAnLi4vQXJyJztcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi4vU3VwZXInO1xuaW1wb3J0IHtcbiAgYXNzaWduLCBpdGVyYXRlLFxuICBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc051bWJlclxufSBmcm9tICcuLi9oZWxwZXJzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREVhY2goQmxvY2ssIGNyZWF0ZUJsb2NrKSB7XG4gIGNsYXNzIERFYWNoIGV4dGVuZHMgQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICBpdGVtOiBpdGVtTmFtZSA9ICckaXRlbScsXG4gICAgICAgICAgaW5kZXg6IGluZGV4TmFtZSA9ICckaW5kZXgnXG4gICAgICAgIH1cbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBhc3NpZ24odGhpcy4kJCwge1xuICAgICAgICB1aWRzOiBuZXcgU3VwZXIoe30pLFxuICAgICAgICBpdGVtczogbmV3IEFycihbXSksXG4gICAgICAgIFVJRDogdGhpcy5hcmdzLnVpZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGl0ZW1OYW1lLFxuICAgICAgICBpbmRleE5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFmdGVyUmVuZGVyKCkge1xuICAgICAgdGhpcy53YXRjaCgnYXJncy5zZXQnLCAnYXJncy5zb3J0QnknLCAnYXJncy5maWx0ZXJCeScsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3NDaGlsZHJlbixcbiAgICAgICAgICB1aWRzLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgICAgaW5kZXhOYW1lLFxuICAgICAgICAgIFVJRFxuICAgICAgICB9ID0gdGhpcy4kJDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IHsgc29ydEJ5IH1cbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0ICR1aWRzID0gdWlkcy4kO1xuICAgICAgICBjb25zdCBuZXdLZXlzID0ge307XG4gICAgICAgIGNvbnN0IG5ld1VJRHMgPSB7fTtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzZXQsXG4gICAgICAgICAgZmlsdGVyQnlcbiAgICAgICAgfSA9IHRoaXMuYXJncztcblxuICAgICAgICBpZiAoaXNOdW1iZXIoc2V0KSkge1xuICAgICAgICAgIHNldCA9IGFycmF5KHNldCkuJDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KHNldCkgJiYgaXNGdW5jdGlvbihzb3J0QnkpKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IEFycihzZXQpXG4gICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgLnNvcnQoc29ydEJ5KVxuICAgICAgICAgICAgLiQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXJCeSkpIHtcbiAgICAgICAgICBmaWx0ZXJCeSA9IFtmaWx0ZXJCeV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheShmaWx0ZXJCeSkpIHtcbiAgICAgICAgICBpdGVyYXRlKGZpbHRlckJ5LCAoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICBzZXQgPSBuZXcgU3VwZXIoc2V0KS5maWx0ZXIoZmlsdGVyKS4kO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IFN1cGVyKHNldCkuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBzY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuICAgICAgICAgIHNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcblxuICAgICAgICAgIGNvbnN0IHVpZCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKFVJRCwgbnVsbCwgbnVsbCwgZmFsc2UsIGZhbHNlLCB0aGlzKTtcblxuICAgICAgICAgIG5ld0tleXNbdWlkXSA9IG5ld0tleXNbdWlkXSB8fCB7fTtcbiAgICAgICAgICBuZXdLZXlzW3VpZF1baW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICBuZXdVSURzW2luZGV4XSA9IHVpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGVbaXRlbU5hbWVdID0gbnVsbDtcbiAgICAgICAgc2NvcGVbaW5kZXhOYW1lXSA9IG51bGw7XG5cbiAgICAgICAgdWlkcy5mb3JFYWNoKChpdGVtcywgdWlkKSA9PiB7XG4gICAgICAgICAgaWYgKCFuZXdLZXlzW3VpZF0pIHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgSXRlbS4kJC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlbXMuc3BsaWNlKE9iamVjdC5rZXlzKG5ld0tleXNbdWlkXSkubGVuZ3RoKS5mb3JFYWNoKChJdGVtKSA9PiB7XG4gICAgICAgICAgICBJdGVtLiQkLnJlbW92ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICAgIG5ldyBTdXBlcihzZXQpLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgdWlkID0gbmV3VUlEc1tpbmRleF07XG4gICAgICAgICAgbGV0IGJsb2NrO1xuXG4gICAgICAgICAgaWYgKCR1aWRzW3VpZF0gJiYgJHVpZHNbdWlkXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJsb2NrID0gbmV3S2V5c1t1aWRdW2luZGV4XSA9IHVpZHMuJFt1aWRdLnNoaWZ0KCk7XG4gICAgICAgICAgICBibG9jay4kJC5zY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG4gICAgICAgICAgICBibG9jay4kJC5zY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuXG4gICAgICAgICAgICBpZiAoYmxvY2suJCQucHJldkJsb2NrICE9PSBwcmV2QmxvY2spIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBjb250ZW50IH0gPSBibG9jay4kJDtcblxuICAgICAgICAgICAgICBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibG9jayA9IG5ld0tleXNbdWlkXVtpbmRleF0gPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBpdGVtTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleE5hbWUsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnI2QtaXRlbScsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGFyZ3NDaGlsZHJlblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxuICAgICAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2suJCQucHJldkJsb2NrID0gcHJldkJsb2NrO1xuICAgICAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiQkLnVpZHMgPSBuZXcgU3VwZXIobmV3S2V5cykubWFwKChpdGVtcykgPT4gKFxuICAgICAgICAgIG5ldyBTdXBlcihpdGVtcykudmFsdWVzKClcbiAgICAgICAgKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWVhY2gnLFxuICAgIHZhbHVlOiBERWFjaFxuICB9O1xufVxuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREVsZW1lbnRzKEJsb2NrLCBjcmVhdGVCbG9jaykge1xuICBjbGFzcyBERWxlbWVudHMgZXh0ZW5kcyBCbG9jayB7XG4gICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgICBjb25zdCB7IHBhcmVudEVsZW0gfSA9IHRoaXMuJCQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgICAgfSA9IHRoaXMuYXJncztcbiAgICAgIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICB0aGlzLndhdGNoKCdhcmdzLnZhbHVlJywgKCkgPT4ge1xuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgbWl4aW5zLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSA9IHRoaXMuJCQ7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuYXJncztcblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGNoaWxkLiQkLnJlbW92ZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xuICAgICAgICAgIG1peGluLiQkLnJlbW92ZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQoY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiQkLmNoaWxkcmVuID0gbmV3IEFycihbXSk7XG4gICAgICAgIHRoaXMuJCQubWl4aW5zID0gbmV3IEFycihbXSk7XG4gICAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JERWxlbWVudHMgfSkgPT4ge1xuICAgICAgICAgIGlmIChmb3JERWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gd2F0Y2hlcnMuaW5kZXhPZih3YXRjaGVyKTtcblxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdhdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kJC5jb250ZW50ID0gbmV3IEVsZW0oKTtcblxuICAgICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICAgIG5ldyBBcnIodmFsdWUgfHwgW10pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgICAgcGFyZW50QmxvY2s6IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZC1lbGVtZW50cycsXG4gICAgdmFsdWU6IERFbGVtZW50c1xuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRElmKEJsb2NrKSB7XG4gIGNsYXNzIERJZiBleHRlbmRzIEJsb2NrIHtcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSAnJ1xuICAgICAgKyAnPGQtZWxlbWVudHMnXG4gICAgICArICcgIHZhbHVlPVwie2VsZW1zfVwiJ1xuICAgICAgKyAnICBwYXJlbnRTY29wZT1cInskJC5wYXJlbnRTY29wZX1cIidcbiAgICAgICsgJyAgcGFyZW50VGVtcGxhdGU9XCJ7JCQucGFyZW50VGVtcGxhdGV9XCInXG4gICAgICArICcvPic7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICBzdXBlcihvcHRzKTtcblxuICAgICAgY29uc3QgeyBwYXJlbnRTY29wZSB9ID0gdGhpcy4kJDtcbiAgICAgIGxldCBpbmRleCA9IEluZmluaXR5O1xuICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4kJC5hcmdzQ2hpbGRyZW4ubWFwKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdHRycyxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9ID0gY2hpbGQ7XG4gICAgICAgIGxldCBjb25kID0gYXR0cnMuaWY7XG5cbiAgICAgICAgaWYgKG5hbWUgIT09ICdkLWVsc2UnICYmIGNvbmQpIHtcbiAgICAgICAgICBjb25kID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoY29uZCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoISFuZXdWYWx1ZSA9PT0gdmFsdWVzLiRbaV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZXMuJFtpXSA9ICEhbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB2YWx1ZXMuZmluZChCb29sZWFuKTtcblxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gZm91bmQua2V5O1xuICAgICAgICAgICAgICB0aGlzLmVsZW1zID0gdGhpcy4kJC5hcmdzQ2hpbGRyZW4uJFtmb3VuZC5rZXldLmNoaWxkcmVuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZCAmJiBpbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhY29uZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtaWYnLFxuICAgIHZhbHVlOiBESWZcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRJdGVtKEJsb2NrKSB7XG4gIGNsYXNzIERJdGVtIGV4dGVuZHMgQmxvY2sge1xuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICcnXG4gICAgICArICc8ZC1lbGVtZW50cydcbiAgICAgICsgJyAgdmFsdWU9XCJ7JCQuYXJnc0NoaWxkcmVufVwiJ1xuICAgICAgKyAnICBwYXJlbnRTY29wZT1cInt0aGlzfVwiJ1xuICAgICAgKyAnICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIidcbiAgICAgICsgJy8+JztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJyNkLWl0ZW0nLFxuICAgIHZhbHVlOiBESXRlbVxuICB9O1xufVxuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi4vU3VwZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEU3dpdGNoKEJsb2NrKSB7XG4gIGNsYXNzIERTd2l0Y2ggZXh0ZW5kcyBCbG9jayB7XG4gICAgc3RhdGljIHRlbXBsYXRlID0gJydcbiAgICAgICsgJzxkLWVsZW1lbnRzJ1xuICAgICAgKyAnICB2YWx1ZT1cIntlbGVtc31cIidcbiAgICAgICsgJyAgcGFyZW50U2NvcGU9XCJ7JCQucGFyZW50U2NvcGV9XCInXG4gICAgICArICcgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiJ1xuICAgICAgKyAnLz4nO1xuXG4gICAgaW5kZXggPSBJbmZpbml0eTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgICQkOiB7IHBhcmVudFNjb3BlIH0sXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGFyZ3M6IHsgdmFsdWUgfVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgd2FzRGVmYXVsdDtcblxuICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLiQkLmFyZ3NDaGlsZHJlbi5vYmplY3QoKHZhbHVlcywgY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBsZXQgdmFsID0gYXR0cnMuaWY7XG5cbiAgICAgICAgaWYgKHdhc0RlZmF1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSAhPT0gJ2QtY2FzZScgJiYgbmFtZSAhPT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgICB3YXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSAnZC1kZWZhdWx0Jykge1xuICAgICAgICAgIHZhbCA9IGFyZ3MudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICAgICAgdmFsID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyh0aGlzLnZhbHVlcy4kW2ldLnZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnZhbHVlcy4kW2ldLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLnZhbHVlcy5maW5kKCh7IHZhbHVlIH0pID0+IChcbiAgICAgICAgICAgICAgdGhpcy5lcXVhbHModmFsdWUsIGFyZ3MudmFsdWUpXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZC5rZXk7XG4gICAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZC52YWx1ZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKHZhbCwgdmFsdWUpICYmIHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH0sIG5ldyBBcnIoW10pKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICAgIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICB0aGlzLndhdGNoKCdhcmdzLnZhbHVlJywgKCkgPT4ge1xuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKCh7IG5hbWUsIHZhbHVlLCBjaGlsZHJlbiB9LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsID0gbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICAgID8gbmV3VmFsdWVcbiAgICAgICAgICAgIDogdmFsdWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5lcXVhbHModmFsLCBuZXdWYWx1ZSkgJiYgdGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVxdWFscyh2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIG5ldyBTdXBlcih2YWx1ZTEpLmVxdWFscyh2YWx1ZTIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtc3dpdGNoJyxcbiAgICB2YWx1ZTogRFN3aXRjaFxuICB9O1xufVxuIiwiaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRBdHRyKE1peGluKSB7XG4gIGNsYXNzIERBdHRyIGV4dGVuZHMgTWl4aW4ge1xuICAgIGF0dHJzID0ge307XG5cbiAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBhcmdzLFxuICAgICAgICBhdHRyc1xuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3IFN1cGVyKGFyZ3MpLm9iamVjdCgoYXR0cnMsIGF0dHIpID0+IHtcbiAgICAgICAgICBhdHRyc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbmV3VmFsdWUgPSBuZXcgU3VwZXIobmV3VmFsdWUgfHwge30pLiQ7XG5cbiAgICAgIG5ldyBTdXBlcihhdHRycykuZm9yRWFjaCgodmFsdWUsIHByb3ApID0+IHtcbiAgICAgICAgaWYgKCFuZXdWYWx1ZVtwcm9wXSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbGVtLmF0dHIobmV3VmFsdWUpO1xuXG4gICAgICB0aGlzLmF0dHJzID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgYmVmb3JlUmVtb3ZlKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBhdHRyc1xuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGVsZW0ucmVtb3ZlQXR0ci5hcHBseShlbGVtLCBuZXcgU3VwZXIoYXR0cnMpLmtleXMoKS4kKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWF0dHInLFxuICAgIHZhbHVlOiBEQXR0clxuICB9O1xufVxuXG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vaGVscGVycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRCaW5kKE1peGluKSB7XG4gIGNsYXNzIERCaW5kIGV4dGVuZHMgTWl4aW4ge1xuICAgIGFmdGVyVXBkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5vZmYpIHtcbiAgICAgICAgdGhpcy5vZmYoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLmVsZW0ub24odGhpcy5hcmdzLmpvaW4oJywnKSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtYmluZFwiIG1peGluIHdpdGggYW4gZXZlbnQgbmFtZXMgKGxpa2UgXCJkLWJpbmQoY2xpY2spXCIgb3IgXCJkLWJpbmQoa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICBjb25zdCB7IG9mZiB9ID0gdGhpcztcblxuICAgICAgaWYgKG9mZikge1xuICAgICAgICBvZmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWJpbmQnLFxuICAgIHZhbHVlOiBEQmluZFxuICB9O1xufVxuIiwiaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XG5pbXBvcnQgeyBpc0FycmF5LCBpc1N0cmluZywgaXRlcmF0ZSB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQ2xhc3MoTWl4aW4pIHtcbiAgY2xhc3MgRENsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICAgIGNsYXNzZXMgPSBbXTtcblxuICAgIGFmdGVyVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNsYXNzZXNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IFtdO1xuXG4gICAgICBuZXdWYWx1ZSA9IG5ldyBTdXBlcihuZXdWYWx1ZSkuJDtcblxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgICAgID8gYXJnc1xuICAgICAgICAgIDogW107XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgICAgaXRlcmF0ZShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlLmluZGV4T2YoY2xzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVyYXRlKG5ld1ZhbHVlLCAoY2xzKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNscykpIHtcbiAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlKGNsYXNzZXMsIChjbHMpID0+IHtcbiAgICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8ICFuZXdWYWx1ZVtjbHNdKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXRlcmF0ZShuZXdWYWx1ZSwgKHZhbCwgY2xzKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGFzc2VzID0gbmV3Q2xhc3NlcztcbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MuYXBwbHkoZWxlbSwgbmV3IFN1cGVyKHRoaXMudmFsdWUpLmtleXMoKS4kKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLWNsYXNzJyxcbiAgICB2YWx1ZTogRENsYXNzXG4gIH07XG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJERWxlbShNaXhpbiwgY3JlYXRlQmxvY2ssIEJsb2NrKSB7XG4gIGNsYXNzIERFbGVtIGV4dGVuZHMgTWl4aW4ge1xuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIGVsZW1cbiAgICAgIH0gPSB0aGlzO1xuICAgICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xuXG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUoZWxlbSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBzY29wZVt2YWx1ZV0gPSBlbGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtZWxlbScsXG4gICAgdmFsdWU6IERFbGVtXG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJESGlkZShNaXhpbikge1xuICBjbGFzcyBESGlkZSBleHRlbmRzIE1peGluIHtcbiAgICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgICAgY29uc3QgeyBlbGVtIH0gPSB0aGlzO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZWxlbS5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtaGlkZScsXG4gICAgdmFsdWU6IERIaWRlXG4gIH07XG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJETm9kZShNaXhpbiwgY3JlYXRlQmxvY2ssIEJsb2NrKSB7XG4gIGNsYXNzIEROb2RlIGV4dGVuZHMgTWl4aW4ge1xuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xuXG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBzY29wZVt2YWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtbm9kZScsXG4gICAgdmFsdWU6IEROb2RlXG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJET24oTWl4aW4pIHtcbiAgY2xhc3MgRE9uIGV4dGVuZHMgTWl4aW4ge1xuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLmVsZW0ub24odGhpcy5hcmdzLmpvaW4oJywnKSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZXZhbHVhdGVPbmNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtb25cIiBtaXhpbiB3aXRoIGFuIGV2ZW50IG5hbWVzIChsaWtlIFwiZC1vbihjbGljaylcIiBvciBcImQtb24oa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICBjb25zdCB7IG9mZiB9ID0gdGhpcztcblxuICAgICAgaWYgKG9mZikge1xuICAgICAgICBvZmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLW9uJyxcbiAgICB2YWx1ZTogRE9uXG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEU2hvdyhNaXhpbikge1xuICBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcbiAgICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgICAgY29uc3QgeyBlbGVtIH0gPSB0aGlzO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZWxlbS5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICB0aGlzLmVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtc2hvdycsXG4gICAgdmFsdWU6IERTaG93XG4gIH07XG59XG4iLCJpbXBvcnQgeyBBcnIgfSBmcm9tICcuLi9BcnInO1xuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEU3R5bGUoTWl4aW4pIHtcbiAgY2xhc3MgRFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xuICAgIGNzcyA9IHt9O1xuXG4gICAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNzc1xuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3IFN1cGVyKGFyZ3MpLm9iamVjdCgoY3NzLCBwcm9wKSA9PiB7XG4gICAgICAgICAgY3NzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3IEFycihuZXdWYWx1ZS5zcGxpdCgvOyA/LykpXG4gICAgICAgICAgLmZpbHRlcigpXG4gICAgICAgICAgLm9iamVjdCgoY3NzLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbcHJvcCwgdmFsdWVdID0gaXRlbTtcblxuICAgICAgICAgICAgY3NzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gbmV3IFN1cGVyKG5ld1ZhbHVlIHx8IHt9KS4kO1xuXG4gICAgICBuZXcgU3VwZXIoY3NzKS5mb3JFYWNoKCh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlW3Byb3BdKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDU1MocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWxlbS5jc3MobmV3VmFsdWUpO1xuXG4gICAgICB0aGlzLmNzcyA9IG5ld1ZhbHVlO1xuICAgIH1cblxuICAgIGJlZm9yZVJlbW92ZSgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgY3NzXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgZWxlbS5yZW1vdmVDU1MuYXBwbHkoZWxlbSwgbmV3IFN1cGVyKGNzcykua2V5cygpLiQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Qtc3R5bGUnLFxuICAgIHZhbHVlOiBEU3R5bGVcbiAgfTtcbn1cbiIsImltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi4vU3dpdGNoZXInO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5jb25zdCBsaXN0ZW5lclN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsICdpbnB1dCcpXG4gIC5jYXNlKCdmb3JtJywgJ2lucHV0LCBjaGFuZ2UnKVxuICAuY2FzZSgnc2VsZWN0JywgJ2NoYW5nZScpXG4gIC5jYXNlKCdpbnB1dCcsICh0eXBlKSA9PiAoXG4gICAgdHlwZSA9PT0gJ3JhZGlvJ1xuICAgIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICB8fCB0eXBlID09PSAnY29sb3InXG4gICAgfHwgdHlwZSA9PT0gJ2ZpbGUnXG4gICAgICA/ICdjaGFuZ2UnXG4gICAgICA6ICdjaGFuZ2UgaW5wdXQnXG4gICkpO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEVmFsaWRhdGUoTWl4aW4pIHtcbiAgY2xhc3MgRFZhbGlkYXRlIGV4dGVuZHMgTWl4aW4ge1xuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHRoaXMudmFsdWUgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICAgIGVsZW0udmFsaWRhdGUodmFsaWRhdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsaWRhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMub2ZmID0gZWxlbS5vbihsaXN0ZW5lclN3aXRjaGVyKGVsZW0ubmFtZSwgW2VsZW0ucHJvcCgndHlwZScpXSksICgpID0+IHtcbiAgICAgICAgICBlbGVtLnZhbGlkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZVJlbW92ZSgpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHZhbGlkYXRvcnMgfSA9IHRoaXMubm9kZS5kd2F5bmVEYXRhO1xuICAgICAgICBjb25zdCBpbmRleCA9IHZhbGlkYXRvcnMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHZhbGlkYXRvcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm9mZigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2QtdmFsaWRhdGUnLFxuICAgIHZhbHVlOiBEVmFsaWRhdGVcbiAgfTtcbn1cbiIsImltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4uL1N3aXRjaGVyJztcbmltcG9ydCB7IGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTmlsLCBjb25zdHJ1Y3RFdmFsRnVuY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzJztcblxuY29uc3QgcHJvcFN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsICh0eXBlLCBlbGVtKSA9PiAoXG4gIGVsZW0uaGFzQXR0cignY29udGVudGVkaXRhYmxlJykgfHwgZWxlbS5oYXNBdHRyKCdjb250ZW50RWRpdGFibGUnKVxuICAgID8gJ3RleHQnXG4gICAgOiAndmFsdWUnXG4pKVxuICAuY2FzZSgnc2VsZWN0JywgKHR5cGUsIGVsZW0pID0+IChcbiAgICBlbGVtLmhhc0F0dHIoJ211bHRpcGxlJylcbiAgICAgID8gJ211bHRpcGxlLXNlbGVjdCdcbiAgICAgIDogJ3ZhbHVlJ1xuICApKVxuICAuY2FzZSgnaW5wdXQnLCAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHJldHVybiAnZmlsZXMnO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICAgID8gJ2NoZWNrZWQnXG4gICAgICA6ICd2YWx1ZSc7XG4gIH0pO1xuY29uc3Qgc2V0VmFsdWVTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAodmFsdWUpID0+IHZhbHVlKVxuICAuY2FzZSgnaW5wdXQnLCAodmFsdWUsIHR5cGUsIGlucHV0VmFsdWUpID0+IHtcbiAgICBpZiAodHlwZSAhPT0gJ3JhZGlvJyAmJiB0eXBlICE9PSAnY2hlY2tib3gnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gaW5wdXRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSAhPT0gLTE7XG4gIH0pO1xuY29uc3QgZ2V0VmFsdWVTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAodmFsdWUpID0+IHZhbHVlKVxuICAuY2FzZSgnc2VsZWN0JywgKHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlLCB2YWx1ZXMsIGVsZW0sIG9wdGlvbnMsIGluaXQsIGlzTXVsdGlwbGUpID0+IHtcbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICAgICAgLm9iamVjdCgodmFsdWVzLCB7IHNlbGVjdGVkLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RlZCAmJiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBbXSlcbiAgICAgIC4kO1xuICB9KVxuICAuY2FzZSgnaW5wdXQnLCAodmFsdWUsIHR5cGUsIGlucHV0VmFsdWUsIHZhbHVlcywgZWxlbSwgb3B0aW9ucywgaW5pdCkgPT4ge1xuICAgIGlmICh0eXBlICE9PSAncmFkaW8nICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gaW5wdXRWYWx1ZVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSAmJiBpbml0KSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmluZGV4T2YoaW5wdXRWYWx1ZSkgPT09IC0xXG4gICAgICAgICAgPyBuZXcgQXJyKHZhbHVlcykuY29uY2F0KGlucHV0VmFsdWUpLiRcbiAgICAgICAgICA6IHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtpbnB1dFZhbHVlXTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdmFsdWVzLmluZGV4T2YoaW5wdXRWYWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5uZXcgQXJyKHZhbHVlcykuc2xpY2UoMCwgaW5kZXgpLiQsXG4gICAgICAgIC4uLm5ldyBBcnIodmFsdWVzKS5zbGljZShpbmRleCArIDEpLiRcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG5jb25zdCBsaXN0ZW5lclN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsICdpbnB1dCcpXG4gIC5jYXNlKCdzZWxlY3QnLCAnY2hhbmdlJylcbiAgLmNhc2UoJ2lucHV0JywgKHR5cGUpID0+IChcbiAgICB0eXBlID09PSAncmFkaW8nXG4gICAgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgIHx8IHR5cGUgPT09ICdjb2xvcidcbiAgICB8fCB0eXBlID09PSAnZmlsZSdcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogJ2NoYW5nZSBpbnB1dCdcbiAgKSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRWYWx1ZShNaXhpbiwgY3JlYXRlQmxvY2ssIEJsb2NrKSB7XG4gIGNsYXNzIERWYWx1ZSBleHRlbmRzIE1peGluIHtcbiAgICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBlbGVtLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLm5hbWU7XG4gICAgICBjb25zdCB0eXBlID0gZWxlbS5wcm9wKCd0eXBlJyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGVPbmNlKCk7XG4gICAgICBsZXQgaW5pdGlhbFNjb3BlVmFsdWUgPSBudWxsO1xuXG4gICAgICB0aGlzLnByb3AgPSBwcm9wU3dpdGNoZXIobmFtZSwgW3R5cGUsIGVsZW1dKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5vcHRpb25zID0gZWxlbS5maW5kKCdvcHRpb24nKTtcbiAgICAgIHRoaXMuc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcblxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gYXJnc1swXTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBpbml0aWFsU2NvcGVWYWx1ZSA9IHRoaXMuc2NvcGUuJCQuZXZhbHVhdGUoY29uc3RydWN0RXZhbEZ1bmN0aW9uKGAkLiR7IHZhbHVlIH1gLCB2YWx1ZSksIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFByb3AobmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluaXRpYWxFbGVtVmFsdWUgPSB0aGlzLmdldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUsIHRydWUpO1xuICAgICAgY29uc3QgaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgPSBpc05pbChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICBjb25zdCBpc0NoZWNrYm94ID0gdHlwZSA9PT0gJ2NoZWNrYm94JztcbiAgICAgIGNvbnN0IGNoYW5nZVNjb3BlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0UHJvcCh0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbEVsZW1WYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTY29wZSgpO1xuXG4gICAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xuICAgICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbFNjb3BlVmFsdWU7XG4gICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2ZmRWxlbUxpc3RlbmVyID0gZWxlbS5vbihsaXN0ZW5lclN3aXRjaGVyKG5hbWUsIFt0eXBlXSksIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gbm9kZSkge1xuICAgICAgICAgIGNoYW5nZVNjb3BlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIgPSBlbGVtLmNsb3Nlc3QoJ2Zvcm0nKS5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoY2hhbmdlU2NvcGUsIDApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2hhbmdlU2NvcGUoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjb3BlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY3VycmVudFZhbHVlXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZVt2YWx1ZV0gPSBjdXJyZW50VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0UHJvcCh2YWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wLFxuICAgICAgICB0eXBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKHByb3AgPT09ICd0ZXh0Jykge1xuICAgICAgICBlbGVtLnRleHQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jykge1xuICAgICAgICBvcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2Yob3B0aW9uLnZhbHVlKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5wcm9wKHByb3AsIHNldFZhbHVlU3dpdGNoZXIobmFtZSwgW3ZhbHVlLCB0eXBlLCBub2RlLnZhbHVlXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldFByb3AodmFsdWVzLCBpbml0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICByZXR1cm4gcHJvcCA9PT0gJ3RleHQnXG4gICAgICAgID8gZWxlbS50ZXh0KClcbiAgICAgICAgOiBnZXRWYWx1ZVN3aXRjaGVyKG5hbWUsIFtlbGVtLnByb3AocHJvcCksIHR5cGUsIG5vZGUudmFsdWUsIHZhbHVlcywgZWxlbSwgb3B0aW9ucywgaW5pdCwgcHJvcCA9PT0gJ211bHRpcGxlLXNlbGVjdCddKTtcbiAgICB9XG5cbiAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lcigpO1xuICAgICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLXZhbHVlJyxcbiAgICB2YWx1ZTogRFZhbHVlXG4gIH07XG59XG4iLCJjb25zdCBlbXB0eVNwYWNlUmVnRXhwID0gL15cXHMrLztcbmNvbnN0IGFueUVtcHR5U3BhY2VSZWdFeHAgPSAvXFxzKy9nO1xuY29uc3QgYW55RXNjYXBlZEV4cHJlc3Npb25SZWdFeHAgPSAvXFxcXFtcXHNcXFNdL2c7XG5jb25zdCBhbnlEb3VibGVRdW90ZVJlZ0V4cCA9IC9cIi9nO1xuY29uc3QgYW55TmV3TGluZVJlZ0V4cCA9IC9cXHJcXG58XFxyfFxcbi9nO1xuY29uc3QgYW55Q29tbWFFbXB0eVNwYWNlID0gL1xccyosXFxzKi87XG5jb25zdCBwcm9wZXJFc2NhcGVkUmVnRXhwID0gL1xcXFx8dXxufGZ8cnx0fGJ8dnxgWzAtN10vO1xuXG5jb25zdCB0aGlzUmVnRXhwID0gL150aGlzKD8hW2EtekEtWl8kXSkvO1xuY29uc3Qgc2ltcGxlRXhwcmVzc2lvblJlZ0V4cCA9IC9eKD86dHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZCkoPyFbYS16QS1aXyRdKS87XG5jb25zdCB2YXJpYWJsZVJlZ0V4cCA9IC9eW2EtekEtWl8kXVthLXpBLVowLTlfJF0qLztcbmNvbnN0IG51bWJlclJlZ0V4cCA9IC9eKD86TmFOfC0/KD86KD86XFxkK3xcXGQqXFwuXFxkKykoPzpbRXxlXVsrfC1dP1xcZCspP3xJbmZpbml0eSkpLztcbmNvbnN0IHN0cmluZ1JlZ0V4cCA9IC9eKD86XCIoPzooPzpcXFxcW1xcc1xcU10pfFteXCJcXG5cXFxcXSkqXCJ8Jyg/Oig/OlxcXFxbXFxzXFxTXSl8W14nXFxuXFxcXF0pKicpLztcbmNvbnN0IHJlZ2V4cFJlZ0V4cCA9IC9eXFwvKD86KD86XFxcXFtcXHNcXFNdKXxbXi9cXG5cXFxcXSkrXFwvW2dpbXV5XSovO1xuY29uc3QgYXJyb3dGdW5jdGlvblJlZ0V4cCA9IC9eKD86KD86XFwoXFxzKigoPzpbYS16QS1aXyRdW2EtekEtWjAtOV8kXSpcXHMqLFxccyopPyg/OlthLXpBLVpfJF1bYS16QS1aMC05XyRdKik/KVxccypcXCkpfChbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopKVxccyo9Pi87XG5jb25zdCB0ZW1wbGF0ZVN0cmluZ0NvbnRlbnRSZWdFeHAgPSAvXig/Oig/OlxcXFxbXFxzXFxTXSl8XFwkKD8hXFx7KXxbXmAkXFxcXF0pKy87XG5jb25zdCBvcGVyYXRvclJlZ0V4cCA9IC9eKD86KD86Pj4+fD4+fDw8KT0/fCYmfFxcfFxcfHwsfCg/OlxcK3wtfFxcKnxcXC98JXwmfFxcfHxcXF58PHw+fD09fCE9KT0/fD0pLztcbmNvbnN0IHBvaW50T3BlcmF0b3JSZWdFeHAgPSAvXlxcLihbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopLztcbmNvbnN0IHByb3BlcnR5UmVnRXhwID0gL14oKD86XCIoPzooPzpcXFxcW1xcc1xcU10pfFteXCJcXG5cXFxcXSkqXCJ8Jyg/Oig/OlxcXFxbXFxzXFxTXSl8W14nXFxuXFxcXF0pKid8W2EtekEtWl8kXVthLXpBLVowLTlfJF0qKSlcXHMqOi87XG5jb25zdCBzaG9ydGhhbmRQcm9wZXJ0eVJlZ0V4cCA9IC9eKFthLXpBLVpfJF1bYS16QS1aMC05XyRdKilcXHMqKD89LHx9KSgsPykvO1xuY29uc3QgdW5hcnlPcGVyYXRvclJlZ0V4cCA9IC9eKD86LXx+fFxcK3whKS87XG5jb25zdCBrZXl3b3Jkc0FycmF5ID0gW1xuICAnZG8nLFxuICAnaWYnLFxuICAnaW4nLFxuICAnZm9yJyxcbiAgJ2xldCcsXG4gICduZXcnLFxuICAndHJ5JyxcbiAgJ3ZhcicsXG4gICdjYXNlJyxcbiAgJ2Vsc2UnLFxuICAnZW51bScsXG4gICdudWxsJyxcbiAgJ3RoaXMnLFxuICAndHJ1ZScsXG4gICd2b2lkJyxcbiAgJ3dpdGgnLFxuICAnYnJlYWsnLFxuICAnY2F0Y2gnLFxuICAnY2xhc3MnLFxuICAnY29uc3QnLFxuICAnZmFsc2UnLFxuICAnc3VwZXInLFxuICAndGhyb3cnLFxuICAnd2hpbGUnLFxuICAneWllbGQnLFxuICAnZGVsZXRlJyxcbiAgJ2V4cG9ydCcsXG4gICdpbXBvcnQnLFxuICAncHVibGljJyxcbiAgJ3JldHVybicsXG4gICdzdGF0aWMnLFxuICAnc3dpdGNoJyxcbiAgJ3R5cGVvZicsXG4gICdkZWZhdWx0JyxcbiAgJ2V4dGVuZHMnLFxuICAnZmluYWxseScsXG4gICdwYWNrYWdlJyxcbiAgJ3ByaXZhdGUnLFxuICAnY29udGludWUnLFxuICAnZGVidWdnZXInLFxuICAnZnVuY3Rpb24nLFxuICAnYXJndW1lbnRzJyxcbiAgJ2ludGVyZmFjZScsXG4gICdwcm90ZWN0ZWQnLFxuICAnaW1wbGVtZW50cycsXG4gICdpbnN0YW5jZW9mJ1xuXTtcbmNvbnN0IGtleXdvcmRzUmVnRXhwID0gbmV3IFJlZ0V4cChgXig/OiR7IGtleXdvcmRzQXJyYXkuam9pbignfCcpIH0pJGApO1xuXG5jb25zdCBFWFBSRVNTSU9OID0gJ2V4cHJlc3Npb24nO1xuY29uc3QgRU5EX09GX0ZVTkNfQk9EWSA9ICdlbmQgb2YgZnVuY3Rpb24gYm9keSc7XG5jb25zdCBzdWJtaXRTdHJpbmcgPSAnUGxlYXNlLCBzdWJtaXQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2R3YXluZWpzL2R3YXluZS9pc3N1ZXMvbmV3LCBpZiBuZWVkZWQuJztcblxuZnVuY3Rpb24gcGFyc2VKUyhzdHJpbmcsIHdob2xlU3RyaW5nLCBjdXJseUVycm9yKSB7XG4gIGN1cmx5RXJyb3IgPSAhIWN1cmx5RXJyb3I7XG5cbiAgY29uc3QgaW5pdGlhbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3QgZXhwZWN0ZWQgPSB7XG4gICAgZXhwcmVzc2lvbjogdHJ1ZSxcbiAgICBjbG9zaW5nRXhwcmVzc2lvbnM6IFtdLFxuICAgIGZ1bmN0aW9uU2NvcGU6IHt9XG4gIH07XG4gIGNvbnN0IHZhcmlhYmxlcyA9IHt9O1xuICBjb25zdCB7IGNsb3NpbmdFeHByZXNzaW9ucyB9ID0gZXhwZWN0ZWQ7XG4gIGxldCBleHByZXNzaW9uID0gJyc7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgc3BhY2VNYXRjaDtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHRvQ29uY2F0ID0gJyc7XG4gICAgbGV0IG1hdGNoZWQ7XG4gICAgbGV0IGlzRW1wdHlTcGFjZTtcbiAgICBsZXQge1xuICAgICAgdHlwZTogcHJvcGVyVHlwZSxcbiAgICAgIHN5bWJvbDogcHJvcGVyU3ltYm9sXG4gICAgfSA9IGNsb3NpbmdFeHByZXNzaW9uc1tjbG9zaW5nRXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0gfHwge307XG4gICAgY29uc3QgZmlyc3RTeW1ib2wgPSBzdHJpbmdbMF07XG5cbiAgICBpZiAoKHNwYWNlTWF0Y2ggPSBzdHJpbmcubWF0Y2goZW1wdHlTcGFjZVJlZ0V4cCkpICYmICFleHBlY3RlZC50ZW1wbGF0ZVN0cmluZykge1xuICAgICAgaXNFbXB0eVNwYWNlID0gdHJ1ZTtcbiAgICAgIG1hdGNoID0gc3BhY2VNYXRjaFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cGVjdGVkLmV4cHJlc3Npb24pIHtcbiAgICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYXJyb3dGdW5jdGlvblJlZ0V4cCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgdmFycyA9IChtYXRjaFsyXSB8fCBtYXRjaFsxXSkuc3BsaXQoYW55Q29tbWFFbXB0eVNwYWNlKTtcbiAgICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBuZXdGdW5jdGlvblZhcnMgPSBPYmplY3QuY3JlYXRlKGV4cGVjdGVkLmZ1bmN0aW9uU2NvcGUpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHZhcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdmFyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgbmV3RnVuY3Rpb25WYXJzW3ZhcmlhYmxlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9Db25jYXQgPSBgZnVuY3Rpb24oJHsgdmFyaWFibGVzLmpvaW4oJywnKSB9KXtyZXR1cm4gYDtcbiAgICAgICAgICBleHBlY3RlZC5mdW5jdGlvblNjb3BlID0gbmV3RnVuY3Rpb25WYXJzO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdhbnknLFxuICAgICAgICAgICAgc3ltYm9sOiBFTkRfT0ZfRlVOQ19CT0RZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdHlwZTogJ2FueScsXG4gICAgICAgICAgICBzeW1ib2w6IEVYUFJFU1NJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFN5bWJvbCA9PT0gJygnKSB7XG4gICAgICAgICAgbWF0Y2ggPSAnKCc7XG4gICAgICAgICAgY2xvc2luZ0V4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3BhcmVuJyxcbiAgICAgICAgICAgIHN5bWJvbDogJyknXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RTeW1ib2wgPT09ICdbJykge1xuICAgICAgICAgIG1hdGNoID0gJ1snO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBzeW1ib2w6ICddJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0U3ltYm9sID09PSAnYCcpIHtcbiAgICAgICAgICBtYXRjaCA9ICdgJztcbiAgICAgICAgICB0b0NvbmNhdCA9ICcoXCJcIic7XG4gICAgICAgICAgZXhwZWN0ZWQudGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZW1wbGF0ZVN0cmluZycsXG4gICAgICAgICAgICBzeW1ib2w6ICdgJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVsZXRlIGV4cGVjdGVkLmV4cHJlc3Npb247XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RTeW1ib2wgPT09ICd7Jykge1xuICAgICAgICAgIG1hdGNoID0gJ3snO1xuICAgICAgICAgIGV4cGVjdGVkLm9iamVjdFByb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBjbG9zaW5nRXhwcmVzc2lvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIHN5bWJvbDogJ30nXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWxldGUgZXhwZWN0ZWQuZXhwcmVzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaCh1bmFyeU9wZXJhdG9yUmVnRXhwKTtcblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9Db25jYXQgPSBtYXRjaFswXS5yZXBsYWNlKGFueUVtcHR5U3BhY2VSZWdFeHAsICcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKHNpbXBsZUV4cHJlc3Npb25SZWdFeHApO1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKG51bWJlclJlZ0V4cCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKHN0cmluZ1JlZ0V4cCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChyZWdleHBSZWdFeHApO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKHRoaXNSZWdFeHApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvQ29uY2F0ID0gJyQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKHZhcmlhYmxlUmVnRXhwKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSBtYXRjaFswXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHBlY3RlZC5mdW5jdGlvblNjb3BlW3ZhcmlhYmxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNbdmFyaWFibGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdG9Db25jYXQgPSBnZXRWYXJpYWJsZSh2YXJpYWJsZSwgZXhwZWN0ZWQuZnVuY3Rpb25TY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBleHBlY3RlZC5vcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgIG1hdGNoZWQgPSBFWFBSRVNTSU9OO1xuXG4gICAgICAgICAgICAgIGRlbGV0ZSBleHBlY3RlZC5leHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleHBlY3RlZC50ZW1wbGF0ZVN0cmluZykge1xuICAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaCh0ZW1wbGF0ZVN0cmluZ0NvbnRlbnRSZWdFeHApO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdXG4gICAgICAgICAgICAucmVwbGFjZShhbnlFc2NhcGVkRXhwcmVzc2lvblJlZ0V4cCwgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlY29uZCA9IG1hdGNoWzFdO1xuXG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJFc2NhcGVkUmVnRXhwLnRlc3Qoc2Vjb25kKVxuICAgICAgICAgICAgICAgID8gbWF0Y2hcbiAgICAgICAgICAgICAgICA6IHNlY29uZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShhbnlEb3VibGVRdW90ZVJlZ0V4cCwgJ1xcXFxcIicpXG4gICAgICAgICAgICAucmVwbGFjZShhbnlOZXdMaW5lUmVnRXhwLCAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAnXFxyXFxuJykge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gJ1xcXFxyXFxcXG4nO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gJ1xcXFxyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9ICdcXFxcbic7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gYFwiK1wiJHsgbWF0Y2ggfVwiK1wiYDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdG9Db25jYXQgPSBgK1wiJHsgc3RyaW5nIH1cImA7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RTeW1ib2wgPT09ICdgJykge1xuICAgICAgICAgIG1hdGNoID0gJ2AnO1xuICAgICAgICAgIG1hdGNoZWQgPSBFWFBSRVNTSU9OO1xuICAgICAgICAgIHRvQ29uY2F0ID0gJyknO1xuICAgICAgICAgIGV4cGVjdGVkLm9wZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICBjbG9zaW5nRXhwcmVzc2lvbnMucG9wKCk7XG5cbiAgICAgICAgICBkZWxldGUgZXhwZWN0ZWQudGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLnNsaWNlKDAsIDIpID09PSAnJHsnKSB7XG4gICAgICAgICAgbWF0Y2ggPSAnJHsnO1xuICAgICAgICAgIHRvQ29uY2F0ID0gJysoJztcbiAgICAgICAgICBleHBlY3RlZC5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICBjbG9zaW5nRXhwcmVzc2lvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAndGVtcGxhdGVTdHJpbmcnLFxuICAgICAgICAgICAgc3ltYm9sOiAnfSdcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnYW55JyxcbiAgICAgICAgICAgIHN5bWJvbDogRVhQUkVTU0lPTlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVsZXRlIGV4cGVjdGVkLnRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLm9iamVjdFByb3BlcnR5KSB7XG4gICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKHByb3BlcnR5UmVnRXhwKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBpZiAoa2V5d29yZHNSZWdFeHAudGVzdChtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgIG1hdGNoWzFdID0gYFwiJHsgbWF0Y2hbMV0gfVwiYDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b0NvbmNhdCA9IGAkeyBtYXRjaFsxXSB9OmA7XG4gICAgICAgICAgZXhwZWN0ZWQuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICAgICAgY2xvc2luZ0V4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2FueScsXG4gICAgICAgICAgICBzeW1ib2w6IEVYUFJFU1NJT05cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlbGV0ZSBleHBlY3RlZC5vYmplY3RQcm9wZXJ0eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChzaG9ydGhhbmRQcm9wZXJ0eVJlZ0V4cCk7XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gbWF0Y2hbMV07XG5cbiAgICAgICAgICAgIGlmICghZXhwZWN0ZWQuZnVuY3Rpb25TY29wZVt2YXJpYWJsZV0pIHtcbiAgICAgICAgICAgICAgdmFyaWFibGVzW3ZhcmlhYmxlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXl3b3Jkc1JlZ0V4cC50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgICBtYXRjaFsxXSA9IGBcIiR7IHZhcmlhYmxlIH1cImA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvQ29uY2F0ID0gYCR7IG1hdGNoWzFdIH06JHsgZ2V0VmFyaWFibGUodmFyaWFibGUsIGV4cGVjdGVkLmZ1bmN0aW9uU2NvcGUpIH0keyBtYXRjaFsyXSB9YDtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaFsyXSkge1xuICAgICAgICAgICAgICBleHBlY3RlZC5vcGVyYXRvciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGV4cGVjdGVkLm9iamVjdFByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleHBlY3RlZC5vcGVyYXRvcikge1xuICAgICAgICBpZiAoZmlyc3RTeW1ib2wgPT09ICcpJyB8fCBmaXJzdFN5bWJvbCA9PT0gJ10nIHx8IGZpcnN0U3ltYm9sID09PSAnfScgfHwgZmlyc3RTeW1ib2wgPT09ICcsJykge1xuICAgICAgICAgIHRvQ29uY2F0ID0gY2xvc2VGdW5jdGlvbkJvZHkoZXhwZWN0ZWQpO1xuXG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIHR5cGU6IHByb3BlclR5cGUsXG4gICAgICAgICAgICBzeW1ib2w6IHByb3BlclN5bWJvbFxuICAgICAgICAgIH0gPSBjbG9zaW5nRXhwcmVzc2lvbnNbY2xvc2luZ0V4cHJlc3Npb25zLmxlbmd0aCAtIDFdIHx8IHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdFN5bWJvbCA9PT0gJygnKSB7XG4gICAgICAgICAgbWF0Y2ggPSAnKCc7XG4gICAgICAgICAgZXhwZWN0ZWQuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICAgICAgY2xvc2luZ0V4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2NhbGwnLFxuICAgICAgICAgICAgc3ltYm9sOiAnKSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlbGV0ZSBleHBlY3RlZC5vcGVyYXRvcjtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFN5bWJvbCA9PT0gJz8nKSB7XG4gICAgICAgICAgbWF0Y2ggPSAnPyc7XG4gICAgICAgICAgZXhwZWN0ZWQuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICAgICAgY2xvc2luZ0V4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3Rlcm5hcnknLFxuICAgICAgICAgICAgc3ltYm9sOiAnOidcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnYW55JyxcbiAgICAgICAgICAgIHN5bWJvbDogRVhQUkVTU0lPTlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVsZXRlIGV4cGVjdGVkLm9wZXJhdG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0U3ltYm9sID09PSAnOicgJiYgcHJvcGVyU3ltYm9sID09PSAnOicpIHtcbiAgICAgICAgICBtYXRjaCA9ICc6JztcbiAgICAgICAgICBleHBlY3RlZC5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICBjbG9zaW5nRXhwcmVzc2lvbnMucG9wKCk7XG5cbiAgICAgICAgICBkZWxldGUgZXhwZWN0ZWQub3BlcmF0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RTeW1ib2wgPT09ICdbJykge1xuICAgICAgICAgIG1hdGNoID0gJ1snO1xuICAgICAgICAgIGV4cGVjdGVkLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdwcm9wZXJ0eScsXG4gICAgICAgICAgICBzeW1ib2w6ICddJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdhbnknLFxuICAgICAgICAgICAgc3ltYm9sOiBFWFBSRVNTSU9OXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWxldGUgZXhwZWN0ZWQub3BlcmF0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RTeW1ib2wgPT09ICd9JyAmJiBwcm9wZXJTeW1ib2wgPT09ICd9JyAmJiBwcm9wZXJUeXBlID09PSAndGVtcGxhdGVTdHJpbmcnKSB7XG4gICAgICAgICAgbWF0Y2ggPSBmaXJzdFN5bWJvbDtcbiAgICAgICAgICB0b0NvbmNhdCArPSAnKSc7XG4gICAgICAgICAgZXhwZWN0ZWQudGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wb3AoKTtcblxuICAgICAgICAgIGRlbGV0ZSBleHBlY3RlZC5vcGVyYXRvcjtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFN5bWJvbCA9PT0gJ10nICYmIHByb3BlclN5bWJvbCA9PT0gJ10nICYmIHByb3BlclR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICBtYXRjaCA9IGZpcnN0U3ltYm9sO1xuICAgICAgICAgIHRvQ29uY2F0ICs9IGZpcnN0U3ltYm9sO1xuICAgICAgICAgIG1hdGNoZWQgPSBFWFBSRVNTSU9OO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFN5bWJvbCA9PT0gJyknICYmIHByb3BlclN5bWJvbCA9PT0gJyknICYmIHByb3BlclR5cGUgPT09ICdwYXJlbicpIHtcbiAgICAgICAgICBtYXRjaCA9IGZpcnN0U3ltYm9sO1xuICAgICAgICAgIHRvQ29uY2F0ICs9IGZpcnN0U3ltYm9sO1xuICAgICAgICAgIG1hdGNoZWQgPSBFWFBSRVNTSU9OO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFN5bWJvbCA9PT0gJywnICYmIHByb3BlclN5bWJvbCA9PT0gJ30nICYmIHByb3BlclR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbWF0Y2ggPSBmaXJzdFN5bWJvbDtcbiAgICAgICAgICB0b0NvbmNhdCArPSBmaXJzdFN5bWJvbDtcbiAgICAgICAgICBtYXRjaGVkID0gRVhQUkVTU0lPTjtcbiAgICAgICAgICBleHBlY3RlZC5vYmplY3RQcm9wZXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICBkZWxldGUgZXhwZWN0ZWQub3BlcmF0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2gocG9pbnRPcGVyYXRvclJlZ0V4cCk7XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoZWQgPSBFWFBSRVNTSU9OO1xuXG4gICAgICAgICAgICBpZiAoa2V5d29yZHNSZWdFeHAudGVzdChtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgdG9Db25jYXQgKz0gYFtcIiR7IG1hdGNoWzFdIH1cIl1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChvcGVyYXRvclJlZ0V4cCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICB0b0NvbmNhdCArPSBtYXRjaFswXS5yZXBsYWNlKGFueUVtcHR5U3BhY2VSZWdFeHAsICcgJyk7XG4gICAgICAgICAgICAgIGV4cGVjdGVkLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgICBjbG9zaW5nRXhwcmVzc2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FueScsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBFWFBSRVNTSU9OXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGRlbGV0ZSBleHBlY3RlZC5vcGVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBpZiAoZmlyc3RTeW1ib2wgPT09ICcpJyB8fCBmaXJzdFN5bWJvbCA9PT0gJ10nIHx8IGZpcnN0U3ltYm9sID09PSAnfScpIHtcbiAgICAgICAgICB0b0NvbmNhdCArPSBjbG9zZUZ1bmN0aW9uQm9keShleHBlY3RlZCk7XG5cbiAgICAgICAgICAoe1xuICAgICAgICAgICAgdHlwZTogcHJvcGVyVHlwZSxcbiAgICAgICAgICAgIHN5bWJvbDogcHJvcGVyU3ltYm9sXG4gICAgICAgICAgfSA9IGNsb3NpbmdFeHByZXNzaW9uc1tjbG9zaW5nRXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0gfHwge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNsb3NpbmdCcmFjZTtcblxuICAgICAgICBpZiAocHJvcGVyU3ltYm9sID09PSAnKScgJiYgZmlyc3RTeW1ib2wgPT09ICcpJyAmJiBwcm9wZXJUeXBlID09PSAnY2FsbCcpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2UgPSB0cnVlO1xuXG4gICAgICAgICAgZGVsZXRlIGV4cGVjdGVkLmV4cHJlc3Npb247XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVyU3ltYm9sID09PSAnXScgJiYgZmlyc3RTeW1ib2wgPT09ICddJyAmJiBwcm9wZXJUeXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNlID0gdHJ1ZTtcblxuICAgICAgICAgIGRlbGV0ZSBleHBlY3RlZC5leHByZXNzaW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0U3ltYm9sID09PSAnfScgJiYgcHJvcGVyU3ltYm9sID09PSAnfScgJiYgcHJvcGVyVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2UgPSB0cnVlO1xuXG4gICAgICAgICAgZGVsZXRlIGV4cGVjdGVkLm9iamVjdFByb3BlcnR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb3NpbmdCcmFjZSkge1xuICAgICAgICAgIG1hdGNoID0gZmlyc3RTeW1ib2w7XG4gICAgICAgICAgdG9Db25jYXQgKz0gZmlyc3RTeW1ib2w7XG4gICAgICAgICAgZXhwZWN0ZWQub3BlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIG1hdGNoZWQgPSBFWFBSRVNTSU9OO1xuICAgICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG1hdGNoZWQgPT09IEVYUFJFU1NJT05cbiAgICAgICAgJiYgY2xvc2luZ0V4cHJlc3Npb25zLmxlbmd0aFxuICAgICAgICAmJiBjbG9zaW5nRXhwcmVzc2lvbnNbY2xvc2luZ0V4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnN5bWJvbCA9PT0gRVhQUkVTU0lPTlxuICAgICAgKSB7XG4gICAgICAgIGNsb3NpbmdFeHByZXNzaW9ucy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBub01hdGNoID0gIW1hdGNoIHx8ICFtYXRjaFswXTtcbiAgICBjb25zdCBjdXJseUluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ30nKTtcblxuICAgIGlmIChub01hdGNoICYmIChjdXJseUluZGV4ID4gMCB8fCBjdXJseUVycm9yKSkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvblN0cmluZyA9IGN1cmx5RXJyb3JcbiAgICAgICAgPyBpbml0aWFsU3RyaW5nXG4gICAgICAgIDogaW5pdGlhbFN0cmluZy5zbGljZSgwLCBpbml0aWFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggKyBjdXJseUluZGV4KTtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgU3ludGF4IGVycm9yIG5lYXIgfn5+IFwiJHsgaW5pdGlhbFN0cmluZy5zbGljZShpbmRleCwgaW5kZXggKyAxNSkgfVwiIH5+fiAoaW5kZXg6ICR7IGluZGV4IH0sICR7IGNvbnN0cnVjdEVycm9ySW5mbyhleHByZXNzaW9uU3RyaW5nLCB3aG9sZVN0cmluZywgY2xvc2luZ0V4cHJlc3Npb25zLCBjdXJseUVycm9yKSB9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG5vTWF0Y2ggJiYgY3VybHlJbmRleCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbiArPSB0b0NvbmNhdDtcblxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChub01hdGNoICYmIGN1cmx5SW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBtYXRjaCA9IHR5cGVvZiBtYXRjaCA9PT0gJ3N0cmluZycgPyBtYXRjaCA6IG1hdGNoWzBdO1xuXG4gICAgaWYgKCFpc0VtcHR5U3BhY2UpIHtcbiAgICAgIGV4cHJlc3Npb24gKz0gdG9Db25jYXQgfHwgbWF0Y2g7XG4gICAgfVxuXG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKG1hdGNoLmxlbmd0aCk7XG4gICAgaW5kZXggKz0gbWF0Y2gubGVuZ3RoO1xuICB9XG5cbiAgZXhwcmVzc2lvbiArPSBjbG9zZUZ1bmN0aW9uQm9keShleHBlY3RlZCk7XG5cbiAgaWYgKGNsb3NpbmdFeHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICBjb25zdCBleHByZXNzaW9uU3RyaW5nID0gaW5pdGlhbFN0cmluZy5zbGljZSgwLCBpbml0aWFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCAoJHsgY29uc3RydWN0RXJyb3JJbmZvKGV4cHJlc3Npb25TdHJpbmcsIHdob2xlU3RyaW5nLCBjbG9zaW5nRXhwcmVzc2lvbnMsIGN1cmx5RXJyb3IpIH1gKTtcbiAgfVxuXG4gIGlmICghc3RyaW5nLmxlbmd0aCAmJiAhY3VybHlFcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uLFxuICAgIHZhcmlhYmxlcyxcbiAgICBvcmlnaW5hbDogaW5pdGlhbFN0cmluZy5zbGljZSgwLCBpbmRleCksXG4gICAgcmVzdDogc3RyaW5nLnNsaWNlKDEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZhcmlhYmxlKG5hbWUsIGZ1bmN0aW9uU2NvcGUpIHtcbiAgaWYgKGZ1bmN0aW9uU2NvcGVbbmFtZV0pIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIHJldHVybiBrZXl3b3Jkc1JlZ0V4cC50ZXN0KG5hbWUpXG4gICAgPyBgJFtcIiR7IG5hbWUgfVwiXWBcbiAgICA6IGAkLiR7IG5hbWUgfWA7XG59XG5cbmZ1bmN0aW9uIGNsb3NlRnVuY3Rpb25Cb2R5KGV4cGVjdGVkKSB7XG4gIGNvbnN0IHsgY2xvc2luZ0V4cHJlc3Npb25zIH0gPSBleHBlY3RlZDtcbiAgbGV0IHRvQ29uY2F0ID0gJyc7XG5cbiAgd2hpbGUgKFxuICAgIGNsb3NpbmdFeHByZXNzaW9uc1tjbG9zaW5nRXhwcmVzc2lvbnMubGVuZ3RoIC0gMV1cbiAgICAmJiBjbG9zaW5nRXhwcmVzc2lvbnNbY2xvc2luZ0V4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnN5bWJvbCA9PT0gRU5EX09GX0ZVTkNfQk9EWVxuICApIHtcbiAgICB0b0NvbmNhdCArPSAnfSc7XG4gICAgZXhwZWN0ZWQuZnVuY3Rpb25TY29wZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHBlY3RlZC5mdW5jdGlvblNjb3BlKTtcbiAgICBjbG9zaW5nRXhwcmVzc2lvbnMucG9wKCk7XG5cbiAgICBpZiAoXG4gICAgICBjbG9zaW5nRXhwcmVzc2lvbnMubGVuZ3RoXG4gICAgICAmJiBjbG9zaW5nRXhwcmVzc2lvbnNbY2xvc2luZ0V4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnN5bWJvbCA9PT0gRVhQUkVTU0lPTlxuICAgICkge1xuICAgICAgY2xvc2luZ0V4cHJlc3Npb25zLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b0NvbmNhdDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0RXJyb3JJbmZvKGV4cHJlc3Npb25TdHJpbmcsIHdob2xlU3RyaW5nLCBjbG9zaW5nRXhwcmVzc2lvbnMsIGN1cmx5RXJyb3IpIHtcbiAgbGV0IHsgc3ltYm9sOiBsYXN0IH0gPSBjbG9zaW5nRXhwcmVzc2lvbnNbY2xvc2luZ0V4cHJlc3Npb25zLmxlbmd0aCAtIDFdIHx8IHt9O1xuICBsZXQgd2hvbGVTdHJpbmdTdHJpbmcgPSAnJztcblxuICBpZiAobGFzdCAmJiBsYXN0ICE9PSBFWFBSRVNTSU9OICYmIGxhc3QgIT09IEVORF9PRl9GVU5DX0JPRFkpIHtcbiAgICBsYXN0ID0gYFwiJHsgbGFzdCB9XCJgO1xuICB9XG5cbiAgaWYgKCFjdXJseUVycm9yKSB7XG4gICAgd2hvbGVTdHJpbmdTdHJpbmcgPSBgLCB3aG9sZSBzdHJpbmc6IFwiJHsgd2hvbGVTdHJpbmcgfVwiYDtcbiAgfVxuXG4gIGNvbnN0IGxhc3RTdHJpbmcgPSBsYXN0XG4gICAgPyBgZXhwZWN0ZWQgJHsgbGFzdCB9LCBgXG4gICAgOiAnJztcblxuICByZXR1cm4gYCR7IGxhc3RTdHJpbmcgfWluaXRpYWwgZXhwcmVzc2lvbjogXCIkeyBleHByZXNzaW9uU3RyaW5nIH1cIiR7IHdob2xlU3RyaW5nU3RyaW5nIH0pLiAkeyBzdWJtaXRTdHJpbmcgfWA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlSlM7XG4iLCIvKipcbiAqIEBtb2R1bGUgQmxvY2tcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEJsb2NrIGNsYXNzLlxuICovXG5cbmltcG9ydCB7IEFyciB9IGZyb20gJy4vQXJyJztcbmltcG9ydCB7IGRvYywgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuL1N0cic7XG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xuaW1wb3J0IHtcbiAgZGVmaW5lVXN1YWxQcm9wZXJ0aWVzLCBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzLFxuICBhc3NpZ24sIGNvbnN0cnVjdEV2YWxGdW5jdGlvbiwgaXRlcmF0ZSwgdmFsaWRhdGUsXG4gIGlzRnVuY3Rpb24sIGlzTmlsLCBpc1N0cmluZ1xufSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0ICogYXMgQmxvY2tzIGZyb20gJy4vYmxvY2tzJztcbmltcG9ydCAqIGFzIE1peGlucyBmcm9tICcuL21peGlucyc7XG5pbXBvcnQgeyBodG1sQWxsb3dlZFRhZ1N5bWJvbHMsIGh0bWxBbGxvd2VkQXR0clN5bWJvbHMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgbWFya3VwVG9KU09OIGZyb20gJy4vaGVscGVycy9tYXJrdXBUb0pTT04nO1xuaW1wb3J0IHBhcnNlSlMgZnJvbSAnLi9oZWxwZXJzL3BhcnNlSlMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFcnJvcn0gRXZhbHVhdGlvbkVycm9yXG4gKiBAcHVibGljXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZXhwcmVzc2lvbiAtIEV4cHJlc3Npb24gd2hpY2ggaGFzIGJlZW4gZXZhbHVhdGVkIHdpdGggdGhlIGVycm9yLlxuICogQHByb3BlcnR5IHtCbG9ja30gYmxvY2sgLSBCbG9jayBpbiBjb250ZXh0IG9mIHdoaWNoIHRoZSBleHByZXNzaW9uIGhhcyBiZWVuIGV2YWx1YXRlZCB3aXRoIHRoZSBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYXRjaGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gTmV3IHZhbHVlLlxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSAtIE9sZCB2YWx1ZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBWYXJzV2F0Y2hlclxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdyYXBwZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QmxvY2t9IEJsb2NrIGNsYXNzIHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7QmxvY2t9IE5ldyBCbG9jayBjbGFzcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBZnRlclVwZGF0ZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG1peGluIC0gTWl4aW4gaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQmxvY2tSZWdpc3Rlckhvb2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QmxvY2t9IEJsb2NrIC0gUmVnaXN0ZXJpbmcgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG5hbWUuXG4gKiBAcmV0dXJucyBSZXR1cm4gdmFsdWUgaXMgdXNlZCBmb3IgcmVnaXN0ZXJpbmcgdGhlIGJsb2NrLlxuICogSWYgQmxvY2sgc3ViY2xhc3MgcmV0dXJuZWQgaXQncyByZWdpc3RlcmVkIGluc3RlYWQgb2YgdGhlIGluaXRpYWwgYmxvY2ssIG90aGVyd2lzZVxuICogdGhlIGluaXRpYWwgYmxvY2sgaXMgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBNaXhpblJlZ2lzdGVySG9va1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtCbG9ja30gTWl4aW4gLSBSZWdpc3RlcmluZyBtaXhpbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTWl4aW4gbmFtZS5cbiAqIEByZXR1cm5zIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciByZWdpc3RlcmluZyB0aGUgbWl4aW4uXG4gKiBJZiBNaXhpbiBzdWJjbGFzcyByZXR1cm5lZCBpdCdzIHJlZ2lzdGVyZWQgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCBtaXhpbiwgb3RoZXJ3aXNlXG4gKiB0aGUgaW5pdGlhbCBtaXhpbiBpcyB1c2VkLlxuICovXG5cbmNvbnN0IHJvb3RCbG9ja3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgcm9vdE1peGlucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB7XG4gIGlzUHJvdG90eXBlT2YsXG4gIGhhc093blByb3BlcnR5XG59ID0ge307XG5jb25zdCB0YWdOYW1lID0gbmV3IFJlZ0V4cChgXiR7IGh0bWxBbGxvd2VkVGFnU3ltYm9scyB9JGAsICdpJyk7XG5jb25zdCBhdHRyTmFtZSA9IG5ldyBSZWdFeHAoYF4keyBodG1sQWxsb3dlZEF0dHJTeW1ib2xzIH0kYCk7XG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBjdXJseUJyYWNrZXRSZWdFeHAgPSAvXFx7LztcbmNvbnN0IGRSZXN0UmVnRXhwID0gL15kLXJlc3QoPzojfCQpLztcbmNvbnN0IGFmdGVyRWxlbSA9IG5ldyBFbGVtKCk7XG5sZXQgZXZhbE1vZGU7XG5sZXQgZ2V0dGluZztcbmxldCBjaGFuZ2VkO1xuXG4vKipcbiAqIEBjbGFzcyBCbG9ja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBFbGVtZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7QmxvY2t9IEluc3RhbmNlIG9mIEJsb2NrLlxuICogQGRlc2NyaXB0aW9uIENsYXNzIGZvciBkeW5hbWljIHRlbXBsYXRpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEQsIEJsb2NrLCBpbml0QXBwIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiBjbGFzcyBBcHAgZXh0ZW5kcyBCbG9jayB7XG4gKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8SGVsbG8gdGV4dD1cInt0ZXh0fVwiLz4nO1xuICpcbiAqICAgY29uc3RydWN0b3Iob3B0cykge1xuICogICAgIHN1cGVyKG9wdHMpO1xuICpcbiAqICAgICB0aGlzLnRleHQgPSAnd29ybGQgKDApJztcbiAqICAgICB0aGlzLnRpbWVzID0gMDtcbiAqXG4gKiAgICAgdGhpcy5zZXRJbnRlcnZhbCgpO1xuICogICB9XG4gKlxuICogICBzZXRJbnRlcnZhbCgpIHtcbiAqICAgICBEKDEwMDApLmludGVydmFsKCgpID0+IHtcbiAqICAgICAgIHRoaXMudGV4dCA9IGB3b3JsZCAoJHsgKyt0aGlzLnRpbWVzIH0pYDtcbiAqICAgICB9KTtcbiAqICAgfVxuICogfVxuICpcbiAqIEJsb2NrLmJsb2NrKCdBcHAnLCBBcHApO1xuICogQmxvY2suYmxvY2soJ0hlbGxvJywgJ0hlbGxvLCB7YXJncy50ZXh0fSEnKTtcbiAqXG4gKiBpbml0QXBwKCdBcHAnLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpKTtcbiAqL1xuY2xhc3MgQmxvY2sge1xuICBzdGF0aWMgX2Jsb2NrcyA9IE9iamVjdC5jcmVhdGUocm9vdEJsb2Nrcyk7XG4gIHN0YXRpYyBfbWl4aW5zID0gT2JqZWN0LmNyZWF0ZShyb290TWl4aW5zKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gW0Jsb2NrLmNvbGxhcHNlV2hpdGVTcGFjZSA9IHRydWVdXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJZiB0aGUgd2hpdGVzcGFjZSBiZXR3ZWVuIGh0bWwgZWxlbWVudHMgYW5kXG4gICAqIGluIHRoZSBzdGFydCBhbmQgdGhlIGVuZCBpbnNpZGUgdGhlIHRhZyBzaG91bGQgYmUgb21pdHRlZCBkdXJpbmcgcGFyc2luZy5cbiAgICovXG4gIHN0YXRpYyBjb2xsYXBzZVdoaXRlU3BhY2UgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay5kZWZhdWx0QXJncyA9IG51bGxdXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIGRlZmF1bHQgYXJncy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0QXJncyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLmRlZmF1bHRMb2NhbHMgPSBudWxsXVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkZWZhdWx0IGxvY2Fscy5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0TG9jYWxzID0gbnVsbDtcblxuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBbQmxvY2sudGVtcGxhdGUgPSAnJ11cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgdGVtcGxhdGUuXG4gICAqL1xuICBzdGF0aWMgdGVtcGxhdGUgPSAnJztcblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5vbkV2YWxFcnJvclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RXZhbHVhdGlvbkVycm9yfSBlcnIgLSBUaGUgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGFuIGV2YWx1YXRpb24gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgc3RhdGljIG9uRXZhbEVycm9yKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEV2YWwgZXJyb3IgKGV2YWx1YXRpbmcgXCIkeyBlcnIuZXhwcmVzc2lvbiB9XCIgaW4gY29udGV4dCBvZiBibG9jayBcIiR7IGVyci5ibG9jay4kJC5uYW1lIH1cIik6YCwgZXJyKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRCbG9ja3MoKSB7XG4gICAgcmV0dXJuIG5ldyBTdXBlcih7IC4uLnRoaXMuX2Jsb2NrcyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNaXhpbnMoKSB7XG4gICAgcmV0dXJuIG5ldyBTdXBlcih7IC4uLnRoaXMuX21peGlucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmJlZm9yZVJlZ2lzdGVyQmxvY2tcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Jsb2NrUmVnaXN0ZXJIb29rfSBob29rIC0gQmxvY2sgcmVnaXN0ZXIgaG9vay5cbiAgICovXG4gIHN0YXRpYyBiZWZvcmVSZWdpc3RlckJsb2NrKGhvb2spIHtcbiAgICBpZiAoIW5ldyBTdXBlcih0aGlzKS5oYXNPd24oJ19ibG9ja0hvb2tzJykpIHtcbiAgICAgIHRoaXMuX2Jsb2NrSG9va3MgPSBuZXcgQXJyKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ibG9ja0hvb2tzLnB1c2goaG9vayk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5iZWZvcmVSZWdpc3Rlck1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtNaXhpblJlZ2lzdGVySG9va30gaG9vayAtIE1peGluIHJlZ2lzdGVyIGhvb2suXG4gICAqL1xuICBzdGF0aWMgYmVmb3JlUmVnaXN0ZXJNaXhpbihob29rKSB7XG4gICAgaWYgKCFuZXcgU3VwZXIodGhpcykuaGFzT3duKCdfbWl4aW5Ib29rcycpKSB7XG4gICAgICB0aGlzLl9taXhpbkhvb2tzID0gbmV3IEFycihbXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWl4aW5Ib29rcy5wdXNoKGhvb2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmxvY2tcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG9yIG1peGluIG5hbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEJsb2NrfSBTdWJjbGFzcyAtIFN1YmNsYXNzIG9mIEJsb2NrIG9yIHRlbXBsYXRlIHN0cmluZyBvZiBpdC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBibG9jayBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgYmxvY2sobmFtZSwgU3ViY2xhc3MpIHtcbiAgICBjb25zdCBfdGhpcyA9IG5ldyBTdXBlcih0aGlzKTtcblxuICAgIGlmIChpc1N0cmluZyhTdWJjbGFzcykpIHtcbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IFN1YmNsYXNzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgIWlzSW5zdGFuY2VPZihCbG9jaywgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IFN1YmNsYXNzO1xuXG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgICAgICBjb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbihTdWJjbGFzcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQmxvY2sgbXVzdCBiZSBhIHN0cmluZyAocmVwcmVzZW50aW5nIGEgYmxvY2sgdGVtcGxhdGUpLCBhIGZ1bmN0aW9uIG9yIGEgY2xhc3MgdGhhdCBleHRlbmRzIEJsb2NrIGNsYXNzIChuYW1lOiBcIiR7IG5hbWUgfVwiKSAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzSW5zdGFuY2VPZihCbG9jaywgU3ViY2xhc3MpKSB7XG4gICAgICBleHRlbmRCbG9jayhTdWJjbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHJvb3RCbG9ja3NbbmFtZV0pIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgYmxvY2sgaXMgYSBidWlsdC1pbiBibG9jayBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRhZ05hbWUudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIGJsb2NrcyBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLmhhc093bignX2Jsb2NrcycpKSB7XG4gICAgICB0aGlzLl9ibG9ja3MgPSBPYmplY3QuY3JlYXRlKF90aGlzLnByb3RvKCkuJC5fYmxvY2tzKTtcbiAgICB9XG5cbiAgICBsZXQgcmV0dXJuVmFsdWU7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSAodGhpcy5fYmxvY2tIb29rcyB8fCBuZXcgQXJyKFtdKSkucmVkdWNlKChTdWJjbGFzcywgaG9vaykgPT4ge1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGhvb2soU3ViY2xhc3MsIG5hbWUpO1xuXG4gICAgICAgIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIHJldHVyblZhbHVlKVxuICAgICAgICAgID8gcmV0dXJuVmFsdWVcbiAgICAgICAgICA6IFN1YmNsYXNzO1xuICAgICAgfSwgU3ViY2xhc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgdGhpcy5fbmFtZSB9IFwiYmVmb3JlUmVnaXN0ZXJCbG9ja1wiIGhvb2s6YCwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNJbnN0YW5jZU9mKEJsb2NrLCByZXR1cm5WYWx1ZSkpIHtcbiAgICAgIFN1YmNsYXNzID0gcmV0dXJuVmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFyaWFibGVzID0ge307XG5cbiAgICBTdWJjbGFzcy5fbmFtZSA9IG5hbWU7XG4gICAgU3ViY2xhc3MuX2h0bWwgPSB0cmFuc2Zvcm1ESWZDaGlsZHJlbihcbiAgICAgIHRyYW5zZm9ybUpTRXhwcmVzc2lvbnMoXG4gICAgICAgIG1hcmt1cFRvSlNPTihcbiAgICAgICAgICBgJHsgU3ViY2xhc3MudGVtcGxhdGUgfHwgJycgfWAsXG4gICAgICAgICAgU3ViY2xhc3MuY29sbGFwc2VXaGl0ZVNwYWNlXG4gICAgICAgICksXG4gICAgICAgIHZhcmlhYmxlc1xuICAgICAgKVxuICAgICk7XG4gICAgU3ViY2xhc3MuX3ZhcmlhYmxlcyA9IG5ldyBTdXBlcih2YXJpYWJsZXMpXG4gICAgICAuZXhjZXB0KCckJCcsICckJylcbiAgICAgIC5rZXlzKCk7XG5cbiAgICBpZiAobmV3IFN1cGVyKFN1YmNsYXNzKS5oYXNPd24oJ2RlZmF1bHRBcmdzJykpIHtcbiAgICAgIG5ldyBTdXBlcihTdWJjbGFzcy5kZWZhdWx0QXJncykucHJvdG8obnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmxvY2tzW25hbWVdID0gU3ViY2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5taXhpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgb3IgbWl4aW4gbmFtZS5cbiAgICogQHBhcmFtIHtNaXhpbnxBZnRlclVwZGF0ZX0gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBNaXhpbiBvciBBZnRlclVwZGF0ZSBjYWxsYmFjay5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBtaXhpbiBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgbWl4aW4obmFtZSwgU3ViY2xhc3MpIHtcbiAgICBjb25zdCBfdGhpcyA9IG5ldyBTdXBlcih0aGlzKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiAhaXNJbnN0YW5jZU9mKE1peGluLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnN0IGFmdGVyVXBkYXRlID0gU3ViY2xhc3M7XG5cbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBNaXhpbiB7XG4gICAgICAgIGFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgIGFmdGVyVXBkYXRlLmNhbGwodGhpcywgbmV3VmFsdWUsIG9sZFZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSW5zdGFuY2VPZihNaXhpbiwgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIGNsYXNzIGRvZXMgbm90IGV4dGVuZCBNaXhpbiBhbmQgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocm9vdE1peGluc1tuYW1lXSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBtaXhpbiBpcyBhIGJ1aWx0LWluIG1peGluIHNvIHRoZSBtaXhpbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghYXR0ck5hbWUudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIG1peGlucyBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLmhhc093bignX21peGlucycpKSB7XG4gICAgICB0aGlzLl9taXhpbnMgPSBPYmplY3QuY3JlYXRlKF90aGlzLnByb3RvKCkuJC5fbWl4aW5zKTtcbiAgICB9XG5cbiAgICBsZXQgcmV0dXJuVmFsdWU7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSAodGhpcy5fbWl4aW5Ib29rcyB8fCBuZXcgQXJyKFtdKSkucmVkdWNlKChTdWJjbGFzcywgaG9vaykgPT4ge1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGhvb2soU3ViY2xhc3MsIG5hbWUpO1xuXG4gICAgICAgIHJldHVybiBpc0luc3RhbmNlT2YoTWl4aW4sIHJldHVyblZhbHVlKVxuICAgICAgICAgID8gcmV0dXJuVmFsdWVcbiAgICAgICAgICA6IFN1YmNsYXNzO1xuICAgICAgfSwgU3ViY2xhc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgdGhpcy5fbmFtZSB9IFwiYmVmb3JlUmVnaXN0ZXJNaXhpblwiIGhvb2s6YCwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNJbnN0YW5jZU9mKE1peGluLCByZXR1cm5WYWx1ZSkpIHtcbiAgICAgIFN1YmNsYXNzID0gcmV0dXJuVmFsdWU7XG4gICAgfVxuXG4gICAgU3ViY2xhc3MuX25hbWUgPSBuYW1lO1xuICAgIFN1YmNsYXNzLl9tYXRjaCA9IGNvbnN0cnVjdE1peGluUmVnRXhwKG5hbWUpO1xuXG4gICAgdGhpcy5fbWl4aW5zW25hbWVdID0gU3ViY2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIGJsb2NrLlxuICAgKiBAcmV0dXJucyB7QmxvY2t9IE5ldyBibG9jay5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd3JhcHBpbmcgYmxvY2tzIGludG8gYW5vdGhlciBibG9ja3MuXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBibG9jayB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2xhc3MgTXlCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdj4xMjM8L2Rpdj4nO1xuICAgKiB9XG4gICAqXG4gICAqIE15QmxvY2sud3JhcCgoQmxvY2spID0+IHtcbiAgICogICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAqICAgICBzdGF0aWMgdGVtcGxhdGUgPSBgPHNlY3Rpb24gY2xhc3M9XCJ3cmFwcGVyXCI+JHsgQmxvY2sudGVtcGxhdGUgfTwvc2VjdGlvbj5gO1xuICAgKlxuICAgKiAgICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgKiAgICAgICBzdXBlcihvcHRzKTtcbiAgICpcbiAgICogICAgICAgdGhpcy5hZGRpdGlvbmFsVmFyID0gJ2FkZGl0aW9uYWwnO1xuICAgKiAgICAgfVxuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFycihhcmd1bWVudHMpLnJlZHVjZSgoYmxvY2ssIHdyYXBwZXIpID0+IHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gd3JhcHBlcihibG9jayk7XG5cbiAgICAgIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIHJldHVyblZhbHVlKVxuICAgICAgICA/IHJldHVyblZhbHVlXG4gICAgICAgIDogYmxvY2s7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGFyZ3M6IG9yaWdpbmFsQXJncyxcbiAgICAgIGRCbG9ja05hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBwcmV2QmxvY2tcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCB3YXRjaGVyc1RvUmVtb3ZlID0gbmV3IEFycihbXSk7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBuZXcgU3VwZXIodGhpcykucHJvdG8oKS4kLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNoaWxkcmVuQmxvY2tzID0gbmV3IEFycihbXSk7XG4gICAgY29uc3QgbWl4aW5zID0gbmV3IEFycihbXSk7XG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0Jsb2NrfSBCbG9jayMkXG4gICAgICAgKiBAdHlwZSB7QmxvY2t9XG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKiBAZGVzY3JpcHRpb24gVGhpcy5cbiAgICAgICAqL1xuICAgICAgJDogdGhpcyxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrIyQkXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFyZ3MgLSBQcml2YXRlIGFyZ3Mgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge0Fycn0gYXJnc0NoaWxkcmVuIC0gQmxvY2sgYXJncyBjaGlsZHJlbi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QXJyfSBjaGlsZHJlbiAtIENoaWxkIGJsb2Nrcy5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QXJyfSBtaXhpbnMgLSBDaGlsZCBtaXhpbnMuXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IHBhcmVudEVsZW0gLSBQYXJlbnQgZWxlbWVudC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gY29udGVudCAtIENvbnRlbnQgZWxlbWVudHMuXG4gICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBldmFsdWF0ZSAtIEV2YWx1YXRlIGZ1bmN0aW9uLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGdsb2JhbHMgLSBQcml2YXRlIGdsb2JhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gbG9jYWxzIC0gUHJpdmF0ZSBsb2NhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge0Fycn0gd2F0Y2hlcnNUb1JlbW92ZSAtIFdhdGNoZXJzIHRvIHJlbW92ZSBiZWZvcmUgcmVtb3ZpbmcgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrczogbmV3IEFycihbXSksXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgY29udGVudDogbmV3IEVsZW0oKSxcbiAgICAgICAgbnM6IGNvbnN0cnVjdG9yLFxuICAgICAgICBhcmdzQ2hpbGRyZW46IGNoaWxkcmVuIHx8IG5ldyBBcnIoW10pLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5CbG9ja3MsXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgcHJldkJsb2NrLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBldmFsdWF0ZTogKGZ1bmMsIG9uQ2hhbmdlLCBpbnN0YW5jZSwgZm9yREVsZW1lbnRzLCBmb3JESXRlbSwgZm9yREVhY2gpID0+IHtcbiAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvckRFbGVtZW50cyA9ICEhZm9yREVsZW1lbnRzO1xuICAgICAgICAgIGZvckRJdGVtID0gISFmb3JESXRlbTtcblxuICAgICAgICAgIGNvbnN0IHNjb3BlID0gKG5hbWUgPT09ICcjZC1pdGVtJyAmJiAhZm9yREl0ZW0pIHx8IGZvckRFYWNoXG4gICAgICAgICAgICA/IChmb3JERWFjaCB8fCB0aGlzKS4kJC5zY29wZVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgd2F0Y2hlcnNUb1JlbW92ZSB9ID0gaW5zdGFuY2UgPyBpbnN0YW5jZS4kJCA6IHt9O1xuXG4gICAgICAgICAgLyogZXNsaW50IG5vLW5ldy1mdW5jOiAwICovXG4gICAgICAgICAgY29uc3QgZXZhbHVhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgZXZhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBnZXR0aW5nID0gbmV3IEFycihbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoc2NvcGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyci5leHByZXNzaW9uID0gZnVuYy5leHByZXNzaW9uO1xuICAgICAgICAgICAgICBlcnIub3JpZ2luYWwgPSBmdW5jLm9yaWdpbmFsO1xuICAgICAgICAgICAgICBlcnIuYmxvY2sgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2F0Y2hlcnMgPSBuZXcgQXJyKFtdKTtcblxuICAgICAgICAgICAgICBnZXR0aW5nLmZvckVhY2goKHdhdGNoZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc3VsdCA9IGV2YWx1YXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHQgIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdSZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICBmb3JERWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5vblJlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsV2F0Y2hlcnMuZm9yRWFjaCgod2F0Y2hlckJsb2NrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXJzXG4gICAgICAgICAgICAgICAgICAgIH0gPSB3YXRjaGVyQmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4MSA9IHdhdGNoZXJzVG9SZW1vdmUuaW5kZXhPZih3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleDIgPSB3YXRjaGVycy5pbmRleE9mKHdhdGNoZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleDEgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZS5zcGxpY2UoaW5kZXgxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnMuc3BsaWNlKGluZGV4MiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsb2NhbFdhdGNoZXJzLnB1c2god2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLnB1c2god2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBldmFsTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBnZXR0aW5nID0gbmV3IEFycihbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChpc1BhcmVudFNpZ25hbCkgPT4ge1xuICAgICAgICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xuXG4gICAgICAgICAgY2hpbGRyZW5CbG9ja3MuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGNoaWxkLiQkLnJlbW92ZSh0cnVlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xuICAgICAgICAgICAgbWl4aW4uJCQucmVtb3ZlKHRydWUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlUmVtb3ZlOmAsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1BhcmVudFNpZ25hbCAmJiBpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudCh0aGlzLiQkLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgcGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50QmxvY2suJCQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY29udGVudC5yZW1vdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29udGVudDogKGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiQkLmNvbnRlbnQuaW5kZXhPZihjb250ZW50VG9BZGQuJFswXS5wcmV2aW91c1NpYmxpbmcpICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy4kJC5jb250ZW50ID0gY29udGVudFRvQWRkXG4gICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgIC5wdXNoQXJyYXkodGhpcy4kJC5jb250ZW50LiQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAucHVzaEFycmF5KGNvbnRlbnRUb0FkZC4kKVxuICAgICAgICAgICAgICAucHVzaEFycmF5KHRoaXMuJCQuY29udGVudC5zbGljZShpbmRleCkuJCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgIW5vdFJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvQWRkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVDb250ZW50OiAoY29udGVudFRvTW92ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuJCQuY29udGVudC5pbmRleE9mKGNvbnRlbnRUb01vdmUuJFswXSk7XG4gICAgICAgICAgY29uc3QgaW5kZXhUb1B1dCA9IHRoaXMuJCQuY29udGVudC5pbmRleE9mKGFmdGVyLiRbMF0pICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleFRvUHV0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSBjb250ZW50VG9Nb3ZlXG4gICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgIC5wdXNoQXJyYXkodGhpcy4kJC5jb250ZW50LnNsaWNlKGluZGV4VG9QdXQsIGluZGV4KS4kKVxuICAgICAgICAgICAgICAucHVzaEFycmF5KHRoaXMuJCQuY29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoKS4kKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgdGhpcy4kJC5jb250ZW50ID0gdGhpcy4kJC5jb250ZW50XG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleFRvUHV0KVxuICAgICAgICAgICAgICAucHVzaEFycmF5KGNvbnRlbnRUb01vdmUuJClcbiAgICAgICAgICAgICAgLnB1c2hBcnJheSh0aGlzLiQkLmNvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLiQpXG4gICAgICAgICAgICAgIC5wdXNoQXJyYXkodGhpcy4kJC5jb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgpLiQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAucHVzaEFycmF5KHRoaXMuJCQuY29udGVudC5zbGljZShpbmRleCArIGNvbnRlbnRUb01vdmUubGVuZ3RoLCBpbmRleFRvUHV0KS4kKVxuICAgICAgICAgICAgICAucHVzaEFycmF5KGNvbnRlbnRUb01vdmUuJClcbiAgICAgICAgICAgICAgLnB1c2hBcnJheSh0aGlzLiQkLmNvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCkuJCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb01vdmUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNvbnRlbnQ6IChjb250ZW50VG9SZW1vdmUpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQuZmlsdGVyKChlbGVtKSA9PiAoXG4gICAgICAgICAgICBjb250ZW50VG9SZW1vdmUuaW5kZXhPZihlbGVtKSA9PT0gLTFcbiAgICAgICAgICApKTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50VG9SZW1vdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0SW5TdGFydE9mSXQ6IChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QmxvY2sgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgbGV0IGFmdGVyID0gYWZ0ZXJFbGVtO1xuXG4gICAgICAgICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSBwYXJlbnQuJCQ7XG5cbiAgICAgICAgICAgIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgICAgbGV0IG5vdFJlY3Vyc2l2ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2s7XG4gICAgICAgICAgICAgICAgbm90UmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBub3RSZWN1cnNpdmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudC4kJC5pbnNlcnRJblN0YXJ0T2ZJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgdGhpcy4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRBZnRlckl0OiAoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJldkJsb2NrIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGxldCBhZnRlciA9IGFmdGVyRWxlbTtcbiAgICAgICAgICBsZXQgdHJ5VG9BZGRPck1vdmU7XG5cbiAgICAgICAgICBpZiAodGhpcy4kJC5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLiQkLmNvbnRlbnQubGFzdCgpO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIHRyeVRvQWRkT3JNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiB0cnlUb0FkZE9yTW92ZSkge1xuICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdGVyYXRlKGNvbnN0cnVjdG9yLmRlZmF1bHRMb2NhbHMsICh2YWx1ZSwgdmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3RydWN0b3IuX3ZhcmlhYmxlcy5mb3JFYWNoKCh2YXJpYWJsZSkgPT4ge1xuICAgICAgdGhpc1t2YXJpYWJsZV0gPSB0aGlzW3ZhcmlhYmxlXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0ICRhcmdzT2JqZWN0ID0gbmV3IFN1cGVyKGFyZ3NPYmplY3QpO1xuICAgIGxldCBhcmdzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5kZWZhdWx0QXJncyB8fCBudWxsKTtcbiAgICBsZXQgd2FzRFJlc3Q7XG5cbiAgICBuZXcgU3VwZXIob3JpZ2luYWxBcmdzKS5mb3JFYWNoKCh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgICBjb25zdCBpc0RSZXN0ID0gZFJlc3RSZWdFeHAudGVzdChhcmcpO1xuICAgICAgY29uc3QgbG9jYWxBcmdzID0gaXNEUmVzdCB8fCB3YXNEUmVzdFxuICAgICAgICA/IE9iamVjdC5jcmVhdGUoYXJncylcbiAgICAgICAgOiBhcmdzO1xuXG4gICAgICBhcmdzID0gbG9jYWxBcmdzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXJncyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBpdGVyYXRlKGxvY2FsQXJncywgKHZhbHVlLCBhcmcpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbEFyZ3NbYXJnXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZpbmVVc3VhbFByb3BlcnRpZXMobG9jYWxBcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyh2YWx1ZSkpO1xuICAgICAgICAgIGNhbGN1bGF0ZUFyZ3MoYXJncywgYXJnc09iamVjdCwgJGFyZ3NPYmplY3QpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB3YXNEUmVzdCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGRlZmluZVVzdWFsUHJvcGVydGllcyhsb2NhbEFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHJlc3RBcmdzKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzREVsZW1lbnRzID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnO1xuICAgICAgY29uc3QgZm9yREVsZW1lbnRzID0gaXNERWxlbWVudHMgJiYgYXJnID09PSAndmFsdWUnO1xuXG4gICAgICB3YXNEUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtZWFjaCcgfHwgYXJnICE9PSAndWlkJykge1xuICAgICAgICB2YWx1ZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBsb2NhbEFyZ3NbYXJnXSA9IHZhbHVlO1xuICAgICAgICAgIGNhbGN1bGF0ZUFyZ3MoYXJncywgYXJnc09iamVjdCwgJGFyZ3NPYmplY3QpO1xuICAgICAgICB9LCB0aGlzLCBmb3JERWxlbWVudHMsIGlzREVsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLm5hbWUgPT09ICcjZC1pdGVtJyk7XG4gICAgICB9XG5cbiAgICAgIGRlZmluZVVzdWFsUHJvcGVydGllcyhsb2NhbEFyZ3MsIHtcbiAgICAgICAgW2FyZ106IHZhbHVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrI2FyZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGFyZ3M6IGFyZ3NPYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNnbG9iYWxzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBnbG9iYWxzOiBPYmplY3QuY3JlYXRlKFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgICAgID8gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS5nbG9iYWxzKVxuICAgICAgICAgIDogbnVsbFxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtCbG9ja3x1bmRlZmluZWR9IEJsb2NrI3BhcmVudFNjb3BlXG4gICAgICAgKiBAdHlwZSB7QmxvY2t8dW5kZWZpbmVkfVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBwYXJlbnRTY29wZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtCbG9ja3x1bmRlZmluZWR9IEJsb2NrI3BhcmVudFRlbXBsYXRlXG4gICAgICAgKiBAdHlwZSB7QmxvY2t8dW5kZWZpbmVkfVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0pO1xuXG4gICAgY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0LCAkYXJnc09iamVjdCk7XG5cbiAgICBpZiAocGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3RcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGNvbnN0cnVjdGlvbiAoaW5jbHVkaW5nIGFsbCBzY29wZXMpXG4gICAqIGJ1dCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBibG9jayBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyUmVuZGVyXG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICovXG4gIGFmdGVyUmVuZGVyKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlclJlbmRlclxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYmVmb3JlIHRoZSBibG9jayByZW1vdmFsLlxuICAgKi9cbiAgYmVmb3JlUmVtb3ZlKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNjaGFuZ2VMb2NhbHNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIC0gT2JqZWN0IHRvIGFzc2lnbiB0byB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBzaW1wbGUgYXNzaWduaW5nIHNvbWUgbG9jYWxzIHRvIHRoaXMuXG4gICAqL1xuICBjaGFuZ2VMb2NhbHMobG9jYWxzKSB7XG4gICAgYXNzaWduKHRoaXMsIGxvY2Fscyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNldmFsdWF0ZUFuZFdhdGNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gLSBFeHByZXNzaW9uIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgaXMgY2hhbmdlZC5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gaW4gY29udGV4dCBvZiB0aGUgYmxvY2sgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlQW5kV2F0Y2goZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcbiAgICB2YWxpZGF0ZShbZXhwcmVzc2lvbl0sIFsnc3RyaW5nJ10sICdCbG9jayNldmFsdWF0ZUFuZFdhdGNoJyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBleHByZXNzaW9uOiBjb2RlLFxuICAgICAgb3JpZ2luYWxcbiAgICB9ID0gcGFyc2VKUyhleHByZXNzaW9uLCBleHByZXNzaW9uLCB0cnVlKTtcblxuICAgIGNvbnN0IGZ1bmMgPSBjb25zdHJ1Y3RFdmFsRnVuY3Rpb24oY29kZSwgb3JpZ2luYWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVPbmNlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gLSBFeHByZXNzaW9uIHRvIGV2YWx1YXRlLlxuICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGlvbiByZXN1bHQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiBpbiBjb250ZXh0IG9mIHRoZSBibG9jayBvbmNlLlxuICAgKi9cbiAgZXZhbHVhdGVPbmNlKGV4cHJlc3Npb24pIHtcbiAgICB2YWxpZGF0ZShbZXhwcmVzc2lvbl0sIFsnc3RyaW5nJ10sICdCbG9jayNldmFsdWF0ZU9uY2UnKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGV4cHJlc3Npb246IGNvZGUsXG4gICAgICBvcmlnaW5hbFxuICAgIH0gPSBwYXJzZUpTKGV4cHJlc3Npb24sIGV4cHJlc3Npb24sIHRydWUpO1xuXG4gICAgY29uc3QgZnVuYyA9IGNvbnN0cnVjdEV2YWxGdW5jdGlvbihjb2RlLCBvcmlnaW5hbCk7XG5cbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShmdW5jKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI3NldEdsb2JhbHNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFscyAtIE9iamVjdCB3aGljaCBrZXlzIGFyZSBnbG9iYWwgdmFycyBhbmQgdmFsdWVzIGFyZSB0aGVpciB2YWx1ZXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHNldHRpbmcgZ2xvYmFsIHZhcmlhYmxlcyAodXNlIG9ubHkgaW4gY29uc3RydWN0b3IhKS5cbiAgICovXG4gIHNldEdsb2JhbHMoZ2xvYmFscykge1xuICAgIGRlZmluZVVzdWFsUHJvcGVydGllcyh0aGlzLmdsb2JhbHMsIGdsb2JhbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjd2F0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLignYXJncyd8J2dsb2JhbHMnfFN0cmluZyl9IFt2YXJzXSAtIFZhcnMgdG8gd2F0Y2ggKGFyZ3MsIGdsb2JhbHMgb3IgbG9jYWxzKS5cbiAgICogSWYgbm8gc3BlY2lmaWVkIGFsbCBsb2NhbHMsIGFyZ3MgYW5kIGdsb2JhbHMgYXJlIHRvIGJlIHdhdGNoZWQuXG4gICAqIElmIHRoZSAnYXJncycgc3RyaW5nIGFsbCBhcmdzIGFyZSB0byBiZSB3YXRjaGVkLlxuICAgKiBJZiB0aGUgJ2dsb2JhbHMnIHN0cmluZyBhbGwgZ2xvYmFscyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogQHBhcmFtIHtWYXJzV2F0Y2hlcn0gd2F0Y2hlciAtIENhbGxlZCB3aGVuIHdhdGNoZWQgdmFycyBhcmUgY2hhbmdlZC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd2F0Y2hpbmcgZm9yIHZhcnMuIElmIG5vIHZhcnMgcGFzc2VkIGluIGFyZ3VtZW50c1xuICAgKiBhbGwgdmFycyBhcmUgdG8gYmUgd2F0Y2hlZC4gSWYgdGhlICdhcmdzJyBzdHJpbmcgaXMgaW4gdGhlIGFyZ3VtZW50cyBhbGwgYXJncyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogSWYgdGhlICdnbG9iYWxzJyBzdHJpbmcgaXMgaW4gdGhlIGFyZ3VtZW50cyBhbGwgZ2xvYmFscyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogT3RoZXJ3aXNlIHNwZWNpZmllZCB2YXJzIHdpbGwgYmUgd2F0Y2hlZC5cbiAgICogV2F0Y2hlcnMgc2hvdWxkIG5vdCBiZSBwdXQgaW5zaWRlIHRoZSBjb25zdHJ1Y3Rvci4gSXQgaXMgY29uc2lkZXJlZCBiZXN0XG4gICAqIHByYWN0aWNlIHRvIGRvIGl0IGluc2lkZSB0aGUge0BsaW5rIEJsb2NrI2FmdGVyQ29uc3RydWN0fSBtZXRob2QuXG4gICAqIE5vdGUgdGhhdCB0aGVzZSBleHByZXNzaW9ucyAodmFycywgaS5lLiBcImFyZ3MuYXJnXCIpIGFyZSBub3QgdG8gYmVcbiAgICogZXZhbHVhdGVkIHNvIHlvdSBjYW5ub3QgcHV0IHRoZXJlIHRoaW5ncyBsaWtlIFwiYVtiXVwiIG9yIGFueSBqcyBjb2RlLFxuICAgKiBvbmx5IGV4cHJlc3Npb25zIGxpa2UgXCJhXCIsIFwiYlwiLCBcImFyZ3MuYVwiLCBcImFyZ3MuYlwiIGFuZCBcImdsb2JhbHMuYVwiLCBcImdsb2JhbHMuYlwiLlxuICAgKiBBbHNvIG5vdGUgdGhhdCBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSB2YXIgdGhhdCBhcmUgY2hhbmdlZCBhdCBvbmNlIChzeW5jaHJvbm91c2x5KVxuICAgKiB0aGUgd2F0Y2hlciBpcyBjYWxsZWQgb25seSBvbmNlLlxuICAgKiBOb3RlIHRoYXQgdGhlIHdhdGNoZXIgaXMgZXhlY3V0ZWQgcmlnaHQgYXdheSBiZWNhdXNlIGluIG1vc3QgY2FzZXNcbiAgICogdGhpcyBiZWhhdmlvdXIgaXMgdmVyeSBjb252ZW5pZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2IC8+JztcbiAgICpcbiAgICogICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICogICAgIHRoaXMud2F0Y2goJ2EnLCAoKSA9PiB7fSk7XG4gICAqICAgICB0aGlzLndhdGNoKCdhcmdzLmEnLCAnZ2xvYmFscy5yJywgKCkgPT4ge30pO1xuICAgKiAgICAgdGhpcy53YXRjaCgoKSA9PiB7fSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqL1xuICB3YXRjaCguLi52YXJzKSB7XG4gICAgY29uc3Qgb2xkV2F0Y2hlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24ob2xkV2F0Y2hlcikpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIGxhc3QgYXJndW1lbnQgKHdhdGNoZXIpIHdhc24ndCBzcGVjaWZpZWQgKCR7IHRoaXMuJCQubmFtZSB9I3dhdGNoKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2F0Y2hlciA9ICgpID0+IHtcbiAgICAgIG9sZFdhdGNoZXIoKTtcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdhdGNoRm9yQWxsTG9jYWxzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgd2F0Y2hGb3JBbGxBcmdzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgd2F0Y2hGb3JBbGxHbG9iYWxzKHRoaXMsIHdhdGNoZXIpO1xuXG4gICAgICBvbGRXYXRjaGVyKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKHZhcmlhYmxlKSA9PiB7XG4gICAgICBpZiAodmFyaWFibGUgPT09IG9sZFdhdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXJpYWJsZSA9IGAkeyB2YXJpYWJsZSB9YDtcblxuICAgICAgaWYgKHZhcmlhYmxlID09PSAnJCcpIHtcbiAgICAgICAgcmV0dXJuIHdhdGNoRm9yQWxsTG9jYWxzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFyaWFibGUgPT09ICdhcmdzJykge1xuICAgICAgICByZXR1cm4gd2F0Y2hGb3JBbGxBcmdzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFyaWFibGUgPT09ICdnbG9iYWxzJykge1xuICAgICAgICByZXR1cm4gd2F0Y2hGb3JBbGxHbG9iYWxzKHRoaXMsIHdhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoL15hcmdzXFwuLy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnJlcGxhY2UoL15hcmdzXFwuLywgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy4kJC5hcmdzW3ZhcmlhYmxlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJCQuYXJnc1t2YXJpYWJsZV0ud2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKC9eZ2xvYmFsc1xcLi8udGVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5yZXBsYWNlKC9eZ2xvYmFsc1xcLi8sICcnKTtcblxuICAgICAgICBpZiAoIXRoaXMuJCQuZ2xvYmFsc1t2YXJpYWJsZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHdhdGNoZXJzIH0gPSB0aGlzLiQkLmdsb2JhbHNbdmFyaWFibGVdO1xuXG4gICAgICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgdGhpcy4kJC53YXRjaGVyc1RvUmVtb3ZlLnB1c2goe1xuICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuJCQubG9jYWxzW3ZhcmlhYmxlXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJCQubG9jYWxzW3ZhcmlhYmxlXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XG4gICAgfSk7XG5cbiAgICBvbGRXYXRjaGVyKCk7XG4gIH1cbn1cblxubmV3IFN1cGVyKEJsb2NrLnByb3RvdHlwZSkucHJvdG8obnVsbCk7XG5cbnJlZ2lzdGVyQnVpbHRJbnMoQmxvY2tzLCByb290QmxvY2tzLCBCbG9jayk7XG5cbmNvbnN0IGJsb2NrcyA9IEJsb2NrLl9ibG9ja3M7XG5cbmNsYXNzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQG1ldGhvZCBNaXhpbi53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIG1peGluLlxuICAgKiBAcmV0dXJucyB7TWl4aW59IE5ldyBtaXhpbi5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd3JhcHBpbmcgbWl4aW5zLlxuICAgKiBJdCBpcyBjb25zaWRlcmVkIGJlc3QgcHJhY3RpY2UgdG8ganVzdCBleHRlbmRzIHRoZSBvbGQgbWl4aW4gd2l0aCBhIG5ldyBvbmUuXG4gICAqL1xuICBzdGF0aWMgd3JhcCguLi53cmFwcGVycykge1xuICAgIHJldHVybiBuZXcgQXJyKGFyZ3VtZW50cykucmVkdWNlKChibG9jaywgd3JhcHBlcikgPT4ge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSB3cmFwcGVyKGJsb2NrKTtcblxuICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgcmV0dXJuVmFsdWUpXG4gICAgICAgID8gcmV0dXJuVmFsdWVcbiAgICAgICAgOiBibG9jaztcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBkeW5hbWljLFxuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjb21tZW50LFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3Qgd2F0Y2hlcnNUb1JlbW92ZSA9IG5ldyBBcnIoW10pO1xuICAgIGNvbnN0IHdhdGNoZXJzID0gbmV3IEFycihbXSk7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICQkOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIF92YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc0R5bmFtaWM6IGR5bmFtaWMsXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIHdhdGNoZXJzLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBldmFsdWF0ZTogKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc0R5bmFtaWMsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIF92YWx1ZVxuICAgICAgICAgIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGlzRHluYW1pY1xuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShfdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoaXNQYXJlbnRTaWduYWwpID0+IHtcbiAgICAgICAgICByZW1vdmVXYXRjaGVycyh3YXRjaGVyc1RvUmVtb3ZlKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgcGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50QmxvY2suJCQubWl4aW5zLmluZGV4T2YodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgdGhpcy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgIHRoaXMucGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMubm9kZSA9IGVsZW0uJFswXTtcblxuICAgIGlmIChwYXJlbnRCbG9jaykge1xuICAgICAgcGFyZW50QmxvY2suJCQubWl4aW5zLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7fVxuXG4gIGJlZm9yZVJlbW92ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVBbmRXYXRjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gY2FsbGJhY2sgLSBDYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgbWl4aW4gdmFsdWUgaXMgY2hhbmdlZC5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIHRoZSBtaXhpbiB2YWx1ZSBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGVBbmRXYXRjaChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLiQkLmV2YWx1YXRlKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlT25jZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgb25jZS5cbiAgICovXG4gIGV2YWx1YXRlT25jZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZSgpO1xuICB9XG59XG5cbnJlZ2lzdGVyQnVpbHRJbnMoTWl4aW5zLCByb290TWl4aW5zLCBNaXhpbik7XG5cbmNvbnN0IG1peGlucyA9IEJsb2NrLl9taXhpbnM7XG5cbmZ1bmN0aW9uIGluaXRBcHAoYmxvY2ssIG5vZGUpIHtcbiAgaWYgKCFibG9ja3NbYmxvY2tdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBcIiR7IGJsb2NrIH1cIiBibG9jayBpcyByZWdpc3RlcmVkISAoaW5pdEFwcClgKTtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudEVsZW0gPSBuZXcgRWxlbShub2RlKTtcblxuICBwYXJlbnRFbGVtLmh0bWwoJycpO1xuXG4gIGlmICghcGFyZW50RWxlbS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gaW5zZXJ0IHRoZSBhcHAgaW50byB3YXMgZ2l2ZW4hIChpbml0QXBwKScpO1xuICB9XG5cbiAgcGFyZW50RWxlbS4kWzBdLkR3YXluZVJvb3RCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICBub2RlOiB7XG4gICAgICBuYW1lOiBibG9jayxcbiAgICAgIGF0dHJzOiB7fSxcbiAgICAgIGNoaWxkcmVuOiBuZXcgQXJyKFtdKVxuICAgIH0sXG4gICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgIHBhcmVudEVsZW1cbiAgfSk7XG4gIHBhcmVudEVsZW0uYXR0cignZHdheW5lLXJvb3QnLCBibG9jayk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFwcChub2RlKSB7XG4gIGNvbnN0IGVsZW0gPSBuZXcgRWxlbShub2RlKTtcblxuICBlbGVtLmh0bWwoJycpO1xuXG4gIGlmICghZWxlbS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhcHAgZnJvbSB3YXMgZ2l2ZW4hIChyZW1vdmVBcHApJyk7XG4gIH1cblxuICBub2RlID0gZWxlbS4kWzBdO1xuXG4gIGlmICghbm9kZS5Ed2F5bmVSb290QmxvY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFwcCByZWdpc3RlcmVkIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCEgKHJlbW92ZUFwcCknKTtcbiAgfVxuXG4gIGRlbGV0ZSBub2RlLkR3YXluZVJvb3RCbG9jay4kJC5yZW1vdmUoKTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJCdWlsdElucyhzZXQsIHNjb3BlLCBwcm90bykge1xuICBpdGVyYXRlKHNldCwgKHJlZ2lzdGVyKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHJlZ2lzdGVyKHByb3RvLCBjcmVhdGVCbG9jaywgQmxvY2spO1xuXG4gICAgaWYgKHByb3RvID09PSBCbG9jaykge1xuICAgICAgY29uc3QgdmFyaWFibGVzID0ge307XG5cbiAgICAgIHZhbHVlLl9odG1sID0gdHJhbnNmb3JtSlNFeHByZXNzaW9ucyhcbiAgICAgICAgbWFya3VwVG9KU09OKFxuICAgICAgICAgIGAkeyB2YWx1ZS50ZW1wbGF0ZSB8fCAnJyB9YCxcbiAgICAgICAgICB2YWx1ZS5jb2xsYXBzZVdoaXRlU3BhY2VcbiAgICAgICAgKSxcbiAgICAgICAgdmFyaWFibGVzXG4gICAgICApO1xuICAgICAgdmFsdWUuX3ZhcmlhYmxlcyA9IG5ldyBTdXBlcih2YXJpYWJsZXMpXG4gICAgICAgIC5leGNlcHQoJyQkJywgJyQnKVxuICAgICAgICAua2V5cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZS5fbWF0Y2ggPSBjb25zdHJ1Y3RNaXhpblJlZ0V4cChuYW1lKTtcbiAgICB9XG5cbiAgICBzY29wZVtuYW1lXSA9IHZhbHVlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmxvY2soeyBub2RlLCBwYXJlbnQsIHBhcmVudEVsZW0sIHBhcmVudEJsb2NrLCBwYXJlbnRTY29wZSwgcGFyZW50VGVtcGxhdGUsIHByZXZCbG9jayB9KSB7XG4gIGNvbnN0IGVsZW0gPSBwYXJlbnRFbGVtLnByb3AoJ25hbWVzcGFjZVVSSScpID09PSBzdmdOU1xuICAgID8gZG9jLnN2ZygpXG4gICAgOiBuZXcgRWxlbShkb2MudGVtcGxhdGUoKS4kWzBdLmNvbnRlbnQpO1xuICBjb25zdCBsb2NhbEJsb2NrcyA9IHBhcmVudFNjb3BlID8gcGFyZW50U2NvcGUuJCQubnMuX2Jsb2NrcyA6IGJsb2NrcztcbiAgY29uc3QgbG9jYWxNaXhpbnMgPSBwYXJlbnRTY29wZSA/IHBhcmVudFNjb3BlLiQkLm5zLl9taXhpbnMgOiBtaXhpbnM7XG4gIGxldCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgbmV3IEFycihbXSk7XG4gIGxldCBhcmdzID0gbm9kZS5hdHRycyB8fCB7fTtcbiAgbGV0IG5hbWUgPSBub2RlLm5hbWUgfHwgJ1Vua25vd25CbG9jayc7XG4gIGxldCBjb25zdHJ1Y3RvciA9IG5vZGUubmFtZSAmJiBsb2NhbEJsb2Nrc1tub2RlLm5hbWVdO1xuICBsZXQgZEJsb2NrTWF0Y2g7XG4gIGxldCBkQmxvY2tOYW1lO1xuICBsZXQgZEJsb2NrQXJncztcbiAgbGV0IGRCbG9ja0NoaWxkcmVuO1xuICBsZXQgZEVsZW1lbnRzTmFtZTtcblxuICBpZiAobmFtZSA9PT0gJ2QtYmxvY2snICYmIGFyZ3MubmFtZSkge1xuICAgIG5hbWUgPSAnZC1lbGVtZW50cyc7XG4gICAgY29uc3RydWN0b3IgPSBsb2NhbEJsb2Nrc1tuYW1lXTtcbiAgICBkRWxlbWVudHNOYW1lID0gYXJncy5uYW1lO1xuICAgIGRCbG9ja0FyZ3MgPSBuZXcgU3VwZXIoYXJncykuZXhjZXB0KCduYW1lJykuJDtcbiAgICBkQmxvY2tDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gbmV3IEFycihbXSk7XG4gICAgYXJncyA9IHt9O1xuICB9IGVsc2UgaWYgKG5hbWUgPT09ICdkLWJsb2NrJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MsICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgbmFtZSA9ICdVbmtub3duQmxvY2snO1xuICAgIGNvbnN0cnVjdG9yID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoYXJncy5jb25zdHJ1Y3Rvcik7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikpIHtcbiAgICAgIGFyZ3MgPSBuZXcgU3VwZXIoYXJncykuZXhjZXB0KCdjb25zdHJ1Y3RvcicpLiQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoKGRCbG9ja01hdGNoID0gbmFtZS5tYXRjaCgvXmQtYmxvY2s6KFtcXHNcXFNdKykkLykpIHx8IG5hbWUgPT09ICdkLWJsb2NrJykge1xuICAgIGNvbnN0cnVjdG9yID0gYmxvY2tzWydkLWJsb2NrJ107XG4gICAgZEJsb2NrTmFtZSA9IGRCbG9ja01hdGNoID8gZEJsb2NrTWF0Y2hbMV0gOiBudWxsO1xuICB9XG5cbiAgbGV0IGJsb2NrSW5zdGFuY2U7XG5cbiAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJsb2NrSW5zdGFuY2UgPSBuZXcgY29uc3RydWN0b3Ioe1xuICAgICAgICBuYW1lLFxuICAgICAgICBhcmdzLFxuICAgICAgICBkQmxvY2tOYW1lLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBwcmV2QmxvY2tcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gbmV3ICR7IG5hbWUgfTpgLCBlcnIpO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IG5vZGU7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbS5jcmVhdGUobmFtZSk7XG4gICAgY29uc3QgY3VycmVudEF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCB3YXNEUmVzdDtcbiAgICBjb25zdCBtaXhpbkRlZmF1bHRPcHRzID0ge1xuICAgICAgZWxlbTogZWxlbWVudCxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH07XG5cbiAgICBuZXcgU3VwZXIoYXJncykuZm9yRWFjaCgodmFsdWUsIGF0dHIpID0+IHtcbiAgICAgIGNvbnN0IGlzRFJlc3QgPSBkUmVzdFJlZ0V4cC50ZXN0KGF0dHIpO1xuICAgICAgY29uc3QgbG9jYWxBdHRycyA9IGlzRFJlc3QgfHwgd2FzRFJlc3RcbiAgICAgICAgPyBPYmplY3QuY3JlYXRlKGF0dHJzKVxuICAgICAgICA6IGF0dHJzO1xuXG4gICAgICBhdHRycyA9IGxvY2FsQXR0cnM7XG5cbiAgICAgIGlmIChpc0RSZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3RBdHRycyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGUobG9jYWxBdHRycywgKHZhbHVlLCBhcmcpID0+IHtcbiAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsQXR0cnNbYXJnXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICAgICAgdmFsdWUsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICByZXN0QXR0cnMsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaCA9IG1peGluTWF0Y2gobG9jYWxNaXhpbnMsIGF0dHIpO1xuXG4gICAgICB3YXNEUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICAgIHR5cGU6ICdtaXhpbicsXG4gICAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAgIC4uLm1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICB0eXBlOiAnYXR0cicsXG4gICAgICAgIHZhbHVlOiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxjdWxhdGVBdHRycyhhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH0sIHBhcmVudEJsb2NrKVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGNyZWF0ZU1peGlucyA9IGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIHRydWUpO1xuXG4gICAgaWYgKG5hbWUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgIGVsZW1lbnQudGV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBsZXQgdGV4dCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQudGV4dChgJHsgdmFsdWUgfWApO1xuICAgICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgICAgaWYgKGlzTmlsKHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC50ZXh0KGAkeyB0ZXh0IH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQudGV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBwYXJlbnRFbGVtID0gbmFtZSA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgICA/IG5ldyBFbGVtKGVsZW1lbnQuJFswXS5jb250ZW50KVxuICAgICAgICA6IGVsZW1lbnQ7XG4gICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuXG4gICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChlbGVtZW50LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QWZ0ZXIocHJldkJsb2NrKTtcblxuICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgcGFyZW50LiQkLmFkZENvbnRlbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoZWxlbWVudCwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmludG8ocGFyZW50RWxlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGNyZWF0ZU1peGlucygpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBjb25zdCB7XG4gICAgJCQsXG4gICAgYXJnczogQXJncyxcbiAgICBnbG9iYWxzLFxuICAgIC4uLmxvY2Fsc1xuICB9ID0gYmxvY2tJbnN0YW5jZTtcblxuICBpZiAoZEJsb2NrTWF0Y2ggfHwgbmFtZSA9PT0gJ2QtYmxvY2snKSB7XG4gICAgcGFyZW50U2NvcGUuJCQuZEJsb2Nrcy5wdXNoKGJsb2NrSW5zdGFuY2UpO1xuICB9XG5cbiAgaWYgKGRCbG9ja0FyZ3MpIHtcbiAgICBub2RlID0ge1xuICAgICAgYXR0cnM6IGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbjogZEJsb2NrQ2hpbGRyZW5cbiAgICB9O1xuICAgIG5vZGUubmFtZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGRFbGVtZW50c05hbWUsIChuZXdOYW1lKSA9PiB7XG4gICAgICBub2RlLm5hbWUgPSBuZXdOYW1lO1xuXG4gICAgICBjb25zdCBodG1sID0gbmV3IEFycihbbm9kZV0pO1xuXG4gICAgICBBcmdzLnZhbHVlID0gbmV3TmFtZSA9PT0gJ2QtaWYnXG4gICAgICAgID8gdHJhbnNmb3JtRElmQ2hpbGRyZW4oaHRtbClcbiAgICAgICAgOiBodG1sO1xuICAgIH0sIGJsb2NrSW5zdGFuY2UsIHRydWUpO1xuXG4gICAgY29uc3QgaHRtbCA9IG5ldyBBcnIoW25vZGVdKTtcblxuICAgIEFyZ3MudmFsdWUgPSBub2RlLm5hbWUgPT09ICdkLWlmJ1xuICAgICAgPyB0cmFuc2Zvcm1ESWZDaGlsZHJlbihodG1sKVxuICAgICAgOiBodG1sO1xuICAgIEFyZ3MucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgfVxuXG4gIGNvbnN0IGh0bWwgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IG5ldyBBcnIoQXJncy52YWx1ZSB8fCBbXSlcbiAgICA6IGNvbnN0cnVjdG9yLl9odG1sO1xuXG4gIGRlbGV0ZSBsb2NhbHMuJDtcbiAgZGVsZXRlIGxvY2Fscy5wYXJlbnRTY29wZTtcblxuICAkJC5hcmdzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKEFyZ3MpO1xuICAkJC5sb2NhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUobG9jYWxzKTtcbiAgJCQuZ2xvYmFscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShnbG9iYWxzLCAnZ2xvYmFscycsIHBhcmVudFNjb3BlKTtcblxuICBpZiAobmFtZSA9PT0gJyNkLWl0ZW0nKSB7XG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcbiAgICAgIFtub2RlLmluZGV4TmFtZV06IG5vZGUuaW5kZXhcbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gcGFyZW50U2NvcGUuJCQubmFtZSA9PT0gJyNkLWl0ZW0nXG4gICAgICA/IHBhcmVudFNjb3BlLiQkLnNjb3BlXG4gICAgICA6IHBhcmVudFNjb3BlO1xuXG4gICAgJCQubnMgPSBwYXJlbnRTY29wZS4kJC5ucztcbiAgICAkJC5wcml2YXRlU2NvcGUgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoc2NvcGVWYWx1ZXMpO1xuICAgIGNvbnN0cnVjdFB1YmxpY1Njb3BlKCQkLnNjb3BlID0gT2JqZWN0LmNyZWF0ZShzY29wZSksIHNjb3BlVmFsdWVzLCAkJC5wcml2YXRlU2NvcGUpO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09ICdkLWVhY2gnKSB7XG4gICAgJCQuc2NvcGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiQkLm5hbWUgPT09ICcjZC1pdGVtJyA/IHBhcmVudFNjb3BlLiQkLnNjb3BlIDogcGFyZW50U2NvcGUsIHtcbiAgICAgIFtBcmdzLml0ZW0gfHwgJyRpdGVtJ106IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW0FyZ3MuaW5kZXggfHwgJyRpbmRleCddOiB7XG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0UHVibGljU2NvcGUoQXJncywgQXJncywgJCQuYXJncyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGdsb2JhbHMsIGdsb2JhbHMsICQkLmdsb2JhbHMpO1xuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShibG9ja0luc3RhbmNlLCBsb2NhbHMsICQkLmxvY2Fscyk7XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyQ29uc3RydWN0KCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnN0cnVjdDpgLCBlcnIpO1xuICB9XG5cbiAgcHJldkJsb2NrID0gdW5kZWZpbmVkO1xuICBwYXJlbnRTY29wZSA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy5wYXJlbnRTY29wZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcbiAgcGFyZW50VGVtcGxhdGUgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IEFyZ3MucGFyZW50VGVtcGxhdGVcbiAgICA6IGJsb2NrSW5zdGFuY2U7XG5cbiAgaHRtbC5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgcGFyZW50OiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrOiBibG9ja0luc3RhbmNlLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0pO1xuICB9KTtcblxuICB0cnkge1xuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJSZW5kZXIoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyUmVuZGVyOmAsIGVycik7XG4gIH1cblxuICByZXR1cm4gYmxvY2tJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWl4aW4oeyBuYW1lLCBNaXhpbiwgZHluYW1pYywgdmFsdWUsIGFyZ3MsIGNvbW1lbnQsIGVsZW0sIHBhcmVudEJsb2NrLCBwYXJlbnRTY29wZSwgcGFyZW50VGVtcGxhdGUgfSkge1xuICBjb25zdCBtaXhpbiA9IG5ldyBNaXhpbih7XG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICBkeW5hbWljLFxuICAgIGFyZ3MsXG4gICAgY29tbWVudCxcbiAgICBlbGVtLFxuICAgIHBhcmVudEJsb2NrLFxuICAgIHBhcmVudFNjb3BlLFxuICAgIHBhcmVudFRlbXBsYXRlXG4gIH0pO1xuXG4gIGlmIChNaXhpbi5ldmFsdWF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gbWl4aW4udmFsdWUgPSBtaXhpbi5ldmFsdWF0ZUFuZFdhdGNoKChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIG1peGluLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1peGluLmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtaXhpbi5hZnRlclVwZGF0ZSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbWl4aW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURJZkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgQXJyKGNoaWxkcmVuIHx8IFtdKVxuICAgIC5jb25jYXQoe30pXG4gICAgLm9iamVjdCgob2JqZWN0LCBjaGlsZCkgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lIH0gPSBjaGlsZDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaHRtbCxcbiAgICAgICAgaWZFbHNlXG4gICAgICB9ID0gb2JqZWN0O1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtZWxzZS1pZicgJiYgbmFtZSAhPT0gJ2QtZWxzZScpIHtcbiAgICAgICAgaWYgKGlmRWxzZSkge1xuICAgICAgICAgIGh0bWwucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnZC1pZicsXG4gICAgICAgICAgICBjaGlsZHJlbjogaWZFbHNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvYmplY3QuaWZFbHNlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSAnZC1pZicpIHtcbiAgICAgICAgICBvYmplY3QuaWZFbHNlID0gbmV3IEFycihbY2hpbGRdKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgaHRtbC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGlmRWxzZSB8fCBodG1sKS5wdXNoKGNoaWxkKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZWxzZScgJiYgaWZFbHNlKSB7XG4gICAgICAgICAgaHRtbC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6ICdkLWlmJyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBpZkVsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG9iamVjdC5pZkVsc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGNoaWxkLmNoaWxkcmVuID0gdHJhbnNmb3JtRElmQ2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGh0bWw6IG5ldyBBcnIoW10pLFxuICAgICAgaWZFbHNlOiBudWxsXG4gICAgfSkuJC5odG1sO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1KU0V4cHJlc3Npb25zKGNoaWxkcmVuLCB2YXJpYWJsZXMsIGV4Y2x1ZGUgPSB7fSkge1xuICByZXR1cm4gbmV3IEFycihjaGlsZHJlbiB8fCBbXSkub2JqZWN0KChjaGlsZHJlbiwgY2hpbGQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cnMsXG4gICAgICBjaGlsZHJlbjogb3duQ2hpbGRyZW4sXG4gICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlXG4gICAgfSA9IGNoaWxkO1xuICAgIGNvbnN0IGlzREVhY2ggPSBuYW1lID09PSAnZC1lYWNoJztcbiAgICBsZXQgeyB2YWx1ZSB9ID0gY2hpbGQ7XG4gICAgbGV0IGV4Y2x1ZGVMb2NhbCA9IHt9O1xuXG4gICAgaWYgKGlzREVhY2gpIHtcbiAgICAgIGV4Y2x1ZGVMb2NhbCA9IHtcbiAgICAgICAgW2NoaWxkLmF0dHJzLml0ZW0gfHwgJyRpdGVtJ106IHRydWUsXG4gICAgICAgIFtjaGlsZC5hdHRycy5pbmRleCB8fCAnJGluZGV4J106IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2hpbGQuYXR0cnMgPSBuZXcgU3VwZXIoYXR0cnMpLm1hcCgodmFsdWUsIGF0dHIpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlWzBdICE9PSAneycgfHwgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICd9Jykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSlModmFsdWUuc2xpY2UoMSwgLTEpLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlZC5yZXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlLCBtaXhpbiBhbmQgYXJndW1lbnQgY29tcHV0ZWQgdmFsdWVzIG11c3QgYmUgb2YgdGhlIGZvcm1hdCBcIns8anNfZXhwcmVzc2lvbj59XCInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNVSUQgPSBhdHRyID09PSAndWlkJztcblxuICAgICAgY29uc3QgdXNlZFZhcmlhYmxlcyA9IG5ldyBTdXBlcihwYXJzZWQudmFyaWFibGVzKS5maWx0ZXIoKHZhbHVlLCB2YXJpYWJsZSkgPT4ge1xuICAgICAgICBpZiAoaXNERWFjaCAmJiBpc1VJRCAmJiBleGNsdWRlTG9jYWxbdmFyaWFibGVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlW3ZhcmlhYmxlXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KS4kO1xuXG4gICAgICBhc3NpZ24odmFyaWFibGVzLCB1c2VkVmFyaWFibGVzKTtcblxuICAgICAgcmV0dXJuIGNvbnN0cnVjdEV2YWxGdW5jdGlvbihwYXJzZWQuZXhwcmVzc2lvbiwgcGFyc2VkLm9yaWdpbmFsKTtcbiAgICB9KS4kO1xuXG4gICAgaWYgKG5hbWUgIT09ICcjdGV4dCcpIHtcbiAgICAgIGV4Y2x1ZGUgPSB7XG4gICAgICAgIC4uLmV4Y2x1ZGUsXG4gICAgICAgIC4uLmV4Y2x1ZGVMb2NhbFxuICAgICAgfTtcblxuICAgICAgaWYgKG93bkNoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkLmNoaWxkcmVuID0gdHJhbnNmb3JtSlNFeHByZXNzaW9ucyhvd25DaGlsZHJlbiwgdmFyaWFibGVzLCBleGNsdWRlKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKGN1cmx5QnJhY2tldFJlZ0V4cCk7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgbmFtZTogJyN0ZXh0JyxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpbmRleCB9ID0gbWF0Y2g7XG5cbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICBuYW1lOiAnI3RleHQnLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSgwLCBpbmRleClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUpTKHZhbHVlLnNsaWNlKDEpLCBpbml0aWFsVmFsdWUpO1xuXG4gICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICBuYW1lOiAnI3RleHQnLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1c2VkVmFyaWFibGVzID0gbmV3IFN1cGVyKHBhcnNlZC52YXJpYWJsZXMpLmZpbHRlcigodmFsdWUsIHZhcmlhYmxlKSA9PiB7XG4gICAgICAgIGlmICghZXhjbHVkZVt2YXJpYWJsZV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkuJDtcblxuICAgICAgYXNzaWduKHZhcmlhYmxlcywgdXNlZFZhcmlhYmxlcyk7XG5cbiAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICBuYW1lOiAnI3RleHQnLFxuICAgICAgICB2YWx1ZTogY29uc3RydWN0RXZhbEZ1bmN0aW9uKHBhcnNlZC5leHByZXNzaW9uLCBwYXJzZWQub3JpZ2luYWwpXG4gICAgICB9KTtcbiAgICAgIHZhbHVlID0gcGFyc2VkLnJlc3Q7XG4gICAgfVxuICB9LCBuZXcgQXJyKFtdKSk7XG59XG5cbmZ1bmN0aW9uIGlzSW5zdGFuY2VPZihDbGFzcywgU3ViY2xhc3MpIHtcbiAgcmV0dXJuIGlzUHJvdG90eXBlT2YuY2FsbChDbGFzcywgU3ViY2xhc3MpICYmIGlzUHJvdG90eXBlT2YuY2FsbChDbGFzcy5wcm90b3R5cGUsIFN1YmNsYXNzLnByb3RvdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcbiAgd2F0Y2hlcnNUb1JlbW92ZS5mb3JFYWNoKCh7IHdhdGNoZXIsIHdhdGNoZXJzIH0pID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHdhdGNoZXJzLmluZGV4T2Yod2F0Y2hlcik7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB3YXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IE9iamVjdC5jcmVhdGUoXG4gICAgICBwYXJlbnRTY29wZVxuICAgICAgICA/IHBhcmVudFNjb3BlLiQkLmdsb2JhbHNcbiAgICAgICAgOiBudWxsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3VwZXIob2JqZWN0KS5vYmplY3QoKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IHtcbiAgICAgICAgdGVtcDogbmV3IEFycihbXSksXG4gICAgICAgIHBlcm06IG5ldyBBcnIoW10pXG4gICAgICB9XG4gICAgfTtcbiAgfSwgc2NvcGUpLiQ7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFB1YmxpY1Njb3BlKHNjb3BlLCBzY29wZVZhbHVlcywgcHJpdmF0ZVNjb3BlKSB7XG4gIG5ldyBTdXBlcihzY29wZSkuZGVmaW5lKG5ldyBTdXBlcihzY29wZVZhbHVlcykubWFwKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKGdldHRpbmcuaW5kZXhPZihzY29wZS53YXRjaGVycy50ZW1wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGdldHRpbmcucHVzaChzY29wZS53YXRjaGVycy50ZW1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gc2NvcGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRUZW1wV2F0Y2hlcnMgPSBzY29wZS53YXRjaGVycy50ZW1wLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc2NvcGUudmFsdWU7XG5cbiAgICAgICAgc2NvcGUud2F0Y2hlcnMudGVtcCA9IG5ldyBBcnIoW10pO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIG9sZFRlbXBXYXRjaGVycy5mb3JFYWNoKCh3YXRjaGVyKSA9PiB7XG4gICAgICAgICAgd2F0Y2hlci5vblJlbW92ZSgpO1xuICAgICAgICAgIHdhdGNoZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5nZWQucHVzaCh7XG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgd2FzID0gbmV3IEFycihbXSk7XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG9sZFZhbHVlXG4gICAgICAgICAgICB9ID0gY2hhbmdlZFtpXTtcblxuICAgICAgICAgICAgc2NvcGUud2F0Y2hlcnMucGVybS5mb3JFYWNoKCh3YXRjaGVyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gd2FzLmluZGV4T2Yod2F0Y2hlcik7XG5cbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHdhcy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjaGFuZ2VkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VkID0gbnVsbDtcblxuICAgICAgICAgIHdhcy5mb3JFYWNoKCh3YXRjaGVyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICAgICAgfSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgd2F0Y2hlcih2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KS4kKTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hGb3JBbGxMb2NhbHMoYmxvY2ssIHdhdGNoZXIpIHtcbiAgaXRlcmF0ZShibG9jay4kJC5sb2NhbHMsICh7IHdhdGNoZXJzIH0pID0+IHtcbiAgICB3YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXRjaEZvckFsbEdsb2JhbHMoYmxvY2ssIHdhdGNoZXIpIHtcbiAgY29uc3Qge1xuICAgIGdsb2JhbHMsXG4gICAgd2F0Y2hlcnNUb1JlbW92ZVxuICB9ID0gYmxvY2suJCQ7XG5cbiAgZm9yIChjb25zdCBnbG9iYWwgaW4gZ2xvYmFscykge1xuICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICBjb25zdCB3YXRjaGVycyA9IGdsb2JhbHNbZ2xvYmFsXS53YXRjaGVycy5wZXJtO1xuXG4gICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICB3YXRjaGVyc1RvUmVtb3ZlLnB1c2goe1xuICAgICAgd2F0Y2hlcixcbiAgICAgIHdhdGNoZXJzXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2F0Y2hGb3JBbGxBcmdzKGJsb2NrLCB3YXRjaGVyKSB7XG4gIGl0ZXJhdGUoYmxvY2suJCQuYXJncywgKHsgd2F0Y2hlcnMgfSkgPT4ge1xuICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFyZ3MoYXJncywgYXJnc09iamVjdCwgJGFyZ3NPYmplY3QpIHtcbiAgJGFyZ3NPYmplY3QucHJvcGVydHlOYW1lcygpLmZvckVhY2goKGFyZykgPT4ge1xuICAgIGlmICghKGFyZyBpbiBhcmdzKSkge1xuICAgICAgYXJnc09iamVjdFthcmddID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChjb25zdCBhcmcgaW4gYXJncykge1xuICAgIGFyZ3NPYmplY3RbYXJnXSA9IGFyZ3NbYXJnXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN0QXJncyhhcmdzKSB7XG4gIHJldHVybiBuZXcgU3VwZXIoYXJncykub2JqZWN0KChhcmdzLCB2YWx1ZSwgYXJnKSA9PiB7XG4gICAgaWYgKGRSZXN0UmVnRXhwLnRlc3QoYXJnKSkge1xuICAgICAgYXNzaWduKGFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NbYXJnXSA9IHZhbHVlO1xuICAgIH1cbiAgfSkuJDtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUmVzdEF0dHJzKGF0dHJzLCBtaXhpbnMsIG1peGluRGVmYXVsdE9wdHMpIHtcbiAgcmV0dXJuIG5ldyBTdXBlcihhdHRycykub2JqZWN0KChldmVudHVhbEF0dHJzLCB2YWx1ZSwgYXR0cikgPT4ge1xuICAgIGlmIChkUmVzdFJlZ0V4cC50ZXN0KGF0dHIpKSB7XG4gICAgICByZXR1cm4gYXNzaWduKGV2ZW50dWFsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyh2YWx1ZSwgbWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBtaXhpbk1hdGNoKG1peGlucywgYXR0cik7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGV2ZW50dWFsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgIHR5cGU6ICdtaXhpbicsXG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIG9wdHM6IHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAuLi5taXhpbkRlZmF1bHRPcHRzXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnR1YWxBdHRyc1thdHRyXSA9IHtcbiAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSkuJDtcbn1cblxuZnVuY3Rpb24gbWl4aW5NYXRjaChtaXhpbnMsIGF0dHIpIHtcbiAgbGV0IG1hdGNoO1xuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBtaXhpbnMpIHtcbiAgICBjb25zdCBNaXhpbiA9IG1peGluc1tuYW1lXTtcbiAgICBjb25zdCBsb2NhbE1hdGNoID0gYXR0ci5tYXRjaChNaXhpbi5fbWF0Y2gpO1xuXG4gICAgaWYgKGxvY2FsTWF0Y2gpIHtcbiAgICAgIGNvbnN0IGFyZ3NNYXRjaCA9IGxvY2FsTWF0Y2hbMV07XG4gICAgICBsZXQgYXJncztcblxuICAgICAgaWYgKC9eXFxzKiQvLnRlc3QoYXJnc01hdGNoKSkge1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NNYXRjaCkge1xuICAgICAgICBhcmdzID0gbmV3IFN0cihhcmdzTWF0Y2gpXG4gICAgICAgICAgLnNwbGl0KC8sXFxzKi8pXG4gICAgICAgICAgLm1hcCgocykgPT4gbmV3IFN0cihzKS50cmltKCkuJClcbiAgICAgICAgICAuJDtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNvbW1lbnQ6IGxvY2FsTWF0Y2hbMl0sXG4gICAgICAgIE1peGluLFxuICAgICAgICBuYW1lXG4gICAgICB9O1xuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBhdHRyc09iamVjdCwgZWxlbSwgZmlyc3RUaW1lKSB7XG4gIGl0ZXJhdGUoYXR0cnNPYmplY3QsICh7IHR5cGUsIHZhbHVlIH0sIGF0dHIpID0+IHtcbiAgICBpZiAoIWF0dHJzW2F0dHJdKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLiQkLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgYXR0cnNPYmplY3RbYXR0cl07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBtaXhpbnMgPSBuZXcgQXJyKFtdKTtcblxuICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0c1xuICAgIH0gPSBhdHRyc1thdHRyXTtcbiAgICBsZXQgbmV4dFR5cGU7XG4gICAgbGV0IG5leHREeW5hbWljO1xuICAgIGxldCBuZXh0VmFsdWU7XG5cbiAgICBpZiAoYXR0cnNPYmplY3RbYXR0cl0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZTogcHJldlR5cGUsXG4gICAgICAgIHZhbHVlOiBwcmV2VmFsdWVcbiAgICAgIH0gPSBhdHRyc09iamVjdFthdHRyXTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBpZiAocHJldlR5cGUgPT09ICdtaXhpbicpIHtcbiAgICAgICAgICBwcmV2VmFsdWUuJCQucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGVsZW0uYXR0cihhdHRyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1peGluID0gcHJldlZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWl4aW4uJCQuaXNEeW5hbWljID0gZHluYW1pYztcblxuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW1peGluLiQkLmV2YWx1YXRlZCAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtaXhpbi4kJC5wYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGR5bmFtaWNcbiAgICAgICAgICAgIH0gPSBhdHRyc1thdHRyXTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtaXhpbik7XG5cbiAgICAgICAgICBtaXhpbi4kJC5ldmFsdWF0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRWYWx1ZSA9IG1peGluO1xuICAgICAgfVxuXG4gICAgICBuZXh0VHlwZSA9IHR5cGU7XG4gICAgICBuZXh0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcblxuICAgICAgICBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkTWl4aW4gPSAoKSA9PiB7XG4gICAgICAgICAgb3B0cy5keW5hbWljID0gZHluYW1pYztcblxuICAgICAgICAgIGNvbnN0IG1peGluID0gY3JlYXRlTWl4aW4ob3B0cyk7XG5cbiAgICAgICAgICBpZiAoIWR5bmFtaWMgJiYgb3B0cy5NaXhpbi5ldmFsdWF0ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBvcHRzO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZHluYW1pY1xuICAgICAgICAgICAgICB9ID0gYXR0cnNbYXR0cl07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaXhpbicgJiYgIWR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtaXhpbik7XG5cbiAgICAgICAgICAgIG1peGluLiQkLmV2YWx1YXRlZCA9IHRydWU7XG4gICAgICAgICAgICBtaXhpbi4kJC52YWx1ZSA9IGZpcnN0VmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZHluYW1pYyxcbiAgICAgICAgICAgICAgdmFsdWU6IG1peGluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgbWl4aW5zLnB1c2goYnVpbGRNaXhpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRNaXhpbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRUeXBlID0gdHlwZTtcbiAgICAgIG5leHREeW5hbWljID0gZHluYW1pYztcbiAgICB9XG5cbiAgICBhdHRyc09iamVjdFthdHRyXSA9IHtcbiAgICAgIHR5cGU6IG5leHRUeXBlLFxuICAgICAgZHluYW1pYzogbmV4dER5bmFtaWMsXG4gICAgICB2YWx1ZTogbmV4dFZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChmaXJzdFRpbWUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWl4aW5zLmZvckVhY2goKGJ1aWxkTWl4aW4pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgb3B0c1xuICAgICAgICB9ID0gYnVpbGRNaXhpbigpO1xuXG4gICAgICAgIGF0dHJzT2JqZWN0W2F0dHJdID0gb3B0cztcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIHZhbHVlKSB7XG4gIGNvbnN0IG9sZFZhbHVlID0gbWl4aW4uJCQudmFsdWU7XG5cbiAgbWl4aW4uJCQudmFsdWUgPSB2YWx1ZTtcblxuICBtaXhpbi4kJC53YXRjaGVycy5mb3JFYWNoKCh3YXRjaGVyKSA9PiB7XG4gICAgd2F0Y2hlcih2YWx1ZSwgb2xkVmFsdWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0TWl4aW5SZWdFeHAobmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7IG5ldyBTdHIobmFtZSkuZXNjYXBlUmVnRXhwKCkuJCB9KD86XFxcXCgoW15cXFxcKV0qKVxcXFwpKT8oPzojKFtcXFxcc1xcXFxTXSopKT8kYCk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZEJsb2NrKGNscykge1xuICBuZXcgU3VwZXIoY2xzKS5wcm90byhCbG9jayk7XG4gIG5ldyBTdXBlcihjbHMucHJvdG90eXBlKS5wcm90byhCbG9jay5wcm90b3R5cGUpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRUZW1wbGF0ZXModGVtcGxhdGUsIHRlbXBsYXRlcykge1xuICBjb25zdCB7IHZhcnMsIHZhbHVlIH0gPSB0ZW1wbGF0ZTtcbiAgY29uc3QgbmV3VGVtcGxhdGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbmV3VmFycyA9IG5ldyBTdXBlcih2YXJzKS5vYmplY3QoKHZhcnMsIHZhcmlhYmxlKSA9PiB7XG4gICAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xuICB9KTtcblxuICBhc3NpZ24obmV3VGVtcGxhdGVzLCB0ZW1wbGF0ZXMpO1xuICBpdGVyYXRlKHZhbHVlLCBmb3JFYWNoTm9kZSk7XG5cbiAgZnVuY3Rpb24gZm9yRWFjaE5vZGUoeyB0eXBlLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaW5kZXgsIHRyZWUpIHtcbiAgICBpZiAodHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgdmFsdWUgPSBuZXcgU3RyKHZhbHVlKS50cmltKCkuJDtcblxuICAgICAgaWYgKG5ld1RlbXBsYXRlc1t2YWx1ZV0pIHtcbiAgICAgICAgdHJlZVtpbmRleF0gPSBuZXdUZW1wbGF0ZXNbdmFsdWVdLnZhbHVlO1xuICAgICAgICBuZXdWYXJzLmFzc2lnbihuZXcgU3VwZXIobmV3VGVtcGxhdGVzW3ZhbHVlXS52YXJzKS5vYmplY3QoKHZhcnMsIHZhcmlhYmxlKSA9PiB7XG4gICAgICAgICAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xuICAgICAgICB9KS4kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZShjaGlsZHJlbiwgZm9yRWFjaE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhcnMubGVuZ3RoID0gMDtcbiAgbmV3IEFycih2YXJzKS5wdXNoQXJyYXkobmV3VmFycy5rZXlzKCkuJCk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5leHBvcnQgeyBCbG9jaywgTWl4aW4sIGluaXRBcHAsIHJlbW92ZUFwcCwgaW5zZXJ0VGVtcGxhdGVzIH07XG4iLCIvKipcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2Zvcm1hdHNcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBkaWZmZXJlbnQgdHlwZXMgb2YgZm9ybWF0dGluZyBmb3Ige0BsaW5rIERhdGUjZm9ybWF0fS5cbiAqL1xuXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XG5cbmNvbnN0IHplcm8gPSBuZXcgU3RyKCcwJyk7XG5jb25zdCBkYXlzT2ZUaGVXZWVrTmFtZXMgPSBbXG4gICdTdW5kYXknLFxuICAnTW9uZGF5JyxcbiAgJ1R1ZXNkYXknLFxuICAnV2VkbmVzZGF5JyxcbiAgJ1RodXJzZGF5JyxcbiAgJ0ZyaWRheScsXG4gICdTYXR1cmRheSdcbl07XG5jb25zdCBkYXlzT2ZUaGVXZWVrQWxpYXNlcyA9IG5ldyBTdXBlcihkYXlzT2ZUaGVXZWVrTmFtZXMpLm1hcCgodmFsdWUpID0+IHZhbHVlLnNsaWNlKDAsIDMpKS4kO1xuY29uc3QgbW9udGhzTmFtZXMgPSBbXG4gICdKYW51YXJ5JyxcbiAgJ0ZlYnJ1YXJ5JyxcbiAgJ01hcmNoJyxcbiAgJ0FwcmlsJyxcbiAgJ01heScsXG4gICdKdW5lJyxcbiAgJ0p1bGUnLFxuICAnQXVndXN0JyxcbiAgJ1NlcHRlbWJlcicsXG4gICdPY3RvYmVyJyxcbiAgJ05vdmVtYmVyJyxcbiAgJ0RlY2VtYmVyJ1xuXTtcbmNvbnN0IG1vbnRoc0FsaWFzZXMgPSBuZXcgU3VwZXIobW9udGhzTmFtZXMpLm1hcCgodmFsdWUpID0+IHZhbHVlLnNsaWNlKDAsIDMpKS4kO1xuXG4vKipcbiAqIEBjYWxsYmFjayBtb2R1bGU6Y29uc3RhbnRzL2Zvcm1hdHN+bWF0Y2hDYWxsYmFja1xuICogQHBhcmFtIHtEYXR9IGRhdGUgLSBELXdyYXAgb2YgYSBkYXRlIHRvIGFwcGx5IGZvcm1hdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBNYXRjaGVkIGFwcGxpZWQgZXhwcmVzc2lvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpjb25zdGFudHMvZm9ybWF0c35mb3JtYXRFeHByXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9ybWF0IC0gTWF0Y2hlZCBmb3JtYXQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpjb25zdGFudHMvZm9ybWF0c35tYXRjaENhbGxiYWNrfSBtYXRjaCAtIENhbGxiYWNrIGlmIHRoZXJlIHdhcyBhIG1hdGNoLlxuICovXG5cbi8qKlxuICogQHR5cGUge21vZHVsZTpjb25zdGFudHMvZm9ybWF0c35mb3JtYXRFeHByW119XG4gKiBAZGVzY3JpcHRpb24gQXJyYXkgb2YgZGlmZmVyZW50IGZvcm1hdHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFtcbiAge1xuICAgIGZvcm1hdDogJ2NjYycsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnYycpLCAzKVxuICB9LFxuICB7XG4gICAgZm9ybWF0OiAnYycsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnYycpXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdzcycsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgncycpLCAyKVxuICB9LFxuICB7XG4gICAgZm9ybWF0OiAncycsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgncycpXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdtbScsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnbScpLCAyKVxuICB9LFxuICB7XG4gICAgZm9ybWF0OiAnbScsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnbScpXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdoaCcsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnaCcpLCAyKVxuICB9LFxuICB7XG4gICAgZm9ybWF0OiAnaCcsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnaCcpXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdkZGRkJyxcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF5c09mVGhlV2Vla05hbWVzW2RhdGVbdXRjXSgnZHcnKV1cbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ2RkZCcsXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRheXNPZlRoZVdlZWtBbGlhc2VzW2RhdGVbdXRjXSgnZHcnKV1cbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ2RkJyxcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gcm91bmQoZGF0ZVt1dGNdKCdkJyksIDIpXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdkJyxcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCdkJylcbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ01NTU0nLFxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBtb250aHNOYW1lc1tkYXRlW3V0Y10oJ00nKSAtIDFdXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdNTU0nLFxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBtb250aHNBbGlhc2VzW2RhdGVbdXRjXSgnTScpIC0gMV1cbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ01NJyxcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gcm91bmQoZGF0ZVt1dGNdKCdNJyksIDIpXG4gIH0sXG4gIHtcbiAgICBmb3JtYXQ6ICdNJyxcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCdNJylcbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ3l5eXknLFxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ3knKSwgNClcbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ3l5JyxcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gU3RyaW5nKGRhdGVbdXRjXSgneScpKS5zbGljZSgtMilcbiAgfSxcbiAge1xuICAgIGZvcm1hdDogJ3knLFxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW3V0Y10oJ3knKVxuICB9XG5dO1xuXG4vKipcbiAqIEBmdW5jdGlvbiByb3VuZFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgLSBOdW1iZXIgdG8gcm91bmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZGlnaXRzIC0gTnVtYmVyIG9mIHRoZSBkaWdpdHMgb2YgdGhlIG91dHB1dC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyB3aXRoIG5lY2Vzc2FyeSBhZGRpdGlvbmFsIHN0YXJ0aW5nIHplcm9lcy5cbiAqL1xuZnVuY3Rpb24gcm91bmQobnVtYmVyLCBkaWdpdHMpIHtcbiAgY29uc3Qgc3RyaW5nID0gU3RyaW5nKG51bWJlcik7XG4gIGxldCB6ZXJvZXMgPSBkaWdpdHMgLSBzdHJpbmcubGVuZ3RoO1xuXG4gIHplcm9lcyA9IHplcm9lcyA8IDAgPyAwIDogemVyb2VzO1xuXG4gIHJldHVybiB6ZXJvLnJlcGVhdCh6ZXJvZXMpLiQgKyBzdHJpbmc7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgRGF0XG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBEYXQgY2xhc3MuXG4gKi9cblxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcbmltcG9ydCB7IE51bSB9IGZyb20gJy4vTnVtJztcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4vU3RyJztcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi9Td2l0Y2hlcic7XG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgZm9ybWF0cyBmcm9tICcuL2NvbnN0YW50cy9mb3JtYXRzJztcbmltcG9ydCB7IGlzRGF0ZSwgaXRlcmF0ZSwgU3ltYm9sLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSAnLi9oZWxwZXJzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7Kn0gRGF0ZUxpa2VcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYyd8J3MnfCdtJ3wnaCd8J2QnfCd3J3wnTSd8J3knfSBBZGRQZXJpb2RcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYyd8J3MnfCdtJ3wnaCd8J2QnfCdkdyd8J00nfCd5J30gR2V0UGVyaW9kXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2MnfCdzJ3wnbSd8J2gnfCdkJ3wnTSd8J3knfSBPZk9uZVBlcmlvZFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydjJ3wncyd8J20nfCdoJ3wnZCd8J00nfCd5J30gU2V0UGVyaW9kXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2NjYyd8J2MnfCdzcyd8J3MnfCdtbSd8J20nfCdoaCd8J2gnfCdkZGRkJ3wnZGRkJ3wnZGQnfCdkJ3wnTU1NTSd8J01NTSd8J01NJ3wnTSd8J3l5eXknfCd5eSd8J3knfSBGb3JtYXRcbiAqIEBwdWJsaWNcbiAqL1xuXG5jb25zdCBjb2VmZnMgPSB7XG4gIGM6IDEsXG4gIHM6IDEwMDAsXG4gIG06IDYwMDAwLFxuICBoOiAzNjAwMDAwLFxuICBkOiA4NjQwMDAwMCxcbiAgdzogNjA0ODAwMDAwLFxuICBNOiAyNTkyMDAwMDAwLFxuICB5OiAzMTUzNjAwMDAwMFxufTtcblxuY29uc3QgZ2V0U3dpdGNoZXIgPSBzd2l0Y2hlcih7XG4gIGM6IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TWlsbGlzZWNvbmRzYF0oKSxcbiAgczogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1TZWNvbmRzYF0oKSxcbiAgbTogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1NaW51dGVzYF0oKSxcbiAgaDogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1Ib3Vyc2BdKCksXG4gIGQ6IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9RGF0ZWBdKCksXG4gIGR3OiAoZGF0ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfURheWBdKCksXG4gIE06IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TW9udGhgXSgpICsgMSxcbiAgeTogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1GdWxsWWVhcmBdKClcbn0sICdlcXVhbHMnLCBOYU4pO1xuY29uc3Qgc2V0U3dpdGNoZXIgPSBzd2l0Y2hlcih7XG4gIGM6IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfU1pbGxpc2Vjb25kc2BdKHZhbHVlKSxcbiAgczogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9U2Vjb25kc2BdKHZhbHVlKSxcbiAgbTogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TWludXRlc2BdKHZhbHVlKSxcbiAgaDogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9SG91cnNgXSh2YWx1ZSksXG4gIGQ6IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfURhdGVgXSh2YWx1ZSksXG4gIE06IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfU1vbnRoYF0odmFsdWUgLSAxKSxcbiAgeTogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9RnVsbFllYXJgXSh2YWx1ZSlcbn0pO1xuXG4vKipcbiAqIEBjbGFzcyBEYXRcbiAqIEBleHRlbmRzIFN1cGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlID0gbmV3IERhdGUoKV0gLSBBIGRhdGUgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtEYXR9IEluc3RhbmNlIG9mIERhdC5cbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGEgZGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGF0ZSA9IG5ldyBEYXQobmV3IERhdGUoKSk7XG4gKi9cbmNsYXNzIERhdCBleHRlbmRzIFN1cGVyIHtcbiAgY29uc3RydWN0b3IoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgICBzdXBlcihkYXRlKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgRGF0IyRcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWdpbmFsIGRhdGUuXG4gICAgICovXG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBEYXQjYWRkXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtBZGRQZXJpb2R8T2JqZWN0LjxBZGRQZXJpb2QsIE51bWJlcj59IHdoYXQgLSBXaGF0IHRvIGFkZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtudW1iZXJdIC0gTnVtYmVyIG9mIHdoYXQgdG8gYWRkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHBlcmlvZCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtEYXR9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIGFtb3VudHMgb2YgdGltZSB0byB0aGUgZGF0ZS4gUmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgRGF0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSkuYWRkKCdjJywgMikudG9JU09TdHJpbmcoKTsgICAgICAgICAvLyAnMjAwMC0wMS0wMVQwMDowMDowMC4wMDFaJ1xuICAgKiBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSkuYWRkKHsgYzogMiwgZDogNSB9KS50b0lTT1N0cmluZygpOyAvLyAnMjAwMC0wMS0wNlQwMDowMDowMC4wMDFaJ1xuICAgKi9cbiAgYWRkKHdoYXQsIG51bWJlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHdoYXQgPSB7IFt3aGF0XTogbnVtYmVyIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGltZSh0aGlzLnRpbWUoKSArIG5ldyBTdXBlcih3aGF0KS5zdW0oKHZhbHVlLCB3aGF0KSA9PiBjb2VmZnNbd2hhdF0gKiB2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRGF0I2V4cGlyZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0geyp9IFt2YWx1ZSA9IHRoaXNdIC0gVmFsdWUgdG8gcmVzb2x2ZSBhZnRlciB0aGUgZGF0ZSBleHBpcmVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZmluaW5nIHdoZW4gdGhlIGRhdGUgZXhwaXJlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IERhdCgpLmFkZCgnYycsIDUwMCkuZXhwaXJlcygnRXhwaXJlZCcpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAqICAgLy8gQWZ0ZXIgNTAwIG1pbGxpc2Vjb25kc1xuICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJ0V4cGlyZWQnXG4gICAqIH0pO1xuICAgKi9cbiAgZXhwaXJlcyh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTnVtKHRoaXMuJCAtIG5vdygpKS50aW1lb3V0KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIERhdCNmb3JtYXRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gVGVtcGxhdGUgZm9yIHRoZSBvdXRwdXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4ID0gJyddIC0gSWYgbmVlZGVkIFthbGwgc3BlY2lhbCBzdHJpbmdzXXtAbGluayBGb3JtYXR9XG4gICAqIGFyZSB0cmVhdGVkIGFzIHRoZXkgc2hvdWxkIGJlIHByZWZpeCB3aXRoIHByZWZpeC5cbiAgICogQHJldHVybnMge1N0cmluZ30gRm9ybWF0dGVkIHN0cmluZy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY3JlYXRpbmcgZm9ybWF0dGVkIG91dHB1dCBiYXNlZCBvbiBhIHN0cmluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IERhdCgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykuZm9ybWF0KCdTZWNvbmRzOiAkc3MsIG1pbGxpc2Vjb25kczogJGNjYy4nLCAnJCcpO1xuICAgKiAvLyAnU2Vjb25kczogNTksIG1pbGxpc2Vjb25kczogOTk5LidcbiAgICovXG4gIGZvcm1hdChzdHJpbmcsIHByZWZpeCA9ICcnKSB7XG4gICAgc3RyaW5nID0gbmV3IFN0cihuZXcgU3VwZXIoc3RyaW5nKS4kKTtcbiAgICBwcmVmaXggPSBTdHJpbmcobmV3IFN1cGVyKHByZWZpeCkuJCk7XG5cbiAgICBpdGVyYXRlKGZvcm1hdHMsIChmb3JtYXQpID0+IHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlU3RyaW5nKHByZWZpeCArIGZvcm1hdC5mb3JtYXQsIGZvcm1hdC5tYXRjaCh0aGlzLCAnZ2V0JykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cmluZy4kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRGF0I2Zvcm1hdFVUQ1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBTZWUge0BsaW5rIERhdCNmb3JtYXR9LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeCA9ICcnXSAtIFNlZSB7QGxpbmsgRGF0I2Zvcm1hdH0uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmcuXG4gICAqIEBkZXNjcmlwdGlvbiBVVEMgdmVyc2lvbiBvZiB7QGxpbmsgRGF0I2Zvcm1hdH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBEYXQoJzE5OTktMDctMDdUMDM6MDk6MDkuMDk5WicpLmZvcm1hdFVUQyhcbiAgICogICBgXG4gICAqICAgICBNaWxsaXNlY29uZHM6ICRjY2N8JGMuXG4gICAqICAgICBTZWNvbmRzOiAgICAgICRzc3wkcy5cbiAgICogICAgIE1pbnV0ZXM6ICAgICAgJG1tfCRtLlxuICAgKiAgICAgSG91cnM6ICAgICAgICAkaGh8JGguXG4gICAqICAgICBEYXk6ICAgICAgICAgICRkZGRkfCRkZGR8JGRkfCRkLlxuICAgKiAgICAgTW9udGg6ICAgICAgICAkTU1NTXwkTU1NfCRNTXwkTS5cbiAgICogICAgIFllYXI6ICAgICAgICAgJHl5eXl8JHl5fCR5LlxuICAgKiAgIGAsXG4gICAqICAgJyQnXG4gICAqICk7XG4gICAqIC8vIE1pbGxpc2Vjb25kczogMDk5fDk5LlxuICAgKiAvLyBTZWNvbmRzOiAgICAgIDA5fDkuXG4gICAqIC8vIE1pbnV0ZXM6ICAgICAgMDl8OS5cbiAgICogLy8gSG91cnM6ICAgICAgICAwM3wzLlxuICAgKiAvLyBEYXk6ICAgICAgICAgIEZyaWRheXxGcml8MDd8Ny5cbiAgICogLy8gTW9udGg6ICAgICAgICBKdWx5fEp1bHwwN3w3LlxuICAgKiAvLyBZZWFyOiAgICAgICAgIDE5OTl8OTl8MTk5OS5cbiAgICovXG4gIGZvcm1hdFVUQyhzdHJpbmcsIHByZWZpeCA9ICcnKSB7XG4gICAgc3RyaW5nID0gbmV3IFN0cihuZXcgU3VwZXIoc3RyaW5nKS4kKTtcbiAgICBwcmVmaXggPSBTdHJpbmcobmV3IFN1cGVyKHByZWZpeCkuJCk7XG5cbiAgICBpdGVyYXRlKGZvcm1hdHMsIChmb3JtYXQpID0+IHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlU3RyaW5nKHByZWZpeCArIGZvcm1hdC5mb3JtYXQsIGZvcm1hdC5tYXRjaCh0aGlzLCAnZ2V0VVRDJykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cmluZy4kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRGF0I2dldFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7R2V0UGVyaW9kfSB3aGF0IC0gV2hhdCB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiB3aGF0IHRvIGdldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyB2YWx1ZXMgc3VjaCBhcyBzZWNvbmRzIG9yIG1pbnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5nZXQoJ3MnKTsgLy8gNTlcbiAgICovXG4gIGdldCh3aGF0KSB7XG4gICAgcmV0dXJuIGdldFN3aXRjaGVyKHdoYXQsIFt0aGlzLiQsICdnZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBEYXQjZ2V0VVRDXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtHZXRQZXJpb2R9IHdoYXQgLSBTZWUge0BsaW5rIERhdCNnZXR9LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2Ygd2hhdCB0byBnZXQuXG4gICAqIEBkZXNjcmlwdGlvbiBVVEMgdmVyc2lvbiBvZiB7QGxpbmsgRGF0I2dldH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRhdGUgPSBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSk7XG4gICAqXG4gICAqIGRhdGUuZ2V0VVRDKCdjJyk7ICAvLyA5OTlcbiAgICogZGF0ZS5nZXRVVEMoJ3MnKTsgIC8vIDU5XG4gICAqIGRhdGUuZ2V0VVRDKCdtJyk7ICAvLyA1OVxuICAgKiBkYXRlLmdldFVUQygnaCcpOyAgLy8gMjNcbiAgICogZGF0ZS5nZXRVVEMoJ2QnKTsgIC8vIDMxXG4gICAqIGRhdGUuZ2V0VVRDKCdkdycpOyAvLyA1XG4gICAqIGRhdGUuZ2V0VVRDKCdNJyk7ICAvLyAxMlxuICAgKiBkYXRlLmdldFVUQygneScpOyAgLy8gMTk5OVxuICAgKi9cbiAgZ2V0VVRDKHdoYXQpIHtcbiAgICByZXR1cm4gZ2V0U3dpdGNoZXIod2hhdCwgW3RoaXMuJCwgJ2dldFVUQyddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIERhdCNpc0FmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtEYXRlTGlrZX0gZGF0ZSAtIERhdGUgdG8gYmUgY29tcGFyZWQgdG8gdGhpcyBkYXRlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhpcyBkYXRlIGlzIGFmdGVyIHRoZSBhcmd1bWVudCBvbmUuXG4gICAqIEBkZXNjcmlwdGlvbiBGaW5kcyBvdXQgaWYgdGhpcyBkYXRlIGlzIGFmdGVyIHRoZSBhcmd1bWVudCBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNBZnRlcihuZXcgRGF0ZSgzMzQpKTsgLy8gZmFsc2VcbiAgICogbmV3IERhdChuZXcgRGF0ZSgzMzMpKS5pc0FmdGVyKG5ldyBEYXRlKDMzMikpOyAvLyB0cnVlXG4gICAqL1xuICBpc0FmdGVyKGRhdGUpIHtcbiAgICBkYXRlID0gbmV3IERhdGUobmV3IFN1cGVyKGRhdGUpLiQpO1xuXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIDwgdGhpcy4kLmdldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIERhdCNpc0JlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RGF0ZUxpa2V9IGRhdGUgLSBEYXRlIHRvIGJlIGNvbXBhcmVkIHRvIHRoaXMgZGF0ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoaXMgZGF0ZSBpcyBiZWZvcmUgdGhlIGFyZ3VtZW50IG9uZS5cbiAgICogQGRlc2NyaXB0aW9uIEZpbmRzIG91dCBpZiB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBhcmd1bWVudCBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNCZWZvcmUobmV3IERhdGUoMzM0KSk7IC8vIHRydWVcbiAgICogbmV3IERhdChuZXcgRGF0ZSgzMzMpKS5pc0JlZm9yZShuZXcgRGF0ZSgzMzIpKTsgLy8gZmFsc2VcbiAgICovXG4gIGlzQmVmb3JlKGRhdGUpIHtcbiAgICBkYXRlID0gbmV3IERhdGUobmV3IFN1cGVyKGRhdGUpLiQpO1xuXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID4gdGhpcy4kLmdldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIERhdCNpc0JldHdlZW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0RhdGVMaWtlfSBkYXRlMSAtIFN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICogQHBhcmFtIHtEYXRlTGlrZX0gZGF0ZTIgLSBFbmQgb2YgdGhlIHJhbmdlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhpcyBkYXRlIGlzIGFmdGVyIGRhdGUxIGFuZCBiZWZvcmUgZGF0ZTIuXG4gICAqIEBkZXNjcmlwdGlvbiBGaW5kcyBvdXQgaWYgdGhpcyBkYXRlIGlzIGFmdGVyIGRhdGUxIGFuZCBiZWZvcmUgZGF0ZTIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNCZXR3ZWVuKG5ldyBEYXRlKDMzMiksIG5ldyBEYXRlKDMzNCkpOyAvLyB0cnVlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNCZXR3ZWVuKG5ldyBEYXRlKDMzNCksIG5ldyBEYXRlKDMzMikpOyAvLyBmYWxzZVxuICAgKi9cbiAgaXNCZXR3ZWVuKGRhdGUxLCBkYXRlMikge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLiQuZ2V0VGltZSgpO1xuXG4gICAgZGF0ZTEgPSBuZXcgRGF0ZShuZXcgU3VwZXIoZGF0ZTEpLiQpO1xuICAgIGRhdGUyID0gbmV3IERhdGUobmV3IFN1cGVyKGRhdGUyKS4kKTtcblxuICAgIHJldHVybiB0aW1lID4gZGF0ZTEuZ2V0VGltZSgpICYmIHRpbWUgPCBkYXRlMi5nZXRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBEYXQjaXNJbnZhbGlkXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBkYXRlIGlzIGludmFsaWQuXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBkYXRlIGlzIGludmFsaWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJ2EnKSkuaXNJbnZhbGlkKCk7IC8vIHRydWVcbiAgICogbmV3IERhdChuZXcgRGF0ZSgxKSkuaXNJbnZhbGlkKCk7ICAgLy8gZmFsc2VcbiAgICovXG4gIGlzSW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy4kLnRvU3RyaW5nKCkgPT09ICdJbnZhbGlkIERhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRGF0I2lzUGFzc2VkXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBkYXRlIGlzIHBhc3NlZC5cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIGRhdGUgaXMgcGFzc2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDEpKS5pc1Bhc3NlZCgpOyAvLyB0cnVlXG4gICAqL1xuICBpc1Bhc3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0JlZm9yZShub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBEYXQjb2ZPbmVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09mT25lUGVyaW9kfSB3aGF0IC0gUGVyaW9kIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge0RhdGVMaWtlfSBkYXRlIC0gRGF0ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHR3byBkYXRlcyBhcmUgb2Ygb25lIHNlY29uZCwgbWludXRlIG9yIHNvbWV0aGluZyBlbHNlLlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0d28gZGF0ZXMgYXJlIG9mIG9uZSBzZWNvbmQsIG1pbnV0ZSBvciBzb21ldGhpbmcgZWxzZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS4wMDBaJykpLm9mT25lKCdzJywgbmV3IERhdGUoMTk5OS0xMi0zMVQyMzo1OTo1OS4zMzNaJykpOyAvLyB0cnVlXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuMDAwWicpKS5vZk9uZSgncycsIG5ldyBEYXRlKDE5OTktMTItMzFUMjM6NTk6NTguOTk5WicpKTsgLy8gZmFsc2VcbiAgICovXG4gIG9mT25lKHdoYXQsIGRhdGUpIHtcbiAgICBpZiAoISh3aGF0IGluIGNvZWZmcykgfHwgd2hhdCA9PT0gJ3cnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0ZSA9IG5ldyBEYXQobmV3IERhdGUoZGF0ZSkpO1xuXG4gICAgbGV0IHN0YXJ0ZWQ7XG5cbiAgICByZXR1cm4gaXRlcmF0ZShjb2VmZnMsIChjb2VmZiwgdykgPT4ge1xuICAgICAgaWYgKHcgPT09IHdoYXQpIHtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhcnRlZCB8fCB3ID09PSAndycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRlZCAmJiB0aGlzLmdldCh3KSAhPT0gZGF0ZS5nZXQodykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pICE9PSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIERhdCNzZXRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1NldFBlcmlvZHxPYmplY3QuPFNldFBlcmlvZCwgTnVtYmVyPn0gd2hhdCAtIFdoYXQgdG8gYWRkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW251bWJlcl0gLSBOdW1iZXIgb2Ygd2hhdCB0byBzZXQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgcGVyaW9kIHN0cmluZy5cbiAgICogQHJldHVybnMge0RhdH0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBzZXR0aW5nIHZhbHVlcyBzdWNoIGFzIHNlY29uZHMgb3IgbWludXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykpLnNldCgncycsIDU4KS5nZXQoJ3MnKTsgICAgICAgICAgIC8vIDU4XG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5zZXQoeyBjOiA5OTgsIHM6IDU4IH0pLmdldCgnYycpOyAvLyA5OThcbiAgICovXG4gIHNldCh3aGF0LCBudW1iZXIpIHtcbiAgICBjb25zdCBkYXRlID0gdGhpcy4kO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgd2hhdCA9IHsgW3doYXRdOiBudW1iZXIgfTtcbiAgICB9XG5cbiAgICB3aGF0ID0gbmV3IFN1cGVyKHdoYXQpLiQ7XG5cbiAgICBpdGVyYXRlKHdoYXQsICh2YWx1ZSwgd2hhdCkgPT4ge1xuICAgICAgc2V0U3dpdGNoZXIod2hhdCwgW2RhdGUsIHZhbHVlLCAnc2V0J10pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBEYXQjc2V0VVRDXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTZXRQZXJpb2R8T2JqZWN0LjxTZXRQZXJpb2QsIE51bWJlcj59IHdoYXQgLSBTZWUge0BsaW5rIERhdCNzZXR9LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW251bWJlcl0gLSBTZWUge0BsaW5rIERhdCNzZXR9LlxuICAgKiBAcmV0dXJucyB7RGF0fSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBVVEMgdmVyc2lvbiBvZiB7QGxpbmsgRGF0I3NldH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRhdGUgPSBuZXcgRGF0KG5ldyBEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSk7XG4gICAqXG4gICAqIGRhdGUuc2V0VVRDKCdjY2MnLCA5OTgpLmdldFVUQygnY2NjJyk7IC8vIDk5OFxuICAgKiBkYXRlLnNldFVUQyh7XG4gICAqICAgczogNTgsXG4gICAqICAgbTogNTgsXG4gICAqICAgaDogMjJcbiAgICogfSk7XG4gICAqXG4gICAqIGRhdGUuZ2V0VVRDKCdzJyk7IC8vIDU4XG4gICAqIGRhdGUuZ2V0VVRDKCdtJyk7IC8vIDU4XG4gICAqIGRhdGUuZ2V0VVRDKCdoJyk7IC8vIDIzXG4gICAqL1xuICBzZXRVVEMod2hhdCwgbnVtYmVyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuJDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHdoYXQgPSB7IFt3aGF0XTogbnVtYmVyIH07XG4gICAgfVxuXG4gICAgd2hhdCA9IG5ldyBTdXBlcih3aGF0KS4kO1xuXG4gICAgaXRlcmF0ZSh3aGF0LCAodmFsdWUsIHdoYXQpID0+IHtcbiAgICAgIHNldFN3aXRjaGVyKHdoYXQsIFtkYXRlLCB2YWx1ZSwgJ3NldFVUQyddKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRGF0I3NldFVUQ1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gLSBUaW1lIHRvIHNldC5cbiAgICogQHJldHVybnMge0RhdHxOdW1iZXJ9IC0gSWYgdGhlIHRpbWUgYXJndW1lbnQgaXMgcHJlc2VudCB0aGlzIGlzIHJldHVybmVkIG90aGVyd2lzZSB0aGUgdGltZSBpcyByZXR1cm5lZC5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIGJvdGhcbiAgICogW0RhdGUjZ2V0VGltZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRUaW1lfSBhbmRcbiAgICogW0RhdGUjc2V0VGltZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRUaW1lfS5cbiAgICovXG4gIHRpbWUodGltZSkge1xuICAgIGNvbnN0IGRhdGUgPSB0aGlzLiQ7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZGF0ZS5zZXRUaW1lKHRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbiAgfVxuXG4gIHRvSVNPU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiQudG9JU09TdHJpbmcoKTtcbiAgfVxuXG4gIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiQudG9Mb2NhbGVTdHJpbmcoKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuJC52YWx1ZU9mKCk7XG4gIH1cbn1cbmRlZmluZVByb3BlcnRpZXMoRGF0LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0RhdCdcbn0pO1xuXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XG4gIGNoZWNrOiBpc0RhdGUsXG4gIGNsczogRGF0XG59KTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gbm93XG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL25vd1xuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gKiBbRGF0ZS5ub3dde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvbm93fS5cbiAqL1xuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGF0ZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtEYXRlTGlrZX0gW2RhdGUgPSBuZXcgRGF0ZSgpXSAtIERhdGUtbGlrZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgRGF0ZSBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm5zIHtEYXR9IE5ldyBpbnN0YW5jZSBvZiBEYXQuXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgbmV3IERhdChuZXcgRGF0ZShkYXRlKSk7XG4gKi9cbmZ1bmN0aW9uIGRhdGUoZGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IERhdChuZXcgRGF0ZShub3coKSkpO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBTdXBlcihkYXRlKS4kO1xuXG4gIHJldHVybiBuZXcgRGF0KG5ldyBEYXRlKGRhdGUpKTtcbn1cblxuZXhwb3J0IHsgRGF0LCBub3csIGRhdGUgfTtcbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2NvbnN0cnVjdFVSTFxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGNvbnN0cnVjdFVSTCBtZXRob2QuXG4gKi9cblxuaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4uL1N3aXRjaGVyJztcbmltcG9ydCB7IGlzQXJyYXksIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9jaGVja1R5cGVzJztcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xuXG4vKipcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAZGVzY3JpcHRpb24gQWJzb2x1dGUgVVJMIHBhdHRlcm4uXG4gKi9cbmNvbnN0IGFic29sdXRlVVJMUmVnZXhwID0gL14oKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC98ZGF0YTpbYS16XStcXC9bYS16XSs7YmFzZTY0LCkvaTtcbmNvbnN0IHF1ZXJ5U3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsICgpID0+IG5ldyBBcnIoW10pKVxuICAuY2FzZShpc0FycmF5LCAocHJlZml4LCBxdWVyeSkgPT4ge1xuICAgIGxldCBxdWVyeVBhcmFtcyA9IG5ldyBBcnIoW10pO1xuXG4gICAgaXRlcmF0ZShxdWVyeSwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb25jYXQocXVlcnlTd2l0Y2hlcih2YWx1ZSwgW2AkeyBwcmVmaXggfVtdYF0pKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHF1ZXJ5UGFyYW1zLnB1c2goe1xuICAgICAgICBwYXJhbTogYCR7IHByZWZpeCB9W11gLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcXVlcnlQYXJhbXMuJDtcbiAgfSlcbiAgLmNhc2UoaXNQbGFpbk9iamVjdCwgKHByZWZpeCwgcXVlcnkpID0+IHtcbiAgICBsZXQgcXVlcnlQYXJhbXMgPSBuZXcgQXJyKFtdKTtcblxuICAgIGl0ZXJhdGUocXVlcnksICh2YWx1ZSwgcGFyYW0pID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBxdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvbmNhdChxdWVyeVN3aXRjaGVyKHZhbHVlLCBbcHJlZml4ID8gYCR7IHByZWZpeCB9WyR7IHBhcmFtIH1dYCA6IHBhcmFtXSkpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcXVlcnlQYXJhbXMucHVzaCh7XG4gICAgICAgIHBhcmFtOiBwcmVmaXggPyBgJHsgcHJlZml4IH1bJHsgcGFyYW0gfV1gIDogcGFyYW0sXG4gICAgICAgIHZhbHVlOiBpc09iamVjdCh2YWx1ZSkgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBTdHJpbmcodmFsdWUpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBxdWVyeVBhcmFtcy4kO1xuICB9KTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY29uc3RydWN0VVJMXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZVVSTCAtIEJhc2VVUkwgb2YgdGhlIG91dHB1dCBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gTWFpbiBwYXJ0IG9mIHRoZSBvdXRwdXQgVVJMLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFBhcmFtcyB0byByZXBsYWNlIGluIHRoZSB1cmwgZXhwcmVzc2lvbnMgbGlrZSBcIjpwYXJhbVwiLlxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IC0gT2JqZWN0IHdpdGggcXVlcnkgcGFyYW1zLlxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNoID0gJyddIC0gVVJMIGhhc2guXG4gKiBAcGFyYW0ge09iamVjdH0gW2VuY29kZU9wdGlvbnMgPSB7fV0gLSBJZiB5b3UgbmVlZCB0byBlbmNvZGUgc29tZXRoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtlbmNvZGVPcHRpb25zLnBhcmFtcyA9IHRydWVdIC0gSWYgeW91IG5lZWQgdG8gZW5jb2RlIHBhcmFtcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW5jb2RlT3B0aW9ucy5xdWVyeSA9IHRydWVdIC0gSWYgeW91IG5lZWQgdG8gZW5jb2RlIHF1ZXJ5IHBhcmFtcy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbnN0cnVjdGVkIFVSTC5cbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgY29uc3RydWN0aW5nIFVSTCBmcm9tIHRoZSBiYXNlIFVSTCwgVVJMLCBwYXJhbXMgYW5kIHF1ZXJ5IHBhcmFtcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2VVUkwsIHVybCwgcGFyYW1zLCBxdWVyeSwgaGFzaCA9ICcnLCBlbmNvZGVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHBhcmFtczogZW5jb2RlUGFyYW1zID0gdHJ1ZSxcbiAgICBxdWVyeTogZW5jb2RlUXVlcnkgPSB0cnVlXG4gIH0gPSBlbmNvZGVPcHRpb25zO1xuICBsZXQgVVJMID0gaXNBYnNvbHV0ZSh1cmwpXG4gICAgPyB1cmxcbiAgICA6IGAkeyBTdHJpbmcoYmFzZVVSTCkucmVwbGFjZSgvXFwvKyQvLCAnJykgfS8keyBTdHJpbmcodXJsKS5yZXBsYWNlKC9eXFwvKy8sICcnKSB9YDtcblxuICBpdGVyYXRlKHBhcmFtcywgKHZhbHVlLCBwYXJhbSkgPT4ge1xuICAgIFVSTCA9IG5ldyBTdHIoVVJMKS5yZXBsYWNlU3RyaW5nKGA6JHsgcGFyYW0gfWAsIGVuY29kZSh2YWx1ZSwgZW5jb2RlUGFyYW1zKSkuJDtcbiAgfSk7XG5cbiAgY29uc3QgcXVlcnlQYXJhbXMgPSBxdWVyeVN3aXRjaGVyKHF1ZXJ5LCBbJyddKTtcblxuICBpZiAocXVlcnlQYXJhbXMubGVuZ3RoKSB7XG4gICAgVVJMICs9IChVUkwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBxdWVyeVBhcmFtc1xuICAgICAgLm1hcCgoeyBwYXJhbSwgdmFsdWUgfSkgPT4gYCR7IGVuY29kZShwYXJhbSwgZW5jb2RlUXVlcnkpIH09JHsgZW5jb2RlKHZhbHVlLCBlbmNvZGVRdWVyeSkgfWApXG4gICAgICAuam9pbignJicpO1xuICB9XG5cbiAgcmV0dXJuIGAkeyBVUkwgfSR7IGhhc2ggPyBgIyR7IGhhc2ggfWAgOiAnJyB9YDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzQWJzb2x1dGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBVUkwgdG8gY2hlY2sgaWYgaXQgaXMgYWJzb2x1dGUgb3Igbm90LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBVUkwgaXMgYWJzb2x1dGUgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc0Fic29sdXRlKHVybCkge1xuICByZXR1cm4gYWJzb2x1dGVVUkxSZWdleHAudGVzdCh1cmwpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBlbmNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBTdHJpbmcgdG8gZW5jb2RlIHVzaW5nIGVuY29kZVVSSUNvbXBvbmVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFbmNvZGVkIC0gSWYgdGhlIHN0cmluZyBzaG91bGQgYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBpc0VuY29kZWQpIHtcbiAgcmV0dXJuIGlzRW5jb2RlZCA/IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpIDogc3RyaW5nO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEZldGNoXG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBGZXRjaCBjbGFzcy5cbiAqL1xuXG5pbXBvcnQgeyBQcm9taXNlIH0gZnJvbSAnLi9Qcm9taXNlJztcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XG5pbXBvcnQgeyBBcnIgfSBmcm9tICcuL0Fycic7XG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuL1N0cic7XG5pbXBvcnQge1xuICBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZyxcbiAgYXNzaWduLCBTeW1ib2wsIHZhbGlkYXRlLCBpdGVyYXRlLCBkZWZpbmVQcm9wZXJ0aWVzXG59IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgY29uc3RydWN0VVJMIGZyb20gJy4vaGVscGVycy9jb25zdHJ1Y3RVUkwnO1xuaW1wb3J0IHBhcnNlSGVhZGVycyBmcm9tICcuL2hlbHBlcnMvcGFyc2VIZWFkZXJzJztcbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vaGVscGVycy90cmFuc2Zvcm1EYXRhJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J2dldCd8J3Bvc3QnfCdkZWxldGUnfCdoZWFkJ3wncHV0J3wncGF0Y2gnfSBGZXRjaE1ldGhvZFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmV0Y2hDb25maWdcbiAqIEBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEFmdGVyTWlkZGxld2FyZXxGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlPn0gW2FmdGVyXVxuICogQHByb3BlcnR5IHtPYmplY3R9IFthdXRoXVxuICogQHByb3BlcnR5IHtTdHJpbmd9IFthdXRoLnVzZXJuYW1lXVxuICogQHByb3BlcnR5IHtTdHJpbmd9IFthdXRoLnBhc3N3b3JkXVxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtiYXNlVVJMXVxuICogQHByb3BlcnR5IHtBcnJheS48QmVmb3JlTWlkZGxld2FyZXxGZXRjaEVycm9yQmVmb3JlTWlkZGxld2FyZT59IFtiZWZvcmVdXG4gKiBAcHJvcGVydHkgeyp9IFtkYXRhXVxuICogQHByb3BlcnR5IHtPYmplY3QuPFN0cmluZywgU3RyaW5nW10+fSBbaGVhZGVyc11cbiAqIEBwcm9wZXJ0eSB7RmV0Y2hNZXRob2R9IFttZXRob2RdXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3BhcmFtc11cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcXVlcnldXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3Jlc3BvbnNlVHlwZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGltZW91dF1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdXJsXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbd2l0aENyZWRlbnRpYWxzXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmV0Y2hSZXNwb25zZVxuICogQHB1YmxpY1xuICogQHByb3BlcnR5IHtGZXRjaENvbmZpZ30gY29uZmlnXG4gKiBAcHJvcGVydHkgeyp9IGRhdGFcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGF0dXNUZXh0XG4gKiBAcHJvcGVydHkge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBGZXRjaEFmdGVyTWlkZGxld2FyZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtGZXRjaFJlc3BvbnNlfSBjb25maWcgLSBGZXRjaCByZXNwb25zZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Vycm9yfCp9IGVyciAtIFRocm93biBlcnJvci5cbiAqIEBwYXJhbSB7RmV0Y2hSZXNwb25zZX0gY29uZmlnIC0gRmV0Y2ggcmVzcG9uc2UuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRmV0Y2hCZWZvcmVNaWRkbGV3YXJlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBjb25maWcgLSBGZXRjaCBjb25maWcuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRmV0Y2hFcnJvckJlZm9yZU1pZGRsZXdhcmVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RXJyb3J8Kn0gZXJyIC0gVGhyb3duIGVycm9yLlxuICogQHBhcmFtIHtGZXRjaENvbmZpZ30gY29uZmlnIC0gRmV0Y2ggY29uZmlnLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEZldGNoQ29uZmlnRnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IGNvbmZpZ1xuICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhZnRlcjogW10sXG4gIGF1dGg6IHtcbiAgICB1c2VybmFtZTogJycsXG4gICAgcGFzc3dvcmQ6ICcnXG4gIH0sXG4gIGJhc2VVUkw6IGdsb2JhbC5sb2NhdGlvbi5vcmlnaW4sXG4gIGJlZm9yZTogW10sXG4gIGRhdGE6IG51bGwsXG4gIGhlYWRlcnM6IHt9LFxuICBtZXRob2Q6ICdnZXQnLFxuICBwYXJhbXM6IHt9LFxuICBxdWVyeToge30sXG4gIHJlc3BvbnNlVHlwZTogJycsXG4gIHRpbWVvdXQ6IDAsXG4gIHVybDogJycsXG4gIHdpdGhDcmVkZW50aWFsczogZmFsc2Vcbn07XG5jb25zdCB1cGxvYWRNZXRob2RzID0gbmV3IEFycihbJ3Bvc3QnLCAncHV0J10pO1xuXG4vKipcbiAqIEBjbGFzcyBGZXRjaFxuICogQGV4dGVuZHMgRnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWcgPSB7fV0gLSBBIG51bWJlciB0byB3cmFwLlxuICogQHJldHVybnMge0ZldGNofSBJbnN0YW5jZSBvZiBGZXRjaC5cbiAqIEFuIGluc3RhbmNlIG9mIEZldGNoIGlzIGEgZnVuY3Rpb24gdGhhdCBzaW1wbHkgY2FsbHMgI3JlcXVlc3Qgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gKiBAZGVzY3JpcHRpb24gQ2xhc3MgZm9yIGZldGNoaW5nIGRhdGEuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKCk7XG4gKlxuICogZmV0Y2goJy9kYXRhJykudGhlbigocmVzKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHJlcyk7XG4gKiB9KTtcbiAqL1xuY2xhc3MgRmV0Y2ggZXh0ZW5kcyBGdW5jdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGZ1bmN0aW9uIGZldGNoKCkge1xuICAgICAgcmV0dXJuIGZldGNoLnJlcXVlc3QuYXBwbHkoZmV0Y2gsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZiA9IG5ldyBTdXBlcih7fSkuZGVlcEFzc2lnbihkZWZhdWx0cywgY29uZmlnKS4kO1xuXG4gICAgaWYgKGNvbmYuYmVmb3JlLmluZGV4T2YoZmV0Y2hCZWZvcmVNaWRkbGV3YXJlKSA9PT0gLTEpIHtcbiAgICAgIGNvbmYuYmVmb3JlLnB1c2goZmV0Y2hCZWZvcmVNaWRkbGV3YXJlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGZXRjaENvbmZpZ30gRmV0Y2gjJCRcbiAgICAgKiBAdHlwZSB7RmV0Y2hDb25maWd9XG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXNjcmlwdGlvbiBGZXRjaCBjb25maWcuXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZldGNoLCAnJCQnLCB7IHZhbHVlOiBjb25mIH0pO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihmZXRjaCwgRmV0Y2gucHJvdG90eXBlKTtcblxuICAgIHJldHVybiBmZXRjaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZldGNoI2FmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtGZXRjaEFmdGVyTWlkZGxld2FyZXxGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlfSBtaWRkbGV3YXJlIC0gTWlkZGxld2FyZSB0byBhZGQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYWZ0ZXJBbGwgPSB0cnVlXSAtIEJvb2xlYW4gcGFyYW1ldGVyIHdoZXJlIHRvIHB1dCB0aGUgbWlkZGxld2FyZS5cbiAgICogVHJ1dGh5IHBhcmFtZXRlciBzdGFuZHMgZm9yIFwidG8gdGhlIGVuZFwiIGFuZCBmYWxzZXkgZm9yIFwidG8gdGhlIGJlZ2lubmluZ1wiLlxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1pZGRsZXdhcmUgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHJlcXVlc3QuXG4gICAqIElmIHRoZSBtaWRkbGV3YXJlIGhhcyAyIG9yIGxlc3MgYXJndW1lbnRzIGl0J3MgdHJlYXRlZCBhcyBzdWNjZXNzIG1pZGRsZXdhcmUgb3RoZXJ3aXNlIGFzIGFuIGVycm9yIG9uZS5cbiAgICogSWYgdGhlIG1pZGRsZXdhcmUgcmV0dXJucyBhIHByb21pc2UgaXQgYmVjb21lcyBhIHBhcnQgb2YgdGhlIG1pZGRsZXdhcmUgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKClcbiAgICogICAuYWZ0ZXIoKGVyciwgcmVzKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgKlxuICAgKiAgICAgdGhyb3cgZXJyO1xuICAgKiAgIH0pXG4gICAqICAgLmFmdGVyKChyZXMpID0+IHtcbiAgICogICAgIHJlcy5qc29uID0gRChyZXMuZGF0YSkucGFyc2VKU09OKCk6XG4gICAqICAgfSk7XG4gICAqL1xuICBhZnRlcihtaWRkbGV3YXJlLCBhZnRlckFsbCA9IHRydWUpIHtcbiAgICB2YWxpZGF0ZShbbWlkZGxld2FyZV0sIFsnZnVuY3Rpb24nXSwgJ0ZldGNoI2FmdGVyJyk7XG5cbiAgICBjb25zdCB7IGFmdGVyIH0gPSB0aGlzLiQkO1xuXG4gICAgaWYgKGFmdGVyQWxsKSB7XG4gICAgICBhZnRlci5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlci51bnNoaWZ0KG1pZGRsZXdhcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRmV0Y2gjYmVmb3JlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtGZXRjaEJlZm9yZU1pZGRsZXdhcmV8RmV0Y2hFcnJvckJlZm9yZU1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBNaWRkbGV3YXJlIHRvIGFkZC5cbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtiZWZvcmVBbGwgPSB0cnVlXSAtIEJvb2xlYW4gcGFyYW1ldGVyIHdoZXJlIHRvIHB1dCB0aGUgbWlkZGxld2FyZS5cbiAgICogVHJ1dGh5IHBhcmFtZXRlciBzdGFuZHMgZm9yIFwidG8gdGhlIGJlZ2lubmluZ1wiIGFuZCBmYWxzZXkgZm9yIFwidG8gdGhlIGVuZFwiLlxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1pZGRsZXdhcmUgdGhhdCBpcyBjYWxsZWQgYmVmb3JlIHRoZSByZXF1ZXN0LlxuICAgKiBJZiB0aGUgbWlkZGxld2FyZSBoYXMgMiBvciBsZXNzIGFyZ3VtZW50cyBpdCdzIHRyZWF0ZWQgYXMgc3VjY2VzcyBtaWRkbGV3YXJlIG90aGVyd2lzZSBhcyBhbiBlcnJvciBvbmUuXG4gICAqIElmIHRoZSBtaWRkbGV3YXJlIHJldHVybnMgYSBwcm9taXNlIGl0IGJlY29tZXMgYSBwYXJ0IG9mIHRoZSBtaWRkbGV3YXJlIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpXG4gICAqICAgLmJlZm9yZSgoZXJyLCByZXEpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAqXG4gICAqICAgICB0aHJvdyBlcnI7XG4gICAqICAgfSlcbiAgICogICAuYmVmb3JlKChyZXEpID0+IHtcbiAgICogICAgIGlmIChyZXEudXJsID09PSAnL3ZlcnlMb25nUmVxdWVzdCcpIHtcbiAgICogICAgICAgcmVxLnRpbWVvdXQgPSAzMDAwMDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICovXG4gIGJlZm9yZShtaWRkbGV3YXJlLCBiZWZvcmVBbGwgPSB0cnVlKSB7XG4gICAgdmFsaWRhdGUoW21pZGRsZXdhcmVdLCBbJ2Z1bmN0aW9uJ10sICdGZXRjaCNiZWZvcmUnKTtcblxuICAgIGNvbnN0IHsgYmVmb3JlIH0gPSB0aGlzLiQkO1xuXG4gICAgaWYgKGJlZm9yZUFsbCkge1xuICAgICAgYmVmb3JlLnVuc2hpZnQobWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRmV0Y2gjY29uZmlnXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8RmV0Y2hDb25maWd8RmV0Y2hDb25maWdGdW5jdGlvbn0gW3Byb3BlcnR5XSAtIElmIGl0J3MgYSBmdW5jdGlvblxuICAgKiBpdCdzIGNhbGxlZCB3aXRoIHRoZSBmZXRjaCBjb25maWcgYXJndW1lbnQsIGlmIGl0J3MgYSBzdHJpbmcgdGhlIHZhbHVlIGFyZ3VtZW50XG4gICAqIGlzIHVzZWQgZm9yIGFzc2lnbmluZyB0aGlzIHByb3BlcnR5IHRvIHRoZSBmZXRjaCBjb25maWdcbiAgICogb3RoZXJ3aXNlIGl0J3MgYXNzaWduZWQgdG8gdGhlIGZldGNoIGNvbmZpZy5cbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gU2VlIHRoZSBwcm9wZXJ0eSBhcmd1bWVudC5cbiAgICogQHJldHVybnMge0ZldGNofEZldGNoQ29uZmlnfSBJZiB0aGUgYXJndW1lbnQgaXMgcHJlc2VudCB0aGlzIGlzIHJldHVybmVkIG90aGVyd2lzZSB0aGUgZmV0Y2ggY29uZmlnIGlzIHJldHVybmVkLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGFuZCBzZXR0aW5nIGNvbmZpZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZmV0Y2ggPSBuZXcgRmV0Y2goKTtcbiAgICpcbiAgICogZmV0Y2guY29uZmlnKHsgYmFzZVVSTDogNTAwMCB9KTtcbiAgICogZmV0Y2guY29uZmlnKCkudGltZW91dDsgLy8gNTAwMFxuICAgKlxuICAgKiBmZXRjaC5jb25maWcoKGNvbmZpZykgPT4ge1xuICAgKiAgIGNvbmZpZy5iYXNlVVJMICs9ICcvYXBpJztcbiAgICogfSk7XG4gICAqL1xuICBjb25maWcocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgY29uZiA9IHRoaXMuJCQ7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjb25mO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkoY29uZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgICB9XG5cbiAgICAgIG5ldyBTdXBlcihjb25mKS5kZWVwQXNzaWduKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZldGNoI2RlbGV0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdXJsXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cbiAgICogQGRlc2NyaXB0aW9uIFNob3J0aGFuZCBmb3IgI3JlcXVlc3QgZm9yIGRlbGV0ZSByZXF1ZXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEZldGNoKCkuZGVsZXRlKCcvZGF0YScpLnRoZW4oKHJlcykgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAqIH0pO1xuICAgKi9cbiAgZGVsZXRlKHVybCwgY29uZmlnID0ge30pIHtcbiAgICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICAgIGNvbmZpZyA9IHVybDtcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAnZGVsZXRlJyB9LCBjb25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZldGNoI2dldFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdXJsXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cbiAgICogQGRlc2NyaXB0aW9uIFNob3J0aGFuZCBmb3IgI3JlcXVlc3QgZm9yIGdldCByZXF1ZXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEZldGNoKCkuZ2V0KCcvZGF0YScpLnRoZW4oKHJlcykgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAqIH0pO1xuICAgKi9cbiAgZ2V0KHVybCwgY29uZmlnID0ge30pIHtcbiAgICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICAgIGNvbmZpZyA9IHVybDtcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZldGNoI2hlYWRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxGZXRjaFJlc3BvbnNlLCBFcnJvcj59IFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBoZWFkIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgRmV0Y2goKS5oZWFkKCcvZGF0YScpLnRoZW4oKHJlcykgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAqIH0pO1xuICAgKi9cbiAgaGVhZCh1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgICBjb25maWcgPSB1cmw7XG4gICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwsIGFzc2lnbih7IG1ldGhvZDogJ2hlYWQnIH0sIGNvbmZpZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRmV0Y2gjaGVhZGVyc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmd8U3RyaW5nW10+fSBoZWFkZXIgLSBBIGhlYWRlciBzdHJpbmcgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuICAgKiB7IFtoZWFkZXJdOiBbdmFsdWUxLCB2YWx1ZTIsIC4uLl0gfS5cbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFt2YWx1ZV0gLSBIZWFkZXIgdmFsdWUuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICAgKiB0aGlzIGhhcyB0byBiZSBhIGhlYWRlciB2YWx1ZSBvciBhbiBhcnJheSBvZiBoZWFkZXIgdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2V0dGluZyByZXF1ZXN0IGhlYWRlcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKClcbiAgICogICAuaGVhZGVycygnSGVhZGVyMScsICdWYWx1ZScpXG4gICAqICAgLmhlYWRlcnMoJ0hlYWRlcjInLCBbJ1ZhbHVlMScsICdWYWx1ZTInXSlcbiAgICogICAuaGVhZGVycyh7XG4gICAqICAgICBIZWFkZXIzOiBbJ1ZhbHVlMScsICdWYWx1ZTInXVxuICAgKiAgIH0pO1xuICAgKi9cbiAgaGVhZGVycyhoZWFkZXIsIHZhbHVlKSB7XG4gICAgY29uc3QgeyBoZWFkZXJzIH0gPSB0aGlzLiQkO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgaGVhZGVyID0geyBbaGVhZGVyXTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICBpdGVyYXRlKGhlYWRlciwgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIGNvbnN0IGFycmF5ID0gaGVhZGVyc1toZWFkZXJdIHx8IFtdO1xuICAgICAgY29uc3QgdG9QdXNoID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5cbiAgICAgIChoZWFkZXJzW2hlYWRlcl0gPSBhcnJheSkucHVzaC5hcHBseShhcnJheSwgdG9QdXNoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRmV0Y2gjaW5zdGFuY2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIE5ldyBjb25maWcgaWYgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IE5ldyBpbnN0YW5jZSBvZiBGZXRjaC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGZldGNoIGluc3RhbmNlcyBiYXNlZCBvbiBhbHJlYWR5IGV4aXN0ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBtYWluRmV0Y2ggPSBuZXcgRmV0Y2goe1xuICAgKiAgIGJhc2VVUkw6ICcvL290aGVyLmRvbWFpbi5jb20vYXBpJyxcbiAgICogICB3aXRoQ3JlZGVudGlhbHM6IHRydWVcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IGxvbmdGZXRjaCA9IG1haW5GZXRjaC5pbnN0YW5jZSh7XG4gICAqICAgdGltZW91dDogMTAwMDBcbiAgICogfSk7XG4gICAqL1xuICBpbnN0YW5jZShjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGRhdGFDb25maWcgPSBuZXcgU3VwZXIoY29uZmlnKS5oYXNPd24oJ2RhdGEnKVxuICAgICAgPyB7IGRhdGE6IGNvbmZpZy5kYXRhIH1cbiAgICAgIDoge307XG5cbiAgICBkZWxldGUgY29uZmlnLmRhdGE7XG5cbiAgICBjb25zdCBjb25mID0gbmV3IFN1cGVyKHt9KVxuICAgICAgLmRlZXBBc3NpZ24odGhpcy4kJCwgY29uZmlnKVxuICAgICAgLmFzc2lnbihkYXRhQ29uZmlnKVxuICAgICAgLiQ7XG5cbiAgICByZXR1cm4gbmV3IEZldGNoKGNvbmYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRmV0Y2gjcGF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyIGZvciB1cGxvYWRpbmcgZGF0YS5cbiAgICogQHBhcmFtIHtGZXRjaENvbmZpZ30gW2NvbmZpZ10gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgaGVhZCByZXF1ZXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEZldGNoKCkucGF0Y2goJy9kYXRhJywgeyB1c2VyOiAnSm9obicgfSkudGhlbigocmVzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcbiAgICogfSk7XG4gICAqL1xuICBwYXRjaCh1cmwsIGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiAhaXNTdHJpbmcodXJsKSkge1xuICAgICAgY29uZmlnID0gZGF0YTtcbiAgICAgIGRhdGEgPSB1cmw7XG4gICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwsIGFzc2lnbih7IG1ldGhvZDogJ3BhdGNoJywgZGF0YSB9LCBjb25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZldGNoI3Bvc3RcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyIGZvciB1cGxvYWRpbmcgZGF0YS5cbiAgICogQHBhcmFtIHtGZXRjaENvbmZpZ30gW2NvbmZpZ10gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgaGVhZCByZXF1ZXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEZldGNoKCkucG9zdCgnL2RhdGEnLCB7IHVzZXI6ICdKb2huJyB9KS50aGVuKChyZXMpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xuICAgKiB9KTtcbiAgICovXG4gIHBvc3QodXJsLCBkYXRhID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgIWlzU3RyaW5nKHVybCkpIHtcbiAgICAgIGNvbmZpZyA9IGRhdGE7XG4gICAgICBkYXRhID0gdXJsO1xuICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsLCBhc3NpZ24oeyBtZXRob2Q6ICdwb3N0JywgZGF0YSB9LCBjb25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEZldGNoI3B1dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdXJsXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXIgZm9yIHVwbG9hZGluZyBkYXRhLlxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxGZXRjaFJlc3BvbnNlLCBFcnJvcj59IFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBoZWFkIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgRmV0Y2goKS5wdXQoJy9kYXRhJywgeyB1c2VyOiAnSm9obicgfSkudGhlbigocmVzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcbiAgICogfSk7XG4gICAqL1xuICBwdXQodXJsLCBkYXRhID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgIWlzU3RyaW5nKHVybCkpIHtcbiAgICAgIGNvbmZpZyA9IGRhdGE7XG4gICAgICBkYXRhID0gdXJsO1xuICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsLCBhc3NpZ24oeyBtZXRob2Q6ICdwdXQnLCBkYXRhIH0sIGNvbmZpZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRmV0Y2gjcmVxdWVzdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdXJsXSAtIFVSTCBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gQWRkaXRpb25hbCBjb25maWcgZm9yIHRoaXMgcGFydGljdWxhciByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmVxdWVzdCByZXNwb25zZS5cbiAgICogQGRlc2NyaXB0aW9uIE1haW4gZnVuY3Rpb24gZm9yIG1ha2luZyByZXF1ZXN0cy4gQWxsIHJlcXVlc3QgbWV0aG9kcyBjYWxsIHRoaXMgbWV0aG9kXG4gICAqIGluY2x1ZGluZyB0aGUgZmV0Y2ggaW5zdGFuY2UgaXRzZWxmLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpO1xuICAgKlxuICAgKiBmZXRjaC5yZXF1ZXN0KCcvZGF0YScsIHsgdGltZW91dDogMTAwMCB9KS50aGVuKChyZXMpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xuICAgKiB9KTtcbiAgICpcbiAgICogZmV0Y2gucmVxdWVzdCh7IHRpbWVvdXQ6IDEwMDAgfSkudGhlbigocmVzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcbiAgICogfSk7XG4gICAqXG4gICAqIGZldGNoLnJlcXVlc3QoKS50aGVuKChyZXMpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xuICAgKiB9KTtcbiAgICovXG4gIHJlcXVlc3QodXJsLCBjb25maWcgPSB7fSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc1N0cmluZyh1cmwpKSB7XG4gICAgICBjb25maWcgPSB1cmw7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YUNvbmZpZyA9IG5ldyBTdXBlcihjb25maWcpLmhhc093bignZGF0YScpXG4gICAgICA/IHsgZGF0YTogY29uZmlnLmRhdGEgfVxuICAgICAgOiB7fTtcbiAgICBjb25zdCB1cmxDb25maWcgPSBpc1N0cmluZyh1cmwpXG4gICAgICA/IHsgdXJsIH1cbiAgICAgIDoge307XG5cbiAgICBkZWxldGUgY29uZmlnLmRhdGE7XG5cbiAgICBjb25zdCBjb25mID0gbmV3IFN1cGVyKHRoaXMuJCQpXG4gICAgICAuZGVlcENsb25lKClcbiAgICAgIC5kZWVwQXNzaWduKHVybENvbmZpZywgY29uZmlnKVxuICAgICAgLmFzc2lnbihkYXRhQ29uZmlnKVxuICAgICAgLiQ7XG5cbiAgICBsZXQgeGhyO1xuICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBpdGVyYXRlKGNvbmYuYmVmb3JlLCAobWlkZGxld2FyZSkgPT4ge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChtaWRkbGV3YXJlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShtaWRkbGV3YXJlKGNvbmYpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChtaWRkbGV3YXJlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUobWlkZGxld2FyZShlcnIsIGNvbmYpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZnRlcixcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIHVzZXJuYW1lLFxuICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgb25wcm9ncmVzcyxcbiAgICAgICAgcmVzcG9uc2VUeXBlLFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHdpdGhDcmVkZW50aWFsc1xuICAgICAgfSA9IGNvbmY7XG5cbiAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSwgdXNlcm5hbWUsIHBhc3N3b3JkKTtcblxuICAgICAgaXRlcmF0ZShoZWFkZXJzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob25wcm9ncmVzcykge1xuICAgICAgICBpZiAodXBsb2FkTWV0aG9kcy5pbmRleE9mU3RyaWN0KG1ldGhvZCkgPT09IC0xKSB7XG4gICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBvbnByb2dyZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IG9ucHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyBhYm9ydGVkJyk7XG5cbiAgICAgICAgZXJyb3IudHlwZSA9ICdBQk9SVF9FUlJPUic7XG5cbiAgICAgICAgcmVqZWN0KGVycm9yKTtcblxuICAgICAgICB4aHIgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJyk7XG5cbiAgICAgICAgZXJyb3IudHlwZSA9ICdORVRXT1JLX0VSUk9SJztcblxuICAgICAgICByZWplY3QoZXJyb3IpO1xuXG4gICAgICAgIHhociA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCB0aW1lIGV4Y2VlZGVkJyk7XG5cbiAgICAgICAgZXJyb3IudHlwZSA9ICdUSU1FT1VUX0VSUk9SJztcblxuICAgICAgICByZWplY3QoZXJyb3IpO1xuXG4gICAgICAgIHhociA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXhociB8fCAheGhyLnN0YXR1cyB8fCB4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgIGNvbmZpZzogY29uZixcbiAgICAgICAgICBkYXRhOiAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8geGhyLnJlc3BvbnNlVGV4dCA6IHhoci5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSxcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICB4aHJcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICAgIGl0ZXJhdGUoYWZ0ZXIsIChtaWRkbGV3YXJlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKG1pZGRsZXdhcmUocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKG1pZGRsZXdhcmUoZXJyLCByZXNwb25zZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc29sdmUocHJvbWlzZVxuICAgICAgICAgIC50aGVuKCgpID0+IHJlc3BvbnNlKVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlcnIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICB4aHIudGltZW91dCA9IE51bWJlcih0aW1lb3V0KSB8fCAwO1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhd2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICB4aHIuc2VuZChkYXRhKTtcbiAgICB9KSk7XG5cbiAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAoeGhyKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn1cblxuZGVmaW5lUHJvcGVydGllcyhGZXRjaC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdGZXRjaCdcbn0pO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBmZXRjaEJlZm9yZU1pZGRsZXdhcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBjb25maWdcbiAqIEBkZXNjcmlwdGlvbiBCdWlsdC1pbiBiZWZvcmUgbWlkZGxld2FyZSBmb3IgdXJsLCBkYXRhLCBtZXRob2QsIGhlYWRlcnMgY29uc3RydWN0aW9uLlxuICovXG5mdW5jdGlvbiBmZXRjaEJlZm9yZU1pZGRsZXdhcmUoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVVJMLFxuICAgIGRhdGEsXG4gICAgaGVhZGVycyxcbiAgICBtZXRob2QsXG4gICAgcGFyYW1zLFxuICAgIHF1ZXJ5LFxuICAgIHVybFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBNRVRIT0QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblxuICBjb25maWcubWV0aG9kID0gTUVUSE9EO1xuICBjb25maWcudXJsID0gY29uc3RydWN0VVJMKGJhc2VVUkwsIHVybCwgcGFyYW1zLCBxdWVyeSk7XG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShkYXRhLCBNRVRIT0QsIGhlYWRlcnMpO1xuICBjb25maWcuaGVhZGVycyA9IG5ldyBTdXBlcihoZWFkZXJzKS5vYmplY3QoKGhlYWRlcnMsIHZhbHVlcywgaGVhZGVyKSA9PiB7XG4gICAgaGVhZGVyID0gbmV3IFN0cihoZWFkZXIpXG4gICAgICAudG9DYXBpdGFsQ2FzZSgpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnLScpXG4gICAgICAuJDtcblxuICAgIGhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlcy5qb2luKCcsICcpO1xuICB9KS4kO1xufVxuXG4vKipcbiAqIEBjb25zdCB7RmV0Y2h9IGZldGNoXG4gKiBAdHlwZSB7RmV0Y2h9XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRW1wdHkgaW5zdGFuY2Ugb2YgRmV0Y2guXG4gKi9cbmNvbnN0IGZldGNoID0gbmV3IEZldGNoKCk7XG5cbmV4cG9ydCB7IEZldGNoLCBmZXRjaCB9O1xuIiwiLyoqXG4gKiBAbW9kdWxlIFJvdXRlclxuICogQHByaXZhdGVcbiAqIEBtaXhpblxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgUm91dGVyLlxuICovXG5cbmltcG9ydCB7IEFyciB9IGZyb20gJy4vQXJyJztcbmltcG9ydCB7IEVsZW0sIHdpbiB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBzZWxmIH0gZnJvbSAnLi9GdW5jJztcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4vU3RyJztcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4vU3dpdGNoZXInO1xuaW1wb3J0IHsgYXNzaWduLCBpc05pbCwgaXNSZWdFeHAsIGlzU3RyaW5nIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCBjb25zdHJ1Y3RVUkwgZnJvbSAnLi9oZWxwZXJzL2NvbnN0cnVjdFVSTCc7XG5pbXBvcnQgcmVzb2x2ZVVSTCBmcm9tICcuL2hlbHBlcnMvcmVzb2x2ZVVSTCc7XG5cbmNvbnN0IFJvdXRlcyA9IG5ldyBBcnIoW10pO1xuY29uc3QgY3VycmVudFJvdXRlcyA9IG5ldyBBcnIoW10pO1xuY29uc3Qgc3Vic2NyaWJlcnMgPSB7fTtcbmNvbnN0IHtcbiAgaGlzdG9yeSxcbiAgbG9jYXRpb24sXG4gIGxvY2F0aW9uOiB7XG4gICAgaHJlZjogaW5pdGlhbFVSTFxuICB9XG59ID0gZ2xvYmFsO1xubGV0IGluaXRpYWxpemVkO1xubGV0IHB1c2hlZDtcbmxldCB3YXNSb290O1xubGV0IHdhc0RlZmF1bHQ7XG5sZXQgcm9vdFJvdXRlO1xubGV0IHJlZGlyZWN0Um91dGU7XG5sZXQgcmVkaXJlY3RSb3V0ZUlzTmVlZGVkVG9QdXNoID0gZmFsc2U7XG5sZXQgUmVkaXJlY3RSb3V0ZTtcbmxldCBkZWZhdWx0Um91dGU7XG5sZXQgRGVmYXVsdFJvdXRlO1xubGV0IGN1cnJlbnRSb3V0ZTtcbmxldCBjdXJyZW50Um91dGVQYXJhbXM7XG5cbmNvbnN0IHBhdGhTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIHBhdGggbXVzdCBiZSBhIHN0cmluZywgYSByZWd1bGFyIGV4cHJlc3Npb24gb3IgdW5kZWZpbmVkISAoYXQgcmVnaXN0ZXJTdGF0ZSknKTtcbn0pXG4gIC5jYXNlKGlzUmVnRXhwLCAocGF0aCkgPT4gKHtcbiAgICBwYXRoOiBwYXRoLnNvdXJjZS5yZXBsYWNlKC9cXFxcXFwvL2csICcvJyksXG4gICAgdXJsOiBwYXRoLFxuICAgIHBhcmFtczoge31cbiAgfSkpXG4gIC5jYXNlKGlzTmlsLCAoKSA9PiAoe1xuICAgIHBhdGg6ICcvJyxcbiAgICB1cmw6ICcvJyxcbiAgICBwYXJhbXM6IHt9XG4gIH0pKVxuICAuY2FzZShpc1N0cmluZywgKHBhdGgpID0+IHtcbiAgICBpZiAocGF0aC5pbmRleE9mKCcvJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgcm91dGUgcGF0aCBpcyBhIHN0cmluZyBpdCBtdXN0IHN0YXJ0IHdpdGggXCIvXCIhIChhdCByZWdpc3RlclN0YXRlKScpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFN1cGVyKHt9KTtcbiAgICBsZXQgbmV3VVJMID0gJyc7XG4gICAgY29uc3QgbmV3UGF0aCA9IG5ldyBTdHIocGF0aClcbiAgICAgIC5zbGljZSgwLCBpbmRleCA9PT0gLTEgPyBwYXRoLmxlbmd0aCA6IGluZGV4KVxuICAgICAgLnJlcGxhY2UoL15cXC98XFwvJC9nKVxuICAgICAgLnNwbGl0KC9cXC8vKVxuICAgICAgLm1hcCgocGFydCwgaSwgYXJyYXkpID0+IHtcbiAgICAgICAgaWYgKCFwYXJ0ICYmIGFycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIHJvdXRlIHBhdGggaXMgYSBzdHJpbmcgaXQgbXVzdCBub3QgY29udGFpbiBcIi8vXCIgb3IgZW5kIHdpdGggXCIvXCIhIChhdCBtYWtlUm91dGUpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnQuaW5kZXhPZignOicpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIHJvdXRlIHBhdGggaXMgYSBzdHJpbmcgcmVzb3VyY2UgcGFydCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBVUkwgcGFyYW1ldGVyISAoYXQgbWFrZVJvdXRlKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHBhcnQsXG4gICAgICAgICAgICB2YWx1ZTogcGFydFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICByZWdleHAgPSAvW14vXSovXG4gICAgICAgIH0gPSByZXNvbHZlUGFyYW1ldGVyKFxuICAgICAgICAgIHBhcnQuc2xpY2UoMSksXG4gICAgICAgICAgJ1VSTCBwYXJhbWV0ZXIgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nIG9yIGNvbnRhaW4gY2hhcmFjdGVycyBiZXNpZGVzIFwiYS16QS1aXyRcIiEgKGF0IG1ha2VSb3V0ZSknLFxuICAgICAgICAgICdVUkwgcGFyYW1ldGVyIHJlZ2V4cCB2YWxpZGF0b3IgbXVzdCBiZSB3aXRoaW4gcGFyZW50aGVzZXMgKGUuZy4gOnVzZXJJZChcXFxcZCspIGFuZCBub3QgY29udGFpbiBvbmVzKSEgKGF0IG1ha2VSb3V0ZSknXG4gICAgICAgICk7XG5cbiAgICAgICAgcGFyYW1zLiRbbmFtZV0gPSBwYXJhbXMuY291bnQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAncGFyYW0nLFxuICAgICAgICAgIHVybDogYDokeyBuYW1lIH1gLFxuICAgICAgICAgIHZhbHVlOiByZWdleHBcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgICAud29yZCgoeyB0eXBlLCB1cmwsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgbGV0IG5ld1BhdGg7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdwYXJhbScpIHtcbiAgICAgICAgICBuZXdQYXRoID0gYCgkeyB2YWx1ZS5zb3VyY2UucmVwbGFjZSgvXFxcXFxcLy9nLCAnLycpIH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdQYXRoID0gbmV3IFN0cih2YWx1ZSkuZXNjYXBlUmVnRXhwKCkuJDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1VSTCArPSBgLyR7IHVybCB9YDtcblxuICAgICAgICByZXR1cm4gYC8keyBuZXdQYXRoIH1gO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgIHVybDogbmV3VVJMLFxuICAgICAgcGFyYW1zOiBwYXJhbXMuJFxuICAgIH07XG4gIH0pO1xuXG5jb25zdCByb3V0ZXIgPSB7XG4gIGJ1aWxkVVJMLFxuICBnbyxcbiAgZ29Ub1VSTCxcbiAgcHVzaFVSTCxcbiAgcmVkaXJlY3QsXG4gIHJlZGlyZWN0VG9VUkwsXG4gIHJlcGxhY2VVUkxcbn07XG5cbmNsYXNzIFJvdXRlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHBhdGggPSAnLycsXG4gICAgICBhYnN0cmFjdCA9IGZhbHNlLFxuICAgICAgcGFyZW50LFxuICAgICAgZGVjb2RlUXVlcnkgPSB0cnVlLFxuICAgICAgZW5jb2RlUXVlcnkgPSB0cnVlLFxuICAgICAgZGVjb2RlUGFyYW1zID0gdHJ1ZSxcbiAgICAgIGVuY29kZVBhcmFtcyA9IHRydWVcbiAgICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCB7XG4gICAgICB1cmw6IHJlbGF0aXZlVVJMLFxuICAgICAgcGF0aDogcmVsYXRpdmVQYXRoLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHBhdGhTd2l0Y2hlcihwYXRoKTtcbiAgICBjb25zdCBxdWVyeSA9IHt9O1xuXG4gICAgbmV3IFN1cGVyKHRoaXMpLmFzc2lnbih7XG4gICAgICBuYW1lLFxuICAgICAgcGFyZW50TmFtZTogcGFyZW50LFxuICAgICAgYWJzdHJhY3Q6ICEhYWJzdHJhY3QsXG4gICAgICBjaGlsZHJlbjogbmV3IEFycihbXSksXG4gICAgICBkZWNvZGVQYXJhbXM6ICEhZGVjb2RlUGFyYW1zLFxuICAgICAgZGVjb2RlUXVlcnk6ICEhZGVjb2RlUXVlcnksXG4gICAgICBlbmNvZGVQYXJhbXM6ICEhZW5jb2RlUGFyYW1zLFxuICAgICAgZW5jb2RlUXVlcnk6ICEhZW5jb2RlUXVlcnksXG4gICAgICBwYXJhbXMsXG4gICAgICBxdWVyeSxcbiAgICAgIHJlbGF0aXZlUGF0aCxcbiAgICAgIHJlbGF0aXZlVVJMXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbmRleCA9IGlzU3RyaW5nKHBhdGgpXG4gICAgICA/IHBhdGguaW5kZXhPZignPycpXG4gICAgICA6IC0xO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbmV3IFN0cihwYXRoKVxuICAgICAgICAucmVwbGFjZSgvJiQvKVxuICAgICAgICAuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAuc3BsaXQoJyYnKVxuICAgICAgICAuZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcmVnZXhwID0gL1tcXHNcXFNdKi9cbiAgICAgICAgICB9ID0gcmVzb2x2ZVBhcmFtZXRlcihcbiAgICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgICAgJ1F1ZXJ5IHBhcmFtZXRlciBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcgb3IgY29udGFpbiBjaGFyYWN0ZXJzIGJlc2lkZXMgXCJhLXpBLVpfJFwiISAoYXQgbWFrZVJvdXRlKScsXG4gICAgICAgICAgICAnUXVlcnkgcGFyYW1ldGVyIHJlZ2V4cCB2YWxpZGF0b3IgbXVzdCBiZSB3aXRoaW4gcGFyZW50aGVzZXMgKGUuZy4gOnVzZXJJZChcXFxcZCspKSBhbmQgbm90IGNvbnRhaW4gdGhlbSEgKGF0IG1ha2VSb3V0ZSknXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHF1ZXJ5W25hbWVdID0gbmV3IFJlZ0V4cChgXiR7IHJlZ2V4cC5zb3VyY2UucmVwbGFjZSgvXFxcXFxcLy9nLCAnLycpIH0kYCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBkZWZhdWx0Um91dGUgJiYgKFxuICAgICAgICBuZXcgU3VwZXIocGFyYW1zKS5jb3VudFxuICAgICAgICB8fCBuZXcgU3VwZXIocXVlcnkpLmNvdW50XG4gICAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgcm91dGUgbXVzdCBub3QgaGF2ZSBVUkwgb3IgcXVlcnkgcGFyYW1zISAoYXQgbWFrZVJvdXRlKScpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBiYXNlUm91dGUgPSBuZXcgUm91dGUoKTtcblxuZnVuY3Rpb24gaW5pdFJvdXRlcigpIHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBSZWRpcmVjdFJvdXRlID0gKFJvdXRlcy5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gcmVkaXJlY3RSb3V0ZSkgfHwge30pLnZhbHVlO1xuICBEZWZhdWx0Um91dGUgPSAoUm91dGVzLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkZWZhdWx0Um91dGUpIHx8IHt9KS52YWx1ZTtcblxuICBpZiAocmVkaXJlY3RSb3V0ZSAmJiAhUmVkaXJlY3RSb3V0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gc3BlY2lmaWVkIGZhbGxiYWNrIHJvdXRlIChcIiR7IHJlZGlyZWN0Um91dGUgfVwiKSEgKGF0IGluaXRSb3V0ZXIpYCk7XG4gIH1cblxuICBSb3V0ZXNcbiAgICAuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IHJvdXRlO1xuICAgICAgY29uc3QgUGFyZW50TmFtZSA9IHBhcmVudE5hbWUgfHwgcm9vdFJvdXRlO1xuICAgICAgY29uc3QgeyB2YWx1ZTogcGFyZW50IH0gPSBSb3V0ZXMuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IFBhcmVudE5hbWUpIHx8IHt9O1xuXG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggcGFyZW50IHJvdXRlIChcIiR7IFBhcmVudE5hbWUgfVwiKSBmb3VuZCBmb3IgdGhlIHJvdXRlIChcIiR7IG5hbWUgfVwiKSEgKGF0IGluaXRSb3V0ZXIpYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50LmFic3RyYWN0ICYmIG5hbWUgIT09IHJvb3RSb3V0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmVudCByb3V0ZSBtdXN0IGJlIGFic3RyYWN0IChmb3IgXCIkeyBuYW1lIH1cIikhIChhdCBpbml0Um91dGVyKWApO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPT0gcm9vdFJvdXRlKSB7XG4gICAgICAgIHJvdXRlLnBhcmVudE5hbWUgPSBQYXJlbnROYW1lO1xuICAgICAgfVxuXG4gICAgICByb3V0ZS5wYXJlbnQgPSBuYW1lID09PSByb290Um91dGVcbiAgICAgICAgPyBiYXNlUm91dGVcbiAgICAgICAgOiBwYXJlbnQ7XG4gICAgfSlcbiAgICAuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFyYW1zOiBwYXJlbnRQYXJhbXMsXG4gICAgICAgICAgcXVlcnk6IHBhcmVudFF1ZXJ5LFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgcmVsYXRpdmVVUkwsXG4gICAgICAgIHJlbGF0aXZlUGF0aFxuICAgICAgfSA9IHJvdXRlO1xuICAgICAgbGV0IHByb3RvID0gcm91dGU7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgbGV0IG5ld1BhdGggPSByZWxhdGl2ZVBhdGg7XG4gICAgICBsZXQgbmV3VVJMID0gJyc7XG5cbiAgICAgIGlmIChpc1JlZ0V4cChwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCByZWdleHAgcm91dGUgY2Fubm90IGJlIGV4dGVuZGVkISAoYXQgaW5pdFJvdXRlciknKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHByb3RvID0gcHJvdG8ucGFyZW50KSB7XG4gICAgICAgIGNvdW50ICs9IG5ldyBTdXBlcihwcm90by5wYXJhbXMpLmNvdW50O1xuICAgICAgICBuZXdQYXRoID0gcHJvdG8ucmVsYXRpdmVQYXRoICsgbmV3UGF0aDtcbiAgICAgICAgbmV3VVJMID0gcHJvdG8ucmVsYXRpdmVVUkwgKyBuZXdVUkw7XG5cbiAgICAgICAgcHJvdG8uY2hpbGRyZW4ucHVzaChyb3V0ZSk7XG4gICAgICB9XG5cbiAgICAgIG5ld1BhdGggPSBuZXcgUmVnRXhwKGBeJHsgbmV3UGF0aC5yZXBsYWNlKC9cXC8rL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycgfSRgKTtcbiAgICAgIG5ld1VSTCA9IGlzUmVnRXhwKHJlbGF0aXZlVVJMKVxuICAgICAgICA/IG5ld1BhdGhcbiAgICAgICAgOiAobmV3VVJMICsgcmVsYXRpdmVVUkwpLnJlcGxhY2UoL1xcLysvZywgJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJztcblxuICAgICAgbmV3IFN1cGVyKHF1ZXJ5KS5wcm90byhwYXJlbnRRdWVyeSk7XG4gICAgICBuZXcgU3VwZXIocGFyYW1zKVxuICAgICAgICAucHJvdG8ocGFyZW50UGFyYW1zKVxuICAgICAgICAuZm9yRWFjaCgodmFsdWUsIGtleSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gKz0gY291bnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAobmFtZSA9PT0gZGVmYXVsdFJvdXRlICYmIChcbiAgICAgICAgICBuZXcgU3VwZXIocGFyYW1zKS5jb3VudFxuICAgICAgICAgIHx8IG5ldyBTdXBlcihxdWVyeSkuY291bnRcbiAgICAgICAgKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgcm91dGUgbXVzdCBub3QgaGF2ZSBVUkwgb3IgcXVlcnkgcGFyYW1zISAoYXQgaW5pdFJvdXRlciknKTtcbiAgICAgIH1cblxuICAgICAgcm91dGUudXJsID0gbmV3VVJMO1xuICAgICAgcm91dGUudmFsaWRhdGVQYXRoID0gbmV3UGF0aDtcbiAgICB9KTtcblxuICBjaGFuZ2VSb3V0ZSgpO1xuXG4gIHdpbi5vbih7XG4gICAgcG9wc3RhdGUoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaHJlZiAhPT0gaW5pdGlhbFVSTCkge1xuICAgICAgICBwdXNoZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHVzaGVkKSB7XG4gICAgICAgIGNoYW5nZVJvdXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGljayhlKSB7XG4gICAgICBjb25zdCBjbG9zZXN0TGluayA9IG5ldyBFbGVtKGUudGFyZ2V0KS5jbG9zZXN0KCdhJyk7XG5cbiAgICAgIGlmIChjbG9zZXN0TGluay5sZW5ndGggJiYgY2xvc2VzdExpbmsuYXR0cigndGFyZ2V0JykgIT09ICdfYmxhbmsnICYmICFjbG9zZXN0TGluay5oYXNBdHRyKCduby1yb3V0aW5nJykpIHtcbiAgICAgICAgY29uc3QgcHVzaCA9ICFjbG9zZXN0TGluay5oYXNBdHRyKCdyZXBsYWNlJyk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGZvcndhcmQoY2xvc2VzdExpbmsuYXR0cignaHJlZicpIHx8ICcnLCBwdXNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlUm91dGUob3B0aW9ucykge1xuICByZXR1cm4gKEJsb2NrKSA9PiB7XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucywgQmxvY2sucm91dGVyT3B0aW9ucyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcGF0aCxcbiAgICAgIGFic3RyYWN0LFxuICAgICAgcm9vdCxcbiAgICAgIGZhbGxiYWNrVG8sXG4gICAgICByZXBsYWNlID0gdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGlzRGVmYXVsdFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JvdXRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZCAoYXQgbWFrZVJvdXRlKScpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBpZiAod2FzUm9vdCAmJiByb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGNhbid0IGJlIHR3byByb290IHJvdXRlcyAoXCIkeyByb290Um91dGUgfVwiIGFuZCBcIiR7IG5hbWUgfVwiKSEgKGF0IG1ha2VSb3V0ZSlgKTtcbiAgICB9XG5cbiAgICBpZiAod2FzRGVmYXVsdCAmJiBpc0RlZmF1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgY2FuJ3QgYmUgdHdvIGRlZmF1bHQgcm91dGVzIChcIiR7IGRlZmF1bHRSb3V0ZSB9XCIgYW5kIFwiJHsgbmFtZSB9XCIpISAoYXQgbWFrZVJvdXRlKWApO1xuICAgIH1cblxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBtdXN0IGhhdmUgYSBub24tZW1wdHkgc3RyaW5nIFwibmFtZVwiIHByb3BlcnR5ISAoYXQgbWFrZVJvdXRlKScpO1xuICAgIH1cblxuICAgIGlmIChSb3V0ZXMuc29tZSgoeyBuYW1lOiBOYW1lIH0pID0+IE5hbWUgPT09IG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG11c3QgaGF2ZSB1bmlxdWUgXCJuYW1lXCIgcHJvcGVydHkhIChhdCBtYWtlUm91dGUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHdhc1Jvb3QgPSB0cnVlO1xuICAgICAgcm9vdFJvdXRlID0gbmFtZTtcbiAgICAgIG9wdGlvbnMucGFyZW50ID0gbnVsbDtcblxuICAgICAgaWYgKGZhbGxiYWNrVG8pIHtcbiAgICAgICAgcmVkaXJlY3RSb3V0ZSA9IGZhbGxiYWNrVG87XG4gICAgICAgIHJlZGlyZWN0Um91dGVJc05lZWRlZFRvUHVzaCA9ICFyZXBsYWNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgIHdhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgZGVmYXVsdFJvdXRlID0gbmFtZTtcblxuICAgICAgaWYgKGFic3RyYWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCByb3V0ZSBjYW5cXCd0IGJlIGFic3RyYWN0ISAoYXQgbWFrZVJvdXRlKScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNSZWdFeHAocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHJvdXRlIGNhblxcJ3QgaGF2ZSBhIHJlZ2V4cCBwYXRoISAoYXQgbWFrZVJvdXRlKScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gbmV3IFJvdXRlKG9wdGlvbnMpO1xuXG4gICAgUm91dGVzLnB1c2gocm91dGUpO1xuXG4gICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgIGxldCByb3V0ZUxvYWRlZDtcblxuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgIC8qIGVzbGludCBwcmVmZXItdGVtcGxhdGU6IDAgKi9cbiAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZC1pZiBpZj1cIntfX3dhc1JvdXRlQWN0aXZlX199XCI+J1xuICAgICAgICArICc8ZGl2J1xuICAgICAgICArIGAgIGNsYXNzPVwiZHdheW5lLXJvdXRlIHJvdXRlLSR7IG5hbWUgKyAoYWJzdHJhY3QgPyAnIGFic3RyYWN0LXJvdXRlJyA6ICcnKSB9XCJgXG4gICAgICAgICsgJyAgZC1jbGFzcz1cInt7IFxcJ2FjdGl2ZS1yb3V0ZVxcJzogX19pc0N1cnJlbnRSb3V0ZV9fIH19XCInXG4gICAgICAgICsgJyAgZC1zaG93PVwie19faXNDdXJyZW50Um91dGVfX31cIidcbiAgICAgICAgKyAnPidcbiAgICAgICAgKyBCbG9jay50ZW1wbGF0ZVxuICAgICAgICArICc8L2Rpdj4nXG4gICAgICAgICsgJzwvZC1pZj4nO1xuXG4gICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgaW5pdFJvdXRlcigpO1xuXG4gICAgICAgICAgdGhpcy5nbG9iYWxzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19yb3V0ZXJJbnN0YW5jZV9fID0gcm91dGU7XG4gICAgICAgIHRoaXMuX19pc0N1cnJlbnRSb3V0ZV9fID0gY3VycmVudFJvdXRlcy5pbmNsdWRlcyhyb3V0ZSk7XG4gICAgICAgIHRoaXMuX193YXNSb3V0ZUFjdGl2ZV9fID0gdGhpcy5fX2lzQ3VycmVudFJvdXRlX187XG4gICAgICAgIHRoaXMuYXJncy5yb3V0ZSA9IGN1cnJlbnRSb3V0ZVBhcmFtcztcblxuICAgICAgICByb3V0ZUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB1bnN1YnNjcmliZSA9IHN1YnNjcmliZShuYW1lLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNDdXJyZW50Um91dGUgPSBhY3Rpb24gIT09ICdsZWF2ZSc7XG5cbiAgICAgICAgICB0aGlzLl9faXNDdXJyZW50Um91dGVfXyA9IGlzQ3VycmVudFJvdXRlO1xuXG4gICAgICAgICAgaWYgKGlzQ3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9fd2FzUm91dGVBY3RpdmVfXyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFyZ3Mucm91dGUgPSBjdXJyZW50Um91dGVQYXJhbXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2xvYWQnKSB7XG4gICAgICAgICAgICBjYWxsQmVmb3JlTG9hZCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgICAgY2FsbEJlZm9yZUxlYXZlKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pc0N1cnJlbnRSb3V0ZV9fKSB7XG4gICAgICAgICAgY2FsbEJlZm9yZUxvYWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYmVmb3JlUmVtb3ZlKCkge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB1bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIGNhbGxCZWZvcmVMZWF2ZSh0aGlzKTtcbiAgICAgICAgc3VwZXIuYmVmb3JlUmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGxCZWZvcmVMb2FkKHJvdXRlKSB7XG4gICAgICBpZiAocm91dGVMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9jayA9IHtcbiAgICAgICAgJCQ6IHtcbiAgICAgICAgICBjaGlsZHJlbjogbmV3IEFycihbcm91dGVdKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGV0IHdhc1JvdXRlO1xuXG4gICAgICBibG9jay4kJC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIGJlZm9yZUxvYWQoYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLl9fcm91dGVySW5zdGFuY2VfXykge1xuICAgICAgICAgIGlmICh3YXNSb3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc1JvdXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIG1peGluc1xuICAgICAgICB9ID0gYmxvY2suJCQ7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChiZWZvcmVMb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICBtaXhpbnMuZm9yRWFjaChiZWZvcmVMb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jay5iZWZvcmVMb2FkUm91dGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmxvY2suYmVmb3JlTG9hZFJvdXRlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlTG9hZDpgLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJvdXRlTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsQmVmb3JlTGVhdmUocm91dGUpIHtcbiAgICAgIGlmICghcm91dGVMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9jayA9IHtcbiAgICAgICAgJCQ6IHtcbiAgICAgICAgICBjaGlsZHJlbjogbmV3IEFycihbcm91dGVdKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGV0IHdhc1JvdXRlO1xuXG4gICAgICBibG9jay4kJC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIGJlZm9yZUxlYXZlKGJsb2NrKSB7XG4gICAgICAgIGlmIChibG9jay5fX3JvdXRlckluc3RhbmNlX18pIHtcbiAgICAgICAgICBpZiAod2FzUm91dGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3YXNSb3V0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICBtaXhpbnNcbiAgICAgICAgfSA9IGJsb2NrLiQkO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goYmVmb3JlTGVhdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1peGlucykge1xuICAgICAgICAgIG1peGlucy5mb3JFYWNoKGJlZm9yZUxlYXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jay5iZWZvcmVMZWF2ZVJvdXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJsb2NrLmJlZm9yZUxlYXZlUm91dGUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVMZWF2ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJvdXRlTG9hZGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUobmFtZSwgY2FsbGJhY2spIHtcbiAgc3Vic2NyaWJlcnNbbmFtZV0gPSBjYWxsYmFjaztcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZCh1cmwsIHB1c2gpIHtcbiAgY2hhbmdlSGlzdG9yeSh1cmwsIHB1c2gpO1xuICBjaGFuZ2VSb3V0ZSgpO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VSb3V0ZSgpIHtcbiAgY29uc3Qgcm91dGUgPSBmaW5kUm91dGVCeVVSTCgpO1xuXG4gIGlmIChyb3V0ZSkge1xuICAgICh7XG4gICAgICByb3V0ZTogY3VycmVudFJvdXRlLFxuICAgICAgLi4uY3VycmVudFJvdXRlUGFyYW1zXG4gICAgfSA9IHJvdXRlKTtcbiAgICBhc3NpZ24oY3VycmVudFJvdXRlUGFyYW1zLCB7XG4gICAgICBuYW1lOiBjdXJyZW50Um91dGUubmFtZSxcbiAgICAgIGhvc3Q6IGxvY2F0aW9uLmhvc3QsXG4gICAgICBob3N0bmFtZTogbG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICBocmVmOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgb3JpZ2luOiBsb2NhdGlvbi5vcmlnaW4sXG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBwb3J0OiBsb2NhdGlvbi5wb3J0LFxuICAgICAgcHJvdG9jb2w6IGxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgc2VhcmNoOiBsb2NhdGlvbi5zZWFyY2hcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVkaXJlY3RSb3V0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB1cmwsXG4gICAgICAgIGVuY29kZVBhcmFtcyxcbiAgICAgICAgZW5jb2RlUXVlcnlcbiAgICAgIH0gPSBSZWRpcmVjdFJvdXRlO1xuXG4gICAgICByZXR1cm4gZm9yd2FyZChjb25zdHJ1Y3RVUkwoJycsIHVybCwge30sIHt9LCAnJywge1xuICAgICAgICBwYXJhbXM6IGVuY29kZVBhcmFtcyxcbiAgICAgICAgcXVlcnk6IGVuY29kZVF1ZXJ5XG4gICAgICB9KSwgcmVkaXJlY3RSb3V0ZUlzTmVlZGVkVG9QdXNoKTtcbiAgICB9XG5cbiAgICBjdXJyZW50Um91dGUgPSBudWxsO1xuICAgIGN1cnJlbnRSb3V0ZVBhcmFtcyA9IG51bGw7XG4gIH1cblxuICBjb25zdCByb3V0ZXNUb0xlYXZlID0gbmV3IEFycihbXSk7XG4gIGNvbnN0IHJvdXRlc1RvTG9hZCA9IG5ldyBBcnIoW10pO1xuICBsZXQgcGFyZW50O1xuXG4gIHdoaWxlIChjdXJyZW50Um91dGVzLmxlbmd0aCAmJiAhcGFyZW50KSB7XG4gICAgY29uc3Qgcm91dGUgPSBjdXJyZW50Um91dGVzLnBvcCgpO1xuXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuLmluY2x1ZGVzKGN1cnJlbnRSb3V0ZSkpIHtcbiAgICAgIGN1cnJlbnRSb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICBwYXJlbnQgPSByb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVzVG9MZWF2ZS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudFJvdXRlKSB7XG4gICAgbGV0IGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50Um91dGU7XG5cbiAgICB3aGlsZSAoY3VycmVudFBhcmVudCAhPT0gcGFyZW50ICYmIGN1cnJlbnRQYXJlbnQgIT09IGJhc2VSb3V0ZSkge1xuICAgICAgcm91dGVzVG9Mb2FkLnVuc2hpZnQoY3VycmVudFBhcmVudCk7XG4gICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgY3VycmVudFJvdXRlcy5wdXNoKC4uLnJvdXRlc1RvTG9hZC4kKTtcbiAgfVxuXG4gIHJvdXRlc1RvTGVhdmUuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICBpZiAoc3Vic2NyaWJlcnNbbmFtZV0pIHtcbiAgICAgIHN1YnNjcmliZXJzW25hbWVdKCdsZWF2ZScpO1xuICAgIH1cbiAgfSk7XG4gIGN1cnJlbnRSb3V0ZXMuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IHJvdXRlO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzW25hbWVdKSB7XG4gICAgICBzdWJzY3JpYmVyc1tuYW1lXShcbiAgICAgICAgcm91dGVzVG9Mb2FkLmluY2x1ZGVzKHJvdXRlKVxuICAgICAgICAgID8gJ2xvYWQnXG4gICAgICAgICAgOiAndXBkYXRlJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kUm91dGVCeVVSTCgpIHtcbiAgY29uc3QgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCAnLyc7XG4gIGNvbnN0IHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgbGV0IHVybFBhcmFtcztcblxuICBSb3V0ZXMuc29tZSgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUuYWJzdHJhY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB1cmw6IHJvdXRlVVJMLFxuICAgICAgdmFsaWRhdGVQYXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgcXVlcnk6IHJlcXVpcmVkUXVlcnksXG4gICAgICBkZWNvZGVQYXJhbXMsXG4gICAgICBkZWNvZGVRdWVyeVxuICAgIH0gPSByb3V0ZTtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVVUkwoZGVjb2RlUXVlcnkpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFN1cGVyKHJlc29sdmVkLnF1ZXJ5KTtcbiAgICBjb25zdCBldmVudHVhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1hdGNoID0gKFxuICAgICAgKHBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKSArXG4gICAgICAoaXNSZWdFeHAocm91dGVVUkwpID8gc2VhcmNoIDogJycpXG4gICAgKS5tYXRjaCh2YWxpZGF0ZVBhdGgpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICBmb3IgKGNvbnN0IHBhcmFtIGluIHJlcXVpcmVkUXVlcnkpIHtcbiAgICAgIGlmICghcXVlcnkuaGFzT3duKHBhcmFtKSB8fCAhcmVxdWlyZWRRdWVyeVtwYXJhbV0udGVzdChxdWVyeS4kW3BhcmFtXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hdGNoLnNoaWZ0KCk7XG5cbiAgICBmb3IgKGNvbnN0IHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgZXZlbnR1YWxQYXJhbXNbcGFyYW1dID0gZGVjb2RlKG1hdGNoW3BhcmFtc1twYXJhbV1dLCBkZWNvZGVQYXJhbXMpO1xuICAgIH1cblxuICAgIHVybFBhcmFtcyA9IHtcbiAgICAgIHJvdXRlLFxuICAgICAgcGFyYW1zOiBldmVudHVhbFBhcmFtcyxcbiAgICAgIHF1ZXJ5OiBxdWVyeS4kLFxuICAgICAgaGFzaDogcmVzb2x2ZWQuaGFzaFxuICAgIH07XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHVybFBhcmFtcykge1xuICAgIHJldHVybiB1cmxQYXJhbXM7XG4gIH1cblxuICBpZiAoIWRlZmF1bHRSb3V0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm91dGU6IERlZmF1bHRSb3V0ZSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIC4uLnJlc29sdmVVUkwoRGVmYXVsdFJvdXRlLmRlY29kZVF1ZXJ5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBkZWNvZGVQYXJhbXMpIHtcbiAgcmV0dXJuIGRlY29kZVBhcmFtc1xuICAgID8gZGVjb2RlVVJJQ29tcG9uZW50KHN0cmluZylcbiAgICA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gY2hhbmdlSGlzdG9yeSh1cmwsIHB1c2gpIHtcbiAgdHJ5IHtcbiAgICBoaXN0b3J5W3B1c2ggPyAncHVzaFN0YXRlJyA6ICdyZXBsYWNlU3RhdGUnXShudWxsLCBudWxsLCB1cmwpO1xuICAgIHB1c2hlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhcmFtZXRlcihwYXJhbSwgbmFtZUVycm9yTmFtZSwgdmFsdWVFcnJvck5hbWUpIHtcbiAgY29uc3QgbmFtZU1hdGNoID0gcGFyYW0ubWF0Y2goL15bYS16XyRdKy9pKTtcblxuICBpZiAoIW5hbWVNYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lRXJyb3JOYW1lKTtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBuYW1lTWF0Y2hbMF07XG4gIGNvbnN0IHZhbHVlID0gcGFyYW0uc2xpY2UobmFtZS5sZW5ndGgpO1xuICBsZXQgcmVnZXhwO1xuXG4gIGlmICh2YWx1ZSAmJiAodmFsdWUuaW5kZXhPZignKCcpIHx8IHZhbHVlLmluZGV4T2YoJyknKSAhPT0gdmFsdWUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWVFcnJvck5hbWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgcmVnZXhwID0gbmV3IFJlZ0V4cCh2YWx1ZS5zbGljZSgxLCAtMSkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHJlZ2V4cFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFVSTChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB2YWx1ZTogcm91dGUgfSA9IFJvdXRlcy5maW5kKCh7IG5hbWU6IG4gfSkgPT4gbiA9PT0gbmFtZSkgfHwge307XG5cbiAgaWYgKCFyb3V0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgYXJlIG5vIHJvdXRlcyB3aXRoIG5hbWUgXCIkeyBuYW1lIH1cIiEgKGF0IHJvdXRlci5idWlsZFVSTClgKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgZW5jb2RlUGFyYW1zLFxuICAgIGVuY29kZVF1ZXJ5XG4gIH0gPSByb3V0ZTtcblxuICBpZiAoaXNSZWdFeHAodXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVVJMIGNhbiBiZSBidWlsdCBvbmx5IGZyb20gdGhlIHN0cmluZyBVUkxzISAoYXQgcm91dGVyLmJ1aWxkVVJMKScpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHBhcmFtcyA9IHt9LFxuICAgIHF1ZXJ5ID0ge30sXG4gICAgaGFzaCA9ICcnXG4gIH0gPSBvcHRpb25zO1xuXG4gIHJldHVybiBjb25zdHJ1Y3RVUkwoJycsIHVybCwgcGFyYW1zLCBxdWVyeSwgaGFzaCwge1xuICAgIHBhcmFtczogZW5jb2RlUGFyYW1zLFxuICAgIHF1ZXJ5OiBlbmNvZGVRdWVyeVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ28obmFtZSwgb3B0aW9ucykge1xuICBmb3J3YXJkKGJ1aWxkVVJMKG5hbWUsIG9wdGlvbnMpLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ29Ub1VSTCh1cmwpIHtcbiAgZm9yd2FyZCh1cmwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBwdXNoVVJMKHVybCkge1xuICBjaGFuZ2VIaXN0b3J5KHVybCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlZGlyZWN0KG5hbWUsIG9wdGlvbnMpIHtcbiAgZm9yd2FyZChidWlsZFVSTChuYW1lLCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIHJlZGlyZWN0VG9VUkwodXJsKSB7XG4gIGZvcndhcmQodXJsKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVVSTCh1cmwpIHtcbiAgY2hhbmdlSGlzdG9yeSh1cmwpO1xufVxuXG5leHBvcnQgeyBtYWtlUm91dGUsIHJvdXRlciB9O1xuIiwiLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG4vKiBlc2xpbnQgbm8tbmVnYXRlZC1jb25kaXRpb246IDAgKi9cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG4iLCIvKipcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2FwcGxpZWRSZWdFeHBzXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgZGlmZmVyZW50IHR5cGVzIG9mIHN5bnRheCBmb3Ige0BsaW5rIEVsZW0jYXBwbHl9LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG1hdGNoQXBwbGllZEV4cHJDYWxsYmFja1xuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gRC1lbGVtIG9mIGFuIGVsZW1lbnQgdG8gYXBwbHkgZXhwcmVzc2lvbiB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBNYXRjaGVkIGFwcGxpZWQgbmFtZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmcgLSBBcmd1bWVudCB3aXRoaW4gdGhlIHBhcmVudGhlc2VzLlxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdC48U3RyaW5nLCBtYXRjaEFwcGxpZWRFeHByQ2FsbGJhY2t8T2JqZWN0LjxTdHJpbmcsIG1hdGNoQXBwbGllZEV4cHJDYWxsYmFjaz4+fVxuICogQGRlc2NyaXB0aW9uIE9iamVjdCBvZiBkaWZmZXJlbnQgdHlwZXMgb2Ygc3ludGF4LlxuICovXG5cbmV4cG9ydCBjb25zdCBhcHBsaWVkUmVnRXhwcyA9IHtcbiAgJyMnKGVsZW0sIGlkKSB7XG4gICAgZWxlbS5pZChpZCk7XG4gIH0sXG4gICcuJyhlbGVtLCBjbHMpIHtcbiAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gIH0sXG4gICQoZWxlbSwgYXR0ciwgdmFsdWUpIHtcbiAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuICB9LFxuICAnQCcoZWxlbSwgcHJvcCwgdmFsdWUpIHtcbiAgICBlbGVtLmNzcyhwcm9wLCB2YWx1ZSk7XG4gIH0sXG4gICcmJyhlbGVtLCBuYW1lLCBodG1sKSB7XG4gICAgZWxlbS5odG1sKGh0bWwpO1xuICB9LFxuICAnKicoZWxlbSwgbmFtZSwgdGV4dCkge1xuICAgIGVsZW0udGV4dCh0ZXh0KTtcbiAgfSxcbiAgJy0nOiB7XG4gICAgJy4nKGVsZW0sIGNscykge1xuICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgIH0sXG4gICAgJChlbGVtLCBhdHRyKSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgfSxcbiAgICAnQCcoZWxlbSwgcHJvcCkge1xuICAgICAgZWxlbS5yZW1vdmVDU1MocHJvcCk7XG4gICAgfVxuICB9XG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9lbGVtZW50c1xuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRpZmZlcmVudCBjYW52YXMgbWV0aG9kcyBmb3Ige0BsaW5rIEVsZW19IGZvciBjcmVhdGluZyBodG1sLWVsZW1lbnRzLlxuICovXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7U3RyaW5nW119XG4gKi9cbmV4cG9ydCBjb25zdCBjYW52YXNHZXRNZXRob2RzID0gW1xuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY3JlYXRlSW1hZ2VEYXRhXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtJbWFnZURhdGF8dm9pZH1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NyZWF0ZUltYWdlRGF0YVxuICAgKi9cbiAgJ2NyZWF0ZUltYWdlRGF0YScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NyZWF0ZUxpbmVhckdyYWRpZW50XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtDYW52YXNHcmFkaWVudHx2b2lkfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY3JlYXRlTGluZWFyR3JhZGllbnRcbiAgICovXG4gICdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NyZWF0ZVBhdHRlcm5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0NhbnZhc1BhdHRlcm58dm9pZH1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NyZWF0ZVBhdHRlcm5cbiAgICovXG4gICdjcmVhdGVQYXR0ZXJuJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY3JlYXRlUmFkaWFsR3JhZGllbnRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0NhbnZhc0dyYWRpZW50fHZvaWR9XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jcmVhdGVSYWRpYWxHcmFkaWVudFxuICAgKi9cbiAgJ2NyZWF0ZVJhZGlhbEdyYWRpZW50JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZ2V0SW1hZ2VEYXRhXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtJbWFnZURhdGF8dm9pZH1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dldEltYWdlRGF0YVxuICAgKi9cbiAgJ2dldEltYWdlRGF0YScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dldExpbmVEYXNoXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJbXXx2b2lkfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2V0TGluZURhc2hcbiAgICovXG4gICdnZXRMaW5lRGFzaCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2lzUG9pbnRJblBhdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0Jvb2xlYW58dm9pZH1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2lzUG9pbnRJblBhdGhcbiAgICovXG4gICdpc1BvaW50SW5QYXRoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaXNQb2ludEluU3Ryb2tlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufHZvaWR9XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9pc1BvaW50SW5TdHJva2VcbiAgICovXG4gICdpc1BvaW50SW5TdHJva2UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZWFzdXJlVGV4dFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7VGV4dE1ldHJpY3N8dm9pZH1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL21lYXN1cmVUZXh0XG4gICAqL1xuICAnbWVhc3VyZVRleHQnXG5dO1xuXG5leHBvcnQgY29uc3QgY2FudmFzUmVzdE1ldGhvZHMgPSBbXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhcmNcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9hcmNcbiAgICovXG4gICdhcmMnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhcmNUb1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2FyY1RvXG4gICAqL1xuICAnYXJjVG8nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiZWdpblBhdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9iZWdpblBhdGhcbiAgICovXG4gICdiZWdpblBhdGgnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiZXppZXJDdXJ2ZVRvXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvYmV6aWVyQ3VydmVUb1xuICAgKi9cbiAgJ2JlemllckN1cnZlVG8nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjbGVhclJlY3RcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jbGVhclJlY3RcbiAgICovXG4gICdjbGVhclJlY3QnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjbGlwXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY2xpcFxuICAgKi9cbiAgJ2NsaXAnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjbG9zZVBhdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jbG9zZVBhdGhcbiAgICovXG4gICdjbG9zZVBhdGgnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkcmF3Rm9jdXNJZk5lZWRlZFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2RyYXdGb2N1c0lmTmVlZGVkXG4gICAqL1xuICAnZHJhd0ZvY3VzSWZOZWVkZWQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkcmF3SW1hZ2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9kcmF3SW1hZ2VcbiAgICovXG4gICdkcmF3SW1hZ2UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNlbGxpcHNlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZWxsaXBzZVxuICAgKi9cbiAgJ2VsbGlwc2UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmaWxsXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZmlsbFxuICAgKi9cbiAgJ2ZpbGwnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmaWxsUmVjdFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxSZWN0XG4gICAqL1xuICAnZmlsbFJlY3QnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmaWxsVGV4dFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxUZXh0XG4gICAqL1xuICAnZmlsbFRleHQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsaW5lVG9cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9saW5lVG9cbiAgICovXG4gICdsaW5lVG8nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtb3ZlVG9cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9tb3ZlVG9cbiAgICovXG4gICdtb3ZlVG8nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwdXRJbWFnZURhdGFcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9wdXRJbWFnZURhdGFcbiAgICovXG4gICdwdXRJbWFnZURhdGEnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNxdWFkcmF0aWNDdXJ2ZVRvXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcXVhZHJhdGljQ3VydmVUb1xuICAgKi9cbiAgJ3F1YWRyYXRpY0N1cnZlVG8nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNyZWN0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcmVjdFxuICAgKi9cbiAgJ3JlY3QnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNyZXNldFRyYW5zZm9ybVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3Jlc2V0VHJhbnNmb3JtXG4gICAqL1xuICAncmVzZXRUcmFuc2Zvcm0nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNyZXN0b3JlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcmVzdG9yZVxuICAgKi9cbiAgJ3Jlc3RvcmUnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNyb3RhdGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9yb3RhdGVcbiAgICovXG4gICdyb3RhdGUnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzYXZlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2F2ZVxuICAgKi9cbiAgJ3NhdmUnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzY2FsZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NjYWxlXG4gICAqL1xuICAnc2NhbGUnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzZXRMaW5lRGFzaFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoXG4gICAqL1xuICAnc2V0TGluZURhc2gnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzZXRUcmFuc2Zvcm1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRUcmFuc2Zvcm1cbiAgICovXG4gICdzZXRUcmFuc2Zvcm0nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHJva2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zdHJva2VcbiAgICovXG4gICdzdHJva2UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHJva2VSZWN0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc3Ryb2tlUmVjdFxuICAgKi9cbiAgJ3N0cm9rZVJlY3QnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHJva2VUZXh0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc3Ryb2tlVGV4dFxuICAgKi9cbiAgJ3N0cm9rZVRleHQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0cmFuc2Zvcm1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC90cmFuc2Zvcm1cbiAgICovXG4gICd0cmFuc2Zvcm0nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0cmFuc2xhdGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC90cmFuc2xhdGVcbiAgICovXG4gICd0cmFuc2xhdGUnXG5dO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9jb25zdHJ1Y3RvcnNcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBjb25zdHJ1Y3RvcnMgbGV2ZWxzLlxuICovXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXlbXX1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0cnVjdG9ycyA9IFtcbiAgW10sXG4gIFtdLFxuICBbXVxuXTtcbiIsIi8qKlxuICogQG1vZHVsZSBjb25zdGFudHMvZWxlbWVudHNcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBtZXRob2RzIGZvciB7QGxpbmsgRWxlbX0gZm9yIGNyZWF0aW5nIGh0bWwtZWxlbWVudHMuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtTdHJpbmdbXX1cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWxFbGVtZW50cyA9IFtcbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2EnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhYmJyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdhYmJyJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWRkcmVzc1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnYWRkcmVzcycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FyZWFcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2FyZWEnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhcnRpY2xlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdhcnRpY2xlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYXVkaW9cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2F1ZGlvJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnYicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Jhc2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2Jhc2UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiZGlcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2JkaScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Jkb1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnYmRvJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYmxvY2txdW90ZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnYmxvY2txdW90ZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2JvZHlcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2JvZHknLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnYnInLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNidXR0b25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2J1dHRvbicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NhbnZhc1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnY2FudmFzJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2FwdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnY2FwdGlvbicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NpdGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2NpdGUnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjb2RlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdjb2RlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29sXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdjb2wnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjb2xncm91cFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnY29sZ3JvdXAnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjb250ZW50XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdjb250ZW50JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGF0YWxpc3RcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2RhdGFsaXN0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2RkJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGVsXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdkZWwnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkZXRhaWxzXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdkZXRhaWxzJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGZuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdkZm4nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkaWFsb2dcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2RpYWxvZycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RpdlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZGl2JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2RsJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2R0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZWxlbWVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZWxlbWVudCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2VtXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdlbScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2VtYmVkXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdlbWJlZCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpZWxkc2V0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmaWVsZHNldCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpZ2NhcHRpb25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZpZ2NhcHRpb24nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmaWd1cmVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZpZ3VyZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Zvb3RlclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZm9vdGVyJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9ybVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZm9ybScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2gxXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoMScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2gyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoMicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2gzXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoMycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2g0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoNCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2g1XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoNScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2g2XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoNicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hlYWRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2hlYWQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoZWFkZXJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2hlYWRlcicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hncm91cFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnaGdyb3VwJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2hyJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnaScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2lmcmFtZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnaWZyYW1lJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaW1nXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdpbWcnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpbnB1dFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnaW5wdXQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpbnNcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2lucycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2tiZFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAna2JkJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGFiZWxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2xhYmVsJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGVnZW5kXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdsZWdlbmQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsaVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbGknLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsaW5rXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdsaW5rJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWFpblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWFpbicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21hcmtcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ21hcmsnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZW51XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdtZW51JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVudWl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ21lbnVpdGVtJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWV0YVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWV0YScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21ldGVyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdtZXRlcicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI25hdlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbmF2JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbm9zY3JpcHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ25vc2NyaXB0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jb2xcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ29sJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jb3B0Z3JvdXBcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ29wdGdyb3VwJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jb3B0aW9uXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdvcHRpb24nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNvdXRwdXRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ291dHB1dCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3AnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwYXJhbVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAncGFyYW0nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwcmVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3ByZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Byb2dyZXNzXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdwcm9ncmVzcycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3FcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3EnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNycFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAncnAnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNydFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAncnQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNydGNcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3J0YycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3J1YnlcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3J1YnknLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdzJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2FtcFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc2FtcCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NjcmlwdFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc2NyaXB0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2VjdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc2VjdGlvbicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NlbGVjdFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc2VsZWN0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2hhZG93XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdzaGFkb3cnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzbWFsbFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc21hbGwnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzb3VyY2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3NvdXJjZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NwYW5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3NwYW4nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHJvbmdcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3N0cm9uZycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N0eWxlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdzdHlsZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N1YlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc3ViJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3VtbWFyeVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc3VtbWFyeScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N1cFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc3VwJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGFibGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RhYmxlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGJvZHlcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3Rib2R5JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RkJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGVtcGxhdGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RlbXBsYXRlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGV4dGFyZWFcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RleHRhcmVhJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGZvb3RcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3Rmb290JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGhlYWRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RoZWFkJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGltZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAndGltZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RpdGxlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICd0aXRsZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICd0cicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RyYWNrXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICd0cmFjaycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN1bFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAndWwnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN2YXJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3ZhcicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3ZpZGVvXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICd2aWRlbycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3diclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnd2JyJ1xuXTtcblxuZXhwb3J0IGNvbnN0IHN2Z0VsZW1lbnRzID0gW1xuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWx0R2x5cGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2FsdEdseXBoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWx0R2x5cGhEZWZcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2FsdEdseXBoRGVmJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWx0R2x5cGhJdGVtXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdhbHRHbHlwaEl0ZW0nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhbmltYXRlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdhbmltYXRlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYW5pbWF0ZUNvbG9yXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdhbmltYXRlQ29sb3InLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhbmltYXRlTW90aW9uXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdhbmltYXRlTW90aW9uJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYW5pbWF0ZVRyYW5zZm9ybVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnYW5pbWF0ZVRyYW5zZm9ybScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NpcmNsZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnY2lyY2xlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2xpcFBhdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2NsaXBQYXRoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29sb3JQcm9maWxlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdjb2xvci1wcm9maWxlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY3Vyc29yXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdjdXJzb3InLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkZWZzXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdkZWZzJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGVzY1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZGVzYycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Rpc2NhcmRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2Rpc2NhcmQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNlbGxpcHNlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdlbGxpcHNlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVCbGVuZFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVCbGVuZCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlQ29sb3JNYXRyaXhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZlQ29sb3JNYXRyaXgnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUNvbXBvbmVudFRyYW5zZmVyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVDb21wb3NpdGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZlQ29tcG9zaXRlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVDb252b2x2ZU1hdHJpeFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVDb252b2x2ZU1hdHJpeCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRGlmZnVzZUxpZ2h0aW5nXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZURpZmZ1c2VMaWdodGluZycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRGlzcGxhY2VtZW50TWFwXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZURpc3BsYWNlbWVudE1hcCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRGlzdGFudExpZ2h0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZURpc3RhbnRMaWdodCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRHJvcFNoYWRvd1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVEcm9wU2hhZG93JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVGbG9vZFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVGbG9vZCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRnVuY0FcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZlRnVuY0EnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUZ1bmNCXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZUZ1bmNCJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVGdW5jR1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVGdW5jRycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRnVuY1JcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZlRnVuY1InLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUdhdXNzaWFuQmx1clxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVHYXVzc2lhbkJsdXInLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUltYWdlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZUltYWdlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVNZXJnZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVNZXJnZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlTWVyZ2VOb2RlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZU1lcmdlTm9kZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlTW9ycGhvbG9neVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVNb3JwaG9sb2d5JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVPZmZzZXRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZlT2Zmc2V0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVQb2ludExpZ2h0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZVBvaW50TGlnaHQnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZVNwZWN1bGFyTGlnaHRpbmdcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlU3BvdExpZ2h0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZVNwb3RMaWdodCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlVGlsZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZmVUaWxlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVUdXJidWxlbmNlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmZVR1cmJ1bGVuY2UnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb250XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmb250JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZvbnQtZmFjZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZvbnRGYWNlRm9ybWF0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmb250LWZhY2UtZm9ybWF0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VOYW1lXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmb250LWZhY2UtbmFtZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZvbnRGYWNlU3JjXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmb250LWZhY2Utc3JjJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VVcmlcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ZvbnQtZmFjZS11cmknLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb3JlaWduT2JqZWN0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdmb3JlaWduT2JqZWN0JyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZ1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnZycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dseXBoXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdnbHlwaCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dseXBoUmVmXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdnbHlwaFJlZicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hhdGNoXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdoYXRjaCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hhdGNocGF0aFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnaGF0Y2hwYXRoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaGtlcm5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2hrZXJuJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaW1hZ2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ2ltYWdlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGluZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbGluZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2xpbmVhckdyYWRpZW50XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdsaW5lYXJHcmFkaWVudCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21hcmtlclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWFya2VyJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWFza1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWFzaycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lc2hcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ21lc2gnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZXNoZ3JhZGllbnRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ21lc2hncmFkaWVudCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lc2hwYXRjaFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWVzaHBhdGNoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVzaHJvd1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWVzaHJvdycsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21ldGFkYXRhXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdtZXRhZGF0YScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21pc3NpbmdHbHlwaFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnbWlzc2luZy1nbHlwaCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21wYXRoXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdtcGF0aCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BhdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3BhdGgnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwYXR0ZXJuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdwYXR0ZXJuJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcG9seWdvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAncG9seWdvbicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BvbHlsaW5lXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdwb2x5bGluZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JhZGlhbEdyYWRpZW50XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdyYWRpYWxHcmFkaWVudCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JlY3RcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3JlY3QnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzZXRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3NldCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NvbGlkY29sb3JcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3NvbGlkY29sb3InLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdG9wXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdzdG9wJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3R5bGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3N0eWxlJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3ZnXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICdzdmcnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzd2l0Y2hcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3N3aXRjaCcsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N5bWJvbFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAnc3ltYm9sJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGV4dFBhdGhcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3RleHRQYXRoJyxcblxuICAvKipcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdHJlZlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAndHJlZicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RzcGFuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICovXG4gICd0c3BhbicsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Vua25vd25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3Vua25vd24nLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN1c2VcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3VzZScsXG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3ZpZXdcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKi9cbiAgJ3ZpZXcnLFxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN2a2VyblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcbiAgICogQHJldHVybnMge0VsZW19XG4gICAqL1xuICAndmtlcm4nXG5dO1xuXG5leHBvcnQgY29uc3Qgdm9pZEVsZW1lbnRzID0gW1xuICAnYXJlYScsXG4gICdiYXNlJyxcbiAgJ2JyJyxcbiAgJ2NvbCcsXG4gICdjb21tYW5kJyxcbiAgJ2VtYmVkJyxcbiAgJ2hyJyxcbiAgJ2ltZycsXG4gICdpbnB1dCcsXG4gICdrZXlnZW4nLFxuICAnbGluaycsXG4gICdtZXRhJyxcbiAgJ3BhcmFtJyxcbiAgJ3NvdXJjZScsXG4gICd0cmFjaycsXG4gICd3YnInLFxuXG4gICdwYXRoJyxcbiAgJ2NpcmNsZScsXG4gICdlbGxpcHNlJyxcbiAgJ2xpbmUnLFxuICAncmVjdCcsXG4gICd1c2UnLFxuICAnc3RvcCcsXG4gICdwb2x5bGluZScsXG4gICdwb2x5Z29uJ1xuXTtcbiIsImV4cG9ydCBjb25zdCBodG1sQWxsb3dlZFRhZ1N5bWJvbHMgPSAnW2Etel1bYS16XFxcXGRcXFxcLV8uOiFAI1xcXFwkJVxcXFxeJiooKVxcXFxbXFxcXF17fVxcXFxcXFxcPVxcJ1wiXSonO1xuZXhwb3J0IGNvbnN0IGh0bWxBbGxvd2VkQXR0clN5bWJvbHMgPSAnW15cXFxcdTAwMDAtXFxcXHUwMDIwXFxcXHNcIlxcJz4vPV0rJztcbiIsIi8qKlxuICogQG1vZHVsZSBjb25zdGFudHMvcmVnZXhwU3BlY2lhbENoYXJhY3RlcnNcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIFJlZ0V4cC5cbiAqL1xuXG4vKipcbiAqIEBjb25zdFxuICogQG5hbWUgbW9kdWxlOmNvbnN0YW50cy9yZWdleHBTcGVjaWFsQ2hhcmFjdGVyc35yZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xuICogQHR5cGUge1N0cmluZ1tdfVxuICovXG5leHBvcnQgY29uc3QgcmVnZXhwU3BlY2lhbENoYXJhY3RlcnMgPSBbXG4gICcuJyxcbiAgJysnLCAnKicsICc/JyxcbiAgJygnLCAnKScsXG4gICdbJywgJ10nLFxuICAneycsICd9JyxcbiAgJzwnLCAnPicsXG4gICdeJywgJyQnLFxuICAnIScsXG4gICc9JyxcbiAgJzonLFxuICAnLScsXG4gICd8JyxcbiAgJywnLFxuICAnXFxcXCdcbl07XG4iLCIvKipcbiAqIEBtb2R1bGUgY29uc3RhbnRzL3ZhbGlkYXRlQ2hlY2tFeHByZXNzaW9uc1xuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRpZmZlcmVudCB0eXBlcyBvZiB2YWxpZGF0ZSBleHByZXNzaW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpoZWxwZXJzL3ZhbGlkYXRlfS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBtZXRob2RzIGZyb20gJy4uL2hlbHBlcnMvY2hlY2tUeXBlcyc7XG5cbi8qKlxuICogQGNhbGxiYWNrIGNoZWNrVmFsaWRpdHlDYWxsYmFja1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjay5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZhbGlkYXRlRXhwclxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0ZXh0IC0gVGV4dCBvZiB0aGUgdGhyb3duIGVycm9yLlxuICogQHByb3BlcnR5IHtFcnJvcn0gZXJyb3IgLSBUeXBlIG9mIHRoZSB0aHJvd24gZXJyb3IuXG4gKiBAcHJvcGVydHkge2NoZWNrVmFsaWRpdHlDYWxsYmFja30gY2hlY2sgLSBDYWxsYmFjayBmb3IgY2hlY2tpbmcgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7dmFsaWRhdGVFeHByW119XG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIE9iamVjdCBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQ2hlY2tFeHByZXNzaW9ucyA9IHtcbiAgJz4wJzoge1xuICAgIGNoZWNrOiAobikgPT4gbiA+IDAsXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgcG9zaXRpdmUhJyxcbiAgICBlcnJvcjogUmFuZ2VFcnJvclxuICB9LFxuICAnPj0wJzoge1xuICAgIGNoZWNrOiAobikgPT4gbiA+PSAwLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIG5vbi1uZWdhdGl2ZSEnLFxuICAgIGVycm9yOiBSYW5nZUVycm9yXG4gIH0sXG4gICc8MCc6IHtcbiAgICBjaGVjazogKG4pID0+IG4gPCAwLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIG5lZ2F0aXZlIScsXG4gICAgZXJyb3I6IFJhbmdlRXJyb3JcbiAgfSxcbiAgJzw9MCc6IHtcbiAgICBjaGVjazogKG4pID0+IG4gPD0gMCxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBub24tcG9zaXRpdmUhJyxcbiAgICBlcnJvcjogUmFuZ2VFcnJvclxuICB9LFxuICAnISEnOiB7XG4gICAgY2hlY2s6ICh2KSA9PiAhbWV0aG9kcy5pc05pbCh2KSxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBub3QgbnVsbCBvciB1bmRlZmluZWQhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIGFycmF5OiB7XG4gICAgY2hlY2s6IG1ldGhvZHMuaXNBcnJheSxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSEnLFxuICAgIGVycm9yOiBUeXBlRXJyb3JcbiAgfSxcbiAgJ2FycmF5fHwhJzoge1xuICAgIGNoZWNrOiAoYSkgPT4gbWV0aG9kcy5pc0FycmF5KGEpIHx8IG1ldGhvZHMuaXNOaWwoYSksXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXksIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxuICAgIGVycm9yOiBUeXBlRXJyb3JcbiAgfSxcbiAgYXJyYXlMaWtlOiB7XG4gICAgY2hlY2s6IG1ldGhvZHMuaXNBcnJheUxpa2UsXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYXJyYXktbGlrZSEnLFxuICAgIGVycm9yOiBUeXBlRXJyb3JcbiAgfSxcbiAgJ2FycmF5TGlrZXx8ISc6IHtcbiAgICBjaGVjazogKGEpID0+IG1ldGhvZHMuaXNBcnJheUxpa2UoYSkgfHwgbWV0aG9kcy5pc05pbChhKSxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhcnJheS1saWtlLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIGRhdGU6IHtcbiAgICBjaGVjazogbWV0aG9kcy5pc0RhdGUsXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBkYXRlIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICAnZGF0ZXx8ISc6IHtcbiAgICBjaGVjazogKGQpID0+IG1ldGhvZHMuaXNEYXRlKGQpIHx8IG1ldGhvZHMuaXNOaWwoZCksXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBkYXRlLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIGRhdGVMaWtlOiB7XG4gICAgY2hlY2s6IG1ldGhvZHMuaXNEYXRlTGlrZSxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBkYXRlLWxpa2UhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gICdkYXRlTGlrZXx8ISc6IHtcbiAgICBjaGVjazogKGQpID0+IG1ldGhvZHMuaXNEYXRlTGlrZShkKSB8fCBtZXRob2RzLmlzTmlsKGQpLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGRhdGUtbGlrZSwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICBmdW5jdGlvbjoge1xuICAgIGNoZWNrOiBtZXRob2RzLmlzRnVuY3Rpb24sXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiEnLFxuICAgIGVycm9yOiBUeXBlRXJyb3JcbiAgfSxcbiAgJ2Z1bmN0aW9ufHwhJzoge1xuICAgIGNoZWNrOiAoZikgPT4gbWV0aG9kcy5pc0Z1bmN0aW9uKGYpIHx8IG1ldGhvZHMuaXNOaWwoZiksXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICBpbnQ6IHtcbiAgICBjaGVjazogbWV0aG9kcy5pc0ludGVnZXIsXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciEnLFxuICAgIGVycm9yOiBUeXBlRXJyb3JcbiAgfSxcbiAgJ2ludHx8ISc6IHtcbiAgICBjaGVjazogKGkpID0+IG1ldGhvZHMuaXNJbnRlZ2VyKGkpIHx8IG1ldGhvZHMuaXNOaWwoaSksXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICBpbnRMaWtlOiB7XG4gICAgY2hlY2s6IG1ldGhvZHMuaXNJbnRlZ2VyTGlrZSxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBpbnRlZ2VyLWxpa2UhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gICdpbnRMaWtlfHwhJzoge1xuICAgIGNoZWNrOiAoaSkgPT4gbWV0aG9kcy5pc0ludGVnZXJMaWtlKGkpIHx8IG1ldGhvZHMuaXNOaWwoaSksXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgaW50ZWdlci1saWtlLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIG51bWJlcjoge1xuICAgIGNoZWNrOiBtZXRob2RzLmlzTnVtYmVyLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICAnbnVtYmVyfHwhJzoge1xuICAgIGNoZWNrOiAobikgPT4gbWV0aG9kcy5pc051bWJlcihuKSB8fCBtZXRob2RzLmlzTmlsKG4pLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIG51bWJlckxpa2U6IHtcbiAgICBjaGVjazogbWV0aG9kcy5pc051bWJlckxpa2UsXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbnVtYmVyLWxpa2UhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gICdudW1iZXJMaWtlfHwhJzoge1xuICAgIGNoZWNrOiAobikgPT4gbWV0aG9kcy5pc051bWJlckxpa2UobikgfHwgbWV0aG9kcy5pc05pbChuKSxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBudW1iZXItbGlrZSwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICBvYmplY3Q6IHtcbiAgICBjaGVjazogbWV0aG9kcy5pc09iamVjdCxcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gICdvYmplY3R8fCEnOiB7XG4gICAgY2hlY2s6IChvKSA9PiBtZXRob2RzLmlzT2JqZWN0KG8pIHx8IG1ldGhvZHMuaXNOaWwobyksXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIHJlZ2V4cDoge1xuICAgIGNoZWNrOiBtZXRob2RzLmlzUmVnRXhwLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgcmVndWxhciBleHByZXNzaW9uIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICAncmVnZXhwfHwhJzoge1xuICAgIGNoZWNrOiAocikgPT4gbWV0aG9kcy5pc1JlZ0V4cChyKSB8fCBtZXRob2RzLmlzTmlsKHIpLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgcmVndWxhciBleHByZXNzaW9uLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH0sXG4gIHN0cmluZzoge1xuICAgIGNoZWNrOiBtZXRob2RzLmlzU3RyaW5nLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIScsXG4gICAgZXJyb3I6IFR5cGVFcnJvclxuICB9LFxuICAnc3RyaW5nfHwhJzoge1xuICAgIGNoZWNrOiAocykgPT4gbWV0aG9kcy5pc1N0cmluZyhzKSB8fCBtZXRob2RzLmlzTmlsKHMpLFxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcbiAgICBlcnJvcjogVHlwZUVycm9yXG4gIH1cbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy9TeW1ib2xcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBTeW1ib2wgY2xhc3MuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgfHwge1xuICB0b1N0cmluZ1RhZzogJ1N5bWJvbC50b1N0cmluZ1RhZycsXG4gIGl0ZXJhdG9yOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KVxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBQcm9taXNlXG4gKiBAcHJpdmF0ZVxuICogQG1peGluXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBQcm9taXNlIGNsYXNzLlxuICovXG5cbmltcG9ydCB7IGlzRnVuY3Rpb24sIGRlZmluZVByb3BlcnRpZXMsIFN5bWJvbCB9IGZyb20gJy4vaGVscGVycyc7XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uRnVsZmlsbGVkT3JSZWplY3RlZFxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFByb21pc2UgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1Y2Nlc3MgLSBJZiB0aGUgcHJldmlvdXMgcHJvbWlzZSBpcyBmdWxmaWxsZWQgaXQncyB0cnVlIGFuZCBmYWxzZSBpZiByZWplY3RlZC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblJlamVjdGVkXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Vycm9yfCp9IGVyciAtIFByb21pc2UgZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25GdWxmaWxsZWRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBQcm9taXNlIHZhbHVlLlxuICovXG5cbmNvbnN0IHNlY3JldCA9IHt9O1xuY29uc3QgaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG5cbi8qKlxuICogQGNsYXNzIFByb21pc2VcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIC0gRnVuY3Rpb24gdGhhdCB0YWtlcyB0d28gYXJndW1lbnRzOiByZXNvbHZlIGFuZCByZWplY3QgZnVuY3Rpb25zLlxuICogQ2FsbCB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB3aGVuIHlvdSBuZWVkIHRvIGZ1bGZpbGwgdGhlIHByb21pc2UgYW5kIGNhbGwgdGhlIHJlamVjdCBvbmVcbiAqIHdoZW4geW91IG5lZWQgdG8gcmVqZWN0IGl0LlxuICogQHJldHVybnMge1Byb21pc2V9IEluc3RhbmNlIG9mIFByb21pc2UuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2VcbiAqIEBkZXNjcmlwdGlvbiBDbGFzcyB3aXRoIGFsbW9zdCBpZGVudGljYWwgQVBJIHRvXG4gKiBbRVM2IFByb21pc2Vde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2V9LlxuICogVGhlcmUgaXMgYSBjb3VwbGUgZGlmZmVyZW5jZXM6IHNldCBQcm9taXNlLm9uRXJyb3IgdG8gYSBmdW5jdGlvbiB3aXRoIHdoaWNoIHlvdSB3YW50IHRvXG4gKiBzdWJzY3JpYmUgdG8gYSBwcm9taXNlIGVycm9yIGFuZCBzZXQgUHJvbWlzZS5vblVuaGFuZGxlZFJlamVjdGlvbiB0byBhIGZ1bmN0aW9uIHdpdGggd2hpY2hcbiAqIHlvdSB3YW50IHRvIHN1YnNjcmliZSB0byBhbiB1bmhhbmRsZWQgZXJyb3JcbiAqIChkZWZhdWx0cyB0byBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgJyVzICVvJywgJ1VuY2F1Z2h0IChpbiBwcm9taXNlKScpKS5cbiAqL1xuY2xhc3MgUHJvbWlzZSB7XG4gIHN0YXRpYyBvbkVycm9yID0gbnVsbDtcbiAgc3RhdGljIG9uVW5oYW5kbGVkUmVqZWN0aW9uID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUsICclcyAlbycsICdVbmNhdWdodCAoaW4gcHJvbWlzZSknKTtcblxuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICghaXNGdW5jdGlvbihleGVjdXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb21pc2UgcmVzb2x2ZXIgJHsge30udG9TdHJpbmcuY2FsbChleGVjdXRvcikgfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICAgIH1cblxuICAgIGxldCBoaWRkZW5TdGF0dXM7XG4gICAgbGV0IGhpZGRlblZhbHVlO1xuXG4gICAgY29uc3RcdG9uRnVsZmlsbCA9IFtdO1xuICAgIGNvbnN0IG9uUmVqZWN0ID0gW107XG4gICAgY29uc3QgcmVhbFByb21pc2UgPSB0aGlzO1xuICAgIGNvbnN0IGhpZGRlblByb21pc2UgPSB7XG4gICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBoaWRkZW5TdGF0dXM7XG4gICAgICB9LFxuICAgICAgc2V0IHN0YXR1cyh2YWx1ZSkge1xuICAgICAgICBoaWRkZW5TdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgcmVhbFByb21pc2Uuc3RhdHVzID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gaGlkZGVuVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0IHZhbHVlKHZhbCkge1xuICAgICAgICBoaWRkZW5WYWx1ZSA9IHZhbDtcbiAgICAgICAgcmVhbFByb21pc2UudmFsdWUgPSB2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhpZGRlblByb21pc2Uuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgIGhpZGRlblByb21pc2UudmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBoaWRkZW5Qcm9taXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBoYW5kbGVkIC0gSWYgdGhlIHByb21pc2UgaXMgaGFuZGxlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHsncGVuZGluZyd8J2Z1bGZpbGxlZCd8J3JlamVjdGVkJ30gc3RhdHVzIC0gU3RhdHVzIG9mIHRoZSBwcm9taXNlLlxuICAgICAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBoaWRkZW5Qcm9taXNlI2hhbmRsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsoJ3JlamVjdCd8J3Jlc29sdmUnKX0gZXZlbnQgLSBUeXBlIG9mIHRoZSBldmVudCB0byBoYW5kbGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIEhhbmRsZXIgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgLSBSZXNvbHZlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCAtIFJlamVjdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VjcmV0IC0gU2VjcmV0LlxuICAgICAqIEBkZXNjcmlwdGlvbiBQcml2YXRlIG1ldGhvZCBmb3IgaGFuZGxpbmcgcHJvbWlzZXMuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtoaWRkZW5Qcm9taXNlfSBQcm9taXNlIyQkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRlZmluZVByb3BlcnRpZXModGhpcy4kJCA9IHt9LCB7XG4gICAgICAnZ2V0L3NldCBoYW5kbGVkJzoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGhpZGRlblByb21pc2UuaGFuZGxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSkge1xuICAgICAgICAgIGlmIChrZXkgPT09IHNlY3JldCkge1xuICAgICAgICAgICAgaGlkZGVuUHJvbWlzZS5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGUoc3RhdHVzLCBmLCByZXNvbHZlLCByZWplY3QsIGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSBzZWNyZXQpIHtcbiAgICAgICAgICBjb25zdCBwcm94eSA9IGlzRnVuY3Rpb24oZikgPyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZih2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiBudWxsO1xuXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3Jlc29sdmUnKSB7XG4gICAgICAgICAgICBvbkZ1bGZpbGwucHVzaChwcm94eSB8fCAoKHZhbHVlKSA9PiByZXNvbHZlKHZhbHVlKSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgb25SZWplY3QucHVzaChwcm94eSB8fCAoKGVycikgPT4gcmVqZWN0KGVycikpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnZ2V0IHN0YXR1cycoKSB7XG4gICAgICAgIHJldHVybiBoaWRkZW5Qcm9taXNlLnN0YXR1cztcbiAgICAgIH0sXG4gICAgICAnZ2V0IHZhbHVlJygpIHtcbiAgICAgICAgcmV0dXJuIGhpZGRlblByb21pc2UudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdChlcnIpIHtcbiAgICAgIGlmIChoaWRkZW5Qcm9taXNlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIGhpZGRlblByb21pc2Uuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgaGlkZGVuUHJvbWlzZS52YWx1ZSA9IGVycjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gb25SZWplY3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoaWRkZW5Qcm9taXNlLmhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgb25SZWplY3RbaV0oZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvblVuaGFuZGxlZFJlamVjdGlvbixcbiAgICAgICAgICBvbkVycm9yXG4gICAgICAgIH0gPSBQcm9taXNlO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uRXJyb3IpKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFoaWRkZW5Qcm9taXNlLmhhbmRsZWQgJiYgaXNGdW5jdGlvbihvblVuaGFuZGxlZFJlamVjdGlvbikpIHtcbiAgICAgICAgICAgIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICBpZiAoaGlkZGVuUHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICBpZiAodmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS50aGVuKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBoaWRkZW5Qcm9taXNlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICBoaWRkZW5Qcm9taXNlLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG9uRnVsZmlsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhpZGRlblByb21pc2UuaGFuZGxlZCA9IHRydWU7XG5cbiAgICAgICAgICBvbkZ1bGZpbGxbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgUHJvbWlzZS5hbGxcbiAgICogQHBhcmFtIHsoQXJyYXl8SXRlcmFibGUpLjxQcm9taXNlfCo+fSBpdGVyYWJsZSAtIEl0ZXJhYmxlIG9iamVjdCAobGlrZSBhcnJheSkgb2YgcHJvbWlzZXNcbiAgICogb3IgYW55IHZhbHVlcy5cbiAgICogQHJldHVybnMge1Byb21pc2V9IE5ldyBpbnN0YW5jZSBvZiBQcm9taXNlLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvYWxsXG4gICAqL1xuICBzdGF0aWMgYWxsKGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGxldCB0b1Jlc29sdmUgPSAwO1xuXG4gICAgaWYgKGl0ZXJhYmxlW2l0ZXJhdG9yXSkge1xuICAgICAgaXRlcmFibGUgPSBpdGVyYWJsZVtpdGVyYXRvcl0oKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICB3aGlsZSAoIShuZXh0ID0gaXRlcmFibGUubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXh0LnZhbHVlKTtcblxuICAgICAgICAgIHRvUmVzb2x2ZSsrO1xuXG4gICAgICAgICAgKChpKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHRvUmVzb2x2ZS0tO1xuICAgICAgICAgICAgICBhcnJheVtpXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUgJiYgIXRvUmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgfSkoaSsrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgdG9SZXNvbHZlID0gbGVuZ3RoO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpdGVyYWJsZVtpXSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRvUmVzb2x2ZS0tO1xuICAgICAgICAgIGFycmF5W2ldID0gdmFsdWU7XG5cbiAgICAgICAgICBpZiAoIXRvUmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgUHJvbWlzZS5yYWNlXG4gICAqIEBwYXJhbSB7KEFycmF5fEl0ZXJhYmxlKS48UHJvbWlzZXwqPn0gaXRlcmFibGUgLSBJdGVyYWJsZSBvYmplY3QgKGxpa2UgYXJyYXkpIG9mIHByb21pc2VzXG4gICAqIG9yIGFueSB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL3JhY2VcbiAgICovXG4gIHN0YXRpYyByYWNlKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlW2l0ZXJhdG9yXSkge1xuICAgICAgaXRlcmFibGUgPSBpdGVyYWJsZVtpdGVyYXRvcl0oKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IG5leHQ7XG5cbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IGl0ZXJhYmxlLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIG5leHQudmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGl0ZXJhYmxlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhYmxlW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFByb21pc2UucmVqZWN0XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byByZWplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL3JlamVjdFxuICAgKi9cbiAgc3RhdGljIHJlamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZWplY3QodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgUHJvbWlzZS5yZXNvbHZlXG4gICAqIEBwYXJhbSB7UHJvbWlzZXxUaGVuYWJsZXwqfSB2YWx1ZSAtIFByb21pc2UsIHRoZW5hYmxlIG9yIGFueSB2YWx1ZSB0byByZXNvbHZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yZXNvbHZlXG4gICAqL1xuICBzdGF0aWMgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFib3J0KCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBQcm9taXNlI2NhdGNoXG4gICAqIEBwYXJhbSB7b25SZWplY3RlZH0gb25SZWplY3RlZCAtIG9uUmVqZWN0ZWQgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL2NhdGNoXG4gICAqL1xuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIFByb21pc2UjZmluYWxseVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7b25GdWxmaWxsZWRPclJlamVjdGVkfSBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgLSBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjYXRjaGluZyBib3RoIGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgcHJvbWlzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHNwaW5uZXIuc2hvdygpO1xuICAgKiBmZXRjaERhdGEoKVxuICAgKiAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCBkYXRhXG4gICAqICAgfSlcbiAgICogICAuY2F0Y2goKGVycikgPT4ge1xuICAgKiAgICAgLy8gaGFuZGxlIGVycm9yIHNvbWVob3dcbiAgICogICB9KVxuICAgKiAgIC5maW5hbGx5KCgpID0+IHtcbiAgICogICAgIHNwaW5uZXIuaGlkZSgpO1xuICAgKiAgIH0pO1xuICAgKi9cbiAgZmluYWxseShvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQpIHtcbiAgICBjb25zdCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9uRnVsZmlsbGVkT3JSZWplY3RlZCk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKCh2YWx1ZSkgPT4gKFxuICAgICAgUHJvbWlzZVxuICAgICAgICAucmVzb2x2ZShcbiAgICAgICAgICBpc0Z1bmNcbiAgICAgICAgICAgID8gb25GdWxmaWxsZWRPclJlamVjdGVkKHZhbHVlLCB0cnVlKVxuICAgICAgICAgICAgOiAwXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKCkgPT4gdmFsdWUpXG4gICAgKSwgKGVycikgPT4gKFxuICAgICAgUHJvbWlzZVxuICAgICAgICAucmVzb2x2ZShcbiAgICAgICAgICBpc0Z1bmNcbiAgICAgICAgICAgID8gb25GdWxmaWxsZWRPclJlamVjdGVkKGVyciwgZmFsc2UpXG4gICAgICAgICAgICA6IDBcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoKSA9PiBQcm9taXNlLnJlamVjdChlcnIpKVxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgUHJvbWlzZSN0aGVuXG4gICAqIEBwYXJhbSB7b25GdWxmaWxsZWR9IFtvbkZ1bGZpbGxlZF0gLSBvbkZ1bGZpbGxlZCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSBbb25SZWplY3RlZF0gLSBvblJlamVjdGVkIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS90aGVuXG4gICAqL1xuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuJCQ7XG5cbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcHJvbWlzZS5oYW5kbGUoJ3JlamVjdCcsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCwgc2VjcmV0KTtcbiAgICAgICAgcHJvbWlzZS5oYW5kbGUoJ3Jlc29sdmUnLCBvbkZ1bGZpbGxlZCwgcmVzb2x2ZSwgcmVqZWN0LCBzZWNyZXQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvbWlzZS5oYW5kbGVkID0gc2VjcmV0O1xuXG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gcHJvbWlzZTtcblxuICAgIGxldCBtZXRob2Q7XG4gICAgbGV0IGhhbmRsZXI7XG5cbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICBtZXRob2QgPSAncmVzb2x2ZSc7XG4gICAgICBoYW5kbGVyID0gb25GdWxmaWxsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGhvZCA9ICdyZWplY3QnO1xuICAgICAgaGFuZGxlciA9IG9uUmVqZWN0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZVttZXRob2RdKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoYW5kbGVyKHZhbHVlKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH1cbn1cblxuZGVmaW5lUHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1Byb21pc2UnXG59KTtcblxuZXhwb3J0IHsgUHJvbWlzZSB9O1xuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvcGFyc2VIZWFkZXJzXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgcGFyc2VIZWFkZXJzIG1ldGhvZC5cbiAqL1xuXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuLi9TdHInO1xuaW1wb3J0IHsgaXRlcmF0ZSB9IGZyb20gJy4vaXRlcmF0ZSc7XG5cbi8qKlxuICogQGZ1bmN0aW9uIHBhcnNlSGVhZGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgLSBSYXcgaGVhZGVycy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgb2JqZWN0XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIHBhcnNpbmcgcmF3IGhlYWRlcnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChyYXdIZWFkZXJzKSA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcblxuICBpdGVyYXRlKChyYXdIZWFkZXJzIHx8ICcnKS5zcGxpdCgnXFxuJyksICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdmFsdWUuaW5kZXhPZignOicpO1xuICAgIGNvbnN0IGtleSA9IG5ldyBTdHIodmFsdWUuc3Vic3RyaW5nKDAsIGluZGV4KSlcbiAgICAgIC50cmltKClcbiAgICAgIC50b0NhbWVsQ2FzZSgpLiQ7XG4gICAgY29uc3QgdmFsID0gbmV3IFN0cih2YWx1ZS5zdWJzdHJpbmcoaW5kZXggKyAxKSkudHJpbSgpLiQ7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSAoaGVhZGVyc1trZXldID8gYCR7IGhlYWRlcnNba2V5XSB9LCBgIDogJycpICsgdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGhlYWRlcnM7XG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdHJhbnNmb3JtRGF0YVxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRyYW5zZm9ybURhdGEgbWV0aG9kLlxuICovXG5cbmltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcbmltcG9ydCB7IGlzT2JqZWN0LCB0b1N0cmluZ1RhZyB9IGZyb20gJy4vJztcblxuY29uc3Qgbm90VG9UcmFuc2Zvcm0gPSBuZXcgQXJyKFsnRm9ybURhdGEnLCAnRmlsZScsICdCbG9iJywgJ0FycmF5QnVmZmVyJywgJ1N0cmluZycsICdOdW1iZXInXSk7XG5jb25zdCB3aXRob3V0Qm9keSA9IG5ldyBBcnIoWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnXSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uIHRyYW5zZm9ybURhdGFcbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIERhdGEgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gSFRUUCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyAtIE9iamVjdCB3aXRoIGhlYWRlcnMuXG4gKiBAcmV0dXJucyB7Kn0gLSBUcmFuc2Zvcm1lZCBkYXRhLlxuICovXG5leHBvcnQgZGVmYXVsdCAoZGF0YSwgbWV0aG9kLCBoZWFkZXJzKSA9PiB7XG4gIGRhdGEgPSBuZXcgU3VwZXIoZGF0YSkuJDtcblxuICBpZiAod2l0aG91dEJvZHkuaW5kZXhPZlN0cmljdChtZXRob2QpICE9PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KGRhdGEpICYmIG5vdFRvVHJhbnNmb3JtLmluZGV4T2ZTdHJpY3QodG9TdHJpbmdUYWcoZGF0YSkpID09PSAtMSkge1xuICAgIGlmICghaGVhZGVycy5jb250ZW50VHlwZSkge1xuICAgICAgaGVhZGVycy5jb250ZW50VHlwZSA9IFsnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04J107XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdXBlcihkYXRhKS5qc29uKCk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy9yZXNvbHZlVVJMXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgT2JqZWN0LmFzc2lnbi1saWtlIG1ldGhvZC5cbiAqL1xuXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuLi9TdHInO1xuXG5jb25zdCB7IGxvY2F0aW9uIH0gPSBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IChkZWNvZGVRdWVyeSkgPT4ge1xuICBjb25zdCB7XG4gICAgc2VhcmNoOiBxdWVyeSxcbiAgICBoYXNoXG4gIH0gPSBsb2NhdGlvbjtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIHF1ZXJ5OiB7fSxcbiAgICBoYXNoOiBoYXNoLnJlcGxhY2UoL14jLywgJycpXG4gIH07XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBuZXcgU3RyKHF1ZXJ5LnJlcGxhY2UoL15cXD8vLCAnJykpXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZm9yRWFjaCgocmF3UGFyYW0pID0+IHtcbiAgICAgIGxldCBbcGFyYW0sIHZhbHVlID0gJyddID0gcmF3UGFyYW0uc3BsaXQoJz0nKTtcblxuICAgICAgcGFyYW0gPSBkZWNvZGVRdWVyeSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBwYXJhbTtcbiAgICAgIHZhbHVlID0gZGVjb2RlUXVlcnkgPyBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgIGlmICghL15bXltdKy8udGVzdChwYXJhbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGFyYW1OYW1lO1xuICAgICAgbGV0IHBhcmFtT2JqZWN0ID0gcGFyYW1zLnF1ZXJ5O1xuXG4gICAgICBuZXcgU3RyKHBhcmFtKVxuICAgICAgICAubWF0Y2goL15bXltcXF1dKnxcXFtbXltcXF1dKl0vZylcbiAgICAgICAgLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdbJykpIHtcbiAgICAgICAgICAgIHBhcmFtTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgICBwYXJhbU9iamVjdCA9IHBhcmFtT2JqZWN0W3BhcmFtTmFtZV0gPSBwYXJhbU9iamVjdFtwYXJhbU5hbWVdIHx8IChuYW1lID8ge30gOiBbXSk7XG4gICAgICAgICAgcGFyYW1OYW1lID0gbmFtZSB8fCBwYXJhbU9iamVjdC5sZW5ndGg7XG4gICAgICAgIH0pO1xuXG4gICAgICBwYXJhbU9iamVjdFtwYXJhbU5hbWVdID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn07XG4iLCJpbXBvcnQgKiBhcyBzdGF0aWNzIGZyb20gJy4vbGliL2Jyb3dzZXInO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi9saWIvaGVscGVycy9hc3NpZ24nO1xuXG5jb25zdCB7IEQgfSA9IHN0YXRpY3M7XG5cbmFzc2lnbihELCBzdGF0aWNzKTtcblxuZGVsZXRlIEQuRDtcblxuZ2xvYmFsLkQgPSBEO1xuIl0sIm5hbWVzIjpbInRvU3RyaW5nVGFnIiwib2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwicmVwbGFjZSIsImlzQXJyYXkiLCJ2YWx1ZSIsImlzQXJyYXlMaWtlIiwiaXNGdW5jdGlvbiIsImxlbmd0aCIsImlzSW50ZWdlciIsImlzQm9vbGVhbiIsImlzRGF0ZSIsImlzRGF0ZUxpa2UiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiaXNFbGVtZW50IiwidGVzdCIsImlzRmluaXRlIiwiaXNOdW1iZXIiLCJOdW1iZXIiLCJJbmZpbml0eSIsImlzSW50ZWdlckxpa2UiLCJwYXJzZUludCIsImlzTnVsbCIsImlzTmlsIiwiaXNOdW1iZXJMaWtlIiwiaXNPYmplY3QiLCJPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwiaXNQcmltaXRpdmUiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJpc1JlZ0V4cCIsImlzU3RyaW5nIiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsIkQiLCJpIiwiY29uc3RydWN0b3JzIiwibGV2ZWxDb25zdHJ1Y3RvcnMiLCJrIiwibGVuIiwiY2xzIiwiY2hlY2siLCJpdGVyYXRlIiwiY2FsbGJhY2siLCJhcnJheSIsIml0ZXJhdGVkS2V5cyIsIml0ZXJhdGVkIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJhc3NpZ24iLCJ0YXJnZXQiLCJvYmplY3RzIiwiYXJndW1lbnRzIiwic291cmNlIiwiaW5kZXgiLCJjb25zdHJ1Y3RFdmFsRnVuY3Rpb24iLCJjb2RlIiwib3JpZ2luYWwiLCJmdW5jIiwiRnVuY3Rpb24iLCJleHByZXNzaW9uIiwiZXJyIiwiRXJyb3IiLCJkeW5hbWljRGVmaW5lUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eUdlbmVyYXRvciIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnRpZXMiLCJ1bmRlZmluZWQiLCJnZXQiLCJzZXQiLCJkZWZpbmVVc3VhbFByb3BlcnRpZXMiLCJkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzIiwidG9BcnJheSIsImNyZWF0ZU5ld0FycmF5IiwicHVzaCIsInZhbGlkYXRlIiwiYXJncyIsIm9wdGlvbnMiLCJudW1iZXIiLCJjaGVja2VyIiwidmFsaWRhdGVDaGVja0V4cHJlc3Npb25zIiwiZXJyb3IiLCJ0ZXh0IiwibnVtYmVycyIsImNoYXIiLCJhbHBoYWJldCIsInN0cmluZyIsInJhbmdlcyIsInNwbGl0IiwicmFuZ2UiLCJzdGFydCIsImNoYXJDb2RlQXQiLCJlbmQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJBbHBoYWJldCIsInN3aXRjaGVyIiwiY2FzZXMiLCJtb2RlIiwiZGVmYXVsdFZhbHVlIiwiU3dpdGNoZXIiLCJ3aGVuIiwiY29uZGl0aW9uIiwidmFsdWUxIiwidmFsdWUyIiwiZGVlcEFzc2lnbiIsImRlZXBDbG9uZSIsImNsb25lIiwiY2xvbmVTd2l0Y2hlciIsImRlZXBFcXVhbCIsIm8xIiwibzIiLCJzdHJpY3QiLCJtYXRjaCIsImxhc3RJbmRleCIsInAxIiwicDIiLCJrZXlzIiwiZGVlcEV2ZXJ5IiwibiIsInRyZWUiLCJuZXdUcmVlIiwiY29uY2F0IiwiZGVlcEZpbHRlciIsIm51bCIsIm8iLCJmaWx0ZXJlZCIsImRlZXBGaW5kIiwicmVzdWx0IiwiZGVlcEZvckVhY2giLCJkZWVwRm9yRWFjaEVudHJ5IiwiZGVlcEZyZWV6ZSIsImZyZWV6ZSIsImRlZXBNYXAiLCJkZWVwUmVkdWNlIiwiSVYiLCJkZWVwU29tZSIsIm1ldGhvZCIsIngiLCJhcHBseSIsIm5vb3AiLCJwcm9wIiwic2VsZiIsInJhbmQiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJhc2MiLCJ5IiwiQXJyIiwiYmxvYiIsImJsb2JQYXJ0cyIsIkJsb2JPYmplY3QiLCJCbG9iIiwidHJpbSIsInBhcnNlSlNPTiIsImpzb24iLCJKU09OIiwicGFyc2UiLCJkYXRlcyIsInRoaXMiLCJmaW5kIiwibWFya3VwIiwiZWxlbSIsIm1hdGNoZXMiLCJyYXdUZXh0U3dpdGNoZXIiLCJTdXBlciIsImNvbnN0cnVjdENsb3NlVGFnUmVnRXhwIiwiTk9ERV9SRUdFWF9TRVQiLCJtYXAiLCJyZWdleCIsInJldHVybmluZyIsImF0dHJzIiwic3RhcnRNYXJrdXAiLCJjbG9zZU1hdGNoIiwic2VsZkNsb3NpbmciLCJzbGljZSIsIlRBR19PUEVOX0NMT1NFIiwiYXR0ciIsIkFUVFJJQlVURSIsIm1pbiIsIk5hTiIsInRhZ05hbWUiLCJSZWdFeHAiLCJuZWFyU3RyaW5nIiwicGFyc2VDaGFyYWN0ZXJEYXRhIiwiaW5uZXJIVE1MIiwiZGl2IiwidGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJ0b0ZpbmQiLCJpc0VsZW0iLCJFbGVtIiwiaXNXaW5kb3ciLCJpc0hUTUxEb2N1bWVudCIsImlzRG9jdW1lbnRGcmFnbWVudCIsImlzU3R5bGVSdWxlIiwiaXNDb21tZW50T3JUZXh0IiwidGFnIiwiZ2V0RWxlbSIsIiQiLCJlbXB0eURpdiIsImdldE5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiYWRkRHdheW5lRGF0YSIsIndpbmRvd3NEd2F5bmVEYXRhIiwic29tZSIsImVsZW1lbnQiLCJnZXRDb250ZXh0Iiwic2VsZWN0b3IiLCJiYXNlIiwibmF0aXZlRG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyc2VIVE1MIiwiaHRtbCIsImNvbGxhcHNlV2hpdGVTcGFjZSIsIm1hcmt1cFRvSlNPTiIsInRlbXBsYXRlIiwiZG9jIiwiY29udGVudCIsImZvckVhY2giLCJmb3JFYWNoTm9kZSIsIm5vZGUiLCJwYXJlbnQiLCJjaGlsZHJlbiIsInBhcmVudE5vZGUiLCJjcmVhdGUiLCJweCIsInNpemUiLCJyZWdpc3RlckRCbG9jayIsIkJsb2NrIiwiREJsb2NrIiwiJCQiLCJwYXJlbnRTY29wZSIsInBhcmVudFBhcmVudFNjb3BlIiwicGFyZW50UGFyZW50VGVtcGxhdGUiLCJwYXJlbnRUZW1wbGF0ZSIsImFyZ3NDaGlsZHJlbiIsIm93bkNoaWxkcmVuIiwiZEJsb2NrTmFtZSIsImZvdW5kIiwiUGFyZW50U2NvcGUiLCJQYXJlbnRUZW1wbGF0ZSIsImRCbG9ja3MiLCJlbGVtcyIsInJlZ2lzdGVyREVhY2giLCJjcmVhdGVCbG9jayIsIm9wdHMiLCJpdGVtIiwiaXRlbU5hbWUiLCJpbmRleE5hbWUiLCJfdGhpcyIsInVpZCIsIndhdGNoIiwiX3RoaXMyIiwidWlkcyIsInBhcmVudEVsZW0iLCJzY29wZSIsIlVJRCIsInNvcnRCeSIsIiR1aWRzIiwibmV3S2V5cyIsIm5ld1VJRHMiLCJmaWx0ZXJCeSIsInNvcnQiLCJmaWx0ZXIiLCJldmFsdWF0ZSIsIml0ZW1zIiwiSXRlbSIsInJlbW92ZSIsInNwbGljZSIsInByZXZCbG9jayIsImJsb2NrIiwic2hpZnQiLCJpbnNlcnRBZnRlckl0IiwiaW5zZXJ0SW5TdGFydE9mSXQiLCJ2YWx1ZXMiLCJyZWdpc3RlckRFbGVtZW50cyIsImZpcnN0VGltZSIsIm1peGlucyIsIndhdGNoZXJzVG9SZW1vdmUiLCJjaGlsZCIsIm1peGluIiwicmVtb3ZlQ29udGVudCIsIndhdGNoZXJzIiwid2F0Y2hlciIsImZvckRFbGVtZW50cyIsImluZGV4T2YiLCJyZWdpc3RlckRJZiIsIkRJZiIsImNvbmQiLCJpZiIsIm5ld1ZhbHVlIiwiQm9vbGVhbiIsInJlZ2lzdGVyREl0ZW0iLCJESXRlbSIsInJlZ2lzdGVyRFN3aXRjaCIsIkRTd2l0Y2giLCJ3YXNEZWZhdWx0IiwidmFsIiwiZXF1YWxzIiwicmVnaXN0ZXJEQXR0ciIsIk1peGluIiwicmVtb3ZlQXR0ciIsInJlZ2lzdGVyREJpbmQiLCJvZmYiLCJvbiIsImpvaW4iLCJyZWdpc3RlckRDbGFzcyIsImNsYXNzZXMiLCJuZXdDbGFzc2VzIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsInJlZ2lzdGVyREVsZW0iLCJERWxlbSIsImV2YWx1YXRlT25jZSIsInJlZ2lzdGVyREhpZGUiLCJoaWRlIiwic2hvdyIsInJlZ2lzdGVyRE5vZGUiLCJETm9kZSIsInJlZ2lzdGVyRE9uIiwiRE9uIiwicmVnaXN0ZXJEU2hvdyIsInJlZ2lzdGVyRFN0eWxlIiwiY3NzIiwib2xkVmFsdWUiLCJyZW1vdmVDU1MiLCJyZWdpc3RlckRWYWxpZGF0ZSIsIkRWYWxpZGF0ZSIsInZhbGlkYXRvciIsImxpc3RlbmVyU3dpdGNoZXIiLCJ2YWxpZGF0b3JzIiwiZHdheW5lRGF0YSIsInJlZ2lzdGVyRFZhbHVlIiwiRFZhbHVlIiwidHlwZSIsImluaXRpYWxTY29wZVZhbHVlIiwicHJvcFN3aXRjaGVyIiwiY3VycmVudFZhbHVlIiwic2V0UHJvcCIsImluaXRpYWxFbGVtVmFsdWUiLCJnZXRQcm9wIiwiaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwiLCJpc0NoZWNrYm94IiwiY2hhbmdlU2NvcGUiLCJvZmZFbGVtTGlzdGVuZXIiLCJlIiwib2ZmRm9ybUxpc3RlbmVyIiwiY2xvc2VzdCIsIm9wdGlvbiIsInNlbGVjdGVkIiwic2V0VmFsdWVTd2l0Y2hlciIsImluaXQiLCJnZXRWYWx1ZVN3aXRjaGVyIiwicGFyc2VKUyIsIndob2xlU3RyaW5nIiwiY3VybHlFcnJvciIsImluaXRpYWxTdHJpbmciLCJleHBlY3RlZCIsInZhcmlhYmxlcyIsImNsb3NpbmdFeHByZXNzaW9ucyIsInNwYWNlTWF0Y2giLCJ0b0NvbmNhdCIsIm1hdGNoZWQiLCJpc0VtcHR5U3BhY2UiLCJwcm9wZXJUeXBlIiwicHJvcGVyU3ltYm9sIiwic3ltYm9sIiwiZmlyc3RTeW1ib2wiLCJlbXB0eVNwYWNlUmVnRXhwIiwidGVtcGxhdGVTdHJpbmciLCJhcnJvd0Z1bmN0aW9uUmVnRXhwIiwidmFycyIsImFueUNvbW1hRW1wdHlTcGFjZSIsIm5ld0Z1bmN0aW9uVmFycyIsImZ1bmN0aW9uU2NvcGUiLCJ2YXJpYWJsZSIsIkVORF9PRl9GVU5DX0JPRFkiLCJFWFBSRVNTSU9OIiwib2JqZWN0UHJvcGVydHkiLCJ1bmFyeU9wZXJhdG9yUmVnRXhwIiwiYW55RW1wdHlTcGFjZVJlZ0V4cCIsInNpbXBsZUV4cHJlc3Npb25SZWdFeHAiLCJudW1iZXJSZWdFeHAiLCJzdHJpbmdSZWdFeHAiLCJyZWdleHBSZWdFeHAiLCJ0aGlzUmVnRXhwIiwidmFyaWFibGVSZWdFeHAiLCJnZXRWYXJpYWJsZSIsIm9wZXJhdG9yIiwidGVtcGxhdGVTdHJpbmdDb250ZW50UmVnRXhwIiwiYW55RXNjYXBlZEV4cHJlc3Npb25SZWdFeHAiLCJzZWNvbmQiLCJwcm9wZXJFc2NhcGVkUmVnRXhwIiwiYW55RG91YmxlUXVvdGVSZWdFeHAiLCJhbnlOZXdMaW5lUmVnRXhwIiwicG9wIiwicHJvcGVydHlSZWdFeHAiLCJrZXl3b3Jkc1JlZ0V4cCIsInNob3J0aGFuZFByb3BlcnR5UmVnRXhwIiwiY2xvc2VGdW5jdGlvbkJvZHkiLCJwb2ludE9wZXJhdG9yUmVnRXhwIiwib3BlcmF0b3JSZWdFeHAiLCJjbG9zaW5nQnJhY2UiLCJub01hdGNoIiwiY3VybHlJbmRleCIsImV4cHJlc3Npb25TdHJpbmciLCJjb25zdHJ1Y3RFcnJvckluZm8iLCJsYXN0Iiwid2hvbGVTdHJpbmdTdHJpbmciLCJzdWJtaXRTdHJpbmciLCJpbml0QXBwIiwiYmxvY2tzIiwiRHdheW5lUm9vdEJsb2NrIiwicmVtb3ZlQXBwIiwicmVnaXN0ZXJCdWlsdElucyIsInJlZ2lzdGVyIiwiX2h0bWwiLCJ0cmFuc2Zvcm1KU0V4cHJlc3Npb25zIiwiX3ZhcmlhYmxlcyIsImV4Y2VwdCIsIl9tYXRjaCIsImNvbnN0cnVjdE1peGluUmVnRXhwIiwicGFyZW50QmxvY2siLCJzdmdOUyIsInN2ZyIsImxvY2FsQmxvY2tzIiwibnMiLCJfYmxvY2tzIiwibG9jYWxNaXhpbnMiLCJfbWl4aW5zIiwiZEJsb2NrTWF0Y2giLCJkQmxvY2tBcmdzIiwiZEJsb2NrQ2hpbGRyZW4iLCJkRWxlbWVudHNOYW1lIiwiYmxvY2tJbnN0YW5jZSIsImN1cnJlbnRBdHRycyIsIndhc0RSZXN0IiwibWl4aW5EZWZhdWx0T3B0cyIsImlzRFJlc3QiLCJkUmVzdFJlZ0V4cCIsImxvY2FsQXR0cnMiLCJyZXN0QXR0cnMiLCJhcmciLCJ0cmFuc2Zvcm1SZXN0QXR0cnMiLCJtaXhpbk1hdGNoIiwiY3JlYXRlTWl4aW5zIiwiY2FsY3VsYXRlQXR0cnMiLCJpc1BhcmVudEJsb2NrIiwiaW5zZXJ0QWZ0ZXIiLCJhZGRDb250ZW50IiwiaW50byIsIkFyZ3MiLCJnbG9iYWxzIiwibG9jYWxzIiwibmV3TmFtZSIsInRyYW5zZm9ybURJZkNoaWxkcmVuIiwiY29uc3RydWN0UHJpdmF0ZVNjb3BlIiwic2NvcGVWYWx1ZXMiLCJwcml2YXRlU2NvcGUiLCJhZnRlckNvbnN0cnVjdCIsImFmdGVyUmVuZGVyIiwiY3JlYXRlTWl4aW4iLCJkeW5hbWljIiwiY29tbWVudCIsImV2YWx1YXRlQW5kV2F0Y2giLCJhZnRlclVwZGF0ZSIsImlmRWxzZSIsImV4Y2x1ZGUiLCJpbml0aWFsVmFsdWUiLCJpc0RFYWNoIiwiZXhjbHVkZUxvY2FsIiwicGFyc2VkIiwicmVzdCIsImlzVUlEIiwidXNlZFZhcmlhYmxlcyIsImN1cmx5QnJhY2tldFJlZ0V4cCIsImlzSW5zdGFuY2VPZiIsIkNsYXNzIiwiU3ViY2xhc3MiLCJpc1Byb3RvdHlwZU9mIiwicHJvdG90eXBlIiwicmVtb3ZlV2F0Y2hlcnMiLCJjb25zdHJ1Y3RQdWJsaWNTY29wZSIsImRlZmluZSIsImV2YWxNb2RlIiwiZ2V0dGluZyIsInRlbXAiLCJjaGFuZ2VkIiwib2xkVGVtcFdhdGNoZXJzIiwib25SZW1vdmUiLCJ3YXMiLCJwZXJtIiwid2F0Y2hGb3JBbGxMb2NhbHMiLCJ3YXRjaEZvckFsbEdsb2JhbHMiLCJnbG9iYWwiLCJ3YXRjaEZvckFsbEFyZ3MiLCJjYWxjdWxhdGVBcmdzIiwiYXJnc09iamVjdCIsIiRhcmdzT2JqZWN0IiwicHJvcGVydHlOYW1lcyIsInRyYW5zZm9ybVJlc3RBcmdzIiwiZXZlbnR1YWxBdHRycyIsImxvY2FsTWF0Y2giLCJhcmdzTWF0Y2giLCJTdHIiLCJzIiwiYXR0cnNPYmplY3QiLCJuZXh0VHlwZSIsIm5leHREeW5hbWljIiwibmV4dFZhbHVlIiwicHJldlR5cGUiLCJwcmV2VmFsdWUiLCJpc0R5bmFtaWMiLCJldmFsdWF0ZWQiLCJidWlsZE1peGluIiwiZmlyc3RWYWx1ZSIsImV4ZWN1dGVNaXhpbldhdGNoZXJzIiwiZXNjYXBlUmVnRXhwIiwiZXh0ZW5kQmxvY2siLCJpbnNlcnRUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZXMiLCJuZXdUZW1wbGF0ZXMiLCJuZXdWYXJzIiwicHVzaEFycmF5Iiwicm91bmQiLCJkaWdpdHMiLCJ6ZXJvZXMiLCJ6ZXJvIiwicmVwZWF0Iiwibm93IiwiZGF0ZSIsIkRhdCIsImlzQWJzb2x1dGUiLCJ1cmwiLCJhYnNvbHV0ZVVSTFJlZ2V4cCIsImVuY29kZSIsImlzRW5jb2RlZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZldGNoQmVmb3JlTWlkZGxld2FyZSIsImNvbmZpZyIsImJhc2VVUkwiLCJkYXRhIiwiaGVhZGVycyIsInBhcmFtcyIsInF1ZXJ5IiwiTUVUSE9EIiwidG9VcHBlckNhc2UiLCJjb25zdHJ1Y3RVUkwiLCJ0cmFuc2Zvcm1EYXRhIiwiaGVhZGVyIiwidG9DYXBpdGFsQ2FzZSIsImluaXRSb3V0ZXIiLCJpbml0aWFsaXplZCIsIlJvdXRlcyIsInJlZGlyZWN0Um91dGUiLCJkZWZhdWx0Um91dGUiLCJSZWRpcmVjdFJvdXRlIiwicm91dGUiLCJwYXJlbnROYW1lIiwiUGFyZW50TmFtZSIsInJvb3RSb3V0ZSIsImFic3RyYWN0IiwiYmFzZVJvdXRlIiwicGFyZW50UGFyYW1zIiwicGFyZW50UXVlcnkiLCJwYXRoIiwicmVsYXRpdmVVUkwiLCJyZWxhdGl2ZVBhdGgiLCJjb3VudCIsIm5ld1BhdGgiLCJuZXdVUkwiLCJ2YWxpZGF0ZVBhdGgiLCJsb2NhdGlvbiIsImhyZWYiLCJpbml0aWFsVVJMIiwicHVzaGVkIiwiY2xvc2VzdExpbmsiLCJoYXNBdHRyIiwicHJldmVudERlZmF1bHQiLCJtYWtlUm91dGUiLCJjYWxsQmVmb3JlTG9hZCIsInJvdXRlTG9hZGVkIiwid2FzUm91dGUiLCJiZWZvcmVMb2FkIiwiX19yb3V0ZXJJbnN0YW5jZV9fIiwiYmVmb3JlTG9hZFJvdXRlIiwiY2FsbEJlZm9yZUxlYXZlIiwiYmVmb3JlTGVhdmUiLCJiZWZvcmVMZWF2ZVJvdXRlIiwicm91dGVyT3B0aW9ucyIsInJvb3QiLCJmYWxsYmFja1RvIiwiaXNEZWZhdWx0IiwiZGVmYXVsdCIsIndhcm4iLCJ3YXNSb290IiwiUm91dGUiLCJ1bnN1YnNjcmliZSIsInJvdXRlciIsIl9faXNDdXJyZW50Um91dGVfXyIsImN1cnJlbnRSb3V0ZXMiLCJpbmNsdWRlcyIsIl9fd2FzUm91dGVBY3RpdmVfXyIsImN1cnJlbnRSb3V0ZVBhcmFtcyIsInN1YnNjcmliZSIsImFjdGlvbiIsImlzQ3VycmVudFJvdXRlIiwic3Vic2NyaWJlcnMiLCJmb3J3YXJkIiwiY2hhbmdlUm91dGUiLCJmaW5kUm91dGVCeVVSTCIsImN1cnJlbnRSb3V0ZSIsImhvc3QiLCJob3N0bmFtZSIsIm9yaWdpbiIsInBhdGhuYW1lIiwicG9ydCIsInByb3RvY29sIiwic2VhcmNoIiwiZW5jb2RlUGFyYW1zIiwiZW5jb2RlUXVlcnkiLCJyZWRpcmVjdFJvdXRlSXNOZWVkZWRUb1B1c2giLCJyb3V0ZXNUb0xlYXZlIiwicm91dGVzVG9Mb2FkIiwiY3VycmVudFBhcmVudCIsInVuc2hpZnQiLCJ1cmxQYXJhbXMiLCJyb3V0ZVVSTCIsInJlcXVpcmVkUXVlcnkiLCJkZWNvZGVQYXJhbXMiLCJkZWNvZGVRdWVyeSIsInJlc29sdmVkIiwicmVzb2x2ZVVSTCIsImV2ZW50dWFsUGFyYW1zIiwicGFyYW0iLCJoYXNPd24iLCJkZWNvZGUiLCJoYXNoIiwiRGVmYXVsdFJvdXRlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiY2hhbmdlSGlzdG9yeSIsInJlc29sdmVQYXJhbWV0ZXIiLCJuYW1lRXJyb3JOYW1lIiwidmFsdWVFcnJvck5hbWUiLCJuYW1lTWF0Y2giLCJyZWdleHAiLCJidWlsZFVSTCIsImdvIiwiZ29Ub1VSTCIsInB1c2hVUkwiLCJyZWRpcmVjdCIsInJlZGlyZWN0VG9VUkwiLCJyZXBsYWNlVVJMIiwid2luZG93IiwiYXBwbGllZFJlZ0V4cHMiLCJpZCIsImNhbnZhc0dldE1ldGhvZHMiLCJjYW52YXNSZXN0TWV0aG9kcyIsImh0bWxFbGVtZW50cyIsInN2Z0VsZW1lbnRzIiwidm9pZEVsZW1lbnRzIiwiaHRtbEFsbG93ZWRUYWdTeW1ib2xzIiwicmVnZXhwU3BlY2lhbENoYXJhY3RlcnMiLCJSYW5nZUVycm9yIiwidiIsIm1ldGhvZHMiLCJUeXBlRXJyb3IiLCJhIiwiZCIsImYiLCJyIiwiU3ltYm9sIiwiY2hhcnMiLCJ3b3JkIiwidG9rZW4iLCJkZWYiLCJyZXQiLCJDYXNlIiwiY2FzZSIsImV2ZW50dWFsQ2FzZXMiLCJzZXRQcm90b3R5cGVPZiIsImRlZXAiLCJzdW0iLCJkZXNjcmlwdG9ycyIsInByb3BlcnR5IiwiZGVzY3JpcHRvciIsInByb3BzIiwiZ2V0dGVyIiwiaXNGcm96ZW4iLCJyZXBsYWNlciIsInNwYWNlIiwic3RyaW5naWZ5IiwibWF4Iiwib2JqIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImlzQ29udGV4dE9iamVjdCIsInN0YXJ0S2V5Iiwic2V0dGVyIiwicmVkdWNlIiwic2VjcmV0IiwiaXRlcmF0b3IiLCJQcm9taXNlIiwiZXhlY3V0b3IiLCJyZWplY3QiLCJoaWRkZW5Qcm9taXNlIiwic3RhdHVzIiwib25SZWplY3QiLCJoYW5kbGVkIiwib25VbmhhbmRsZWRSZWplY3Rpb24iLCJvbkVycm9yIiwicmVzb2x2ZSIsInRoZW4iLCJvbkZ1bGZpbGwiLCJoaWRkZW5TdGF0dXMiLCJoaWRkZW5WYWx1ZSIsInJlYWxQcm9taXNlIiwicHJveHkiLCJvblJlamVjdGVkIiwib25GdWxmaWxsZWRPclJlamVjdGVkIiwiaXNGdW5jIiwib25GdWxmaWxsZWQiLCJwcm9taXNlIiwiaGFuZGxlIiwiaGFuZGxlciIsIml0ZXJhYmxlIiwidG9SZXNvbHZlIiwibmV4dCIsImRvbmUiLCJjb25zb2xlIiwiYmluZCIsIkZ1bmMiLCJjYWxsZWQiLCJjYW5CZUNhbGxlZCIsImJlZm9yZSIsImFmdGVyIiwic3luYyIsImNvbnRleHRMb2NrZWQiLCJjb250ZXh0IiwibWlkZGxld2FyZSIsImFmdGVyQWxsIiwiYmVmb3JlQWxsIiwiYmluZENvbnRleHQiLCJiaW5kQXJncyIsInRpbWVzIiwibG9ja0NvbnRleHQiLCJsb2NrQXJncyIsImFyZ3NMb2NrZWQiLCJtYXJrIiwidGltZSIsInRpbWVFbmQiLCJ1bmJpbmRDb250ZXh0IiwidW5iaW5kQXJncyIsInRvUmFkaWFuIiwiUEkiLCJ0b0RlZ3JlZSIsImxuMiIsIkxOMiIsImxuMTAiLCJMTjEwIiwiTnVtIiwidG9EZWdyZWVzIiwiYWNvcyIsImFzaW4iLCJhdGFuIiwiYXNEZWdyZWVzIiwiY29zIiwiYWJvcnQiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiYWJvcnRlZCIsInNldFRpbWVvdXQiLCJpbnRlcnZhbCIsImxvZyIsInBvd2VyIiwicG93Iiwic2luIiwidGFuIiwicmVqIiwiZnJhY3Rpb25EaWdpdHMiLCJ0b0V4cG9uZW50aWFsIiwidG9GaXhlZCIsInByZWNpc2lvbiIsInRvUHJlY2lzaW9uIiwiYWJzIiwic3FydCIsImNicnQiLCJjZWlsIiwiZXhwIiwibG4iLCJzaWduIiwiaW5kZXhPZlN0cmljdCIsImtleU9mIiwia2V5T2ZTdHJpY3QiLCJzZXBhcmF0b3IiLCJyZXZlcnNlIiwicmFuZG9tSW5kZXgiLCJiZWdpbiIsImNvbXBhcmVGdW5jdGlvbiIsImRlbGV0ZUNvdW50IiwiVVJMIiwicHJvZ3Jlc3MiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwidG9SZWplY3QiLCJvbnByb2dyZXNzIiwib25lcnJvciIsIm9ubG9hZCIsImFuY2hvciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImRhdGFVUkwiLCJzZXRBdHRyaWJ1dGUiLCJjbGljayIsImNyZWF0ZU9iamVjdFVSTCIsImh0bWxTcGVjaWFscyIsInJlZ2V4cFNwZWNpYWxzUmVnZXhwIiwic2VhcmNoU3RyaW5nIiwicG9zaXRpb24iLCJyZXZlcnQiLCJzdGFydHNXaXRoIiwiZXNjYXBlZCIsInNlYXJjaFZhbHVlIiwiZnJvbUluZGV4IiwibGFzdEluZGV4T2YiLCJzdHIiLCJiZWdpblNsaWNlIiwiZW5kU2xpY2UiLCJzdWJzdHIiLCJpbmRleFN0YXJ0IiwiaW5kZXhFbmQiLCJzdWJzdHJpbmciLCJub2RlU3dpdGNoZXIiLCJJbnRlcm5hbFBhcnNpbmdFcnJvciIsIlBhcnNpbmdFcnJvciIsInRocm93VW5leHBlY3RlZEVycm9yIiwiZ2xvYmFsSW5kZXgiLCJlbGVtZW50cyIsImV2ZW50U2VwYXJhdG9yIiwidGV4dFByb3BlcnR5IiwiTm9kZSIsInByb3BlcnR5RGVzY3JpcHRvciIsImlucHV0RWxlbWVudHMiLCJ0eXBlU3dpdGNoZXIiLCJkb2N1bWVudEVsZW1lbnQiLCJuYW1lc3BhY2VVUkkiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVDb21tZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJyZWZTd2l0Y2hlciIsImZpbHRlclN3aXRjaGVyIiwiaXMiLCJpbm5lclN3aXRjaGVyIiwicGFkZGluZ3MiLCJib3JkZXJzIiwib3V0ZXJTd2l0Y2hlciIsImF0dHJOU1N3aXRjaGVyIiwibGlzdCIsImNsYXNzTGlzdCIsImFkZCIsImluc2VydEFkamFjZW50SFRNTCIsInN0eWxlIiwic2hlZXQiLCJjc3NSdWxlcyIsInJ1bGVzIiwidG9IeXBoZW5DYXNlIiwiaW5zZXJ0UnVsZSIsInN0cmluZ3MiLCJhcHBsaWVkIiwic2V0QXBwbGllZCIsIm5wMSIsImF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwiX3RoaXM0IiwiZmlyc3QiLCJsb2FkIiwiaXNCcm9rZW4iLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsImJ5dGVTdHJpbmciLCJhdG9iIiwiYWIiLCJBcnJheUJ1ZmZlciIsImlhIiwiVWludDhBcnJheSIsImJsdXIiLCJwc2V1ZG8iLCJnZXRDb21wdXRlZFN0eWxlIiwicnVsZSIsImNoaWxkTm9kZXMiLCJjbGFzc05hbWUiLCJjbG9uZU5vZGUiLCJjb250YWlucyIsImFwcGxpZWRFeHByZXNzaW9ucyIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRQcm9wZXJ0eVByaW9yaXR5IiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImNzc1RleHQiLCJ0b0NhbWVsQ2FzZSIsImN0eCIsImRhdGFzZXQiLCJlbmNvZGVyT3B0aW9ucyIsInRvRGF0YVVSTCIsImRlbGV0ZVJ1bGUiLCJldmVudCIsImV2ZW50SW5pdCIsImRldGFpbHMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImZpbmFsRXZlbnQiLCJFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImZvY3VzIiwic2VsZWN0b3JUZXh0IiwiaGFzQXR0cmlidXRlIiwiaGFzQXR0cmlidXRlTlMiLCJjdXJyZW50RGlzcGxheSIsInByZXZpb3VzRGlzcGxheSIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJmaXJzdENoaWxkIiwiZm9yRWFjaFJldmVyc2UiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJpbWFnZXMiLCJhbGwiLCIkZWxlbSIsInJlbW92ZUxpc3RlbmVycyIsInByb3BlciIsImJyb2tlbiIsInByZXYiLCJldmVudHMiLCJsaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsImxpc3RlbmVyIiwiYWxsTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJoYXMiLCJuZXdMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZWxldGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHJldmlvdXNTaWJsaW5nIiwibGluayIsInJlbW92ZUNoaWxkIiwicmVtb3ZlQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlTlMiLCIyIiwiMSIsImNyZWF0ZWQiLCJ0eHQiLCJfYXJndW1lbnRzNiIsImhhc0NsYXNzIiwibGV2ZWwiLCJ2YWxpZGF0b3JXcmFwIiwiaW5wdXQiLCJlcnJvcnMiLCJ2YWxpZGl0eSIsInZhbGlkIiwidmFsaWRhdGlvbk1lc3NhZ2UiLCJmb3JtRXJyb3JzIiwiZm9ybSIsImlucHV0cyIsImRpc3BhdGNoIiwiaW5wdXRFcnJvciIsImV2ZXJ5IiwiaW5uZXJIZWlnaHQiLCJjYWxjQ1NTIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJveFNpemluZyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiaW5uZXJXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIm91dGVySGVpZ2h0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwib3V0ZXJXaWR0aCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIndpbiIsImJvZHkiLCJoZWFkIiwiaW5wdXRWYWx1ZSIsImlzTXVsdGlwbGUiLCJrZXl3b3Jkc0FycmF5Iiwicm9vdEJsb2NrcyIsInJvb3RNaXhpbnMiLCJhdHRyTmFtZSIsImFmdGVyRWxlbSIsIm9yaWdpbmFsQXJncyIsImNoaWxkcmVuQmxvY2tzIiwib25DaGFuZ2UiLCJpbnN0YW5jZSIsImZvckRJdGVtIiwiZm9yREVhY2giLCJvbkV2YWxFcnJvciIsImxvY2FsV2F0Y2hlcnMiLCJuZXdSZXN1bHQiLCJ3YXRjaGVyQmxvY2siLCJpbmRleDEiLCJpbmRleDIiLCJpc1BhcmVudFNpZ25hbCIsImJlZm9yZVJlbW92ZSIsIl90aGlzNSIsImNvbnRlbnRUb0FkZCIsIm5vdFJlY3Vyc2l2ZSIsImNvbnRlbnRUb01vdmUiLCJpbmRleFRvUHV0IiwibW92ZUNvbnRlbnQiLCJjb250ZW50VG9SZW1vdmUiLCJjb250ZW50VG9JbnNlcnQiLCJtb3ZlRmxhZyIsInRyeVRvQWRkT3JNb3ZlIiwiZGVmYXVsdExvY2FscyIsImRlZmF1bHRBcmdzIiwibG9jYWxBcmdzIiwicmVzdEFyZ3MiLCJpc0RFbGVtZW50cyIsImhvb2siLCJfYmxvY2tIb29rcyIsIl9taXhpbkhvb2tzIiwicmV0dXJuVmFsdWUiLCJfbmFtZSIsIndyYXBwZXJzIiwid3JhcHBlciIsIm9sZFdhdGNoZXIiLCJfdGhpczYiLCJCbG9ja3MiLCJfdGhpczciLCJfdmFsdWUiLCJNaXhpbnMiLCJkYXlzT2ZUaGVXZWVrTmFtZXMiLCJkYXlzT2ZUaGVXZWVrQWxpYXNlcyIsIm1vbnRoc05hbWVzIiwibW9udGhzQWxpYXNlcyIsInV0YyIsImNvZWZmcyIsImdldFN3aXRjaGVyIiwic2V0U3dpdGNoZXIiLCJ3aGF0IiwicHJlZml4IiwiZm9ybWF0cyIsImZvcm1hdCIsInJlcGxhY2VTdHJpbmciLCJkYXRlMSIsImRhdGUyIiwiaXNCZWZvcmUiLCJzdGFydGVkIiwiY29lZmYiLCJ3Iiwic2V0VGltZSIsInRvSVNPU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJ2YWx1ZU9mIiwicXVlcnlTd2l0Y2hlciIsInF1ZXJ5UGFyYW1zIiwiZW5jb2RlT3B0aW9ucyIsInJhd0hlYWRlcnMiLCJub3RUb1RyYW5zZm9ybSIsIndpdGhvdXRCb2R5IiwiY29udGVudFR5cGUiLCJkZWZhdWx0cyIsInVwbG9hZE1ldGhvZHMiLCJGZXRjaCIsImZldGNoIiwicmVxdWVzdCIsImNvbmYiLCJ0b1B1c2giLCJkYXRhQ29uZmlnIiwidXJsQ29uZmlnIiwieGhyIiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJyZXNwb25zZVR5cGUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwidXBsb2FkIiwib25hYm9ydCIsIm9udGltZW91dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsInBhcnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInN0YXR1c1RleHQiLCJjYXRjaCIsInNlbmQiLCJyYXdQYXJhbSIsInBhcmFtTmFtZSIsInBhcmFtT2JqZWN0IiwiaGlzdG9yeSIsInBhdGhTd2l0Y2hlciIsInBhcnQiLCJzdGF0aWNzIl0sIm1hcHBpbmdzIjoid0JBWUEsU0FBZ0JBLEdBQVlDLFlBQ2hCQyxTQUFTQyxLQUFLRixHQUFRRyxRQUFRLGlCQUFrQixJQ081RCxRQUFnQkMsR0FBUUMsU0FDUSxVQUF2Qk4sRUFBWU0sR0FnQnJCLFFBQWdCQyxHQUFZRCxPQUNyQkEsR0FBU0UsRUFBV0YsVUFDaEIsS0FHSEcsR0FBU0gsRUFBTUcsYUFFZEMsR0FBVUQsSUFBV0EsR0FBVSxFQWN4QyxRQUFnQkUsR0FBVUwsU0FDTSxZQUF2Qk4sRUFBWU0sR0FhckIsUUFBZ0JNLEdBQU9OLFNBQ1MsU0FBdkJOLEVBQVlNLEdBZXJCLFFBQWdCTyxH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UUEsS0FRQSxTQVFBLFNBUUEsVUFRQSxPQVFBLE9BUUEsTUFRQSxXQVFBLFVBUUEsV0FRQSxLQVFBLE1BUUEsVUFRQSxNQVFBLFNBUUEsTUFRQSxLQVFBLEtBUUEsVUFRQSxLQVFBLFFBUUEsV0FRQSxhQVFBLFNBUUEsU0FRQSxPQVFBLEtBUUEsS0FRQSxLQVFBLEtBUUEsS0FRQSxLQVFBLE9BUUEsU0FRQSxTQVFBLEtBUUEsSUFRQSxTQVFBLE1BUUEsUUFRQSxNQVFBLE1BUUEsUUFRQSxTQVFBLEtBUUEsT0FRQSxPQVFBLE9BUUEsT0FRQSxXQVFBLE9BUUEsUUFRQSxNQVFBLFdBUUEsS0FRQSxXQVFBLFNBUUEsU0FRQSxJQVFBLFFBUUEsTUFRQSxXQVFBLElBUUEsS0FRQSxLQVFBLE1BUUEsT0FRQSxJQVFBLE9BUUEsU0FRQSxVQVFBLFNBUUEsU0FRQSxRQVFBLFNBUUEsT0FRQSxTQVFBLFFBUUEsTUFRQSxVQVFBLE1BUUEsUUFRQSxRQVFBLEtBUUEsV0FRQSxXQVFBLFFBUUEsS0FRQSxRQVFBLE9BUUEsUUFRQSxLQVFBLFFBUUEsSUFRQSxLQVFBLE1BUUEsUUFRQSxPQUdXQyxJQU9YLFdBUUEsY0FRQSxlQVFBLFVBUUEsZUFRQSxnQkFRQSxtQkFRQSxTQVFBLFdBUUEsZ0JBUUEsU0FRQSxPQVFBLE9BUUEsVUFRQSxVQVFBLFVBUUEsZ0JBUUEsc0JBUUEsY0FRQSxtQkFRQSxvQkFRQSxvQkFRQSxpQkFRQSxlQVFBLFVBUUEsVUFRQSxVQVFBLFVBUUEsVUFRQSxpQkFRQSxVQVFBLFVBUUEsY0FRQSxlQVFBLFdBUUEsZUFRQSxxQkFRQSxjQVFBLFNBUUEsZUFRQSxPQVFBLFlBUUEsbUJBUUEsaUJBUUEsZ0JBUUEsZ0JBUUEsZ0JBUUEsSUFRQSxRQVFBLFdBUUEsUUFRQSxZQVFBLFFBUUEsUUFRQSxPQVFBLGlCQVFBLFNBUUEsT0FRQSxPQVFBLGVBUUEsWUFRQSxVQVFBLFdBUUEsZ0JBUUEsUUFRQSxPQVFBLFVBUUEsVUFRQSxXQVFBLGlCQVFBLE9BUUEsTUFRQSxhQVFBLE9BUUEsUUFRQSxNQVFBLFNB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"}