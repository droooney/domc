{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/toStringTag.js","../src/utils/is.js","../src/utils/escapeRegex.js","../src/utils/toCase.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/isElem.js","../src/helpers/Elem/isElementsCollection.js","../src/helpers/Elem/isHTMLDocument.js","../src/helpers/Elem/isValidNode.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/constructMixinRegex.js","../src/helpers/Block/mixinMatch.js","../src/helpers/Block/transformRestAttrs.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/createMixin.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/extendBlock.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/remove.js","../src/helpers/Block/watchForAll.js","../src/helpers/Block/wrap.js","../src/initApp.js","../src/blocks/d-switch.js","../src/mixins/d-style.js","../src/mixins/d-value.js","../src/insertTemplates.js","../src/removeApp.js","../src/global.js","../src/utils/objectStatics.js","../src/constants/index.js","../src/Elem.js","../src/Mixin.js","../src/Block.js","../src/blocks/d-block.js","../src/blocks/d-item.js","../src/blocks/d-each.js","../src/blocks/d-elements.js","../src/blocks/d-if.js","../src/mixins/d-attr.js","../src/mixins/d-bind.js","../src/mixins/d-class.js","../src/mixins/d-elem.js","../src/mixins/d-hide.js","../src/mixins/d-node.js","../src/mixins/d-on.js","../src/mixins/d-show.js","../src/helpers/Block/registerBuiltins.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","import { iterateArray } from './array';\n\nconst {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  iterateArray(arguments, (source, index) => {\n    if (index) {\n      iterateObject(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\n/**\n * @function defineProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining properties of an object.\n */\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineFrozenProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining frozen properties of an object.\n */\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","import { definePrototypeProperties } from './defineProperty';\n\nconst { Symbol } = global;\nconst { toString } = {};\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(object, tag) {\n  if (Symbol && Symbol.toStringTag) {\n    definePrototypeProperties(object.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","/**\n * @module helpers/checkTypes\n * @private\n * @mixin\n * @description Exports is<Type> methods.\n */\n\nimport { toStringTag } from './toStringTag';\n\n/**\n * @function isArray\n * @public\n * @param {*} value - Value to check if it is an array.\n * @returns {Boolean} If the argument is an array or not.\n * \n * @example\n * isArray([]);                             // true\n * isArray(0);                              // true\n * isArray(document.querySelectorAll('*')); // false\n */\nexport const { isArray } = Array;\n\n/**\n * @function isFunction\n * @public\n * @param {*} value - Value to check if it is a function.\n * @returns {Boolean} If the argument is a function or not.\n * \n * @example\n * isFunction(() => {});            // true\n * \n * const func = () => {};\n * Object.setPrototypeOf(func, {});\n * isFunction(func);                // true\n */\nexport function isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\n * @function isNil\n * @public\n * @param {*} value - Value to check if it is null or undefined.\n * @returns {Boolean} If the argument is null or undefined or not.\n *\n * @example\n * isNil(null);      // true\n * isNil(undefined); // true\n * isNil(false);     // false\n */\nexport function isNil(value) {\n  /* eslint eqeqeq: 0 */\n  return value == null;\n}\n\n/**\n * @function isString\n * @public\n * @param {*} value - Value to check if it is a string.\n * @returns {Boolean} If the argument is a string or not.\n *\n * @example\n * isString('0');             // true\n * isString(new String('0')); // true\n */\nexport function isString(value) {\n  return toStringTag(value) === 'String';\n}\n","const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\nconst regexpSpecialsRegexp = new RegExp(\n  regexpSpecialCharacters\n    .map((s) => `\\\\${ s }`)\n    .join('|'),\n  'g'\n);\n\nexport function escapeRegex(string) {\n  return string.replace(regexpSpecialsRegexp, '\\\\$&');\n}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_REGEX = /^xlink:\\w/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\n\nexport function getAttrNS(attr, elem) {\n  if (attr === 'xmlns' || attr === 'xmlns:xlink') {\n    return elem.nodeName === 'SVG'\n      ? XML_NS\n      : null;\n  }\n\n  if (X_LINK_ATTR_REGEX.test(attr)) {\n    return new Elem(elem).closest('svg').length\n      ? X_LINK_NS\n      : null;\n  }\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { Elem } from '../../Elem';\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { isElem } from './isElem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n","import { toStringTag } from '../../utils';\n\nexport function isHTMLDocument(value) {\n  return toStringTag(value) === 'HTMLDocument';\n}\n","import { toStringTag } from '../../utils';\n\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || tag === 'HTMLDocument'\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './isElem';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\n\nconst {\n  document = {}\n} = global;\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, keys } from '../../utils';\n\nexport function calculateArgs(args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  /* eslint guard-for-in: 0 */\n  for (const arg in args) {\n    argsObject[arg] = args[arg];\n  }\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { escapeRegex } from '../../utils';\n\nexport function constructMixinRegex(name) {\n  return new RegExp(`^${ escapeRegex(name) }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n","const COMMA_REGEX = /,/;\n\nexport function mixinMatch(mixins, attr) {\n  let match;\n\n  /* eslint guard-for-in: 0 */\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (argsMatch === '') {\n        args = [];\n      } else if (argsMatch) {\n        args = argsMatch.split(COMMA_REGEX);\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n\n  return match;\n}\n","import { collectFromObject, assign } from '../../utils';\nimport { D_REST_REGEX } from '../../constants';\nimport { mixinMatch } from './mixinMatch';\n\nexport function transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return collectFromObject(attrs, (eventualAttrs, value, attr) => {\n    if (D_REST_REGEX.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  });\n}\n\nexport function transformRestArgs(args) {\n  return collectFromObject(args, addArgs);\n}\n\nfunction addArgs(args, value, arg) {\n  if (D_REST_REGEX.test(arg)) {\n    assign(args, transformRestArgs(value));\n  } else {\n    args[arg] = value;\n  }\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","export function createMixin({\n  name, Mixin, dynamic,\n  value, args, comment, elem,\n  parentBlock, parentScope, parentTemplate\n}) {\n  const mixin = new Mixin({\n    name,\n    value,\n    dynamic,\n    args,\n    comment,\n    elem,\n    parentBlock,\n    parentScope,\n    parentTemplate\n  });\n\n  if (Mixin.evaluate) {\n    const value = mixin.value = mixin.evaluate((newValue, oldValue) => {\n      mixin.value = newValue;\n\n      try {\n        mixin.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    });\n\n    mixin.afterUpdate(value);\n  }\n\n  return mixin;\n}\n","import { iterateObject, iterateArray } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\nimport { createMixin } from './createMixin';\n\nexport function calculateAttrs(attrs, attrsObject, elem, firstTime) {\n  iterateObject(attrsObject, ({ type, value }, attr) => {\n    if (!attrs[attr]) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = [];\n\n  /* eslint guard-for-in: 0 */\n  for (const attr in attrs) {\n    const {\n      type,\n      dynamic,\n      value,\n      opts\n    } = attrs[attr];\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        const mixin = prevValue;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n        }\n\n        mixin.$$.isDynamic = dynamic;\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(value, (newValue) => {\n            const {\n              type,\n              dynamic\n            } = attrs[attr];\n\n            if (type === 'mixin' && !dynamic) {\n              executeMixinWatchers(mixin, newValue);\n            }\n          }, mixin);\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        }\n\n        nextValue = mixin;\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = createMixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(value, (newValue) => {\n              const {\n                type,\n                dynamic\n              } = attrs[attr];\n\n              if (type === 'mixin' && !dynamic) {\n                executeMixinWatchers(mixin, newValue);\n              }\n            }, mixin);\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  }\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, (buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: {\n        temp: [],\n        perm: []\n      }\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher.onRemove();\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { Scope } from '../../constants';\nimport { removeTempWatcher } from './removeWatcher';\n\nlet changed;\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n    const { watchers } = scope;\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (Scope.evalMode) {\n          if (Scope.gettingVars.indexOf(watchers.temp) === -1) {\n            Scope.gettingVars.push(watchers.temp);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        if (!changed) {\n          changed = [];\n        }\n\n        const oldTempWatchers = watchers.temp.slice();\n        const oldValue = scope.value;\n\n        watchers.temp = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n        changed.push({\n          scope,\n          oldValue,\n          value\n        });\n\n        setTimeout(() => {\n          if (!changed) {\n            return;\n          }\n\n          const was = [];\n          const values = [];\n\n          for (let i = changed.length - 1; i >= 0; i--) {\n            const {\n              scope,\n              value,\n              oldValue\n            } = changed[i];\n\n            iterateArray(scope.watchers.perm, (watcher) => {\n              const index = was.indexOf(watcher);\n\n              if (index === -1) {\n                was.push(watcher);\n                values.push({\n                  value,\n                  oldValue\n                });\n              } else {\n                values[index].oldValue = oldValue;\n              }\n            });\n\n            changed.splice(i, 1);\n          }\n\n          changed = null;\n\n          iterateArray(was, (watcher, i) => {\n            const {\n              value,\n              oldValue\n            } = values[i];\n\n            watcher(value, oldValue);\n          });\n        }, 0);\n      }\n    };\n  }));\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil\n} from '../../utils';\nimport { Elem } from '../../Elem';\nimport {\n  SVG_NS, D_REST_REGEX\n} from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { transformRestAttrs } from './transformRestAttrs';\nimport { calculateAttrs } from './calculateAttrs';\nimport { mixinMatch } from './mixinMatch';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { Block } from '../../Block';\n\nconst NAMED_D_BLOCK_REGEX = /^d-block:([\\s\\S]+)$/;\n\nexport function createBlock({ node, Constructor, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = new Elem(parentElem[0].ownerDocument);\n  const elem = parentElem[0].namespaceURI === SVG_NS\n    ? doc.create('svg')\n    : doc;\n  const localBlocks = parentTemplate ? parentTemplate.$$.ns._blocks : Block._blocks;\n  const localMixins = parentTemplate ? parentTemplate.$$.ns._mixins : Block._mixins;\n  let children = node.children = node.children || [];\n  let args = node.attrs = node.attrs || {};\n  let name = node.name || 'UnknownBlock';\n  let constructor = Constructor || (node.name && localBlocks[node.name]);\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n  let dBlockChildren;\n  let dElementsName;\n  let dElementsConstructor;\n\n  if (name === 'd-block' && args.name) {\n    name = 'd-elements';\n    constructor = localBlocks[name];\n    dElementsName = args.name;\n    dBlockArgs = except(args, 'name');\n    dBlockChildren = children;\n    children = [];\n    args = {};\n  } else if (name === 'd-block' && args.Constructor) {\n    name = 'UnknownBlock';\n    constructor = localBlocks[name];\n    dElementsConstructor = args.Constructor;\n    dBlockArgs = except(args, 'Constructor');\n    dBlockChildren = children;\n    children = [];\n    args = {};\n  } else if ((dBlockMatch = name.match(NAMED_D_BLOCK_REGEX)) || name === 'd-block') {\n    constructor = Block._blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const {\n      value,\n      children\n    } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = create(null);\n    let attrs = create(null);\n    let wasDRest;\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    iterateObject(args, (value, attr) => {\n      const isDRest = D_REST_REGEX.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? create(attrs)\n        : attrs;\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          setTimeout(() => {\n            iterateObject(localAttrs, cleanProperty);\n            assign(localAttrs, transformRestAttrs(\n              value, localMixins, mixinDefaultOpts\n            ));\n            calculateAttrs(attrs, currentAttrs, element, false);\n          }, 0);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        if (value === true) {\n          value = 'true';\n        }\n\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    const createMixins = calculateAttrs(attrs, currentAttrs, element, true);\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        element.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      element.text(`${ text }`);\n    }\n\n    if (children) {\n      const parentElem = name === 'template'\n        ? new Elem(element[0].content)\n        : element;\n      let prevBlock;\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }\n\n    const isParentBlock = parent instanceof Block;\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    createMixins();\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  if (dElementsName) {\n    node = {\n      attrs: dBlockArgs,\n      children: dBlockChildren\n    };\n    node.name = parentScope.$$.evaluate(dElementsName, (newName) => {\n      node.name = newName;\n\n      Args.value = [node];\n    }, blockInstance, true);\n\n    Args.value = [node];\n    Args.parentScope = parentScope;\n    Args.parentTemplate = parentTemplate;\n  }\n\n  if (dElementsConstructor) {\n    node = {\n      name,\n      attrs: dBlockArgs,\n      children: dBlockChildren\n    };\n\n    Args.Constructor = parentScope.$$.evaluate(dElementsConstructor, (newConstructor) => {\n      Args.Constructor = newConstructor;\n      Args.value = [node];\n    }, blockInstance, true);\n    Args.value = [node];\n    Args.parentScope = parentScope;\n    Args.parentTemplate = parentTemplate;\n  }\n\n  const html = name === 'd-elements'\n    ? Args.value || []\n    : constructor._html;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  if (name === 'd-each') {\n    $$.scope = create(parentScope.$$.name === '#d-item' ? parentScope.$$.scope : parentScope, {\n      [Args.item || '$item']: {\n        value: null,\n        writable: true\n      },\n      [Args.index || '$index']: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","import { setProto } from '../../utils';\nimport { Block } from '../../Block';\n\nexport function extendBlock(cls) {\n  setProto(cls, Block);\n  setProto(cls.prototype, Block.prototype);\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { iterateObject } from '../../utils';\n\nexport function watchForAllLocals(block, watcher) {\n  iterateObject(block.$$.locals, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n\nexport function watchForAllGlobals(block, watcher) {\n  const {\n    globals,\n    watchersToRemove\n  } = block.$$;\n\n  for (const glob in globals) {\n    /* eslint guard-for-in: 0 */\n    const watchers = globals[glob].watchers.perm;\n\n    watchers.push(watcher);\n    watchersToRemove.push({\n      watcher,\n      watchers\n    });\n  }\n}\n\nexport function watchForAllArgs(block, watcher) {\n  iterateObject(block.$$.args, ({ watchers }) => {\n    watchers.perm.push(watcher);\n  });\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n","import { isArray } from './utils';\nimport { createBlock } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\nexport function initApp(html, container) {\n  const parentElem = new Elem(container).elem(0);\n\n  if (!parentElem.length) {\n    throw new Error('No valid element to insert the app into was given! (initApp)');\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    throw new Error('There already exists a Dwayne app inside the given element! (initApp)');\n  }\n\n  if (isArray(html)) {\n    html = {\n      vars: [],\n      value: html\n    };\n  }\n\n  class RootBlock extends Block {\n    static _vars = html.vars;\n    static _html = html.value\n  }\n\n  const block = createBlock({\n    node: {\n      name: '#RootBlock'\n    },\n    Constructor: RootBlock,\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', block)\n    .attr('dwayne-root', '');\n}\n","import { collectFromArray, findInArray, iterateArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-switch'] = class DSwitch extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren,\n        parentScope\n      },\n      args,\n      args: { value }\n    } = this;\n    let wasDefault;\n\n    this.values = collectFromArray(htmlChildren, (values, child, i) => {\n      const {\n        name,\n        attrs,\n        children\n      } = child;\n      let val = attrs.if;\n\n      if (wasDefault) {\n        return;\n      }\n\n      if (name !== 'd-case' && name !== 'd-default') {\n        return;\n      }\n\n      if (name === 'd-default') {\n        wasDefault = true;\n      }\n\n      if (name === 'd-default') {\n        val = value;\n      } else if (val) {\n        val = parentScope.$$.evaluate(val, (newValue) => {\n          if (equals(this.values[i].value, newValue)) {\n            return;\n          }\n\n          this.values[i].value = newValue;\n\n          if (i > this.index) {\n            return;\n          }\n\n          if (i < this.index) {\n            this.index = i;\n            this.elems = children;\n\n            return;\n          }\n\n          const found = findInArray(this.values, ({ value }) => (\n            equals(value, args.value)\n          ));\n\n          if (found) {\n            this.index = found.key;\n            this.elems = found.value.children;\n          } else {\n            this.index = Infinity;\n            this.elems = null;\n          }\n        }, this);\n      } else {\n        val = undefined;\n      }\n\n      if (equals(val, value) && this.index === Infinity) {\n        this.index = i;\n        this.elems = children;\n      }\n\n      values.push({\n        name,\n        children,\n        value: val\n      });\n    }, []);\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, () => {\n      const {\n        value: newValue\n      } = this.args;\n\n      this.index = Infinity;\n\n      iterateArray(this.values, ({ name, value, children }, i) => {\n        const val = name === 'd-default'\n          ? newValue\n          : value;\n\n        if (equals(val, newValue) && this.index === Infinity) {\n          this.index = i;\n          this.elems = children;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n};\n\nfunction equals(value1, value2) {\n  return value1 === value2;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\n\nrootMixins['d-style'] = class DStyle extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      css\n    } = this;\n\n    elem.removeCSS.apply(elem, keys(css));\n  }\n};\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n","import {\n  isArray, isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-value'] = class DValue extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem,\n      node\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.find('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.name = args[0];\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n    }\n\n    if (!isFunction(value)) {\n      initialScopeValue = this.scope.$$.evaluate(getEvalFunction(value), (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), (e) => {\n      if (e.target === node) {\n        changeScope();\n      }\n    });\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove() {\n    this.offElemListener();\n    this.offFormListener();\n  }\n};\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        if (values) {\n          return values.indexOf(inputValue) === -1\n            ? values.concat(inputValue)\n            : values;\n        }\n\n        return [inputValue];\n      }\n\n      if (!isArray(values)) {\n        return [];\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction getEvalFunction(value) {\n  return (scope) => scope[value];\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n","import {\n  toObjectKeys, iterateArray,\n  assign, keys, create\n} from './utils';\n\nexport function insertTemplates(template, templates) {\n  const {\n    vars,\n    value\n  } = template;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n  iterateArray(value, forEachNode);\n\n  function forEachNode({ type, value, children }, index, tree) {\n    if (type === '#comment') {\n      value = value.trim();\n\n      if (newTemplates[value]) {\n        tree[index] = newTemplates[value].value;\n        assign(newVars, toObjectKeys(newTemplates[value].vars));\n      }\n    } else {\n      iterateArray(children, forEachNode);\n    }\n  }\n\n  vars.length = 0;\n  vars.push(...keys(newVars));\n\n  return template;\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\nexport function removeApp(node) {\n  const elem = new Elem(node);\n\n  if (!elem.length) {\n    throw new Error('No valid element to remove the app from was given! (removeApp)');\n  }\n\n  node = elem[0];\n\n  const { DwayneRootBlock } = node;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    throw new Error('No app registered inside the given element! (removeApp)');\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete node.DwayneRootBlock;\n}\n","/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint no-proto: 0 */\n  target.__proto__ = proto;\n});\n","import { create } from '../utils/objectStatics';\n\nexport const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const D_REST_REGEX = /^d-rest(?:#|$)/;\n\nexport const rootBlocks = create(null);\nexport const rootMixins = create(null);\nexport const Scope = {\n  evalMode: false,\n  gettingVars: []\n};\n","import {\n  isNil, isString, assign,\n  definePrototypeProperties, defineProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, toStringTag,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isHTMLDocument, isValidNode,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\nconst { Symbol } = global;\nconst EVENT_SEPARATOR_REGEX = /(?:,| ) */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst EVENT_REGEX = /Event$/;\nconst XHTML_NS = 'http://www.w3.org/1999/xhtml';\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  static addMethods(property, value) {\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    definePrototypeProperties(this.prototype, property);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add() {\n    const elems = this.slice();\n\n    iterateArray(arguments, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromObject(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const ns = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, attr)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const ns = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isHTMLDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        const ns = type === 'svg'\n          ? SVG_NS\n          : elem.namespaceURI || document.documentElement.namespaceURI || XHTML_NS;\n\n        el = document.createElementNS(ns, type);\n      }\n\n      add(new Elem(el).into(elem));\n    });\n  }\n\n  /**\n   * @method Elem#createComment\n   * @public\n   * @param {String} text - Text of the comment.\n   * @returns {Elem} New instance of Elem - wrap of the created comments.\n   * @description Method for creating comments inside this element.\n   * If this element is not an Element the comment is just created.\n   *\n   * @example\n   * elem.createComment('comment');\n   */\n  createComment(text) {\n    return this\n      .create('#comment')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#createText\n   * @public\n   * @param {String} text - Text.\n   * @returns {Elem} New instance of Elem - wrap of the created text nodes.\n   * @description Method for creating text nodes inside this element.\n   * If this element is not an Element the text node is just created.\n   *\n   * @example\n   * elem.createText('text');\n   */\n  createText(text) {\n    return this\n      .create('#text')\n      .text(text);\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details || {};\n    let finalEvent = event;\n\n    if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n      try {\n        finalEvent = new Event(finalEvent, { bubbles, cancelable });\n        assign(finalEvent, realDetails);\n      } catch (err) {}\n    }\n\n    return this.forEach((elem) => {\n      if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n        const document = isHTMLDocument(elem)\n          ? elem\n          : elem.ownerDocument;\n\n        finalEvent = document.createEvent('Event');\n        finalEvent.initEvent(event, bubbles, cancelable);\n\n        assign(finalEvent, realDetails);\n      }\n\n      elem.dispatchEvent(finalEvent);\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback} [filterFn = Boolean] - Filter function\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filterFn = Boolean) {\n    return this.collect((add, elem, index) => {\n      if (filterFn(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const ns = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (\n      !element\n      || isHTMLDocument(element)\n    ) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = (\n      elem.matches\n      || elem.matchesSelector\n      || elem.webkitMatchesSelector\n      || elem.mozMatchesSelector\n      || elem.msMatchesSelector\n      || elem.oMatchesSelector\n    );\n\n    try {\n      return matches.call(elem, selector);\n    } catch (err) {\n      console.error(`Selector '${ selector }' is not a valid selector (Elem#is)`);\n\n      return false;\n    }\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem && elem.nodeName\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   'input, select, textarea, datalist, keygen, output',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   {\n   *     'change, input': (e, elem, index) => console.log(elem.value),\n   *     'blur': () => console.log('blur')\n   *   },\n   *   'input, select, textarea, datalist, keygen, output'\n   * );\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (attr) => {\n        const ns = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      classList.toggle(cls, arguments.length < 2 ? !classList.contains(cls) : condition);\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\n\nif (Symbol && Symbol.species) {\n  defineProperties(Elem, {\n    [Symbol.species]: {\n      get() {\n        return Array;\n      }\n    }\n  });\n}\n\nexport { Elem };\n","import {\n  defineFrozenProperties,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\nclass Mixin {\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n\n    defineFrozenProperties(this, {\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {String} [Mixin#comment]\n     * @type {String}\n     * @public\n     */\n    this.comment = comment;\n\n    /**\n     * @member {Block} [Mixin#parentBlock]\n     * @type {Block}\n     * @public\n     */\n    this.parentBlock = parentBlock;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    if (parentBlock) {\n      parentBlock.$$.mixins.push(this);\n    }\n  }\n\n  afterUpdate() {}\n\n  beforeRemove() {}\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, isArray,\n  setToStringTag, hasOwnProperty,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  constructMixinRegex, isInstanceOf,\n  removeWatchers, removeWithParentSignal, cleanProperty,\n  transformRestArgs, calculateArgs,\n  watchForAllArgs, watchForAllGlobals, watchForAllLocals,\n  extendBlock, wrapBlock\n} from './helpers/Block';\nimport {\n  D_REST_REGEX, Scope,\n  rootBlocks, rootMixins\n} from './constants';\nimport { initApp } from './initApp';\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {String} expression - Expression which has been evaluated with the error.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback VarsWatcher\n * @public\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {*} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {Block} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\nconst blockHooks = [];\nconst mixinHooks = [];\nconst TAG_NAME_REGEX = /^[a-z][a-z\\d\\-_.:!@#$%^&*()[\\]{}='\"\\\\]*$/i;\nconst ATTR_NAME_REGEX = /^[\\u0000-\\u0020\\s'\">/=]+$/;\nconst WATCHED_ARG_PREFIX_REGEX = /^args\\./;\nconst WATCHED_GLOBAL_PREFIX_REGEX = /^globals\\./;\nconst afterElem = new Elem();\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Element options.\n * @returns {Block} Instance of Block.\n * @description Class for dynamic templating.\n *\n * @example\n * import { D, Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/>';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world (0)';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     D(1000).interval(() => {\n *       this.text = `world (${ ++this.times })`;\n *     });\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', 'Hello, {args.text}!');\n *\n * initApp(html`<App/>`, document.getElementById('root'));\n */\nclass Block {\n  static _blocks = create(rootBlocks);\n  static _mixins = create(rootMixins);\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {Object} [Block.template = { vars: [], value: [] }]\n   * @type {Object}\n   * @public\n   * @description Block template.\n   */\n  static template = {\n    vars: [],\n    value: []\n  };\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.expression }\" in context of block \"${ err.block.$$.name }\"):`, err);\n  }\n\n  /**\n   * @method Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   */\n  static beforeRegisterBlock(hook) {\n    blockHooks.push(hook);\n\n    return () => {\n      removeArrayElem(blockHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   */\n  static beforeRegisterMixin(hook) {\n    mixinHooks.push(hook);\n\n    return () => {\n      removeArrayElem(mixinHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Template|typeof Block} Subclass - Subclass of Block or template string of it.\n   * @returns {typeof Block|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        constructor(opts) {\n          super(opts);\n\n          this::constructor(opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass)) {\n      Subclass = class extends Block {\n        static template = {\n          vars: [],\n          value: Subclass\n        };\n      };\n    }\n\n    if (!isFunction(Subclass) && Subclass.vars && Subclass.value) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (!isFunction(Subclass)) {\n      console.warn(`Block must be a string (representing a block template), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      extendBlock(Subclass);\n    }\n\n    if (rootBlocks[name]) {\n      console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!TAG_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_blocks')) {\n      this._blocks = create(getProto(this)._blocks);\n    }\n\n    if (!hasOwnProperty(this, 'defaultLocals')) {\n      this.defaultLocals = {};\n    }\n\n    if (!hasOwnProperty(this, 'defaultArgs')) {\n      this.defaultArgs = create(null);\n    }\n\n    try {\n      Subclass = blockHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Block, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterBlock\" hook:', err);\n    }\n\n    const {\n      vars,\n      value\n    } = Subclass.template;\n\n    Subclass._html = value;\n    Subclass._vars = vars;\n\n    if (hasOwnProperty(Subclass, 'defaultArgs')) {\n      setProto(Subclass.defaultArgs, null);\n    }\n\n    this._blocks[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.init\n   * @public\n   * @param {Elem|Element} container - Container of the app.\n   * @returns {void}\n   * @description Method for initializing app.\n   */\n  static init(container) {\n    const klass = this;\n\n    initApp(htmlScopeless`<d-block Constructor=\"{klass}\"/>`, container);\n  }\n\n  /**\n   * @method Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {typeof Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {typeof Mixin|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          this::afterUpdate(newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin and will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (rootMixins[name]) {\n      console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!ATTR_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_mixins')) {\n      this._mixins = create(getProto(this)._mixins);\n    }\n\n    try {\n      Subclass = mixinHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Mixin, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterMixin\" hook:', err);\n    }\n\n    Subclass._match = constructMixinRegex(name);\n\n    this._mixins[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const constructor = getProto(this).constructor;\n    const childrenBlocks = [];\n    const mixins = [];\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Block} Block#$\n       * @type {Block}\n       * @public\n       * @description This.\n       */\n      $: this,\n\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} args - Private args scope.\n       * @property {Object[]} htmlChildren - Block html children.\n       * @property {Block[]} children - Child blocks.\n       * @property {Mixin[]} mixins - Child mixins.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Elem} content - Content elements.\n       * @property {Function} evaluate - Evaluate function.\n       * @property {Object} globals - Private globals scope.\n       * @property {Object} locals - Private locals scope.\n       * @property {Object[]} watchersToRemove - Watchers to remove before removing element.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlocks: [],\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        htmlChildren: children,\n        children: childrenBlocks,\n        mixins,\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forDElements, forDItem, forDEach) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = (name === '#d-item' && !forDItem) || forDEach\n            ? (forDEach || this).$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : {};\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              Scope.evalMode = true;\n              Scope.gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.expression = func.expression;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error('Uncaught error in onEvalError:', e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(Scope.gettingVars, (watchers) => {\n                const watcher = () => {\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                watcher.onRemove = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              Scope.evalMode = false;\n              Scope.gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(mixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered) {\n            try {\n              this.afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterContentChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor._vars, (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    let args = create(constructor.defaultArgs || null);\n    let wasDRest;\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isDRest = D_REST_REGEX.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? create(args)\n        : args;\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, transformRestArgs(value));\n          calculateArgs(args, argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return assign(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      if (name !== 'd-each' || arg !== 'uid') {\n        value = parentScope.$$.evaluate(value, (value) => {\n          localArgs[arg] = value;\n          calculateArgs(args, argsObject);\n        }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n      }\n\n      localArgs[arg] = value;\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getChildBlocks\n   * @public\n   * @returns {Block[]}\n   * @description Returns child blocks.\n   */\n  getChildBlocks() {\n    return this.$$.blocks.slice();\n  }\n\n  /**\n   * @method Block#getChildBlocks\n   * @public\n   * @returns {Mixin[]}\n   * @description Returns child mixins.\n   */\n  getChildMixins() {\n    return this.$$.mixins.slice();\n  }\n\n  /**\n   * @method Block#getChildren\n   * @public\n   * @returns {Object[]}\n   * @description Returns Block HTML children.\n   */\n  getChildren() {\n    return this.$$.htmlChildren;\n  }\n\n  /**\n   * @method Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#getParentBlock\n   * @public\n   * @returns {Block|void}\n   * @description Returns parent block.\n   */\n  getParentBlock() {\n    return this.$$.parentBlock;\n  }\n\n  /**\n   * @method Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @method Block#getParentScope\n   * @public\n   * @returns {Block|void}\n   * @description Returns parent scope.\n   */\n  getParentScope() {\n    return this.$$.parentScope;\n  }\n\n  /**\n   * @method Block#getParentTemplate\n   * @public\n   * @returns {Block|void}\n   * @description Returns parent template.\n   */\n  getParentTemplate() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  /**\n   * @method Block#watch\n   * @public\n   * @param {...('args'|'globals'|String)} [vars] - Vars to watch (args, globals or locals).\n   * If no specified all locals, args and globals are to be watched.\n   * If the 'args' string all args are to be watched.\n   * If the 'globals' string all globals are to be watched.\n   * @param {VarsWatcher} watcher - Called when watched vars are changed.\n   * @description Method for watching for vars. If no vars passed in arguments\n   * all vars are to be watched. If the 'args' string is in the arguments all args are to be watched.\n   * If the 'globals' string is in the arguments all globals are to be watched.\n   * Otherwise specified vars will be watched.\n   * Watchers should not be put inside the constructor. It is considered best\n   * practice to do it inside the {@link Block#afterConstruct} method.\n   * Note that these expressions (vars, i.e. \"args.arg\") are not to be\n   * evaluated so you cannot put there things like \"a[b]\" or any js code,\n   * only expressions like \"a\", \"b\", \"args.a\", \"args.b\" and \"globals.a\", \"globals.b\".\n   * Also note that if there are more than one var that are changed at once (synchronously)\n   * the watcher is called only once.\n   * Note that the watcher is executed right away because in most cases\n   * this behaviour is very convenient.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div />';\n   *\n   *   afterConstruct() {\n   *     this.watch('a', () => {});\n   *     this.watch('args.a', 'globals.r', () => {});\n   *     this.watch(() => {});\n   *   }\n   * }\n   */\n  watch(...vars) {\n    const oldWatcher = arguments[arguments.length - 1];\n\n    if (!isFunction(oldWatcher)) {\n      console.warn(`The last argument (watcher) wasn't specified (${ this.$$.name }#watch)`);\n\n      return;\n    }\n\n    const watcher = () => {\n      oldWatcher();\n    };\n\n    if (arguments.length === 1) {\n      watchForAllLocals(this, watcher);\n      watchForAllArgs(this, watcher);\n      watchForAllGlobals(this, watcher);\n\n      oldWatcher();\n\n      return;\n    }\n\n    iterateArray(arguments, (variable) => {\n      if (variable === oldWatcher) {\n        return;\n      }\n\n      variable = `${ variable }`;\n\n      if (variable === '$') {\n        return watchForAllLocals(this, watcher);\n      }\n\n      if (variable === 'args') {\n        return watchForAllArgs(this, watcher);\n      }\n\n      if (variable === 'globals') {\n        return watchForAllGlobals(this, watcher);\n      }\n\n      if (WATCHED_ARG_PREFIX_REGEX.test(variable)) {\n        variable = variable.replace(WATCHED_ARG_PREFIX_REGEX, '');\n\n        if (!this.$$.args[variable]) {\n          return;\n        }\n\n        this.$$.args[variable].watchers.perm.push(watcher);\n\n        return;\n      }\n\n      if (WATCHED_GLOBAL_PREFIX_REGEX.test(variable)) {\n        variable = variable.replace(WATCHED_GLOBAL_PREFIX_REGEX, '');\n\n        if (!this.$$.globals[variable]) {\n          return;\n        }\n\n        const { watchers } = this.$$.globals[variable];\n\n        watchers.perm.push(watcher);\n        this.$$.watchersToRemove.push({\n          watcher,\n          watchers\n        });\n\n        return;\n      }\n\n      if (!this.$$.locals[variable]) {\n        return;\n      }\n\n      this.$$.locals[variable].watchers.perm.push(watcher);\n    });\n\n    oldWatcher();\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block };\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nrootBlocks['d-block'] = class DBlock extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{ParentScope}\"\n      parentTemplate=\"{ParentTemplate}\"\n    />\n  `;\n\n  afterConstruct() {\n    const {\n      parentScope: {\n        $$: {\n          parentScope: parentParentScope,\n          parentTemplate: parentParentTemplate,\n          htmlChildren: children\n        }\n      },\n      htmlChildren: ownChildren,\n      parentTemplate,\n      dBlockName\n    } = this.$$;\n    let found;\n\n    if (ownChildren.length) {\n      return;\n    }\n\n    this.ParentScope = parentParentScope;\n    this.ParentTemplate = parentParentTemplate;\n\n    if (dBlockName) {\n      found = findInArray(children, ({ name: nodeName }) => nodeName === `d-block:${ dBlockName }`);\n\n      if (!found) {\n        let parent = this;\n\n        /* eslint no-empty: 0 */\n        while (\n        (parent = parent.$$.parentScope)\n        && !(found = findInArray(parent.$$.dBlocks, ({ $$: { dBlockName: DBlockName } }) => DBlockName === dBlockName))\n        && parent.$$.parentScope.$$.name === '#d-item'\n          ) {}\n\n        if (found) {\n          this.ParentScope = parent;\n          this.ParentTemplate = parentTemplate;\n          found.value = {\n            children: found.value.$$.htmlChildren\n          };\n        }\n      }\n\n      this.elems = found && found.value.children.length\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = children;\n    }\n  }\n};\n","import { Block } from '../Block';\n\nconst template = html`\n  <d-elements\n    value=\"{$$.htmlChildren}\"\n    parentScope=\"{this}\"\n    parentTemplate=\"{$$.parentTemplate}\"\n  />\n`;\n\nclass DItem extends Block {\n  static template = template;\n  static _vars = template.vars;\n  static _html = template.value;\n}\n\nexport { DItem };\n","import {\n  assign, iterateArray, iterateObject,\n  isArray, isFunction\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\nimport { DItem } from './d-item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nrootBlocks['d-each'] = class DEach extends Block {\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item: itemName = '$item',\n        index: indexName = '$index'\n      }\n    } = this;\n\n    assign(this.$$, {\n      itemsByUIDs: {},\n      UID: this.args.uid || undefined,\n      itemName,\n      indexName\n    });\n  }\n\n  afterRender() {\n    this.evaluate(watchArgs, this.renderSet);\n    this.renderSet();\n  }\n\n  renderSet = () => {\n    const {\n      htmlChildren,\n      itemsByUIDs,\n      parentScope,\n      parentElem,\n      parentTemplate,\n      scope,\n      itemName,\n      indexName,\n      UID\n    } = this.$$;\n    const {\n      args: { sortBy }\n    } = this;\n    const newItemsByUIDs = {};\n    const newUIDsCounter = {};\n    const newUIDs = {};\n    let {\n      set,\n      filterBy\n    } = this.args;\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      scope[itemName] = item;\n      scope[indexName] = index;\n\n      const uid = parentScope.$$.evaluate(UID, null, null, false, false, this);\n\n      newUIDsCounter[uid] = (newUIDsCounter[uid] || 0) + 1;\n      newUIDs[index] = uid;\n    });\n\n    scope[itemName] = null;\n    scope[indexName] = null;\n\n    iterateObject(itemsByUIDs, (items, uid) => {\n      if (!newUIDsCounter[uid]) {\n        iterateArray(items, remove);\n\n        return;\n      }\n\n      iterateArray(items.splice(newUIDsCounter[uid]), remove);\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (itemsByUIDs[uid] && itemsByUIDs[uid].length) {\n        block = itemsByUIDs[uid].shift();\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        if (block.$$.prevBlock !== prevBlock && prevBlock) {\n          prevBlock.$$.insertAfterIt(block.$$.content, true);\n        }\n      } else {\n        block = createBlock({\n          node: {\n            itemName,\n            indexName,\n            item,\n            index,\n            name: '#d-item',\n            children: htmlChildren\n          },\n          Constructor: DItem,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      (newItemsByUIDs[uid] = newItemsByUIDs[uid] || []).push(block);\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.$$.itemsByUIDs = newItemsByUIDs;\n  };\n};\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-elements'] = class DElements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      Constructor,\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, () => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n      const { value } = this.args;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n        if (forDElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          Constructor,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }, this, true);\n  }\n};\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nrootBlocks['d-if'] = class DIf extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      parentScope,\n      htmlChildren\n    } = this.$$;\n    let index = Infinity;\n    const values = htmlChildren.map((child, i) => {\n      const {\n        name,\n        attrs = {},\n        children\n      } = child;\n      let cond = attrs.if;\n\n      if (name !== 'd-else' && cond) {\n        cond = parentScope.$$.evaluate(cond, (newValue) => {\n          if (!!newValue === values[i]) {\n            return;\n          }\n\n          values[i] = !!newValue;\n\n          if (i > index) {\n            return;\n          }\n\n          if (i < index) {\n            index = i;\n            this.elems = children;\n\n            return;\n          }\n\n          const found = findInArray(values, Boolean);\n\n          if (found) {\n            index = found.key;\n            this.elems = htmlChildren[found.key].children;\n          } else {\n            index = Infinity;\n            this.elems = null;\n          }\n        }, this);\n      } else {\n        cond = true;\n      }\n\n      if (cond && index === Infinity) {\n        index = i;\n        this.elems = children;\n      }\n\n      return !!cond;\n    });\n  }\n};\n","import { collectFromObject, iterateObject, keys } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-attr'] = class DAttr extends Mixin {\n  attrs = {};\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      attrs\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (attrs, attr) => {\n        attrs[attr] = newValue;\n      });\n    }\n\n    iterateObject(attrs, (value, prop) => {\n      if (!(prop in newValue)) {\n        elem.removeAttr(prop);\n      }\n    });\n    elem.attr(newValue);\n\n    this.attrs = newValue;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      attrs\n    } = this;\n\n    elem.removeAttr.apply(elem, keys(attrs));\n  }\n};\n\n","import { isFunction } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-bind'] = class DBind extends Mixin {\n  afterUpdate(value) {\n    if (this.off) {\n      this.off();\n    }\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove() {\n    const { off } = this;\n\n    if (off) {\n      off();\n    }\n  }\n};\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nrootMixins['d-class'] = class DClass extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      classes\n    } = this;\n\n    elem.removeClass.apply(elem, classes);\n  }\n};\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-elem'] = class DElem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-hide'] = class DHide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove() {\n    this.elem.show();\n  }\n};\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-node'] = class DNode extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-on'] = class DOn extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove() {\n    const { off } = this;\n\n    if (off) {\n      off();\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-show'] = class DShow extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove() {\n    this.elem.show();\n  }\n};\n","import { iterateObject } from '../../utils';\nimport { rootBlocks, rootMixins } from '../../constants';\nimport { constructMixinRegex } from './constructMixinRegex';\n\niterateObject(rootBlocks, (Block) => {\n  Block._vars = Block.template.vars;\n  Block._html = Block.template.value;\n});\n\niterateObject(rootMixins, (Mixin, name) => {\n  Mixin._match = constructMixinRegex(name);\n});\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\n\nconst {\n  document = {}\n} = global;\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","assign","target","arguments","source","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","toStringTag","toString","setToStringTag","tag","Symbol","prototype","isFunction","isNil","isString","escapeRegex","string","replace","regexpSpecialsRegexp","toCamelCase","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","nodeName","XML_NS","X_LINK_ATTR_REGEX","test","Elem","closest","X_LINK_NS","hide","ownerDocument","addClass","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isHTMLDocument","isValidNode","ELEMENT_REGEX","remove","parent","removeChild","show","removeClass","toElem","selector","base","document","querySelectorAll","String","calculateArgs","args","argsObject","keys","arg","undefined","cleanProperty","constructMixinRegex","RegExp","mixinMatch","mixins","Mixin","localMatch","_match","argsMatch","COMMA_REGEX","transformRestAttrs","mixinDefaultOpts","eventualAttrs","D_REST_REGEX","transformRestArgs","addArgs","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","createMixin","dynamic","comment","parentBlock","parentScope","parentTemplate","evaluate","newValue","afterUpdate","err","error","calculateAttrs","attrsObject","firstTime","type","removeAttr","opts","nextType","nextDynamic","nextValue","prevType","prevValue","isDynamic","evaluated","buildMixin","firstValue","push","constructPrivateScope","scope","globals","removeTempWatcher","onRemove","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","Scope","evalMode","gettingVars","temp","changed","oldTempWatchers","was","values","perm","createBlock","node","Constructor","parentElem","prevBlock","doc","namespaceURI","SVG_NS","localBlocks","ns","_blocks","Block","localMixins","_mixins","children","constructor","dBlockMatch","dBlockName","dBlockArgs","dBlockChildren","dElementsName","dElementsConstructor","NAMED_D_BLOCK_REGEX","blockInstance","element","currentAttrs","wasDRest","isDRest","localAttrs","restAttrs","createMixins","content","child","isParentBlock","insertAfterIt","insertAfter","addContent","insertInStartOfIt","into","Args","locals","newName","newConstructor","html","_html","itemName","item","indexName","afterConstruct","isRendered","afterRender","extendBlock","cls","isInstanceOf","Class","Subclass","isPrototypeOf","removeWithParentSignal","watchForAllLocals","block","watchForAllGlobals","glob","watchForAllArgs","wrapBlock","wrapper","returnValue","wrapMixin","initApp","container","Error","RootBlock","_vars","equals","value1","value2","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","options","init","isMultiple","addValue","concat","getListenerName","getEvalFunction","selected","insertTemplates","template","templates","forEachNode","tree","trim","newTemplates","newVars","removeApp","DwayneRootBlock","window","global","self","defineProperties","Object","Array","regexpSpecialCharacters","map","s","join","getProto","getPrototypeOf","setProto","setPrototypeOf","proto","__proto__","rootBlocks","rootMixins","CSS_IMPORTANT_REGEX","EVENT_REGEX","emptyCollection","_this","includes","this","elems","forEach","list","classList","attributes","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","elements","cb","contains","el","isText","createTextNode","createComment","documentElement","createElementNS","style","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","event","details","bubbles","cancelable","realDetails","finalEvent","Event","createEvent","initEvent","dispatchEvent","filterFn","Boolean","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","first","method","prev","babelHelpers.get","apply","textContent","condition","_arguments5","toggle","_arguments6","species","_value","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","blockHooks","mixinHooks","TAG_NAME_REGEX","ATTR_NAME_REGEX","WATCHED_ARG_PREFIX_REGEX","WATCHED_GLOBAL_PREFIX_REGEX","afterElem","originalArgs","childrenBlocks","func","onChange","targetBlock","forDElements","forDItem","forDEach","onChangeFlag","result","expression","original","onEvalError","e","localWatchers","newResult","watcherBlock","removeContent","_this7","newContent","afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","filter","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","warn","currentReturnValue","klass","blocks","htmlChildren","oldWatcher","_this8","parentParentScope","parentParentTemplate","ownChildren","found","ParentScope","ParentTemplate","dBlocks","DItem","watchArgs","uid","renderSet","_this2","itemsByUIDs","UID","sortBy","newItemsByUIDs","newUIDsCounter","newUIDs","set","filterBy","isArr","iterate","sort","items","shift","Infinity","cond","if","wasDefault","val","off","on","classes","newClasses","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL3V0aWxzL2lzLmpzIiwiLi4vc3JjL3V0aWxzL2VzY2FwZVJlZ2V4LmpzIiwiLi4vc3JjL3V0aWxzL3RvQ2FzZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkQ1NTUHJvcC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkRGF0YUF0dHIuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2FkZE5leHQuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2FkZFBhcmVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUHJldi5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vY3JlYXRlSGlkZVN0eWxlTm9kZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vZ2V0QXR0ck5TLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9oaWRlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9pc0VsZW0uanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzRWxlbWVudHNDb2xsZWN0aW9uLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9pc0hUTUxEb2N1bWVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaXNWYWxpZE5vZGUuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL3JlbW92ZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vc2hvdy5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vdG9FbGVtLmpzIiwiLi4vc3JjL2ZpbmQuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jYWxjdWxhdGVBcmdzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY2xlYW5Qcm9wZXJ0eS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NvbnN0cnVjdE1peGluUmVnZXguanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9taXhpbk1hdGNoLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svdHJhbnNmb3JtUmVzdEF0dHJzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svZXhlY3V0ZU1peGluV2F0Y2hlcnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jcmVhdGVNaXhpbi5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUF0dHJzLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0UHJpdmF0ZVNjb3BlLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svcmVtb3ZlV2F0Y2hlci5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NvbnN0cnVjdFB1YmxpY1Njb3BlLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY3JlYXRlQmxvY2suanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9leHRlbmRCbG9jay5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2lzSW5zdGFuY2VPZi5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlbW92ZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3dhdGNoRm9yQWxsLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svd3JhcC5qcyIsIi4uL3NyYy9pbml0QXBwLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLXN3aXRjaC5qcyIsIi4uL3NyYy9taXhpbnMvZC1zdHlsZS5qcyIsIi4uL3NyYy9taXhpbnMvZC12YWx1ZS5qcyIsIi4uL3NyYy9pbnNlcnRUZW1wbGF0ZXMuanMiLCIuLi9zcmMvcmVtb3ZlQXBwLmpzIiwiLi4vc3JjL2dsb2JhbC5qcyIsIi4uL3NyYy91dGlscy9vYmplY3RTdGF0aWNzLmpzIiwiLi4vc3JjL2NvbnN0YW50cy9pbmRleC5qcyIsIi4uL3NyYy9FbGVtLmpzIiwiLi4vc3JjL01peGluLmpzIiwiLi4vc3JjL0Jsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWJsb2NrLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWl0ZW0uanMiLCIuLi9zcmMvYmxvY2tzL2QtZWFjaC5qcyIsIi4uL3NyYy9ibG9ja3MvZC1lbGVtZW50cy5qcyIsIi4uL3NyYy9ibG9ja3MvZC1pZi5qcyIsIi4uL3NyYy9taXhpbnMvZC1hdHRyLmpzIiwiLi4vc3JjL21peGlucy9kLWJpbmQuanMiLCIuLi9zcmMvbWl4aW5zL2QtY2xhc3MuanMiLCIuLi9zcmMvbWl4aW5zL2QtZWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvZC1oaWRlLmpzIiwiLi4vc3JjL21peGlucy9kLW5vZGUuanMiLCIuLi9zcmMvbWl4aW5zL2Qtb24uanMiLCIuLi9zcmMvbWl4aW5zL2Qtc2hvdy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlZ2lzdGVyQnVpbHRpbnMuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi9hcnJheSc7XG5cbmNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuY29uc3QgeyBzbGljZSB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChzb3VyY2UsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSA9IHt9KSB7XG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGNhbGxiYWNrKGluaXRpYWxWYWx1ZSwgdmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VwdChvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG4gIGNvbnN0IHBhdGhzID0gYXJndW1lbnRzOjpzbGljZSgxKTtcblxuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAocGF0aHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0OjpoYXMoa2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG5cbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgbmV3T2JqZWN0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZU9iamVjdCB9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lRnJvemVuUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIGZyb3plbiBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIH0gZnJvbSAnLi9kZWZpbmVQcm9wZXJ0eSc7XG5cbmNvbnN0IHsgU3ltYm9sIH0gPSBnbG9iYWw7XG5jb25zdCB7IHRvU3RyaW5nIH0gPSB7fTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdG9TdHJpbmdUYWdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGdldCB0b1N0cmluZ1RhZyBvZi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEN1dCBzdHJpbmcuXG4gKiBAZGVzY3JpcHRpb24gQ3V0IFwiVHlwZVwiIHN0cmluZyBmcm9tIFwiW29iamVjdCBUeXBlXVwiIHN0cmluZyB0aGF0IGdvdHRlbiBmcm9tIHt9LnRvU3RyaW5nLGNhbGwob2JqZWN0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0Ojp0b1N0cmluZygpLnNsaWNlKDgsIC0xKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKG9iamVjdCwgdGFnKSB7XG4gIGlmIChTeW1ib2wgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyhvYmplY3QucHJvdG90eXBlLCB7XG4gICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogdGFnXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2NoZWNrVHlwZXNcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGlzPFR5cGU+IG1ldGhvZHMuXG4gKi9cblxuaW1wb3J0IHsgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3RvU3RyaW5nVGFnJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNBcnJheVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGFycmF5LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvciBub3QuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBpc0FycmF5KFtdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzQXJyYXkoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpOyAvLyBmYWxzZVxuICovXG5leHBvcnQgY29uc3QgeyBpc0FycmF5IH0gPSBBcnJheTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNGdW5jdGlvbigoKSA9PiB7fSk7ICAgICAgICAgICAgLy8gdHJ1ZVxuICogXG4gKiBjb25zdCBmdW5jID0gKCkgPT4ge307XG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZnVuYywge30pO1xuICogaXNGdW5jdGlvbihmdW5jKTsgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOaWxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc05pbChudWxsKTsgICAgICAvLyB0cnVlXG4gKiBpc05pbCh1bmRlZmluZWQpOyAvLyB0cnVlXG4gKiBpc05pbChmYWxzZSk7ICAgICAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc1N0cmluZygnMCcpOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1N0cmluZyhuZXcgU3RyaW5nKCcwJykpOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnU3RyaW5nJztcbn1cbiIsImNvbnN0IHJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gW1xuICAnLicsXG4gICcrJywgJyonLCAnPycsXG4gICcoJywgJyknLFxuICAnWycsICddJyxcbiAgJ3snLCAnfScsXG4gICc8JywgJz4nLFxuICAnXicsICckJyxcbiAgJyEnLFxuICAnPScsXG4gICc6JyxcbiAgJy0nLFxuICAnfCcsXG4gICcsJyxcbiAgJ1xcXFwnXG5dO1xuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxuICByZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xuICAgIC5tYXAoKHMpID0+IGBcXFxcJHsgcyB9YClcbiAgICAuam9pbignfCcpLFxuICAnZydcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XG59XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRBdHRyKGF0dHJzLCBhdHRyKSB7XG4gIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xufVxuIiwiaW1wb3J0IHsgdG9DYW1lbENhc2UgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCA9IC86IC87XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDU1NQcm9wKGNzcywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdChDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gICAgY3NzW3RvQ2FtZWxDYXNlKHByb3BlcnR5WzBdKV0gPSBwcm9wZXJ0eVsxXTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZERhdGFBdHRyKGRhdGEsIHZhbHVlLCBrZXkpIHtcbiAgZGF0YVtrZXldID0gdmFsdWU7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkTmV4dChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ubmV4dFNpYmxpbmcpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZFBhcmVudChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucGFyZW50Tm9kZSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUHJldihhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucHJldmlvdXNTaWJsaW5nKTtcbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGlkZVN0eWxlTm9kZShoZWFkKSB7XG4gIGNvbnN0IHN0eWxlID0gaGVhZC5maW5kKGBzdHlsZSMkeyBISURFX0NMQVNTIH1gKTtcblxuICBpZiAoc3R5bGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGVhZFxuICAgIC5jcmVhdGUoJ3N0eWxlJylcbiAgICAucHJvcCgnaWQnLCBISURFX0NMQVNTKVxuICAgIC50ZXh0KGAuJHsgSElERV9DTEFTUyB9e2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50O31gKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuY29uc3QgWF9MSU5LX0FUVFJfUkVHRVggPSAvXnhsaW5rOlxcdy87XG5jb25zdCBYTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgWF9MSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0ck5TKGF0dHIsIGVsZW0pIHtcbiAgaWYgKGF0dHIgPT09ICd4bWxucycgfHwgYXR0ciA9PT0gJ3htbG5zOnhsaW5rJykge1xuICAgIHJldHVybiBlbGVtLm5vZGVOYW1lID09PSAnU1ZHJ1xuICAgICAgPyBYTUxfTlNcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGlmIChYX0xJTktfQVRUUl9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJ3N2ZycpLmxlbmd0aFxuICAgICAgPyBYX0xJTktfTlNcbiAgICAgIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlSGlkZVN0eWxlTm9kZSB9IGZyb20gJy4vY3JlYXRlSGlkZVN0eWxlTm9kZSc7XG5pbXBvcnQgeyBISURFX0NMQVNTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGUoZWxlbSkge1xuICBjcmVhdGVIaWRlU3R5bGVOb2RlKG5ldyBFbGVtKGVsZW0ub3duZXJEb2N1bWVudC5oZWFkKSk7XG4gIG5ldyBFbGVtKGVsZW0pLmFkZENsYXNzKEhJREVfQ0xBU1MpO1xufVxuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW07XG59XG4iLCJpbXBvcnQgeyB0b1N0cmluZ1RhZywgaXNBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGlzRWxlbSB9IGZyb20gJy4vaXNFbGVtJztcblxuY29uc3QgSFRNTF9DT0xMRUNUSU9OX1JFR0VYID0gL14oSFRNTENvbGxlY3Rpb258Tm9kZUxpc3QpJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRzQ29sbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIEhUTUxfQ09MTEVDVElPTl9SRUdFWC50ZXN0KHRvU3RyaW5nVGFnKHZhbHVlKSlcbiAgICB8fCBpc0VsZW0odmFsdWUpXG4gICAgfHwgaXNBcnJheSh2YWx1ZSlcbiAgKTtcbn1cbiIsImltcG9ydCB7IHRvU3RyaW5nVGFnIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRG9jdW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0hUTUxEb2N1bWVudCc7XG59XG4iLCJpbXBvcnQgeyB0b1N0cmluZ1RhZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuY29uc3QgRUxFTUVOVF9SRUdFWCA9IC9FbGVtZW50JC87XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTm9kZSh2YWx1ZSkge1xuICBjb25zdCB0YWcgPSB0b1N0cmluZ1RhZyh2YWx1ZSk7XG5cbiAgcmV0dXJuIChcbiAgICBFTEVNRU5UX1JFR0VYLnRlc3QodGFnKVxuICAgIHx8IHRhZyA9PT0gJ0hUTUxEb2N1bWVudCdcbiAgICB8fCB0YWcgPT09ICdUZXh0J1xuICAgIHx8IHRhZyA9PT0gJ0RvY3VtZW50RnJhZ21lbnQnXG4gICAgfHwgdGFnID09PSAnQ29tbWVudCdcbiAgKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWxlbSkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSElERV9DTEFTUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93KGVsZW0pIHtcbiAgbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ2xhc3MoSElERV9DTEFTUyk7XG59XG4iLCJpbXBvcnQgeyBpc0VsZW0gfSBmcm9tICcuL2lzRWxlbSc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0VsZW0oZWxlbSkge1xuICByZXR1cm4gaXNFbGVtKGVsZW0pXG4gICAgPyBlbGVtXG4gICAgOiBuZXcgRWxlbShlbGVtKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG5jb25zdCB7XG4gIGRvY3VtZW50ID0ge31cbn0gPSBnbG9iYWw7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGZpbmRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gW2Jhc2UgPSBkb2N1bWVudF0gLSBCYXNlIHRvIGZpbmQgaW4uXG4gKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAqIFtEb2N1bWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBiYXNlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBFbGVtKGJhc2UucXVlcnlTZWxlY3RvckFsbChTdHJpbmcoc2VsZWN0b3IpKSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIGtleXMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpIHtcbiAgaXRlcmF0ZUFycmF5KGtleXMoYXJnc09iamVjdCksIChhcmcpID0+IHtcbiAgICBpZiAoIShhcmcgaW4gYXJncykpIHtcbiAgICAgIGFyZ3NPYmplY3RbYXJnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgZm9yIChjb25zdCBhcmcgaW4gYXJncykge1xuICAgIGFyZ3NPYmplY3RbYXJnXSA9IGFyZ3NbYXJnXTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsZWFuUHJvcGVydHkodmFsdWUsIGFyZywgb2JqZWN0KSB7XG4gIGRlbGV0ZSBvYmplY3RbYXJnXTtcbn1cbiIsImltcG9ydCB7IGVzY2FwZVJlZ2V4IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHsgZXNjYXBlUmVnZXgobmFtZSkgfSg/OlxcXFwoKFteXFxcXCldKilcXFxcKSk/KD86IyhbXFxcXHNcXFxcU10qKSk/JGApO1xufVxuIiwiY29uc3QgQ09NTUFfUkVHRVggPSAvLC87XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbk1hdGNoKG1peGlucywgYXR0cikge1xuICBsZXQgbWF0Y2g7XG5cbiAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gbWl4aW5zKSB7XG4gICAgY29uc3QgTWl4aW4gPSBtaXhpbnNbbmFtZV07XG4gICAgY29uc3QgbG9jYWxNYXRjaCA9IGF0dHIubWF0Y2goTWl4aW4uX21hdGNoKTtcblxuICAgIGlmIChsb2NhbE1hdGNoKSB7XG4gICAgICBjb25zdCBhcmdzTWF0Y2ggPSBsb2NhbE1hdGNoWzFdO1xuICAgICAgbGV0IGFyZ3M7XG5cbiAgICAgIGlmIChhcmdzTWF0Y2ggPT09ICcnKSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc01hdGNoKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzTWF0Y2guc3BsaXQoQ09NTUFfUkVHRVgpO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgY29tbWVudDogbG9jYWxNYXRjaFsyXSxcbiAgICAgICAgTWl4aW4sXG4gICAgICAgIG5hbWVcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cbiIsImltcG9ydCB7IGNvbGxlY3RGcm9tT2JqZWN0LCBhc3NpZ24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBEX1JFU1RfUkVHRVggfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgbWl4aW5NYXRjaCB9IGZyb20gJy4vbWl4aW5NYXRjaCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SZXN0QXR0cnMoYXR0cnMsIG1peGlucywgbWl4aW5EZWZhdWx0T3B0cykge1xuICByZXR1cm4gY29sbGVjdEZyb21PYmplY3QoYXR0cnMsIChldmVudHVhbEF0dHJzLCB2YWx1ZSwgYXR0cikgPT4ge1xuICAgIGlmIChEX1JFU1RfUkVHRVgudGVzdChhdHRyKSkge1xuICAgICAgcmV0dXJuIGFzc2lnbihldmVudHVhbEF0dHJzLCB0cmFuc2Zvcm1SZXN0QXR0cnModmFsdWUsIG1peGlucywgbWl4aW5EZWZhdWx0T3B0cykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gbWl4aW5NYXRjaChtaXhpbnMsIGF0dHIpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudHVhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICB0eXBlOiAnbWl4aW4nLFxuICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgLi4ubWl4aW5EZWZhdWx0T3B0c1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50dWFsQXR0cnNbYXR0cl0gPSB7XG4gICAgICB0eXBlOiAnYXR0cicsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUmVzdEFyZ3MoYXJncykge1xuICByZXR1cm4gY29sbGVjdEZyb21PYmplY3QoYXJncywgYWRkQXJncyk7XG59XG5cbmZ1bmN0aW9uIGFkZEFyZ3MoYXJncywgdmFsdWUsIGFyZykge1xuICBpZiAoRF9SRVNUX1JFR0VYLnRlc3QoYXJnKSkge1xuICAgIGFzc2lnbihhcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyh2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbYXJnXSA9IHZhbHVlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgdmFsdWUpIHtcbiAgY29uc3Qgb2xkVmFsdWUgPSBtaXhpbi4kJC52YWx1ZTtcblxuICBtaXhpbi4kJC52YWx1ZSA9IHZhbHVlO1xuXG4gIGl0ZXJhdGVBcnJheShtaXhpbi4kJC53YXRjaGVycywgKHdhdGNoZXIpID0+IHtcbiAgICB3YXRjaGVyKHZhbHVlLCBvbGRWYWx1ZSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1peGluKHtcbiAgbmFtZSwgTWl4aW4sIGR5bmFtaWMsXG4gIHZhbHVlLCBhcmdzLCBjb21tZW50LCBlbGVtLFxuICBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUsIHBhcmVudFRlbXBsYXRlXG59KSB7XG4gIGNvbnN0IG1peGluID0gbmV3IE1peGluKHtcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIGR5bmFtaWMsXG4gICAgYXJncyxcbiAgICBjb21tZW50LFxuICAgIGVsZW0sXG4gICAgcGFyZW50QmxvY2ssXG4gICAgcGFyZW50U2NvcGUsXG4gICAgcGFyZW50VGVtcGxhdGVcbiAgfSk7XG5cbiAgaWYgKE1peGluLmV2YWx1YXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBtaXhpbi52YWx1ZSA9IG1peGluLmV2YWx1YXRlKChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIG1peGluLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1peGluLmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtaXhpbi5hZnRlclVwZGF0ZSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbWl4aW47XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBleGVjdXRlTWl4aW5XYXRjaGVycyB9IGZyb20gJy4vZXhlY3V0ZU1peGluV2F0Y2hlcnMnO1xuaW1wb3J0IHsgY3JlYXRlTWl4aW4gfSBmcm9tICcuL2NyZWF0ZU1peGluJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBhdHRyc09iamVjdCwgZWxlbSwgZmlyc3RUaW1lKSB7XG4gIGl0ZXJhdGVPYmplY3QoYXR0cnNPYmplY3QsICh7IHR5cGUsIHZhbHVlIH0sIGF0dHIpID0+IHtcbiAgICBpZiAoIWF0dHJzW2F0dHJdKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLiQkLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgYXR0cnNPYmplY3RbYXR0cl07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBtaXhpbnMgPSBbXTtcblxuICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gIGZvciAoY29uc3QgYXR0ciBpbiBhdHRycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBkeW5hbWljLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRzXG4gICAgfSA9IGF0dHJzW2F0dHJdO1xuICAgIGxldCBuZXh0VHlwZTtcbiAgICBsZXQgbmV4dER5bmFtaWM7XG4gICAgbGV0IG5leHRWYWx1ZTtcblxuICAgIGlmIChhdHRyc09iamVjdFthdHRyXSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlOiBwcmV2VHlwZSxcbiAgICAgICAgdmFsdWU6IHByZXZWYWx1ZVxuICAgICAgfSA9IGF0dHJzT2JqZWN0W2F0dHJdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ21peGluJykge1xuICAgICAgICAgIHByZXZWYWx1ZS4kJC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWl4aW4gPSBwcmV2VmFsdWU7XG5cbiAgICAgICAgaWYgKHByZXZUeXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICBtaXhpbi4kJC5pc0R5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghbWl4aW4uJCQuZXZhbHVhdGVkICYmIG9wdHMuTWl4aW4uZXZhbHVhdGUpIHtcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG1peGluLiQkLnBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZHluYW1pY1xuICAgICAgICAgICAgfSA9IGF0dHJzW2F0dHJdO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21peGluJyAmJiAhZHluYW1pYykge1xuICAgICAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1peGluKTtcblxuICAgICAgICAgIG1peGluLiQkLmV2YWx1YXRlZCA9IHRydWU7XG5cbiAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG4gICAgICB9XG5cbiAgICAgIG5leHRUeXBlID0gdHlwZTtcbiAgICAgIG5leHREeW5hbWljID0gZHluYW1pYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuXG4gICAgICAgIG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVpbGRNaXhpbiA9ICgpID0+IHtcbiAgICAgICAgICBvcHRzLmR5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgICAgICAgY29uc3QgbWl4aW4gPSBjcmVhdGVNaXhpbihvcHRzKTtcblxuICAgICAgICAgIGlmICghZHluYW1pYyAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IG9wdHM7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBkeW5hbWljXG4gICAgICAgICAgICAgIH0gPSBhdHRyc1thdHRyXTtcblxuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21peGluJyAmJiAhZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1peGluKTtcblxuICAgICAgICAgICAgbWl4aW4uJCQuZXZhbHVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1peGluLiQkLnZhbHVlID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0VmFsdWUgPSBtaXhpbjtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkeW5hbWljLFxuICAgICAgICAgICAgICB2YWx1ZTogbWl4aW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICBtaXhpbnMucHVzaChidWlsZE1peGluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsZE1peGluKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFR5cGUgPSB0eXBlO1xuICAgICAgbmV4dER5bmFtaWMgPSBkeW5hbWljO1xuICAgIH1cblxuICAgIGF0dHJzT2JqZWN0W2F0dHJdID0ge1xuICAgICAgdHlwZTogbmV4dFR5cGUsXG4gICAgICBkeW5hbWljOiBuZXh0RHluYW1pYyxcbiAgICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZpcnN0VGltZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCAoYnVpbGRNaXhpbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXR0cixcbiAgICAgICAgICBvcHRzXG4gICAgICAgIH0gPSBidWlsZE1peGluKCk7XG5cbiAgICAgICAgYXR0cnNPYmplY3RbYXR0cl0gPSBvcHRzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlLCBjb2xsZWN0RnJvbU9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IGNyZWF0ZShcbiAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgID8gcGFyZW50U2NvcGUuJCQuZ2xvYmFsc1xuICAgICAgICA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IHtcbiAgICAgICAgdGVtcDogW10sXG4gICAgICAgIHBlcm06IFtdXG4gICAgICB9XG4gICAgfTtcbiAgfSwgc2NvcGUpO1xufVxuIiwiaW1wb3J0IHsgcmVtb3ZlQXJyYXlFbGVtLCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUZW1wV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHdhdGNoZXIub25SZW1vdmUoKTtcbiAgd2F0Y2hlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSkge1xuICBpdGVyYXRlQXJyYXkod2F0Y2hlcnNUb1JlbW92ZSwgcmVtb3ZlV2F0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVdhdGNoZXIoeyB3YXRjaGVyLCB3YXRjaGVycyB9KSB7XG4gIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVycywgd2F0Y2hlcik7XG59XG4iLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBtYXBPYmplY3QsIGl0ZXJhdGVBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHJlbW92ZVRlbXBXYXRjaGVyIH0gZnJvbSAnLi9yZW1vdmVXYXRjaGVyJztcblxubGV0IGNoYW5nZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCBtYXBPYmplY3Qoc2NvcGVWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcbiAgICBjb25zdCB7IHdhdGNoZXJzIH0gPSBzY29wZTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKFNjb3BlLmV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKFNjb3BlLmdldHRpbmdWYXJzLmluZGV4T2Yod2F0Y2hlcnMudGVtcCkgPT09IC0xKSB7XG4gICAgICAgICAgICBTY29wZS5nZXR0aW5nVmFycy5wdXNoKHdhdGNoZXJzLnRlbXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBzY29wZS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgICAgIGNoYW5nZWQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9sZFRlbXBXYXRjaGVycyA9IHdhdGNoZXJzLnRlbXAuc2xpY2UoKTtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzY29wZS52YWx1ZTtcblxuICAgICAgICB3YXRjaGVycy50ZW1wID0gW107XG4gICAgICAgIHNjb3BlLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaXRlcmF0ZUFycmF5KG9sZFRlbXBXYXRjaGVycywgcmVtb3ZlVGVtcFdhdGNoZXIpO1xuICAgICAgICBjaGFuZ2VkLnB1c2goe1xuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHdhcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICAgICAgfSA9IGNoYW5nZWRbaV07XG5cbiAgICAgICAgICAgIGl0ZXJhdGVBcnJheShzY29wZS53YXRjaGVycy5wZXJtLCAod2F0Y2hlcikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHdhcy5pbmRleE9mKHdhdGNoZXIpO1xuXG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB3YXMucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2hhbmdlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZCA9IG51bGw7XG5cbiAgICAgICAgICBpdGVyYXRlQXJyYXkod2FzLCAod2F0Y2hlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgICAgIH0gPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgIHdhdGNoZXIodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkpO1xufVxuIiwiaW1wb3J0IHtcbiAgZXhjZXB0LCBjcmVhdGUsIGFzc2lnbixcbiAgaXRlcmF0ZU9iamVjdCwgaXRlcmF0ZUFycmF5LFxuICBpc05pbFxufSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5pbXBvcnQge1xuICBTVkdfTlMsIERfUkVTVF9SRUdFWFxufSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY2xlYW5Qcm9wZXJ0eSB9IGZyb20gJy4vY2xlYW5Qcm9wZXJ0eSc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1SZXN0QXR0cnMgfSBmcm9tICcuL3RyYW5zZm9ybVJlc3RBdHRycyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVBdHRycyB9IGZyb20gJy4vY2FsY3VsYXRlQXR0cnMnO1xuaW1wb3J0IHsgbWl4aW5NYXRjaCB9IGZyb20gJy4vbWl4aW5NYXRjaCc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RQcml2YXRlU2NvcGUgfSBmcm9tICcuL2NvbnN0cnVjdFByaXZhdGVTY29wZSc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RQdWJsaWNTY29wZSB9IGZyb20gJy4vY29uc3RydWN0UHVibGljU2NvcGUnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5cbmNvbnN0IE5BTUVEX0RfQkxPQ0tfUkVHRVggPSAvXmQtYmxvY2s6KFtcXHNcXFNdKykkLztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHsgbm9kZSwgQ29uc3RydWN0b3IsIHBhcmVudCwgcGFyZW50RWxlbSwgcGFyZW50QmxvY2ssIHBhcmVudFNjb3BlLCBwYXJlbnRUZW1wbGF0ZSwgcHJldkJsb2NrIH0pIHtcbiAgY29uc3QgZG9jID0gbmV3IEVsZW0ocGFyZW50RWxlbVswXS5vd25lckRvY3VtZW50KTtcbiAgY29uc3QgZWxlbSA9IHBhcmVudEVsZW1bMF0ubmFtZXNwYWNlVVJJID09PSBTVkdfTlNcbiAgICA/IGRvYy5jcmVhdGUoJ3N2ZycpXG4gICAgOiBkb2M7XG4gIGNvbnN0IGxvY2FsQmxvY2tzID0gcGFyZW50VGVtcGxhdGUgPyBwYXJlbnRUZW1wbGF0ZS4kJC5ucy5fYmxvY2tzIDogQmxvY2suX2Jsb2NrcztcbiAgY29uc3QgbG9jYWxNaXhpbnMgPSBwYXJlbnRUZW1wbGF0ZSA/IHBhcmVudFRlbXBsYXRlLiQkLm5zLl9taXhpbnMgOiBCbG9jay5fbWl4aW5zO1xuICBsZXQgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcbiAgbGV0IGFyZ3MgPSBub2RlLmF0dHJzID0gbm9kZS5hdHRycyB8fCB7fTtcbiAgbGV0IG5hbWUgPSBub2RlLm5hbWUgfHwgJ1Vua25vd25CbG9jayc7XG4gIGxldCBjb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yIHx8IChub2RlLm5hbWUgJiYgbG9jYWxCbG9ja3Nbbm9kZS5uYW1lXSk7XG4gIGxldCBkQmxvY2tNYXRjaDtcbiAgbGV0IGRCbG9ja05hbWU7XG4gIGxldCBkQmxvY2tBcmdzO1xuICBsZXQgZEJsb2NrQ2hpbGRyZW47XG4gIGxldCBkRWxlbWVudHNOYW1lO1xuICBsZXQgZEVsZW1lbnRzQ29uc3RydWN0b3I7XG5cbiAgaWYgKG5hbWUgPT09ICdkLWJsb2NrJyAmJiBhcmdzLm5hbWUpIHtcbiAgICBuYW1lID0gJ2QtZWxlbWVudHMnO1xuICAgIGNvbnN0cnVjdG9yID0gbG9jYWxCbG9ja3NbbmFtZV07XG4gICAgZEVsZW1lbnRzTmFtZSA9IGFyZ3MubmFtZTtcbiAgICBkQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICduYW1lJyk7XG4gICAgZEJsb2NrQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IFtdO1xuICAgIGFyZ3MgPSB7fTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSAnZC1ibG9jaycgJiYgYXJncy5Db25zdHJ1Y3Rvcikge1xuICAgIG5hbWUgPSAnVW5rbm93bkJsb2NrJztcbiAgICBjb25zdHJ1Y3RvciA9IGxvY2FsQmxvY2tzW25hbWVdO1xuICAgIGRFbGVtZW50c0NvbnN0cnVjdG9yID0gYXJncy5Db25zdHJ1Y3RvcjtcbiAgICBkQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICdDb25zdHJ1Y3RvcicpO1xuICAgIGRCbG9ja0NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBbXTtcbiAgICBhcmdzID0ge307XG4gIH0gZWxzZSBpZiAoKGRCbG9ja01hdGNoID0gbmFtZS5tYXRjaChOQU1FRF9EX0JMT0NLX1JFR0VYKSkgfHwgbmFtZSA9PT0gJ2QtYmxvY2snKSB7XG4gICAgY29uc3RydWN0b3IgPSBCbG9jay5fYmxvY2tzWydkLWJsb2NrJ107XG4gICAgZEJsb2NrTmFtZSA9IGRCbG9ja01hdGNoID8gZEJsb2NrTWF0Y2hbMV0gOiBudWxsO1xuICB9XG5cbiAgbGV0IGJsb2NrSW5zdGFuY2U7XG5cbiAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJsb2NrSW5zdGFuY2UgPSBuZXcgY29uc3RydWN0b3Ioe1xuICAgICAgICBuYW1lLFxuICAgICAgICBhcmdzLFxuICAgICAgICBkQmxvY2tOYW1lLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBwcmV2QmxvY2tcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gbmV3ICR7IG5hbWUgfTpgLCBlcnIpO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IG5vZGU7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbS5jcmVhdGUobmFtZSk7XG4gICAgY29uc3QgY3VycmVudEF0dHJzID0gY3JlYXRlKG51bGwpO1xuICAgIGxldCBhdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgd2FzRFJlc3Q7XG4gICAgY29uc3QgbWl4aW5EZWZhdWx0T3B0cyA9IHtcbiAgICAgIGVsZW06IGVsZW1lbnQsXG4gICAgICBwYXJlbnRCbG9jayxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9O1xuXG4gICAgaXRlcmF0ZU9iamVjdChhcmdzLCAodmFsdWUsIGF0dHIpID0+IHtcbiAgICAgIGNvbnN0IGlzRFJlc3QgPSBEX1JFU1RfUkVHRVgudGVzdChhdHRyKTtcbiAgICAgIGNvbnN0IGxvY2FsQXR0cnMgPSBpc0RSZXN0IHx8IHdhc0RSZXN0XG4gICAgICAgID8gY3JlYXRlKGF0dHJzKVxuICAgICAgICA6IGF0dHJzO1xuXG4gICAgICBhdHRycyA9IGxvY2FsQXR0cnM7XG5cbiAgICAgIGlmIChpc0RSZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3RBdHRycyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QobG9jYWxBdHRycywgY2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgICBhc3NpZ24obG9jYWxBdHRycywgdHJhbnNmb3JtUmVzdEF0dHJzKFxuICAgICAgICAgICAgICB2YWx1ZSwgbG9jYWxNaXhpbnMsIG1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgY2FsY3VsYXRlQXR0cnMoYXR0cnMsIGN1cnJlbnRBdHRycywgZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgICAgd2FzRFJlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBdHRycywgdHJhbnNmb3JtUmVzdEF0dHJzKFxuICAgICAgICAgIHJlc3RBdHRycywgbG9jYWxNaXhpbnMsIG1peGluRGVmYXVsdE9wdHNcbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gbWl4aW5NYXRjaChsb2NhbE1peGlucywgYXR0cik7XG5cbiAgICAgIHdhc0RSZXN0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICB2YWx1ZSA9ICd0cnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgICAgdHlwZTogJ21peGluJyxcbiAgICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIC4uLm1hdGNoLFxuICAgICAgICAgICAgLi4ubWl4aW5EZWZhdWx0T3B0c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgIHR5cGU6ICdhdHRyJyxcbiAgICAgICAgdmFsdWU6IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBsb2NhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F0dHInLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3QgY3JlYXRlTWl4aW5zID0gY2FsY3VsYXRlQXR0cnMoYXR0cnMsIGN1cnJlbnRBdHRycywgZWxlbWVudCwgdHJ1ZSk7XG5cbiAgICBpZiAobmFtZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgZWxlbWVudC50ZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgbGV0IHRleHQgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC50ZXh0KGAkeyB2YWx1ZSB9YCk7XG4gICAgICB9LCBwYXJlbnRCbG9jayk7XG5cbiAgICAgIGlmIChpc05pbCh0ZXh0KSkge1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQudGV4dChgJHsgdGV4dCB9YCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBwYXJlbnRFbGVtID0gbmFtZSA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgICA/IG5ldyBFbGVtKGVsZW1lbnRbMF0uY29udGVudClcbiAgICAgICAgOiBlbGVtZW50O1xuICAgICAgbGV0IHByZXZCbG9jaztcblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzUGFyZW50QmxvY2sgPSBwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaztcblxuICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoZWxlbWVudCwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICBlbGVtZW50Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG5cbiAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgcGFyZW50LiQkLmluc2VydEluU3RhcnRPZkl0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjcmVhdGVNaXhpbnMoKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgY29uc3Qge1xuICAgICQkLFxuICAgIGFyZ3M6IEFyZ3MsXG4gICAgZ2xvYmFscyxcbiAgICAuLi5sb2NhbHNcbiAgfSA9IGJsb2NrSW5zdGFuY2U7XG5cbiAgaWYgKGRFbGVtZW50c05hbWUpIHtcbiAgICBub2RlID0ge1xuICAgICAgYXR0cnM6IGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbjogZEJsb2NrQ2hpbGRyZW5cbiAgICB9O1xuICAgIG5vZGUubmFtZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGRFbGVtZW50c05hbWUsIChuZXdOYW1lKSA9PiB7XG4gICAgICBub2RlLm5hbWUgPSBuZXdOYW1lO1xuXG4gICAgICBBcmdzLnZhbHVlID0gW25vZGVdO1xuICAgIH0sIGJsb2NrSW5zdGFuY2UsIHRydWUpO1xuXG4gICAgQXJncy52YWx1ZSA9IFtub2RlXTtcbiAgICBBcmdzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgQXJncy5wYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKGRFbGVtZW50c0NvbnN0cnVjdG9yKSB7XG4gICAgbm9kZSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICBhdHRyczogZEJsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBkQmxvY2tDaGlsZHJlblxuICAgIH07XG5cbiAgICBBcmdzLkNvbnN0cnVjdG9yID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoZEVsZW1lbnRzQ29uc3RydWN0b3IsIChuZXdDb25zdHJ1Y3RvcikgPT4ge1xuICAgICAgQXJncy5Db25zdHJ1Y3RvciA9IG5ld0NvbnN0cnVjdG9yO1xuICAgICAgQXJncy52YWx1ZSA9IFtub2RlXTtcbiAgICB9LCBibG9ja0luc3RhbmNlLCB0cnVlKTtcbiAgICBBcmdzLnZhbHVlID0gW25vZGVdO1xuICAgIEFyZ3MucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgICBBcmdzLnBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG4gIH1cblxuICBjb25zdCBodG1sID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnZhbHVlIHx8IFtdXG4gICAgOiBjb25zdHJ1Y3Rvci5faHRtbDtcblxuICAkJC5hcmdzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKEFyZ3MpO1xuICAkJC5sb2NhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUobG9jYWxzKTtcbiAgJCQuZ2xvYmFscyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShnbG9iYWxzLCAnZ2xvYmFscycsIHBhcmVudFNjb3BlKTtcblxuICBpZiAobmFtZSA9PT0gJyNkLWl0ZW0nKSB7XG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XG4gICAgICBbbm9kZS5pdGVtTmFtZV06IG5vZGUuaXRlbSxcbiAgICAgIFtub2RlLmluZGV4TmFtZV06IG5vZGUuaW5kZXhcbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gcGFyZW50U2NvcGUuJCQubmFtZSA9PT0gJyNkLWl0ZW0nXG4gICAgICA/IHBhcmVudFNjb3BlLiQkLnNjb3BlXG4gICAgICA6IHBhcmVudFNjb3BlO1xuXG4gICAgJCQubnMgPSBwYXJlbnRTY29wZS4kJC5ucztcbiAgICAkJC5wcml2YXRlU2NvcGUgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoc2NvcGVWYWx1ZXMpO1xuICAgIGNvbnN0cnVjdFB1YmxpY1Njb3BlKCQkLnNjb3BlID0gY3JlYXRlKHNjb3BlKSwgc2NvcGVWYWx1ZXMsICQkLnByaXZhdGVTY29wZSk7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ2QtZWFjaCcpIHtcbiAgICAkJC5zY29wZSA9IGNyZWF0ZShwYXJlbnRTY29wZS4kJC5uYW1lID09PSAnI2QtaXRlbScgPyBwYXJlbnRTY29wZS4kJC5zY29wZSA6IHBhcmVudFNjb3BlLCB7XG4gICAgICBbQXJncy5pdGVtIHx8ICckaXRlbSddOiB7XG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtBcmdzLmluZGV4IHx8ICckaW5kZXgnXToge1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKEFyZ3MsIEFyZ3MsICQkLmFyZ3MpO1xuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShnbG9iYWxzLCBnbG9iYWxzLCAkJC5nbG9iYWxzKTtcbiAgY29uc3RydWN0UHVibGljU2NvcGUoYmxvY2tJbnN0YW5jZSwgbG9jYWxzLCAkJC5sb2NhbHMpO1xuXG4gIHRyeSB7XG4gICAgYmxvY2tJbnN0YW5jZS5hZnRlckNvbnN0cnVjdCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYWZ0ZXJDb25zdHJ1Y3Q6YCwgZXJyKTtcbiAgfVxuXG4gIHByZXZCbG9jayA9IHVuZGVmaW5lZDtcbiAgcGFyZW50U2NvcGUgPSBuYW1lID09PSAnZC1lbGVtZW50cydcbiAgICA/IEFyZ3MucGFyZW50U2NvcGVcbiAgICA6IGJsb2NrSW5zdGFuY2U7XG4gIHBhcmVudFRlbXBsYXRlID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnBhcmVudFRlbXBsYXRlXG4gICAgOiBibG9ja0luc3RhbmNlO1xuXG4gIGl0ZXJhdGVBcnJheShodG1sLCAoY2hpbGQpID0+IHtcbiAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIHBhcmVudDogYmxvY2tJbnN0YW5jZSxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRCbG9jazogYmxvY2tJbnN0YW5jZSxcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBwcmV2QmxvY2tcbiAgICB9KTtcbiAgfSk7XG5cbiAgYmxvY2tJbnN0YW5jZS4kJC5pc1JlbmRlcmVkID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJSZW5kZXIoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyUmVuZGVyOmAsIGVycik7XG4gIH1cblxuICByZXR1cm4gYmxvY2tJbnN0YW5jZTtcbn1cbiIsImltcG9ydCB7IHNldFByb3RvIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRCbG9jayhjbHMpIHtcbiAgc2V0UHJvdG8oY2xzLCBCbG9jayk7XG4gIHNldFByb3RvKGNscy5wcm90b3R5cGUsIEJsb2NrLnByb3RvdHlwZSk7XG59XG4iLCJjb25zdCB7IGlzUHJvdG90eXBlT2YgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKENsYXNzLCBTdWJjbGFzcykge1xuICByZXR1cm4gQ2xhc3M6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MpICYmIENsYXNzLnByb3RvdHlwZTo6aXNQcm90b3R5cGVPZihTdWJjbGFzcy5wcm90b3R5cGUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwoY2hpbGQpIHtcbiAgY2hpbGQuJCQucmVtb3ZlKHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZU9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoRm9yQWxsTG9jYWxzKGJsb2NrLCB3YXRjaGVyKSB7XG4gIGl0ZXJhdGVPYmplY3QoYmxvY2suJCQubG9jYWxzLCAoeyB3YXRjaGVycyB9KSA9PiB7XG4gICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoRm9yQWxsR2xvYmFscyhibG9jaywgd2F0Y2hlcikge1xuICBjb25zdCB7XG4gICAgZ2xvYmFscyxcbiAgICB3YXRjaGVyc1RvUmVtb3ZlXG4gIH0gPSBibG9jay4kJDtcblxuICBmb3IgKGNvbnN0IGdsb2IgaW4gZ2xvYmFscykge1xuICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICBjb25zdCB3YXRjaGVycyA9IGdsb2JhbHNbZ2xvYl0ud2F0Y2hlcnMucGVybTtcblxuICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgd2F0Y2hlcnNUb1JlbW92ZS5wdXNoKHtcbiAgICAgIHdhdGNoZXIsXG4gICAgICB3YXRjaGVyc1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXRjaEZvckFsbEFyZ3MoYmxvY2ssIHdhdGNoZXIpIHtcbiAgaXRlcmF0ZU9iamVjdChibG9jay4kJC5hcmdzLCAoeyB3YXRjaGVycyB9KSA9PiB7XG4gICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IGlzSW5zdGFuY2VPZiB9IGZyb20gJy4vaXNJbnN0YW5jZU9mJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi8uLi9NaXhpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQmxvY2soYmxvY2ssIHdyYXBwZXIpIHtcbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB3cmFwcGVyKGJsb2NrKTtcblxuICByZXR1cm4gaXNJbnN0YW5jZU9mKEJsb2NrLCByZXR1cm5WYWx1ZSlcbiAgICA/IHJldHVyblZhbHVlXG4gICAgOiBibG9jaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNaXhpbihtaXhpbiwgd3JhcHBlcikge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHdyYXBwZXIobWl4aW4pO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoTWl4aW4sIHJldHVyblZhbHVlKVxuICAgID8gcmV0dXJuVmFsdWVcbiAgICA6IG1peGluO1xufVxuIiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQmxvY2sgfSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEFwcChodG1sLCBjb250YWluZXIpIHtcbiAgY29uc3QgcGFyZW50RWxlbSA9IG5ldyBFbGVtKGNvbnRhaW5lcikuZWxlbSgwKTtcblxuICBpZiAoIXBhcmVudEVsZW0ubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBlbGVtZW50IHRvIGluc2VydCB0aGUgYXBwIGludG8gd2FzIGdpdmVuISAoaW5pdEFwcCknKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRFbGVtLnByb3AoJ0R3YXluZVJvb3RCbG9jaycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBhbHJlYWR5IGV4aXN0cyBhIER3YXluZSBhcHAgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50ISAoaW5pdEFwcCknKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGh0bWwpKSB7XG4gICAgaHRtbCA9IHtcbiAgICAgIHZhcnM6IFtdLFxuICAgICAgdmFsdWU6IGh0bWxcbiAgICB9O1xuICB9XG5cbiAgY2xhc3MgUm9vdEJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICAgIHN0YXRpYyBfdmFycyA9IGh0bWwudmFycztcbiAgICBzdGF0aWMgX2h0bWwgPSBodG1sLnZhbHVlXG4gIH1cblxuICBjb25zdCBibG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICBub2RlOiB7XG4gICAgICBuYW1lOiAnI1Jvb3RCbG9jaydcbiAgICB9LFxuICAgIENvbnN0cnVjdG9yOiBSb290QmxvY2ssXG4gICAgcGFyZW50OiBwYXJlbnRFbGVtLFxuICAgIHBhcmVudEVsZW1cbiAgfSk7XG5cbiAgcGFyZW50RWxlbVxuICAgIC5wcm9wKCdEd2F5bmVSb290QmxvY2snLCBibG9jaylcbiAgICAuYXR0cignZHdheW5lLXJvb3QnLCAnJyk7XG59XG4iLCJpbXBvcnQgeyBjb2xsZWN0RnJvbUFycmF5LCBmaW5kSW5BcnJheSwgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgYXJncy52YWx1ZWA7XG5cbnJvb3RCbG9ja3NbJ2Qtc3dpdGNoJ10gPSBjbGFzcyBEU3dpdGNoIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7JCQucGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcblxuICBpbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICQkOiB7XG4gICAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgICAgcGFyZW50U2NvcGVcbiAgICAgIH0sXG4gICAgICBhcmdzLFxuICAgICAgYXJnczogeyB2YWx1ZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHdhc0RlZmF1bHQ7XG5cbiAgICB0aGlzLnZhbHVlcyA9IGNvbGxlY3RGcm9tQXJyYXkoaHRtbENoaWxkcmVuLCAodmFsdWVzLCBjaGlsZCwgaSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBhdHRycyxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGxldCB2YWwgPSBhdHRycy5pZjtcblxuICAgICAgaWYgKHdhc0RlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtY2FzZScgJiYgbmFtZSAhPT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgd2FzRGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnZC1kZWZhdWx0Jykge1xuICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKGVxdWFscyh0aGlzLnZhbHVlc1tpXS52YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy52YWx1ZXNbaV0udmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgIGlmIChpID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpIDwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmb3VuZCA9IGZpbmRJbkFycmF5KHRoaXMudmFsdWVzLCAoeyB2YWx1ZSB9KSA9PiAoXG4gICAgICAgICAgICBlcXVhbHModmFsdWUsIGFyZ3MudmFsdWUpXG4gICAgICAgICAgKSk7XG5cbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZC5rZXk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gZm91bmQudmFsdWUuY2hpbGRyZW47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcXVhbHModmFsLCB2YWx1ZSkgJiYgdGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgfSk7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9ID0gdGhpcy5hcmdzO1xuXG4gICAgICB0aGlzLmluZGV4ID0gSW5maW5pdHk7XG5cbiAgICAgIGl0ZXJhdGVBcnJheSh0aGlzLnZhbHVlcywgKHsgbmFtZSwgdmFsdWUsIGNoaWxkcmVuIH0sIGkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICA/IG5ld1ZhbHVlXG4gICAgICAgICAgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoZXF1YWxzKHZhbCwgbmV3VmFsdWUpICYmIHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBlcXVhbHModmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMSA9PT0gdmFsdWUyO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNTdHJpbmcsIGl0ZXJhdGVPYmplY3QsIGtleXMsXG4gIGNvbGxlY3RGcm9tT2JqZWN0LCBjb2xsZWN0RnJvbUFycmF5XG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYID0gLzsgPy87XG5cbnJvb3RNaXhpbnNbJ2Qtc3R5bGUnXSA9IGNsYXNzIERTdHlsZSBleHRlbmRzIE1peGluIHtcbiAgY3NzID0ge307XG5cbiAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjc3NcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIChjc3MsIHByb3ApID0+IHtcbiAgICAgICAgY3NzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tQXJyYXkoXG4gICAgICAgIG5ld1ZhbHVlXG4gICAgICAgICAgLnNwbGl0KENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgIGFkZENTU1Byb3BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZU9iamVjdChjc3MsICh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCFuZXdWYWx1ZVtwcm9wXSkge1xuICAgICAgICBlbGVtLnJlbW92ZUNTUyhwcm9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtLmNzcyhuZXdWYWx1ZSk7XG5cbiAgICB0aGlzLmNzcyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBjc3NcbiAgICB9ID0gdGhpcztcblxuICAgIGVsZW0ucmVtb3ZlQ1NTLmFwcGx5KGVsZW0sIGtleXMoY3NzKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFkZENTU1Byb3AoY3NzLCBpdGVtKSB7XG4gIGNvbnN0IFtwcm9wLCB2YWx1ZV0gPSBpdGVtO1xuXG4gIGNzc1twcm9wXSA9IHZhbHVlO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNOaWwsXG4gIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC12YWx1ZSddID0gY2xhc3MgRFZhbHVlIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBlbGVtLFxuICAgICAgbm9kZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5hbWUgPSBlbGVtLm5hbWUoKTtcbiAgICBjb25zdCB0eXBlID0gZWxlbS5wcm9wKCd0eXBlJyk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKCk7XG4gICAgbGV0IGluaXRpYWxTY29wZVZhbHVlID0gbnVsbDtcblxuICAgIHRoaXMucHJvcCA9IGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBlbGVtLmZpbmQoJ29wdGlvbicpO1xuICAgIHRoaXMuc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICB0aGlzLm5hbWUgPSBhcmdzWzBdO1xuICAgICAgdGhpcy5zY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGluaXRpYWxTY29wZVZhbHVlID0gdGhpcy5zY29wZS4kJC5ldmFsdWF0ZShnZXRFdmFsRnVuY3Rpb24odmFsdWUpLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXRQcm9wKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbEVsZW1WYWx1ZSA9IHRoaXMuZ2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSwgdHJ1ZSk7XG4gICAgY29uc3QgaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgPSBpc05pbChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgY29uc3QgaXNDaGVja2JveCA9IHR5cGUgPT09ICdjaGVja2JveCc7XG4gICAgY29uc3QgY2hhbmdlU2NvcGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0UHJvcCh0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG4gICAgfTtcblxuICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxFbGVtVmFsdWU7XG4gICAgICB0aGlzLmNoYW5nZVNjb3BlKCk7XG5cbiAgICAgIGlmICghaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwgJiYgaXNDaGVja2JveCkge1xuICAgICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxTY29wZVZhbHVlO1xuICAgICAgdGhpcy5zZXRQcm9wKGluaXRpYWxTY29wZVZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lciA9IGVsZW0ub24oZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBub2RlKSB7XG4gICAgICAgIGNoYW5nZVNjb3BlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vZmZGb3JtTGlzdGVuZXIgPSBlbGVtLmNsb3Nlc3QoJ2Zvcm0nKS5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KGNoYW5nZVNjb3BlLCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNoYW5nZVNjb3BlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjb3BlLFxuICAgICAgdmFsdWUsXG4gICAgICBjdXJyZW50VmFsdWVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NvcGVbdmFsdWVdID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb3AodmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChwcm9wID09PSAndGV4dCcpIHtcbiAgICAgIGVsZW0udGV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jykge1xuICAgICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnByb3AocHJvcCwgZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBub2RlLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvcCh2YWx1ZXMsIGluaXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgbmFtZSxcbiAgICAgIHByb3AsXG4gICAgICB0eXBlLFxuICAgICAgbm9kZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiBwcm9wID09PSAndGV4dCdcbiAgICAgID8gZWxlbS50ZXh0KClcbiAgICAgIDogZ2V0VmFsdWVGb3JHZXR0aW5nKG5hbWUsIGVsZW0ucHJvcChwcm9wKSwgdHlwZSwgbm9kZS52YWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBwcm9wID09PSAnbXVsdGlwbGUtc2VsZWN0Jyk7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5vZmZFbGVtTGlzdGVuZXIoKTtcbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lcigpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignbXVsdGlwbGUnKVxuICAgICAgICA/ICdtdWx0aXBsZS1zZWxlY3QnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgcmV0dXJuICdmaWxlcyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCdcbiAgICAgICAgPyAnY2hlY2tlZCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBlbGVtLmhhc0F0dHIoJ2NvbnRlbnRFZGl0YWJsZScpXG4gICAgICAgID8gJ3RleHQnXG4gICAgICAgIDogJ3ZhbHVlJztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JTZXR0aW5nKG5hbWUsIHZhbHVlLCB0eXBlLCBpbnB1dFZhbHVlKSB7XG4gIGlmIChuYW1lICE9PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgaXNSYWRpbyA9IHR5cGUgPT09ICdyYWRpbyc7XG5cbiAgaWYgKCFpc1JhZGlvICYmIHR5cGUgIT09ICdjaGVja2JveCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gaXNSYWRpb1xuICAgID8gdmFsdWUgPT09IGlucHV0VmFsdWVcbiAgICA6IHZhbHVlLmluZGV4T2YoaW5wdXRWYWx1ZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUsIHZhbHVlcywgb3B0aW9ucywgaW5pdCwgaXNNdWx0aXBsZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShvcHRpb25zLCBhZGRWYWx1ZSwgW10pO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgIT09ICdyYWRpbycgJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgID8gaW5wdXRWYWx1ZVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2YWx1ZSAmJiBpbml0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpID09PSAtMVxuICAgICAgICAgICAgPyB2YWx1ZXMuY29uY2F0KGlucHV0VmFsdWUpXG4gICAgICAgICAgICA6IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbaW5wdXRWYWx1ZV07XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZXMuaW5kZXhPZihpbnB1dFZhbHVlKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIC4uLnZhbHVlcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyTmFtZShuYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIHJldHVybiAnY2hhbmdlJztcbiAgICB9XG5cbiAgICBjYXNlICdpbnB1dCc6IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHR5cGUgPT09ICdyYWRpbydcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICB8fCB0eXBlID09PSAnY29sb3InXG4gICAgICAgIHx8IHR5cGUgPT09ICdmaWxlJ1xuICAgICAgKVxuICAgICAgICA/ICdjaGFuZ2UnXG4gICAgICAgIDogJ2NoYW5nZSBpbnB1dCc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuICdpbnB1dCc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV2YWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHNjb3BlKSA9PiBzY29wZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKHZhbHVlcywgeyBzZWxlY3RlZCwgdmFsdWUgfSkge1xuICBpZiAoc2VsZWN0ZWQgJiYgdmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgdG9PYmplY3RLZXlzLCBpdGVyYXRlQXJyYXksXG4gIGFzc2lnbiwga2V5cywgY3JlYXRlXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0VGVtcGxhdGVzKHRlbXBsYXRlLCB0ZW1wbGF0ZXMpIHtcbiAgY29uc3Qge1xuICAgIHZhcnMsXG4gICAgdmFsdWVcbiAgfSA9IHRlbXBsYXRlO1xuICBjb25zdCBuZXdUZW1wbGF0ZXMgPSBjcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5ld1ZhcnMgPSB0b09iamVjdEtleXModmFycyk7XG5cbiAgYXNzaWduKG5ld1RlbXBsYXRlcywgdGVtcGxhdGVzKTtcbiAgaXRlcmF0ZUFycmF5KHZhbHVlLCBmb3JFYWNoTm9kZSk7XG5cbiAgZnVuY3Rpb24gZm9yRWFjaE5vZGUoeyB0eXBlLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaW5kZXgsIHRyZWUpIHtcbiAgICBpZiAodHlwZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG5cbiAgICAgIGlmIChuZXdUZW1wbGF0ZXNbdmFsdWVdKSB7XG4gICAgICAgIHRyZWVbaW5kZXhdID0gbmV3VGVtcGxhdGVzW3ZhbHVlXS52YWx1ZTtcbiAgICAgICAgYXNzaWduKG5ld1ZhcnMsIHRvT2JqZWN0S2V5cyhuZXdUZW1wbGF0ZXNbdmFsdWVdLnZhcnMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCBmb3JFYWNoTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFycy5sZW5ndGggPSAwO1xuICB2YXJzLnB1c2goLi4ua2V5cyhuZXdWYXJzKSk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuIiwiaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXBwKG5vZGUpIHtcbiAgY29uc3QgZWxlbSA9IG5ldyBFbGVtKG5vZGUpO1xuXG4gIGlmICghZWxlbS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhcHAgZnJvbSB3YXMgZ2l2ZW4hIChyZW1vdmVBcHApJyk7XG4gIH1cblxuICBub2RlID0gZWxlbVswXTtcblxuICBjb25zdCB7IER3YXluZVJvb3RCbG9jayB9ID0gbm9kZTtcblxuICBpZiAoIShEd2F5bmVSb290QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFwcCByZWdpc3RlcmVkIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCEgKHJlbW92ZUFwcCknKTtcbiAgfVxuXG4gIER3YXluZVJvb3RCbG9jay4kJC5yZW1vdmUoKTtcbiAgZWxlbS5yZW1vdmVBdHRyKCdkd2F5bmUtcm9vdCcpO1xuXG4gIGRlbGV0ZSBub2RlLkR3YXluZVJvb3RCbG9jaztcbn1cbiIsIi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xuLyogZXNsaW50IG5vLW5lZ2F0ZWQtY29uZGl0aW9uOiAwICovXG5leHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuIiwiZXhwb3J0IGNvbnN0IHtcbiAgY3JlYXRlLFxuICBrZXlzLFxuICBnZXRQcm90b3R5cGVPZjogZ2V0UHJvdG9cbn0gPSBPYmplY3Q7XG5cbmV4cG9ydCBjb25zdCBzZXRQcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoKHRhcmdldCwgcHJvdG8pID0+IHtcbiAgLyogZXNsaW50IG5vLXByb3RvOiAwICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBwcm90bztcbn0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi4vdXRpbHMvb2JqZWN0U3RhdGljcyc7XG5cbmV4cG9ydCBjb25zdCBISURFX0NMQVNTID0gJ19fZHdheW5lLWhpZGRlbl9fJztcbmV4cG9ydCBjb25zdCBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuZXhwb3J0IGNvbnN0IERfUkVTVF9SRUdFWCA9IC9eZC1yZXN0KD86I3wkKS87XG5cbmV4cG9ydCBjb25zdCByb290QmxvY2tzID0gY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IHJvb3RNaXhpbnMgPSBjcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgU2NvcGUgPSB7XG4gIGV2YWxNb2RlOiBmYWxzZSxcbiAgZ2V0dGluZ1ZhcnM6IFtdXG59O1xuIiwiaW1wb3J0IHtcbiAgaXNOaWwsIGlzU3RyaW5nLCBhc3NpZ24sXG4gIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMsIGRlZmluZVByb3BlcnRpZXMsXG4gIGNvbGxlY3RGcm9tQXJyYXksIGNvbGxlY3RGcm9tT2JqZWN0LFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIHRvSHlwaGVuQ2FzZSwgdG9TdHJpbmdUYWcsXG4gIHNldFRvU3RyaW5nVGFnLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGlzSFRNTERvY3VtZW50LCBpc1ZhbGlkTm9kZSxcbiAgYWRkQXR0ciwgYWRkQ1NTUHJvcCwgYWRkRGF0YUF0dHIsXG4gIGFkZE5leHQsIGFkZFBhcmVudCwgYWRkUHJldixcbiAgdG9FbGVtLCBpc0VsZW1lbnRzQ29sbGVjdGlvbixcbiAgZ2V0QXR0ck5TLCBoaWRlLCBzaG93LCByZW1vdmVcbn0gZnJvbSAnLi9oZWxwZXJzL0VsZW0nO1xuaW1wb3J0IHsgU1ZHX05TIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gJy4vZmluZCc7XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ30gRWxlbUV2ZW50U3RyaW5nXG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gQSBzdHJpbmcgY29udGFpbmluZyBldmVudHMgc2VwYXJhdGVkIGJ5IGEgY29tbWEgd2l0aCB6ZXJvIG9yIG1vcmUgc3BhY2VzIG9yIGp1c3Qgc3BhY2VzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1MaXN0ZW5lclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtFdmVudH0gZSAtIEZpcmVkIGV2ZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gRWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1SZW1vdmVMaXN0ZW5lcnNcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Li4uRWxlbUV2ZW50U3RyaW5nfSBldmVudHMgLSBJZiBhdCBsZWFzdCBvbmUgYXJndW1lbnQgcHJlc2VudCBvbmx5IHJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIHNwZWNpZmllZFxuICogYnkgdGhlIGV2ZW50cyBpbiB0aGUgYXJndW1lbnRzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEl0ZXJhdGlvbkNhbGxiYWNrXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gbm9kZSAtIEl0ZXJhdGlvbiBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSXRlcmF0aW9uIGluZGV4LlxuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gSW5pdGlhbCBzZXQuXG4gKi9cblxuY29uc3QgeyBTeW1ib2wgfSA9IGdsb2JhbDtcbmNvbnN0IEVWRU5UX1NFUEFSQVRPUl9SRUdFWCA9IC8oPzosfCApICovO1xuY29uc3QgQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVggPSAvOyA/LztcbmNvbnN0IENTU19JTVBPUlRBTlRfUkVHRVggPSAvID8haW1wb3J0YW50JC87XG5jb25zdCBFVkVOVF9SRUdFWCA9IC9FdmVudCQvO1xuY29uc3QgWEhUTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBlbXB0eUNvbGxlY3Rpb24gPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgRWxlbVxuICogQGV4dGVuZHMgQXJyYXlcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IFtlbGVtID0gW11dIC0gQW4gZWxlbWVudCBvciBhbiBhcnJheSBvZiBlbGVtZW50cyB0byB3cmFwLlxuICogQHJldHVybnMge0VsZW19IEluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhbiBlbGVtZW50cyBzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNscycpKTtcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NscycpKTtcbiAqL1xuY2xhc3MgRWxlbSBleHRlbmRzIEFycmF5IHtcbiAgc3RhdGljIGFkZE1ldGhvZHMocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyh0aGlzLnByb3RvdHlwZSwgcHJvcGVydHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbGVtID0gZW1wdHlDb2xsZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgfVxuXG4gICAgc2V0UHJvdG8odGhpcywgRWxlbS5wcm90b3R5cGUpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudHNDb2xsZWN0aW9uKGVsZW0pKSB7XG4gICAgICAgIGVsZW0gPSBbZWxlbV07XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShlbGVtLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICB0aGlzLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLihFbGVtfEVsZW1lbnR8RWxlbWVudFtdKX0gZWxlbWVudHMgLSBFYWNoIGFyZ3VtZW50IGlzIGEgRWxlbSwgb3IgRWxlbWVudCwgb3IgYXJyYXkgb2YgRWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgZWxlbWVudHMgdG8gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbTEuZmluZCgnLmNsczEnKVxuICAgKiAgIC5hZGQoZWxlbTIuZmluZCgnLmNsczInKSlcbiAgICogICAuaGlkZSgpO1xuICAgKi9cbiAgYWRkKCkge1xuICAgIGNvbnN0IGVsZW1zID0gdGhpcy5zbGljZSgpO1xuXG4gICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGVsZW0pID0+IHtcbiAgICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgICAgZWxlbSA9IFtlbGVtXTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICAgIGlmICghZWxlbXMuaW5jbHVkZXMoZWxlbSkgJiYgaXNWYWxpZE5vZGUoZWxlbSkpIHtcbiAgICAgICAgICBlbGVtcy5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYWRkQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gY2xhc3NlcyAtIENsYXNzZXMgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY2xhc3NlcyB0byB0aGUgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmFkZENsYXNzKCdyZWQnLCAncm91bmQnKTtcbiAgICovXG4gIGFkZENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5hZGQoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2F0dHJdIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFthdHRyTmFtZV06IHZhbHVlLCAuLi4gfSB0byBzZXQgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAgICogaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGF0dHJpYnV0ZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiByZXR1cm5lZCwgaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cjEnLCAndmFsdWUxJyk7IC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMScgYW5kIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCdhdHRyMScpOyAgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5hdHRyKHtcbiAgICogICBhdHRyMTogJ3ZhbHVlMycsICAgICAgICAgICAgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIGF0dHIyOiAndmFsdWUyJyAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjIgc2V0IHRvICd2YWx1ZTInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5hdHRyKCk7ICAgICAgICAgICAgICAgICAgLy8geyBhdHRyMTogJ3ZhbHVlMycsIGF0dHIyOiAndmFsdWUyJyB9XG4gICAqL1xuICBhdHRyKGF0dHIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChlbGVtLmF0dHJpYnV0ZXMsIGFkZEF0dHIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcoYXR0cikpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnMgPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICAgIHJldHVybiBuc1xuICAgICAgICA/IGVsZW0uZ2V0QXR0cmlidXRlTlMobnMsIGF0dHIpXG4gICAgICAgIDogZWxlbS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgYXR0ciA9IHsgW2F0dHJdOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QoYXR0ciwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQXR0cihrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWU7XG5cbiAgICAgICAgY29uc3QgbnMgPSBnZXRBdHRyTlMoa2V5LCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZU5TKG5zLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NoaWxkcmVuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IEQtV3JhcCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBlbGVtZW50J3MgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbigpO1xuICAgKi9cbiAgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXMubGVuZ3RoID8gdGhpc1swXS5jaGlsZE5vZGVzIDogW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjbG9zZXN0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VlIHRoZSBsaW5rLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjY2xvc2VzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdH0uXG4gICAqL1xuICBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb2xsZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBjYiA9IDo6ZWxlbWVudHMucHVzaDtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNiLCBlbGVtLCBpbmRleCwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVsZW0oZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjb250YWluc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgYXJndW1lbnQgd2l0aGluIHRoaXMgZWxlbWVudC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBleHRlbnNpb24gZm9yXG4gICAqIFtOb2RlI2NvbnRhaW5zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc30uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY29udGFpbnMoZWxlbTIpOyAgIC8vIHRydWV8ZmFsc2VcbiAgICovXG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzWzBdO1xuICAgIGNvbnN0IGNoaWxkID0gdG9FbGVtKGVsZW1lbnQpWzBdO1xuXG4gICAgcmV0dXJuICFwYXJlbnQgfHwgIWNoaWxkXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2NyZWF0ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBjcmVhdGVkIGVsZW1lbnQuIElmIHR5cGUgaXMgXCIjdGV4dFwiIGEgdGV4dCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIElmIHR5cGUgaXMgXCIjY29tbWVudFwiIGEgY29tbWVudCBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSAtIHdyYXAgb2YgdGhlIGNyZWF0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgZWxlbWVudCBpcyBqdXN0IGNyZWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3JlYXRlKCdkaXYnKTtcbiAgICovXG4gIGNyZWF0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBsZXQgZWwgPSBudWxsO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdHlwZSA9PT0gJyN0ZXh0JztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gaXNIVE1MRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBpZiAoaXNUZXh0IHx8IHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgZWwgPSBpc1RleHRcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBucyA9IHR5cGUgPT09ICdzdmcnXG4gICAgICAgICAgPyBTVkdfTlNcbiAgICAgICAgICA6IGVsZW0ubmFtZXNwYWNlVVJJIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgfHwgWEhUTUxfTlM7XG5cbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBhZGQobmV3IEVsZW0oZWwpLmludG8oZWxlbSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVDb21tZW50XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGNvbW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBjb21tZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGNvbW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZUNvbW1lbnQoJ2NvbW1lbnQnKTtcbiAgICovXG4gIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiB0aGlzXG4gICAgICAuY3JlYXRlKCcjY29tbWVudCcpXG4gICAgICAudGV4dCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlVGV4dFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCB0ZXh0IG5vZGVzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyB0ZXh0IG5vZGVzIGluc2lkZSB0aGlzIGVsZW1lbnQuXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgdGV4dCBub2RlIGlzIGp1c3QgY3JlYXRlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGVUZXh0KCd0ZXh0Jyk7XG4gICAqL1xuICBjcmVhdGVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpc1xuICAgICAgLmNyZWF0ZSgnI3RleHQnKVxuICAgICAgLnRleHQodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbcHJvcGVydHldIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBzdHlsZXMuIFN1cHBvcnRzICFpbXBvcnRhbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5JywgJ25vbmUnKTsgLy8gZGlzcGxheSBzZXQgdG8gJ25vbmUnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXG4gICAqIGVsZW0uY3NzKHtcbiAgICogICBkaXNwbGF5OiAnaW5saW5lJywgICAgICAgICAvLyBkaXNwbGF5IHNldCB0byAnaW5saW5lJ1xuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXG4gICAqIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygpOyAgICAgICAgICAgICAgICAgIC8vIHsgZGlzcGxheTogJ25vbmUnLCBjdXJzb3I6ICdwb2ludGVyJyB9XG4gICAqL1xuICBjc3MocHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KHN0eWxlLmNzc1RleHQuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpLCBhZGRDU1NQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpICsgKHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpID8gJyAhaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHByb3BlcnR5ID0gdG9IeXBoZW5DYXNlKHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbShlbGVtKS5yZW1vdmVDU1MocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgdmFsdWUucmVwbGFjZShDU1NfSU1QT1JUQU5UX1JFR0VYLCAnJyksXG4gICAgICAgICAgQ1NTX0lNUE9SVEFOVF9SRUdFWC50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJydcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtrZXldIC0gTmFtZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgKHdpdGhvdXQgZGF0YS0gcHJlZml4KVxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBhIHZhbHVlIHRvIHNldCBmb3IgdGhhdCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBkYXRhc2V0IG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgZGF0YSBhdHRyaWJ1dGVzLiBTZWVcbiAgICogW0hUTUxFbGVtZW50I2RhdGFzZXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9kYXRhc2V0fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScsICd2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnKTsgICAgICAgICAgLy8gJ3ZhbHVlMSdcbiAgICogZWxlbS5kYXRhKHtcbiAgICogICBzb21lS2V5MTogJ3ZhbHVlMycsICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTMnXG4gICAqICAgc29tZUtleTI6ICd2YWx1ZTInICAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkyIHNldCB0byAndmFsdWUyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5kYXRhKCk7ICAgICAgICAgICAgICAgICAgICAvLyB7IHNvbWVLZXkxOiAndmFsdWUzJywgc29tZUtleTI6ICd2YWx1ZTInIH1cbiAgICovXG4gIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpc1swXSB8fCB7fTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KGRhdGFzZXQsIGFkZERhdGFBdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YXNldFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChrZXksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGlzcGF0Y2hcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudH0gZXZlbnQgLSBFdmVudCBvciBhIHN0cmluZyAobmV3IEV2ZW50KGV2ZW50KSBpcyBjcmVhdGVkKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzID0ge31dIC0gT2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0V2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50fS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snKTtcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UsIGRhdGE6IDEgfSk7XG4gICAqIGVsZW0uZGlzcGF0Y2gobmV3IEN1c3RvbUV2ZW50KCdjdXN0b20tZXZlbnQnKSk7XG4gICAqL1xuICBkaXNwYXRjaChldmVudCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYnViYmxlcyA9IHRydWUsXG4gICAgICBjYW5jZWxhYmxlID0gdHJ1ZSxcbiAgICAgIC4uLnJlYWxEZXRhaWxzXG4gICAgfSA9IGRldGFpbHMgfHwge307XG4gICAgbGV0IGZpbmFsRXZlbnQgPSBldmVudDtcblxuICAgIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmFsRXZlbnQgPSBuZXcgRXZlbnQoZmluYWxFdmVudCwgeyBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xuICAgICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0hUTUxEb2N1bWVudChlbGVtKVxuICAgICAgICAgID8gZWxlbVxuICAgICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIGZpbmFsRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG4gICAgICAgIGFzc2lnbihmaW5hbEV2ZW50LCByZWFsRGV0YWlscyk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChmaW5hbEV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZWxlbVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXggPSAwXSAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9mIHRoZSBzZXQgdG8gZ2V0LiBOZWdhdGl2ZSBpbmRleCBtZWFucyBlbGVtLmxlbmd0aCArIGluZGV4LlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZWxlbSgxKTsgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMVxuICAgKiBlbGVtLmVsZW0oKTsgIC8vIGEgd3JhcCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2V0IHRoYXQgaGFzIGluZGV4IDBcbiAgICovXG4gIGVsZW0oaW5kZXggPSAwKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCArIGluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzW2luZGV4XSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2ZpbHRlclxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtmaWx0ZXJGbiA9IEJvb2xlYW5dIC0gRmlsdGVyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmZpbHRlcigoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuY2xvc2VzdCgnLnBhcmVudCcpKTtcbiAgICovXG4gIGZpbHRlcihmaWx0ZXJGbiA9IEJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KChhZGQsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZmlsdGVyRm4oZWxlbSwgaW5kZXgsIHRoaXMpKSB7XG4gICAgICAgIGFkZChlbGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZmluZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFbGVtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L3F1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKi9cbiAgZmluZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgYWRkKGZpbmQoc2VsZWN0b3IsIGVsZW0pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZm9yRWFjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBmaW5kKCcuY2xzJykuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgsIHNldCkgPT4ge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZ1xuICAgKiB9KTtcbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBpdGVyYXRlQXJyYXkodGhpcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGNhbGxiYWNrKHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hhc0F0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUgb3Igbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmF0dHIoJ2F0dHInLCAndmFsdWUnKS5oYXNBdHRyKCdhdHRyJyk7IC8vIHRydWVcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdhdHRyJykuaGFzQXR0cignYXR0cicpOyAgICAvLyBmYWxzZVxuICAgKi9cbiAgaGFzQXR0cihhdHRyKSB7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBucyA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgIHJldHVybiBuc1xuICAgICAgPyBlbGVtLmhhc0F0dHJpYnV0ZU5TKG5zLCBhdHRyKVxuICAgICAgOiBlbGVtLmhhc0F0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gTmFtZSBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3MuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcyBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgICAgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKS5oYXNDbGFzcygnY2xzJyk7IC8vIGZhbHNlXG4gICAqL1xuICBoYXNDbGFzcyhjbHMpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNscylcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hpZGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gSGlkZXMgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaGlkZSgpO1xuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGhpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNodG1sXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW2h0bWxdIC0gSFRNTCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgSFRNTC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIEhUTUwgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyBIVE1MIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgaHRtbCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyBIVE1MLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmh0bWwoJzxkaXY+MTwvZGl2PicpO1xuICAgKiBlbGVtLmh0bWwoKTsgLy8gJzxkaXY+MTwvZGl2PidcbiAgICovXG4gIGh0bWwoaHRtbCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgIHJldHVybiBlbGVtXG4gICAgICAgID8gZWxlbS5pbm5lckhUTUxcbiAgICAgICAgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH1cblxuICBpbmNsdWRlcyhlbGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEFmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYWZ0ZXIgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGJlZm9yZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudFswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnRvXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHB1dCB0aGlzIGVsZW1lbnRzIGludG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSB0aGV5IGFyZSBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNhcHBlbmRDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvYXBwZW5kQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmludG8oZWxlbTIpO1xuICAgKiBlbGVtLmludG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmludG8oJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGludG8oZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudClbMF07XG5cbiAgICBpZiAoXG4gICAgICAhZWxlbWVudFxuICAgICAgfHwgaXNIVE1MRG9jdW1lbnQoZWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpc1tpXSwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoXG4gICAgICBlbGVtLm1hdGNoZXNcbiAgICAgIHx8IGVsZW0ubWF0Y2hlc1NlbGVjdG9yXG4gICAgICB8fCBlbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgfHwgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICAgIHx8IGVsZW0ubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgIHx8IGVsZW0ub01hdGNoZXNTZWxlY3RvclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtLCBzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBTZWxlY3RvciAnJHsgc2VsZWN0b3IgfScgaXMgbm90IGEgdmFsaWQgc2VsZWN0b3IgKEVsZW0jaXMpYCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfHZvaWR9IG5vZGVOYW1lIChsb3dlcmNhc2VkKSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIG5hbWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGUoJ2RpdicpLm5hbWUoKSAvLyAnZGl2J1xuICAgKi9cbiAgbmFtZSgpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtICYmIGVsZW0ubm9kZU5hbWVcbiAgICAgID8gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jbmV4dFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBuZXh0IGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ubmV4dCgpOyAvLyBmaW5kcyBuZXh0IGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICovXG4gIG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGROZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jb25cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW1FdmVudFN0cmluZ3xPYmplY3QuPEVsZW1FdmVudFN0cmluZ3xFbGVtTGlzdGVuZXI+fSBldmVudCAtIEVpdGhlciBhIHtAbGluayBFbGVtRXZlbnRTdHJpbmd9IHN0cmluZ1xuICAgKiBvciBhbiBvYmplY3Qgd2l0aCBldmVudCBrZXlzIChhIGtleSBpcyBhbHNvIEVsZW1FdmVudFN0cmluZykgYW5kIGxpc3RlbmVycyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RWxlbUxpc3RlbmVyfSBbbGlzdGVuZXJdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IG11c3QgYmUgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3JcbiAgICogc3BlY2lmaWVkIGV2ZW50KHMpLlxuICAgKiBAcmV0dXJucyB7RWxlbVJlbW92ZUxpc3RlbmVyc30gRnVuY3Rpb24gdGhhdCB0YWtlcyBvcHRpb25hbCBldmVudCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ub24oXG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnLFxuICAgKiAgICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgZGF0YWxpc3QsIGtleWdlbiwgb3V0cHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oXG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnLFxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcbiAgICogKTtcbiAgICogZWxlbS5vbihcbiAgICogICB7XG4gICAqICAgICAnY2hhbmdlLCBpbnB1dCc6IChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSksXG4gICAqICAgICAnYmx1cic6ICgpID0+IGNvbnNvbGUubG9nKCdibHVyJylcbiAgICogICB9LFxuICAgKiAgICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgZGF0YWxpc3QsIGtleWdlbiwgb3V0cHV0J1xuICAgKiApO1xuICAgKlxuICAgKiBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBlbGVtLm9uKHtcbiAgICogICAnY2hhbmdlLCBpbnB1dCc6IChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSksXG4gICAqICAgJ2JsdXInOiAoKSA9PiBjb25zb2xlLmxvZygnYmx1cicpXG4gICAqIH0pO1xuICAgKlxuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2NsaWNrJyk7XG4gICAqIHJlbW92ZUxpc3RlbmVycygnYmx1ciwgY2hhbmdlJyk7XG4gICAqIHJlbW92ZUxpc3RlbmVycygnYmx1ciwgY2hhbmdlJywgJ2lucHV0Jyk7XG4gICAqIHJlbW92ZUxpc3RlbmVycygpO1xuICAgKi9cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKGV2ZW50KSkge1xuICAgICAgZXZlbnQgPSB7IFtldmVudF06IGxpc3RlbmVyIH07XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RXZlbnRzID0ge307XG4gICAgY29uc3QgYWxsTGlzdGVuZXJzID0ge307XG5cbiAgICBpdGVyYXRlT2JqZWN0KGV2ZW50LCAobGlzdGVuZXIsIGV2ZW50KSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkoZXZlbnQuc3BsaXQoRVZFTlRfU0VQQVJBVE9SX1JFR0VYKSwgKGV2ZW50KSA9PiB7XG4gICAgICAgIChuZXdFdmVudHNbZXZlbnRdID0gbmV3RXZlbnRzW2V2ZW50XSB8fCBbXSkucHVzaChsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChuZXdFdmVudHMsIChsaXN0ZW5lcnMsIGV2ZW50KSA9PiB7XG4gICAgICAgIGl0ZXJhdGVBcnJheShsaXN0ZW5lcnMsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAoYWxsTGlzdGVuZXJzW2V2ZW50XSA9IGFsbExpc3RlbmVyc1tldmVudF0gfHwgW10pLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChldmVudCkgPT4ge1xuICAgICAgICAgIGl0ZXJhdGVBcnJheShldmVudC5zcGxpdChFVkVOVF9TRVBBUkFUT1JfUkVHRVgpLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9IGFsbExpc3RlbmVyc1tldmVudF07XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KHJlbW92ZUxpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcblxuICAgICAgICAgICAgICBkZWxldGUgYWxsTGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlT2JqZWN0KGFsbExpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVycywgZXZlbnQpID0+IHtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkocmVtb3ZlTGlzdGVuZXJzLCAocmVtb3ZlTGlzdGVuZXIpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuXG4gICAgICAgICAgZGVsZXRlIGFsbExpc3RlbmVyc1tldmVudF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3BhcmVudFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCByZXR1cm5zIHdyYXAgb2YgdGhlIHNldCBvZiB0aGUgcGFyZW50IGVsZW1lbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKi9cbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkUGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcHJldlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnByZXYoKTsgLy8gZmluZHMgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKi9cbiAgcHJldigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZFByZXYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwcm9wXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsICo+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGFuIGFzc2lnbmVkIG9iamVjdC5cbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmdcbiAgICogdGhpcyBoYXMgdG8gYmUgYW4gYXNzaWduZWQgdmFsdWUgaWYgaXQncyBwcmVzZW50LlxuICAgKiBAcmV0dXJucyB7RWxlbXwqfSBSZXR1cm5zIHRoaXMgaWYgaXQncyBzZXR0ZXIgb3IgYSB2YWx1ZSBpZiBnZXR0ZXIuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBnZXR0ZXIgZm9yIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICogb3IgYSBzZXR0ZXIgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5wcm9wKCdkcmFnZ2FibGUnLCBmYWxzZSk7XG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJyk7IC8vIGZhbHNlXG4gICAqL1xuICBwcm9wKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF1bcHJvcGVydHldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QocHJvcGVydHksICh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgICAgICBlbGVtW3Byb3BdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAqIE5vdGU6IGl0IGRvZXNuJ3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2V0IHNvIHdhdGNoIG91dCBmb3IgdGhlIG1lbW9yeSBsZWFrcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmUoKTtcbiAgICovXG4gIHJlbW92ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKHJlbW92ZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXR0cmlidXRlcyAtIEF0dHJpYnV0ZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSBhcmd1bWVudHMgZnJvbSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlQXR0cignZm9vJywgJ2JhcicsICdiYXonKTtcbiAgICovXG4gIHJlbW92ZUF0dHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGF0dHIpID0+IHtcbiAgICAgICAgY29uc3QgbnMgPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGVOUyhucywgYXR0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgY2xhc3NlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVDbGFzcygnZm9vJywgJ2JhcicsICdiYXonKTtcbiAgICovXG4gIHJlbW92ZUNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcblxuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5yZW1vdmUoY2xzKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNTU1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBwcm9wcyAtIENTUyBwcm9wZXJ0aWVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBDU1MgcHJvcGVydGllcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZW1vdmVDU1MoJ2Rpc3BsYXknLCAncG9zaXRpb24nLCAnbWFyZ2luJyk7XG4gICAqL1xuICByZW1vdmVDU1MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGFyZ3VtZW50cywgKGNzcykgPT4ge1xuICAgICAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHRvSHlwaGVuQ2FzZShjc3MpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZXBsYWNlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHJlcGxhY2UgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiB3aXRoIGEgc2V0IG9mIGVsZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQgKEVsZW1lbnQgb3IgRWxlbSkuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNyZXBsYWNlQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL3JlcGxhY2VDaGlsZH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVwbGFjZShlbGVtMik7XG4gICAqIGVsZW0ucmVwbGFjZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0ucmVwbGFjZSgnI2lkIGRpdi5jMScpO1xuICAgKi9cbiAgcmVwbGFjZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KTtcblxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5lbGVtKDApO1xuICAgIGNvbnN0IHBhcmVudCA9IGZpcnN0LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgZWxlbSA9IHBhcmVudDtcbiAgICBsZXQgbWV0aG9kID0gJ2ludG8nO1xuICAgIGNvbnN0IG5leHQgPSBmaXJzdC5uZXh0KClbMF07XG4gICAgY29uc3QgcHJldiA9IGZpcnN0LnByZXYoKVswXTtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBlbGVtID0gbmV4dDtcbiAgICAgIG1ldGhvZCA9ICdpbnNlcnRCZWZvcmUnO1xuICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgZWxlbSA9IHByZXY7XG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QWZ0ZXInO1xuICAgIH1cblxuICAgIGZpcnN0LnJlbW92ZSgpO1xuXG4gICAgZWxlbWVudFttZXRob2RdKGVsZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNzaG93XG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFNob3dzIGFsbCBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKiBJZiBhbiBlbGVtZW50IHdhcyBoaWRkZW4gdXNpbmcge0BsaW5rIEVsZW0jaGlkZX0gcHJldmlvdXMgZGlzcGxheSBpcyBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uc2hvdygpO1xuICAgKi9cbiAgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKHNob3cpO1xuICB9XG5cbiAgc2xpY2UoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtKHN1cGVyLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0ZXh0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW3RleHRdIC0gVGV4dCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgdGV4dC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIHRleHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyB0ZXh0cyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIHRleHQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgdGV4dC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50ZXh0KCcxMjMnKTtcbiAgICogZWxlbS50ZXh0KCk7IC8vICcxMjMnXG4gICAqL1xuICB0ZXh0KHRleHQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AoJ3RleHRDb250ZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcbiAgICogd2l0aCB0aGUgJycgdmFsdWUgYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLiBJZiBub3QgcHJlc2VudCBtZXRob2QgYWRkc1xuICAgKiB0aGUgYXR0cmlidXRlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJyk7XG4gICAqIGVsZW0udG9nZ2xlQXR0cignYXR0cicsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQXR0cihhdHRyLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFlbGVtLmhhc0F0dHIoYXR0cikgOiBjb25kaXRpb24pIHtcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdG9nZ2xlQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gQ2xhc3MgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgY2xhc3NcbiAgICogYW5kIGlmIGZhbHNleSBtZXRob2QgcmVtb3ZlcyB0aGUgY2xhc3MuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXG4gICAqIHRoZSBjbGFzcyBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHRvZ2dsaW5nIGNsYXNzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLnRvZ2dsZUNsYXNzKCdjbHMnLCBzb21lQ29uZGl0aW9uKTtcbiAgICovXG4gIHRvZ2dsZUNsYXNzKGNscywgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW07XG5cbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xzLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICFjbGFzc0xpc3QuY29udGFpbnMoY2xzKSA6IGNvbmRpdGlvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoRWxlbSwgJ0VsZW0nKTtcblxuaWYgKFN5bWJvbCAmJiBTeW1ib2wuc3BlY2llcykge1xuICBkZWZpbmVQcm9wZXJ0aWVzKEVsZW0sIHtcbiAgICBbU3ltYm9sLnNwZWNpZXNdOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBBcnJheTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBFbGVtIH07XG4iLCJpbXBvcnQge1xuICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzLFxuICByZW1vdmVBcnJheUVsZW0sIHNldFRvU3RyaW5nVGFnXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgd3JhcE1peGluLCByZW1vdmVXYXRjaGVycyB9IGZyb20gJy4vaGVscGVycy9CbG9jayc7XG5cbmNsYXNzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQG1ldGhvZCBNaXhpbi53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIG1peGluLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIE1peGlufSBOZXcgbWl4aW4uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIG1peGlucy5cbiAgICogSXQgaXMgY29uc2lkZXJlZCBiZXN0IHByYWN0aWNlIHRvIGp1c3QgZXh0ZW5kcyB0aGUgb2xkIG1peGluIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoLi4ud3JhcHBlcnMpIHtcbiAgICByZXR1cm4gd3JhcHBlcnMucmVkdWNlKHdyYXBNaXhpbiwgdGhpcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgZHluYW1pYyxcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgY29tbWVudCxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCB3YXRjaGVycyA9IFtdO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAkJDoge1xuICAgICAgICBuYW1lLFxuICAgICAgICBfdmFsdWU6IHZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaXNEeW5hbWljOiBkeW5hbWljLFxuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICB3YXRjaGVycyxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgaXNSZW1vdmVkOiBmYWxzZSxcbiAgICAgICAgZXZhbHVhdGU6ICh3YXRjaGVyKSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaXNEeW5hbWljLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBfdmFsdWVcbiAgICAgICAgICB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpc0R5bmFtaWNcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoX3ZhbHVlKTtcblxuICAgICAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgICAgICB3YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKGlzUGFyZW50U2lnbmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheUVsZW0ocGFyZW50QmxvY2suJCQubWl4aW5zLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBbTWl4aW4jYXJnc11cbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IFtNaXhpbiNjb21tZW50XVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudEJsb2NrXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRCbG9jayA9IHBhcmVudEJsb2NrO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QmxvY2t9IFtNaXhpbiNwYXJlbnRTY29wZV1cbiAgICAgKiBAdHlwZSB7QmxvY2t9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jsb2NrfSBbTWl4aW4jcGFyZW50VGVtcGxhdGVdXG4gICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtFbGVtfSBNaXhpbiNlbGVtXG4gICAgICogQHR5cGUge0VsZW19XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBNaXhpbiNub2RlXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMubm9kZSA9IGVsZW1bMF07XG5cbiAgICBpZiAocGFyZW50QmxvY2spIHtcbiAgICAgIHBhcmVudEJsb2NrLiQkLm1peGlucy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGFmdGVyVXBkYXRlKCkge31cblxuICBiZWZvcmVSZW1vdmUoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtXYXRjaGVyfSBbY2FsbGJhY2tdIC0gSWYgcHJlc2VudCwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIG1peGluIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoY2FsbGJhY2spO1xuICB9XG59XG5cbnNldFRvU3RyaW5nVGFnKE1peGluLCAnTWl4aW4nKTtcblxuZXhwb3J0IHsgTWl4aW4gfTtcbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHtcbiAgZGVmaW5lRnJvemVuUHJvcGVydGllcyxcbiAgYXNzaWduLCBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIGlzRnVuY3Rpb24sIGlzQXJyYXksXG4gIHNldFRvU3RyaW5nVGFnLCBoYXNPd25Qcm9wZXJ0eSxcbiAgcmVtb3ZlQXJyYXlFbGVtLCBjcmVhdGUsXG4gIGdldFByb3RvLCBzZXRQcm90b1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGNvbnN0cnVjdE1peGluUmVnZXgsIGlzSW5zdGFuY2VPZixcbiAgcmVtb3ZlV2F0Y2hlcnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNsZWFuUHJvcGVydHksXG4gIHRyYW5zZm9ybVJlc3RBcmdzLCBjYWxjdWxhdGVBcmdzLFxuICB3YXRjaEZvckFsbEFyZ3MsIHdhdGNoRm9yQWxsR2xvYmFscywgd2F0Y2hGb3JBbGxMb2NhbHMsXG4gIGV4dGVuZEJsb2NrLCB3cmFwQmxvY2tcbn0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7XG4gIERfUkVTVF9SRUdFWCwgU2NvcGUsXG4gIHJvb3RCbG9ja3MsIHJvb3RNaXhpbnNcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgaW5pdEFwcCB9IGZyb20gJy4vaW5pdEFwcCc7XG5cbi8qKlxuICogQHR5cGVkZWYge0Vycm9yfSBFdmFsdWF0aW9uRXJyb3JcbiAqIEBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBleHByZXNzaW9uIC0gRXhwcmVzc2lvbiB3aGljaCBoYXMgYmVlbiBldmFsdWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBAcHJvcGVydHkge0Jsb2NrfSBibG9jayAtIEJsb2NrIGluIGNvbnRleHQgb2Ygd2hpY2ggdGhlIGV4cHJlc3Npb24gaGFzIGJlZW4gZXZhbHVhdGVkIHdpdGggdGhlIGVycm9yLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhdGNoZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gT2xkIHZhbHVlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFZhcnNXYXRjaGVyXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV3JhcHBlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHt0eXBlb2YgQmxvY2t8dHlwZW9mIE1peGlufSBCbG9jayBjbGFzcyB0byB3cmFwLlxuICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IEJsb2NrIGNsYXNzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEFmdGVyVXBkYXRlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gTmV3IHZhbHVlLlxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSAtIE9sZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gbWl4aW4gLSBNaXhpbiBpbnN0YW5jZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBCbG9ja1JlZ2lzdGVySG9va1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtCbG9ja30gQmxvY2sgLSBSZWdpc3RlcmluZyBibG9jay5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgbmFtZS5cbiAqIEByZXR1cm5zIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciByZWdpc3RlcmluZyB0aGUgYmxvY2suXG4gKiBJZiBCbG9jayBzdWJjbGFzcyByZXR1cm5lZCBpdCdzIHJlZ2lzdGVyZWQgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCBibG9jaywgb3RoZXJ3aXNlXG4gKiB0aGUgaW5pdGlhbCBibG9jayBpcyB1c2VkLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1peGluUmVnaXN0ZXJIb29rXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Jsb2NrfSBNaXhpbiAtIFJlZ2lzdGVyaW5nIG1peGluLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBNaXhpbiBuYW1lLlxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIHRoZSBtaXhpbi5cbiAqIElmIE1peGluIHN1YmNsYXNzIHJldHVybmVkIGl0J3MgcmVnaXN0ZXJlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsIG1peGluLCBvdGhlcndpc2VcbiAqIHRoZSBpbml0aWFsIG1peGluIGlzIHVzZWQuXG4gKi9cblxuY29uc3QgYmxvY2tIb29rcyA9IFtdO1xuY29uc3QgbWl4aW5Ib29rcyA9IFtdO1xuY29uc3QgVEFHX05BTUVfUkVHRVggPSAvXlthLXpdW2EtelxcZFxcLV8uOiFAIyQlXiYqKClbXFxde309J1wiXFxcXF0qJC9pO1xuY29uc3QgQVRUUl9OQU1FX1JFR0VYID0gL15bXFx1MDAwMC1cXHUwMDIwXFxzJ1wiPi89XSskLztcbmNvbnN0IFdBVENIRURfQVJHX1BSRUZJWF9SRUdFWCA9IC9eYXJnc1xcLi87XG5jb25zdCBXQVRDSEVEX0dMT0JBTF9QUkVGSVhfUkVHRVggPSAvXmdsb2JhbHNcXC4vO1xuY29uc3QgYWZ0ZXJFbGVtID0gbmV3IEVsZW0oKTtcblxuLyoqXG4gKiBAY2xhc3MgQmxvY2tcbiAqIEBleHRlbmRzIG51bGxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gRWxlbWVudCBvcHRpb25zLlxuICogQHJldHVybnMge0Jsb2NrfSBJbnN0YW5jZSBvZiBCbG9jay5cbiAqIEBkZXNjcmlwdGlvbiBDbGFzcyBmb3IgZHluYW1pYyB0ZW1wbGF0aW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBELCBCbG9jaywgaW5pdEFwcCB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogY2xhc3MgQXBwIGV4dGVuZHMgQmxvY2sge1xuICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPEhlbGxvIHRleHQ9XCJ7dGV4dH1cIi8+JztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAqICAgICBzdXBlcihvcHRzKTtcbiAqXG4gKiAgICAgdGhpcy50ZXh0ID0gJ3dvcmxkICgwKSc7XG4gKiAgICAgdGhpcy50aW1lcyA9IDA7XG4gKlxuICogICAgIHRoaXMuc2V0SW50ZXJ2YWwoKTtcbiAqICAgfVxuICpcbiAqICAgc2V0SW50ZXJ2YWwoKSB7XG4gKiAgICAgRCgxMDAwKS5pbnRlcnZhbCgoKSA9PiB7XG4gKiAgICAgICB0aGlzLnRleHQgPSBgd29ybGQgKCR7ICsrdGhpcy50aW1lcyB9KWA7XG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBCbG9jay5ibG9jaygnQXBwJywgQXBwKTtcbiAqIEJsb2NrLmJsb2NrKCdIZWxsbycsICdIZWxsbywge2FyZ3MudGV4dH0hJyk7XG4gKlxuICogaW5pdEFwcChodG1sYDxBcHAvPmAsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykpO1xuICovXG5jbGFzcyBCbG9jayB7XG4gIHN0YXRpYyBfYmxvY2tzID0gY3JlYXRlKHJvb3RCbG9ja3MpO1xuICBzdGF0aWMgX21peGlucyA9IGNyZWF0ZShyb290TWl4aW5zKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2suZGVmYXVsdEFyZ3MgPSBudWxsXVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkZWZhdWx0IGFyZ3MuXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdEFyZ3MgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay5kZWZhdWx0TG9jYWxzID0gbnVsbF1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgZGVmYXVsdCBsb2NhbHMuXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdExvY2FscyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLnRlbXBsYXRlID0geyB2YXJzOiBbXSwgdmFsdWU6IFtdIH1dXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIHRlbXBsYXRlLlxuICAgKi9cbiAgc3RhdGljIHRlbXBsYXRlID0ge1xuICAgIHZhcnM6IFtdLFxuICAgIHZhbHVlOiBbXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLm9uRXZhbEVycm9yXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFdmFsdWF0aW9uRXJyb3J9IGVyciAtIFRoZSBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYW4gZXZhbHVhdGlvbiBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBzdGF0aWMgb25FdmFsRXJyb3IoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXZhbCBlcnJvciAoZXZhbHVhdGluZyBcIiR7IGVyci5leHByZXNzaW9uIH1cIiBpbiBjb250ZXh0IG9mIGJsb2NrIFwiJHsgZXJyLmJsb2NrLiQkLm5hbWUgfVwiKTpgLCBlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmVmb3JlUmVnaXN0ZXJCbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7QmxvY2tSZWdpc3Rlckhvb2t9IGhvb2sgLSBCbG9jayByZWdpc3RlciBob29rLlxuICAgKi9cbiAgc3RhdGljIGJlZm9yZVJlZ2lzdGVyQmxvY2soaG9vaykge1xuICAgIGJsb2NrSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW1vdmVBcnJheUVsZW0oYmxvY2tIb29rcywgaG9vayk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmJlZm9yZVJlZ2lzdGVyTWl4aW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge01peGluUmVnaXN0ZXJIb29rfSBob29rIC0gTWl4aW4gcmVnaXN0ZXIgaG9vay5cbiAgICovXG4gIHN0YXRpYyBiZWZvcmVSZWdpc3Rlck1peGluKGhvb2spIHtcbiAgICBtaXhpbkhvb2tzLnB1c2goaG9vayk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlQXJyYXlFbGVtKG1peGluSG9va3MsIGhvb2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5ibG9ja1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgb3IgbWl4aW4gbmFtZS5cbiAgICogQHBhcmFtIHtUZW1wbGF0ZXx0eXBlb2YgQmxvY2t9IFN1YmNsYXNzIC0gU3ViY2xhc3Mgb2YgQmxvY2sgb3IgdGVtcGxhdGUgc3RyaW5nIG9mIGl0LlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEJsb2NrfHVuZGVmaW5lZH0gUmV0dXJucyByZWdpc3RlcmVkIEJsb2NrIG9yIHVuZGVmaW5lZCBpZiB0aGUgYmxvY2sgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogQGRlc2NyaXB0aW9uIFJlZ2lzdGVyIGJsb2NrIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhpcy5cbiAgICovXG4gIHN0YXRpYyBibG9jayhuYW1lLCBTdWJjbGFzcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiAhaXNJbnN0YW5jZU9mKEJsb2NrLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gU3ViY2xhc3M7XG5cbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgICBzdXBlcihvcHRzKTtcblxuICAgICAgICAgIHRoaXM6OmNvbnN0cnVjdG9yKG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgaXNBcnJheShTdWJjbGFzcykpIHtcbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICB2YWx1ZTogU3ViY2xhc3NcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiBTdWJjbGFzcy52YXJzICYmIFN1YmNsYXNzLnZhbHVlKSB7XG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgICBzdGF0aWMgdGVtcGxhdGUgPSBTdWJjbGFzcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFN1YmNsYXNzKSkge1xuICAgICAgY29uc29sZS53YXJuKGBCbG9jayBtdXN0IGJlIGEgc3RyaW5nIChyZXByZXNlbnRpbmcgYSBibG9jayB0ZW1wbGF0ZSksIGEgZnVuY3Rpb24gb3IgYSBjbGFzcyB0aGF0IGV4dGVuZHMgQmxvY2sgY2xhc3MgKG5hbWU6IFwiJHsgbmFtZSB9XCIpIChCbG9jay5ibG9jaylgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNJbnN0YW5jZU9mKEJsb2NrLCBTdWJjbGFzcykpIHtcbiAgICAgIGV4dGVuZEJsb2NrKFN1YmNsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAocm9vdEJsb2Nrc1tuYW1lXSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBibG9jayBpcyBhIGJ1aWx0LWluIGJsb2NrIHNvIHRoZSBibG9jayB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5ibG9jaylgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghVEFHX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIGJsb2NrcyBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdfYmxvY2tzJykpIHtcbiAgICAgIHRoaXMuX2Jsb2NrcyA9IGNyZWF0ZShnZXRQcm90byh0aGlzKS5fYmxvY2tzKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdkZWZhdWx0TG9jYWxzJykpIHtcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FscyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcGVydHkodGhpcywgJ2RlZmF1bHRBcmdzJykpIHtcbiAgICAgIHRoaXMuZGVmYXVsdEFyZ3MgPSBjcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIFN1YmNsYXNzID0gYmxvY2tIb29rcy5yZWR1Y2UoKHJldHVyblZhbHVlLCBob29rKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZXR1cm5WYWx1ZSA9IGhvb2socmV0dXJuVmFsdWUsIG5hbWUsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIGN1cnJlbnRSZXR1cm5WYWx1ZSlcbiAgICAgICAgICA/IGN1cnJlbnRSZXR1cm5WYWx1ZVxuICAgICAgICAgIDogcmV0dXJuVmFsdWU7XG4gICAgICB9LCBTdWJjbGFzcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmNhdWdodCBlcnJvciBpbiBcImJlZm9yZVJlZ2lzdGVyQmxvY2tcIiBob29rOicsIGVycik7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgdmFycyxcbiAgICAgIHZhbHVlXG4gICAgfSA9IFN1YmNsYXNzLnRlbXBsYXRlO1xuXG4gICAgU3ViY2xhc3MuX2h0bWwgPSB2YWx1ZTtcbiAgICBTdWJjbGFzcy5fdmFycyA9IHZhcnM7XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkoU3ViY2xhc3MsICdkZWZhdWx0QXJncycpKSB7XG4gICAgICBzZXRQcm90byhTdWJjbGFzcy5kZWZhdWx0QXJncywgbnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmxvY2tzW25hbWVdID0gU3ViY2xhc3M7XG5cbiAgICByZXR1cm4gU3ViY2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5pbml0XG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGNvbnRhaW5lciAtIENvbnRhaW5lciBvZiB0aGUgYXBwLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaW5pdGlhbGl6aW5nIGFwcC5cbiAgICovXG4gIHN0YXRpYyBpbml0KGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGtsYXNzID0gdGhpcztcblxuICAgIGluaXRBcHAoaHRtbFNjb3BlbGVzc2A8ZC1ibG9jayBDb25zdHJ1Y3Rvcj1cIntrbGFzc31cIi8+YCwgY29udGFpbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLm1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge3R5cGVvZiBNaXhpbnxBZnRlclVwZGF0ZX0gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBNaXhpbiBvciBBZnRlclVwZGF0ZSBjYWxsYmFjay5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbnx1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBCbG9jayBvciB1bmRlZmluZWQgaWYgdGhlIGJsb2NrIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBtaXhpbiBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXG4gICAqL1xuICBzdGF0aWMgbWl4aW4obmFtZSwgU3ViY2xhc3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgIWlzSW5zdGFuY2VPZihNaXhpbiwgU3ViY2xhc3MpKSB7XG4gICAgICBjb25zdCBhZnRlclVwZGF0ZSA9IFN1YmNsYXNzO1xuXG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICAgICAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICB0aGlzOjphZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNJbnN0YW5jZU9mKE1peGluLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgY2xhc3MgZG9lcyBub3QgZXh0ZW5kIE1peGluIGFuZCB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyb290TWl4aW5zW25hbWVdKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIG1peGluIGlzIGEgYnVpbHQtaW4gbWl4aW4gc28gdGhlIG1peGluIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLm1peGluKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFBVFRSX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIG1peGlucyBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdfbWl4aW5zJykpIHtcbiAgICAgIHRoaXMuX21peGlucyA9IGNyZWF0ZShnZXRQcm90byh0aGlzKS5fbWl4aW5zKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgU3ViY2xhc3MgPSBtaXhpbkhvb2tzLnJlZHVjZSgocmV0dXJuVmFsdWUsIGhvb2spID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJldHVyblZhbHVlID0gaG9vayhyZXR1cm5WYWx1ZSwgbmFtZSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgY3VycmVudFJldHVyblZhbHVlKVxuICAgICAgICAgID8gY3VycmVudFJldHVyblZhbHVlXG4gICAgICAgICAgOiByZXR1cm5WYWx1ZTtcbiAgICAgIH0sIFN1YmNsYXNzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuY2F1Z2h0IGVycm9yIGluIFwiYmVmb3JlUmVnaXN0ZXJNaXhpblwiIGhvb2s6JywgZXJyKTtcbiAgICB9XG5cbiAgICBTdWJjbGFzcy5fbWF0Y2ggPSBjb25zdHJ1Y3RNaXhpblJlZ2V4KG5hbWUpO1xuXG4gICAgdGhpcy5fbWl4aW5zW25hbWVdID0gU3ViY2xhc3M7XG5cbiAgICByZXR1cm4gU3ViY2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIGJsb2NrLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEJsb2NrfSBOZXcgYmxvY2suXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIGJsb2NrcyBpbnRvIGFub3RoZXIgYmxvY2tzLlxuICAgKiBJdCBpcyBjb25zaWRlcmVkIGJlc3QgcHJhY3RpY2UgdG8ganVzdCBleHRlbmRzIHRoZSBvbGQgYmxvY2sgd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXY+MTIzPC9kaXY+JztcbiAgICogfVxuICAgKlxuICAgKiBNeUJsb2NrLndyYXAoKEJsb2NrKSA9PiB7XG4gICAqICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgICAgc3RhdGljIHRlbXBsYXRlID0gYDxzZWN0aW9uIGNsYXNzPVwid3JhcHBlclwiPiR7IEJsb2NrLnRlbXBsYXRlIH08L3NlY3Rpb24+YDtcbiAgICpcbiAgICogICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICogICAgICAgc3VwZXIob3B0cyk7XG4gICAqXG4gICAqICAgICAgIHRoaXMuYWRkaXRpb25hbFZhciA9ICdhZGRpdGlvbmFsJztcbiAgICogICAgIH1cbiAgICogICB9O1xuICAgKiB9KTtcbiAgICovXG4gIHN0YXRpYyB3cmFwKC4uLndyYXBwZXJzKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJzLnJlZHVjZSh3cmFwQmxvY2ssIHRoaXMpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzOiBvcmlnaW5hbEFyZ3MsXG4gICAgICBkQmxvY2tOYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgcHJldkJsb2NrXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3Qgd2F0Y2hlcnNUb1JlbW92ZSA9IFtdO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZ2V0UHJvdG8odGhpcykuY29uc3RydWN0b3I7XG4gICAgY29uc3QgY2hpbGRyZW5CbG9ja3MgPSBbXTtcbiAgICBjb25zdCBtaXhpbnMgPSBbXTtcbiAgICBjb25zdCBpc1BhcmVudEJsb2NrID0gcGFyZW50IGluc3RhbmNlb2YgQmxvY2s7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7QmxvY2t9IEJsb2NrIyRcbiAgICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzLlxuICAgICAgICovXG4gICAgICAkOiB0aGlzLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjJCRcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gYXJncyAtIFByaXZhdGUgYXJncyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IGh0bWxDaGlsZHJlbiAtIEJsb2NrIGh0bWwgY2hpbGRyZW4uXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrW119IGNoaWxkcmVuIC0gQ2hpbGQgYmxvY2tzLlxuICAgICAgICogQHByb3BlcnR5IHtNaXhpbltdfSBtaXhpbnMgLSBDaGlsZCBtaXhpbnMuXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IHBhcmVudEVsZW0gLSBQYXJlbnQgZWxlbWVudC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gY29udGVudCAtIENvbnRlbnQgZWxlbWVudHMuXG4gICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBldmFsdWF0ZSAtIEV2YWx1YXRlIGZ1bmN0aW9uLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGdsb2JhbHMgLSBQcml2YXRlIGdsb2JhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gbG9jYWxzIC0gUHJpdmF0ZSBsb2NhbHMgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSB3YXRjaGVyc1RvUmVtb3ZlIC0gV2F0Y2hlcnMgdG8gcmVtb3ZlIGJlZm9yZSByZW1vdmluZyBlbGVtZW50LlxuICAgICAgICovXG4gICAgICAkJDoge1xuICAgICAgICBuYW1lLFxuICAgICAgICBkQmxvY2tOYW1lLFxuICAgICAgICBkQmxvY2tzOiBbXSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICBjb250ZW50OiBuZXcgRWxlbSgpLFxuICAgICAgICBuczogY29uc3RydWN0b3IsXG4gICAgICAgIGh0bWxDaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbkJsb2NrcyxcbiAgICAgICAgbWl4aW5zLFxuICAgICAgICBwcmV2QmxvY2ssXG4gICAgICAgIHdhdGNoZXJzVG9SZW1vdmUsXG4gICAgICAgIGlzUmVtb3ZlZDogZmFsc2UsXG4gICAgICAgIGlzUmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKGZ1bmMsIG9uQ2hhbmdlLCB0YXJnZXRCbG9jaywgZm9yREVsZW1lbnRzLCBmb3JESXRlbSwgZm9yREVhY2gpID0+IHtcbiAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvckRFbGVtZW50cyA9ICEhZm9yREVsZW1lbnRzO1xuICAgICAgICAgIGZvckRJdGVtID0gISFmb3JESXRlbTtcblxuICAgICAgICAgIGNvbnN0IHNjb3BlID0gKG5hbWUgPT09ICcjZC1pdGVtJyAmJiAhZm9yREl0ZW0pIHx8IGZvckRFYWNoXG4gICAgICAgICAgICA/IChmb3JERWFjaCB8fCB0aGlzKS4kJC5zY29wZVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgd2F0Y2hlcnNUb1JlbW92ZSB9ID0gdGFyZ2V0QmxvY2sgPyB0YXJnZXRCbG9jay4kJCA6IHt9O1xuICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlRmxhZyA9ICEhb25DaGFuZ2U7XG5cbiAgICAgICAgICBjb25zdCBldmFsdWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChvbkNoYW5nZUZsYWcpIHtcbiAgICAgICAgICAgICAgU2NvcGUuZXZhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBTY29wZS5nZXR0aW5nVmFycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHNjb3BlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBlcnIuZXhwcmVzc2lvbiA9IGZ1bmMuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgZXJyLm9yaWdpbmFsID0gZnVuYy5vcmlnaW5hbDtcbiAgICAgICAgICAgICAgZXJyLmJsb2NrID0gdGhpcztcblxuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb25zdHJ1Y3Rvci5vbkV2YWxFcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3Iub25FdmFsRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmNhdWdodCBlcnJvciBpbiBvbkV2YWxFcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlRmxhZykge1xuICAgICAgICAgICAgICBjb25zdCBsb2NhbFdhdGNoZXJzID0gW107XG5cbiAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KFNjb3BlLmdldHRpbmdWYXJzLCAod2F0Y2hlcnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmVzdWx0ID0gZXZhbHVhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jlc3VsdCAhPT0gcmVzdWx0ICYmICF0YXJnZXRCbG9jay4kJC5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3UmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlckJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgZm9yREVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXJzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHdhdGNoZXIub25SZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlQXJyYXkobG9jYWxXYXRjaGVycywgKHdhdGNoZXJCbG9jaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICB9ID0gd2F0Y2hlckJsb2NrO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVyc1RvUmVtb3ZlLCB3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxvY2FsV2F0Y2hlcnMucHVzaCh3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJzVG9SZW1vdmUucHVzaCh3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIFNjb3BlLmV2YWxNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgIFNjb3BlLmdldHRpbmdWYXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChpc1BhcmVudFNpZ25hbCkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuaXNSZW1vdmVkID0gdHJ1ZTtcblxuICAgICAgICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xuXG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuQmxvY2tzLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQodGhpcy4kJC5jb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheUVsZW0ocGFyZW50QmxvY2suJCQuY2hpbGRyZW4sIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY29udGVudC5yZW1vdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlQ29udGVudDogKG5ld0NvbnRlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKHRoaXMuJCQuaXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5hZnRlckRPTUNoYW5nZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlckNvbnRlbnRDaGFuZ2U6YCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZENvbnRlbnQ6IChjb250ZW50VG9BZGQsIG5vdFJlY3Vyc2l2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvbGRDb250ZW50LmluZGV4T2YoY29udGVudFRvQWRkWzBdLnByZXZpb3VzU2libGluZykgKyAxO1xuICAgICAgICAgIGxldCBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudFRvQWRkLmFkZChvbGRDb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKGNvbnRlbnRUb0FkZCwgb2xkQ29udGVudC5zbGljZShpbmRleCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudChuZXdDb250ZW50KTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmICFub3RSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVDb250ZW50OiAoY29udGVudFRvTW92ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGRDb250ZW50ID0gdGhpcy4kJC5jb250ZW50O1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gb2xkQ29udGVudC5pbmRleE9mKGNvbnRlbnRUb01vdmVbMF0pO1xuICAgICAgICAgIGNvbnN0IGluZGV4VG9QdXQgPSBvbGRDb250ZW50LmluZGV4T2YoYWZ0ZXJbMF0pICsgMTtcbiAgICAgICAgICBsZXQgbmV3Q29udGVudDtcblxuICAgICAgICAgIGlmIChpbmRleFRvUHV0ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudFRvTW92ZS5hZGQoXG4gICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiBpbmRleFRvUHV0KSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgLmFkZChcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aCwgaW5kZXhUb1B1dCksXG4gICAgICAgICAgICAgICAgY29udGVudFRvTW92ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4VG9QdXQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KG5ld0NvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb01vdmUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNvbnRlbnQ6IChjb250ZW50VG9SZW1vdmUpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQodGhpcy4kJC5jb250ZW50LmZpbHRlcigoZWxlbSkgPT4gKFxuICAgICAgICAgICAgY29udGVudFRvUmVtb3ZlLmluZGV4T2YoZWxlbSkgPT09IC0xXG4gICAgICAgICAgKSkpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KGNvbnRlbnRUb1JlbW92ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRJblN0YXJ0T2ZJdDogKGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBhZnRlckVsZW07XG5cbiAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG5cbiAgICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gcGFyZW50LiQkO1xuXG4gICAgICAgICAgICBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICAgIGxldCBub3RSZWN1cnNpdmU7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgICAgICBub3RSZWN1cnNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgbm90UmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZnRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXJJdDogKGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBhZnRlckVsZW07XG4gICAgICAgICAgbGV0IHRyeVRvQWRkT3JNb3ZlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuJCQuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy4kJC5jb250ZW50LmVsZW0oLTEpO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIHRyeVRvQWRkT3JNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiB0cnlUb0FkZE9yTW92ZSkge1xuICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNvbnN0cnVjdG9yLmRlZmF1bHRMb2NhbHMsICh2YWx1ZSwgdmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgaXRlcmF0ZUFycmF5KGNvbnN0cnVjdG9yLl92YXJzLCAodmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdGhpc1t2YXJpYWJsZV07XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcmdzT2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuICAgIGxldCBhcmdzID0gY3JlYXRlKGNvbnN0cnVjdG9yLmRlZmF1bHRBcmdzIHx8IG51bGwpO1xuICAgIGxldCB3YXNEUmVzdDtcblxuICAgIGl0ZXJhdGVPYmplY3Qob3JpZ2luYWxBcmdzLCAodmFsdWUsIGFyZykgPT4ge1xuICAgICAgY29uc3QgaXNEUmVzdCA9IERfUkVTVF9SRUdFWC50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBsb2NhbEFyZ3MgPSBpc0RSZXN0IHx8IHdhc0RSZXN0XG4gICAgICAgID8gY3JlYXRlKGFyZ3MpXG4gICAgICAgIDogYXJncztcblxuICAgICAgYXJncyA9IGxvY2FsQXJncztcblxuICAgICAgaWYgKGlzRFJlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdEFyZ3MgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZU9iamVjdChsb2NhbEFyZ3MsIGNsZWFuUHJvcGVydHkpO1xuICAgICAgICAgIGFzc2lnbihsb2NhbEFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHZhbHVlKSk7XG4gICAgICAgICAgY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgd2FzRFJlc3QgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxBcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyhyZXN0QXJncykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0RFbGVtZW50cyA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJztcbiAgICAgIGNvbnN0IGZvckRFbGVtZW50cyA9IGlzREVsZW1lbnRzICYmIGFyZyA9PT0gJ3ZhbHVlJztcblxuICAgICAgd2FzRFJlc3QgPSBmYWxzZTtcblxuICAgICAgaWYgKG5hbWUgIT09ICdkLWVhY2gnIHx8IGFyZyAhPT0gJ3VpZCcpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbG9jYWxBcmdzW2FyZ10gPSB2YWx1ZTtcbiAgICAgICAgICBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpO1xuICAgICAgICB9LCB0aGlzLCBmb3JERWxlbWVudHMsIGlzREVsZW1lbnRzICYmIHBhcmVudEJsb2NrLiQkLm5hbWUgPT09ICcjZC1pdGVtJyk7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQXJnc1thcmddID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNhcmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhcmdzOiBhcmdzT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjZ2xvYmFsc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZ2xvYmFsczogY3JlYXRlKFxuICAgICAgICBwYXJlbnRTY29wZVxuICAgICAgICAgID8gcGFyZW50U2NvcGUuZ2xvYmFsc1xuICAgICAgICAgIDogbnVsbFxuICAgICAgKVxuICAgIH0pO1xuXG4gICAgY2FsY3VsYXRlQXJncyhhcmdzLCBhcmdzT2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnRCbG9jaykge1xuICAgICAgcGFyZW50QmxvY2suJCQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlckNvbnN0cnVjdFxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgY29uc3RydWN0aW9uIChpbmNsdWRpbmcgYWxsIHNjb3BlcylcbiAgICogYnV0IGJlZm9yZSByZW5kZXJpbmcgdGhlIGJsb2NrIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICBhZnRlckNvbnN0cnVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJET01DaGFuZ2VcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIERPTSBzdHJ1Y3R1cmUgaGFzIGNoYW5nZWQuXG4gICAqL1xuICBhZnRlckRPTUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJSZW5kZXJcbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGFmdGVyIGJsb2NrIGhhcyBiZWVuIHJlbmRlcmVkLlxuICAgKi9cbiAgYWZ0ZXJSZW5kZXIoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2JlZm9yZVJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYmVmb3JlIHRoZSBibG9jayByZW1vdmFsLlxuICAgKi9cbiAgYmVmb3JlUmVtb3ZlKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRDaGlsZEJsb2Nrc1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBjaGlsZCBibG9ja3MuXG4gICAqL1xuICBnZXRDaGlsZEJsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ibG9ja3Muc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldENoaWxkQmxvY2tzXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge01peGluW119XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGNoaWxkIG1peGlucy5cbiAgICovXG4gIGdldENoaWxkTWl4aW5zKCkge1xuICAgIHJldHVybiB0aGlzLiQkLm1peGlucy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0Q2hpbGRyZW5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIEJsb2NrIEhUTUwgY2hpbGRyZW4uXG4gICAqL1xuICBnZXRDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5odG1sQ2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRET01cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgRE9NIGNvbnRlbnRzIG9mIHRoZSBibG9jay5cbiAgICovXG4gIGdldERPTSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5jb250ZW50LnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRCbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBwYXJlbnQgYmxvY2suXG4gICAqL1xuICBnZXRQYXJlbnRCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRCbG9jaztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldFBhcmVudEVsZW1cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbXx2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBwYXJlbnQgRWxlbS5cbiAgICovXG4gIGdldFBhcmVudEVsZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50RWxlbS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50U2NvcGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QmxvY2t8dm9pZH1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgcGFyZW50IHNjb3BlLlxuICAgKi9cbiAgZ2V0UGFyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50U2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRQYXJlbnRUZW1wbGF0ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBwYXJlbnQgdGVtcGxhdGUuXG4gICAqL1xuICBnZXRQYXJlbnRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IFtjYWxsYmFja10gLSBJZiBwcmVzZW50LCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge0Jsb2NrfE1peGlufSBbdGFyZ2V0ID0gdGhpc10gLSBXaGF0IGJsb2NrIG9yIG1peGluIHJlcXVlc3RzIHRoZSB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IEV2YWx1YXRpb24gcmVzdWx0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gaW4gY29udGV4dCBvZiB0aGUgYmxvY2sgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGZ1bmMsIGNhbGxiYWNrLCB0YXJnZXQgPSB0aGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayN3YXRjaFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uKCdhcmdzJ3wnZ2xvYmFscyd8U3RyaW5nKX0gW3ZhcnNdIC0gVmFycyB0byB3YXRjaCAoYXJncywgZ2xvYmFscyBvciBsb2NhbHMpLlxuICAgKiBJZiBubyBzcGVjaWZpZWQgYWxsIGxvY2FscywgYXJncyBhbmQgZ2xvYmFscyBhcmUgdG8gYmUgd2F0Y2hlZC5cbiAgICogSWYgdGhlICdhcmdzJyBzdHJpbmcgYWxsIGFyZ3MgYXJlIHRvIGJlIHdhdGNoZWQuXG4gICAqIElmIHRoZSAnZ2xvYmFscycgc3RyaW5nIGFsbCBnbG9iYWxzIGFyZSB0byBiZSB3YXRjaGVkLlxuICAgKiBAcGFyYW0ge1ZhcnNXYXRjaGVyfSB3YXRjaGVyIC0gQ2FsbGVkIHdoZW4gd2F0Y2hlZCB2YXJzIGFyZSBjaGFuZ2VkLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3YXRjaGluZyBmb3IgdmFycy4gSWYgbm8gdmFycyBwYXNzZWQgaW4gYXJndW1lbnRzXG4gICAqIGFsbCB2YXJzIGFyZSB0byBiZSB3YXRjaGVkLiBJZiB0aGUgJ2FyZ3MnIHN0cmluZyBpcyBpbiB0aGUgYXJndW1lbnRzIGFsbCBhcmdzIGFyZSB0byBiZSB3YXRjaGVkLlxuICAgKiBJZiB0aGUgJ2dsb2JhbHMnIHN0cmluZyBpcyBpbiB0aGUgYXJndW1lbnRzIGFsbCBnbG9iYWxzIGFyZSB0byBiZSB3YXRjaGVkLlxuICAgKiBPdGhlcndpc2Ugc3BlY2lmaWVkIHZhcnMgd2lsbCBiZSB3YXRjaGVkLlxuICAgKiBXYXRjaGVycyBzaG91bGQgbm90IGJlIHB1dCBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yLiBJdCBpcyBjb25zaWRlcmVkIGJlc3RcbiAgICogcHJhY3RpY2UgdG8gZG8gaXQgaW5zaWRlIHRoZSB7QGxpbmsgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3R9IG1ldGhvZC5cbiAgICogTm90ZSB0aGF0IHRoZXNlIGV4cHJlc3Npb25zICh2YXJzLCBpLmUuIFwiYXJncy5hcmdcIikgYXJlIG5vdCB0byBiZVxuICAgKiBldmFsdWF0ZWQgc28geW91IGNhbm5vdCBwdXQgdGhlcmUgdGhpbmdzIGxpa2UgXCJhW2JdXCIgb3IgYW55IGpzIGNvZGUsXG4gICAqIG9ubHkgZXhwcmVzc2lvbnMgbGlrZSBcImFcIiwgXCJiXCIsIFwiYXJncy5hXCIsIFwiYXJncy5iXCIgYW5kIFwiZ2xvYmFscy5hXCIsIFwiZ2xvYmFscy5iXCIuXG4gICAqIEFsc28gbm90ZSB0aGF0IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHZhciB0aGF0IGFyZSBjaGFuZ2VkIGF0IG9uY2UgKHN5bmNocm9ub3VzbHkpXG4gICAqIHRoZSB3YXRjaGVyIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gICAqIE5vdGUgdGhhdCB0aGUgd2F0Y2hlciBpcyBleGVjdXRlZCByaWdodCBhd2F5IGJlY2F1c2UgaW4gbW9zdCBjYXNlc1xuICAgKiB0aGlzIGJlaGF2aW91ciBpcyB2ZXJ5IGNvbnZlbmllbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXYgLz4nO1xuICAgKlxuICAgKiAgIGFmdGVyQ29uc3RydWN0KCkge1xuICAgKiAgICAgdGhpcy53YXRjaCgnYScsICgpID0+IHt9KTtcbiAgICogICAgIHRoaXMud2F0Y2goJ2FyZ3MuYScsICdnbG9iYWxzLnInLCAoKSA9PiB7fSk7XG4gICAqICAgICB0aGlzLndhdGNoKCgpID0+IHt9KTtcbiAgICogICB9XG4gICAqIH1cbiAgICovXG4gIHdhdGNoKC4uLnZhcnMpIHtcbiAgICBjb25zdCBvbGRXYXRjaGVyID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblxuICAgIGlmICghaXNGdW5jdGlvbihvbGRXYXRjaGVyKSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbGFzdCBhcmd1bWVudCAod2F0Y2hlcikgd2Fzbid0IHNwZWNpZmllZCAoJHsgdGhpcy4kJC5uYW1lIH0jd2F0Y2gpYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3YXRjaGVyID0gKCkgPT4ge1xuICAgICAgb2xkV2F0Y2hlcigpO1xuICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2F0Y2hGb3JBbGxMb2NhbHModGhpcywgd2F0Y2hlcik7XG4gICAgICB3YXRjaEZvckFsbEFyZ3ModGhpcywgd2F0Y2hlcik7XG4gICAgICB3YXRjaEZvckFsbEdsb2JhbHModGhpcywgd2F0Y2hlcik7XG5cbiAgICAgIG9sZFdhdGNoZXIoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsICh2YXJpYWJsZSkgPT4ge1xuICAgICAgaWYgKHZhcmlhYmxlID09PSBvbGRXYXRjaGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyaWFibGUgPSBgJHsgdmFyaWFibGUgfWA7XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gJyQnKSB7XG4gICAgICAgIHJldHVybiB3YXRjaEZvckFsbExvY2Fscyh0aGlzLCB3YXRjaGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcmlhYmxlID09PSAnYXJncycpIHtcbiAgICAgICAgcmV0dXJuIHdhdGNoRm9yQWxsQXJncyh0aGlzLCB3YXRjaGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcmlhYmxlID09PSAnZ2xvYmFscycpIHtcbiAgICAgICAgcmV0dXJuIHdhdGNoRm9yQWxsR2xvYmFscyh0aGlzLCB3YXRjaGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFdBVENIRURfQVJHX1BSRUZJWF9SRUdFWC50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnJlcGxhY2UoV0FUQ0hFRF9BUkdfUFJFRklYX1JFR0VYLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLiQkLmFyZ3NbdmFyaWFibGVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kJC5hcmdzW3ZhcmlhYmxlXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoV0FUQ0hFRF9HTE9CQUxfUFJFRklYX1JFR0VYLnRlc3QodmFyaWFibGUpKSB7XG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUucmVwbGFjZShXQVRDSEVEX0dMT0JBTF9QUkVGSVhfUkVHRVgsICcnKTtcblxuICAgICAgICBpZiAoIXRoaXMuJCQuZ2xvYmFsc1t2YXJpYWJsZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHdhdGNoZXJzIH0gPSB0aGlzLiQkLmdsb2JhbHNbdmFyaWFibGVdO1xuXG4gICAgICAgIHdhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgdGhpcy4kJC53YXRjaGVyc1RvUmVtb3ZlLnB1c2goe1xuICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuJCQubG9jYWxzW3ZhcmlhYmxlXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJCQubG9jYWxzW3ZhcmlhYmxlXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XG4gICAgfSk7XG5cbiAgICBvbGRXYXRjaGVyKCk7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoQmxvY2ssICdCbG9jaycpO1xuc2V0UHJvdG8oQmxvY2sucHJvdG90eXBlLCBudWxsKTtcblxuZXhwb3J0IHsgQmxvY2sgfTtcbiIsImltcG9ydCB7IGZpbmRJbkFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdEJsb2Nrc1snZC1ibG9jayddID0gY2xhc3MgREJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7UGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwie1BhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcblxuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY29wZToge1xuICAgICAgICAkJDoge1xuICAgICAgICAgIHBhcmVudFNjb3BlOiBwYXJlbnRQYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZTogcGFyZW50UGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgaHRtbENoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaHRtbENoaWxkcmVuOiBvd25DaGlsZHJlbixcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZEJsb2NrTmFtZVxuICAgIH0gPSB0aGlzLiQkO1xuICAgIGxldCBmb3VuZDtcblxuICAgIGlmIChvd25DaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50UGFyZW50U2NvcGU7XG4gICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFBhcmVudFRlbXBsYXRlO1xuXG4gICAgaWYgKGRCbG9ja05hbWUpIHtcbiAgICAgIGZvdW5kID0gZmluZEluQXJyYXkoY2hpbGRyZW4sICh7IG5hbWU6IG5vZGVOYW1lIH0pID0+IG5vZGVOYW1lID09PSBgZC1ibG9jazokeyBkQmxvY2tOYW1lIH1gKTtcblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcblxuICAgICAgICAvKiBlc2xpbnQgbm8tZW1wdHk6IDAgKi9cbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAocGFyZW50ID0gcGFyZW50LiQkLnBhcmVudFNjb3BlKVxuICAgICAgICAmJiAhKGZvdW5kID0gZmluZEluQXJyYXkocGFyZW50LiQkLmRCbG9ja3MsICh7ICQkOiB7IGRCbG9ja05hbWU6IERCbG9ja05hbWUgfSB9KSA9PiBEQmxvY2tOYW1lID09PSBkQmxvY2tOYW1lKSlcbiAgICAgICAgJiYgcGFyZW50LiQkLnBhcmVudFNjb3BlLiQkLm5hbWUgPT09ICcjZC1pdGVtJ1xuICAgICAgICAgICkge31cblxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50O1xuICAgICAgICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgICAgICBmb3VuZC52YWx1ZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBmb3VuZC52YWx1ZS4kJC5odG1sQ2hpbGRyZW5cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZCAmJiBmb3VuZC52YWx1ZS5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgPyBmb3VuZC52YWx1ZS5jaGlsZHJlblxuICAgICAgICA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcblxuY29uc3QgdGVtcGxhdGUgPSBodG1sYFxuICA8ZC1lbGVtZW50c1xuICAgIHZhbHVlPVwieyQkLmh0bWxDaGlsZHJlbn1cIlxuICAgIHBhcmVudFNjb3BlPVwie3RoaXN9XCJcbiAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAvPlxuYDtcblxuY2xhc3MgREl0ZW0gZXh0ZW5kcyBCbG9jayB7XG4gIHN0YXRpYyB0ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBzdGF0aWMgX3ZhcnMgPSB0ZW1wbGF0ZS52YXJzO1xuICBzdGF0aWMgX2h0bWwgPSB0ZW1wbGF0ZS52YWx1ZTtcbn1cblxuZXhwb3J0IHsgREl0ZW0gfTtcbiIsImltcG9ydCB7XG4gIGFzc2lnbiwgaXRlcmF0ZUFycmF5LCBpdGVyYXRlT2JqZWN0LFxuICBpc0FycmF5LCBpc0Z1bmN0aW9uXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW92ZSwgY3JlYXRlQmxvY2sgfSBmcm9tICcuLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBESXRlbSB9IGZyb20gJy4vZC1pdGVtJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgW1xuICBhcmdzLnNldCxcbiAgYXJncy5maWx0ZXJCeSxcbiAgYXJncy5zb3J0Qnlcbl1gO1xuXG5yb290QmxvY2tzWydkLWVhY2gnXSA9IGNsYXNzIERFYWNoIGV4dGVuZHMgQmxvY2sge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzOiB7XG4gICAgICAgIGl0ZW06IGl0ZW1OYW1lID0gJyRpdGVtJyxcbiAgICAgICAgaW5kZXg6IGluZGV4TmFtZSA9ICckaW5kZXgnXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG5cbiAgICBhc3NpZ24odGhpcy4kJCwge1xuICAgICAgaXRlbXNCeVVJRHM6IHt9LFxuICAgICAgVUlEOiB0aGlzLmFyZ3MudWlkIHx8IHVuZGVmaW5lZCxcbiAgICAgIGl0ZW1OYW1lLFxuICAgICAgaW5kZXhOYW1lXG4gICAgfSk7XG4gIH1cblxuICBhZnRlclJlbmRlcigpIHtcbiAgICB0aGlzLmV2YWx1YXRlKHdhdGNoQXJncywgdGhpcy5yZW5kZXJTZXQpO1xuICAgIHRoaXMucmVuZGVyU2V0KCk7XG4gIH1cblxuICByZW5kZXJTZXQgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgaXRlbXNCeVVJRHMsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudEVsZW0sXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHNjb3BlLFxuICAgICAgaXRlbU5hbWUsXG4gICAgICBpbmRleE5hbWUsXG4gICAgICBVSURcbiAgICB9ID0gdGhpcy4kJDtcbiAgICBjb25zdCB7XG4gICAgICBhcmdzOiB7IHNvcnRCeSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3SXRlbXNCeVVJRHMgPSB7fTtcbiAgICBjb25zdCBuZXdVSURzQ291bnRlciA9IHt9O1xuICAgIGNvbnN0IG5ld1VJRHMgPSB7fTtcbiAgICBsZXQge1xuICAgICAgc2V0LFxuICAgICAgZmlsdGVyQnlcbiAgICB9ID0gdGhpcy5hcmdzO1xuICAgIGNvbnN0IGlzQXJyID0gaXNBcnJheShzZXQpO1xuICAgIGNvbnN0IGl0ZXJhdGUgPSBpc0FyclxuICAgICAgPyBpdGVyYXRlQXJyYXlcbiAgICAgIDogaXRlcmF0ZU9iamVjdDtcblxuICAgIGlmIChpc0FyciAmJiBpc0Z1bmN0aW9uKHNvcnRCeSkpIHtcbiAgICAgIHNldCA9IHNldFxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydChzb3J0QnkpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGZpbHRlckJ5KSkge1xuICAgICAgZmlsdGVyQnkgPSBbZmlsdGVyQnldO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGZpbHRlckJ5KSkge1xuICAgICAgaXRlcmF0ZUFycmF5KGZpbHRlckJ5LCAoZmlsdGVyKSA9PiB7XG4gICAgICAgIHNldCA9IHNldC5maWx0ZXIoZmlsdGVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGl0ZXJhdGUoc2V0LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIHNjb3BlW2l0ZW1OYW1lXSA9IGl0ZW07XG4gICAgICBzY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG5cbiAgICAgIGNvbnN0IHVpZCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKFVJRCwgbnVsbCwgbnVsbCwgZmFsc2UsIGZhbHNlLCB0aGlzKTtcblxuICAgICAgbmV3VUlEc0NvdW50ZXJbdWlkXSA9IChuZXdVSURzQ291bnRlclt1aWRdIHx8IDApICsgMTtcbiAgICAgIG5ld1VJRHNbaW5kZXhdID0gdWlkO1xuICAgIH0pO1xuXG4gICAgc2NvcGVbaXRlbU5hbWVdID0gbnVsbDtcbiAgICBzY29wZVtpbmRleE5hbWVdID0gbnVsbDtcblxuICAgIGl0ZXJhdGVPYmplY3QoaXRlbXNCeVVJRHMsIChpdGVtcywgdWlkKSA9PiB7XG4gICAgICBpZiAoIW5ld1VJRHNDb3VudGVyW3VpZF0pIHtcbiAgICAgICAgaXRlcmF0ZUFycmF5KGl0ZW1zLCByZW1vdmUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGl0ZW1zLnNwbGljZShuZXdVSURzQ291bnRlclt1aWRdKSwgcmVtb3ZlKTtcbiAgICB9KTtcblxuICAgIGxldCBwcmV2QmxvY2s7XG5cbiAgICBpdGVyYXRlKHNldCwgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB1aWQgPSBuZXdVSURzW2luZGV4XTtcbiAgICAgIGxldCBibG9jaztcblxuICAgICAgaWYgKGl0ZW1zQnlVSURzW3VpZF0gJiYgaXRlbXNCeVVJRHNbdWlkXS5sZW5ndGgpIHtcbiAgICAgICAgYmxvY2sgPSBpdGVtc0J5VUlEc1t1aWRdLnNoaWZ0KCk7XG4gICAgICAgIGJsb2NrLiQkLnNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcbiAgICAgICAgYmxvY2suJCQuc2NvcGVbaXRlbU5hbWVdID0gaXRlbTtcblxuICAgICAgICBpZiAoYmxvY2suJCQucHJldkJsb2NrICE9PSBwcmV2QmxvY2sgJiYgcHJldkJsb2NrKSB7XG4gICAgICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoYmxvY2suJCQuY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIGl0ZW1OYW1lLFxuICAgICAgICAgICAgaW5kZXhOYW1lLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgbmFtZTogJyNkLWl0ZW0nLFxuICAgICAgICAgICAgY2hpbGRyZW46IGh0bWxDaGlsZHJlblxuICAgICAgICAgIH0sXG4gICAgICAgICAgQ29uc3RydWN0b3I6IERJdGVtLFxuICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgKG5ld0l0ZW1zQnlVSURzW3VpZF0gPSBuZXdJdGVtc0J5VUlEc1t1aWRdIHx8IFtdKS5wdXNoKGJsb2NrKTtcbiAgICAgIGJsb2NrLiQkLnByZXZCbG9jayA9IHByZXZCbG9jaztcbiAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kJC5pdGVtc0J5VUlEcyA9IG5ld0l0ZW1zQnlVSURzO1xuICB9O1xufTtcbiIsImltcG9ydCB7IGl0ZXJhdGVBcnJheSwgcmVtb3ZlQXJyYXlFbGVtIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCwgY3JlYXRlQmxvY2sgfSBmcm9tICcuLi9oZWxwZXJzL0Jsb2NrJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uL0VsZW0nO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYGFyZ3MudmFsdWVgO1xuXG5yb290QmxvY2tzWydkLWVsZW1lbnRzJ10gPSBjbGFzcyBERWxlbWVudHMgZXh0ZW5kcyBCbG9jayB7XG4gIGFmdGVyQ29uc3RydWN0KCkge1xuICAgIGNvbnN0IHsgcGFyZW50RWxlbSB9ID0gdGhpcy4kJDtcbiAgICBjb25zdCB7XG4gICAgICBDb25zdHJ1Y3RvcixcbiAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgcGFyZW50VGVtcGxhdGVcbiAgICB9ID0gdGhpcy5hcmdzO1xuXG4gICAgdGhpcy4kJC5ldmFsdWF0ZSh3YXRjaEFyZ3MsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBjb250ZW50XG4gICAgICB9ID0gdGhpcy4kJDtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuYXJncztcblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGl0ZXJhdGVBcnJheShtaXhpbnMsIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwpO1xuICAgICAgY29udGVudC5yZW1vdmUoKTtcblxuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiQkLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLiQkLm1peGlucyA9IFtdO1xuICAgICAgdGhpcy4kJC53YXRjaGVyc1RvUmVtb3ZlID0gd2F0Y2hlcnNUb1JlbW92ZS5maWx0ZXIoKHsgd2F0Y2hlcnMsIHdhdGNoZXIsIGZvckRFbGVtZW50cyB9KSA9PiB7XG4gICAgICAgIGlmIChmb3JERWxlbWVudHMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUFycmF5RWxlbSh3YXRjaGVycywgd2F0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJCQuY29udGVudCA9IG5ldyBFbGVtKCk7XG5cbiAgICAgIGxldCBwcmV2QmxvY2s7XG5cbiAgICAgIGl0ZXJhdGVBcnJheSh2YWx1ZSB8fCBbXSwgKGNoaWxkKSA9PiB7XG4gICAgICAgIHByZXZCbG9jayA9IGNyZWF0ZUJsb2NrKHtcbiAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICBDb25zdHJ1Y3RvcixcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLCB0cnVlKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGZpbmRJbkFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdEJsb2Nrc1snZC1pZiddID0gY2xhc3MgRElmIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7JCQucGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIGh0bWxDaGlsZHJlblxuICAgIH0gPSB0aGlzLiQkO1xuICAgIGxldCBpbmRleCA9IEluZmluaXR5O1xuICAgIGNvbnN0IHZhbHVlcyA9IGh0bWxDaGlsZHJlbi5tYXAoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGF0dHJzID0ge30sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBsZXQgY29uZCA9IGF0dHJzLmlmO1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtZWxzZScgJiYgY29uZCkge1xuICAgICAgICBjb25kID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoY29uZCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKCEhbmV3VmFsdWUgPT09IHZhbHVlc1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlc1tpXSA9ICEhbmV3VmFsdWU7XG5cbiAgICAgICAgICBpZiAoaSA+IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPCBpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZm91bmQgPSBmaW5kSW5BcnJheSh2YWx1ZXMsIEJvb2xlYW4pO1xuXG4gICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvdW5kLmtleTtcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBodG1sQ2hpbGRyZW5bZm91bmQua2V5XS5jaGlsZHJlbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25kID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmQgJiYgaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gISFjb25kO1xuICAgIH0pO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgY29sbGVjdEZyb21PYmplY3QsIGl0ZXJhdGVPYmplY3QsIGtleXMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLWF0dHInXSA9IGNsYXNzIERBdHRyIGV4dGVuZHMgTWl4aW4ge1xuICBhdHRycyA9IHt9O1xuXG4gIGFmdGVyVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBhdHRyc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21PYmplY3QoYXJncywgKGF0dHJzLCBhdHRyKSA9PiB7XG4gICAgICAgIGF0dHJzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpdGVyYXRlT2JqZWN0KGF0dHJzLCAodmFsdWUsIHByb3ApID0+IHtcbiAgICAgIGlmICghKHByb3AgaW4gbmV3VmFsdWUpKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihwcm9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtLmF0dHIobmV3VmFsdWUpO1xuXG4gICAgdGhpcy5hdHRycyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBhdHRyc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgZWxlbS5yZW1vdmVBdHRyLmFwcGx5KGVsZW0sIGtleXMoYXR0cnMpKTtcbiAgfVxufTtcblxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2QtYmluZCddID0gY2xhc3MgREJpbmQgZXh0ZW5kcyBNaXhpbiB7XG4gIGFmdGVyVXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub2ZmKSB7XG4gICAgICB0aGlzLm9mZigpO1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLm9mZiA9IHRoaXMuZWxlbS5vbih0aGlzLmFyZ3Muam9pbignLCcpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3ZpZGUgXCJkLWJpbmRcIiBtaXhpbiB3aXRoIGFuIGV2ZW50IG5hbWVzIChsaWtlIFwiZC1iaW5kKGNsaWNrKVwiIG9yIFwiZC1iaW5kKGtleXVwLCBrZXlwcmVzcylcIikhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHsgb2ZmIH0gPSB0aGlzO1xuXG4gICAgaWYgKG9mZikge1xuICAgICAgb2ZmKCk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSwgaXNTdHJpbmcsXG4gIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCBFTVBUWV9TUEFDRV9SRUdFWCA9IC9cXHMrLztcblxucm9vdE1peGluc1snZC1jbGFzcyddID0gY2xhc3MgRENsYXNzIGV4dGVuZHMgTWl4aW4ge1xuICBjbGFzc2VzID0gW107XG5cbiAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNsYXNzZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdDbGFzc2VzID0gW107XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgICA/IGFyZ3NcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcobmV3VmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNwbGl0KEVNUFRZX1NQQUNFX1JFR0VYKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKGNscykgPT09IC0xKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVBcnJheShuZXdWYWx1ZSwgKGNscykgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcoY2xzKSkge1xuICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVBcnJheShjbGFzc2VzLCAoY2xzKSA9PiB7XG4gICAgICAgIGlmICghbmV3VmFsdWUgfHwgIW5ld1ZhbHVlW2Nsc10pIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZU9iamVjdChuZXdWYWx1ZSwgKHZhbCwgY2xzKSA9PiB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NlcyA9IG5ld0NsYXNzZXM7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGNsYXNzZXNcbiAgICB9ID0gdGhpcztcblxuICAgIGVsZW0ucmVtb3ZlQ2xhc3MuYXBwbHkoZWxlbSwgY2xhc3Nlcyk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1lbGVtJ10gPSBjbGFzcyBERWxlbSBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJncyxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZWxlbVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBzY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGUoKTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUoZWxlbSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHNjb3BlW3ZhbHVlXSA9IGVsZW07XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1oaWRlJ10gPSBjbGFzcyBESGlkZSBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5lbGVtLnNob3coKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLW5vZGUnXSA9IGNsYXNzIEROb2RlIGV4dGVuZHMgTWl4aW4ge1xuICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBub2RlXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHNjb3BlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogcGFyZW50VGVtcGxhdGU7XG4gICAgICB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgc2NvcGVbdmFsdWVdID0gbm9kZTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLW9uJ10gPSBjbGFzcyBET24gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIHRoaXMub2ZmID0gdGhpcy5lbGVtLm9uKHRoaXMuYXJncy5qb2luKCcsJyksICgpID0+IHtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3ZpZGUgXCJkLW9uXCIgbWl4aW4gd2l0aCBhbiBldmVudCBuYW1lcyAobGlrZSBcImQtb24oY2xpY2spXCIgb3IgXCJkLW9uKGtleXVwLCBrZXlwcmVzcylcIikhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHsgb2ZmIH0gPSB0aGlzO1xuXG4gICAgaWYgKG9mZikge1xuICAgICAgb2ZmKCk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1zaG93J10gPSBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5lbGVtLnNob3coKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyByb290QmxvY2tzLCByb290TWl4aW5zIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbnN0cnVjdE1peGluUmVnZXggfSBmcm9tICcuL2NvbnN0cnVjdE1peGluUmVnZXgnO1xuXG5pdGVyYXRlT2JqZWN0KHJvb3RCbG9ja3MsIChCbG9jaykgPT4ge1xuICBCbG9jay5fdmFycyA9IEJsb2NrLnRlbXBsYXRlLnZhcnM7XG4gIEJsb2NrLl9odG1sID0gQmxvY2sudGVtcGxhdGUudmFsdWU7XG59KTtcblxuaXRlcmF0ZU9iamVjdChyb290TWl4aW5zLCAoTWl4aW4sIG5hbWUpID0+IHtcbiAgTWl4aW4uX21hdGNoID0gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKTtcbn0pO1xuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQgeyBjcmVhdGVIaWRlU3R5bGVOb2RlIH0gZnJvbSAnLi9oZWxwZXJzL0VsZW0nO1xuXG5jb25zdCB7XG4gIGRvY3VtZW50ID0ge31cbn0gPSBnbG9iYWw7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBkb2NcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBkb2MgPSBuZXcgRWxlbShkb2N1bWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBodG1sXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWwgPSBuZXcgRWxlbShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gYm9keVxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5ib2R5LlxuICovXG5leHBvcnQgY29uc3QgYm9keSA9IG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpO1xuXG4vKipcbiAqIEBjb25zdCB7RWxlbX0gaGVhZFxuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5oZWFkLlxuICovXG5leHBvcnQgY29uc3QgaGVhZCA9IG5ldyBFbGVtKGRvY3VtZW50LmhlYWQpO1xuXG5jcmVhdGVIaWRlU3R5bGVOb2RlKGhlYWQpO1xuIl0sIm5hbWVzIjpbImNvbGxlY3RGcm9tQXJyYXkiLCJhcnJheSIsImNhbGxiYWNrIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJpbmRleCIsImZpbmRJbkFycmF5IiwiaSIsImxlbmd0aCIsIml0ZXJhdGVBcnJheSIsInJlbW92ZUFycmF5RWxlbSIsImVsZW0iLCJpbmRleE9mIiwic3BsaWNlIiwidG9PYmplY3RLZXlzIiwiYWRkS2V5IiwidmFycyIsInZhcmlhYmxlIiwiYXNzaWduIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwic291cmNlIiwia2V5IiwiY29sbGVjdEZyb21PYmplY3QiLCJvYmplY3QiLCJleGNlcHQiLCJuZXdPYmplY3QiLCJwYXRocyIsInNsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJoYXMiLCJpdGVyYXRlT2JqZWN0IiwibWFwT2JqZWN0IiwiZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJuYW1lIiwiZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsInNldFRvU3RyaW5nVGFnIiwidGFnIiwiU3ltYm9sIiwicHJvdG90eXBlIiwiaXNGdW5jdGlvbiIsImlzTmlsIiwiaXNTdHJpbmciLCJlc2NhcGVSZWdleCIsInN0cmluZyIsInJlcGxhY2UiLCJyZWdleHBTcGVjaWFsc1JlZ2V4cCIsInRvQ2FtZWxDYXNlIiwiREFTSEVEX1NZTUJPTF9SRUdFWCIsImNhcGl0YWxpemUiLCJ0b0h5cGhlbkNhc2UiLCJVUFBFUkNBU0VEX1NZTUJPTF9SRUdFWCIsImh5cGhlbml6ZSIsIm1hdGNoIiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImFkZEF0dHIiLCJhdHRycyIsImF0dHIiLCJhZGRDU1NQcm9wIiwiY3NzIiwicHJvcGVydHkiLCJzcGxpdCIsIkNTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCIsImFkZERhdGFBdHRyIiwiZGF0YSIsImFkZE5leHQiLCJhZGQiLCJuZXh0U2libGluZyIsImFkZFBhcmVudCIsInBhcmVudE5vZGUiLCJhZGRQcmV2IiwicHJldmlvdXNTaWJsaW5nIiwiY3JlYXRlSGlkZVN0eWxlTm9kZSIsImhlYWQiLCJmaW5kIiwiSElERV9DTEFTUyIsImNyZWF0ZSIsInByb3AiLCJ0ZXh0IiwiZ2V0QXR0ck5TIiwibm9kZU5hbWUiLCJYTUxfTlMiLCJYX0xJTktfQVRUUl9SRUdFWCIsInRlc3QiLCJFbGVtIiwiY2xvc2VzdCIsIlhfTElOS19OUyIsImhpZGUiLCJvd25lckRvY3VtZW50IiwiYWRkQ2xhc3MiLCJpc0VsZW0iLCJpc0VsZW1lbnRzQ29sbGVjdGlvbiIsIkhUTUxfQ09MTEVDVElPTl9SRUdFWCIsImlzQXJyYXkiLCJpc0hUTUxEb2N1bWVudCIsImlzVmFsaWROb2RlIiwiRUxFTUVOVF9SRUdFWCIsInJlbW92ZSIsInBhcmVudCIsInJlbW92ZUNoaWxkIiwic2hvdyIsInJlbW92ZUNsYXNzIiwidG9FbGVtIiwic2VsZWN0b3IiLCJiYXNlIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiU3RyaW5nIiwiY2FsY3VsYXRlQXJncyIsImFyZ3MiLCJhcmdzT2JqZWN0Iiwia2V5cyIsImFyZyIsInVuZGVmaW5lZCIsImNsZWFuUHJvcGVydHkiLCJjb25zdHJ1Y3RNaXhpblJlZ2V4IiwiUmVnRXhwIiwibWl4aW5NYXRjaCIsIm1peGlucyIsIk1peGluIiwibG9jYWxNYXRjaCIsIl9tYXRjaCIsImFyZ3NNYXRjaCIsIkNPTU1BX1JFR0VYIiwidHJhbnNmb3JtUmVzdEF0dHJzIiwibWl4aW5EZWZhdWx0T3B0cyIsImV2ZW50dWFsQXR0cnMiLCJEX1JFU1RfUkVHRVgiLCJ0cmFuc2Zvcm1SZXN0QXJncyIsImFkZEFyZ3MiLCJleGVjdXRlTWl4aW5XYXRjaGVycyIsIm1peGluIiwib2xkVmFsdWUiLCIkJCIsIndhdGNoZXJzIiwid2F0Y2hlciIsImNyZWF0ZU1peGluIiwiZHluYW1pYyIsImNvbW1lbnQiLCJwYXJlbnRCbG9jayIsInBhcmVudFNjb3BlIiwicGFyZW50VGVtcGxhdGUiLCJldmFsdWF0ZSIsIm5ld1ZhbHVlIiwiYWZ0ZXJVcGRhdGUiLCJlcnIiLCJlcnJvciIsImNhbGN1bGF0ZUF0dHJzIiwiYXR0cnNPYmplY3QiLCJmaXJzdFRpbWUiLCJ0eXBlIiwicmVtb3ZlQXR0ciIsIm9wdHMiLCJuZXh0VHlwZSIsIm5leHREeW5hbWljIiwibmV4dFZhbHVlIiwicHJldlR5cGUiLCJwcmV2VmFsdWUiLCJpc0R5bmFtaWMiLCJldmFsdWF0ZWQiLCJidWlsZE1peGluIiwiZmlyc3RWYWx1ZSIsInB1c2giLCJjb25zdHJ1Y3RQcml2YXRlU2NvcGUiLCJzY29wZSIsImdsb2JhbHMiLCJyZW1vdmVUZW1wV2F0Y2hlciIsIm9uUmVtb3ZlIiwicmVtb3ZlV2F0Y2hlcnMiLCJ3YXRjaGVyc1RvUmVtb3ZlIiwicmVtb3ZlV2F0Y2hlciIsImNvbnN0cnVjdFB1YmxpY1Njb3BlIiwic2NvcGVWYWx1ZXMiLCJwcml2YXRlU2NvcGUiLCJTY29wZSIsImV2YWxNb2RlIiwiZ2V0dGluZ1ZhcnMiLCJ0ZW1wIiwiY2hhbmdlZCIsIm9sZFRlbXBXYXRjaGVycyIsIndhcyIsInZhbHVlcyIsInBlcm0iLCJjcmVhdGVCbG9jayIsIm5vZGUiLCJDb25zdHJ1Y3RvciIsInBhcmVudEVsZW0iLCJwcmV2QmxvY2siLCJkb2MiLCJuYW1lc3BhY2VVUkkiLCJTVkdfTlMiLCJsb2NhbEJsb2NrcyIsIm5zIiwiX2Jsb2NrcyIsIkJsb2NrIiwibG9jYWxNaXhpbnMiLCJfbWl4aW5zIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsImRCbG9ja01hdGNoIiwiZEJsb2NrTmFtZSIsImRCbG9ja0FyZ3MiLCJkQmxvY2tDaGlsZHJlbiIsImRFbGVtZW50c05hbWUiLCJkRWxlbWVudHNDb25zdHJ1Y3RvciIsIk5BTUVEX0RfQkxPQ0tfUkVHRVgiLCJibG9ja0luc3RhbmNlIiwiZWxlbWVudCIsImN1cnJlbnRBdHRycyIsIndhc0RSZXN0IiwiaXNEUmVzdCIsImxvY2FsQXR0cnMiLCJyZXN0QXR0cnMiLCJjcmVhdGVNaXhpbnMiLCJjb250ZW50IiwiY2hpbGQiLCJpc1BhcmVudEJsb2NrIiwiaW5zZXJ0QWZ0ZXJJdCIsImluc2VydEFmdGVyIiwiYWRkQ29udGVudCIsImluc2VydEluU3RhcnRPZkl0IiwiaW50byIsIkFyZ3MiLCJsb2NhbHMiLCJuZXdOYW1lIiwibmV3Q29uc3RydWN0b3IiLCJodG1sIiwiX2h0bWwiLCJpdGVtTmFtZSIsIml0ZW0iLCJpbmRleE5hbWUiLCJhZnRlckNvbnN0cnVjdCIsImlzUmVuZGVyZWQiLCJhZnRlclJlbmRlciIsImV4dGVuZEJsb2NrIiwiY2xzIiwiaXNJbnN0YW5jZU9mIiwiQ2xhc3MiLCJTdWJjbGFzcyIsImlzUHJvdG90eXBlT2YiLCJyZW1vdmVXaXRoUGFyZW50U2lnbmFsIiwid2F0Y2hGb3JBbGxMb2NhbHMiLCJibG9jayIsIndhdGNoRm9yQWxsR2xvYmFscyIsImdsb2IiLCJ3YXRjaEZvckFsbEFyZ3MiLCJ3cmFwQmxvY2siLCJ3cmFwcGVyIiwicmV0dXJuVmFsdWUiLCJ3cmFwTWl4aW4iLCJpbml0QXBwIiwiY29udGFpbmVyIiwiRXJyb3IiLCJSb290QmxvY2siLCJfdmFycyIsImVxdWFscyIsInZhbHVlMSIsInZhbHVlMiIsImdldFByb3AiLCJoYXNBdHRyIiwiZ2V0VmFsdWVGb3JTZXR0aW5nIiwiaW5wdXRWYWx1ZSIsImlzUmFkaW8iLCJnZXRWYWx1ZUZvckdldHRpbmciLCJvcHRpb25zIiwiaW5pdCIsImlzTXVsdGlwbGUiLCJhZGRWYWx1ZSIsImNvbmNhdCIsImdldExpc3RlbmVyTmFtZSIsImdldEV2YWxGdW5jdGlvbiIsInNlbGVjdGVkIiwiaW5zZXJ0VGVtcGxhdGVzIiwidGVtcGxhdGUiLCJ0ZW1wbGF0ZXMiLCJmb3JFYWNoTm9kZSIsInRyZWUiLCJ0cmltIiwibmV3VGVtcGxhdGVzIiwibmV3VmFycyIsInJlbW92ZUFwcCIsIkR3YXluZVJvb3RCbG9jayIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiT2JqZWN0IiwiQXJyYXkiLCJyZWdleHBTcGVjaWFsQ2hhcmFjdGVycyIsIm1hcCIsInMiLCJqb2luIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInNldFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJwcm90byIsIl9fcHJvdG9fXyIsInJvb3RCbG9ja3MiLCJyb290TWl4aW5zIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsIkVWRU5UX1JFR0VYIiwiZW1wdHlDb2xsZWN0aW9uIiwiX3RoaXMiLCJpbmNsdWRlcyIsInRoaXMiLCJlbGVtcyIsImZvckVhY2giLCJsaXN0IiwiY2xhc3NMaXN0IiwiYXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZU5TIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZE5vZGVzIiwiY29sbGVjdCIsImlzIiwiZWxlbWVudHMiLCJjYiIsImNvbnRhaW5zIiwiZWwiLCJpc1RleHQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJzdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRQcm9wZXJ0eVByaW9yaXR5IiwicmVtb3ZlQ1NTIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImNzc1RleHQiLCJkYXRhc2V0IiwiZXZlbnQiLCJkZXRhaWxzIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJyZWFsRGV0YWlscyIsImZpbmFsRXZlbnQiLCJFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImZpbHRlckZuIiwiQm9vbGVhbiIsImhhc0F0dHJpYnV0ZU5TIiwiaGFzQXR0cmlidXRlIiwiaW5uZXJIVE1MIiwibmV4dCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZW5kIiwiZmlyc3RDaGlsZCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJjYWxsIiwibGlzdGVuZXIiLCJuZXdFdmVudHMiLCJhbGxMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJmaXJzdCIsIm1ldGhvZCIsInByZXYiLCJiYWJlbEhlbHBlcnMuZ2V0IiwiYXBwbHkiLCJ0ZXh0Q29udGVudCIsImNvbmRpdGlvbiIsIl9hcmd1bWVudHM1IiwidG9nZ2xlIiwiX2FyZ3VtZW50czYiLCJzcGVjaWVzIiwiX3ZhbHVlIiwiY3VycmVudFZhbHVlIiwiaXNQYXJlbnRTaWduYWwiLCJpc1JlbW92ZWQiLCJiZWZvcmVSZW1vdmUiLCJ3cmFwcGVycyIsInJlZHVjZSIsImJsb2NrSG9va3MiLCJtaXhpbkhvb2tzIiwiVEFHX05BTUVfUkVHRVgiLCJBVFRSX05BTUVfUkVHRVgiLCJXQVRDSEVEX0FSR19QUkVGSVhfUkVHRVgiLCJXQVRDSEVEX0dMT0JBTF9QUkVGSVhfUkVHRVgiLCJhZnRlckVsZW0iLCJvcmlnaW5hbEFyZ3MiLCJjaGlsZHJlbkJsb2NrcyIsImZ1bmMiLCJvbkNoYW5nZSIsInRhcmdldEJsb2NrIiwiZm9yREVsZW1lbnRzIiwiZm9yREl0ZW0iLCJmb3JERWFjaCIsIm9uQ2hhbmdlRmxhZyIsInJlc3VsdCIsImV4cHJlc3Npb24iLCJvcmlnaW5hbCIsIm9uRXZhbEVycm9yIiwiZSIsImxvY2FsV2F0Y2hlcnMiLCJuZXdSZXN1bHQiLCJ3YXRjaGVyQmxvY2siLCJyZW1vdmVDb250ZW50IiwiX3RoaXM3IiwibmV3Q29udGVudCIsImFmdGVyRE9NQ2hhbmdlIiwiY29udGVudFRvQWRkIiwibm90UmVjdXJzaXZlIiwib2xkQ29udGVudCIsImNoYW5nZUNvbnRlbnQiLCJjb250ZW50VG9Nb3ZlIiwiYWZ0ZXIiLCJpbmRleFRvUHV0IiwibW92ZUNvbnRlbnQiLCJjb250ZW50VG9SZW1vdmUiLCJmaWx0ZXIiLCJjb250ZW50VG9JbnNlcnQiLCJtb3ZlRmxhZyIsInRyeVRvQWRkT3JNb3ZlIiwiZGVmYXVsdExvY2FscyIsImRlZmF1bHRBcmdzIiwibG9jYWxBcmdzIiwicmVzdEFyZ3MiLCJpc0RFbGVtZW50cyIsImhvb2siLCJ3YXJuIiwiY3VycmVudFJldHVyblZhbHVlIiwia2xhc3MiLCJibG9ja3MiLCJodG1sQ2hpbGRyZW4iLCJvbGRXYXRjaGVyIiwiX3RoaXM4IiwicGFyZW50UGFyZW50U2NvcGUiLCJwYXJlbnRQYXJlbnRUZW1wbGF0ZSIsIm93bkNoaWxkcmVuIiwiZm91bmQiLCJQYXJlbnRTY29wZSIsIlBhcmVudFRlbXBsYXRlIiwiZEJsb2NrcyIsIkRJdGVtIiwid2F0Y2hBcmdzIiwidWlkIiwicmVuZGVyU2V0IiwiX3RoaXMyIiwiaXRlbXNCeVVJRHMiLCJVSUQiLCJzb3J0QnkiLCJuZXdJdGVtc0J5VUlEcyIsIm5ld1VJRHNDb3VudGVyIiwibmV3VUlEcyIsInNldCIsImZpbHRlckJ5IiwiaXNBcnIiLCJpdGVyYXRlIiwic29ydCIsIml0ZW1zIiwic2hpZnQiLCJJbmZpbml0eSIsImNvbmQiLCJpZiIsIndhc0RlZmF1bHQiLCJ2YWwiLCJvZmYiLCJvbiIsImNsYXNzZXMiLCJuZXdDbGFzc2VzIiwiaW5pdGlhbFNjb3BlVmFsdWUiLCJzZXRQcm9wIiwiaW5pdGlhbEVsZW1WYWx1ZSIsImlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIiwiaXNDaGVja2JveCIsImNoYW5nZVNjb3BlIiwib2ZmRWxlbUxpc3RlbmVyIiwib2ZmRm9ybUxpc3RlbmVyIiwib3B0aW9uIiwiYm9keSJdLCJtYXBwaW5ncyI6InlCQUFPLFNBQVNBLEdBQWlCQyxFQUFPQyxNQUFVQyxzRUFDbkNGLEVBQU8sU0FBQ0csRUFBT0MsS0FDakJGLEVBQWNDLEVBQU9DLEVBQU9KLEtBR2hDRSxFQUdULFFBQWdCRyxHQUFZTCxFQUFPQyxPQUM1QixHQUFJSyxHQUFJLEVBQUdDLEVBQVNQLEVBQU1PLE9BQVFELEVBQUlDLEVBQVFELElBQUssSUFDaERILEdBQVFILEVBQU1NLE1BRWhCTCxFQUFTRSxFQUFPRyxFQUFHTixjQUVkTSxZQU9iLFFBQWdCRSxHQUFhUixFQUFPQyxPQUM3QixHQUFJSyxHQUFJLEVBQUdDLEVBQVNQLEVBQU1PLE9BQVFELEVBQUlDLEVBQVFELE1BQ3hDTixFQUFNTSxHQUFJQSxFQUFHTixHQUkxQixRQUFnQlMsR0FBZ0JULEVBQU9VLE1BQy9CTixHQUFRSixFQUFNVyxRQUFRRCxJQUViLElBQVhOLEtBQ0lRLE9BQU9SLEVBQU8sR0FJeEIsUUFBZ0JTLEdBQWFiLFNBQ3BCRCxHQUFpQkMsRUFBT2MsR0FHakMsUUFBU0EsR0FBT0MsRUFBTUMsS0FDZkEsSUFBWSxFQ2pDbkIsUUFBZ0JDLEdBQU9DLFlBQ1JDLFVBQVcsU0FBQ0MsRUFBUWhCLEdBQzNCQSxLQUNZZ0IsRUFBUSxTQUFDakIsRUFBT2tCLEtBQ3JCQSxHQUFPbEIsTUFLYmUsRUFHVCxRQUFnQkksR0FBa0JDLEVBQVF0QixNQUFVQyxzRUFDcENxQixFQUFRLFNBQUNwQixFQUFPa0IsS0FDbkJuQixFQUFjQyxFQUFPa0IsRUFBS0UsS0FHOUJyQixFQUdULFFBQWdCc0IsR0FBT0QsTUFDZkUsTUFDQUMsRUFBbUJDLGtCQUFNLFlBRWpCSixFQUFRLFNBQUNwQixFQUFPa0IsSUFDQSxJQUF4QkssRUFBTWYsUUFBUVUsT0FDTkEsR0FBT2xCLEtBSWRzQixFQUdULFFBQWdCRyxHQUFlTCxFQUFRRixTQUN0QlEsV0FBSVIsR0FHckIsUUFBZ0JTLEdBQWNQLEVBQVF0QixPQUMvQixHQUFNb0IsS0FBT0UsR0FDWkssRUFBZUwsRUFBUUYsTUFDaEJFLEVBQU9GLEdBQU1BLEVBQUtFLEdBS2pDLFFBQWdCUSxHQUFVUixFQUFRdEIsTUFDMUJ3QixlQUVRRixFQUFRLFNBQUNwQixFQUFPa0IsS0FDbEJBLEdBQU9wQixFQUFTRSxFQUFPa0IsRUFBS0UsS0FHakNFLFVDaERPTyxHQUEwQmQsRUFBUWUsS0FDbENBLEVBQVksU0FBQzlCLEVBQU8rQixVQUN6QkMsZUFBZWpCLEVBQVFnQixxQkFFbEIsY0FDRSxnQkFDRSxNQVlwQixRQUFnQkUsR0FBdUJsQixFQUFRZSxLQUMvQkEsRUFBWSxTQUFDOUIsRUFBTytCLFVBQ3pCQyxlQUFlakIsRUFBUWdCLHFCQUVsQixjQUNFLGdCQUNFLE1DeEJwQixRQUFnQkcsR0FBWWQsU0FDWGUsWUFBV1gsTUFBTSxHQUFJLEdBR3RDLFFBQWdCWSxHQUFlaEIsRUFBUWlCLEdBQ2pDQyxJQUFVQSxHQUFPSixlQUNPZCxFQUFPbUIsZ0JBQzlCRCxHQUFPSixZQUFjRyxJQ0k1QixRQWFnQkcsR0FBV3hDLFNBQ0ssYUFBdkJrQyxFQUFZbEMsSUFBMEMsa0JBQVZBLEdBY3JELFFBQWdCeUMsR0FBTXpDLFNBRUosT0FBVEEsRUFhVCxRQUFnQjBDLEdBQVMxQyxTQUNPLFdBQXZCa0MsRUFBWWxDLEdDM0NyQixRQUFnQjJDLEdBQVlDLFNBQ25CQSxHQUFPQyxRQUFRQyxHQUFzQixRQ3JCOUMsUUFBZ0JDLEdBQVkvQyxTQUNuQkEsR0FBTTZDLFFBQVFHLEdBQXFCQyxHQUc1QyxRQUFnQkMsR0FBYWxELFNBQ3BCQSxHQUFNNkMsUUFBUU0sR0FBeUJDLEdBR2hELFFBQVNILEdBQVdJLFNBQ1hBLEdBQU0sR0FBR0MsY0FHbEIsUUFBU0YsR0FBVUMsYUFDTEEsRUFBTSxHQUFHRSxjQ2hCaEIsUUFBU0MsR0FBUUMsRUFBT0MsS0FDdkJBLEVBQUszQixNQUFRMkIsRUFBSzFELE1DRzFCLFFBQWdCMkQsR0FBV0MsRUFBSzVELE1BQzFCQSxFQUFPLElBQ0g2RCxHQUFXN0QsRUFBTThELE1BQU1DLE1BRXpCaEIsRUFBWWMsRUFBUyxLQUFPQSxFQUFTLElDUnRDLFFBQVNHLEdBQVlDLEVBQU1qRSxFQUFPa0IsS0FDbENBLEdBQU9sQixFQ0RQLFFBQVNrRSxHQUFRQyxFQUFLNUQsS0FDdkJBLEVBQUs2RCxhQ0RKLFFBQVNDLEdBQVVGLEVBQUs1RCxLQUN6QkEsRUFBSytELFlDREosUUFBU0MsR0FBUUosRUFBSzVELEtBQ3ZCQSxFQUFLaUUsaUJDQ0osUUFBU0MsR0FBb0JDLEdBQ3BCQSxFQUFLQyxjQUFlQyxJQUV4QnhFLFVBS1B5RSxPQUFPLFNBQ1BDLEtBQUssS0FBTUYsSUFDWEcsU0FBVUgsaUNDTmYsUUFBZ0JJLEdBQVV0QixFQUFNbkQsU0FDakIsVUFBVG1ELEdBQTZCLGdCQUFUQSxFQUNHLFFBQWxCbkQsRUFBSzBFLFNBQ1JDLEdBQ0EsS0FHRkMsR0FBa0JDLEtBQUsxQixHQUNsQixHQUFJMkIsSUFBSzlFLEdBQU0rRSxRQUFRLE9BQU9sRixPQUNqQ21GLEdBQ0EsWUNaRCxRQUFTQyxHQUFLakYsS0FDQyxHQUFJOEUsSUFBSzlFLEVBQUtrRixjQUFjZixVQUM1Q1csSUFBSzlFLEdBQU1tRixTQUFTZCxJQ0puQixRQUFTZSxHQUFPM0YsU0FDZEEsYUFBaUJxRixJQ0UxQixRQUFnQk8sR0FBcUI1RixTQUVqQzZGLElBQXNCVCxLQUFLbEQsRUFBWWxDLEtBQ3BDMkYsRUFBTzNGLElBQ1A4RixHQUFROUYsR0NQUixRQUFTK0YsR0FBZS9GLFNBQ0MsaUJBQXZCa0MsRUFBWWxDLEdDQ3JCLFFBQWdCZ0csR0FBWWhHLE1BQ3BCcUMsR0FBTUgsRUFBWWxDLFNBR3RCaUcsSUFBY2IsS0FBSy9DLElBQ1IsaUJBQVJBLEdBQ1EsU0FBUkEsR0FDUSxxQkFBUkEsR0FDUSxZQUFSQSxFQ1pBLFFBQVM2RCxHQUFPM0YsTUFDZjRGLEdBQVM1RixFQUFLK0QsVUFFaEI2QixNQUNLQyxZQUFZN0YsR0NEaEIsUUFBUzhGLEdBQUs5RixNQUNmOEUsSUFBSzlFLEdBQU0rRixZQUFZMUIsSUNEdEIsUUFBUzJCLEdBQU9oRyxTQUNkb0YsR0FBT3BGLEdBQ1ZBLEVBQ0EsR0FBSThFLElBQUs5RSxHQ1NmLFFBQWdCb0UsR0FBSzZCLE1BQVVDLDBEQUFPQyxTQUM3QixJQUFJckIsSUFBS29CLEVBQUtFLGlCQUFpQkMsT0FBT0osS0NkeEMsUUFBU0ssR0FBY0MsRUFBTUMsS0FDckJDLEdBQUtELEdBQWEsU0FBQ0UsR0FDeEJBLElBQU9ILE9BQ0FHLE9BQU9DLFVBS2pCLEdBQU1ELEtBQU9ILEtBQ0xHLEdBQU9ILEVBQUtHLEdDWHBCLFFBQVNFLEdBQWNuSCxFQUFPaUgsRUFBSzdGLFNBQ2pDQSxHQUFPNkYsR0NDVCxRQUFTRyxHQUFvQnJGLFNBQzNCLElBQUlzRixZQUFZMUUsRUFBWVosNkNDRHJDLFFBQWdCdUYsR0FBV0MsRUFBUTdELE1BQzdCTCxjQUdDLEdBQU10QixLQUFRd0YsR0FBUSxJQUNuQkMsR0FBUUQsRUFBT3hGLEdBQ2YwRixFQUFhL0QsRUFBS0wsTUFBTW1FLEVBQU1FLFdBRWhDRCxFQUFZLElBQ1JFLEdBQVlGLEVBQVcsR0FDekJYLFFBRWMsTUFBZGEsT0FFT0EsTUFDRkEsRUFBVTdELE1BQU04RCx1QkFLZEgsRUFBVyxnQ0FTbkJwRSxHQzNCRixRQUFTd0UsR0FBbUJwRSxFQUFPOEQsRUFBUU8sU0FDekMzRyxHQUFrQnNDLEVBQU8sU0FBQ3NFLEVBQWUvSCxFQUFPMEQsTUFDakRzRSxHQUFhNUMsS0FBSzFCLFNBQ2I1QyxHQUFPaUgsRUFBZUYsRUFBbUI3SCxFQUFPdUgsRUFBUU8sT0FHM0R6RSxHQUFRaUUsRUFBV0MsRUFBUTdELE1BRTdCTCxnQkFDWUssU0FDTixpQkFDRyxvQkFHSkwsRUFDQXlFLGVBUUtwRSxTQUNOLGtCQU1aLFFBQWdCdUUsR0FBa0JuQixTQUN6QjNGLEdBQWtCMkYsRUFBTW9CLEdBR2pDLFFBQVNBLEdBQVFwQixFQUFNOUcsRUFBT2lILEdBQ3hCZSxHQUFhNUMsS0FBSzZCLEtBQ2JILEVBQU1tQixFQUFrQmpJLE1BRTFCaUgsR0FBT2pILEVDeENULFFBQVNtSSxHQUFxQkMsRUFBT3BJLE1BQ3BDcUksR0FBV0QsRUFBTUUsR0FBR3RJLFFBRXBCc0ksR0FBR3RJLE1BQVFBLElBRUpvSSxFQUFNRSxHQUFHQyxTQUFVLFNBQUNDLEtBQ3ZCeEksRUFBT3FJLEtDUlosUUFBU0ksU0FDZDFHLEtBQUFBLEtBQU15RixJQUFBQSxNQUFPa0IsSUFBQUEsUUFDYjFJLElBQUFBLE1BQU84RyxJQUFBQSxLQUFNNkIsSUFBQUEsUUFBU3BJLElBQUFBLEtBQ3RCcUksSUFBQUEsWUFBYUMsSUFBQUEsWUFBYUMsSUFBQUEsZUFFcEJWLEVBQVEsR0FBSVosdUdBWWRBLEVBQU11QixTQUFVLElBQ1ovSSxHQUFRb0ksRUFBTXBJLE1BQVFvSSxFQUFNVyxTQUFTLFNBQUNDLEVBQVVYLEtBQzlDckksTUFBUWdKLFFBR05DLFlBQVlELEVBQVVYLEdBQzVCLE1BQU9hLFdBQ0NDLDJCQUE0QnBILGtCQUFzQm1ILFFBSXhERCxZQUFZakosU0FHYm9JLEdDM0JGLFFBQVNnQixHQUFlM0YsRUFBTzRGLEVBQWE5SSxFQUFNK0ksS0FDekNELEVBQWEsV0FBa0IzRixNQUFmNkYsS0FBQUEsS0FBTXZKLElBQUFBLEtBQzdCeUQsR0FBTUMsS0FDSSxTQUFUNkYsSUFDR0MsV0FBVzlGLEtBRVY0RSxHQUFHcEMsZUFHSm1ELEdBQVkzRixTQUlqQjZELFVBR0QsR0FBTTdELEtBQVFELGFBQVJDLFNBTUxELEVBQU1DLEdBSlI2RixJQUFBQSxLQUNBYixJQUFBQSxRQUNBMUksSUFBQUEsTUFDQXlKLElBQUFBLEtBRUVDLFNBQ0FDLFNBQ0FDLFlBRUFQLEVBQVkzRixHQUFPLE9BSWpCMkYsRUFBWTNGLEdBRlJtRyxJQUFOTixLQUNPTyxJQUFQOUosU0FHVyxTQUFUdUosRUFDZSxVQUFiTSxLQUNRdkIsR0FBR3BDLFNBR1g0RCxJQUFjOUosS0FDWDBELEtBQUtBLEVBQU0xRCxLQUdOQSxNQUNQLElBQ0NvSSxHQUFRMEIsS0FFRyxTQUFiRCxLQUNHTCxXQUFXOUYsS0FHWjRFLEdBQUd5QixVQUFZckIsRUFFakJBLElBQ21CTixFQUFPcEksT0FDdkIsS0FBS29JLEVBQU1FLEdBQUcwQixXQUFhUCxFQUFLakMsTUFBTXVCLFNBQVUsSUFDL0NDLEdBQVdaLEVBQU1FLEdBQUdPLFlBQVlQLEdBQUdTLFNBQVMvSSxFQUFPLFNBQUNnSixTQUlwRHZGLEVBQU1DLEdBRlI2RixJQUFBQSxLQUNBYixJQUFBQSxPQUdXLFdBQVRhLEdBQXFCYixLQUNGTixFQUFPWSxJQUU3QlosS0FFR0UsR0FBRzBCLFdBQVksSUFFQTVCLEVBQU9ZLEtBR2xCWixJQUdIbUIsSUFDR2IsTUFDVCxJQUNRLFNBQVRhLElBQ0c3RixLQUFLQSxFQUFNMUQsS0FFSkEsTUFDUCxJQUNDaUssR0FBYSxhQUNadkIsUUFBVUEsS0FFVE4sR0FBUUssRUFBWWdCLE9BRXJCZixHQUFXZSxFQUFLakMsTUFBTXVCLFNBQVUsSUFFakNGLEdBRUVZLEVBRkZaLFlBQ0E3SSxFQUNFeUosRUFERnpKLE1BRUlrSyxFQUFhckIsRUFBWVAsR0FBR1MsU0FBUy9JLEVBQU8sU0FBQ2dKLFNBSTdDdkYsRUFBTUMsR0FGUjZGLElBQUFBLEtBQ0FiLElBQUFBLE9BR1csV0FBVGEsR0FBcUJiLEtBQ0ZOLEVBQU9ZLElBRTdCWixLQUVHRSxHQUFHMEIsV0FBWSxJQUNmMUIsR0FBR3RJLE1BQVFrSyxXQUdQOUIsdUNBT0RBLElBS1RrQixLQUNLYSxLQUFLRixTQU1MVixJQUNHYixJQUdKaEYsU0FDSmdHLFVBQ0dDLFFBQ0ZDLElBckhBbEcsTUF5SFA0RixRQUNLLGNBQ1EvQixFQUFRLFNBQUMwQyxTQUloQkEsSUFGRnZHLElBQUFBLEtBQ0ErRixJQUFBQSxPQUdVL0YsR0FBUStGLEtDbkpyQixRQUFTVyxHQUFzQmhKLEVBQVFtSSxFQUFNVixNQUM5Q3dCLFlBRVMsWUFBVGQsTUFDTTFFLEdBQ05nRSxFQUNJQSxFQUFZUCxHQUFHZ0MsUUFDZixPQUlEbkosRUFBa0JDLEVBQVEsU0FBQ2lKLEVBQU9ySyxFQUFPa0IsS0FDeENBLHlDQU9MbUosR0NuQkUsUUFBU0UsR0FBa0IvQixLQUN4QmdDLGVBSVYsUUFBZ0JDLElBQWVDLEtBQ2hCQSxFQUFrQkMsSUFHakMsUUFBU0EsVUFBZ0JuQyxLQUFBQSxZQUFTRCxTQUNOQyxHQ041QixRQUFnQm9DLElBQXFCUCxFQUFPUSxFQUFhQyxNQUN0Q1QsRUFBT3pJLEVBQVVpSixFQUFhLFNBQUM3SyxFQUFPa0IsTUFDL0NtSixHQUFRUyxFQUFhNUosR0FDbkJxSCxFQUFhOEIsRUFBYjlCLDhCQUdRLGNBQ0YsdUJBRU53QyxJQUFNQyxXQUMwQyxJQUE5Q0QsR0FBTUUsWUFBWXpLLFFBQVErSCxFQUFTMkMsVUFDL0JELFlBQVlkLEtBQUs1QixFQUFTMkMsTUFJN0JiLEVBQU1ySyxvQkFFWEEsTUFDRUEsSUFBVXFLLEVBQU1ySyxPQUlmbUwsZUFJQ0MsR0FBa0I3QyxFQUFTMkMsS0FBSzFKLFFBQ2hDNkcsRUFBV2dDLEVBQU1ySyxRQUVka0wsVUFDSGxMLE1BQVFBLElBRURvTCxFQUFpQmIsTUFDdEJKLDhDQU1HLGNBQ0pnQixRQU9BLEdBSENFLE1BQ0FDLEtBRUduTCxFQUFJZ0wsR0FBUS9LLE9BQVMsRUFBR0QsR0FBSyxFQUFHQSxjQUFoQ0EsU0FLSGdMLEdBQVFoTCxHQUhWa0ssSUFBQUEsTUFDQXJLLElBQUFBLE1BQ0FxSSxJQUFBQSxXQUdXZ0MsRUFBTTlCLFNBQVNnRCxLQUFNLFNBQUMvQyxNQUMzQnZJLEdBQVFvTCxFQUFJN0ssUUFBUWdJLElBRVgsSUFBWHZJLEtBQ0VrSyxLQUFLM0IsS0FDRjJCLDhCQUtBbEssR0FBT29JLFNBQVdBLE9BSXJCNUgsT0FBT04sRUFBRyxJQXJCWEEsTUF3QkMsT0FFR2tMLEVBQUssU0FBQzdDLEVBQVNySSxTQUl0Qm1MLEVBQU9uTCxPQUZUSCxRQUNBcUksY0FLSCxTQ3BFWCxRQUFnQm1ELFVBQWNDLEtBQUFBLEtBQU1DLElBQUFBLFlBQWF2RixJQUFBQSxPQUFRd0YsSUFBQUEsV0FBWS9DLElBQUFBLFlBQWFDLElBQUFBLFlBQWFDLElBQUFBLGVBQWdCOEMsSUFBQUEsVUFDdkdDLEVBQU0sR0FBSXhHLElBQUtzRyxFQUFXLEdBQUdsRyxlQUM3QmxGLEVBQU9vTCxFQUFXLEdBQUdHLGVBQWlCQyxHQUN4Q0YsRUFBSWhILE9BQU8sT0FDWGdILEVBQ0VHLEVBQWNsRCxFQUFpQkEsRUFBZVIsR0FBRzJELEdBQUdDLFFBQVVDLEdBQU1ELFFBQ3BFRSxFQUFjdEQsRUFBaUJBLEVBQWVSLEdBQUcyRCxHQUFHSSxRQUFVRixHQUFNRSxRQUN0RUMsRUFBV2IsRUFBS2EsU0FBV2IsRUFBS2EsYUFDaEN4RixFQUFPMkUsRUFBS2hJLE1BQVFnSSxFQUFLaEksVUFDekIxQixFQUFPMEosRUFBSzFKLE1BQVEsZUFDcEJ3SyxFQUFjYixHQUFnQkQsRUFBSzFKLE1BQVFpSyxFQUFZUCxFQUFLMUosTUFDNUR5SyxTQUNBQyxTQUNBQyxTQUNBQyxTQUNBQyxTQUNBQyxRQUVTLGFBQVQ5SyxHQUFzQitFLEVBQUsvRSxRQUN0QixlQUNPaUssRUFBWWpLLEtBQ1YrRSxFQUFLL0UsT0FDUlYsRUFBT3lGLEVBQU0sVUFDVHdGLGFBR0MsWUFBVHZLLEdBQXNCK0UsRUFBSzRFLGVBQzdCLGlCQUNPTSxFQUFZakssS0FDSCtFLEVBQUs0RSxjQUNmckssRUFBT3lGLEVBQU0saUJBQ1R3RixlQUdQRSxFQUFjekssRUFBS3NCLE1BQU15SixNQUFrQyxZQUFUL0ssT0FDOUNvSyxHQUFNRCxRQUFRLGFBQ2ZNLEVBQWNBLEVBQVksR0FBSyxTQUcxQ08sYUFFQVIsUUFFZ0IsR0FBSUEsMkhBWXBCLE1BQU9yRCxXQUNDQywrQkFBZ0NwSCxNQUFVbUgsS0FDcEMsU0FJYnFELEVBQWEsT0FJWmQsRUFGRnpMLElBQUFBLE1BQ0FzTSxJQUFBQSxTQUdJVSxFQUFVek0sRUFBS3NFLE9BQU85QyxHQUN0QmtMLEVBQWVwSSxHQUFPLE1BQ3hCcEIsRUFBUW9CLEdBQU8sTUFDZnFJLFNBQ0VwRixRQUNFa0Ysa0RBTU1sRyxFQUFNLFNBQUM5RyxFQUFPMEQsTUFDcEJ5SixHQUFVbkYsR0FBYTVDLEtBQUsxQixHQUM1QjBKLEVBQWFELEdBQVdELEVBQzFCckksR0FBT3BCLEdBQ1BBLE9BRUkySixFQUVKRCxFQUFTLElBQ0xFLEdBQVl4RSxFQUFZUCxHQUFHUyxTQUFTL0ksRUFBTyxTQUFDQSxjQUNyQyxhQUNLb04sRUFBWWpHLEtBQ25CaUcsRUFBWXZGLEVBQ2pCN0gsRUFBT29NLEVBQWF0RSxNQUVQckUsRUFBT3dKLEVBQWNELEdBQVMsSUFDNUMsSUFDRnBFLGFBRVEsRUFFSjlILEVBQU9zTSxFQUFZdkYsRUFDeEJ3RixFQUFXakIsRUFBYXRFLE9BSXRCekUsR0FBUWlFLEVBQVc4RSxFQUFhMUksU0FFM0IsRUFFUEwsU0FDWSxJQUFWckQsTUFDTSxlQUdDMEQsU0FDSCxpQkFDRyxvQkFHSkwsRUFDQXlFLGVBUUVwRSxTQUNILGFBQ0NtRixFQUFZUCxHQUFHUyxTQUFTL0ksRUFBTyxTQUFDQSxLQUMxQjBELFNBQ0gsa0JBR09ELEVBQU93SixFQUFjRCxHQUFTLElBQzVDcEUsU0FJRDBFLEdBQWVsRSxFQUFlM0YsRUFBT3dKLEVBQWNELEdBQVMsTUFFckQsYUFBVGpMLEtBQ01nRCxLQUFLL0UsR0FHRixVQUFUK0IsRUFBa0IsSUFDaEJnRCxHQUFPOEQsRUFBWVAsR0FBR1MsU0FBUy9JLEVBQU8sU0FBQ0EsR0FDckN5QyxFQUFNekMsT0FDQSxNQUdGK0UsUUFBUy9FLElBQ2hCNEksRUFFQ25HLEdBQU1zQyxPQUNELE1BR0RBLFFBQVNBLE1BR2Z1SCxFQUFVLElBQ05YLEdBQXNCLGFBQVQ1SixFQUNmLEdBQUlzRCxJQUFLMkgsRUFBUSxHQUFHTyxTQUNwQlAsRUFDQXBCLFdBRVNVLEVBQVUsU0FBQ2tCLEtBQ1ZoQyxTQUNKZ0MsU0FDRTdCLCtFQVVSOEIsR0FBZ0J0SCxZQUFrQmdHLFVBRXBDUCxhQUFxQk8sTUFDYjdELEdBQUdvRixjQUFjVixHQUFTLEdBQzNCcEIsS0FDRCtCLFlBQVkvQixHQUVoQjZCLEtBQ0tuRixHQUFHc0YsV0FBV1osSUFFZFMsSUFDRm5GLEdBQUd1RixrQkFBa0JiLEdBQVMsS0FFN0JjLEtBQUtuQyxHQUFZLE9BS3BCcUIsUUFRTEQsRUFKRnpFLElBQUFBLEdBQ015RixJQUFOakgsS0FDQXdELElBQUFBLFFBQ0cwRCwrQkFHRHBCLGNBRU9GLFdBQ0dDLEtBRVA1SyxLQUFPOEcsRUFBWVAsR0FBR1MsU0FBUzZELEVBQWUsU0FBQ3FCLEtBQzdDbE0sS0FBT2tNLElBRVBqTyxPQUFTeUwsSUFDYnNCLEdBQWUsS0FFYi9NLE9BQVN5TCxLQUNUNUMsWUFBY0EsSUFDZEMsZUFBaUJBLEdBR3BCK0Qsb0JBR09ILFdBQ0dDLEtBR1BqQixZQUFjN0MsRUFBWVAsR0FBR1MsU0FBUzhELEVBQXNCLFNBQUNxQixLQUMzRHhDLFlBQWN3QyxJQUNkbE8sT0FBU3lMLElBQ2JzQixHQUFlLEtBQ2IvTSxPQUFTeUwsS0FDVDVDLFlBQWNBLElBQ2RDLGVBQWlCQSxNQUdsQnFGLEdBQWdCLGVBQVRwTSxFQUNUZ00sRUFBSy9OLFVBQ0x1TSxFQUFZNkIsV0FFYnRILEtBQU9zRCxFQUFzQjJELEtBQzdCQyxPQUFTNUQsRUFBc0I0RCxLQUMvQjFELFFBQVVGLEVBQXNCRSxFQUFTLFVBQVd6QixHQUUxQyxZQUFUOUcsRUFBb0IsT0FDaEI4SSxjQUNIWSxFQUFLNEMsU0FBVzVDLEVBQUs2QyxXQUNyQjdDLEVBQUs4QyxVQUFZOUMsRUFBS3hMLFVBRW5Cb0ssR0FBZ0MsWUFBeEJ4QixFQUFZUCxHQUFHdkcsS0FDekI4RyxFQUFZUCxHQUFHK0IsTUFDZnhCLElBRURvRCxHQUFLcEQsRUFBWVAsR0FBRzJELEtBQ3BCbkIsYUFBZVYsRUFBc0JTLE9BQ25CdkMsRUFBRytCLE1BQVF4RixHQUFPd0YsSUFBUVEsR0FBYXZDLEVBQUd3QyxpQkFHcEQsV0FBVC9JLEVBQW1CLFVBQ2xCc0ksTUFBUXhGLEdBQStCLFlBQXhCZ0UsRUFBWVAsR0FBR3ZHLEtBQXFCOEcsRUFBWVAsR0FBRytCLE1BQVF4QixlQUMxRWtGLEVBQUtPLE1BQVEsZUFDTCxlQUNHLFVBRVhQLEVBQUs5TixPQUFTLGdCQUNOLGVBQ0csWUFLSzhOLEVBQU1BLEVBQU16RixFQUFHeEIsU0FDZndELEVBQVNBLEVBQVNoQyxFQUFHZ0MsWUFDckJ5QyxFQUFlaUIsRUFBUTFGLEVBQUcwRixjQUcvQlEsaUJBQ2QsTUFBT3RGLFdBQ0NDLDJCQUE0QnBILHFCQUF5Qm1ILFNBR25EaEMsS0FDVyxlQUFUbkYsRUFDVmdNLEVBQUtsRixZQUNMa0UsSUFDc0IsZUFBVGhMLEVBQ2JnTSxFQUFLakYsZUFDTGlFLElBRVNvQixFQUFNLFNBQUNYLEtBQ05oQyxTQUNKZ0MsU0FDRVQsMkJBRUtBLG1EQU9IekUsR0FBR21HLFlBQWEsUUFHZEMsY0FDZCxNQUFPeEYsV0FDQ0MsMkJBQTRCcEgsa0JBQXNCbUgsU0FHckQ2RCxHQ3pVRixRQUFTNEIsSUFBWUMsTUFDakJBLEVBQUt6QyxPQUNMeUMsRUFBSXJNLFVBQVc0SixHQUFNNUosV0NIaEMsUUFBZ0JzTSxJQUFhQyxFQUFPQyxlQUNwQkMsV0FBY0QsU0FBbUJ4TSxVQUFXeU0sV0FBY0QsRUFBU3hNLFdDSDVFLFFBQVMwTSxJQUF1QnpCLEtBQy9CbEYsR0FBR3BDLFFBQU8sR0FHbEIsUUFBZ0JBLElBQU9zSCxLQUNmbEYsR0FBR3BDLFNDSEosUUFBU2dKLElBQWtCQyxFQUFPM0csS0FDekIyRyxFQUFNN0csR0FBRzBGLE9BQVEsY0FBR3pGLFNBQ3ZCZ0QsS0FBS3BCLEtBQUszQixLQUl2QixRQUFnQjRHLElBQW1CRCxFQUFPM0csU0FJcEMyRyxFQUFNN0csR0FGUmdDLElBQUFBLFFBQ0FJLElBQUFBLHFCQUdHLEdBQU0yRSxLQUFRL0UsR0FBUyxJQUVwQi9CLEdBQVcrQixFQUFRK0UsR0FBTTlHLFNBQVNnRCxPQUUvQnBCLEtBQUszQixLQUNHMkIsOEJBT3JCLFFBQWdCbUYsSUFBZ0JILEVBQU8zRyxLQUN2QjJHLEVBQU03RyxHQUFHeEIsS0FBTSxjQUFHeUIsU0FDckJnRCxLQUFLcEIsS0FBSzNCLEtDeEJoQixRQUFTK0csSUFBVUosRUFBT0ssTUFDekJDLEdBQWNELEVBQVFMLFNBRXJCTixJQUFhMUMsR0FBT3NELEdBQ3ZCQSxFQUNBTixFQUdOLFFBQWdCTyxJQUFVdEgsRUFBT29ILE1BQ3pCQyxHQUFjRCxFQUFRcEgsU0FFckJ5RyxJQUFhckgsR0FBT2lJLEdBQ3ZCQSxFQUNBckgsRUNaQyxRQUFTdUgsSUFBUXhCLEVBQU15QixNQUN0QmpFLEdBQWEsR0FBSXRHLElBQUt1SyxHQUFXclAsS0FBSyxPQUV2Q29MLEVBQVd2TCxZQUNSLElBQUl5UCxPQUFNLG1FQUdkbEUsRUFBVzdHLEtBQUssd0JBQ1osSUFBSStLLE9BQU0sd0VBR2QvSixJQUFRcUksc0JBR0RBLE9BSUwyQix1SUFBa0IzRCxNQUNmNEQsTUFBUTVCLEVBQUt2TixPQUNid04sTUFBUUQsRUFBS25PLFNBR2hCbVAsR0FBUTNELGVBRUosMEJBRUtzRSxTQUNMbkUsbUJBS1A3RyxLQUFLLGtCQUFtQnFLLEdBQ3hCekwsS0FBSyxjQUFlLElDdUZ6QixRQUFTc00sSUFBT0MsRUFBUUMsU0FDZkQsS0FBV0MsRUN6RXBCLFFBQVN2TSxJQUFXQyxFQUFLMEssWUFDREEsS0FBZnhKLE9BQU05RSxTQUVUOEUsR0FBUTlFLEVDNEVkLFFBQVNtUSxJQUFRcE8sRUFBTXdILEVBQU1oSixVQUNuQndCLE9BQ0QsZUFDSXhCLEdBQUs2UCxRQUFRLFlBQ2hCLGtCQUNBLFlBR0QsY0FDVSxTQUFUN0csRUFDSyxRQUdPLFVBQVRBLEdBQTZCLGFBQVRBLEVBQ3ZCLFVBQ0Esc0JBSUdoSixHQUFLNlAsUUFBUSxtQkFDaEIsT0FDQSxTQUtWLFFBQVNDLElBQW1CdE8sRUFBTS9CLEVBQU91SixFQUFNK0csTUFDaEMsVUFBVHZPLFFBQ0svQixNQUdIdVEsR0FBbUIsVUFBVGhILFFBRVhnSCxJQUFvQixhQUFUaEgsRUFJVGdILEVBQ0h2USxJQUFVc1EsR0FDcUIsSUFBL0J0USxFQUFNUSxRQUFROFAsR0FMVHRRLEVBUVgsUUFBU3dRLElBQW1Cek8sRUFBTS9CLEVBQU91SixFQUFNK0csRUFBWWhGLEVBQVFtRixFQUFTQyxFQUFNQyxVQUN4RTVPLE9BQ0QsZUFDRTRPLEdBSUUvUSxFQUFpQjZRLEVBQVNHLE9BSHhCNVEsTUFNTixXQUNVLFVBQVR1SixHQUE2QixhQUFUQSxRQUNmdkosTUFHSSxVQUFUdUosUUFDS3ZKLEdBQ0hzUSxFQUNBLFNBR0R0USxHQUFTMFEsUUFDTHBGLE1BR0x0TCxRQUNFc0wsSUFDcUMsSUFBaENBLEVBQU85SyxRQUFROFAsR0FDbEJoRixFQUFPdUYsT0FBT1AsR0FDZGhGLEdBR0VnRixPQUdMeEssR0FBUXdGLGVBSVByTCxHQUFRcUwsRUFBTzlLLFFBQVE4UCxVQUVkLElBQVhyUSxlQUVHcUwsRUFBTzlKLE1BQU0sRUFBR3ZCLE9BQ2hCcUwsRUFBTzlKLE1BQU12QixFQUFRLEtBSXJCcUwsZ0JBSUF0TCxJQUtiLFFBQVM4USxJQUFnQi9PLEVBQU13SCxVQUNyQnhILE9BQ0QsZUFDSSxhQUdKLGNBRVEsVUFBVHdILEdBQ1ksYUFBVEEsR0FDUyxVQUFUQSxHQUNTLFNBQVRBLEVBRUQsU0FDQSw2QkFJRyxTQUtiLFFBQVN3SCxJQUFnQi9RLFNBQ2hCLFVBQUNxSyxTQUFVQSxHQUFNckssSUFHMUIsUUFBUzRRLElBQVN0RixRQUFVMEYsS0FBQUEsU0FBVWhSLElBQUFBLEtBQ2hDZ1IsS0FBdUMsSUFBM0IxRixFQUFPOUssUUFBUVIsTUFDdEJtSyxLQUFLbkssR0NoUVQsUUFBU2lSLElBQWdCQyxFQUFVQyxXQVcvQkMsS0FBdUNuUixFQUFPb1IsTUFBaEM5SCxLQUFBQSxLQUFNdkosSUFBQUEsTUFBT3NNLElBQUFBLFFBQ3JCLGNBQVQvQyxLQUNNdkosRUFBTXNSLE9BRVZDLEVBQWF2UixPQUNWQyxHQUFTc1IsRUFBYXZSLEdBQU9BLFFBQzNCd1IsRUFBUzlRLEVBQWE2USxFQUFhdlIsR0FBT1ksV0FHdEMwTCxFQUFVOEUsTUFsQnpCeFEsR0FFRXNRLEVBRkZ0USxLQUNBWixFQUNFa1IsRUFERmxSLE1BRUl1UixFQUFlMU0sR0FBTyxNQUN0QjJNLEVBQVU5USxFQUFhRSxZQUV0QjJRLEVBQWNKLEtBQ1JuUixFQUFPb1IsS0FlZmhSLE9BQVMsSUFDVCtKLGdCQUFRbkQsR0FBS3dLLEtBRVhOLEVDN0JGLFFBQVNPLElBQVVoRyxNQUNsQmxMLEdBQU8sR0FBSThFLElBQUtvRyxPQUVqQmxMLEVBQUtILFlBQ0YsSUFBSXlQLE9BQU0sb0VBR1h0UCxFQUFLLFNBRWdCa0wsRUFBcEJpRyxJQUFBQSxxQkFFRkEsWUFBMkJ2RixVQUN6QixJQUFJMEQsT0FBTSw2REFHRnZILEdBQUdwQyxXQUNkc0QsV0FBVyxxQkFFVGlDLEdBQUtpRyxnQkNuQmQsT0FBaUMsbUJBQVhDLFFBQXlCQSxPQUEyQixtQkFBWEMsUUFBeUJBLE9BQXlCLG1CQUFUQyxNQUF1QkEsYzlDQzdHblEsTUFBaEJELGVBRU1ELE1BQUFBLE1DSU9zUSxHQUFxQkMsT0FBckJELGdnRUNQSUYsR0FBWHRQLE1BQUFBLGFBQ0FILE1BQUFBLFNDaUJPMkQsR0FBWWtNLE1BQVpsTSxRQ3BCVG1NLElBQ0osSUFDQSxJQUFLLElBQUssSUFDVixJQUFLLElBQ0wsSUFBSyxJQUNMLElBQUssSUFDTCxJQUFLLElBQ0wsSUFBSyxJQUNMLElBQ0EsSUFDQSxJQUNBLElBQ0EsSUFDQSxJQUNBLE1BRUluUCxHQUF1QixHQUFJdUUsUUFDL0I0SyxHQUNHQyxJQUFJLFNBQUNDLGNBQVlBLElBQ2pCQyxLQUFLLEtBQ1IsSzJDbkJBdk4sR0FHRWtOLE9BSEZsTixPQUNBbUMsR0FFRStLLE9BRkYvSyxLQUNnQnFMLEdBQ2ROLE9BREZPLGVBR1dDLEdBQVdSLE9BQU9TLGdCQUFtQixTQUFDelIsRUFBUTBSLEtBRWxEQyxVQUFZRCxHMUNSZnpQLEdBQXNCLFVBQ3RCRyxHQUEwQixTRUMxQlksR0FBaUMsS3lDQTFCYSxHQUFhLG9CQUNibUgsR0FBUyw2QkFDVC9ELEdBQWUsaUJBRWYySyxHQUFhOU4sR0FBTyxNQUNwQitOLEdBQWEvTixHQUFPLE1BQ3BCa0csY0FDRCxrQm5DUE41RixHQUFvQixZQUNwQkQsR0FBUyxnQ0FDVEssR0FBWSwrQkdEWk0sR0FBd0IsOEJFRHhCSSxHQUFnQixjSUVsQjJMLFNBREZsTCxTQUFBQSx3QjJCNENpQmtMLEdBQVh0UCxNQUFBQSxPQUdGdVEsR0FBc0IsZ0JBQ3RCQyxHQUFjLFNBRWRDLE1BZUExTiwrQkFXUTlFLDBEQUFPd1Msc0ZBR1puTixHQUFxQnJGLFFBQ2hCQSxTQUdLOEUsRUFBSzlDLGFBRVBoQyxFQUFNLFNBQUNBLEdBQ2JxRixFQUFxQnJGLFFBQ2hCQSxNQUdHQSxFQUFNLFNBQUNBLElBQ2J5UyxFQUFLQyxTQUFTMVMsSUFBU3lGLEVBQVl6RixNQUNqQzRKLEtBQUs1SixvRUExQkFzRCxFQUFVN0QsU0FDdEJnQixXQUFVWixRQUFVLFlBQ1J5RCxFQUFXN0QsTUFHRGtULEtBQUszUSxVQUFXc0IsR0FFbkNxUCw4Q0FzQ0RDLEdBQVFELEtBQUsxUixpQkFFTlIsVUFBVyxTQUFDVCxHQUNsQnFGLEVBQXFCckYsUUFDaEJBLE1BR0dBLEVBQU0sU0FBQ0EsSUFDYjRTLEVBQU1GLFNBQVMxUyxJQUFTeUYsRUFBWXpGLE1BQ2pDNEosS0FBSzVKLE9BS1Y0UywyREFjQUQsTUFBS0UsUUFBUSxTQUFDN1MsTUFDYjhTLEdBQU85UyxFQUFLK1MsY0FFTSxTQUFDMUUsU0FBUXlFLEdBQUtsUCxJQUFJeUssb0NBeUJ6Q2xMLEVBQU0xRCxNQUNITyxHQUFPMlMsS0FBSyxPQUVibFMsVUFBVVosYUFDUkcsR0FJRVksRUFBa0JaLEVBQUtnVCxXQUFZL1AsU0FHeEN4QyxVQUFVWixRQUFVLEdBQUtzQyxFQUFTZ0IsR0FBTyxLQUN0Q25ELFFBQ0ksU0FHSDBMLEdBQUtqSCxFQUFVdEIsRUFBTW5ELFNBRXBCMEwsR0FDSDFMLEVBQUtpVCxlQUFldkgsRUFBSXZJLEdBQ3hCbkQsRUFBS2tULGFBQWEvUCxTQUdwQjFDLFdBQVVaLFFBQVUsWUFDWnNELEVBQU8xRCxJQUdaa1QsS0FBS0UsUUFBUSxTQUFDN1MsS0FDTG1ELEVBQU0sU0FBQzFELEVBQU9rQixNQUN0QnVCLEVBQU16QyxLQUFvQixJQUFWQSxRQUNYLElBQUlxRixHQUFLOUUsR0FBTWlKLFdBQVd0SSxNQUdqQixJQUFWbEIsRUFBaUIsR0FBS0EsS0FFeEJpTSxHQUFLakgsRUFBVTlELEVBQUtYLEVBRXRCMEwsS0FDR3lILGVBQWV6SCxFQUFJL0ssRUFBS2xCLEtBRXhCMlQsYUFBYXpTLEVBQUtsQixnREFnQnRCLElBQUlxRixHQUFLNk4sS0FBSzlTLE9BQVM4UyxLQUFLLEdBQUdVLCtDQVdoQ3BOLFNBQ0MwTSxNQUFLVyxRQUFRLFNBQUMxUCxFQUFLNUQsUUFDakJBLEdBQU0sSUFDUCxHQUFJOEUsR0FBSzlFLEdBQU11VCxHQUFHdE4sU0FDYnJDLEdBQUk1RCxLQUdOQSxFQUFLK0QsOENBS1Z4RSxjQUNBaVUsS0FDQUMsRUFBT0QsRUFBUzVKLFVBQVQ0SixlQUVSWCxRQUFRLFNBQUM3UyxFQUFNTixLQUNUK1QsRUFBSXpULEVBQU1OLE9BR2QsR0FBSW9GLEdBQUswTyxvQ0FjVC9HLE1BQ0Q3RyxHQUFTK00sS0FBSyxHQUNkMUYsRUFBUWpILEVBQU95RyxHQUFTLFlBRXRCN0csSUFBV3FILElBRWZySCxFQUFPOE4sU0FBU3pHLGtDQWVmakUsU0FDRTJKLE1BQUtXLFFBQVEsU0FBQzFQLEVBQUs1RCxNQUNwQjJULEdBQUssS0FDSEMsRUFBa0IsVUFBVDVLLEVBQ1Q3QyxFQUFXWCxFQUFleEYsR0FDNUJBLEVBQ0FBLEVBQUtrRixpQkFFTDBPLEdBQW1CLGFBQVQ1SyxJQUNQNEssRUFDRHpOLEVBQVMwTixlQUFlLElBQ3hCMU4sRUFBUzJOLGNBQWMsUUFDdEIsSUFDQ3BJLEdBQWMsUUFBVDFDLEVBQ1B3QyxHQUNBeEwsRUFBS3VMLGNBQWdCcEYsRUFBUzROLGdCQUFnQnhJLGNBL1B6QyxpQ0FpUUpwRixFQUFTNk4sZ0JBQWdCdEksRUFBSTFDLEtBR2hDLEdBQUlsRSxHQUFLNk8sR0FBSXBHLEtBQUt2Tiw0Q0FlWndFLFNBQ0xtTyxNQUNKck8sT0FBTyxZQUNQRSxLQUFLQSxzQ0FjQ0EsU0FDRm1PLE1BQ0pyTyxPQUFPLFNBQ1BFLEtBQUtBLCtCQXNCTmxCLEVBQVU3RCxTQUNNa1QsS0FBSyxPQUFmc0IsSUFBQUEsWUFFSHhULFdBQVVaLE9BUVhZLFVBQVVaLFFBQVUsR0FBS3NDLEVBQVNtQixHQUMvQjJRLEtBSU10UixFQUFhVyxHQUVqQjJRLEVBQU1DLGlCQUFpQjVRLElBQWEyUSxFQUFNRSxvQkFBb0I3USxHQUFZLGNBQWdCLEtBTHhGLElBUVA3QyxVQUFVWixRQUFVLFlBQ1J5RCxFQUFXN0QsSUFHcEJrVCxLQUFLRSxRQUFRLFNBQUM3UyxLQUNMc0QsRUFBVSxTQUFDN0QsRUFBTzZELFFBQ25CWCxFQUFhVyxHQUVwQnBCLEVBQU16QyxLQUFvQixJQUFWQSxRQUNYLElBQUlxRixHQUFLOUUsR0FBTW9VLFVBQVU5USxLQUc3QjJRLE1BQU1JLGVBQWUvUSxLQUNyQjJRLE1BQU1LLFlBQ1RoUixFQUNBN0QsRUFBTTZDLFFBQVFnUSxHQUFxQixJQUNuQ0EsR0FBb0J6TixLQUFLcEYsR0FBUyxZQUFjLFNBakMvQ3dVLEVBSUU1VSxFQUFpQjRVLEVBQU1NLFFBQVFoUixNQXhVVCxPQXdVNENILG1DQXVEeEV6QyxFQUFLbEIsU0FDWWtULEtBQUssT0FBakI2QixJQUFBQSxZQUVIL1QsVUFBVVosYUFDUjJVLEdBSUU1VCxFQUFrQjRULEVBQVMvUSxTQUdYLElBQXJCaEQsVUFBVVosUUFBZ0JzQyxFQUFTeEIsR0FBTSxLQUN0QzZULGVBSUVBLEdBQVE3VCxTQUdiRixXQUFVWixRQUFVLFlBQ2JjLEVBQU1sQixJQUdWa1QsS0FBS0UsUUFBUSxTQUFDN1MsS0FDTFcsRUFBSyxTQUFDbEIsRUFBT2tCLEtBQ3BCNlQsUUFBUTdULEdBQU9sQix1Q0FvQmpCZ1YsTUFBT0MsK0RBS1ZBLFVBSEZDLFFBQUFBLG9CQUNBQyxXQUFBQSxnQkFDR0MsaUNBRURDLEVBQWFMLE1BRVpsQyxHQUFZMU4sS0FBS2xELEVBQVltVCxVQUVqQixHQUFJQyxPQUFNRCxHQUFjSCxVQUFTQyxpQkFDdkNFLEVBQVlELEdBQ25CLE1BQU9sTSxVQUdKZ0ssTUFBS0UsUUFBUSxTQUFDN1MsT0FDZHVTLEdBQVkxTixLQUFLbEQsRUFBWW1ULElBQWMsSUFDeEMzTyxHQUFXWCxFQUFleEYsR0FDNUJBLEVBQ0FBLEVBQUtrRixnQkFFSWlCLEVBQVM2TyxZQUFZLFdBQ3ZCQyxVQUFVUixFQUFPRSxFQUFTQyxLQUU5QkUsRUFBWUQsS0FHaEJLLGNBQWNKLHVDQWNsQnBWLDBEQUFRLFFBQ1BBLEdBQVEsTUFDRmlULEtBQUs5UyxPQUFTSCxHQUdqQixHQUFJb0YsR0FBSzZOLEtBQUtqVCxnREFhaEJ5Vix5REFBV0MsY0FDVHpDLE1BQUtXLFFBQVEsU0FBQzFQLEVBQUs1RCxFQUFNTixHQUMxQnlWLEVBQVNuVixFQUFNTixRQUNiTSxrQ0FhTGlHLFNBQ0kwTSxNQUFLVyxRQUFRLFNBQUMxUCxFQUFLNUQsS0FDcEJvRSxFQUFLNkIsRUFBVWpHLHNDQWdCZlQsdUJBQ09vVCxLQUFNLFNBQUNsVCxFQUFPa0IsS0FDaEJsQixFQUFPa0IsT0FHWGdTLHFDQWNEeFAsTUFDQW5ELEdBQU8yUyxLQUFLLE9BRWIzUyxTQUNJLEtBR0gwTCxHQUFLakgsRUFBVXRCLEVBQU1uRCxTQUVwQjBMLEdBQ0gxTCxFQUFLcVYsZUFBZTNKLEVBQUl2SSxHQUN4Qm5ELEVBQUtzVixhQUFhblMsb0NBY2ZrTCxNQUNEck8sR0FBTzJTLEtBQUssV0FFWDNTLEdBQ0hBLEVBQUsrUyxVQUFVVyxTQUFTckYsd0NBY3JCc0UsTUFBS0UsUUFBUTVOLGdDQWVqQjJJLE9BQ0VuTixVQUFVWixPQUFRLElBQ2ZHLEdBQU8yUyxLQUFLLFNBRVgzUyxHQUNIQSxFQUFLdVYsVUFDTCxTQUdDNUMsTUFBS0UsUUFBUSxTQUFDN1MsS0FDZHVWLFVBQVkzSCxxQ0FJWjVOLFVBQ3dCLElBQXhCMlMsS0FBSzFTLFFBQVFELHVDQWdCVnlNLEtBQ0F6RyxFQUFPeUcsR0FBU3pNLEtBQUssTUFFM0I0RixHQUFTNkcsRUFBUTdHLGVBRWhCQSxHQUFPL0YsVUFJRjRNLEVBQVErSSxPQUFPLEtBQ2hCNVAsRUFBTyxHQUVUK00sS0FBS0UsUUFBUSxTQUFDN1MsTUFDZkEsSUFBU3lNLGdCQUNEQSxFQUFRNUksWUFLaEI0SSxLQUNLZ0osYUFBYXpWLEVBQU15TSxLQUVuQmlKLFlBQVkxVixNQWhCZDJTLDBDQWtDRWxHLEtBQ0R6RyxFQUFPeUcsR0FBU3pNLEtBQUssTUFFM0I0RixHQUFTNkcsRUFBUTdHLGVBRWhCQSxHQUFPL0YsVUFJRjRNLEVBQVEsS0FDVDdHLEVBQU8sR0FFVCtNLEtBQUtFLFFBQVEsU0FBQzdTLEtBQ1p5VixhQUFhelYsRUFBTXlNLE1BUG5Ca0csa0NBeUJObEcsTUFBU2tKLHFFQUNGM1AsRUFBT3lHLEdBQVMsS0FJckJqSCxFQUFlaUgsU0FFWGtHLFVBR0pnRCxHQUFPbEosRUFBUW1KLFdBQVksS0FDekIsR0FBSWhXLEdBQUkrUyxLQUFLOVMsT0FBUyxFQUFHRCxHQUFLLEVBQUdBLE1BQzVCNlYsYUFBYTlDLEtBQUsvUyxHQUFJNk0sRUFBUW1KLGtCQUdqQ2pELFlBR0ZBLE1BQUtFLFFBQVEsU0FBQzdTLEtBQ1gwVixZQUFZMVYsZ0NBbUJyQmlHLE9BQ0kwTSxLQUFLOVMsY0FDRCxLQUdIRyxHQUFPMlMsS0FBSyxHQUNaa0QsRUFDSjdWLEVBQUs2VixTQUNGN1YsRUFBSzhWLGlCQUNMOVYsRUFBSytWLHVCQUNML1YsRUFBS2dXLG9CQUNMaFcsRUFBS2lXLG1CQUNMalcsRUFBS2tXLDJCQUlETCxHQUFRTSxLQUFLblcsRUFBTWlHLEdBQzFCLE1BQU8wQyxrQkFDQ0MsbUJBQW9CM0MsMENBRXJCLHFDQWNIakcsR0FBTzJTLEtBQUssU0FFWDNTLElBQVFBLEVBQUswRSxTQUNoQjFFLEVBQUswRSxTQUFTMUIsa0JBQ2QyRCx3Q0FhR2dNLE1BQUtXLFFBQVEzUCw4QkF5Q25COFEsRUFBTzJCLEdBQ0pqVSxFQUFTc1MsYUFDQUEsRUFBUTJCLE9BR2ZDLE1BQ0FDLGNBRVE3QixFQUFPLFNBQUMyQixFQUFVM0IsS0FDakJBLEVBQU1sUixNQXgwQkssYUF3MEJ5QixTQUFDa1IsSUFDL0M0QixFQUFVNUIsR0FBUzRCLEVBQVU1QixRQUFjN0ssS0FBS3dNLFlBSWhEdkQsUUFBUSxTQUFDN1MsS0FDRXFXLEVBQVcsU0FBQ0UsRUFBVzlCLEtBQ3RCOEIsRUFBVyxTQUFDSCxLQUNsQkksaUJBQWlCL0IsRUFBTzJCLEdBQVUsSUFDdENFLEVBQWE3QixHQUFTNkIsRUFBYTdCLFFBQWM3SyxLQUFLLGFBQ2hENk0sb0JBQW9CaEMsRUFBTzJCLFdBTWpDLFNBQThCM0IsR0FDL0JoVSxVQUFVWixTQUNDWSxVQUFXLFNBQUNnVSxLQUNWQSxFQUFNbFIsTUEzMUJDLGFBMjFCNkIsU0FBQ2tSLE1BQzFDaUMsR0FBa0JKLEVBQWE3QixFQUVqQ2lDLE9BQ1dBLEVBQWlCLFNBQUNDLFNBQW1CQSxhQUUzQ0wsR0FBYTdCLFVBS1o2QixFQUFjLFNBQUNJLEVBQWlCakMsS0FDL0JpQyxFQUFpQixTQUFDQyxTQUFtQkEsYUFFM0NMLEdBQWE3Qiw2Q0FhbkI5QixNQUFLVyxRQUFReFAsd0NBYWI2TyxNQUFLVyxRQUFRdFAsZ0NBaUJqQlYsRUFBVTdELFNBQ1RnQixXQUFVWixRQUFVLEdBQUtzQyxFQUFTbUIsR0FDN0JxUCxLQUFLLEdBQUtBLEtBQUssR0FBR3JQLE9BQVlxRCxJQUduQ2xHLFVBQVVaLFFBQVUsWUFDUnlELEVBQVc3RCxJQUdwQmtULEtBQUtFLFFBQVEsU0FBQzdTLEtBQ0xzRCxFQUFVLFNBQUM3RCxFQUFPOEUsS0FDekJBLEdBQVE5RSw4Q0FnQlZrVCxNQUFLRSxRQUFRbE4sOERBY2JnTixNQUFLRSxRQUFRLFNBQUM3UyxPQUNLLFNBQUNtRCxNQUNqQnVJLEdBQUtqSCxFQUFVdEIsRUFBTW5ELEVBRXZCMEwsS0FDR2tMLGtCQUFrQmxMLEVBQUl2SSxLQUV0QjBULGdCQUFnQjFULG1FQWlCcEJ3UCxNQUFLRSxRQUFRLFNBQUM3UyxNQUNiOFMsR0FBTzlTLEVBQUsrUyxjQUVNLFNBQUMxRSxTQUFReUUsR0FBS25OLE9BQU8wSSxpRUFleENzRSxNQUFLRSxRQUFRLFNBQUM3UyxPQUNLLFNBQUNxRCxLQUNsQjRRLE1BQU1JLGVBQWUxUixFQUFhVSx3Q0FtQnJDb0osS0FDSXpHLEVBQU95RyxNQUVYcUssR0FBUW5FLEtBQUszUyxLQUFLLEdBQ2xCNEYsRUFBU2tSLEVBQU1sUixhQUVoQkEsRUFBTy9GLGFBQ0g4UyxTQUdMM1MsR0FBTzRGLEVBQ1BtUixFQUFTLE9BQ1B2QixFQUFPc0IsRUFBTXRCLE9BQU8sR0FDcEJ3QixFQUFPRixFQUFNRSxPQUFPLEVBRXRCeEIsTUFDS0EsSUFDRSxnQkFDQXdCLE1BQ0ZBLElBQ0UsaUJBR0xyUixXQUVFb1IsR0FBUS9XLHdDQWNUMlMsTUFBS0UsUUFBUS9NLHlDQUliLElBQUloQixHQUFLbVMsMkVBQVlDLE1BQU12RSxLQUFNbFMseUNBZXJDK0QsU0FDRS9ELFdBQVVaLE9BSVI4UyxLQUFLRSxRQUFRLFNBQUM3UyxLQUNkbVgsWUFBYzNTLElBSlptTyxLQUFLcE8sS0FBSyxrREFzQlZwQixFQUFNaVUseUJBQ1J6RSxNQUFLRSxRQUFRLFNBQUM3UyxLQUNaLEdBQUk4RSxHQUFLOUUsSUFFWnFYLEVBQVV4WCxPQUFTLEdBQUtHLEVBQUs2UCxRQUFRMU0sR0FBUWlVLEtBQzFDalUsS0FBS0EsRUFBTSxNQUVYOEYsV0FBVzlGLHlDQW1CVmtMLEVBQUsrSSx5QkFDUnpFLE1BQUtFLFFBQVEsU0FBQzdTLE1BQ1grUyxHQUFjL1MsRUFBZCtTLFlBRUV1RSxPQUFPakosRUFBS2tKLEVBQVUxWCxPQUFTLEdBQUtrVCxFQUFVVyxTQUFTckYsR0FBTytJLFlBeGxDM0QzRixNQTZsQ25CNVAsR0FBZWlELEdBQU0sUUFFakIvQyxJQUFVQSxHQUFPeVYsWUFDRjFTLFNBQ2QvQyxHQUFPeVYsOEJBRUcvRixVdkJ2cUNmLElBQU1wSyxJQUFjLElPSWhCdUQsVUNhRTJCLEdBQXNCLDRCRWpCcEJrQyxNQUFBQSxjY01GeEgseUJBZVFpQyw0QkFFUjFILEdBU0UwSCxFQVRGMUgsS0FDQS9CLEVBUUV5SixFQVJGekosTUFDQTBJLEVBT0VlLEVBUEZmLFFBQ0FuSSxFQU1Fa0osRUFORmxKLEtBQ0F1RyxFQUtFMkMsRUFMRjNDLEtBQ0E2QixFQUlFYyxFQUpGZCxRQUNBQyxFQUdFYSxFQUhGYixZQUNBQyxFQUVFWSxFQUZGWixZQUNBQyxFQUNFVyxFQURGWCxlQUVJNEIsS0FDQW5DLE9BRWlCMkssd0JBR1hsVCxvQkFFRzBJLHdGQU1BLFdBQ0QsU0FBQ0YsU0FLTHdLLEVBQUsxSyxHQUhQeUIsSUFBQUEsVUFDQS9KLElBQUFBLE1BQ0FnWSxJQUFBQSxPQUVJQyxFQUFlbE8sRUFDakIvSixFQUNBNkksRUFBWVAsR0FBR1MsU0FBU2lQLFNBRXhCeFAsTUFDTzJCLEtBQUszQixHQUdUeVAsVUFFRCxTQUFDQyxLQUNGNVAsR0FBRzZQLFdBQVksS0FFTHpOLFNBR1IwTixlQUNMLE1BQU9sUCxXQUNDQywyQkFBNEJwSCxtQkFBdUJtSCxJQUd4RGdQLEdBQWtCdFAsS0FDTEEsRUFBWU4sR0FBR2YsbUJBV2xDVCxLQUFPQSxPQU9QNkIsUUFBVUEsT0FPVkMsWUFBY0EsT0FPZEMsWUFBY0EsT0FPZEMsZUFBaUJBLE9BT2pCdkksS0FBT0EsT0FPUGtMLEtBQU9sTCxFQUFLLEdBRWJxSSxLQUNVTixHQUFHZixPQUFPNEMsS0FBSytJLGdGQW5IaEJtRiwrQ0FDTkEsR0FBU0MsT0FBTzVJLEdBQVd3RCw4SEFpSTNCcFQsU0FDQW9ULE1BQUs1SyxHQUFHUyxTQUFTakosV0E5SXRCMEgsSUFDR3VCLFVBQVcsRUFpSnBCM0csRUFBZW9GLEdBQU8sUUM1RXRCLElBQU0rUSxPQUNBQyxNQUNBQyxHQUFpQiw0Q0FDakJDLEdBQWtCLDZCQUNsQkMsR0FBMkIsVUFDM0JDLEdBQThCLGFBQzlCQyxHQUFZLEdBQUl4VCxJQXFDaEI4Ryx5QkEyUVExQyw0QkFFUjFILEdBVUUwSCxFQVZGMUgsS0FDTStXLEVBU0pyUCxFQVRGM0MsS0FDQTJGLEVBUUVoRCxFQVJGZ0QsV0FDQUgsRUFPRTdDLEVBUEY2QyxTQUNBbkcsRUFNRXNELEVBTkZ0RCxPQUNBd0YsRUFLRWxDLEVBTEZrQyxXQUNBL0MsRUFJRWEsRUFKRmIsWUFDQUMsRUFHRVksRUFIRlosWUFDQUMsRUFFRVcsRUFGRlgsZUFDQThDLEVBQ0VuQyxFQURGbUMsVUFFSWxCLEtBQ0E2QixFQUFjOEYsR0FBU2EsTUFBTTNHLFlBQzdCd00sS0FDQXhSLEtBQ0FrRyxFQUFnQnRILFlBQWtCZ0csS0FFakIrRyxRQU9sQkEsbUhBMEJRLEdBQUk3TixPQUNUa0gsZUFDVUQsV0FDSnlNLHFEQUlDLGNBQ0MsV0FDRixTQUFDQyxFQUFNQyxFQUFVQyxFQUFhQyxFQUFjQyxFQUFVQyxPQUN6RDdXLEVBQVd3VyxTQUNQQSxPQUdRRyxNQUNKQyxLQUVQL08sR0FBa0IsWUFBVHRJLElBQXVCcVgsR0FBYUMsR0FDOUNBLE1BQWtCL1EsR0FBRytCLFVBRUc2TyxFQUFjQSxFQUFZNVEsTUFBL0NvQyxJQUFBQSxpQkFDRjRPLElBQWlCTCxRQUVOLFNBQVhsUSxRQUNBd1EsU0FFQUQsUUFDSXRPLFVBQVcsS0FDWEMsc0JBSUcrTixFQUFLM08sR0FDZCxNQUFPbkIsUUFDSHNRLFdBQWFSLEVBQUtRLGFBQ2xCQyxTQUFXVCxFQUFLUyxXQUNoQnRLLFFBRUEzTSxFQUFXK0osRUFBWW1OLG1CQUVYQSxZQUFZeFEsR0FDeEIsTUFBT3lRLFdBQ0N4USxNQUFNLGlDQUFrQ3dRLE9BS2xETCxFQUFjLElBQ1ZNLFFBRU83TyxHQUFNRSxZQUFhLFNBQUMxQyxNQUN6QkMsR0FBVSxjQUNScVIsR0FBWTlRLEdBRWQ4USxLQUFjTixHQUFXTCxFQUFZNVEsR0FBRzZQLGFBQ2pDMEIsRUFBV04sSUFHbEJPLDBDQU1FdFAsU0FBVyxhQUNKb1AsRUFBZSxTQUFDRSxNQUV6QnRSLEdBRUVzUixFQUZGdFIsUUFDQUQsRUFDRXVSLEVBREZ2UixXQUdjbUMsRUFBa0JvUCxLQUNsQnZSLEVBQVVDLFFBSWhCMkIsS0FBSzJQLEtBQ0YzUCxLQUFLMlAsS0FDYjNQLEtBQUszQixRQUdWd0MsVUFBVyxLQUNYQyxxQkFHRHNPLGNBS0gsU0FBQ3JCLEtBQ0Y1UCxHQUFHNlAsV0FBWSxLQUVMek4sS0FFRnFPLEVBQWdCOUosTUFDaEIxSCxFQUFRMEgsVUFHZG1KLGVBQ0wsTUFBT2xQLFdBQ0NDLDJCQUE0QnBILG1CQUF1Qm1ILElBR3hEZ1AsR0FBa0J6SyxLQUNkbkYsR0FBR3lSLGNBQWNDLEVBQUsxUixHQUFHaUYsVUFHN0IySyxHQUFrQnRQLEtBQ0xBLEVBQVlOLEdBQUdnRSxjQUc1QmhFLEdBQUdpRixRQUFRckgsd0JBRUgsU0FBQytULFFBQ1QzUixHQUFHaUYsUUFBVTBNLEVBRWRELEVBQUsxUixHQUFHbUcsaUJBRUh5TCxpQkFDTCxNQUFPaFIsV0FDQ0MsMkJBQTRCcEgseUJBQTZCbUgsZ0JBSTNELFNBQUNpUixFQUFjQyxNQUNuQkMsR0FBYUwsRUFBSzFSLEdBQUdpRixRQUNyQnROLEVBQVFvYSxFQUFXN1osUUFBUTJaLEVBQWEsR0FBRzNWLGlCQUFtQixFQUNoRXlWLFdBRVUsSUFBVmhhLEVBQ1drYSxFQUFhaFcsSUFBSWtXLEdBRWpCQSxFQUNWN1ksTUFBTSxFQUFHdkIsR0FDVGtFLElBQUlnVyxFQUFjRSxFQUFXN1ksTUFBTXZCLE1BR25DcUksR0FBR2dTLGNBQWNMLEdBRWxCeE0sSUFBa0IyTSxLQUNiOVIsR0FBR3NGLFdBQVd1TSxFQUFjQyxnQkFHMUIsU0FBQ0csRUFBZUMsTUFDckJILEdBQWFMLEVBQUsxUixHQUFHaUYsUUFDckJ0TixFQUFRb2EsRUFBVzdaLFFBQVErWixFQUFjLElBQ3pDRSxFQUFhSixFQUFXN1osUUFBUWdhLEVBQU0sSUFBTSxFQUM5Q1AsV0FFZSxJQUFmUSxFQUNXRixFQUFjcFcsSUFDekJrVyxFQUFXN1ksTUFBTWlaLEVBQVl4YSxHQUM3Qm9hLEVBQVc3WSxNQUFNdkIsRUFBUXNhLEVBQWNuYSxTQUVoQ0gsRUFBUXdhLEVBQ0pKLEVBQ1Y3WSxNQUFNLEVBQUdpWixHQUNUdFcsSUFDQ29XLEVBQ0FGLEVBQVc3WSxNQUFNaVosRUFBWXhhLEdBQzdCb2EsRUFBVzdZLE1BQU12QixFQUFRc2EsRUFBY25hLFNBRzlCaWEsRUFDVjdZLE1BQU0sRUFBR3ZCLEdBQ1RrRSxJQUNDa1csRUFBVzdZLE1BQU12QixFQUFRc2EsRUFBY25hLE9BQVFxYSxHQUMvQ0YsRUFDQUYsRUFBVzdZLE1BQU1pWixNQUlsQm5TLEdBQUdnUyxjQUFjTCxHQUVsQnhNLEdBQWlCZ04sS0FDWm5TLEdBQUdvUyxZQUFZSCxFQUFlQyxrQkFHMUIsU0FBQ0csS0FDVHJTLEdBQUdnUyxjQUFjTixFQUFLMVIsR0FBR2lGLFFBQVFxTixPQUFPLFNBQUNyYSxVQUNULElBQW5Db2EsRUFBZ0JuYSxRQUFRRCxNQUd0QmtOLEtBQ0tuRixHQUFHeVIsY0FBY1ksc0JBR1QsU0FBQ0UsRUFBaUJDLE1BQzNCbFAsR0FBY29PLEVBQUsxUixHQUFuQnNELFVBQ0o0TyxFQUFRM0IsTUFFUmpOLFlBQXFCTyxLQUNmUCxFQUFVdEQsR0FBR29GLGNBQWNtTixFQUFpQkMsT0FDL0MsSUFBSWxQLElBQ0RBLElBQ1ErQixZQUFZL0IsR0FFeEI2QixJQUNFcU4sSUFDS3hTLEdBQUdvUyxZQUFZRyxFQUFpQkwsS0FFaENsUyxHQUFHc0YsV0FBV2lOLEdBQWlCLFFBR3JDLElBQUlwTixFQUFlLElBQ2hCN0IsR0FBY3pGLEVBQU9tQyxHQUFyQnNELGFBRUpBLEVBQVcsSUFDVHdPLFNBRUF4TyxhQUFxQk8sTUFDZlAsRUFBVXRELEdBQUdvRixjQUFjbU4sRUFBaUJDLE1BQ3JDLE1BRVBsUCxLQUNPLElBQ0MrQixZQUFZL0IsSUFHMUJrUCxJQUNLeFMsR0FBR29TLFlBQVlHLEVBQWlCTCxLQUVoQ2xTLEdBQUdzRixXQUFXaU4sRUFBaUJULFVBR2hDalUsRUFBT21DLEdBQUd1RixrQkFBa0JnTixFQUFpQkMsVUFHdkNoTixLQUFLbkMsR0FBWSxTQUcvQm1QLEtBQ0d4UyxHQUFHb1MsWUFBWUcsRUFBaUJMLEtBRWhDbFMsR0FBR3NGLFdBQVdpTixHQUFpQixHQUcvQkwsaUJBRU0sU0FBQ0ssRUFBaUJDLE1BQ3ZCbFAsR0FBY29PLEVBQUsxUixHQUFuQnNELFVBQ0o0TyxFQUFRM0IsR0FDUmtDLGVBRUFmLEdBQUsxUixHQUFHaUYsUUFBUW5OLFVBQ1Y0WixFQUFLMVIsR0FBR2lGLFFBQVFoTixNQUFNLE1BQ2IsSUFDRG9OLFlBQVk2TSxJQUNuQjVPLFlBQXFCTyxLQUN0QlAsRUFBVXRELEdBQUdvRixjQUFjbU4sRUFBaUJDLEdBQzNDbFAsS0FDREEsS0FDUyxJQUNEK0IsWUFBWS9CLElBQ25CNkIsSUFDRHRILEVBQU9tQyxHQUFHdUYsa0JBQWtCZ04sRUFBaUJDLEtBRXJDaE4sS0FBS25DLEdBQVksR0FHL0I4QixHQUFpQnNOLElBQ2ZELElBQ0t4UyxHQUFHb1MsWUFBWUcsRUFBaUJMLEtBRWhDbFMsR0FBR3NGLFdBQVdpTixJQUlsQkwsUUFLQ2pPLEVBQVl5TyxjQUFlLFNBQUNoYixFQUFPYSxLQUMxQ0EsR0FBWWIsTUFFTnVNLEVBQVl3RCxNQUFPLFNBQUNsUCxLQUMxQkEsR0FBWW1aLEVBQUtuWixRQUdsQmtHLEdBQWFsQyxHQUFPLE1BQ3RCaUMsRUFBT2pDLEdBQU8wSCxFQUFZME8sYUFBZSxNQUN6Qy9OLFdBRVU0TCxFQUFjLFNBQUM5WSxFQUFPaUgsTUFDNUJrRyxHQUFVbkYsR0FBYTVDLEtBQUs2QixHQUM1QmlVLEVBQVkvTixHQUFXRCxFQUN6QnJJLEdBQU9pQyxHQUNQQSxPQUVHb1UsRUFFSC9OLEVBQVMsSUFDTGdPLEdBQVd0UyxFQUFZUCxHQUFHUyxTQUFTL0ksRUFBTyxTQUFDQSxLQUNqQ2tiLEVBQVcvVCxLQUNsQitULEVBQVdqVCxFQUFrQmpJLE1BQ3RCOEcsRUFBTUMsaUJBR1gsRUFFSmpHLEVBQU9vYSxFQUFXalQsRUFBa0JrVCxPQUd2Q0MsR0FBdUIsZUFBVHJaLEVBQ2RvWCxFQUFlaUMsR0FBdUIsVUFBUm5VLEtBRXpCLEVBRUUsV0FBVGxGLEdBQTZCLFFBQVJrRixNQUNmNEIsRUFBWVAsR0FBR1MsU0FBUy9JLEVBQU8sU0FBQ0EsS0FDNUJpSCxHQUFPakgsSUFDSDhHLEVBQU1DLE1BQ2JvUyxFQUFjaUMsR0FBdUMsWUFBeEJ4UyxFQUFZTixHQUFHdkcsU0FHN0NrRixHQUFPakgsTUFHSWtULFdBTWZuTSxVQU9HbEMsR0FDUGdFLEVBQ0lBLEVBQVl5QixRQUNaLFVBSU14RCxFQUFNQyxHQUVoQjZCLEtBQ1VOLEdBQUdnRSxTQUFTbkMsS0FBSytJLDBEQWxuQmRoSyxXQUNUQyxpQ0FBa0NELEVBQUlzUSxxQ0FBc0N0USxFQUFJaUcsTUFBTTdHLEdBQUd2RyxXQUFZbUgsK0NBUXBGbVMsYUFDZGxSLEtBQUtrUixHQUVULGFBQ1c5QyxHQUFZOEMsZ0RBU0xBLGFBQ2RsUixLQUFLa1IsR0FFVCxhQUNXN0MsR0FBWTZDLGtDQVluQnRaLEVBQU1nTixpQkFDYnZNLEVBQVd1TSxLQUFjRixHQUFhMUMsRUFBTzRDLEdBQVcsSUFDcER4QyxHQUFjd0MsMkJBR050Riw4RUFDSkEsb0JBRVlBLHVCQUpHMEMsT0FTdEIzSixFQUFXdU0sSUFBYWpKLEdBQVFpSixHQUFXLGlKQUNyQjVDLEtBQ2hCK0Usd0JBRUVuQyxXQUtSdk0sRUFBV3VNLElBQWFBLEVBQVNuTyxNQUFRbU8sRUFBUy9PLE1BQU8saUpBQ25DbU0sS0FDaEIrRSxTQUFXbkMsVUFJakJ2TSxFQUFXdU0sdUJBQ051TSx1SEFBd0h2Wix5QkFLN0g4TSxHQUFhMUMsRUFBTzRDLE9BQ1hBLEdBR1Y0RCxHQUFXNVEsdUJBQ0x1WixhQUFjdlosdUZBS25CMFcsR0FBZXJULEtBQUtyRCx1QkFDZnVaLGNBQWV2WixrRkFLcEJOLEdBQWV5UixLQUFNLGtCQUNuQmhILFFBQVVySCxHQUFPd04sR0FBU2EsTUFBTWhILFVBR2xDekssRUFBZXlSLEtBQU0sd0JBQ25COEgsa0JBR0Z2WixFQUFleVIsS0FBTSxzQkFDbkIrSCxZQUFjcFcsR0FBTyxhQUlmMFQsR0FBV0QsT0FBTyxTQUFDN0ksRUFBYTRMLE1BQ25DRSxHQUFxQkYsRUFBSzVMLEVBQWExTixXQUV0QzhNLElBQWExQyxFQUFPb1AsR0FDdkJBLEVBQ0E5TCxHQUNIVixHQUNILE1BQU83RixXQUNDQyxNQUFNLGdEQUFpREQsU0FNN0Q2RixFQUFTbUMsU0FGWHRRLElBQUFBLEtBQ0FaLElBQUFBLGVBR09vTyxNQUFRcE8sSUFDUitQLE1BQVFuUCxFQUViYSxFQUFlc04sRUFBVSxtQkFDbEJBLEVBQVNrTSxZQUFhLFdBRzVCL08sUUFBUW5LLEdBQVFnTixFQUVkQSwrQkFVR2EsTUFDSjRMLEdBQVF0SSxxRUFFMkN0RCxpQ0FXOUM3TixFQUFNZ04saUJBQ2J2TSxFQUFXdU0sS0FBY0YsR0FBYXJILE1BQU91SCxHQUFXLElBQ3BEOUYsR0FBYzhGLDZLQUdOL0YsRUFBVVgsZUFDRlcsRUFBVVgsRUFBVTZLLGFBRmpCMUwsV0FPdEJxSCxHQUFhckgsTUFBT3VILHVCQUNmdU0sYUFBY3ZaLCtFQUtwQjZRLEdBQVc3USx1QkFDTHVaLGFBQWN2Wix1RkFLbkIyVyxHQUFnQnRULEtBQUtyRCx1QkFDaEJ1WixjQUFldlosa0ZBS3BCTixHQUFleVIsS0FBTSxrQkFDbkI3RyxRQUFVeEgsR0FBT3dOLEdBQVNhLE1BQU03RyxnQkFJMUJtTSxHQUFXRixPQUFPLFNBQUM3SSxFQUFhNEwsTUFDbkNFLEdBQXFCRixFQUFLNUwsRUFBYTFOLFdBRXRDOE0sSUFBYXJILE1BQU8rVCxHQUN2QkEsRUFDQTlMLEdBQ0hWLEdBQ0gsTUFBTzdGLFdBQ0NDLE1BQU0sZ0RBQWlERCxZQUd4RHhCLE9BQVNOLEVBQW9CckYsUUFFakNzSyxRQUFRdEssR0FBUWdOLEVBRWRBLDREQTRCTXNKLCtDQUNOQSxHQUFTQyxPQUFPL0ksR0FBVzJELGdPQXNiM0JBLE1BQUs1SyxHQUFHbVQsT0FBT2phLHVEQVVmMFIsTUFBSzVLLEdBQUdmLE9BQU8vRixvREFVZjBSLE1BQUs1SyxHQUFHb1Qsb0RBVVJ4SSxNQUFLNUssR0FBR2lGLFFBQVEvTCx1REFVaEIwUixNQUFLNUssR0FBR00sMERBVVJzSyxNQUFLNUssR0FBR3FELFdBQVduSyx1REFVbkIwUixNQUFLNUssR0FBR08sOERBVVJxSyxNQUFLNUssR0FBR1EsZ0RBWVJrUSxFQUFNbFosTUFBVWlCLDBEQUFTbVMsV0FDekJBLE1BQUs1SyxHQUFHUyxTQUFTaVEsRUFBTWxaLEVBQVVpQixxRUFvQ2pDSCw0Q0FDRCthLEdBQWEzYSxVQUFVQSxVQUFVWixPQUFTLE9BRTNDb0MsRUFBV21aLHVCQUNOTCxzREFBdURwSSxLQUFLNUssR0FBR3ZHLG1CQUtuRXlHLEdBQVUsbUJBSVMsSUFBckJ4SCxVQUFVWixpQkFDTThTLEtBQU0xSyxNQUNSMEssS0FBTTFLLE1BQ0gwSyxLQUFNMUssY0FPZHhILFVBQVcsU0FBQ0gsTUFDbkJBLElBQWE4YSxNQU1BLFlBRkY5YSxTQUdOcU8sTUFBd0IxRyxNQUdoQixTQUFiM0gsUUFDS3lPLE1BQXNCOUcsTUFHZCxZQUFiM0gsUUFDS3VPLE1BQXlCNUcsTUFHOUJtUSxHQUF5QnZULEtBQUt2RSxHQUFXLE1BQ2hDQSxFQUFTZ0MsUUFBUThWLEdBQTBCLEtBRWpEaUQsRUFBS3RULEdBQUd4QixLQUFLakcsd0JBSWJ5SCxHQUFHeEIsS0FBS2pHLEdBQVUwSCxTQUFTZ0QsS0FBS3BCLEtBQUszQixNQUt4Q29RLEdBQTRCeFQsS0FBS3ZFLEdBQVcsTUFDbkNBLEVBQVNnQyxRQUFRK1YsR0FBNkIsS0FFcERnRCxFQUFLdFQsR0FBR2dDLFFBQVF6SixhQUliMEgsR0FBYXFULEVBQUt0VCxHQUFHZ0MsUUFBUXpKLEdBQTdCMEgsa0JBRUNnRCxLQUFLcEIsS0FBSzNCLFVBQ2RGLEdBQUdvQyxpQkFBaUJQLDZCQVF0QnlSLEVBQUt0VCxHQUFHMEYsT0FBT25OLE1BSWZ5SCxHQUFHMEYsT0FBT25OLEdBQVUwSCxTQUFTZ0QsS0FBS3BCLEtBQUszQixrQkFqNEI1QzJELElBQ0dELFFBQVVySCxHQUFPOE4sSUFEcEJ4RyxHQUVHRSxRQUFVeEgsR0FBTytOLElBRnBCekcsR0FVRzhPLFlBQWMsS0FWakI5TyxHQWtCRzZPLGNBQWdCLEtBbEJuQjdPLEdBMEJHK0UsNEJBODJCVDlPLEVBQWUrSixHQUFPLFNBQ3RCb0csR0FBU3BHLEdBQU01SixVQUFXLGVDaGdDMUJvUSxJQUlXLHNNQXFCSE8sS0FBSzVLLE9BVlBPLFlBQ0VQLEdBQ2V1VCxJQUFiaFQsWUFDZ0JpVCxJQUFoQmhULGVBQ2N3RCxJQUFkb1AsYUFHVUssSUFBZEwsYUFDQTVTLElBQUFBLGVBQ0EyRCxJQUFBQSxXQUVFdVAsYUFFQUQsRUFBWTNiLGVBSVg2YixZQUFjSjt5Q0FDZEssZUFBaUJKLEVBRWxCclAsRUFBWSxRQUNOdk0sRUFBWW9NLEVBQVUscUJBQUd2SyxrQkFBOEMwSyxLQUVuRSxRQUNOdEcsR0FBUytNLE1BSVovTSxFQUFTQSxFQUFPbUMsR0FBR08sZ0JBQ2ZtVCxFQUFROWIsRUFBWWlHLEVBQU9tQyxHQUFHNlQsUUFBUyxxQkFBRzdULEdBQU1tRSxhQUE4Q0EsTUFDOUQsWUFBbEN0RyxFQUFPbUMsR0FBR08sWUFBWVAsR0FBR3ZHLE9BR3hCaWEsU0FDR0MsWUFBYzlWLE9BQ2QrVixlQUFpQnBULElBQ2hCOUksZ0JBQ01nYyxFQUFNaGMsTUFBTXNJLEdBQUdvVCxvQkFLMUJ2SSxNQUFRNkksR0FBU0EsRUFBTWhjLE1BQU1zTSxTQUFTbE0sT0FDdkM0YixFQUFNaGMsTUFBTXNNLFNBQ1osZUFFQzZHLE1BQVE3RyxTQXpEMEJILE9BQ3BDK0Usb09DSFQsSUFBTUEsdUxBUUFrTCx1SUFBY2pRLEdBQWRpUSxJQUNHbEwsU0FBV0EsR0FEZGtMLEdBRUdyTSxNQUFRbUIsR0FBU3RRLEtBRnBCd2IsR0FHR2hPLE1BQVE4QyxHQUFTbFIsZ0JDSnBCcWMsZ0VBTU4xSixJQUFXLHFDQUNHbEosOEVBQ0pBLHVCQUdKM0MsU0FDRXdILEtBQU1ELGFBQVcsY0FDakJwTyxNQUFPc08sYUFBWSxvQkFJaEJ5RSxFQUFLMUssdUJBRUwwSyxFQUFLbE0sS0FBS3dWLFNBQU9wViw0RkFPbkI2QixTQUFTc1QsR0FBV25KLEtBQUtxSixnQkFDekJBLG1CQXJCa0NwUSxrQ0F3QnpDb1EsVUFBWSxpQkFXTkMsRUFBS2xVLEdBVFBvVCxJQUFBQSxhQUNBZSxJQUFBQSxZQUNBNVQsSUFBQUEsWUFDQThDLElBQUFBLFdBQ0E3QyxJQUFBQSxlQUNBdUIsSUFBQUEsTUFDQWdFLElBQUFBLFNBQ0FFLElBQUFBLFVBQ0FtTyxJQUFBQSxJQUdRQyxJQUFSN1YsS0FBUTZWLE9BRUpDLEtBQ0FDLEtBQ0FDLE9BSUZOLEVBQUsxVixLQUZQaVcsSUFBQUEsSUFDQUMsSUFBQUEsU0FFSUMsRUFBUW5YLEdBQVFpWCxHQUNoQkcsRUFBVUQsRUFDWjVjLEVBQ0FzQixDQUVBc2IsSUFBU3phLEVBQVdtYSxPQUNoQkksRUFDSHZiLFFBQ0EyYixLQUFLUixJQUdObmEsRUFBV3dhLFFBQ0RBLElBR1ZsWCxHQUFRa1gsTUFDR0EsRUFBVSxTQUFDcEMsS0FDaEJtQyxFQUFJbkMsT0FBT0EsT0FJYm1DLEVBQUssU0FBQ3pPLEVBQU1yTyxLQUNab08sR0FBWUMsSUFDWkMsR0FBYXRPLEtBRWJxYyxHQUFNelQsRUFBWVAsR0FBR1MsU0FBUzJULEVBQUssS0FBTSxNQUFNLEdBQU8sT0FFN0NKLElBQVFPLEVBQWVQLElBQVEsR0FBSyxJQUMzQ3JjLEdBQVNxYyxNQUdiak8sR0FBWSxPQUNaRSxHQUFhLE9BRUxrTyxFQUFhLFNBQUNXLEVBQU9kLE9BQzVCTyxFQUFlUCxpQkFDTGMsRUFBT2xYLE1BS1RrWCxFQUFNM2MsT0FBT29jLEVBQWVQLElBQU9wVyxTQUc5QzBGLFlBRUltUixFQUFLLFNBQUN6TyxFQUFNck8sTUFDWnFjLEdBQU1RLEVBQVE3YyxHQUNoQmtQLFFBRUFzTixHQUFZSCxJQUFRRyxFQUFZSCxHQUFLbGMsVUFDL0JxYyxFQUFZSCxHQUFLZSxVQUNuQi9VLEdBQUcrQixNQUFNa0UsR0FBYXRPLElBQ3RCcUksR0FBRytCLE1BQU1nRSxHQUFZQyxFQUV2QmEsRUFBTTdHLEdBQUdzRCxZQUFjQSxHQUFhQSxLQUM1QnRELEdBQUdvRixjQUFjeUIsRUFBTTdHLEdBQUdpRixTQUFTLE1BR3ZDL0IscURBTUUsbUJBQ0lrUSxlQUVDVSxxRkFVaEJRLEVBQWVOLEdBQU9NLEVBQWVOLFFBQVluUyxLQUFLZ0YsS0FDakQ3RyxHQUFHc0QsVUFBWUEsSUFDVHVELE1BR1Q3RyxHQUFHbVUsWUFBY0csT0MxSTFCLElBQU1QLG9DQUVOMUosSUFBVyx1TUFFQ2hILEVBQWV1SCxLQUFLNUssR0FBcEJxRCxhQUtKdUgsS0FBS3BNLEtBSFA0RSxJQUFBQSxZQUNBN0MsSUFBQUEsWUFDQUMsSUFBQUEsb0JBR0dSLEdBQUdTLFNBQVNzVCxHQUFXLGlCQU90QkcsRUFBS2xVLEdBTFBnRSxJQUFBQSxTQUNBL0UsSUFBQUEsT0FDQXBCLElBQUFBLE9BQ0F1RSxJQUFBQSxpQkFDQTZDLElBQUFBLFFBRU12TixFQUFVd2MsRUFBSzFWLEtBQWY5RyxRQUVLc00sRUFBVTJDLE1BQ1YxSCxFQUFRMEgsTUFDYi9JLFNBRUpDLFlBQWtCZ0csT0FDYjdELEdBQUd5UixjQUFjeE0sS0FHckJqRixHQUFHZ0UsY0FDSGhFLEdBQUdmLFlBQ0hlLEdBQUdvQyxpQkFBbUJBLEVBQWlCa1EsT0FBTyxlQUFHclMsS0FBQUEsU0FBVUMsSUFBQUEsYUFBUzJRLG9CQUU5RCxJQUdPNVEsRUFBVUMsT0FFdkJGLEdBQUdpRixRQUFVLEdBQUlsSSxPQUVsQnVHLFlBRVM1TCxNQUFhLFNBQUN3TixLQUNiaEMsU0FDSmdDLG9HQVVUMEYsTUFBTSxVQXBEc0MvRyxhQ1JuRHdHLElBSVcsc0NBU0dsSiw4RUFDSkEsTUFLRnVKLEVBQUsxSyxHQUZQTyxJQUFBQSxZQUNBNlMsSUFBQUEsYUFFRXpiLEVBQVFxZCxFQUFBQSxFQUNOaFMsRUFBU29RLEVBQWF4SixJQUFJLFNBQUMxRSxFQUFPck4sTUFFcEM0QixHQUdFeUwsRUFIRnpMLE9BR0V5TCxFQUZGL0osTUFBQUEsa0JBQ0E2SSxFQUNFa0IsRUFERmxCLFNBRUVpUixFQUFPOVosRUFBTStaLFlBRUosV0FBVHpiLElBQXFCd2IsR0FDaEIxVSxFQUFZUCxHQUFHUyxTQUFTd1UsRUFBTSxTQUFDdlUsUUFDOUJBLElBQWFzQyxFQUFPbkwsT0FJbkJBLEtBQU82SSxJQUVWN0ksRUFBSUYsUUFJSkUsRUFBSUYsV0FDRUUsU0FDSGdULE1BQVE3RyxNQUtUMFAsR0FBUTliLEVBQVlvTCxFQUFRcUssUUFFOUJxRyxNQUNNQSxFQUFNOWEsTUFDVGlTLE1BQVF1SSxFQUFhTSxFQUFNOWEsS0FBS29MLGFBRTdCZ1IsRUFBQUEsSUFDSG5LLE1BQVEsV0FPZm9LLEdBQVF0ZCxJQUFVcWQsRUFBQUEsTUFDWm5kLElBQ0hnVCxNQUFRN0csS0FHTmlSLCtCQS9Ed0JwUixPQUM5QitFLHNOZkRIbUwsbUNBRU4xSixJQUFXLDBDQVdHbEosOEVBQ0pBLE1BSFJ4SixNQUFRcWQsRUFBQUEsVUFNSmhWLEdBQ0VvVCxJQUFBQSxhQUNBN1MsSUFBQUEsWUFFRi9CLElBQUFBLEtBQ1E5RyxJQUFSOEcsS0FBUTlHLE1BRU55ZCxrQkFFQ25TLE9BQVMxTCxFQUFpQjhiLEVBQWMsU0FBQ3BRLEVBQVFrQyxFQUFPck4sTUFFekQ0QixHQUdFeUwsRUFIRnpMLEtBQ0EwQixFQUVFK0osRUFGRi9KLE1BQ0E2SSxFQUNFa0IsRUFERmxCLFNBRUVvUixFQUFNamEsRUFBTStaLEVBRVpDLElBSVMsV0FBVDFiLEdBQThCLGNBQVRBLElBSVosY0FBVEEsT0FDVyxLQUdGLGNBQVRBLEVBQ0kvQixFQUNHMGQsRUFDSDdVLEVBQVlQLEdBQUdTLFNBQVMyVSxFQUFLLFNBQUMxVSxRQUM5QmdILEdBQU9nRCxFQUFLMUgsT0FBT25MLEdBQUdILE1BQU9nSixPQUk1QnNDLE9BQU9uTCxHQUFHSCxNQUFRZ0osRUFFbkI3SSxFQUFJNlMsRUFBSy9TLFlBSVRFLEVBQUk2UyxFQUFLL1MsZUFDTkEsTUFBUUUsU0FDUmdULE1BQVE3RyxNQUtUMFAsR0FBUTliLEVBQVk4UyxFQUFLMUgsT0FBUSxrQkFDckMwRSxNQUR3Q2hRLE1BQzFCOEcsRUFBSzlHLFFBR2pCZ2MsTUFDRy9iLE1BQVErYixFQUFNOWEsTUFDZGlTLE1BQVE2SSxFQUFNaGMsTUFBTXNNLGFBRXBCck0sTUFBUXFkLEVBQUFBLElBQ1JuSyxNQUFRLGVBSVhqTSxHQUdKOEksR0FBTzBOLEVBQUsxZCxJQUFVZ1QsRUFBSy9TLFFBQVVxZCxFQUFBQSxNQUNsQ3JkLE1BQVFFLElBQ1JnVCxNQUFRN0csS0FHUm5DLDhCQUdFdVQsd0ZBTU4zVSxTQUFTc1QsR0FBVyxjQUVkclQsR0FDTHdULEVBQUsxVixLQURQOUcsUUFHR0MsTUFBUXFkLEVBQUFBLElBRUFkLEVBQUtsUixPQUFRLFdBQTRCbkwsTUFBekI0QixLQUFBQSxLQUFNL0IsSUFBQUEsTUFBT3NNLElBQUFBLFFBS3BDMEQsSUFKaUIsY0FBVGpPLEVBQ1JpSCxFQUNBaEosRUFFWWdKLElBQWF3VCxFQUFLdmMsUUFBVXFkLEVBQUFBLE1BQ3JDcmQsTUFBUUUsSUFDUmdULE1BQVE3RyxLQUlia1EsRUFBS3ZjLFFBQVVxZCxFQUFBQSxNQUNabkssTUFBUSxlQWxIMEJoSCxPQUN0QytFLDRNZ0JIVDBCLEdBQVcsNk5BQ1RuUCw0RUFFWXVGLE1BRVJ6SSxHQUdFMlMsS0FIRjNTLEtBQ0F1RyxFQUVFb00sS0FGRnBNLEtBQ0FyRCxFQUNFeVAsS0FERnpQLEtBR0VxRCxPQUNTM0YsRUFBa0IyRixFQUFNLFNBQUNyRCxFQUFPQyxLQUNuQ0EsR0FBUXNGLE9BSUp2RixFQUFPLFNBQUN6RCxFQUFPOEUsR0FDckJBLElBQVFrRSxNQUNQUSxXQUFXMUUsT0FHZnBCLEtBQUtzRixRQUVMdkYsTUFBUXVGLDRDQUtYekksR0FFRTJTLEtBRkYzUyxLQUNBa0QsRUFDRXlQLEtBREZ6UCxRQUdHK0YsV0FBV2lPLE1BQU1sWCxFQUFNeUcsR0FBS3ZELFdBaENNK0QsSUNBM0NvTCxHQUFXLG1MQUNHNVMsR0FDTmtULEtBQUt5SyxVQUNGQSxNQUdGbmIsRUFBV3hDLEtBSVprVCxLQUFLcE0sVUFDRjZXLElBQU16SyxLQUFLM1MsS0FBS3FkLEdBQUcxSyxLQUFLcE0sS0FBS3NMLEtBQUssS0FBTXBTLFdBRXJDbUosTUFBTSw4SUFLUndVLEdBQVF6SyxLQUFSeUssR0FFSkEsZUFwQm1DblcsR0NLM0NvTCxJQUFXLDhOQUNUaUwsOEVBRVk3VSxNQUVSekksR0FHRTJTLEtBSEYzUyxLQUNBdUcsRUFFRW9NLEtBRkZwTSxLQUNBK1csRUFDRTNLLEtBREYySyxRQUVJQyxJQUVGaFgsT0FDU2tDLEVBQ1BsQyxNQUlGcEUsRUFBU3NHLE9BQ0FBLEVBQVNsRixNQXBCQSxRQXVCbEJnQyxHQUFRa0QsTUFDRzZVLEVBQVMsU0FBQ2pQLElBQ1UsSUFBM0I1RixFQUFTeEksUUFBUW9PLE1BQ2R0SSxZQUFZc0ksT0FHUjVGLEVBQVUsU0FBQzRGLEdBQ2xCbE0sRUFBU2tNLE9BQ0F6RSxLQUFLeUUsS0FDWGxKLFNBQVNrSixVQUlMaVAsRUFBUyxTQUFDalAsR0FDaEI1RixHQUFhQSxFQUFTNEYsTUFDcEJ0SSxZQUFZc0ksT0FHUDVGLEVBQVUsU0FBQzBVLEVBQUs5TyxHQUN4QjhPLE1BQ1N2VCxLQUFLeUUsS0FDWGxKLFNBQVNrSixZQUtmaVAsUUFBVUMsNENBS2J2ZCxHQUVFMlMsS0FGRjNTLEtBQ0FzZCxFQUNFM0ssS0FERjJLLFVBR0d2WCxZQUFZbVIsTUFBTWxYLEVBQU1zZCxVQXhEWXJXLGFDVDdDb0wsSUFLVyx3Q0FHR25KLDhFQUNKQSxJQUdKM0MsSUFBQUEsS0FDQWdDLElBQUFBLGVBQ0F2SSxJQUFBQSxLQUVFOEosRUFBUXZCLEVBQ1I5SSxFQUFRZ1QsRUFBS2pLLGlCQUViakMsT0FDTTlHLFlBQWlCbU0sSUFDckJuTSxFQUNBOEksSUFDSWhDLEVBQUssSUFHWHRFLEVBQVd4QyxLQUNQTyxHQUNHbUMsRUFBUzFDLE9BQ1pBLEdBQVNPLHVCQXhCc0JpSCxPQUNsQ3VCLFVBQVcsTUNIcEI2SixHQUFXLG1MQUNHNVMsTUFDRk8sR0FBUzJTLEtBQVQzUyxJQUVKUCxLQUNHd0YsU0FFQWEsbURBS0Y5RixLQUFLOEYsY0FaNkJtQixhQ0gzQ29MLElBS1csd0NBR0duSiw4RUFDSkEsSUFHSjNDLElBQUFBLEtBQ0FnQyxJQUFBQSxlQUNBMkMsSUFBQUEsS0FFRXBCLEVBQVF2QixFQUNSOUksRUFBUWdULEVBQUtqSyxpQkFFYmpDLE9BQ005RyxZQUFpQm1NLElBQ3JCbk0sRUFDQThJLElBQ0loQyxFQUFLLElBR1h0RSxFQUFXeEMsS0FDUHlMLEdBQ0cvSSxFQUFTMUMsT0FDWkEsR0FBU3lMLHVCQXhCc0JqRSxPQUNsQ3VCLFVBQVcsZUNOcEI2SixJQUdXLHNDQUdHbkosOEVBQ0pBLFVBRUZ1SixHQUFLbE0sT0FDRjZXLElBQU0zSyxFQUFLelMsS0FBS3FkLEdBQUc1SyxFQUFLbE0sS0FBS3NMLEtBQUssS0FBTSxhQUN0Q3JKLHFCQUdDSSxNQUFNLDRKQUtSd1UsR0FBUXpLLEtBQVJ5SyxHQUVKQSxlQWxCK0JuVyxPQUM5QnVCLFVBQVcsTUNEcEI2SixHQUFXLG1MQUNHNVMsTUFDRk8sR0FBUzJTLEtBQVQzUyxJQUVKUCxLQUNHcUcsU0FFQWIsbURBS0ZqRixLQUFLOEYsY0FaNkJtQixHdEJNM0NvTCxJQUFXLDhOQUNUaFAsMEVBRVlvRixFQUFVWCxNQUVsQjlILEdBR0UyUyxLQUhGM1MsS0FDQXVHLEVBRUVvTSxLQUZGcE0sS0FDQWxELEVBQ0VzUCxLQURGdFAsR0FHRWtELE9BQ1MzRixFQUFrQjJGLEVBQU0sU0FBQ2xELEVBQUtrQixLQUNuQ0EsR0FBUWtFLEtBSVp0RyxFQUFTc0csT0FDQXBKLEVBQ1RvSixFQUNHbEYsTUFyQndCLE9Bc0J4QjhXLE9BQU9qRixTQUNWaFMsT0FJVUMsRUFBSyxTQUFDNUQsRUFBTzhFLEdBQ3BCa0UsRUFBU2xFLE1BQ1A2UCxVQUFVN1AsT0FHZGxCLElBQUlvRixRQUVKcEYsSUFBTW9GLDRDQUtUekksR0FFRTJTLEtBRkYzUyxLQUNBcUQsRUFDRXNQLEtBREZ0UCxNQUdHK1EsVUFBVThDLE1BQU1sWCxFQUFNeUcsR0FBS3BELFdBekNTNEQsYUNUN0NvTCxJQU9XLHlDQUdHbkosOEVBQ0pBLElBR0ozQyxJQUFBQSxLQUNBZ0MsSUFBQUEsZUFDQXZJLElBQUFBLEtBQ0FrTCxJQUFBQSxLQUVJMUosRUFBT3hCLEVBQUt3QixPQUNad0gsRUFBT2hKLEVBQUt1RSxLQUFLLFFBQ2pCOUUsRUFBUWdULEVBQUtqSyxXQUNmZ1YsRUFBb0IsT0FFbkJqWixLQUFPcUwsR0FBUXBPLEVBQU13SCxFQUFNaEosS0FDM0J3QixLQUFPQSxJQUNQd0gsS0FBT0EsSUFDUHZKLE1BQVFBLElBQ1J5USxRQUFVbFEsRUFBS29FLEtBQUssWUFDcEIwRixNQUFRdkIsRUFFVGhDLE1BQ0cvRSxLQUFPK0UsRUFBSyxLQUNadUQsTUFBUXJLLFlBQWlCbU0sT0FDMUJuTSxFQUNBOEksR0FHRHRHLEVBQVd4QyxPQUNNZ1QsRUFBSzNJLE1BQU0vQixHQUFHUyxTQUFTZ0ksR0FBZ0IvUSxHQUFRLFNBQUNnSixHQUM5RGdLLEVBQUtpRixlQUFpQmpQLE1BQ25CaVAsYUFBZWpQLElBQ2ZnVixRQUFRaFYsWUFLYmlWLEdBQW1CakwsRUFBSzdDLFFBQVE0TixHQUFtQixHQUNuREcsRUFBMEJ6YixFQUFNc2IsR0FDaENJLEVBQXNCLGFBQVQ1VSxFQUNiNlUsRUFBYyxhQUNibkcsYUFBZWpGLEVBQUs3QyxRQUFRNkMsRUFBS2lGLGdCQUNqQ21HLHFCQUdIRixJQUEyQkMsS0FDeEJsRyxhQUFlZ0csSUFDZkcsZUFFQUYsR0FBMkJDLEtBQ3pCSCxRQUFRRCxPQUdWOUYsYUFBZThGLElBQ2ZDLFFBQVFELE1BR1ZNLGdCQUFrQjlkLEVBQUtxZCxHQUFHOU0sR0FBZ0IvTyxFQUFNd0gsR0FBTyxTQUFDb1EsR0FDdkRBLEVBQUU1WSxTQUFXMEssV0FJZDZTLGdCQUFrQi9kLEVBQUsrRSxRQUFRLFFBQVFzWSxHQUFHLFFBQVMsc0JBQzNDUSxFQUFhLG1FQU14Qi9ULEdBR0U2SSxLQUhGN0ksTUFDQXJLLEVBRUVrVCxLQUZGbFQsTUFDQWlZLEVBQ0UvRSxLQURGK0UsWUFHRXpWLEdBQVd4QyxLQUNQaVksS0FFQWpZLEdBQVNpWSxrQ0FJWGpZLE1BRUpPLEdBTUUyUyxLQU5GM1MsS0FDQXdCLEVBS0VtUixLQUxGblIsS0FDQStDLEVBSUVvTyxLQUpGcE8sS0FDQXlFLEVBR0UySixLQUhGM0osS0FDQWtDLEVBRUV5SCxLQUZGekgsS0FDQWdGLEVBQ0V5QyxLQURGekMsT0FHVyxVQUFUM0wsSUFDR0MsS0FBSy9FLEdBQ1Esb0JBQVQ4RSxJQUNEc08sUUFBUSxTQUFDbUwsS0FDUnZOLFVBQTRDLElBQWpDaFIsRUFBTVEsUUFBUStkLEVBQU92ZSxXQUdwQzhFLEtBQUtBLEVBQU11TCxHQUFtQnRPLEVBQU0vQixFQUFPdUosRUFBTWtDLEVBQUt6TCx3Q0FJdkRzTCxFQUFRb0YsTUFFWm5RLEdBTUUyUyxLQU5GM1MsS0FDQXdCLEVBS0VtUixLQUxGblIsS0FDQStDLEVBSUVvTyxLQUpGcE8sS0FDQXlFLEVBR0UySixLQUhGM0osS0FDQWtDLEVBRUV5SCxLQUZGekgsS0FDQWdGLEVBQ0V5QyxLQURGekMsY0FHYyxTQUFUM0wsRUFDSHZFLEVBQUt3RSxPQUNMeUwsR0FBbUJ6TyxFQUFNeEIsRUFBS3VFLEtBQUtBLEdBQU95RSxFQUFNa0MsRUFBS3pMLE1BQU9zTCxFQUFRbUYsRUFBU0MsRUFBZSxvQkFBVDVMLCtDQUlsRnVaLHVCQUNBQyx5QkExSG9DOVcsT0FDcEN1QixVQUFXLE1zQkpwQnBILEVBQWNnUixHQUFZLFNBQUN4RyxLQUNuQjRELE1BQVE1RCxFQUFNK0UsU0FBU3RRLE9BQ3ZCd04sTUFBUWpDLEVBQU0rRSxTQUFTbFIsUUFHL0IyQixFQUFjaVIsR0FBWSxTQUFDcEwsRUFBT3pGLEtBQzFCMkYsT0FBU04sRUFBb0JyRixZQ0xqQzZQLFNBREZsTCxTQUFBQSxxQkFTV21GLEdBQU0sR0FBSXhHLElBQUtxQixJQVFmeUgsR0FBTyxHQUFJOUksSUFBS3FCLEdBQVM0TixpQkFRekJrSyxHQUFPLEdBQUluWixJQUFLcUIsR0FBUzhYLE1BUXpCOVosR0FBTyxHQUFJVyxJQUFLcUIsR0FBU2hDLEtBRXRDRCxHQUFvQkMifQ=="}