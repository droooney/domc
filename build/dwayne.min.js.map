{"version":3,"file":"dwayne.min.js","sources":["../lib/helpers/toStringTag.js","../lib/helpers/checkTypes.js","../lib/D.js","../lib/helpers/iterate.js","../lib/helpers/assign.js","../lib/helpers/defineProperty.js","../lib/helpers/toArray.js","../lib/helpers/validate.js","../lib/Alphabet.js","../lib/Switcher.js","../lib/Super.js","../lib/Func.js","../lib/Num.js","../lib/Arr.js","../lib/BlobObject.js","../lib/Str.js","../lib/helpers/markupToJSON.js","../lib/Elem.js","../lib/blocks/d-block.js","../lib/blocks/d-each.js","../lib/blocks/d-elements.js","../lib/blocks/d-if.js","../lib/blocks/d-item.js","../lib/blocks/d-switch.js","../lib/blocks/d-text.js","../lib/mixins/d-attr.js","../lib/mixins/d-bind.js","../lib/mixins/d-class.js","../lib/mixins/d-elem.js","../lib/mixins/d-hide.js","../lib/mixins/d-on.js","../lib/mixins/d-show.js","../lib/mixins/d-style.js","../lib/mixins/d-text.js","../lib/mixins/d-validate.js","../lib/mixins/d-value.js","../lib/Block.js","../lib/constants/formats.js","../lib/Dat.js","../lib/helpers/constructURL.js","../lib/Fetch.js","../lib/Router.js","../lib/constants/global.js","../lib/constants/appliedRegExps.js","../lib/constants/canvasMethods.js","../lib/constants/constructors.js","../lib/constants/elements.js","../lib/constants/htmlAllowedTagSymbols.js","../lib/constants/regexpSpecialCharacters.js","../lib/constants/validateCheckExpressions.js","../lib/helpers/Symbol.js","../lib/Promise.js","../lib/helpers/parseHeaders.js","../lib/helpers/transformData.js","../lib/helpers/resolveURL.js","../browser.js"],"sourcesContent":["/**\r\n * @module helpers/toStringTag\r\n * @private\r\n * @description Exports toStringTag method.\r\n */\r\n\r\n/**\r\n * @function toStringTag\r\n * @param {*} object - Object to get toStringTag of.\r\n * @returns {String} Cut string.\r\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\r\n */\r\nexport function toStringTag(object) {\r\n  return {}.toString.call(object).replace(/^\\[object |]$/g, '');\r\n}\r\n","/**\r\n * @module helpers/checkTypes\r\n * @private\r\n * @mixin\r\n * @description Exports is<Type> methods.\r\n */\r\n\r\nimport { toStringTag } from './toStringTag';\r\n\r\n/**\r\n * @function isArray\r\n * @public\r\n * @param {*} value - Value to check if it is an array.\r\n * @returns {Boolean} If the argument is an array or not.\r\n * \r\n * @example\r\n * isArray([]);                             // true\r\n * isArray(0);                              // true\r\n * isArray(document.querySelectorAll('*')); // false\r\n */\r\nexport function isArray(value) {\r\n  return toStringTag(value) === 'Array';\r\n}\r\n\r\n/**\r\n * @function isArrayLike\r\n * @public\r\n * @param {*} value - Value to check if it is array-like.\r\n * @returns {Boolean} If the argument is array-like or not.\r\n * @description Basically returns if the argument has non-negative integer \"length\" property and isn't a function.\r\n * \r\n * @example\r\n * isArrayLike([]);                             // true\r\n * isArrayLike('');                             // true\r\n * isArrayLike(() => {});                       // false\r\n * isArrayLike(document.querySelectorAll('*')); // true\r\n */\r\nexport function isArrayLike(value) {\r\n  if (!value || isFunction(value)) {\r\n    return false;\r\n  }\r\n  \r\n  const length = value.length;\r\n  \r\n  return isInteger(length) && length >= 0;\r\n}\r\n\r\n/**\r\n * @function isBoolean\r\n * @public\r\n * @param {*} value - Value to check if it is a boolean.\r\n * @returns {Boolean} If the argument is a boolean or not.\r\n * \r\n * @example\r\n * isBoolean(true);               // true\r\n * isBoolean(new Boolean(false)); // true\r\n * isBoolean(null);               // false\r\n */\r\nexport function isBoolean(value) {\r\n  return toStringTag(value) === 'Boolean';\r\n}\r\n\r\n/**\r\n * @function isDate\r\n * @public\r\n * @param {*} value - Value to check if it is a date.\r\n * @returns {Boolean} If the argument is a date or not.\r\n * \r\n * @example\r\n * isDate(new Date());                 // true\r\n * isDate('1999-12-31T23:59:59.999Z'); // false\r\n */\r\nexport function isDate(value) {\r\n  return toStringTag(value) === 'Date';\r\n}\r\n\r\n/**\r\n * @function isDateLike\r\n * @public\r\n * @param {*} value - Value to check if it is date-like.\r\n * @returns {Boolean} If the argument is date-like or not.\r\n * @description Basically returns if new Date(argument) is not invalid date.\r\n * \r\n * @example\r\n * isDateLike(new Date());                 // true\r\n * isDateLike('1999-12-31T23:59:59.999Z'); // true\r\n * isDateLike(0);                          // true\r\n */\r\nexport function isDateLike(value) {\r\n  value = new Date(value);\r\n  \r\n  return !isNaN(value.getTime());\r\n}\r\n\r\n/**\r\n * @function isElement\r\n * @public\r\n * @param {*} value - Value to check if it is an element.\r\n * @returns {Boolean} If the argument is element or not.\r\n *\r\n * @example\r\n * isElement(document.querySelector('html')); // true\r\n */\r\nexport function isElement(value) {\r\n  return /Element$/.test(toStringTag(value));\r\n}\r\n\r\n/**\r\n * @function isFinite\r\n * @public\r\n * @param {*} value - Value to check if it is finite.\r\n * @returns {Boolean} If the argument is finite or not.\r\n * \r\n * @example\r\n * isFinite(0);        // true\r\n * isFinite('0');      // false\r\n * isFinite(Infinity); // false\r\n * isFinite(NaN);      // false\r\n */\r\nexport function isFinite(value) {\r\n  if (!isNumber(value)) {\r\n    return false;\r\n  }\r\n  \r\n  value = Number(value);\r\n\r\n  return !isNaN(value) && value !== Infinity && value !== -Infinity;\r\n}\r\n\r\n/**\r\n * @function isFunction\r\n * @public\r\n * @param {*} value - Value to check if it is a function.\r\n * @returns {Boolean} If the argument is a function or not.\r\n * \r\n * @example\r\n * isFunction(() => {});            // true\r\n * \r\n * const func = () => {};\r\n * Object.setPrototypeOf(func, {});\r\n * isFunction(func);                // true\r\n */\r\nexport function isFunction(value) {\r\n  return toStringTag(value) === 'Function' || typeof value === 'function';\r\n}\r\n\r\n/**\r\n * @function isInteger\r\n * @public\r\n * @param {*} value - Value to check if it is an integer.\r\n * @returns {Boolean} If the argument is an integer or not.\r\n *\r\n * @example\r\n * isInteger(0);             // true\r\n * isInteger(0.1);           // false\r\n * isInteger(new Number(0)); // true\r\n * isInteger('0');           // false\r\n * isInteger(Infinity);      // false\r\n * isInteger(NaN);           // false\r\n */\r\nexport function isInteger(value) {\r\n  return isNumber(value) && value % 1 === 0;\r\n}\r\n\r\n/**\r\n * @function isIntegerLike\r\n * @public\r\n * @param {*} value - Value to check if it is integer-like.\r\n * @returns {Boolean} If the argument is integer-like or not.\r\n *\r\n * @example\r\n * isIntegerLike(0);             // true\r\n * isIntegerLike(new Number(0)); // true\r\n * isIntegerLike(0.1);           // false\r\n * isIntegerLike('0');           // true\r\n */\r\nexport function isIntegerLike(value) {\r\n  value = parseInt(Number(value));\r\n\r\n  return !!(value || value === 0);\r\n}\r\n\r\n/**\r\n * @function isNaN\r\n * @public\r\n * @param {*} value - Value to check if it is NaN.\r\n * @returns {Boolean} If the argument is NaN or not.\r\n *\r\n * @example\r\n * isNaN(0);               // false\r\n * isNaN('NaN');           // false\r\n * isNaN(NaN);             // true\r\n * isNaN(new Number(NaN)); // true\r\n */\r\nexport function isNaN(value) {\r\n  if (!isNumber(value)) {\r\n    return false;\r\n  }\r\n  \r\n  value = Number(value);\r\n\r\n  return value !== value;\r\n}\r\n\r\n/**\r\n * @function isNull\r\n * @public\r\n * @param {*} value - Value to check if it is null.\r\n * @returns {Boolean} If the argument is null or not.\r\n *\r\n * @example\r\n * isNull(null);      // true\r\n * isNull(undefined); // false\r\n */\r\nexport function isNull(value) {\r\n  return value === null;\r\n}\r\n\r\n/**\r\n * @function isNil\r\n * @public\r\n * @param {*} value - Value to check if it is null or undefined.\r\n * @returns {Boolean} If the argument is null or undefined or not.\r\n *\r\n * @example\r\n * isNil(null);      // true\r\n * isNil(undefined); // true\r\n * isNil(false);     // false\r\n */\r\nexport function isNil(value) {\r\n  return value === null || typeof value === 'undefined';\r\n}\r\n\r\n/**\r\n * @function isNumber\r\n * @public\r\n * @param {*} value - Value to check if it is a number.\r\n * @returns {Boolean} If the argument is a number or not.\r\n *\r\n * @example\r\n * isNumber(0);             // true\r\n * isNumber(new Number(0)); // true\r\n * isNumber(NaN);           // true\r\n * isNumber('0');           // false\r\n */\r\nexport function isNumber(value) {\r\n  return toStringTag(value) === 'Number';\r\n}\r\n\r\n/**\r\n * @function isNumberLike\r\n * @public\r\n * @param {*} value - Value to check if it is number-like.\r\n * @returns {Boolean} If the argument is number-like or not.\r\n *\r\n * @example\r\n * isNumberLike(0);          // true\r\n * isNumberLike('0');        // true\r\n * isNumberLike('Infinity'); // true\r\n * isNumberLike('NaN');      // true\r\n * isNumberLike(NaN);        // true\r\n */\r\nexport function isNumberLike(value) {\r\n  if (isNaN(value) || value === 'NaN') {\r\n    return true;\r\n  }\r\n  \r\n  value = Number(value);\r\n  \r\n  return !!(value || value === 0);\r\n}\r\n\r\n/**\r\n * @function isObject\r\n * @public\r\n * @param {*} value - Value to check if it is an object.\r\n * @returns {Boolean} If the argument is an object or not.\r\n *\r\n * @example\r\n * isObject({});   // true\r\n * isObject(1);    // false\r\n * isObject(null); // false\r\n */\r\nexport function isObject(value) {\r\n  return !!value && (toStringTag(value) === 'Object' || typeof value === 'object' || value instanceof Object);\r\n}\r\n\r\n/**\r\n * @function isPlainObject\r\n * @public\r\n * @param {*} value - Value to check if it is a plain object.\r\n * @returns {Boolean} If the argument is a plain object or not.\r\n *\r\n * @example\r\n * const obj = {};\r\n *\r\n * ifPlainObject(obj); // true\r\n *\r\n * Object.setPrototypeOf(object, null);\r\n *\r\n * ifPlainObject(obj); // true\r\n *\r\n * Object.setPrototypeOf(object, {});\r\n *\r\n * ifPlainObject(obj); // false\r\n */\r\nexport function isPlainObject(value) {\r\n  if (isPrimitive(value)) {\r\n    return false;\r\n  }\r\n\r\n  const proto = Object.getPrototypeOf(value);\r\n\r\n  if (isNull(proto)) {\r\n    return true;\r\n  }\r\n\r\n  const constructor = proto.constructor;\r\n\r\n  return isFunction(constructor) &&\r\n    constructor instanceof constructor &&\r\n    isNull(Object.getPrototypeOf(proto));\r\n}\r\n\r\n/**\r\n * @function isPrimitive\r\n * @public\r\n * @param {*} value - Value to check if it is primitive.\r\n * @returns {Boolean} If the argument is primitive or not.\r\n *\r\n * @example\r\n * isPrimitive(1);             // true\r\n * isPrimitive({});            // false\r\n * isPrimitive('');            // true\r\n * isPrimitive(new Number(0)); // false\r\n * isPrimitive(true);          // true\r\n * isPrimitive(Symbol('foo')); // true\r\n * isPrimitive(null);          // true\r\n * isPrimitive(undefined);     // true\r\n */\r\nexport function isPrimitive(value) {\r\n  return isNull(value) || /^(number|string|boolean|symbol|undefined)$/.test(typeof value);\r\n}\r\n\r\n/**\r\n * @function isRegExp\r\n * @public\r\n * @param {*} value - Value to check if it is a regular expression.\r\n * @returns {Boolean} If the argument is a regular expression or not.\r\n *\r\n * @example\r\n * isRegExp(/foo/);             // true\r\n * isRegExp('/foo/');           // false\r\n * isRegExp(new RegExp('foo')); // true\r\n */\r\nexport function isRegExp(value) {\r\n  return toStringTag(value) === 'RegExp';\r\n}\r\n\r\n/**\r\n * @function isString\r\n * @public\r\n * @param {*} value - Value to check if it is a string.\r\n * @returns {Boolean} If the argument is a string or not.\r\n *\r\n * @example\r\n * isString('0');             // true\r\n * isString(new String('0')); // true\r\n */\r\nexport function isString(value) {\r\n  return toStringTag(value) === 'String';\r\n}\r\n\r\n/**\r\n * @function isSymbol\r\n * @public\r\n * @param {*} value - Value to check if it is a symbol.\r\n * @returns {Boolean} If the argument is a symbol or not.\r\n *\r\n * @example\r\n * isSymbol(Symbol('1')); // true\r\n */\r\nexport function isSymbol(value) {\r\n  return toStringTag(value) === 'Symbol';\r\n}\r\n\r\n/**\r\n * @function isUndefined\r\n * @public\r\n * @param {*} value - Value to check if it is undefined.\r\n * @returns {Boolean} If the argument is undefined or not.\r\n *\r\n * @example\r\n * isUndefined(null);      // false\r\n * isUndefined(undefined); // true\r\n */\r\nexport function isUndefined(value) {\r\n  return typeof value === 'undefined';\r\n}\r\n","/**\r\n * @module D\r\n * @private\r\n * @description Exports D function.\r\n */\r\n\r\nimport { constructors } from './constants';\r\n\r\n/**\r\n * @function D\r\n * @public\r\n * @param {*} [value] - Any value.\r\n * @returns {DWrap} Wrap of the argument.\r\n * @description Function for creating a D-wrap of an object.\r\n *\r\n * @example\r\n * D({});            // Super\r\n * D(() => {});      // Func\r\n * D([]);            // Arr\r\n * D(1);             // Num\r\n * D('1');           // Str\r\n * D(new Date());    // Dat\r\n * D(document.body); // Elem\r\n */\r\nfunction D(value) {\r\n  for (let i = constructors.length - 1; i >= 0; i--) {\r\n    const levelConstructors = constructors[i];\r\n\r\n    for (let k = 0, len = levelConstructors.length; k < len; k++) {\r\n      const constructor = levelConstructors[k];\r\n\r\n      if (value instanceof constructor.cls) {\r\n        return value;\r\n      }\r\n\r\n      if (constructor.check(value)) {\r\n        return new constructor.cls(value);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport * from './helpers/checkTypes';\r\nexport { D };\r\n","/**\r\n * @module helpers/iterate\r\n * @private\r\n * @description Exports iterate method.\r\n */\r\n\r\nimport { isArrayLike, isUndefined } from './checkTypes';\r\n\r\n/**\r\n * @callback IterationCallback\r\n * @param {*} value - Iteration value.\r\n * @param {String|Number} key - Iteration key.\r\n * @param {*} object - Initial iterable object.\r\n */\r\n\r\n/**\r\n * @function iterate\r\n * @param {(Object|Array|null|undefined)} object - Value to iterate over.\r\n * @param {IterationCallback} callback - Callback that is called on every iteration.\r\n * @returns {*} If callback returns not undefined then iterate returns this value.\r\n * @description Function for iterating over all types of values.\r\n */\r\nexport function iterate(object, callback) {\r\n  const array = isArrayLike(object);\r\n  const iteratedKeys = {};\r\n\r\n  let iterated = 0;\r\n\r\n  for (const key in object) {\r\n    if ({}.hasOwnProperty.call(iteratedKeys, key)) {\r\n      continue;\r\n    }\r\n\r\n    iteratedKeys[key] = true;\r\n\r\n    if ({}.hasOwnProperty.call(object, key)) {\r\n      if (array && iterated++ >= object.length) {\r\n        break;\r\n      }\r\n\r\n      const value = callback(object[key], array ? Number(key) : key, object);\r\n\r\n      if (!isUndefined(value)) {\r\n        return value;\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @module helpers/assign\r\n * @private\r\n * @description Exports Object.assign-like method.\r\n */\r\n\r\nimport { iterate } from './iterate';\r\n\r\n/**\r\n * @const\r\n * @function assign\r\n * @param {Object} target - Object to assign rest of arguments to.\r\n * @param {...Object} objects - Objects that are assigned to the target.\r\n * @returns {Object} Target.\r\n */\r\nexport function assign(target, ...objects) {\r\n  iterate(arguments, (source, index) => {\r\n    if (index) {\r\n      iterate(source, (value, key) => {\r\n        target[key] = value;\r\n      });\r\n    }\r\n  });\r\n    \r\n  return target;\r\n}\r\n","/**\r\n * @module helpers/defineProperty\r\n * @private\r\n * @description Exports defineProperty and dynamicDefineProperties methods.\r\n */\r\n\r\nimport { iterate } from './iterate';\r\n\r\n/**\r\n * @callback propertyGeneratorCallback\r\n * @param {String} name - Name of the property.\r\n * @param {Number} i - Index of the array.\r\n * @returns {*} Generated property.\r\n */\r\n\r\n/**\r\n * @function dynamicDefineProperties\r\n * @param {Object} target - Object to define properties for.\r\n * @param {Array} properties - Object which keys are properties.\r\n * @param {propertyGeneratorCallback} propertyGenerator - Callback for every property.\r\n * @returns {void}\r\n * @description Function for dynamic creating properties based on name of the method.\r\n */\r\nexport function dynamicDefineProperties(target, properties, propertyGenerator) {\r\n  iterate(properties, (name, i) => {\r\n    Object.defineProperty(target, name, {\r\n      value: propertyGenerator(name, i),\r\n      writable: true,\r\n      enumerable: false,\r\n      configurable: true\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * @function defineProperties\r\n * @param {Object} target - Target to define properties for.\r\n * @param {Object} properties - Object with properties needed to be assign to the target.\r\n * @returns {void}\r\n * @description Function for defining properties of an object.\r\n */\r\nexport function defineProperties(target, properties) {\r\n  iterate(properties, (method, name) => {\r\n    if (/^get /.test(name)) {\r\n      Object.defineProperty(target, name.replace(/^get /, ''), {\r\n        get: method,\r\n        set: undefined,\r\n        enumerable: false,\r\n        configurable: true\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (/^set /.test(name)) {\r\n      Object.defineProperty(target, name.replace(/^set /, ''), {\r\n        set: method,\r\n        get: undefined,\r\n        enumerable: false,\r\n        configurable: true\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (/^get\\/set /.test(name)) {\r\n      Object.defineProperty(target, name.replace(/^get\\/set /, ''), {\r\n        get: method.get,\r\n        set: method.set,\r\n        enumerable: false,\r\n        configurable: true\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (name !== 'Symbol.toStringTag') {\r\n      Object.defineProperty(target, name, {\r\n        value: method,\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: true\r\n      });\r\n    }\r\n  });\r\n}\r\n","/**\r\n * @module helpers/toArray\r\n * @private\r\n * @description Exports toArray method.\r\n */\r\n\r\nimport { isArray, isArrayLike, isString } from './checkTypes';\r\nimport { iterate } from './iterate';\r\n\r\n/**\r\n * @function toArray\r\n * @param {*} value - Any value.\r\n * @param {Boolean} [createNewArray = false] - If it is needed to create new array.\r\n * @returns {Array} Create array.\r\n * @description Function for creating an array of any value.\r\n */\r\nexport function toArray(value, createNewArray) {\r\n  if (isArray(value) && !createNewArray) {\r\n    return value;\r\n  }\r\n\r\n  const array = [];\r\n\r\n  if (isArrayLike(value) && !isString(value)) {\r\n    iterate(value, (value) => {\r\n      array.push(value);\r\n    });\r\n  } else {\r\n    array.push(value);\r\n  }\r\n\r\n  return array;\r\n}\r\n","/**\r\n * @module helpers/validate\r\n * @private\r\n * @description Exports validate method.\r\n */\r\n\r\nimport { validateCheckExpressions } from '../constants';\r\nimport { iterate } from './iterate';\r\nimport { isArray } from './checkTypes';\r\n\r\nconst numbers = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th'];\r\n\r\n/**\r\n * @function validate\r\n * @private\r\n * @param {Object} args - Arguments of function.\r\n * @param {Object} options - Object with validate parameters.\r\n * @param {String} [name] - Name of the function what called validate.\r\n * @returns {void}\r\n * @description Function for checking arguments of other functions.\r\n */\r\nexport function validate(args, options, name) {\r\n  iterate(options, (array, number) => {\r\n    if (!isArray(array)) {\r\n      array = [array];\r\n    }\r\n\r\n    iterate(array, (checker) => {\r\n      checker = validateCheckExpressions[checker];\r\n\r\n      if (!checker.check(args[number])) {\r\n        throw new checker.error(checker.text.replace('$n', numbers[number]) + (name ? ` (at ${ name })` : ''));\r\n      }\r\n    });\r\n  });\r\n}\r\n","/**\r\n * @module Alphabet\r\n * @private\r\n * @mixin\r\n * @description Exports Alphabet class.\r\n */\r\n\r\nimport { isString, validate, defineProperties, Symbol } from './helpers';\r\n\r\n/**\r\n * @typedef {String} Char\r\n * @public\r\n * @description A string of one char.\r\n */\r\n\r\n/**\r\n * @class Alphabet\r\n * @public\r\n * @param {ArrayLike} alphabet - Alphabet to wrap.\r\n * @returns {Alphabet} Instance of Alphabet.\r\n * @description Class for alphabet manipulations: add, delete symbols, generate a token from an alphabet,\r\n * check if an alphabet contains a word.\r\n *\r\n * @example\r\n * new Alphabet(['a', 'b', 'c']);\r\n */\r\nclass Alphabet {\r\n  constructor(alphabet = []) {\r\n    const a = {};\r\n\r\n    for (let i = 0, length = alphabet.length; i < length; i++) {\r\n      const char = alphabet[i];\r\n\r\n      if (!check(char)) {\r\n        throw new Error('Each element of an array must be a single char! (in Alphabet)');\r\n      }\r\n\r\n      a[char] = char;\r\n    }\r\n\r\n    /**\r\n     * @member {Object} Alphabet#$$\r\n     * @public\r\n     * @description The alphabet.\r\n     */\r\n    Object.defineProperty(this, '$$', { value: a });\r\n  }\r\n\r\n  /**\r\n   * @method Alphabet#add\r\n   * @public\r\n   * @param {...Char} chars - Chars to add.\r\n   * @returns {Alphabet} Returns this.\r\n   * @description Method for adding new letters to the alphabet.\r\n   *\r\n   * @example\r\n   * const alphabet = new Alphabet(['a', 'b', 'c']);\r\n   *\r\n   * alphabet.add('d', 'e');\r\n   *\r\n   * alphabet.get().$; // ['a', 'b', 'c', 'd', 'e']\r\n   */\r\n  add(...chars) {\r\n    for (let i = 0, length = chars.length; i < length; i++) {\r\n      const char = chars[i];\r\n\r\n      if (!check(char)) {\r\n        throw new Error('Each argument must be a single char! (in Alphabet#add)');\r\n      }\r\n\r\n      this.$$[char] = char;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Alphabet#contains\r\n   * @public\r\n   * @param {String} word - Word to check if it is in the alphabet or not.\r\n   * @returns {Boolean} If the word in the alphabet or not.\r\n   * @description Method that returns if a word is in alphabet or not.\r\n   *\r\n   * @example\r\n   * const alphabet = new Alphabet(['f', 'b', 'o', 'a', 'r']);\r\n   *\r\n   * alphabet.contains('foo'); // true\r\n   * alphabet.contains('bar'); // true\r\n   * alphabet.contains('baz'); // false\r\n   */\r\n  contains(word) {\r\n    validate([word], ['string'], 'Alphabet#contains');\r\n\r\n    const alphabet = this.$$;\r\n\r\n    for (let i = 0, length = word.length; i < length; i++) {\r\n      if (!alphabet[word[i]]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @method Alphabet#delete\r\n   * @public\r\n   * @param {...Char} chars - Chars to delete.\r\n   * @returns {Alphabet} Returns this.\r\n   * @description Method for deleting letters from the alphabet.\r\n   *\r\n   * @example\r\n   * const alphabet = new Alphabet(['a', 'b', 'c', 'd']);\r\n   *\r\n   * alphabet.delete('a');\r\n   *\r\n   * alphabet.get().$; // ['b', 'c', 'd']\r\n   *\r\n   * alphabet.delete('b', 'd');\r\n   *\r\n   * alphabet.get().$; // ['c']\r\n   */\r\n  delete(...chars) {\r\n    for (let i = 0, length = chars.length; i < length; i++) {\r\n      const char = chars[i];\r\n\r\n      if (!check(char)) {\r\n        throw new Error('Each argument must be a single char! (in Alphabet#delete)');\r\n      }\r\n\r\n      delete this.$$[char];\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Alphabet#get\r\n   * @returns {Array} Wrap of an array of alphabet letters.\r\n   * @description Method for getting array of alphabet letters.\r\n   *\r\n   * @example\r\n   * new Alphabet(['a', 'b', 'c']).get().$; // ['a', 'b', 'c']\r\n   */\r\n  get() {\r\n    return Object.keys(this.$$);\r\n  }\r\n\r\n  /**\r\n   * @method Alphabet#token\r\n   * @public\r\n   * @param {Number} length - Token length.\r\n   * @returns {String} Token.\r\n   * @description Method for generating random token with given length.\r\n   *\r\n   * @example\r\n   * new Alphabet(['a', 'b', 'c']).token(4); // 'abcb'\r\n   */\r\n  token(length) {\r\n    validate([length], [['intLike', '>0']], 'Alphabet#token');\r\n\r\n    const alphabet = Object.keys(this.$$);\r\n    const len = alphabet.length;\r\n    let token = '';\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      token += alphabet[Math.floor(Math.random() * len)];\r\n    }\r\n\r\n    return token;\r\n  }\r\n}\r\n\r\ndefineProperties(Alphabet.prototype, {\r\n  [Symbol.toStringTag]: 'Alphabet'\r\n});\r\n\r\nfunction check(char) {\r\n  return isString(char) && char.length === 1;\r\n}\r\n\r\n/**\r\n * @function alphabet\r\n * @public\r\n * @param {String} string - String to generate an alphabet from.\r\n * @returns {Alphabet} New instance of Alphabet.\r\n * @description Function for creating an alphabet from a string that has format like this:\r\n * '&lt;char1&gt;-&lt;char2&gt; &lt;char3&gt;-&lt;char4&gt;'\r\n *\r\n * @example\r\n * const a1 = alphabet('a-c 1-3');\r\n * const a2 = alphabet('5-5f-g');\r\n *\r\n * a1.get().$; // ['1', '2', '3', 'a', 'b', 'c']\r\n * a2.get().$; // ['5', 'f', 'g']\r\n */\r\nfunction alphabet(string) {\r\n  validate([string], ['string']);\r\n\r\n  const ranges = string.split(/([\\s\\S]-+[\\s\\S])?/g);\r\n  const length = ranges.length;\r\n  const alphabet = [];\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    const range = ranges[i];\r\n\r\n    if (!range || range === ' ') {\r\n      continue;\r\n    }\r\n\r\n    if (/-/.test(range) && !/[\\s\\S]-+[\\s\\S]/.test(range)) {\r\n      throw new Error(`Wrong part of the string (${ range })! (in alphabet)`);\r\n    }\r\n\r\n    if (/-/.test(range)) {\r\n      const start = range.charCodeAt(0);\r\n      const end = range.charCodeAt(2);\r\n\r\n      if (start > end) {\r\n        throw new Error('Start of the range must be before its end! (in alphabet)');\r\n      }\r\n\r\n      for (let k = 0, len = end - start + 1; k < len; k++) {\r\n        alphabet.push(String.fromCharCode(start + k));\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (range.length === 1) {\r\n      alphabet.push(range);\r\n    }\r\n  }\r\n\r\n  return new Alphabet(alphabet);\r\n}\r\n\r\nexport { Alphabet, alphabet };\r\n","/**\r\n * @module Switcher\r\n * @private\r\n * @mixin\r\n * @description Exports Switcher class.\r\n */\r\n\r\nimport {\r\n  isArray, isFunction, isString, isUndefined,\r\n  iterate, Symbol, toArray, defineProperties\r\n} from './helpers';\r\n\r\n/**\r\n * @typedef {'boolean'|'equals'|'strictEquals'|'call'} SwitcherMode\r\n * @public\r\n * @description Enum type of switcher modes.\r\n */\r\n\r\n/**\r\n * @callback SwitcherCallCallback\r\n * @public\r\n * @param {*} value - Switcher value.\r\n * @returns {Boolean|*} On what the callback returns depends if the case is a match (truthy for the match).\r\n */\r\n\r\n/**\r\n * @callback SwitcherMatchCallback\r\n * @public\r\n * @param {...*} args - Arguments from the second argument that switcher was called with.\r\n * @param {*} value - Switcher value.\r\n * @param {*} matched - Switcher matched case.\r\n */\r\n\r\n/**\r\n * @class Switcher\r\n * @public\r\n * @param {Object} [cases = {}] - Object of cases.\r\n * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.\r\n * @param {*} [defaultValue] - Switcher default value.\r\n * @returns {Switcher} - Instance of Switcher.\r\n * @description Switcher class for creating functions working similar to switch (value) {} construction,\r\n * but with the value assignment. Switcher instance is a function that accepts a value argument and an optional\r\n * args argument. Args with additional switcher value and matched case\r\n * are passed into the function of the matched case (if it is a function).\r\n *\r\n * @example\r\n * const switcher = new Switcher();\r\n * const switcher = new Switcher({\r\n *   case1: 'value1',\r\n *   case2: 'value2'\r\n * });\r\n * const switcher = new Switcher('strictEquals');\r\n * const switcher = new Switcher({\r\n *   case1: 'value1',\r\n *   case2: 'value2'\r\n * }, 'strictEquals');\r\n * const switcher = new Switcher('strictEquals', 'defaultValue');\r\n * const switcher = new Switcher({\r\n *   case1: 'value1',\r\n *   case2: 'value2'\r\n * }, 'strictEquals', 'defaultValue');\r\n *\r\n * // See [switcher]{@link switcher} examples for more information.\r\n */\r\nclass Switcher extends Function {\r\n  constructor(cases = {}, mode = 'equals', defaultValue) {\r\n    super();\r\n\r\n    if (isString(cases)) {\r\n      if (!isUndefined(arguments[1])) {\r\n        defaultValue = mode;\r\n      }\r\n\r\n      mode = cases;\r\n      cases = {};\r\n    }\r\n\r\n    const eventualCases = [];\r\n\r\n    iterate(cases, (value, Case) => {\r\n      eventualCases.push({ case: Case, value });\r\n    });\r\n\r\n    function switcher(value, args = []) {\r\n      const { mode, default: def, cases } = switcher.$$;\r\n\r\n      let ret = iterate(cases, ({ value: val, case: Case }) => {\r\n        if (\r\n          (mode === 'boolean' && Case) ||\r\n          /* eslint eqeqeq: 0 */\r\n          (mode === 'equals' && Case == value) ||\r\n          (mode === 'strictEquals' && Case === value) ||\r\n          (mode === 'call' && Case(value))\r\n        ) {\r\n          return { case: Case, value: val };\r\n        }\r\n      });\r\n\r\n      if (isUndefined(ret)) {\r\n        ret = { value: def };\r\n      }\r\n\r\n      if (!isFunction(ret.value)) {\r\n        return ret.value;\r\n      }\r\n\r\n      args = toArray(args, true);\r\n      args.push(value, ret.case);\r\n\r\n      return ret.value.apply(null, args);\r\n    }\r\n\r\n    /**\r\n     * @member Switcher#$$\r\n     * @type {Object}\r\n     * @protected\r\n     * @property {Array} cases - Array of cases.\r\n     * @property {SwitcherMode} mode - Switcher mode.\r\n     * @property {*} default - Switcher default value.\r\n     * @description Config parameters.\r\n     */\r\n    Object.defineProperty(switcher, '$$', {\r\n      value: {\r\n        cases: eventualCases,\r\n        mode,\r\n        default: defaultValue\r\n      }\r\n    });\r\n    Object.setPrototypeOf(switcher, Switcher.prototype);\r\n\r\n    return switcher;\r\n  }\r\n\r\n  /**\r\n   * @method Switcher#case\r\n   * @public\r\n   * @param {*|SwitcherCallCallback|Array.<*|SwitcherCallCallback>} cases - Case or an array of cases.\r\n   * @param {*|SwitcherMatchCallback} value - Value that has to be assigned or a function\r\n   * that is called with switcher value, if it's the case.\r\n   * @returns {Switcher} Returns this.\r\n   * @description Method for defining new cases.\r\n   *\r\n   * @example\r\n   * const sw = new Switcher()\r\n   *   .case(1, 'one')\r\n   *   .case(2, 'two');\r\n   *\r\n   * sw(1); // 'one'\r\n   * sw(2); // 'two'\r\n   */\r\n  case(cases, value) {\r\n    if (!isArray(cases)) {\r\n      cases = [cases];\r\n    }\r\n\r\n    iterate(cases, (Case) => {\r\n      this.$$.cases.push({ case: Case, value });\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Switcher#default\r\n   * @public\r\n   * @param {*} def - New default value.\r\n   * @returns {Switcher} Returns this.\r\n   * @description Method for redefining default switcher value.\r\n   *\r\n   * @example\r\n   * const sw = new Switcher()\r\n   *   .case(1, 'one')\r\n   *   .default('three');\r\n   *\r\n   * sw(1); // 'one'\r\n   * sw(2); // 'three'\r\n   */\r\n  default(def) {\r\n    this.$$.default = def;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Switcher#mode\r\n   * @public\r\n   * @param {SwitcherMode} mode - New switcher mode.\r\n   * @returns {Switcher} Returns this.\r\n   * @description Method for redefining switcher mode.\r\n   *\r\n   * @example\r\n   * const sw = new Switcher()\r\n   *   .mode('strictEquals')\r\n   *   .case(1, 'number')\r\n   *   .case('1', 'string');\r\n   *\r\n   * sw(1);   // 'number'\r\n   * sw('1'); // 'string'\r\n   */\r\n  mode(mode) {\r\n    this.$$.mode = mode;\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\ndefineProperties(Switcher.prototype, {\r\n  [Symbol.toStringTag]: 'Switcher'\r\n});\r\n\r\n/**\r\n * @function switcher\r\n * @public\r\n * @param {Object} [cases = {}] - Object of cases.\r\n * @param {SwitcherMode} [mode = 'equals'] - Switcher mode.\r\n * @param {*} [defaultValue] - Switcher default value.\r\n * @returns {Switcher} New instance of Switcher.\r\n * @description Simple wrap of [new Switcher(...)]{@link Switcher}.\r\n * \r\n * @example\r\n * const sw = switcher({\r\n *   1: 'foo',\r\n *   2: 'bar'\r\n * });\r\n * sw(1); // 'foo'\r\n * sw(2); // 'bar'\r\n * sw(3); // undefined\r\n * \r\n * @example\r\n * const sw = switcher()\r\n *   .case([1, 2], 'foo')\r\n *   .case(3, 'bar');\r\n *   \r\n * sw(1); // 'foo'\r\n * sw(2); // 'foo'\r\n * sw(3); // 'bar'\r\n * \r\n * @example\r\n * const sw = switcher('call')\r\n *   .case(isArray, 'array')\r\n *   .case(isString, 'string')\r\n *   .case(isNumber, 'number')\r\n *   .default('rest');\r\n *   \r\n * sw([]);    // 'array'\r\n * sw('foo'); // 'string'\r\n * sw(123);   // 'number'\r\n * sw({});    // 'rest'\r\n * \r\n * @example\r\n * const sw = switcher({\r\n *   1: (value) => {\r\n *     console.log(value + 1);\r\n *   },\r\n *   2: () => {\r\n *     console.log(value - 1);\r\n *   }\r\n * });\r\n * \r\n * sw(1); // 2\r\n * sw(2); // 1\r\n * \r\n * @example\r\n * const sw = switcher({\r\n *   first: (array) => array[0],\r\n *   last: (array) => array[array.length - 1]\r\n * }, 'equals', (array, index) => array[index]);\r\n * const array = [1, 2, 3, 4];\r\n * \r\n * sw('first', [array]); // 1\r\n * sw('last', [array]);  // 4\r\n * sw(1, [array]);       // 2\r\n * sw(2, [array]);       // 3\r\n */\r\nfunction switcher(cases, mode, defaultValue) {\r\n  return new Switcher(...arguments);\r\n}\r\n\r\n/**\r\n * @function when\r\n * @public\r\n * @param {Boolean|*} condition - Condition used for returning the proper value.\r\n * @param {*} value1 - Value if the condition is truthy.\r\n * @param {*} value2 - Value if the condition is falsey.\r\n * @returns {*} value1 or value2.\r\n * @description Synonym for\r\n * [ternary operator]{@link https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Operators/Conditional_Operator}.\r\n * \r\n * @example\r\n * when(true, 'true', 'false'); // 'true'\r\n */\r\nfunction when(condition, value1, value2) {\r\n  return condition ? value1 : value2;\r\n}\r\n\r\nexport { Switcher, switcher, when };\r\n","/**\r\n * @module Super\r\n * @private\r\n * @mixin\r\n * @description Exports Super class.\r\n */\r\n\r\nimport { D } from './D';\r\nimport { switcher } from './Switcher';\r\nimport { constructors } from './constants/constructors';\r\nimport {\r\n  isArray, isArrayLike, isDate, isElement, isFunction, isNil, isNaN, isNull,\r\n  isObject, isPlainObject, isPrimitive, isRegExp, isString, isUndefined,\r\n  validate, toStringTag, iterate, Symbol, defineProperties\r\n} from './helpers';\r\n\r\n/**\r\n * @typedef {Super|Arr|Func|Elem|Str|Num|Dat|BlobObject} DWrap\r\n * @public\r\n * @description Any kind of D-Wrap.\r\n */\r\n\r\n/**\r\n * @typedef {String|Number|null} Key\r\n * @public\r\n * @description Key type used in many methods.\r\n */\r\n\r\n/**\r\n * @typedef {TreeElement[]} Tree\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {Object} TreeElement\r\n * @public\r\n * @property {Key} key - Tree element key.\r\n * @property {*} value - Tree element value.\r\n * @description {@link Tree} element.\r\n */\r\n\r\n/**\r\n * @callback DeepIterationCallback\r\n * @public\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n * @param {Tree} tree - Tree of { key, value } elements.\r\n */\r\n\r\n/**\r\n * @callback DeepReduceCallback\r\n * @public\r\n * @param {*} previousValue - Previous value.\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n * @param {Tree} tree - Tree of { key, value } elements.\r\n */\r\n\r\n/**\r\n * @callback IterationCallback\r\n * @public\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n */\r\n\r\n/**\r\n * @callback JSONCallback\r\n * @public\r\n * @param {String|null} key - Current value.\r\n * @param {*} value - Current key.\r\n * @param {Object} object - Iteration object.\r\n */\r\n\r\n/**\r\n * @callback ObjectCallback\r\n * @public\r\n * @param {Object} newObject - The new object.\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n */\r\n\r\n/**\r\n * @callback ReduceCallback\r\n * @public\r\n * @param {*} previousValue - Previous value.\r\n * @param {*} value - Current iteration value.\r\n * @param {String|Number} key - Current iteration key/index.\r\n * @param {*} object - Iteration object.\r\n */\r\n\r\n/**\r\n * @callback SuperMethod\r\n * @public\r\n * @this {DWrap}\r\n */\r\n\r\nconst cloneSwitcher = switcher('call', (object) => object)\r\n  .case(\r\n    (object) => new Super(object) === object,\r\n    (object) => new (Object.getPrototypeOf(object).constructor)(new Super(object.$).deepClone().$)\r\n  )\r\n  .case(isElement, (object, deep) => object.clone(deep))\r\n  .case(isDate, (object) => new Date(object))\r\n  .case(isRegExp, (object) => new RegExp(object.source, object.toString().match(/[gimuy]*$/)[0]))\r\n  .case(isArray, () => [])\r\n  .case(isPlainObject, () => ({}));\r\n\r\n/**\r\n * @class Super\r\n * @public\r\n * @param {*} [object] - An object to wrap.\r\n * @returns {DWrap} Instance of Super.\r\n * @description Wrap of any value. And there is no way to create a nested wrap.\r\n *\r\n * @example\r\n * new Super({}); // Super\r\n */\r\nclass Super {\r\n  constructor(object) {\r\n    if (object instanceof Super) {\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * @member Super#$\r\n     * @type {*}\r\n     * @public\r\n     * @description Wrapped object.\r\n     */\r\n    Object.defineProperty(this, '$', { value: object });\r\n  }\r\n\r\n  /**\r\n   * @method Super.addStaticProperties\r\n   * @public\r\n   * @param {String|Object} property - Either a string of a property or an object\r\n   * with properties keys and values values.\r\n   * @param {Object} [value] - If a property parameter is a string this has to be a property value.\r\n   * @returns {this} Returns this.\r\n   * @description Sets static properties for DWrap constructors.\r\n   *\r\n   * @example\r\n   * Super.addStaticProperties('cool', 42);\r\n   * Super.addStaticProperties('superCool', 42*42);\r\n   */\r\n  static addStaticProperties(property, value) {\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: value };\r\n    }\r\n\r\n    defineProperties(this, property);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super.addInstanceProperties\r\n   * @public\r\n   * @param {String|Object} property - Either a string of a property or an object\r\n   * with properties keys and values values.\r\n   * @param {Object} [value] - If a property parameter is a string this has to be a property value.\r\n   * @returns {this} Returns this.\r\n   * @description Sets static properties for DWrap prototypes.\r\n   *\r\n   * @example\r\n   * Super.addInstanceProperties('cool', 42);\r\n   * Super.addInstanceProperties('superCool', 42*42);\r\n   */\r\n  static addInstanceProperties(property, value) {\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: value };\r\n    }\r\n\r\n    defineProperties(this.prototype, property);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#assign\r\n   * @public\r\n   * @param {...(Object|Super|*)} objects - Objects to be assigned to the object.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Synonym for\r\n   * [Object.assign]\r\n   * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2 }).assign({ a: 3 }, { c: 3, d: 4 }, { d: 5 }).$; // { a: 3, b: 2, c: 3, d: 5 }\r\n   */\r\n  assign(...objects) {\r\n    const object = this.$;\r\n\r\n    iterate(object && arguments, (o) => {\r\n      iterate(new Super(o).$, (value, key) => {\r\n        object[key] = value;\r\n      });\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#average\r\n   * @public\r\n   * @param {IterationCallback} [callback = null] - Callback that is passed to {@link Super#sum}.\r\n   * @returns {Number} Average value.\r\n   * @description Synonym for object.sum(callback) / object.count.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).average();                         // 2\r\n   * new Super({ a: 1, b: 2, c: 5 }).average((value) => value * value); // 10\r\n   */\r\n  average(callback = null) {\r\n    validate([callback], ['function||!'], 'Super#average');\r\n\r\n    return this.sum(callback) / this.count;\r\n  }\r\n\r\n  /**\r\n   * @method Super#call\r\n   * @public\r\n   * @param {SuperMethod} func - Function to be called with this context.\r\n   * @param {...*} args - Arguments to be called with.\r\n   * @returns {*} Return of function call.\r\n   * @description Synonym for func.call(DObject, ...args);\r\n   *\r\n   * @example\r\n   * new Super({ a: 1 }).call(function (b, c) {\r\n   *   return this.a + b + c;\r\n   * }, 2, 3); // 6\r\n   */\r\n  call(func, ...args) {\r\n    validate([func], ['function'], 'Super#call');\r\n\r\n    return func.apply(this, args);\r\n  }\r\n\r\n  /**\r\n   * @method Super#clone\r\n   * @returns {DWrap} New object.\r\n   * @description Method assigns properties of the object to an empty one and returns the new one.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2 } }).clone().$; // { a: 1, b: { c: 2 } }\r\n   */\r\n  clone() {\r\n    const object = this.$;\r\n    const clone = cloneSwitcher(object, [object, false]);\r\n\r\n    if (clone !== object) {\r\n      iterate(object, (value, key) => {\r\n        clone[key] = value;\r\n      });\r\n    }\r\n\r\n    return new this.constructor(clone);\r\n  }\r\n\r\n  /**\r\n   * @member Super#count\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description Returns number of own enumerable keys of the object.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2 }).count; // 2\r\n   */\r\n  get count() {\r\n    const object = this.$;\r\n\r\n    if (!isObject(object)) {\r\n      return 0;\r\n    }\r\n\r\n    return isArrayLike(object) ? object.length : Object.keys(object).length;\r\n  }\r\n\r\n  /**\r\n   * @method Super#create\r\n   * @public\r\n   * @param {Object} [descriptors] - Descriptors passed to Object.create.\r\n   * @returns {DWrap} New instance of D-Wrap.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\r\n   * @description Synonym for\r\n   * [Object.create]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create}.\r\n   *\r\n   * @example\r\n   * new Super({}).create({\r\n   *   a: {\r\n   *     value: 1,\r\n   *     enumerable: false,\r\n   *     writable: true,\r\n   *     configurable: false\r\n   *   }\r\n   * }).$; // { a: 1 }\r\n   */\r\n  create(descriptors) {\r\n    return D(isPrimitive(this.$) ? undefined : Object.create(this.$, descriptors));\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepAssign\r\n   * @public\r\n   * @param {...*} objects - Objects to be assigned to the object.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Deep analogue of {@link Super#assign}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1 }).deepAssign(\r\n   *   {\r\n   *     b: {\r\n   *       c: 2\r\n   *     }\r\n   *   },\r\n   *   {\r\n   *     a: {\r\n   *       b: 1\r\n   *     }\r\n   *   },\r\n   *   {\r\n   *     a: {\r\n   *       c: {\r\n   *         d: 1\r\n   *       }\r\n   *     },\r\n   *     b: 2\r\n   *   },\r\n   *   null\r\n   * });\r\n   * // {\r\n   * //   a: {\r\n   * //     b: 1,\r\n   * //     c: {\r\n   * //       d: 1\r\n   * //     }\r\n   * //   },\r\n   * //   b: 2,\r\n   * // }\r\n   */\r\n  deepAssign(...objects) {\r\n    const object = this.$;\r\n\r\n    if (isPrimitive(object)) {\r\n      return this;\r\n    }\r\n\r\n    iterate(arguments, (o) => {\r\n      deepAssign(object, o);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepClone\r\n   * @public\r\n   * @returns {DWrap} New instance of DWrap.\r\n   * @description Deep cloning method. Clones plain objects, arrays, regular expressions and elements, the rest stays the same.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: [2, 3], c: { d: 4 } }).deepClone().$;\r\n   * // {\r\n   * //   a: 1,\r\n   * //   b: [2, 3],\r\n   * //   c: { d: 4 }\r\n   * // }\r\n   */\r\n  deepClone() {\r\n    return new this.constructor(deepClone(this.$));\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepEquals\r\n   * @public\r\n   * @param {*} [object] - Object to compare to.\r\n   * @returns {Boolean} - If the objects are deep equal or not.\r\n   * @description Method for deep comparison of two objects.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1 }).deepEquals({ a: '1' }); // true\r\n   * new Super(/1/).deepEquals(/1/);             // true\r\n   */\r\n  deepEquals(object = null) {\r\n    return deepEqual(this.$, object, false);\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepEvery\r\n   * @public\r\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy iteration goes on and if falsey it stops.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {Boolean} If all the callback calls returned truthy value.\r\n   * @description Returns boolean if all the callback calls returned truthy value.\r\n   * Otherwise false. Deep analogue of {@link Super#every}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepEvery((value) => value < 4); // true\r\n   * new Super({ a: {}, b: {}, c: {} }).deepEvery(() => false);              // true\r\n   */\r\n  deepEvery(callback, n) {\r\n    if (arguments.length === 1 && !isFunction(callback)) {\r\n      n = callback;\r\n      callback = Boolean;\r\n    } else if (arguments.length === 1) {\r\n      n = Infinity;\r\n    } else if (!arguments.length) {\r\n      n = Infinity;\r\n      callback = Boolean;\r\n    }\r\n\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepEvery');\r\n\r\n    n = Number(n);\r\n\r\n    return deepEvery(this.$, callback, n, [{ key: null, value: this.$ }]);\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepFilter\r\n   * @public\r\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy the element is included and if falsey it's excluded.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {DWrap} New D-Wrap of filtered object.\r\n   * @description Returns filtered by the callback object. Deep analogue of {@link Super#filter}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value%2).$;     // { a: 1, b: { d: 3 } }\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value === 1).$; // { a: 1 }\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFilter((value) => value > 3).$;   // {}\r\n   */\r\n  deepFilter(callback, n) {\r\n    if (arguments.length === 1 && !isFunction(callback)) {\r\n      n = callback;\r\n      callback = Boolean;\r\n    } else if (arguments.length === 1) {\r\n      n = Infinity;\r\n    } else if (!arguments.length) {\r\n      n = Infinity;\r\n      callback = Boolean;\r\n    }\r\n\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFilter');\r\n\r\n    const filtered = deepFilter(this.$, callback, n, [{ key: null, value: this.$ }]);\r\n\r\n    return D(isNil(filtered) ? filtered : filtered || {});\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepFind\r\n   * @public\r\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy iteration stops and if falsey it continues.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {Tree|null} Tree of { key, value } if something found and null if not.\r\n   * @description Returns tree of the elements if something found and null if nothing found.\r\n   * Deep analogue of {@link Super#find}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFind((value) => value === 2);\r\n   * // [\r\n   * //   { key: 'c', value: 2 },\r\n   * //   { key: 'b', value: { c: 2, d: 3 } },\r\n   * //   { key: null, value: <initial object> }\r\n   * // ]\r\n   */\r\n  deepFind(callback, n) {\r\n    if (arguments.length === 1 && !isFunction(callback)) {\r\n      n = callback;\r\n      callback = Boolean;\r\n    } else if (arguments.length === 1) {\r\n      n = Infinity;\r\n    } else if (!arguments.length) {\r\n      n = Infinity;\r\n      callback = Boolean;\r\n    }\r\n\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepFind');\r\n\r\n    return deepFind(this.$, callback, n, [{ key: null, value: this.$ }]);\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepForEach\r\n   * @public\r\n   * @param {DeepIterationCallback} callback - Called on each iteration.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;\r\n   * // { a: 1, b: { c: 4, d: 9 } }\r\n   */\r\n  deepForEach(callback, n = Infinity) {\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');\r\n\r\n    n = Number(n);\r\n\r\n    deepForEach(this.$, callback, n, [{ key: null, value: this.$ }]);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepForEach\r\n   * @public\r\n   * @param {DeepIterationCallback} callback - Called on each iteration.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Method for iterating over any object. Deep analogue of {@link Super#forEach}.\r\n   * Unlike {@link Super#deepForEach} the callback is called on every value of every object inside\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepForEach((value, key, object) => object[key] = value * value).$;\r\n   * // { a: 1, b: { c: 4, d: 9 } }\r\n   */\r\n  deepForEachEntry(callback, n = Infinity) {\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepForEach');\r\n\r\n    n = Number(n);\r\n\r\n    deepForEachEntry(this.$, callback, n, [{ key: null, value: this.$ }]);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepFreeze\r\n   * @public\r\n   * @returns {DWrap} Returns this.\r\n   * @description Deep analogue of {@link Super#freeze}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepFreeze(); // Super\r\n   */\r\n  deepFreeze() {\r\n    deepFreeze(this.$);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepMap\r\n   * @public\r\n   * @param {DeepIterationCallback} callback - Called on each iteration.\r\n   * Return value is used for creating a new object.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {DWrap} D-Wrap of the new object.\r\n   * @description Returns a wrap of a new object using the callback. Deep analogue of {@link Super#map}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepMap((value) => value * value).$;\r\n   * // { a: 1, b: { c: 4, d: 9 } }\r\n   */\r\n  deepMap(callback, n = Infinity) {\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepMap');\r\n\r\n    n = Number(n);\r\n\r\n    return D(deepMap(this.$, callback, n, [{ key: null, value: this.$ }]));\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepReduce\r\n   * @public\r\n   * @param {DeepReduceCallback} callback - Called on each iteration.\r\n   * Return value is passed to the next callback call.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @param {*} [IV = <first value>|undefined] - Initial value.\r\n   * @returns {*} Modified IV.\r\n   * @description Returns modified IV. Deep analogue of {@link Super#reduce}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepReduce((sum, value) => sum + value * value, Infinity, 0); // 14\r\n   */\r\n  deepReduce(callback, n = Infinity, IV) {\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepReduce');\r\n\r\n    n = Number(n);\r\n\r\n    const object = this.$;\r\n    const tree = [{ key: null, value: this.$ }];\r\n\r\n    if (arguments.length < 3) {\r\n      return deepReduce(object, callback, n, false, undefined, tree).IV;\r\n    }\r\n\r\n    return deepReduce(object, callback, n, false, { IV }, tree).IV;\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepSome\r\n   * @public\r\n   * @param {DeepIterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy iteration stops and if falsey it continues.\r\n   * @param {Number} [n = Infinity] - Iteration depth.\r\n   * @returns {Boolean} If all the callback calls returned truthy value.\r\n   * @description Returns true if some of the callback calls returned truthy value.\r\n   * Otherwise false. Deep analogue of {@link Super#some}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: { c: 2, d: 3 } }).deepSome((value) => value > 4); // false\r\n   * new Super({ a: {}, b: {}, c: {} }).deepSome(() => true);               // false\r\n   */\r\n  deepSome(callback, n) {\r\n    if (arguments.length === 1 && !isFunction(callback)) {\r\n      n = callback;\r\n      callback = Boolean;\r\n    } else if (arguments.length === 1) {\r\n      n = Infinity;\r\n    } else if (!arguments.length) {\r\n      n = Infinity;\r\n      callback = Boolean;\r\n    }\r\n\r\n    validate([callback, n], ['function', ['numberLike', '>0']], 'Super#deepSome');\r\n\r\n    n = Number(n);\r\n\r\n    return deepSome(this.$, callback, n, [{ key: null, value: this.$ }]);\r\n  }\r\n\r\n  /**\r\n   * @method Super#deepStrictEquals\r\n   * @public\r\n   * @param {*} [object] - Object to compare to.\r\n   * @returns {Boolean} - If the objects are deep strict equal or not.\r\n   * @description Method for deep strict comparison of two objects.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1 }).deepStrictEquals({ a: '1' }); // false\r\n   * new Super(/1/).deepStrictEquals(/1/);             // true\r\n   */\r\n  deepStrictEquals(object = null) {\r\n    return deepEqual(this.$, object, true);\r\n  }\r\n\r\n  /**\r\n   * @method Super#define\r\n   * @param {String|Object} property - Either a string of a property or a descriptors object.\r\n   * @param {Object} [descriptor] - If a property parameter is a string this has to be a property descriptor.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Synonym for both\r\n   * [Object.defineProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty}\r\n   * and\r\n   * [Object.defineProperties]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties}.\r\n   *\r\n   * @example\r\n   * new Super({}).define('a', {\r\n   *   value: 1,\r\n   *   enumerable: false,\r\n   *   writable: true,\r\n   *   configurable: false\r\n   * }).$; // { a: 1 }\r\n   * new Super({}).define({\r\n   *   a: {\r\n   *     value: 1,\r\n   *     enumerable: false,\r\n   *     writable: true,\r\n   *     configurable: false\r\n   *   }\r\n   * }).$; // { a: 1 }\r\n   */\r\n  define(property, descriptor) {\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: descriptor };\r\n    }\r\n\r\n    property = new Super(property).$;\r\n\r\n    if (isObject(this.$)) {\r\n      Object.defineProperties(this.$, property);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#delete\r\n   * @public\r\n   * @param {...String} props - List of properties to delete.\r\n   * @returns {DWrap} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete\r\n   * @description Synonym for multiple\r\n   * [\"delete\" operator]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/delete}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).delete('c', 'a').$; // { b: 2 }\r\n   */\r\n  delete(...props) {\r\n    const object = this.$;\r\n\r\n    iterate(object && props, (property) => {\r\n      delete object[property];\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#equals\r\n   * @public\r\n   * @param {*} [object] - Object to compare.\r\n   * @returns {Boolean} If the objects are equal or not.\r\n   * @description Returns true if objects are equal using '==' operator and false if not. NaNs are considered to be equal.\r\n   *\r\n   * @example\r\n   * new Super(3).equals('3');   // true\r\n   * new Super(NaN).equals(NaN); // true\r\n   */\r\n  equals(object) {\r\n    const o = this.$;\r\n\r\n    object = new Super(object).$;\r\n\r\n    /* eslint eqeqeq: 0 */\r\n    return o == object || (isNaN(o) && isNaN(object));\r\n  }\r\n\r\n  /**\r\n   * @method Super#every\r\n   * @public\r\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy iteration goes on and if falsey it stops.\r\n   * @returns {Boolean} If all the callback calls returned truthy value.\r\n   * @description Returns boolean if all the callback calls returned truthy value.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).every((value) => value < 4); // true\r\n   * new Super({}).every(() => false);                            // true\r\n   */\r\n  every(callback = Boolean) {\r\n    validate([callback], ['function'], 'Super#every');\r\n\r\n    return iterate(this.$, (value, key, object) => {\r\n      if (!callback(value, key, object)) {\r\n        return false;\r\n      }\r\n    }) !== false;\r\n  }\r\n\r\n  /**\r\n   * @method Super#filter\r\n   * @public\r\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy the element is included and if falsey it's excluded.\r\n   * @returns {DWrap} New D-Wrap of filtered object.\r\n   * @description Returns filtered by the callback object.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).filter((value) => value%2).$; // { a: 1, c: 3 }\r\n   * new Super(null).filter((value) => value%2).$;                 // null\r\n   */\r\n  filter(callback = Boolean) {\r\n    validate([callback], ['function'], 'Super#filter');\r\n\r\n    const object = this.$;\r\n    const array = isArrayLike(object);\r\n\r\n    /* eslint no-nested-ternary: 0 */\r\n    const o = array ? [] : isNil(object) ? object : {};\r\n\r\n    iterate(object, (value, key) => {\r\n      if (callback(value, key, object)) {\r\n        if (array) {\r\n          o.push(value);\r\n        } else {\r\n          o[key] = value;\r\n        }\r\n      }\r\n    });\r\n\r\n    return D(o);\r\n  }\r\n\r\n  /**\r\n   * @method Super#find\r\n   * @public\r\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy iteration stops and if falsey it continues.\r\n   * @returns {{ key: Key, value: * }|null} { key, value } if found and null if not.\r\n   * @description Returns found { key, value } if something found and null if nothing found.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).find((value) => value === 2); // { key: 'b', value: 2 }\r\n   * new Super([1, 2, 3]).find((value) => value === 2);            // { key: 1, value: 2 }\r\n   */\r\n  find(callback) {\r\n    validate([callback], ['function'], 'Super#find');\r\n\r\n    return iterate(this.$, (value, key, object) => {\r\n      if (callback(value, key, object)) {\r\n        return { key, value };\r\n      }\r\n    }) || null;\r\n  }\r\n\r\n  /**\r\n   * @method Super#forEach\r\n   * @public\r\n   * @param {IterationCallback} callback - Called on each iteration.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Method for iterating over any object.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).forEach((value, key, object) => {\r\n   *   object[key] = value * value;\r\n   * }).$; // { a: 1, b: { c: 4, d: 5 } }\r\n   */\r\n  forEach(callback) {\r\n    validate([callback], ['function'], 'Super#forEach');\r\n\r\n    iterate(this.$, (value, key, object) => {\r\n      callback(value, key, object);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#freeze\r\n   * @public\r\n   * @returns {DWrap} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\r\n   * @description Synonym for\r\n   * [Object.freeze]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).freeze(); // Super\r\n   */\r\n  freeze() {\r\n    Object.freeze(this.$);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#get\r\n   * @public\r\n   * @param {String|Object.<String, Function>} property - Either a string of a property or a getters object.\r\n   * @param {Function} [getter] - If a property parameter is a string this has to be a getter function.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Method for defining getters.\r\n   *\r\n   * @example\r\n   * const object1 = new Super({}).get('a', () => 1).$;\r\n   * object1.a; // 1\r\n   *\r\n   * const object2 = new Super({}).get({\r\n   *   a: () => 2\r\n   * }).$;\r\n   * object2.a; // 2\r\n   */\r\n  get(property, getter) {\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: getter };\r\n    }\r\n\r\n    const object = this.$;\r\n\r\n    iterate(isObject(object) && new Super(property).$, (getter, property) => {\r\n      Object.defineProperty(object, property, { get: getter });\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#has\r\n   * @public\r\n   * @param {String|*} key - Property to check.\r\n   * @returns {Boolean} Returns true if the object has the key and false if not.\r\n   * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in\r\n   * @description Synonym for\r\n   * [\"in\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).has('b'); // true\r\n   */\r\n  has(key) {\r\n    const object = this.$;\r\n\r\n    if (!isObject(object)) {\r\n      return false;\r\n    }\r\n\r\n    return key in object;\r\n  }\r\n\r\n  /**\r\n   * @method Super#hasOwn\r\n   * @public\r\n   * @param {String|*} key - Property to check.\r\n   * @returns {Boolean} Returns true if the object has its own key and false if not.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\r\n   * @description Synonym for\r\n   * [Object#hasOwnProperty]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).hasOwn('b');              // true\r\n   * new Super({ a: 1, b: 2, c: 3 }).hasOwn('hasOwnProperty'); // false\r\n   */\r\n  hasOwn(key) {\r\n    const object = this.$;\r\n\r\n    if (!isObject(object)) {\r\n      return false;\r\n    }\r\n\r\n    return {}.hasOwnProperty.call(object, key);\r\n  }\r\n\r\n  /**\r\n   * @method Super#instanceof\r\n   * @public\r\n   * @param {Function} constructor - Constructor to check.\r\n   * @returns {Boolean} If the object is an instance of constructor.\r\n   * @see https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof\r\n   * @description Synonym for\r\n   * [\"instanceof\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}.\r\n   */\r\n  instanceof(constructor) {\r\n    return this.$ instanceof constructor;\r\n  }\r\n\r\n  /**\r\n   * @method Super#isFrozen\r\n   * @public\r\n   * @returns {Boolean} If the object is frozen.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\r\n   * @description Synonym for\r\n   * [Object.isFrozen]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen}.\r\n   *\r\n   * @example\r\n   * new Super({}).freeze().isFrozen(); // true\r\n   */\r\n  isFrozen() {\r\n    return Object.isFrozen(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Super#json\r\n   * @public\r\n   * @param {JSONCallback|String[]} [replacer] - See the link.\r\n   * @param {String|Number} [space] - See the link.\r\n   * @returns {String} JSON string.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\r\n   * @description Synonym for\r\n   * [JSON.stringify]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).json(); // '{\"a\":1,\"b\":2,\"c\":3}'\r\n   * new Super({ a: 1, b: 2, c: 3 }).json('    ');\r\n   * // {\r\n   * //     \"a\": 1,\r\n   * //     \"b\": 2,\r\n   * //     \"c\": 3\r\n   * // }\r\n   * new Super({ a: 1, b: 2, c: 3 }).json((key, value) => {\r\n   *   if (typeof value === 'number') {\r\n   *     return value%2 ? key + value0 : undefined;\r\n   *   }\r\n   *\r\n   *   return value;\r\n   * }, 2);\r\n   * // {\r\n   * //   \"a\": \"a1\",\r\n   * //   \"c\": \"c3\"\r\n   * // }\r\n   */\r\n  json(replacer, space) {\r\n    if (arguments.length === 1 && !isFunction(replacer) && !isArray(replacer)) {\r\n      [].unshift.call(arguments, null);\r\n    }\r\n\r\n    [].unshift.call(arguments, this.$);\r\n\r\n    return JSON.stringify.apply(JSON, arguments);\r\n  }\r\n\r\n  /**\r\n   * @method Super#keyOf\r\n   * @public\r\n   * @param {*} value - Value to find.\r\n   * @returns {String|Number|null} A key or an index if found and null if not.\r\n   * @description Method for finding equal to the argument value in the object. NaNs are considered to be equal.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).keyOf(2);   // 'b'\r\n   * new Super({ a: 1, b: 2, c: 3 }).keyOf('2'); // 'b'\r\n   */\r\n  keyOf(value) {\r\n    const key = iterate(this.$, (val, key) => {\r\n      if (val == value || (isNaN(val) && isNaN(value))) {\r\n        return key;\r\n      }\r\n    });\r\n\r\n    return isUndefined(key) ? null : key;\r\n  }\r\n\r\n  /**\r\n   * @method Super#keyOfStrict\r\n   * @public\r\n   * @param {*} value - Value to find.\r\n   * @returns {String|Number|null} A key or an index if found and null if not.\r\n   * @description Method for finding strict equal to the argument value in the object. NaNs are considered to be equal.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict(2);   // 'b'\r\n   * new Super({ a: 1, b: 2, c: 3 }).keyOfStrict('2'); // 'b'\r\n   */\r\n  keyOfStrict(value) {\r\n    const key = iterate(this.$, (val, key) => {\r\n      if (val === value || (isNaN(val) && isNaN(value))) {\r\n        return key;\r\n      }\r\n    });\r\n\r\n    return isUndefined(key) ? null : key;\r\n  }\r\n\r\n  /**\r\n   * @method Super#keys\r\n   * @public\r\n   * @returns {DWrap} A wrap of the keys array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\r\n   * @description Synonym for\r\n   * [Object.keys]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).keys().$; // ['a', 'b', 'c']\r\n   * new Super(null).keys().$;                 // []\r\n   */\r\n  keys() {\r\n    const object = this.$;\r\n\r\n    return D(isObject(object) ? Object.keys(object) : []);\r\n  }\r\n\r\n  /**\r\n   * @method Super#map\r\n   * @public\r\n   * @param {IterationCallback} callback - Called on each iteration.\r\n   * Return value is used for creating a new object.\r\n   * @returns {DWrap} D-Wrap of the new object.\r\n   * @description Returns a wrap of a new object using the callback.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).map((value) => value * 2).$; // { a: 2, b: 4, c: 6 }\r\n   * new Super(null).map((value) => value * 2).$;                 // null\r\n   */\r\n  map(callback) {\r\n    validate([callback], ['function'], 'Super#map');\r\n\r\n    const object = this.$;\r\n    const o = isArrayLike(object) ? [] : isNull(object) ? null : {};\r\n\r\n    iterate(object, (value, key) => {\r\n      o[key] = callback(value, key, object);\r\n    });\r\n\r\n    return D(o);\r\n  }\r\n\r\n  /**\r\n   * @method Super#max\r\n   * @public\r\n   * @param {IterationCallback} callback - Called on each iteration.\r\n   * Return value is used for comparison with the previous max value.\r\n   * @returns {{key: Key, value: Number}} Object with max value and key of the max value.\r\n   * @description Method for finding max value in the object.\r\n   * If no callback is present comparison is between values of the object.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).max();                     // { key: 'c', value: 3 }\r\n   * new Super({ a: 1, b: 2, c: 3 }).max((value) => 4 - value); // { key: 'a', value: 3 }\r\n   * new Super({ a: 'a', b: 'b', c: 'c' }).max();               // { key: null, value: -Infinity }\r\n   */\r\n  max(callback = null) {\r\n    validate([callback], ['function||!'], 'Super#max');\r\n\r\n    return this.object((max, value, key, object) => {\r\n      const val = Number(callback ? callback(value, key, object) : value);\r\n\r\n      if (val > max.value) {\r\n        max.key = key;\r\n        max.value = val;\r\n      }\r\n    }, { key: null, value: -Infinity }).$;\r\n  }\r\n\r\n  /**\r\n   * @method Super#min\r\n   * @public\r\n   * @param {IterationCallback} callback - Called on each iteration.\r\n   * Return value is used for comparison with the previous min value.\r\n   * @returns {{key: Key, value: Number}} Object with min value and key of the min value.\r\n   * @description Method for finding min value in the object.\r\n   * If no callback is present comparison is between values of the object.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).min();                     // { key: 'a', value: 1 }\r\n   * new Super({ a: 1, b: 2, c: 3 }).min((value) => 4 - value); // { key: 'c', value: 1 }\r\n   * new Super({ a: 'a', b: 'b', c: 'c' }).min();               // { key: null, value: Infinity }\r\n   */\r\n  min(callback = null) {\r\n    validate([callback], ['function||!'], 'Super#min');\r\n\r\n    return this.object((min, value, key, object) => {\r\n      const val = Number(callback ? callback(value, key, object) : value);\r\n\r\n      if (val < min.value) {\r\n        min.key = key;\r\n        min.value = val;\r\n      }\r\n    }, { key: null, value: Infinity }).$;\r\n  }\r\n\r\n  /**\r\n   * @method Super#object\r\n   * @public\r\n   * @param {ObjectCallback} callback - Called on each iteration.\r\n   * @param {Object|*} [object = {}] - Object that is passed to the callback.\r\n   * @returns {DWrap} Wrap of the new object.\r\n   * @description Type of {@link Super#reduce}.\r\n   * The object is passed as an argument into the callback. The output is this object.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2 }).object((object, value, key) => {\r\n   *   object[key] = value;\r\n   *   object[key + key] = value * 2;\r\n   * }).$; // { a: 1, aa: 2, b: 2, bb: 4 }\r\n   */\r\n  object(callback, object = {}) {\r\n    validate([callback], ['function'], 'Super#object');\r\n\r\n    iterate(this.$, (value, key, obj) => {\r\n      callback(object, value, key, obj);\r\n    });\r\n\r\n    return D(object);\r\n  }\r\n\r\n  /**\r\n   * @method Super#prop\r\n   * @public\r\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\r\n   * @param {*} [value] - If a property parameter is a string\r\n   * this has to be an assigned value if it's present.\r\n   * @returns {DWrap|*} Returns this if it's a setter or a value if getter.\r\n   * @description Method for getting and setting properties.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).prop('a');              // 1\r\n   * new Super({ a: 1, b: 2, c: 3 }).prop('a', 7).$;         // { a: 7, b: 2, c: 3 }\r\n   * new Super({ a: 1, b: 2, c: 3 }).prop({ a: 7, b: 8 }).$; // { a: 7, b: 8, c: 3 }\r\n   */\r\n  prop(property, value) {\r\n    if (arguments.length <= 1 && isString(property)) {\r\n      return this.$ ? this.$[property] : undefined;\r\n    }\r\n\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: value };\r\n    }\r\n\r\n    return this.assign(property);\r\n  }\r\n\r\n  /**\r\n   * @method Super#propertyDescriptor\r\n   * @public\r\n   * @param {String} property - Property of the object.\r\n   * @returns {Object|undefined} Property descriptor.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\r\n   * @descriptor Synonym for\r\n   * [Object.getOwnPropertyDescriptor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1 }).propertyDescriptor('a');\r\n   * // {\r\n   * //   value: 1,\r\n   * //   enumerable: true,\r\n   * //   writable: true,\r\n   * //   configurable: true\r\n   * // }\r\n   */\r\n  propertyDescriptor(property) {\r\n    const object = this.$;\r\n\r\n    return isObject(object) ? Object.getOwnPropertyDescriptor(object, property) : undefined;\r\n  }\r\n\r\n  /**\r\n   * @method Super#propertyNames\r\n   * @public\r\n   * @returns {DWrap} D-Wrap of the names array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\r\n   * @descriptor Synonym for\r\n   * [Object.getOwnPropertyNames]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames}.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2 }).define('c', { value: 3 }).$; // ['a', 'b', 'c']\r\n   */\r\n  propertyNames() {\r\n    const object = this.$;\r\n\r\n    return D(isObject(object) ? Object.getOwnPropertyNames(object) : []);\r\n  }\r\n\r\n  /**\r\n   * @method Super#propertySymbols\r\n   * @public\r\n   * @returns {DWrap} D-Wrap of the names array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\r\n   * @descriptor Synonym for\r\n   * [Object.getOwnPropertySymbols]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols}.\r\n   *\r\n   * @example\r\n   * new Super({ [Symbol('foo')]: 1 }).define(Symbol('bar'), { value: 2 }).$; // [Symbol('foo'), Symbol('bar')]\r\n   */\r\n  propertySymbols() {\r\n    const object = this.$;\r\n\r\n    return D(isObject(object) ? Object.getOwnPropertySymbols(object) : []);\r\n  }\r\n\r\n  /**\r\n   * @method Super#proto\r\n   * @public\r\n   * @param {*} [proto] - If it's present it's set as a prototype to the object.\r\n   * @returns {DWrap} In getter mode returns wrap of the prototype and in setter mode returns this.\r\n   * @description Synonym for both\r\n   * [Object.getPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf}\r\n   * and\r\n   * [Object.setPrototypeOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf}.\r\n   */\r\n  proto(proto) {\r\n    const object = this.$;\r\n    const isContextObject = !isNil(object);\r\n\r\n    if (arguments.length) {\r\n      if (isContextObject && (isObject(proto) || isNull(proto))) {\r\n        Object.setPrototypeOf(object, proto);\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n    return isContextObject ? new Super(Object.getPrototypeOf(object)) : new Super();\r\n  }\r\n\r\n  /**\r\n   * @method Super#reduce\r\n   * @public\r\n   * @param {ReduceCallback} callback - Called on each iteration.\r\n   * Return value is passed to the next callback call.\r\n   * @param {*} [IV = <first value>|undefined] - Initial value.\r\n   * @returns {*} Modified IV.\r\n   * @description Returns modified IV. If the second argument is not present first value in the object is taken\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).reduce((sum, value) => sum + value * value, 0); // 14\r\n   */\r\n  reduce(callback, IV) {\r\n    validate([callback], ['function'], 'Super#reduce');\r\n\r\n    const object = this.$;\r\n\r\n    let startKey;\r\n\r\n    if (arguments.length === 1) {\r\n      iterate(object, (value, key) => {\r\n        startKey = key;\r\n        IV = value;\r\n\r\n        return true;\r\n      });\r\n    }\r\n\r\n    iterate(object, (value, key) => {\r\n      if (key !== startKey) {\r\n        IV = callback(IV, value, key, object);\r\n      }\r\n    });\r\n\r\n    return IV;\r\n  }\r\n\r\n  /**\r\n   * @method Super#set\r\n   * @public\r\n   * @param {String|Object.<String, Function>} property - Either a string of a property or a setters object.\r\n   * @param {Function} [setter] - If a property parameter is a string this has to be a setter function.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Method for defining setters.\r\n   *\r\n   * @example\r\n   * const object = new Super({})\r\n   *   .get('public', function () {\r\n   *     return this._private;\r\n   *   })\r\n   *   .set('public', function (value) {\r\n   *     if (typeof value === 'number') {\r\n   *       this._private = value;\r\n   *     }\r\n   *   });\r\n   * object.prop('public', '1').$; // { public: undefined }\r\n   * object.prop('public', 1).$;   // { public: 1, _private: 1 }\r\n   *\r\n   * new Super({}).set({\r\n   *   public(value) {\r\n   *     if (typeof value === 'number') {\r\n   *       this._private = value;\r\n   *     }\r\n   *   }\r\n   * });\r\n   */\r\n  set(property, setter) {\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: setter };\r\n    }\r\n\r\n    const object = this.$;\r\n\r\n    iterate(isObject(object) && new Super(property).$, (setter, property) => {\r\n      Object.defineProperty(object, property, { set: setter });\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#some\r\n   * @public\r\n   * @param {IterationCallback} [callback = Boolean] - Called on each iteration.\r\n   * If returns truthy iteration stops and if falsey it continues.\r\n   * @returns {Boolean} If all the callback calls returned truthy value.\r\n   * @description Returns true if some of the callback calls returned truthy value. Otherwise false.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).some((value) => value > 4); // false\r\n   * new Super({}).some(() => true);                             // false\r\n   */\r\n  some(callback = Boolean) {\r\n    validate([callback], ['function'], 'Super#some');\r\n\r\n    return iterate(this.$, (value, key, object) => {\r\n      if (callback(value, key, object)) {\r\n        return true;\r\n      }\r\n    }) || false;\r\n  }\r\n\r\n  /**\r\n   * @method Super#strictEquals\r\n   * @public\r\n   * @param {*} [object] - Object to compare.\r\n   * @returns {Boolean} If the objects are equal or not.\r\n   * @description Returns true if objects are equal using '===' operator and false if not.\r\n   * NaNs are considered to be strict equal.\r\n   *\r\n   * @example\r\n   * new Super(3).strictEquals('3');   // false\r\n   * new Super(NaN).strictEquals(NaN); // true\r\n   */\r\n  strictEquals(object) {\r\n    const o = this.$;\r\n\r\n    object = new Super(object).$;\r\n\r\n    return o === object || (isNaN(o) && isNaN(object));\r\n  }\r\n\r\n  /**\r\n   * @method Super#sum\r\n   * @public\r\n   * @param {IterationCallback} [callback = null] - Called on each iteration.\r\n   * @returns {Number} Sum.\r\n   * @description Type of {@link Super#reduce}.\r\n   * If the callback is present it's used for summing. If not the value is used.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).sum();                         // 6\r\n   * new Super({ a: 1, b: 2, c: 3 }).sum((value) => value * value); // 14\r\n   */\r\n  sum(callback = null) {\r\n    validate([callback], ['function||!'], 'Super#sum');\r\n\r\n    return this.reduce((sum, value, key, object) => (\r\n      sum + Number(callback ? callback(value, key, object) : value)\r\n    ), 0);\r\n  }\r\n\r\n  toJSON() {\r\n    return this.$;\r\n  }\r\n\r\n  /**\r\n   * @member Super#toStringTag\r\n   * @type {String}\r\n   * @public\r\n   * @readonly\r\n   * @description Returns toString tag of the object.\r\n   *\r\n   * @example\r\n   * new Super({}).toStringTag; // 'Object'\r\n   * new Super([]).toStringTag; // 'Array'\r\n   * new Super(1).toStringTag;  // 'Number'\r\n   */\r\n  get toStringTag() {\r\n    return toStringTag(this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Super#type\r\n   * @type {String}\r\n   * @public\r\n   * @readonly\r\n   * @description Synonym for\r\n   * [\"typeof\" operator]{@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof}..\r\n   *\r\n   * @example\r\n   * new Super({}).type;   // 'object'\r\n   * new Super(1).type;    // 'number'\r\n   * new Super('1').type;  // 'string'\r\n   * new Super(true).type; // 'boolean'\r\n   */\r\n  get type() {\r\n    return typeof this.$;\r\n  }\r\n\r\n  /**\r\n   * @method Super#value\r\n   * @public\r\n   * @param {String|Object.<String, *>} property - Either a string of a property or a values object.\r\n   * @param {Object.<String, *>} [value] - If a property parameter is a string this has to be a value to be set.\r\n   * @returns {DWrap} Returns this.\r\n   * @description Method for defining non-enumerable, non-writable, non-configurable values.\r\n   * Synonym for object.define(property, { value: value }).\r\n   *\r\n   * @example\r\n   * new Super({}).value('a', 1).$; // { a: 1 }\r\n   * new Super({}).value({\r\n   *   a: 1\r\n   * }).$;                          // { a: 1 }\r\n   */\r\n  value(property, value) {\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: value };\r\n    }\r\n\r\n    const object = this.$;\r\n\r\n    iterate(isObject(object) && new Super(property).$, (value, property) => {\r\n      Object.defineProperty(object, property, { value });\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Super#values\r\n   * @public\r\n   * @returns {DWrap} A wrap of the values array.\r\n   * @description Returns D-Wrap of the values array.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).values().$; // [1, 2, 3]\r\n   * new Super(null).values().$;                 // []\r\n   */\r\n  values() {\r\n    const array = [];\r\n\r\n    iterate(this.$, (value) => {\r\n      array.push(value);\r\n    });\r\n\r\n    return D(array);\r\n  }\r\n\r\n  /**\r\n   * @method Super#word\r\n   * @public\r\n   * @param {IterationCallback} callback - Called on each iteration.\r\n   * @returns {String} Concatenated string.\r\n   * @description Type of {@link Super#reduce}.\r\n   * If the callback is present it's used for concatenating. If not the value is used.\r\n   *\r\n   * @example\r\n   * new Super({ a: 1, b: 2, c: 3 }).word();                         // '123'\r\n   * new Super({ a: 1, b: 2, c: 3 }).word((value) => value + value); // '112233'\r\n   */\r\n  word(callback = null) {\r\n    validate([callback], ['function||!'], 'Super#word');\r\n\r\n    return this.reduce((word, value, key, object) => (\r\n      word + String(callback ? callback(value, key, object) : value)\r\n    ), '');\r\n  }\r\n}\r\n\r\ndefineProperties(Super.prototype, {\r\n  [Symbol.toStringTag]: 'Super'\r\n});\r\n\r\n/**\r\n * @function deepAssign\r\n * @private\r\n * @param {*} target - Object to assign properties to.\r\n * @param {*} object - Object to assign properties from.\r\n * @returns {void}\r\n */\r\nfunction deepAssign(target, object) {\r\n  iterate(object, (value, key) => {\r\n    if (isPrimitive(target[key]) || !{}.hasOwnProperty.call(target, key)) {\r\n      target[key] = deepClone(value);\r\n\r\n      return;\r\n    }\r\n\r\n    if (!isPrimitive(target[key])) {\r\n      deepAssign(target[key], value);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @function deepClone\r\n * @private\r\n * @param {*} object - Object to clone.\r\n * @description Does the deep cloning.\r\n */\r\nfunction deepClone(object) {\r\n  const clone = cloneSwitcher(object, [object, true]);\r\n\r\n  if (clone !== object) {\r\n    iterate(object, (value, key) => {\r\n      clone[key] = deepClone(value);\r\n    });\r\n  }\r\n\r\n  return clone;\r\n}\r\n\r\n/**\r\n * @function deepEqual\r\n * @private\r\n * @param {*} o1 - First object to compare.\r\n * @param {*} o2 - Second object to compare.\r\n * @param {Boolean} strict - If comparison should be strict or not.\r\n * @returns {Boolean} - If the object are deep equal or not.\r\n */\r\nfunction deepEqual(o1, o2, strict) {\r\n  if (o1 === o2) {\r\n    return true;\r\n  }\r\n\r\n  if (isNaN(o1) && isNaN(o2) && isPrimitive(o1) && isPrimitive(o2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isNaN(o1) || isNaN(o2)) {\r\n    return false;\r\n  }\r\n\r\n  if (isPrimitive(o1) || isPrimitive(o2)) {\r\n    return strict ? o1 === o2 : o1 == o2;\r\n  }\r\n\r\n  if (isDate(o1) && isDate(o2)) {\r\n    return o1.getTime() === o2.getTime();\r\n  }\r\n\r\n  if (isDate(o1) || isDate(o2)) {\r\n    return false;\r\n  }\r\n\r\n  if (isRegExp(o1) && isRegExp(o2)) {\r\n    return o1.source === o2.source &&\r\n      o1.toString().match(/[gimuy]*$/)[0] === o2.toString().match(/[gimuy]*$/)[0] &&\r\n      o1.lastIndex === o2.lastIndex;\r\n  }\r\n\r\n  if (isRegExp(o1) || isRegExp(o2)) {\r\n    return false;\r\n  }\r\n\r\n  if ((!isPlainObject(o1) && !isArray(o1)) || (!isPlainObject(o2) && !isArray(o2))) {\r\n    return false;\r\n  }\r\n\r\n  const p1 = Object.getPrototypeOf(o1);\r\n  const p2 = Object.getPrototypeOf(o1);\r\n\r\n  if (Object.keys(o1).length !== Object.keys(o2).length) {\r\n    return false;\r\n  }\r\n\r\n  if (p1 && p2 && (toStringTag(p1.constructor) !== toStringTag(p2.constructor))) {\r\n    return false;\r\n  }\r\n\r\n  return iterate(o1, (value, key) => {\r\n    if (!(key in o2) || !deepEqual(value, o2[key], strict)) {\r\n      return false;\r\n    }\r\n  }) !== false;\r\n}\r\n\r\n/**\r\n * @function deepEvery\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the iteration goes on and if not it stops.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {Boolean} - If all the callback calls returned truthy value.\r\n */\r\nfunction deepEvery(object, callback, n, tree) {\r\n  const end = n === 1;\r\n\r\n  return iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    if (\r\n      end || isPrimitive(value)\r\n        ? !callback(value, key, object, newTree)\r\n        : !deepEvery(value, callback, n - 1, newTree)\r\n    ) {\r\n      return false;\r\n    }\r\n  }) !== false;\r\n}\r\n\r\n/**\r\n * @function deepFilter\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the element is included in the output and if not it's excluded.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {*} Filtered object.\r\n */\r\nfunction deepFilter(object, callback, n, tree) {\r\n  const array = isArrayLike(object);\r\n  const nul = isNil(object);\r\n  const o = array ? [] : nul ? object : {};\r\n  const end = n === 1;\r\n\r\n  iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    if ((end || isPrimitive(value)) && callback(value, key, object, newTree)) {\r\n      if (array) {\r\n        o.push(value);\r\n      } else {\r\n        o[key] = value;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (!end) {\r\n      const filtered = deepFilter(value, callback, n - 1, newTree);\r\n\r\n      if (filtered) {\r\n        if (array) {\r\n          o.push(filtered);\r\n        } else {\r\n          o[key] = filtered;\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  if (array) {\r\n    return o.length ? o : undefined;\r\n  }\r\n\r\n  if (!nul) {\r\n    return Object.keys(o).length ? o : undefined;\r\n  }\r\n\r\n  return o;\r\n}\r\n\r\n/**\r\n * @function deepFind\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the iteration stops and if not it continues.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {Tree|null} - If found the whole tree is returned and if not it's null what's returned.\r\n */\r\nfunction deepFind(object, callback, n, tree) {\r\n  const end = n === 1;\r\n\r\n  return iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    if (end || isPrimitive(value)) {\r\n      if (callback(value, key, object, newTree)) {\r\n        return newTree;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const result = deepFind(value, callback, n - 1, newTree);\r\n\r\n    if (result) {\r\n      return result;\r\n    }\r\n  }) || null;\r\n}\r\n\r\n/**\r\n * @function deepForEach\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {void}\r\n */\r\nfunction deepForEach(object, callback, n, tree) {\r\n  const end = n === 1;\r\n\r\n  iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    if (end || isPrimitive(value)) {\r\n      callback(value, key, object, newTree);\r\n    } else {\r\n      deepForEach(value, callback, n - 1, newTree);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @function deepForEachEntry\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {void}\r\n */\r\nfunction deepForEachEntry(object, callback, n, tree) {\r\n  const end = n === 1;\r\n\r\n  iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    callback(value, key, object, newTree);\r\n\r\n    if (!end && !isPrimitive(value)) {\r\n      deepForEachEntry(value, callback, n - 1, newTree);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @function deepFreeze\r\n * @private\r\n * @param {*} object - Object to freeze.\r\n * @returns {void}\r\n */\r\nfunction deepFreeze(object) {\r\n  Object.freeze(object);\r\n  iterate(object, deepFreeze);\r\n}\r\n\r\n/**\r\n * @function deepMap\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * Returned value is used to create to new object.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {*} New object.\r\n */\r\nfunction deepMap(object, callback, n, tree) {\r\n  const o = isArrayLike(object) ? [] : isNil(object) ? object : {};\r\n  const end = n === 1;\r\n\r\n  iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    o[key] = end || isPrimitive(value)\r\n      ? callback(value, key, object, newTree)\r\n      : deepMap(value, callback, n - 1, newTree);\r\n  });\r\n\r\n  return o;\r\n}\r\n\r\n/**\r\n * @function deepReduce\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepReduceCallback} callback - Callback that is called on every element.\r\n * Returned value is used to create to new object.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Boolean} start - If callback was called already or not.\r\n * @param {{ IV: * }|undefined} IV - If callback was called already or not.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {{ IV: * }} Transformed IV.\r\n */\r\nfunction deepReduce(object, callback, n, start, IV, tree) {\r\n  const end = n === 1;\r\n\r\n  iterate(object, (value, key, object) => {\r\n    if (!IV && (end || isPrimitive(value)) && !start) {\r\n      IV = { IV: value };\r\n      start = true;\r\n\r\n      return;\r\n    }\r\n\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    IV = end || isPrimitive(value)\r\n      ? { IV: callback(IV.IV, value, key, object, newTree) }\r\n      : deepReduce(value, callback, n - 1, start, IV, newTree);\r\n  });\r\n\r\n  return IV;\r\n}\r\n\r\n/**\r\n * @function deepSome\r\n * @private\r\n * @param {*} object - Object to iterate over.\r\n * @param {DeepIterationCallback} callback - Callback that is called on every element.\r\n * If returns truthy the iteration stops and if not it continues.\r\n * @param {Number} n - Depth of iteration.\r\n * @param {Tree} tree - Tree of { key, value } objects of iteration.\r\n * @returns {Boolean} - If some of the callback calls returned truthy value.\r\n */\r\nfunction deepSome(object, callback, n, tree) {\r\n  const end = n === 1;\r\n\r\n  return iterate(object, (value, key, object) => {\r\n    const newTree = [{ key, value }].concat(tree);\r\n\r\n    if (\r\n      end || isPrimitive(value)\r\n        ? callback(value, key, object, newTree)\r\n        : deepSome(value, callback, n - 1, newTree)\r\n    ) {\r\n      return true;\r\n    }\r\n  }) || false;\r\n}\r\n\r\nconstructors[0].push({\r\n  check: () => true,\r\n  cls: Super\r\n});\r\n\r\nexport { Super };\r\n","/**\r\n * @module Func\r\n * @private\r\n * @mixin\r\n * @description Exports Func class.\r\n */\r\n\r\nimport { Super } from './Super';\r\nimport { Promise } from './Promise';\r\nimport { constructors } from './constants';\r\nimport { isFunction, validate, toArray, Symbol, defineProperties, iterate } from './helpers';\r\n\r\n/**\r\n * @callback BeforeMiddleware\r\n * @param {Array} args - Previous arguments.\r\n * @param {Func} func - This function.\r\n * @returns {Array} - New arguments.\r\n */\r\n\r\n/**\r\n * @callback AfterMiddleware\r\n * @param {*} returnValue - Previous return value.\r\n * @param {Func} func - This function.\r\n * @returns {*} - New return value.\r\n */\r\n\r\n/**\r\n * @class Func\r\n * @extends Super\r\n * @public\r\n * @param {Function} [func = function () {}] - Function to wrap.\r\n * @returns {Func} Instance of Func.\r\n * @description A wrap of a function.\r\n *\r\n * @example\r\n * const func = new Func(Math.max);\r\n *\r\n * func(1, 4, -2, 5); // 5\r\n */\r\nclass Func extends Super {\r\n  constructor(func = () => {}) {\r\n    super();\r\n\r\n    function proxy() {\r\n      if (++proxy.$$.called < proxy.$$.canBeCalled) {\r\n        const { before, after, sync, contextLocked } = proxy.$$;\r\n        let { context, args } = proxy.$$;\r\n        let ret;\r\n\r\n        context = contextLocked ? context : context || this;\r\n        args = args.concat(toArray(arguments));\r\n\r\n        if (sync) {\r\n          iterate(before, (middleware) => {\r\n            args = middleware.call(context, toArray(args), proxy);\r\n          });\r\n\r\n          ret = func.apply(context, toArray(args));\r\n\r\n          iterate(after, (middleware) => {\r\n            ret = middleware.call(context, ret, proxy);\r\n          });\r\n\r\n          return ret;\r\n        }\r\n\r\n        let promise = Promise.resolve(args);\r\n\r\n        iterate(before, (middleware) => {\r\n          promise = promise.then((args) => middleware.call(context, toArray(args), proxy));\r\n        });\r\n\r\n        promise = promise.then((args) => func.apply(context, toArray(args)));\r\n\r\n        iterate(after, (middleware) => {\r\n          promise = promise.then((ret) => middleware.call(context, ret, proxy));\r\n        });\r\n\r\n        return promise;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @member {Object} Func#$$\r\n     * @type {Object}\r\n     * @protected\r\n     * @property {Array} after - After middleware array.\r\n     * @property {Array} args - Locked and bound arguments.\r\n     * @property {Array} argsLocked - Locked arguments.\r\n     * @property {Array} before - Before middleware array.\r\n     * @property {Number} called - How many times the function was called.\r\n     * @property {Number} canBeCalled - How many times the function can be actually called.\r\n     * @property {*} context - Locked or bound context.\r\n     * @property {Boolean} contextLocked - Is context locked or not.\r\n     * @property {Boolean} sync - Is function synchronous or not.\r\n     * @description Config parameters.\r\n     */\r\n    Object.defineProperty(proxy, '$$', {\r\n      value: {\r\n        after: [],\r\n        args: [],\r\n        argsLocked: [],\r\n        before: [],\r\n        called: 0,\r\n        canBeCalled: Infinity,\r\n        context: null,\r\n        contextLocked: false,\r\n        sync: true\r\n      }\r\n    });\r\n\r\n    /**\r\n     * @member {Function} Func#$\r\n     * @type {Function}\r\n     * @public\r\n     * @description Original function.\r\n     */\r\n    Object.defineProperty(proxy, '$', { value: func });\r\n    Object.setPrototypeOf(proxy, Func.prototype);\r\n\r\n    return proxy;\r\n  }\r\n\r\n  /**\r\n   * @method Func#after\r\n   * @public\r\n   * @param {AfterMiddleware} middleware - After middleware.\r\n   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put middleware.\r\n   * Truthy parameter stands for \"to the end\" and falsey for \"to the beginning\".\r\n   * @returns {Func} Returns this.\r\n   * @description Adds after middleware.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1)\r\n   *   .after((result) => result * result);\r\n   *\r\n   * func(4);  // 25\r\n   * func(-4); // 9\r\n   */\r\n  after(middleware, afterAll = true) {\r\n    validate([middleware], ['function'], 'Func#after');\r\n\r\n    const { after } = this.$$;\r\n\r\n    if (afterAll) {\r\n      after.push(middleware);\r\n    } else {\r\n      after.unshift(middleware);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#apply\r\n   * @public\r\n   * @param {*} [context] - Context to call with.\r\n   * @param {(Array|Arguments)} [args] - Arguments to call with.\r\n   * @returns {*} Return of function call.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\r\n   * @description Synonym for\r\n   * [Function#apply]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/apply}.\r\n   */\r\n  apply(context, args) {\r\n    return (() => {}).apply.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * @method Func#async\r\n   * @public\r\n   * @param {Boolean|*} [condition] - If the function should be synchronous or not.\r\n   * @returns {Func} Returns this.\r\n   * @description If the function should be synchronous or not.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1).async();\r\n   *\r\n   * func(4).then((result) => {\r\n   *   console.log(result); // 5\r\n   * });\r\n   */\r\n  async(condition = true) {\r\n    this.$$.sync = !condition;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#before\r\n   * @public\r\n   * @param {BeforeMiddleware} middleware - Before middleware.\r\n   * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put middleware.\r\n   * Truthy parameter stands for \"to the beginning\" and falsey for \"to the end\".\r\n   * @returns {Func} Returns this.\r\n   * @description Adds before middleware.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1)\r\n   *   .before(([arg]) => [arg * arg]);\r\n   *\r\n   * func(4); // 17\r\n   * func(3); // 10\r\n   */\r\n  before(middleware, beforeAll = true) {\r\n    validate([middleware], ['function'], 'Func#before');\r\n\r\n    const { before } = this.$$;\r\n\r\n    if (beforeAll) {\r\n      before.unshift(middleware);\r\n    } else {\r\n      before.push(middleware);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#bind\r\n   * @public\r\n   * @param {*} context - Context to bind.\r\n   * @param {...(Array|Arguments|*)} args - Arguments to bind.\r\n   * @returns {Func} Returns this.\r\n   * @description Composition of {@link Func#bindContext} and {@link Func#bindArgs}.\r\n   *\r\n   * @example\r\n   * const func = new Func(function (a, b) {\r\n   *   return this.a + a + b;\r\n   * }).bind({ a: 2 }, 1);\r\n   *\r\n   * func(1); // 4\r\n   * func(3); // 6\r\n   */\r\n  bind(context, ...args) {\r\n    return this\r\n      .bindContext(context)\r\n      .bindArgs(args);\r\n  }\r\n\r\n  /**\r\n   * @method Func#bindArgs\r\n   * @public\r\n   * @param {(Array|Arguments)} args - Arguments to bind.\r\n   * @returns {Func} Returns this.\r\n   * @description Binds arguments in addition to already locked and bound ones.\r\n   *\r\n   * @example\r\n   * const func = new Func((...args) => {\r\n   *   let sum = 0;\r\n   *\r\n   *   for (let i = 0; i < args.length; i++) {\r\n   *     sum += args[i];\r\n   *   }\r\n   *\r\n   *   return sum;\r\n   * });\r\n   *\r\n   * func(1, 2, 3); // 6\r\n   *\r\n   * func.bindArgs([4]);\r\n   *\r\n   * func(1, 2, 3); // 10\r\n   *\r\n   * func.bindArgs([5]);\r\n   *\r\n   * func(1, 2, 3); // 15\r\n   */\r\n  bindArgs(args) {\r\n    const func = this.$$;\r\n\r\n    func.args = func.args.concat(toArray(args));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#bindContext\r\n   * @public\r\n   * @param {*} context - Context to bind.\r\n   * @returns {Func} Returns this.\r\n   * @description Bind new context if it's not already locked.\r\n   *\r\n   * @example\r\n   * const func = new Func(function () {\r\n   *   return this.a;\r\n   * }).bindContext({ a: 1 });\r\n   *\r\n   * func(); // 1\r\n   *\r\n   * func.bindContext({ a: 2 });\r\n   *\r\n   * func(); // 2\r\n   */\r\n  bindContext(context) {\r\n    const func = this.$$;\r\n\r\n    if (!func.contextLocked) {\r\n      func.context = context;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#call\r\n   * @public\r\n   * @param {*} [context] - Context to call with.\r\n   * @param {...*} [args] - Arguments to call with.\r\n   * @returns {*} Return of function call.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call\r\n   * @description Synonym for\r\n   * [Function#call]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Function/call}.\r\n   */\r\n  call(context, ...args) {\r\n    return (() => {}).call.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * @member {Number} Func#called\r\n   * @public\r\n   * @readonly\r\n   * @description Returns how many times the function was called.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1);\r\n   *\r\n   * func();\r\n   * func();\r\n   *\r\n   * func.called // 2\r\n   */\r\n  get called() {\r\n    return this.$$.called;\r\n  }\r\n\r\n  /**\r\n   * @method Func#canBeCalled\r\n   * @public\r\n   * @param {Number} times - Number of maximum times the function is called (middlewares are also taken for a count).\r\n   * @returns {Func} Returns this.\r\n   * @description Method for limiting call times of function.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1)\r\n   *   .canBeCalled(1);\r\n   *\r\n   * func(1); // 2\r\n   * func(1); // undefined\r\n   */\r\n  canBeCalled(times) {\r\n    this.$$.canBeCalled = times;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#limitArgsTo\r\n   * @public\r\n   * @param {Number} number - Number of arguments to limit to.\r\n   * @returns {Func} Returns this.\r\n   * @description Built-in before middleware for limiting number of arguments\r\n   * that is put to the end of before middlewares.\r\n   *\r\n   * @example\r\n   * const func = new Func((a, b) => [a, b]);\r\n   *\r\n   * func(1, 2); // [1, 2]\r\n   *\r\n   * func.limitArgsTo(1);\r\n   *\r\n   * func(1, 2); // [1, undefined]\r\n   */\r\n  limitArgsTo(number) {\r\n    return this.before((args) => args.slice(0, number), false);\r\n  }\r\n\r\n  /**\r\n   * @method Func#lock\r\n   * @public\r\n   * @param {*} context - Context to lock.\r\n   * @param {(Array|Arguments|*)} args - Arguments to lock.\r\n   * @returns {Func} Returns this.\r\n   * @description Composition of {@link Func#lockContext} and {@link Func#lockArgs}.\r\n   *\r\n   * @example\r\n   * const func = new Func(function (a, b) {\r\n   *   return this.a + a + b;\r\n   * }).lock({ a: 2 }, [1]);\r\n   *\r\n   * func(1); // 4\r\n   * func(3); // 6\r\n   */\r\n  lock(context, args) {\r\n    return this\r\n      .lockContext(context)\r\n      .lockArgs(args);\r\n  }\r\n\r\n  /**\r\n   * @method Func#lockArgs\r\n   * @public\r\n   * @param {(Array|Arguments|*)} args - Arguments to lock.\r\n   * @returns {Func} Returns this.\r\n   * @description Erases bound arguments and adds new arguments to already locked ones.\r\n   *\r\n   * @example\r\n   * const func = new Func((...args) => {\r\n   *   let sum = 0;\r\n   *\r\n   *   for (let i = 0; i < args.length; i++) {\r\n   *     sum += args[i];\r\n   *   }\r\n   *\r\n   *   return sum;\r\n   * });\r\n   *\r\n   * func(1, 2, 3); // 6\r\n   *\r\n   * func.lockArgs([4]);\r\n   *\r\n   * func(1, 2, 3); // 10\r\n   *\r\n   * func.bindArgs([6, 7]);\r\n   * func.lockArgs([5]);\r\n   *\r\n   * func(1, 2, 3); // 15\r\n   */\r\n  lockArgs(args) {\r\n    const func = this.$$;\r\n\r\n    func.args = func.argsLocked = func.argsLocked.concat(toArray(args));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#lockContext\r\n   * @public\r\n   * @param {*} context - Context to lock.\r\n   * @returns {Func} Returns this.\r\n   * @description Locks context if it's not already locked.\r\n   *\r\n   * @example\r\n   * const func = new Func(function () {\r\n   *   return this.a;\r\n   * }).lockContext({ a: 1 });\r\n   *\r\n   * func(); // 1\r\n   *\r\n   * func.lockContext({ a: 2 });\r\n   *\r\n   * func(); // 1\r\n   */\r\n  lockContext(context) {\r\n    const func = this.$$;\r\n\r\n    if (!func.contextLocked) {\r\n      func.context = context;\r\n      func.contextLocked = true;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#timing\r\n   * @public\r\n   * @param {String} mark - Argument that is passed to console.time() and console.timeEnd().\r\n   * By default name of the original function, or if it's not present, 'anonymous' is used.\r\n   * @returns {Func} Returns this.\r\n   * @description Built-in before and after middlewares for noting calling time.\r\n   * In case of asynchronous functions it notes time between calling function and resolving or rejecting the result.\r\n   *\r\n   * @example\r\n   * const func = new Func((a) => a + 1)\r\n   *   .timing('plus 1');\r\n   *\r\n   * func(2); // plus 1: 0.010ms\r\n   *\r\n   * const async = new Func(() => new Promise(() => {\r\n   *     setTimeout(resolve, 1000);\r\n   *   }))\r\n   *   .async()\r\n   *   .timing();\r\n   *\r\n   * async();\r\n   * // After 1 second...\r\n   * // anonymous: 1000.010ms\r\n   */\r\n  timing(mark) {\r\n    mark = arguments.length ? String(mark) : this.$.name || 'anonymous';\r\n\r\n    this.before((args) => {\r\n      console.time(mark);\r\n\r\n      return args;\r\n    }, false);\r\n\r\n    this.after((ret) => {\r\n      console.timeEnd(mark);\r\n\r\n      return ret;\r\n    }, false);\r\n\r\n    return this;\r\n  }\r\n\r\n  toString() {\r\n    return (() => {}).toString.call(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Func#unbind\r\n   * @public\r\n   * @returns {Func} Returns this.\r\n   * @description Composition of {@link Func#unbindContext} and {@link Func#unbindArgs}.\r\n   *\r\n   * @example\r\n   * const func = new Func(function (a) {\r\n   *   return this.foo + ' & ' +  a;\r\n   * }).bind({ foo: 2 }, 1);\r\n   *\r\n   * func(); // '2 & 1'\r\n   *\r\n   * func.unbind();\r\n   *\r\n   * func(); // 'undefined & undefined'\r\n   */\r\n  unbind() {\r\n    return this\r\n      .unbindContext()\r\n      .unbindArgs();\r\n  }\r\n\r\n  /**\r\n   * @method Func#unbindArgs\r\n   * @public\r\n   * @returns {Func} Returns this.\r\n   * @description Erases all bound arguments.\r\n   *\r\n   * @example\r\n   * const func = new Func((...args) => {\r\n   *   let sum = 0;\r\n   *\r\n   *   for (let i = 0; i < args.length; i++) {\r\n   *     sum += args[i];\r\n   *   }\r\n   *\r\n   *   return sum;\r\n   * }).bindArgs([4, 5]);\r\n   *\r\n   * func(1, 2, 3); // 15\r\n   *\r\n   * func.unbindArgs();\r\n   *\r\n   * func(1, 2, 3); // 6\r\n   */\r\n  unbindArgs() {\r\n    const func = this.$$;\r\n\r\n    func.args = func.argsLocked;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Func#unbindContext\r\n   * @public\r\n   * @returns {Func} Returns this.\r\n   * @description Erases context if it's not locked.\r\n   *\r\n   * @example\r\n   * const func = new Func(function () {\r\n   *   return this.foo;\r\n   * }).bindContext({ foo: 1 });\r\n   *\r\n   * func(); // 1\r\n   *\r\n   * func.unbindArgs();\r\n   *\r\n   * func(); // undefined\r\n   */\r\n  unbindContext() {\r\n    const func = this.$$;\r\n\r\n    if (!func.contextLocked) {\r\n      func.context = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\ndefineProperties(Func.prototype, {\r\n  [Symbol.toStringTag]: 'Func'\r\n});\r\n\r\nconstructors[1].push({\r\n  check: isFunction,\r\n  cls: Func\r\n});\r\n\r\n/**\r\n * @function method\r\n * @public\r\n * @param {String} method - Method to call.\r\n * @param {(Array|Arguments|*)} args - Arguments to call the method with.\r\n * @returns {Function} Function that calls stated method with given arguments.\r\n * @description Function that returns the function\r\n * that calls stated method of its first argument with given arguments.\r\n *\r\n * @example\r\n * [1.2345, 2.789, 3.14].map(method('toFixed', [2])); // ['1.23', '2.79', '3.14']\r\n */\r\nfunction method(method, args = []) {\r\n  return (x) => x[method].apply(x, toArray(args));\r\n}\r\n\r\n/**\r\n * @function noop\r\n * @public\r\n * @returns {void}\r\n * @description Empty function.\r\n */\r\nfunction noop() {}\r\n\r\n/**\r\n * @function prop\r\n * @public\r\n * @param {String} prop - Property to return.\r\n * @returns {Function} Function that returns given property of its first argument.\r\n * @description Function that return the function that returns given property of its first argument.\r\n *\r\n * @example\r\n * ['foo', '12', '7890'].map(prop('length')); // [3, 2, 4]\r\n */\r\nfunction prop(prop) {\r\n  return ({ [prop]: value }) => value;\r\n}\r\n\r\n/**\r\n * @function self\r\n * @public\r\n * @returns {*} First argument itself.\r\n * @description Function that returns the first argument.\r\n *\r\n * @example\r\n * [1, 2].map(self);                     // [1, 2]\r\n * [1, 3, NaN, 0, 7, null].filter(self); // [1, 3, 7]\r\n */\r\nfunction self() {\r\n  return arguments[0];\r\n}\r\n\r\nexport { Func, method, noop, prop, self };\r\n","/**\r\n * @module Num\r\n * @private\r\n * @mixin\r\n * @description Exports Num class.\r\n */\r\n\r\nimport { Super } from './Super';\r\nimport { Func } from './Func';\r\nimport { Promise } from './Promise';\r\nimport { constructors } from './constants';\r\nimport {\r\n  isNumber, isFinite, toArray,\r\n  defineProperties, validate, Symbol\r\n} from './helpers';\r\n\r\nconst toRadian = Math.PI / 180;\r\nconst toDegree = 180 / Math.PI;\r\nconst ln2 = Math.LN2;\r\nconst ln10 = Math.LN10;\r\n\r\n/**\r\n * @class Num\r\n * @extends Super\r\n * @public\r\n * @param {Number} [number = 0] - A number to wrap.\r\n * @returns {Num} Instance of Num.\r\n * @description Wrap of a number.\r\n *\r\n * @example\r\n * const num = new Num(1);\r\n */\r\nclass Num extends Super {\r\n  constructor(number = 0) {\r\n    super(+number);\r\n\r\n    /**\r\n     * @member Num#$\r\n     * @type {Number}\r\n     * @public\r\n     * @description Original number.\r\n     */\r\n  }\r\n\r\n  /**\r\n   * @member Num#abs\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs\r\n   * @description Synonym for\r\n   * [Math.abs]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/abs}.\r\n   *\r\n   * @example\r\n   * new Num(1).abs;  // 1\r\n   * new Num(-1).abs; // 1\r\n   */\r\n  get abs() {\r\n    return Math.abs(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Num#acos\r\n   * @public\r\n   * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\r\n   * @returns {Number} Arccosine of the number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos\r\n   * @description Synonym for\r\n   * [Math.acos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acos}.\r\n   */\r\n  acos(toDegrees) {\r\n    return (toDegrees ? toDegree : 1) * Math.acos(this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#acosh\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\r\n   * @description Synonym for\r\n   * [Math.acosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh}.\r\n   */\r\n  get acosh() {\r\n    const number = this.$;\r\n\r\n    return Math.log(number + Math.sqrt(number * number - 1));\r\n  }\r\n\r\n  /**\r\n   * @member Num#asinh\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\r\n   * @description Synonym for\r\n   * [Math.asinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh}.\r\n   */\r\n  get asinh() {\r\n    const number = this.$;\r\n\r\n    return Math.log(number + Math.sqrt(number * number + 1));\r\n  }\r\n\r\n  /**\r\n   * @method Num#asin\r\n   * @public\r\n   * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\r\n   * @returns {Number} Arcsine of the number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin\r\n   * @description Synonym for\r\n   * [Math.asin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/asin}.\r\n   */\r\n  asin(toDegrees) {\r\n    return (toDegrees ? toDegree : 1) * Math.asin(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Num#atan\r\n   * @public\r\n   * @param {Boolean|*} [toDegrees = false] If it is truthy the return value is transformed into degrees.\r\n   * @returns {Number} Arcsine of the number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan\r\n   * @description Synonym for\r\n   * [Math.atan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atan}.\r\n   */\r\n  atan(toDegrees) {\r\n    return (toDegrees ? toDegree : 1) * Math.atan(this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#atanh\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\r\n   * @description Synonym for\r\n   * [Math.atanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh}.\r\n   */\r\n  get atanh() {\r\n    const number = this.$;\r\n\r\n    return Math.log((1 + number) / (1 - number)) / 2;\r\n  }\r\n\r\n  /**\r\n   * @member Num#cbrt\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt\r\n   * @description Synonym for\r\n   * [Math.cbrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt}.\r\n   */\r\n  get cbrt() {\r\n    const cbrt = Math.pow(Math.abs(this.$), 1 / 3);\r\n\r\n    return this.$ > 0 ? cbrt : -cbrt;\r\n  }\r\n\r\n  /**\r\n   * @member Num#ceil\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil\r\n   * @description Synonym for\r\n   * [Math.ceil]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil}.\r\n   *\r\n   * @example\r\n   * new Num(1.1).ceil;  // 2\r\n   * new Num(-1.1).ceil; // -1\r\n   */\r\n  get ceil() {\r\n    return Math.ceil(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Num#cos\r\n   * @public\r\n   * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\r\n   * @returns {Number} Cosine of the number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos\r\n   * @description Synonym for\r\n   * [Math.cos]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cos}.\r\n   */\r\n  cos(asDegrees) {\r\n    return Math.cos((asDegrees ? toRadian : 1) * this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#cosh\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\r\n   * @description Synonym for\r\n   * [Math.cosh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh}.\r\n   */\r\n  get cosh() {\r\n    const exp = this.exp;\r\n\r\n    return (exp + 1 / exp) / 2;\r\n  }\r\n\r\n  /**\r\n   * @member Num#cube\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description Cube of the number.\r\n   *\r\n   * @example\r\n   * new Num(2).cube;  // 8\r\n   * new Num(-3).ceil; // -27\r\n   */\r\n  get cube() {\r\n    return this.$ * this.$ * this.$;\r\n  }\r\n\r\n  /**\r\n   * @member Num#exp\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp\r\n   * @description Synonym for\r\n   * [Math.exp]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/exp}.\r\n   */\r\n  get exp() {\r\n    return Math.exp(this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#floor\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor\r\n   * @description Synonym for\r\n   * [Math.floor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/floor}.\r\n   *\r\n   * @example\r\n   * new Num(1.1).floor;  // 1\r\n   * new Num(-1.1).floor; // -2\r\n   */\r\n  get floor() {\r\n    return Math.floor(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Num#interval\r\n   * @public\r\n   * @param {Function} func - Function that is called every <number> milliseconds.\r\n   * @param {Array} [args] - Arguments passed to the function.\r\n   * @returns {Function} Function that aborts the interval. The context of the function (if it's not already bound)\r\n   * is the object with the abort method.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/setInterval\r\n   * @description Analogue of the\r\n   * [setInterval]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setInterval}.\r\n   *\r\n   * @example\r\n   * const times = 0;\r\n   * new Num(50).interval(function () {\r\n   *   if (++times === 10) {\r\n   *     this.abort();\r\n   *   }\r\n   * });\r\n   */\r\n  interval(func, args = []) {\r\n    validate([func], ['function'], 'Num#interval');\r\n\r\n    func = new Func(func).bindContext({ abort });\r\n    args = toArray(args);\r\n\r\n    const number = this.$;\r\n\r\n    let aborted;\r\n    let timeout = setTimeout(function interval() {\r\n      if (!aborted) {\r\n        func.apply(null, args);\r\n\r\n        if (!aborted) {\r\n          timeout = setTimeout(interval, number);\r\n        }\r\n      }\r\n    }, 0);\r\n\r\n    return abort;\r\n\r\n    function abort() {\r\n      aborted = true;\r\n\r\n      return clearTimeout(timeout);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @member Num#ln\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log\r\n   * @description Synonym for\r\n   * [Math.log]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log}.\r\n   */\r\n  get ln() {\r\n    return Math.log(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Num#log\r\n   * @public\r\n   * @param {Number} number - Number to get logarithm of.\r\n   * @returns {Number} Logarithm of the argument number to the number base.\r\n   * @description Returns the logarithm of the argument number to the number base.\r\n   *\r\n   * @example\r\n   * new Num(2).log(16);  // 4\r\n   * new Num(3).log(243); // 5\r\n   */\r\n  log(number) {\r\n    return Math.log(number) / Math.log(this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#log2\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2\r\n   * @description Synonym for\r\n   * [Math.log2]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log2}.\r\n   */\r\n  get log2() {\r\n    return this.ln / ln2;\r\n  }\r\n\r\n  /**\r\n   * @member Num#log10\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\r\n   * @description Synonym for\r\n   * [Math.log10]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/log10}.\r\n   */\r\n  get log10() {\r\n    return this.ln / ln10;\r\n  }\r\n\r\n  /**\r\n   * @method Num#pow\r\n   * @public\r\n   * @param {Number} power - Power the number should be raised to.\r\n   * @returns {Number} The number to the <power> power.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow\r\n   * @description Synonym for\r\n   * [Math.pow]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/pow}.\r\n   *\r\n   * @example\r\n   * new Num(4).pow(.5); // 2\r\n   * new Num(3).pow(2);  // 9\r\n   */\r\n  pow(power) {\r\n    return Math.pow(this.$, power);\r\n  }\r\n\r\n  /**\r\n   * @method Num#root\r\n   * @public\r\n   * @param {Number} power - Power the number should be raised to.\r\n   * @returns {Number} The <power> root of the number.\r\n   * @description Synonym for number.pow(1 / power);\r\n   *\r\n   * @example\r\n   * new Num(4).root(2);   // 0.5\r\n   * new Num(243).root(5); // 3\r\n   */\r\n  root(power) {\r\n    return Math.pow(this.$, 1 / power);\r\n  }\r\n\r\n  /**\r\n   * @member Num#round\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round\r\n   * @description Synonym for\r\n   * [Math.round]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/round}.\r\n   *\r\n   * @example\r\n   * new Num(1.1).floor;  // 1\r\n   * new Num(-1.1).floor; // -1\r\n   * new Num(1.5).floor;  // 2\r\n   */\r\n  get round() {\r\n    return Math.round(this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#sign\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n   * @description Synonym for\r\n   * [Math.sign]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sign}.\r\n   */\r\n  get sign() {\r\n    const number = this.$;\r\n\r\n    if (!number) {\r\n      return number;\r\n    }\r\n\r\n    return number > 0 ? 1 : -1;\r\n  }\r\n\r\n  /**\r\n   * @method Num#sin\r\n   * @public\r\n   * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\r\n   * @returns {Number} Sine of the number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin\r\n   * @description Synonym for\r\n   * [Math.sin]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sin}.\r\n   */\r\n  sin(asDegrees) {\r\n    return Math.sin((asDegrees ? toRadian : 1) * this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#sinh\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\r\n   * @description Synonym for\r\n   * [Math.sinh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh}.\r\n   */\r\n  get sinh() {\r\n    const exp = this.exp;\r\n\r\n    return (exp - 1 / exp) / 2;\r\n  }\r\n\r\n  /**\r\n   * @member Num#sq\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description The square of the number.\r\n   *\r\n   * @example\r\n   * new Num(2).sq;  // 4\r\n   * new Num(-3).sq; // 9\r\n   */\r\n  get sq() {\r\n    return this.$ * this.$;\r\n  }\r\n\r\n  /**\r\n   * @member Num#sqrt\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt\r\n   * @description Synonym for\r\n   * [Math.sqrt]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt}.\r\n   */\r\n  get sqrt() {\r\n    return Math.sqrt(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method Num#tan\r\n   * @public\r\n   * @param {Boolean|*} [asDegrees = false] If it is truthy the number is treated as a degree value.\r\n   * @returns {Number} Tangent of the number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan\r\n   * @description Synonym for\r\n   * [Math.tan]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tan}.\r\n   */\r\n  tan(asDegrees) {\r\n    return Math.tan((asDegrees ? toRadian : 1) * this.$);\r\n  }\r\n\r\n  /**\r\n   * @member Num#tanh\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\r\n   * @description Synonym for\r\n   * [Math.tanh]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh}.\r\n   */\r\n  get tanh() {\r\n    const number = this.$;\r\n\r\n    if (!isFinite(number)) {\r\n      return this.sign;\r\n    }\r\n\r\n    const exp = Math.exp(2 * number);\r\n\r\n    return (exp - 1) / (exp + 1);\r\n  }\r\n\r\n  /**\r\n   * @method Num#timeout\r\n   * @public\r\n   * @param {*} [value] - Value to be resolved by the promise.\r\n   * @returns {Promise} Promise that could be aborted.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout\r\n   * @description Promise-based analogue of\r\n   * [setTimeout]{@link https://developer.mozilla.org/en/docs/Web/API/WindowTimers/setTimeout}.\r\n   *\r\n   * @example\r\n   * new Num(50).timeout('resolved').then((value) => {\r\n   *   console.log(value); // 'resolved'\r\n   * });\r\n   *\r\n   * const promise = new Num(50).timeout();\r\n   * promise.abort();\r\n   */\r\n  timeout(value) {\r\n    let timeout;\r\n    let reject;\r\n\r\n    const promise = new Promise((resolve, rej) => {\r\n      reject = rej;\r\n      timeout = setTimeout(resolve, this.$, value);\r\n    });\r\n\r\n    promise.abort = function abort() {\r\n      clearTimeout(timeout);\r\n\r\n      reject(new Error('Timeout was aborted'));\r\n\r\n      return this;\r\n    };\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * @method Num#toBase\r\n   * @public\r\n   * @param {Number} [base = 10] - Base that the number should inverted to.\r\n   * @returns {String} A string representation of the number in <base> base.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\r\n   * @description Synonym for\r\n   * [Number#toString]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toString}.\r\n   *\r\n   * @example\r\n   * new Num(4).toBase(2); // 100\r\n   * new Num(3).toBase();  // 3\r\n   */\r\n  toBase(base = 10) {\r\n    return this.$.toString(base);\r\n  }\r\n\r\n  /**\r\n   * @method Num#toExponential\r\n   * @public\r\n   * @param {Number} [fractionDigits] - See the link.\r\n   * @returns {String} A string representation of the number in the exponential format.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential\r\n   * @description Synonym for\r\n   * [Number#toExponential]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential}.\r\n   */\r\n  toExponential(fractionDigits) {\r\n    return this.$.toExponential(fractionDigits);\r\n  }\r\n\r\n  /**\r\n   * @method Num#toFixed\r\n   * @public\r\n   * @param {Number} [digits = 0] - See the link.\r\n   * @returns {String} Fixed-point formatted number.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\r\n   * @description Synonym for\r\n   * [Number#toFixed]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed}.\r\n   */\r\n  toFixed(digits) {\r\n    return this.$.toFixed(digits);\r\n  }\r\n\r\n  /**\r\n   * @method Num#toPrecision\r\n   * @public\r\n   * @param {Number} [precision] - See the link.\r\n   * @returns {String} A string representation of the number to the specified precision.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision\r\n   * @description Synonym for\r\n   * [Number#toPrecision]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision}.\r\n   */\r\n  toPrecision(precision) {\r\n    return this.$.toPrecision(precision);\r\n  }\r\n\r\n  valueOf() {\r\n    return Number(this.$);\r\n  }\r\n}\r\n\r\ndefineProperties(Num.prototype, {\r\n  [Symbol.toStringTag]: 'Num'\r\n});\r\n\r\nconstructors[1].push({\r\n  check: isNumber,\r\n  cls: Num\r\n});\r\n\r\n/**\r\n * @function rand\r\n * @public\r\n * @param {Number} [start = 0] - Start of the range.\r\n * @param {Number} [end = 1] - End of the range.\r\n * @returns {Number} Random number.\r\n * @description Returns a random number in the range specified by the arguments.\r\n *\r\n * @example\r\n * rand(1, 5); // 2.315\r\n * rand(1, 5); // 4.356763\r\n */\r\nfunction rand(start = 0, end = 1) {\r\n  return start + (end - start) * Math.random();\r\n}\r\n\r\n/**\r\n * @function random\r\n * @public\r\n * @param {Integer} start - Start of the range.\r\n * @param {Integer} end - End of the range.\r\n * @returns {Number} Random integer.\r\n * @description Returns a random integer number in the range specified by the arguments.\r\n *\r\n * @example\r\n * random(1, 5); // 3\r\n * random(1, 5); // 1\r\n */\r\nfunction random(start, end) {\r\n  validate([start, end], ['intLike', 'intLike'], 'random');\r\n\r\n  if (end <= start) {\r\n    throw new Error('The second argument must be greater than the first!', 'random');\r\n  }\r\n\r\n  return Math.floor(rand(start, end + 1));\r\n}\r\n\r\nexport { Num, rand, random };\r\n","/**\r\n * @module Arr\r\n * @private\r\n * @mixin\r\n * @description Exports Arr class.\r\n */\r\n\r\nimport { random } from './Num';\r\nimport { Super } from './Super';\r\nimport { constructors } from './constants';\r\nimport {\r\n  isArrayLike, isNaN, isNumber, isString,\r\n  toArray, validate, iterate as iterator, Symbol, defineProperties\r\n} from './helpers';\r\n\r\n/**\r\n * @typedef {Array|*} ArrayLike\r\n * @public\r\n * @description Array-like type.\r\n */\r\n\r\n/**\r\n * @callback ArrayCallback\r\n * @public\r\n * @param {Number} i - Iteration index.\r\n */\r\n\r\n/**\r\n * @callback IterateCallback\r\n * @public\r\n * @param {Number} i - Iteration index.\r\n */\r\n\r\n/**\r\n * @callback CompareFunction\r\n * @public\r\n * @param {*} x - First value to be compared.\r\n * @param {*} y - Second value to be compared.\r\n */\r\n\r\n/**\r\n * @class Arr\r\n * @extends Super\r\n * @public\r\n * @param {Array} [array = []] - An array to wrap.\r\n * @returns {Arr} Instance of Arr.\r\n * @description Wrap of an array.\r\n *\r\n * @example\r\n * new Arr([1, 2]);\r\n */\r\nclass Arr extends Super {\r\n  constructor(array = []) {\r\n    super(toArray(array instanceof Arr ? array.$ : array));\r\n\r\n    /**\r\n     * @member Arr#$\r\n     * @type {Array}\r\n     * @public\r\n     * @description Made array.\r\n     */\r\n  }\r\n\r\n  /**\r\n   * @method Arr#concat\r\n   * @public\r\n   * @param {...(Array|Arr|*)} values - Arrays or any other values to concat the array with.\r\n   * @returns {Arr} New instance of Arr.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\r\n   * @description Synonym for\r\n   * [Array#concat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat}.\r\n   */\r\n  concat(...values) {\r\n    const array = toArray(this.$, true);\r\n\r\n    iterator(arguments, (value) => {\r\n      value = new Super(value).$;\r\n\r\n      if (isArrayLike(value) && !isString(value)) {\r\n        iterator(value, (value) => {\r\n          array.push(value);\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      array.push(value);\r\n    });\r\n\r\n    return new this.constructor(array);\r\n  }\r\n\r\n  /**\r\n   * @member Arr#first\r\n   * @type {*}\r\n   * @public\r\n   * @readonly\r\n   * @description Returns the first element of the array.\r\n   *\r\n   * @example\r\n   * new Arr([1, 2, 3]).first; // 1\r\n   * new Arr([]).first;        // undefined\r\n   */\r\n  get first() {\r\n    return this.$[0];\r\n  }\r\n\r\n  /**\r\n   * @method Arr#indexOf\r\n   * @public\r\n   * @param {*} value - Value to search.\r\n   * @returns {Number} Index of the argument.\r\n   * @description Almost the same as {@link Super#keyOf}. The difference is that if the value is not found\r\n   * -1 returned instead of null and if found Number(key) returned.\r\n   *\r\n   * @example\r\n   * new Arr([1, 2, 3]).indexOf(1);       // 0\r\n   * new Arr([1, 2, 3]).indexOf('1');     // 0\r\n   * new Arr([1, 2, 3]).indexOf(3);       // -1\r\n   * new Arr([1, 2, NaN]).indexOf(NaN);   // 2\r\n   */\r\n  indexOf(value) {\r\n    const key = this.keyOf(value);\r\n\r\n    return key === null ? -1 : Number(key);\r\n  }\r\n\r\n  /**\r\n   * @method Arr#indexOfStrict\r\n   * @public\r\n   * @param {*} value - Value to search.\r\n   * @returns {Number} Index of the argument.\r\n   * @description Almost the same as {@link Super#keyOfStrict}. The difference is that if the value is not found\r\n   * -1 returned instead of null and if found Number(key) returned.\r\n   *\r\n   * @example\r\n   * new Arr([1, 2, 3]).indexOfStrict(1);       // 0\r\n   * new Arr([1, 2, 3]).indexOfStrict('1');     // -1\r\n   * new Arr([1, 2, 3]).indexOfStrict(3);       // -1\r\n   * new Arr([1, 2, NaN]).indexOfStrict(NaN);   // 2\r\n   */\r\n  indexOfStrict(value) {\r\n    const key = this.keyOfStrict(value);\r\n\r\n    return key === null ? -1 : Number(key);\r\n  }\r\n\r\n  /**\r\n   * @method Arr#join\r\n   * @public\r\n   * @param {String} [separator = ','] - See the link.\r\n   * @returns {String} - String of joined array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join\r\n   * @description Synonym for\r\n   * [Array#join]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/join}.\r\n   */\r\n  join(separator) {\r\n    return this.$.join.apply(this.$, arguments);\r\n  }\r\n\r\n  /**\r\n   * @member Arr#last\r\n   * @type {*}\r\n   * @public\r\n   * @readonly\r\n   * @description The last element of the array.\r\n   *\r\n   * @example\r\n   * new Arr([1, 2, 3]).last; // 3\r\n   * new Arr([]).last;        // undefined\r\n   */\r\n  get last() {\r\n    const array = this.$;\r\n\r\n    return array[array.length - 1];\r\n  }\r\n\r\n  /**\r\n   * @member Arr#length\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length\r\n   * @description Synonym for\r\n   * [Array#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length}.\r\n   */\r\n  get length() {\r\n    return this.$.length;\r\n  }\r\n\r\n  /**\r\n   * @method Arr#pop\r\n   * @public\r\n   * @returns {*} Returns deleted element.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop\r\n   * @description Synonym for\r\n   * [Array#pop]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop}.\r\n   */\r\n  pop() {\r\n    return this.$.pop();\r\n  }\r\n\r\n  /**\r\n   * @method Arr#push\r\n   * @public\r\n   * @param {...*} values See the link.\r\n   * @this {Arr}\r\n   * @returns {Arr} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push\r\n   * @description Synonym for\r\n   * [Array#push]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push}\r\n   * besides returning this.\r\n   */\r\n  push(...values) {\r\n    this.$.push.apply(this.$, arguments);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Arr#random\r\n   * @public\r\n   * @returns {*} Random item of the array.\r\n   * @description Method for getting random items of the array.\r\n   *\r\n   * @example\r\n   * new Arr([1, 5, 3]).random(); // 3\r\n   * new Arr([1, 5, 3]).random(); // 5\r\n   */\r\n  random() {\r\n    return this.$[random(0, this.$.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * @method Arr#reverse\r\n   * @public\r\n   * @returns {Arr} A wrap of the reversed array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\r\n   * @description Synonym for\r\n   * [Array#reverse]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}.\r\n   */\r\n  reverse() {\r\n    this.$.reverse();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Arr#shift\r\n   * @public\r\n   * @returns {*} Returns deleted element.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift\r\n   * @description Synonym for\r\n   * [Array#shift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift}.\r\n   */\r\n  shift() {\r\n    return this.$.shift();\r\n  }\r\n\r\n  /**\r\n   * @method Arr#shuffle\r\n   * @public\r\n   * @returns {Arr} Returns this.\r\n   * @description Method for shuffling.\r\n   *\r\n   * @example\r\n   * new Arr([1, 2, 3, 4]).shuffle().$; // [4, 2, 3, 1]\r\n   * new Arr([1, 2, 3, 4]).shuffle().$; // [1, 3, 4, 2]\r\n   */\r\n  shuffle() {\r\n    const length = this.$.length;\r\n\r\n    return this.forEach((value, index, array) => {\r\n      const randomIndex = index + Math.floor((length - index) * Math.random());\r\n\r\n      array[index] = array[randomIndex];\r\n      array[randomIndex] = value;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Arr#slice\r\n   * @public\r\n   * @param {Number} [begin = 0] - See the link.\r\n   * @param {Number} [end = array.length] - See the link.\r\n   * @returns {Arr} A wrap of a sliced array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\r\n   * @description Synonym for\r\n   * [Array#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}.\r\n   */\r\n  slice(begin, end) {\r\n    return new this.constructor(this.$.slice.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Arr#sort\r\n   * @public\r\n   * @param {CompareFunction} [compareFunction] - See the link.\r\n   * @returns {Arr} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n   * @description Synonym for\r\n   * [Array#sort]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}.\r\n   */\r\n  sort(compareFunction) {\r\n    validate([compareFunction], ['function||!'], 'Arr#sort');\r\n\r\n    this.$.sort(compareFunction);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Arr#sortAsc\r\n   * @public\r\n   * @returns {Arr} Returns this.\r\n   * @description Method for ascending sorting. Puts non-numbers first, then NaNs, then sorted values.\r\n   *\r\n   * @example\r\n   * new Arr([NaN, 1, -7, '100', 5]).sortAsc().$; // ['100', NaN, -7, 1, 5]\r\n   */\r\n  sortAsc() {\r\n    return this.sort(asc);\r\n  }\r\n\r\n  /**\r\n   * @method Arr#sortDesc\r\n   * @public\r\n   * @returns {Arr} Returns this.\r\n   * @description Method for descending sorting. Puts sorted values first, then NaNs, then non-numbers.\r\n   *\r\n   * @example\r\n   * new Arr([NaN, 1, -7, '100', 5]).sortDesc().$; // [5, 1, -7, NaN, '100']\r\n   */\r\n  sortDesc() {\r\n    return this.sort((y, x) => asc(x, y));\r\n  }\r\n\r\n  /**\r\n   * @method Arr#splice\r\n   * @public\r\n   * @param {Number} [start] - See the link.\r\n   * @param {Number} [deleteCount] - See the link.\r\n   * @param {...*} [items] - See the link.\r\n   * @returns {Arr} A wrap of return value of #splice call.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\r\n   * @description Synonym for\r\n   * [Array#splice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}.\r\n   */\r\n  splice(start, deleteCount, ...items) {\r\n    return new Arr(this.$.splice.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Arr#string\r\n   * @public\r\n   * @returns {String} Concatenated array.\r\n   * @description Synonym for array.join('').\r\n   *\r\n   * @example\r\n   * new Arr([1, 2, 3]).string(); // '123'\r\n   */\r\n  string() {\r\n    return this.join('');\r\n  }\r\n\r\n  /**\r\n   * @method Arr#unshift\r\n   * @public\r\n   * @param {...*} [values] - See the link.\r\n   * @returns {Arr} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\r\n   * @description Synonym for\r\n   * [Array#unshift]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}\r\n   * besides returning this.\r\n   */\r\n  unshift(...values) {\r\n    this.$.unshift.apply(this.$, arguments);\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\ndefineProperties(Arr.prototype, {\r\n  [Symbol.toStringTag]: 'Arr'\r\n});\r\n\r\n/**\r\n * @function asc\r\n * @private\r\n * @param {*} x - First value to be compared.\r\n * @param {*} y - Second value to be compared.\r\n * @returns {Number} Where to put the first element: before or after.\r\n */\r\nfunction asc(x, y) {\r\n  if (!isNumber(x) && !isNumber(y)) {\r\n    return 0;\r\n  }\r\n\r\n  if (!isNumber(x)) {\r\n    return -1;\r\n  }\r\n\r\n  if (!isNumber(y)) {\r\n    return 1;\r\n  }\r\n\r\n  if (isNaN(x) && isNaN(y)) {\r\n    return 0;\r\n  }\r\n\r\n  if (isNaN(x)) {\r\n    return -1;\r\n  }\r\n\r\n  if (isNaN(y)) {\r\n    return 1;\r\n  }\r\n\r\n  return x - y;\r\n}\r\n\r\nconstructors[1].push({\r\n  check: isArrayLike,\r\n  cls: Arr\r\n});\r\n\r\n/**\r\n * @function array\r\n * @public\r\n * @param {Number} number - Length of the array.\r\n * @param {ArrayCallback} [callback] - If it's present it has to be a function\r\n * that returns the element that is pushed to the new array.\r\n * @returns {Arr} New instance of Arr.\r\n * @description Method for creating new array from the length using optional callback.\r\n *\r\n * @example\r\n * array(3).$;               // [0, 1, 2]\r\n * array(3, (i) => i * 2).$; // [0, 2, 4]\r\n */\r\nfunction array(number, callback) {\r\n  validate([number, callback], [['intLike', '>=0'], 'function||!'], 'array');\r\n\r\n  const array = [];\r\n\r\n  for (let i = 0; i < number; i++) {\r\n    array.push(callback ? callback(i) : i);\r\n  }\r\n\r\n  return new Arr(array);\r\n}\r\n\r\n/**\r\n * @function iterate\r\n * @public\r\n * @param {Number} number - Number of iterations.\r\n * @param {IterateCallback} callback - Callback that is called on each iteration with the iteration index.\r\n * @returns {void}\r\n * @description Method for replacing for (...) construction.\r\n *\r\n * @example\r\n * iterate();\r\n */\r\nfunction iterate(number, callback) {\r\n  validate([number, callback], [['intLike', '>=0'], 'function'], 'iterate');\r\n\r\n  for (let i = 0; i < number; i++) {\r\n    callback(i);\r\n  }\r\n}\r\n\r\nexport { Arr, array, iterate };\r\n","/**\r\n * @module BlobObject\r\n * @private\r\n * @mixin\r\n * @description Exports BlobObject class.\r\n */\r\n\r\nimport { Super } from './Super';\r\nimport { Promise } from './Promise';\r\nimport { constructors } from './constants';\r\nimport {\r\n  isArray, isFunction,\r\n  toStringTag, Symbol, defineProperties\r\n} from './helpers';\r\n\r\n/**\r\n * @typedef {{ buffer: String, binary: String, dataURL: String, text: String }} methods\r\n * @private\r\n * @description List of read blob methods.\r\n */\r\nconst methods = {\r\n  buffer: 'ArrayBuffer',\r\n  binary: 'BinaryString',\r\n  dataURL: 'DataURL',\r\n  text: 'Text'\r\n};\r\nconst { URL } = global;\r\n\r\n/**\r\n * @typedef {('buffer'|'binary'|'dataURL'|'text')} ReadBlobMethod\r\n * @public\r\n * @description Enum type of read blob methods.\r\n */\r\n\r\n/**\r\n * @typedef {ArrayBuffer|ArrayBufferView|Blob|String} BlobParts\r\n * @public\r\n * @description Allowed blob parts.\r\n */\r\n\r\n/**\r\n * @callback ReaderEventListener\r\n * @public\r\n * @param {Event} e - Fired event.\r\n * @param {FileReader} reader - FileReader.\r\n */\r\n\r\n/**\r\n * @class BlobObject\r\n * @extends Super\r\n * @public\r\n * @param {Blob} blob - Blob to wrap.\r\n * @returns {BlobObject} Instance of BlobObject.\r\n * @description Wrap of a blob.\r\n *\r\n * @example\r\n * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }));\r\n */\r\nclass BlobObject extends Super {\r\n  /**\r\n   * @member BlobObject#$\r\n   * @type {Blob}\r\n   * @public\r\n   * @description Original Blob.\r\n   */\r\n\r\n  /**\r\n   * @member {String} BlobObject#dataURL\r\n   * @type {String}\r\n   * @public\r\n   * @readonly\r\n   * @description Returns dataURL representation of the blob.\r\n   */\r\n  get dataURL() {\r\n    return URL.createObjectURL(this.$);\r\n  }\r\n\r\n  /**\r\n   * @method BlobObject#readAs\r\n   * @public\r\n   * @param {ReadBlobMethod} method - Method that is used for reading from blob.\r\n   * @param {ReaderEventListener} [progress] - Progress listener.\r\n   * @returns {Promise} Promise that could be aborted.\r\n   * @description Method for reading from blobs.\r\n   *\r\n   * @example\r\n   * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }))\r\n   *   .readAs('text')\r\n   *   .then((value) => {\r\n   *     console.log(value); // '{\"foo\":\"bar\"}'\r\n   *   });\r\n   */\r\n  readAs(method, progress) {\r\n    if (!methods[method]) {\r\n      throw new Error('1st argument must be one of following values: buffer, binary, dataURL, text');\r\n    }\r\n\r\n    let reader = new FileReader();\r\n    let toReject;\r\n\r\n    if (isFunction(progress)) {\r\n      reader.onprogress = function (e) {\r\n        progress(e, this);\r\n      };\r\n    }\r\n\r\n    const promise = new Promise((resolve, reject) => {\r\n      toReject = reject;\r\n\r\n      reader.onerror = ({ target }) => {\r\n        if (reader) {\r\n          reject(target.error);\r\n        }\r\n      };\r\n\r\n      reader.onload = ({ target }) => {\r\n        resolve(target.result);\r\n      };\r\n\r\n      reader[`readAs${ methods[method] }`](this.$);\r\n    });\r\n\r\n    promise.abort = function abort() {\r\n      toReject(new Error('Reading was aborted'));\r\n\r\n      reader.abort();\r\n\r\n      reader = null;\r\n\r\n      return this;\r\n    };\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * @method BlobObject#saveAs\r\n   * @public\r\n   * @param {String} [name] - Name that is used for saving file.\r\n   * @returns {BlobObject} Returns this.\r\n   * @description Method for saving blobs.\r\n   *\r\n   * @example\r\n   * new BlobObject(new Blob(['{\"foo\":\"bar\"}'], { type: 'application/json' }))\r\n   *   .saveAs('blob.json');\r\n   */\r\n  saveAs(name = 'download') {\r\n    const anchor = document.createElement('a');\r\n\r\n    anchor.href = this.dataURL;\r\n    anchor.setAttribute('download', name);\r\n    anchor.click();\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\ndefineProperties(BlobObject.prototype, {\r\n  [Symbol.toStringTag]: 'BlobObject'\r\n});\r\n\r\nconstructors[1].push({\r\n  check: (blob) => /^(Blob|File)$/.test(toStringTag(blob)),\r\n  cls: BlobObject\r\n});\r\n\r\n/**\r\n * @function blob\r\n * @public\r\n * @param {(BlobParts[]|BlobParts)} blobParts - Blob parts that are passed to\r\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.\r\n * @param {Object} [options] - Options that are passed to\r\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob} constructor.\r\n * @returns {BlobObject} New instance of BlobObject.\r\n * @description Function for creating blobs not involving BlobObject and Blob constructors.\r\n */\r\nfunction blob(blobParts, options = {}) {\r\n  if (!isArray(blobParts)) {\r\n    blobParts = [blobParts];\r\n  }\r\n\r\n  return new BlobObject(new Blob(blobParts, options));\r\n}\r\n\r\nexport { BlobObject, blob };\r\n","/**\r\n * @module Str\r\n * @private\r\n * @mixin\r\n * @description Exports Str class.\r\n */\r\n\r\nimport { D } from './D';\r\nimport { Super } from './Super';\r\nimport { constructors, regexpSpecialCharacters } from './constants';\r\nimport {\r\n  isFunction, isNumberLike, isObject, isString,\r\n  validate, Symbol, defineProperties, iterate\r\n} from './helpers';\r\n\r\nconst htmlSpecials = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;'\r\n};\r\nconst regexpSpecialsRegexp = new RegExp(\r\n  new Super(regexpSpecialCharacters)\r\n    .word((x) => `\\\\${ x }|`)\r\n    .replace(/\\|$/, ''),\r\n  'g'\r\n);\r\n\r\n/**\r\n * @class Str\r\n * @extends Super\r\n * @public\r\n * @param {String} [string = ''] - A string to wrap.\r\n * @returns {Str} Instance of Str.\r\n * @description Wrap of a string.\r\n *\r\n * @example\r\n * const s = new Num('1');\r\n */\r\nclass Str extends Super {\r\n  constructor(string = '') {\r\n    super(`${ string }`);\r\n\r\n    /**\r\n     * @member Str#$\r\n     * @type {String}\r\n     * @public\r\n     * @description Original string.\r\n     */\r\n  }\r\n\r\n  /**\r\n   * @method Str#capitalizeFirst\r\n   * @public\r\n   * @returns {Str} Capitalized string.\r\n   * @description Method capitalizing the first symbol.\r\n   *\r\n   * @example\r\n   * new Str('foo').capitalizeFirst().$; // 'Foo'\r\n   */\r\n  capitalizeFirst() {\r\n    const string = this.$;\r\n\r\n    return new Str(string.slice(0, 1).toUpperCase() + string.slice(1));\r\n  }\r\n\r\n  /**\r\n   * @method Str#endsWith\r\n   * @public\r\n   * @param {String} searchString - See the link.\r\n   * @param {Number} [position = string.length] - See the link.\r\n   * @returns {Boolean} If the string ends with the argument string.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\r\n   * @description Synonym for\r\n   * [String#endsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith}.\r\n   */\r\n  endsWith(searchString, position) {\r\n    if (arguments.length < 2) {\r\n      position = this.$.length;\r\n    }\r\n\r\n    return this\r\n      .slice(0, position)\r\n      .revert()\r\n      .startsWith(new Str(searchString).revert().$);\r\n  }\r\n\r\n  /**\r\n   * @method Str#escapeHTML\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Methods escaping \"&\", \"<\" and \">\" symbols.\r\n   *\r\n   * @example\r\n   * new Str('\"1 < 2\" & \"7 > 4\" are true expressions.').escapeHTML().$;\r\n   * // '\"1 &lt; 2\" &amp \"7 &gt; 2\" are true expressions.'\r\n   */\r\n  escapeHTML() {\r\n    let string = this.$;\r\n\r\n    iterate(htmlSpecials, (escaped, symbol) => {\r\n      string = string.replace(new RegExp(symbol, 'g'), escaped);\r\n    });\r\n\r\n    return new Str(string);\r\n  }\r\n\r\n  /**\r\n   * @method Str#escapeRegExp\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Method escaping RegExp special characters.\r\n   *\r\n   * @example\r\n   * new Str('(213.98 - [] {})').escapeRegExp().$; // '\\(213\\.98 \\- \\[\\] \\{\\}\\)'\r\n   */\r\n  escapeRegExp() {\r\n    return this.replace(regexpSpecialsRegexp, '\\\\$&');\r\n  }\r\n\r\n  /**\r\n   * @method Str#in\r\n   * @public\r\n   * @param {*} object - Object to check the string as a property in.\r\n   * @returns {Boolean} If it is in the object or not.\r\n   * @description Returns string in object.\r\n   *\r\n   * @example\r\n   * new Str('a').in({ a: 1 }); // true\r\n   * new Str('toFixed').in(1);  // false\r\n   * new Str('a').in(null);     // false\r\n   */\r\n  in(object) {\r\n    if (!isObject(object)) {\r\n      return false;\r\n    }\r\n\r\n    return this.$ in object;\r\n  }\r\n\r\n  /**\r\n   * @method Str#indexOf\r\n   * @public\r\n   * @param {String} searchValue - See the link.\r\n   * @param {Number} [fromIndex = 0] - See the link.\r\n   * @returns {Number} Found index or -1.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\r\n   * @description Synonym for\r\n   * [String#indexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf}.\r\n   */\r\n  indexOf(searchValue, fromIndex) {\r\n    return this.$.indexOf.apply(this.$, arguments);\r\n  }\r\n\r\n  /**\r\n   * @method Str#lastIndexOf\r\n   * @public\r\n   * @param {String} searchValue - See the link.\r\n   * @param {Number} [fromIndex = string.length] - See the link.\r\n   * @returns {Number} Found index or -1.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf\r\n   * @description Synonym for\r\n   * [String#lastIndexOf]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf}.\r\n   */\r\n  lastIndexOf(searchValue, fromIndex) {\r\n    return this.$.lastIndexOf.apply(this.$, arguments);\r\n  }\r\n\r\n  /**\r\n   * @member Str#length\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length\r\n   * @description Synonym for\r\n   * [String#length]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/length}.\r\n   */\r\n  get length() {\r\n    return this.$.length;\r\n  }\r\n\r\n  /**\r\n   * @method Str#match\r\n   * @public\r\n   * @returns {Arr|Super} D-Wrap of found match.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match\r\n   * @description Synonym for\r\n   * [String#match]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match}.\r\n   */\r\n  match(regexp) {\r\n    return D(this.$.match.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Str#repeat\r\n   * @public\r\n   * @param {Integer} times - Times to repeat the string.\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\r\n   * @description Synonym for\r\n   * [String#repeat]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/repeat}.\r\n   *\r\n   * @example\r\n   * new Str('123').repeat(2).$; // '123123'\r\n   * new Str('123').repeat(0).$; // ''\r\n   */\r\n  repeat(times) {\r\n    validate([times], [['intLike', '>=0']], 'Str#repeat');\r\n\r\n    times = +times;\r\n\r\n    const string = this.$;\r\n\r\n    let s = '';\r\n\r\n    for (let i = 0; i < times; i++) {\r\n      s += string;\r\n    }\r\n\r\n    return new Str(s);\r\n  }\r\n\r\n  /**\r\n   * @method Str#replace\r\n   * @public\r\n   * @param {RegExp|String} regexp - See the link.\r\n   * @param {String|Function} [replacer = ''] - See the link.\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace\r\n   * @description Synonym for\r\n   * [String#replace]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/replace}\r\n   * besides that replacer has a default value of ''.\r\n   */\r\n  replace(regexp, replacer = '') {\r\n    return new Str(this.$.replace(regexp, replacer));\r\n  }\r\n\r\n  /**\r\n   * @method Str#replaceString\r\n   * @public\r\n   * @param {String} string - String to replace.\r\n   * @param {String} [replacer = ''] - String to replace with.\r\n   * @returns {Str} New instance of Str.\r\n   * @description Method for global string replaceing.\r\n   *\r\n   * @example\r\n   * new Str('123123').replaceString('1', '4').$; // '423423'\r\n   * new Str('123123').replaceString('1').$;      // '2323'\r\n   */\r\n  replaceString(string, replacer = '') {\r\n    string = new Super(string).$;\r\n\r\n    validate([string], ['string'], 'Str#replaceString');\r\n\r\n    return new Str(this.$.split(string).join(replacer));\r\n  }\r\n\r\n  /**\r\n   * @method Str#revert\r\n   * @public\r\n   * @returns {Str} New instance of string.\r\n   * @description Method for reverting a string.\r\n   *\r\n   * @example\r\n   * new Str('1234').revert().$; // '4321'\r\n   */\r\n  revert() {\r\n    const string = this.$;\r\n    let str = '';\r\n\r\n    for (let i = string.length - 1; i >= 0; i--) {\r\n      str += string[i];\r\n    }\r\n\r\n    return new Str(str);\r\n  }\r\n\r\n  /**\r\n   * @method Str#search\r\n   * @public\r\n   * @param {RegExp} regexp - See the link.\r\n   * @returns {Number} Index of the first match, if found, and -1 if not.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search\r\n   * @description Synonym for\r\n   * [String#search]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search}.\r\n   */\r\n  search(regexp) {\r\n    validate([regexp], ['regexp']);\r\n\r\n    return this.$.search.apply(this.$, arguments);\r\n  }\r\n\r\n  /**\r\n   * @method Str#slice\r\n   * @public\r\n   * @param {Number} [beginSlice = 0] - See the link.\r\n   * @param {Number} [endSlice = string.length] - See the link.\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice\r\n   * @description Synonym for\r\n   * [String#slice]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice}.\r\n   */\r\n  slice(beginSlice, endSlice) {\r\n    return new Str(this.$.slice.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Str#split\r\n   * @public\r\n   * @param {RegExp|String} [separator] - See the link.\r\n   * @returns {Arr|Super} D-Wrap of the array.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split\r\n   * @description Synonym for\r\n   * [String#split]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/split}.\r\n   */\r\n  split(separator) {\r\n    return D(this.$.split.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Str#startsWith\r\n   * @public\r\n   * @param {String} searchString - See the link.\r\n   * @param {Number} [position = 0] - See the link.\r\n   * @returns {Boolean} If the string ends with the argument string.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\r\n   * @description Synonym for\r\n   * [String#startsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith}.\r\n   */\r\n  startsWith(searchString, position = 0) {\r\n    return this.$.indexOf.apply(this.$, arguments) === position;\r\n  }\r\n\r\n  /**\r\n   * @method Str#substr\r\n   * @public\r\n   * @param {Number} [start = 0] - See the link.\r\n   * @param {Number} [length = string.length] - See the link.\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr\r\n   * @description Synonym for\r\n   * [String#substr]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substr}.\r\n   */\r\n  substr(start, length) {\r\n    return new Str(this.$.substr.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Str#substring\r\n   * @public\r\n   * @param {Number} [indexStart = 0] - See the link.\r\n   * @param {Number} [indexEnd = string.length] - See the link.\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring\r\n   * @description Synonym for\r\n   * [String#substring]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring}.\r\n   */\r\n  substring(indexStart, indexEnd) {\r\n    return new Str(this.$.substring.apply(this.$, arguments));\r\n  }\r\n\r\n  /**\r\n   * @method Str#toCamelCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Removes following regexp /\\s\\-_\\./ making the string camel cased.\r\n   *\r\n   * @example\r\n   * new Str('spinal-case').toCamelCase().$;  // 'spinalCase'\r\n   * new Str('_snake_case_').toCamelCase().$; // 'snakeCase'\r\n   */\r\n  toCamelCase() {\r\n    return new Str(trim(this.$)\r\n      .replace(/[\\s\\-_.]+/g, '-')\r\n      .replace(/-[^-]/g, (match) => match[1].toUpperCase())\r\n      .replace(/^[\\S]/, (match) => match.toLowerCase())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @method Str#toCapitalCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Removes following regexp /\\-_\\./ making the string capital letter cased.\r\n   *\r\n   * @example\r\n   * new Str('spinal-case').toCapitalCase().$;  // 'Spinal Case'\r\n   * new Str('_snake_case_').toCapitalCase().$; // 'Snake Case'\r\n   */\r\n  toCapitalCase() {\r\n    return new Str(trim(this.$)\r\n      .replace(/[\\s\\-_.]+/g, ' ')\r\n      .replace(/[\\S]/g, (match) => (\r\n        match.toLowerCase() === match ? match : ` ${ match }`\r\n      ))\r\n      .replace(/\\s[\\S]/g, (match) => match.toUpperCase())\r\n      .replace(/\\s+/g, ' ')\r\n      .replace(/^\\s/, '')\r\n      .replace(/^[\\S]/, (match) => match.toUpperCase())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @method Str#toDotCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Removes following regexp /\\-_\\./ making the string dot cased.\r\n   *\r\n   * @example\r\n   * new Str('spinal-case').toDotCase().$;  // 'spinal.case'\r\n   * new Str('_snake_case_').toDotCase().$; // 'snake.case'\r\n   */\r\n  toDotCase() {\r\n    return new Str(trim(this.$)\r\n      .replace(/[\\s\\-_.]+/g, '.')\r\n      .replace(/[^.]/g, (match) => (\r\n        match.toLowerCase() === match ? match : `.${ match }`\r\n      ))\r\n      .replace(/\\.+/g, '.')\r\n      .replace(/^\\./, '')\r\n      .toLowerCase()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @method Str#toHyphenCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Removes following regexp /\\s\\-_\\./ making the string camel cased.\r\n   *\r\n   * @example\r\n   * new Str('camelCase').toSpinalCase().$;    // 'camel-case'\r\n   * new Str('_snake_case_').toSpinalCase().$; // 'snake-case'\r\n   */\r\n  toHyphenCase() {\r\n    return new Str(trim(this.$)\r\n      .replace(/[\\s\\-_.]+/g, '-')\r\n      .replace(/[^-]/g, (match) => (\r\n        match.toLowerCase() === match ? match : `-${ match }`\r\n      ))\r\n      .replace(/-+/g, '-')\r\n      .replace(/^-/, '')\r\n      .toLowerCase()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @method Str#toLowerCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase\r\n   * @description Synonym for\r\n   * [String#toLowerCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase}.\r\n   *\r\n   * @example\r\n   * new Str('UPPER-CASE').toLowerCase().$;  // 'upper-case'\r\n   */\r\n  toLowerCase() {\r\n    return new Str(this.$.toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * @method Str#toSnakeCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Removes following regexp /\\s\\-\\./ making the string spinal cased.\r\n   *\r\n   * @example\r\n   * new Str('spinal-case').toSnakeCase().$; // 'spinal_case'\r\n   * new Str('camelCase').toSnakeCase().$;   // 'camel_case'\r\n   */\r\n  toSnakeCase() {\r\n    return new Str(trim(this.$)\r\n      .replace(/[\\s\\-_.]+/g, '_')\r\n      .replace(/[^_]/g, (match) => (\r\n        match.toLowerCase() === match ? match : `_${ match }`\r\n      ))\r\n      .replace(/_+/g, '_')\r\n      .replace(/^_/, '')\r\n      .toLowerCase()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @method Str#toSpaceCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @description Removes following regexp /\\-_\\./ making the string space cased.\r\n   *\r\n   * @example\r\n   * new Str('spinal-case').toSpaceCase().$;  // 'spinal case'\r\n   * new Str('_snake_case_').toSpaceCase().$; // 'snake case'\r\n   */\r\n  toSpaceCase() {\r\n    return new Str(trim(this.$)\r\n      .replace(/[\\s\\-_.]+/g, ' ')\r\n      .replace(/[\\S]/g, (match) => (\r\n        match.toLowerCase() === match ? match : ` ${ match }`\r\n      ))\r\n      .replace(/\\s+/g, ' ')\r\n      .replace(/^\\s/, '')\r\n      .toLowerCase()\r\n    );\r\n  }\r\n\r\n  toString() {\r\n    return this.$;\r\n  }\r\n\r\n  /**\r\n   * @method Str#toUpperCase\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase\r\n   * @description Synonym for\r\n   * [String#toUpperCase]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase}.\r\n   *\r\n   * @example\r\n   * new Str('lower-case').toUpperCase().$;  // 'LOWER-CASE'\r\n   */\r\n  toUpperCase() {\r\n    return new Str(this.$.toUpperCase());\r\n  }\r\n\r\n  /**\r\n   * @method Str#trim\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim\r\n   * @description Synonym for\r\n   * [String#trim]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trim}.\r\n   */\r\n  trim() {\r\n    return new Str(this.$.replace(/^[\\s\\ufeff\\u00a0]+|[\\s\\ufeff\\u00a0]+$/g, ''));\r\n  }\r\n\r\n  /**\r\n   * @method Str#trimLeft\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft\r\n   * @description Synonym for\r\n   * [String#trimLeft]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimLeft}.\r\n   */\r\n  trimLeft() {\r\n    return new Str(this.$.replace(/^[\\s\\ufeff\\u00a0]+/, ''));\r\n  }\r\n\r\n  /**\r\n   * @method Str#trimRight\r\n   * @public\r\n   * @returns {Str} New instance of Str.\r\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight\r\n   * @description Synonym for\r\n   * [String#trimRight]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/trimRight}.\r\n   */\r\n  trimRight() {\r\n    return new Str(this.$.replace(/[\\s\\ufeff\\u00a0]+$/, ''));\r\n  }\r\n}\r\n\r\ndefineProperties(Str.prototype, {\r\n  [Symbol.toStringTag]: 'Str'\r\n});\r\n\r\nconstructors[2].push({\r\n  check: isString,\r\n  cls: Str\r\n});\r\n\r\nfunction trim(string) {\r\n  return string.replace(/^[\\s\\-_.]+|[\\s\\-_.]+$/g, '');\r\n}\r\n\r\n/**\r\n * @function parseJSON\r\n * @public\r\n * @param {String} [json = null] - String to parse.\r\n * @param {Object} [options] - Options.\r\n * @param {Boolean|*} [options.numbers] - If it is needed to parse number-like strings as numbers.\r\n * @param {Boolean|*} [options.dates] - If it is needed to parse date-like string as dates.\r\n * Date-like string is considered to match ^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ?$\r\n * @param {JSONCallback} [callback] - Callback that called on every iteration.\r\n * @returns {DWrap} D-Wrap of found match.\r\n * @description Method for parsing json.\r\n *\r\n * @example\r\n * parseJSON('{ \"a\": 1 }').$;                                           // { a: 1 }\r\n * parseJSON('{ \"a\": \"1\" }', { numbers: true }).$;                      // { numbers: true }\r\n * parseJSON('{ \"a\": \"1999-12-31T23:59:59.999Z\" }', { dates: true }).$; // { a: Date {...} }\r\n */\r\nfunction parseJSON(json = null, options = {}, callback) {\r\n  if (arguments.length <= 1) {\r\n    return D(JSON.parse(json));\r\n  }\r\n\r\n  if (isFunction(options)) {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  const { numbers, dates } = options;\r\n  const parsed = JSON.parse(json, function (key, value) {\r\n    if (dates && /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ?$/.test(value)) {\r\n      value = new Date(value);\r\n    } else if (numbers && isNumberLike(value) && isString(value)) {\r\n      value = Number(value);\r\n    }\r\n\r\n    return callback ? callback.apply(this, arguments) : value;\r\n  });\r\n\r\n  return D(parsed);\r\n}\r\n\r\nexport { Str, parseJSON };\r\n","/**\r\n * @module helpers/markupToJSON\r\n * @private\r\n * @description Exports markupToJSON method.\r\n */\r\n\r\nimport { Arr } from '../Arr';\r\nimport { Str } from '../Str';\r\nimport { Super } from '../Super';\r\nimport { switcher } from '../Switcher';\r\nimport { htmlAllowedTagSymbols, htmlAllowedAttrSymbols, voidElements } from '../constants';\r\n\r\n/**\r\n * @typedef {Object} MarkupElement\r\n * @property {'comment'|'text'|'element'} type - Type of the node.\r\n * @property {MarkupElement} parent - Type of the node.\r\n * @property {Object.<String, String>} attrs - Node attributes\r\n * @property {MarkupElement[]} children - Node children.\r\n */\r\n\r\nconst submitString = 'Please, submit an issue at https://github.com/dwaynejs/dwayne/issues.';\r\nconst NODE_REGEX_SET = new Super({\r\n  'tag-open': new RegExp(`<(${ htmlAllowedTagSymbols })\\\\s*`, 'i'),\r\n  'tag-close': constructCloseTagRegExp(htmlAllowedTagSymbols),\r\n  comment: /<!--((?:-[^\\->]|[^\\->])(?:-?[^-])*[^-]?|)-->/\r\n});\r\nconst TAG_OPEN_CLOSE = /^(\\/?)>/;\r\n// const ATTRIBUTE = /^([^\\u0000-\\u0020\\s\"'>\\/=]+)(?:\\s*=\\s*('[^']*'|\"[^\"]*\"|[^\\s\"'`<>=]+))?\\s*/;\r\nconst ATTRIBUTE = new RegExp(`^(${ htmlAllowedAttrSymbols })(?:\\\\s*=\\\\s*('[^']*'|\"[^\"]*\"|[^\\\\s\"'\\`<>=]+))?\\\\s*`);\r\nconst div = document.createElement('div');\r\nconst nodeSwitcher = switcher('strictEquals', (elem) => elem)\r\n  .case('tag-open', (elem, node) => {\r\n    const {\r\n      value: name,\r\n      selfClosing\r\n    } = node;\r\n\r\n    node = {\r\n      name,\r\n      attrs: new Super(node.attrs).map((value) => (\r\n        parseCharacterData(value)\r\n      )).$,\r\n      parent: elem,\r\n      children: new Arr([])\r\n    };\r\n\r\n    elem.children.push(node);\r\n\r\n    if (!selfClosing && voidElements.indexOf(name) === -1) {\r\n      elem = node;\r\n    }\r\n\r\n    return elem;\r\n  })\r\n  .case('tag-close', (elem, node) => {\r\n    if (elem.name === node.value) {\r\n      elem = elem.parent;\r\n    }\r\n\r\n    return elem;\r\n  })\r\n  .case(['comment', 'text'], (elem, node, collapseWhiteSpace, type) => {\r\n    const element = {\r\n      name: `#${ type }`,\r\n      parent: elem,\r\n      value: node.value\r\n    };\r\n\r\n    if (type === 'text' && elem.name !== 'script' && elem.name !== 'style') {\r\n      element.value = parseCharacterData(element.value);\r\n\r\n      if (collapseWhiteSpace) {\r\n        element.value = new Str(element.value).trim().$;\r\n      }\r\n    }\r\n\r\n    if (!collapseWhiteSpace || !/^\\s*$/.test(element.value)) {\r\n      elem.children.push(element);\r\n    }\r\n\r\n    return elem;\r\n  });\r\nconst rawTextSwitcher = switcher('strictEquals', false)\r\n  .case(['title', 'textarea', 'style', 'script'], true);\r\n\r\nclass InternalParsingError {\r\n  constructor(index) {\r\n    this.index = index;\r\n  }\r\n}\r\n\r\nclass ParsingError extends Error {\r\n  type = 'PARSING_ERROR';\r\n}\r\n\r\n/**\r\n * @function markupToJSON\r\n * @private\r\n * @param {String} markup - Markup to parse to JSON.\r\n * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be collapsed.\r\n * @returns {Arr.<MarkupElement>} Markup elements array.\r\n * @description Function for parsing html and xml to JSON.\r\n */\r\nexport default (markup, collapseWhiteSpace) => {\r\n  collapseWhiteSpace = !!collapseWhiteSpace;\r\n\r\n  const elements = new Arr([]);\r\n  const startMarkup = markup;\r\n  let found;\r\n  let globalIndex = 0;\r\n  let elem = {\r\n    name: null,\r\n    children: elements\r\n  };\r\n\r\n  while (markup.length) {\r\n    try {\r\n      found = find(markup, elem);\r\n    } catch (err) {\r\n      if (!(err instanceof InternalParsingError)) {\r\n        throwUnexpectedError();\r\n      }\r\n\r\n      throw new ParsingError(`Parsing error near index ${ nearString(startMarkup, globalIndex + err.index) }`);\r\n    }\r\n\r\n    const {\r\n      type,\r\n      attrs,\r\n      selfClosing,\r\n      index,\r\n      value\r\n    } = found;\r\n\r\n    globalIndex += index;\r\n\r\n    if (!index) {\r\n      throwUnexpectedError();\r\n    }\r\n\r\n    const node = {\r\n      type,\r\n      value\r\n    };\r\n\r\n    if (type === 'tag-open') {\r\n      node.attrs = attrs;\r\n      node.selfClosing = selfClosing;\r\n    }\r\n\r\n    elem = nodeSwitcher(node.type, [elem, node, collapseWhiteSpace]);\r\n\r\n    markup = markup.slice(index);\r\n  }\r\n\r\n  return elements;\r\n\r\n  function throwUnexpectedError() {\r\n    throw new ParsingError(`Unexpected parsing error near index ${ nearString(startMarkup, globalIndex) }. ${ submitString }`);\r\n  }\r\n};\r\n\r\nfunction find(markup, elem) {\r\n  const { name } = elem;\r\n  let matches;\r\n\r\n  if (rawTextSwitcher(name)) {\r\n    matches = new Super({\r\n      'tag-close': markup.match(constructCloseTagRegExp(name))\r\n    });\r\n  } else {\r\n    matches = NODE_REGEX_SET.map((regex) => (\r\n      markup.match(regex)\r\n    ));\r\n  }\r\n\r\n  let match;\r\n\r\n  if (\r\n    match = matches.find((match) => (\r\n      match && match.index === 0\r\n    ))\r\n  ) {\r\n    const returning = {\r\n      type: match.key,\r\n      index: match.value[0].length,\r\n      value: match.value[1]\r\n    };\r\n    const attrs = {};\r\n\r\n    if (match.key === 'tag-open') {\r\n      const startMarkup = markup;\r\n      let closeMatch;\r\n\r\n      returning.selfClosing = false;\r\n      returning.attrs = attrs;\r\n\r\n      while (\r\n        (markup = startMarkup.slice(returning.index)) &&\r\n        !(closeMatch = markup.match(TAG_OPEN_CLOSE))\r\n      ) {\r\n        const attr = markup.match(ATTRIBUTE);\r\n\r\n        if (!attr) {\r\n          returning.index += 1;\r\n\r\n          continue;\r\n        }\r\n\r\n        attrs[attr[1]] = (attr[2] || '').replace(/^(\"|')|(\"|')$/g, '');\r\n        returning.index += attr[0].length;\r\n      }\r\n\r\n      if (closeMatch) {\r\n        returning.index += closeMatch[0].length;\r\n        returning.selfClosing = !!closeMatch[1];\r\n      }\r\n    }\r\n\r\n    return returning;\r\n  }\r\n\r\n  let { value: index } = matches.min((match) => (\r\n    match ? match.index : NaN\r\n  ));\r\n\r\n  if (index === Infinity) {\r\n    index = markup.length;\r\n  }\r\n\r\n  return {\r\n    type: 'text',\r\n    index,\r\n    value: markup.slice(0, index)\r\n  };\r\n}\r\n\r\nfunction constructCloseTagRegExp(tagName) {\r\n  return new RegExp(`</(${ tagName })\\\\s*>`, 'i');\r\n}\r\n\r\nfunction nearString(markup, index) {\r\n  return `${ index } (~~~ \"${ markup.slice(index, index + 15) }\" ~~~, the string itself is \"${ markup }\")`;\r\n}\r\n\r\nfunction parseCharacterData(string) {\r\n  return string.replace(/&(\\w+|#x?\\d+);/g, (match) => {\r\n    div.innerHTML = match;\r\n\r\n    return div.textContent || div.innerText;\r\n  });\r\n}\r\n","/**\r\n * @module Elem\r\n * @private\r\n * @mixin\r\n * @description Exports Elem class.\r\n */\r\n\r\nimport { Super } from './Super';\r\nimport { Arr, array, iterate as times } from './Arr';\r\nimport { blob } from './BlobObject';\r\nimport { method } from './Func';\r\nimport { Promise } from './Promise';\r\nimport { Str } from './Str';\r\nimport { switcher } from './Switcher';\r\nimport {\r\n  constructors, appliedRegExps, htmlElements, svgElements,\r\n  canvasGetMethods, canvasRestMethods\r\n} from './constants';\r\nimport {\r\n  isArray, isArrayLike, isElement, isFunction,\r\n  isInteger, isNil, isNumber, isNull, isString,\r\n  assign, dynamicDefineProperties, defineProperties, toArray,\r\n  validate, toStringTag, iterate, Symbol\r\n} from './helpers';\r\nimport markupToJSON from './helpers/markupToJSON';\r\n\r\n/**\r\n * @typedef {String} ElemEventString\r\n * @public\r\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\r\n */\r\n\r\n/**\r\n * @callback ElemValueCallback\r\n * @public\r\n * @param {String} value - Old value.\r\n * @param {Elem} elem - Current element.\r\n * @param {Number} index - Index in the set of the elements.\r\n */\r\n\r\n/**\r\n * @callback ElemSetOfCallback\r\n * @public\r\n * @param {Element} created - Created element.\r\n * @param {*} value - Value of the iterated element in the object.\r\n * @param {Key} key - Key of the iterated element in the object.\r\n * @param {*} object - Object that is iterated over.\r\n * @param {Element} elem - Current element.\r\n * @param {Number} index - Index of the current element.\r\n */\r\n\r\n/**\r\n * @callback ValidateCallback\r\n * @public\r\n * @param {*} value - Element value.\r\n * @param {Element} elem - Element to validate.\r\n * @param {Number} index - Index of the element.\r\n */\r\n\r\n/**\r\n * @callback CtxCallback\r\n * @public\r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context.\r\n */\r\n\r\n/**\r\n * @callback ElemListener\r\n * @public\r\n * @param {Event} e - Fired event.\r\n * @param {Element} elem - Element on which the listener was called.\r\n * @param {Number} index - Index of the element on which the listener was called.\r\n */\r\n\r\n/**\r\n * @callback ElemRemoveListeners\r\n * @public\r\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\r\n * by the events in the arguments.\r\n */\r\n\r\nconst nativeDocument = global.document;\r\nconst emptyDiv = nativeDocument.createElement('div');\r\nconst eventSeparator = /(,| ) */;\r\nconst textProperty = new Super(Node.prototype).propertyDescriptor('textContent') ? 'textContent' : 'innerText';\r\nconst classes = {};\r\nconst attrs = {};\r\nconst windowsDwayneData = new Arr([]);\r\nconst inputElements = 'input, select, textarea, datalist, keygen, output';\r\nconst click = method('click');\r\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst xmlNS = 'http://www.w3.org/2000/xmlns/';\r\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nconst xhtmlNS = 'http://www.w3.org/1999/xhtml';\r\nconst typeSwitcher = switcher('call', (elem, type) => {\r\n  const ns = type === 'svg'\r\n    ? svgNS\r\n    : elem.prop('namespaceURI') || nativeDocument.documentElement.namespaceURI || xhtmlNS;\r\n\r\n  return nativeDocument.createElementNS(ns, type);\r\n})\r\n  .case(\r\n    (type) => type === '#comment',\r\n    () => nativeDocument.createComment('')\r\n  )\r\n  .case(\r\n    (type) => type === '#text',\r\n    () => nativeDocument.createTextNode('')\r\n  );\r\nconst refSwitcher = switcher('strictEquals', 'href')\r\n  .case(\r\n    ['img', 'script', 'iframe', 'audio', 'video'],\r\n    'src'\r\n  )\r\n  .case(\r\n    'form',\r\n    'action'\r\n  );\r\nconst filterSwitcher = switcher('call', (selector) => selector)\r\n  .case(\r\n    isString,\r\n    (selector) => (\r\n      (elem) => new Elem(elem).is(selector)\r\n    )\r\n  )\r\n  .case(\r\n    [isArray, isElem],\r\n    (elems) => {\r\n      elems = new Arr(elems);\r\n\r\n      return (elem) => elems.indexOf(elem) !== -1;\r\n    }\r\n  );\r\nconst innerSwitcher = switcher('strictEquals', 0)\r\n  .case('padding-box', (paddings) => paddings)\r\n  .case('border-box', (paddings, borders) => paddings + borders);\r\nconst outerSwitcher = switcher('strictEquals', (borders, paddings) => borders + paddings)\r\n  .case('padding-box', (borders) => borders)\r\n  .case('border-box', 0);\r\nconst attrNSSwitcher = switcher('call', null)\r\n  .case((attr) => attr === 'xmlns' || attr === 'xmlns:xlink', (elem) => (\r\n    elem.name === 'svg'\r\n      ? xmlNS\r\n      : null\r\n  ))\r\n  .case((attr) => /^xlink:\\w/.test(attr), (elem) => (\r\n    elem.closest('svg').length\r\n      ? xlinkNS\r\n      : null\r\n  ));\r\n\r\n/**\r\n * @class Elem\r\n * @extends Arr\r\n * @public\r\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\r\n * @returns {Elem} Instance of Elem.\r\n * @description Wrap of an elements set. Also has all methods from from\r\n * [CanvasRenderingContext2D]{@link https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D}.\r\n * Getters methods return the same as methods from CanvasRenderingContext2D and the rest return this.\r\n * Work for the first canvas element in the set.\r\n *\r\n * @example\r\n * new Elem(document.body);\r\n * new Elem(document.querySelectorAll('.cls'));\r\n * new Elem(document.getElementsByClassName('cls'));\r\n */\r\nclass Elem extends Arr {\r\n  constructor(elem = []) {\r\n    super((() => {\r\n      let element = elem;\r\n\r\n      if (isArrayLike(element) && (\r\n        isWindow(element) ||\r\n        isHTMLDocument(element) ||\r\n        isDocumentFragment(element) ||\r\n        isElement(element) ||\r\n        isCommentOrText(element) ||\r\n        isStyleRule(element)\r\n      )) {\r\n        element = [element];\r\n      }\r\n\r\n      return new Arr(toArray(new Super(element).$, true)).object((elems, elem) => {\r\n        if (elems.indexOf(elem) === -1 && (\r\n          isElement(elem) ||\r\n          isWindow(elem) ||\r\n          isHTMLDocument(elem) ||\r\n          isDocumentFragment(elem) ||\r\n          isCommentOrText(elem) ||\r\n          isStyleRule(elem)\r\n        )) {\r\n          return elems.push(elem);\r\n        }\r\n\r\n        if (isElem(elem)) {\r\n          elems.push.apply(elems, elem.$);\r\n        }\r\n      }, []).$;\r\n    })());\r\n\r\n    this.$$ = elem;\r\n\r\n    this.forEach(addDwayneData);\r\n\r\n    /**\r\n     * @member {Array.<Node|Window>} Elem#$\r\n     * @type {Array.<Node|Window>}\r\n     * @public\r\n     * @description Constructed element set.\r\n     */\r\n\r\n    /**\r\n     * @member {*} Elem#$$\r\n     * @type {*}\r\n     * @public\r\n     * @description Initial element set.\r\n     */\r\n  }\r\n\r\n  /**\r\n   * @method Elem#add\r\n   * @public\r\n   * @param {...(String|Elem|Element|Element[])} elements - Each argument is a selector, or Elem, or Element, or array of Elements.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding new elements to the set.\r\n   *\r\n   * @example\r\n   * elem1.find('.cls1')\r\n   *   .add(elem2.find('.cls2'))\r\n   *   .hide();\r\n   */\r\n  add(...elements) {\r\n    iterate(arguments, (elem) => {\r\n      toFind(elem).forEach((elem) => {\r\n        if (this.indexOf(elem) === -1) {\r\n          this.push(elem);\r\n        }\r\n      });\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#addClass\r\n   * @public\r\n   * @param {...String} classes - Classes to add.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding classes to the all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.addClass('red', 'round');\r\n   */\r\n  addClass(...classes) {\r\n    return this.forEach((elem) => {\r\n      const list = elem.classList;\r\n\r\n      iterate(isElement(elem) && arguments, (cls) => list.add(cls));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#addComment\r\n   * @public\r\n   * @param {String} text - Text of comment to add.\r\n   * @param {Boolean} end - If the comment should be inserted to the end. If false it's inserted to the start.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding comment to all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.addHTML('<div>1</div>');\r\n   */\r\n  addComment(text, end = true) {\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', `<!--${ text }-->`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#addHTML\r\n   * @public\r\n   * @param {String} html - HTML to add.\r\n   * @param {Boolean} end - If the HTML should be inserted to the end. If false it's inserted to the start.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding HTML to all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.addHTML('<div>1</div>');\r\n   */\r\n  addHTML(html, end = true) {\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.insertAdjacentHTML(end ? 'beforeend' : 'afterbegin', html);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#addRule\r\n   * @public\r\n   * @param {String} name - Name of the rule.\r\n   * @param {String} selector - Selector for the rule\r\n   * @param {Object.<String, String>} style - Style for the selector.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding css styles into the first style tag in the set.\r\n   * Note: style element should be inside the document.\r\n   *\r\n   * @example\r\n   * style.addRule('img-size', 'img.square', {\r\n   *   width: '40px !important',\r\n   *   height: '40px !important'\r\n   * });\r\n   */\r\n  addRule(name, selector, style) {\r\n    this.some((elem) => {\r\n      if (getName(elem) === 'style') {\r\n        const { sheet } = elem;\r\n        const { length } = sheet.cssRules;\r\n        const rules = new Super(style).word((value, property) => (\r\n          `${ new Str(property).toHyphenCase() }: ${ value };\\n`\r\n        ));\r\n\r\n        sheet.insertRule(\r\n          `${ selector } {${ rules && '\\n' }${ rules }}`,\r\n          length\r\n        );\r\n        sheet.cssRules[length].dwayneData = { name };\r\n\r\n        return true;\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#addText\r\n   * @public\r\n   * @param {String} text - Text to add.\r\n   * @param {Boolean} end - If the text should be inserted to the end. If false it's inserted to the start.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for adding text to all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.addText('123');\r\n   */\r\n  addText(text, end = true) {\r\n    return this.forEach((elem) => {\r\n      new Elem(nativeDocument.createTextNode(text)).into(elem, end);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#apply\r\n   * @public\r\n   * @param {...String} strings - Strings to apply.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method that is a shorthand for many other methods.\r\n   * All shorthands can be separated with space and written within one string.\r\n   *\r\n   * @example\r\n   * elem.apply(\r\n   *   '#id .c1 .c2 @border(1px solid black) $disabled $attr(some value) *(Click me!)'\r\n   * );\r\n   * // shorthand for\r\n   * // elem\r\n   * //   .id('id')\r\n   * //   .addClass('c1', 'c2')\r\n   * //   .css('border', '1px solid black')\r\n   * //   .attr({\r\n   * //     attr, 'some value'\r\n   * //     disabled: ''\r\n   * //   })\r\n   * //   .text('Click me!');\r\n   * // There is a full list of possible types of syntax below...\r\n   *\r\n   * elem.apply('#id');                    // shorthand for elem.id('id');\r\n   * elem.apply('.c1 .c2');                // shorthand for elem.addClass('c1', 'c2');\r\n   * elem.apply('-.c1 -.c2');              // shorthand for elem.removeClass('c1', 'c2');\r\n   * elem.apply('-@float -@display');      // shorthand for elem.removeCSS('float', 'display');\r\n   * elem.apply('-$a1 -$a2');              // shorthand for elem.removeAttr('a1', 'a2');\r\n   * elem.apply('*(some text)');           // shorthand for elem.text('some text');\r\n   * elem.apply('&(<div>1</div>)');        // shorthand for elem.html('<div>1</div>');\r\n   * elem.apply('@float(right)');          // shorthand for elem.css('float', 'right');\r\n   * elem.apply('@transform(scale(5px))'); // shorthand for elem.css('transform', 'scale(5px)');\r\n   * elem.apply('@margin(2px 2px)');       // shorthand for elem.css('margin', '2px 2px');\r\n   * elem.apply('@marginLeft(2px)');       // shorthand for elem.css('marginLeft', '2px 2px');\r\n   * elem.apply('@margin-left(2px)');      // shorthand for elem.css('margin-left', '2px 2px');\r\n   * elem.apply('$attr(some value)');      // shorthand for elem.attr('attr', 'some value');\r\n   * elem.apply('$attr');                  // shorthand for elem.attr('attr', '');\r\n   */\r\n  apply(...strings) {\r\n    let applied;\r\n    let setApplied;\r\n    let callback;\r\n    let name;\r\n    let np1;\r\n    let slice;\r\n\r\n    new Str(new Arr(arguments).join(' '))\r\n      .split(/(\\s+)/)\r\n      .forEach((string) => {\r\n        if (!applied) {\r\n          np1 = string.slice(0, 1);\r\n          callback = appliedRegExps[np1];\r\n          slice = 1;\r\n\r\n          if (callback && !isFunction(callback)) {\r\n            callback = callback[string.slice(1, 2)];\r\n            slice = 2;\r\n          }\r\n\r\n          if (/^\\s+$/.test(string) || !callback) {\r\n            return;\r\n          }\r\n\r\n          name = string.slice(slice).match(/^[^()]+/);\r\n\r\n          if (!name && (np1 !== '*' && np1 !== '&')) {\r\n            return;\r\n          }\r\n\r\n          applied = {\r\n            name: name ? name[0] : '',\r\n            args: string.slice(slice + (name ? name[0] : '').length),\r\n            callback\r\n          };\r\n\r\n          setApplied = true;\r\n        }\r\n\r\n        if (!setApplied) {\r\n          applied.args += string;\r\n        }\r\n\r\n        if (!applied.args || /^\\([\\s\\S]+\\)$/.test(applied.args)) {\r\n          applied.callback(this, applied.name, applied.args.replace(/^\\(|\\)$/g, ''));\r\n          applied = null;\r\n        }\r\n\r\n        setApplied = false;\r\n      });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#attr\r\n   * @public\r\n   * @param {String|Object.<String, String|ElemValueCallback>} [attr] - Name of the attribute to get or\r\n   * an object of the format { [attrName]: value, ... } to set attributes.\r\n   * @param {String|ElemValueCallback} [value] - If the first argument is a string\r\n   * it should be a value to set for that attribute.\r\n   * @returns {Super|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\r\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\r\n   * returned otherwise returns this.\r\n   * @description Method for getting/setting attributes.\r\n   *\r\n   * @example\r\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\r\n   * elem.attr('attr1');           // 'value1'\r\n   * elem.attr({\r\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\r\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\r\n   * });                           // this returned\r\n   * elem.attr().$;                // { attr1: 'value3', attr2: 'value2' }\r\n   */\r\n  attr(attr, value) {\r\n    const elem = getElem(this);\r\n\r\n    if (!arguments.length) {\r\n      return new Super(elem.attributes).object((o, attr) => {\r\n        o[attr.name] = attr.value;\r\n      });\r\n    }\r\n\r\n    if (arguments.length <= 1 && isString(attr)) {\r\n      const ns = attrNSSwitcher(attr, [new Elem(elem)]);\r\n\r\n      return isNull(ns)\r\n        ? elem.getAttribute(attr)\r\n        : elem.getAttributeNS(ns, attr);\r\n    }\r\n\r\n    if (arguments.length >= 2) {\r\n      attr = { [attr]: value };\r\n    }\r\n\r\n    return this.forEach((elem, index) => {\r\n      if (!isElement(elem)) {\r\n        return;\r\n      }\r\n\r\n      new Super(attr).forEach((value, key) => {\r\n        if (isNil(value)) {\r\n          return new Elem(elem).removeAttr(key);\r\n        }\r\n\r\n        if (isFunction(value)) {\r\n          value = value(new Elem(elem).attr(key), elem, index);\r\n        }\r\n\r\n        if (isNil(value)) {\r\n          return new Elem(elem).removeAttr(key);\r\n        }\r\n\r\n        const ns = attrNSSwitcher(key, [new Elem(elem)]);\r\n\r\n        if (isNull(ns)) {\r\n          elem.setAttribute(key, value);\r\n        } else {\r\n          elem.setAttributeNS(ns, key, value);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#blob\r\n   * @public\r\n   * @param {Object} [options = {}] - Options that are passed into {@link blob}.\r\n   * @returns {Promise.<BlobObject>} New instance of promise.\r\n   * @description Returns a {@link BlobObject} Promise. Works with image or canvas first element.\r\n   *\r\n   * @example\r\n   * image.blob().then((blob) => console.log(blob));  // BlobObject\r\n   * canvas.blob().then((blob) => console.log(blob)); // BlobObject\r\n   */\r\n  blob(options = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      const elem = this.first();\r\n      const { name } = elem;\r\n\r\n      if (name !== 'img' && name !== 'canvas') {\r\n        reject(new Error('First element in the set isn\\'t an image or a canvas! (Elem#blob)'));\r\n      }\r\n\r\n      if (name === 'canvas') {\r\n        return resolve(elem);\r\n      }\r\n\r\n      elem\r\n        .load()\r\n        .then(() => {\r\n          if (elem.isBroken()) {\r\n            return reject(new Error('The image is broken! (Elem#blob)'));\r\n          }\r\n\r\n          const canvas = new Elem(nativeDocument).canvas();\r\n          const width = elem.width();\r\n          const height = elem.height();\r\n\r\n          canvas\r\n            .width(width)\r\n            .height(height)\r\n            .drawImage(elem.$[0], 0, 0);\r\n\r\n          resolve(canvas);\r\n        });\r\n    }).then((canvas) => {\r\n      const dataURL = canvas.dataURL();\r\n      const byteString = atob(dataURL.split(',')[1]);\r\n      const length = byteString.length;\r\n      const ab = new ArrayBuffer(length);\r\n      const ia = new Uint8Array(ab);\r\n\r\n      times(length, (i) => {\r\n        ia[i] = byteString.charCodeAt(i);\r\n      });\r\n\r\n      return blob(ab, options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#blur\r\n   * @returns {Elem} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur\r\n   * @description Synonym for\r\n   * [HTMLElement#blur]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/blur}.\r\n   */\r\n  blur() {\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.blur();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#calcCSS\r\n   * @param {String} [pseudo] - See the link.\r\n   * @returns {CSSStyleDeclaration} See the link.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle\r\n   * @description Synonym for\r\n   * [getComputedStyle]{@link https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle}.\r\n   * Returns computed style for the first element in the set or undefined.\r\n   */\r\n  calcCSS(pseudo = null) {\r\n    return getComputedStyle(getElem(this), pseudo);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#changeRule\r\n   * @public\r\n   * @param {String} name - Name of the rule.\r\n   * @param {Object.<String, String>} style - Style for the selector.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for changing css styles in the first style tag in the set.\r\n   * Note: style element should be inside the document.\r\n   *\r\n   * @example\r\n   * style.changeRule('img-size', {\r\n   *   width: '50px !important',\r\n   *   height: '50px !important'\r\n   * });\r\n   */\r\n  changeRule(name, style) {\r\n    this.some((elem) => {\r\n      if (getName(elem) === 'style') {\r\n        const { value: rule } = new Arr(elem.sheet.cssRules).find((rule) => rule.dwayneData && rule.dwayneData.name === name) || {};\r\n\r\n        if (rule) {\r\n          new Elem(rule).css(style);\r\n\r\n          return true;\r\n        }\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#child\r\n   * @public\r\n   * @param {Number|String|Elem|Element|Element[]} element - If the argument is a number a wrap of the set of the children\r\n   * of this index of each element in the set returned otherwise an element to put into this element, a collection\r\n   * or a selector of it.\r\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\r\n   * @returns {Elem} Returns a wrap of children or inserted elements.\r\n   * @description Method is similar to\r\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\r\n   *\r\n   * @example\r\n   * const child = elem.child(1);\r\n   *\r\n   * elem.child(elem2);\r\n   * elem.child(document.getElementById('id'));\r\n   * elem.child('#id div.c1');\r\n   */\r\n  child(element, end = true) {\r\n    if (isInteger(element) && element >= 0) {\r\n      return this.children().elem(element);\r\n    }\r\n\r\n    return toFind(element).into(this, end);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#children\r\n   * @public\r\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\r\n   * @description Method for getting element's children.\r\n   *\r\n   * @example\r\n   * const children = elem.children();\r\n   */\r\n  children() {\r\n    return new Elem(this.length ? this.$[0].childNodes : []);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#class\r\n   * @public\r\n   * @param {String} [cls] - If it's present it has to contain class attribute to set.\r\n   * @returns {Arr|Elem} If the argument is present this returned otherwise a wrap of the classes array returned.\r\n   * @description Method for getting/setting classes.\r\n   *\r\n   * @example\r\n   * elem.class('c1 c2'); // class set to 'c1 c2'\r\n   * elem.class().$;      // ['c1', 'c2']\r\n   */\r\n  class(cls) {\r\n    if (!arguments.length) {\r\n      return new Arr(getElem(this).className.split(' '));\r\n    }\r\n\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.className = cls;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#click\r\n   * @returns {Elem} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click\r\n   * @description Synonym for\r\n   * [HTMLElement#click]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/click}.\r\n   */\r\n  click() {\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.click();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#clone\r\n   * @public\r\n   * @param {Boolean|*} [deep = false] - See thee link.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode\r\n   * @description Synonym for\r\n   * [Node#cloneNode]{@link https://developer.mozilla.org/en/docs/Web/API/Node/cloneNode}.\r\n   */\r\n  clone(deep = false) {\r\n    return this.object((elems, elem) => {\r\n      elems.add(elem.cloneNode(!!deep));\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#closest\r\n   * @public\r\n   * @param {String} selector - See the link.\r\n   * @returns {Elem} Set of the closest elements.\r\n   * @description Synonym for\r\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\r\n   */\r\n  closest(selector) {\r\n    return this.object((elems, elem) => {\r\n      while (elem) {\r\n        if (new Elem(elem).is(selector)) {\r\n          return elems.add(elem);\r\n        }\r\n\r\n        elem = elem.parentNode;\r\n      }\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#contains\r\n   * @public\r\n   * @param {String|Elem|Element} element - Element to find out if it's within the first element\r\n   * in the set or a selector of it.\r\n   * @returns {Boolean} Returns if the argument within this element.\r\n   * @description Method is extension for\r\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\r\n   *\r\n   * @example\r\n   * elem1.contains(elem2);   // true|false\r\n   * elem.contains(selector); // true|false\r\n   */\r\n  contains(element) {\r\n    element = toFind(element);\r\n\r\n    return getElem(this).contains(getElem(element));\r\n  }\r\n\r\n  /**\r\n   * @method Elem#create\r\n   * @public\r\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\r\n   * If type is \"#comment\" a comment node is created.\r\n   * @param {...String} appliedExpressions - Strings that are passed into {@link Elem#apply}.\r\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\r\n   * @description Method for creating elements inside this element.\r\n   * If this element is not an Element the element is just created.\r\n   *\r\n   * @example\r\n   * elem.create('div', '#id .c1 .c2 *Some text*');\r\n   *\r\n   * // also there are shorthands for almost every HTML-element\r\n   * elem.div();\r\n   * elem.input('$type(checkbox) $name(country)');\r\n   */\r\n  create(type, ...appliedExpressions) {\r\n    return this.object((elems, elem) => {\r\n      const element = new Elem(typeSwitcher(type, [new Elem(elem)]));\r\n\r\n      element.into(elem);\r\n\r\n      elems.add(element.apply.apply(element, appliedExpressions));\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#createComment\r\n   * @public\r\n   * @param {String} text - Text of the comment.\r\n   * @returns {Elem} New instance of Elem - wrap of the created comments.\r\n   * @description Method for creating comments inside this element.\r\n   * If this element is not an Element the comment is just created.\r\n   *\r\n   * @example\r\n   * elem.createComment('comment');\r\n   */\r\n  createComment(text) {\r\n    return this\r\n      .create('#comment')\r\n      .text(text);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#createText\r\n   * @public\r\n   * @param {String} text - Text.\r\n   * @returns {Elem} New instance of Elem - wrap of the created text nodes.\r\n   * @description Method for creating text nodes inside this element.\r\n   * If this element is not an Element the text node is just created.\r\n   *\r\n   * @example\r\n   * elem.createText('text');\r\n   */\r\n  createText(text) {\r\n    return this\r\n      .create('#text')\r\n      .text(text);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#css\r\n   * @public\r\n   * @param {String|Object.<String, String|ElemValueCallback>} [property] - Name of the property to get or\r\n   * an object of the format { [property]: value, ... } to set styles.\r\n   * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that property.\r\n   * @returns {Super|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\r\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\r\n   * @description Method for getting/setting styles. Supports !important.\r\n   *\r\n   * @example\r\n   * elem.css('display', 'none'); // display set to 'none' and this returned\r\n   * elem.css('display');         // 'none'\r\n   * elem.css({\r\n   *   display: 'inline',         // display set to 'inline'\r\n   *   cursor: 'pointer'          // cursor set to 'pointer'\r\n   * });                          // this returned\r\n   * elem.css().$;                // { display: 'none', cursor: 'pointer' }\r\n   */\r\n  css(property, value) {\r\n    let style = getElem(this).style;\r\n\r\n    if (isStyleRule(this.$[0])) {\r\n      style = this.$[0].style;\r\n    }\r\n\r\n    if (!arguments.length) {\r\n      return new Str(style.cssText)\r\n        .split(/; ?/)\r\n        .object((o, value) => {\r\n          if (value) {\r\n            property = value.split(/: /);\r\n\r\n            o[new Str(property[0]).toCamelCase().$] = property[1];\r\n          }\r\n        });\r\n    }\r\n\r\n    if (arguments.length <= 1 && isString(property)) {\r\n      property = new Str(property).toHyphenCase().$;\r\n\r\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\r\n    }\r\n\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: value };\r\n    }\r\n\r\n    return this.forEach((elem, index) => {\r\n      if (!isElement(elem) && !isStyleRule(elem)) {\r\n        return;\r\n      }\r\n\r\n      new Super(property).forEach((value, property) => {\r\n        if (isNil(value)) {\r\n          return new Elem(elem).removeCSS(property);\r\n        }\r\n\r\n        property = new Str(property).toHyphenCase().$;\r\n\r\n        if (isFunction(value)) {\r\n          value = value(new Elem(elem).css(property), elem, index);\r\n        }\r\n\r\n        if (isNil(value)) {\r\n          return new Elem(elem).removeAttr(key);\r\n        }\r\n\r\n        elem.style.removeProperty(property);\r\n        elem.style.setProperty(\r\n          property,\r\n          value.replace(/ ?!important$/, ''),\r\n          /!important$/.test(value) ? 'important' : ''\r\n        );\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#ctx\r\n   * @public\r\n   * @param {String|Object|CtxCallback} [property] - If present and object\r\n   * it's assigned to the canvas rendering context, if function\r\n   * it's called with canvas rendering context argument, if string\r\n   * the value from the second argument is used for assigning\r\n   * this property to canvas rendering context and if not present\r\n   * canvas rendering context returned.\r\n   * @param {*} [value] - See the property argument.\r\n   * @returns {CanvasRenderingContext2D|Elem}\r\n   * @description Rendering context of the first canvas in the set.\r\n   *\r\n   * @example\r\n   * canvas.ctx; // CanvasRenderingContext2D\r\n   */\r\n  ctx(property, value) {\r\n    let ctx;\r\n\r\n    this.some((elem) => {\r\n      if (getName(elem) === 'canvas') {\r\n        ctx = elem.dwayneData.ctx;\r\n\r\n        return true;\r\n      }\r\n    });\r\n\r\n    if (!arguments.length) {\r\n      return ctx;\r\n    }\r\n\r\n    if (!ctx) {\r\n      return this;\r\n    }\r\n\r\n    if (isFunction(property)) {\r\n      property(ctx);\r\n    } else {\r\n      if (arguments.length >= 2) {\r\n        property = { [property]: value };\r\n      }\r\n\r\n      assign(ctx, property);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#data\r\n   * @public\r\n   * @param {String|Object.<String, String|ElemValueCallback>} [key] - Name of the data attribute (without data- prefix)\r\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\r\n   * @param {String|ElemValueCallback} [value] - If the first argument is a string it should be a value to set for that attribute.\r\n   * @returns {Super|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\r\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\r\n   * @description Method for getting/setting data attributes. See\r\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\r\n   *\r\n   * @example\r\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\r\n   * elem.data('someKey1');          // 'value1'\r\n   * elem.data({\r\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\r\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\r\n   * });                             // this returned\r\n   * elem.data().$;                  // { someKey1: 'value3', someKey2: 'value2' }\r\n   */\r\n  data(key, value) {\r\n    const dataset = getElem(this).dataset;\r\n\r\n    if (!arguments.length) {\r\n      return new Super(dataset).object((o, value, key) => {\r\n        o[key] = value;\r\n      });\r\n    }\r\n\r\n    if (arguments.length === 1 && isString(key)) {\r\n      return dataset[key];\r\n    }\r\n\r\n    if (arguments.length >= 2) {\r\n      key = { [key]: value };\r\n    }\r\n\r\n    return this.forEach((elem, index) => {\r\n      if (!isElement(elem)) {\r\n        return;\r\n      }\r\n\r\n      iterate(key, (value, key) => {\r\n        elem.dataset[key] = isFunction(value) ? value(elem.dataset[key], elem, index) : value;\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#dataURL\r\n   * @param {String} [type = 'image/png'] - See the link\r\n   * @param {Number} [encoderOptions = 0.92] - See the link.\r\n   * @returns {String} Data URL for the first canvas element in the set.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL\r\n   * @description Synonym for\r\n   * [HTMLCanvasElement#toDataURL]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/toDataURL}.\r\n   *\r\n   * @example\r\n   * canvas.dataURL();\r\n   */\r\n  dataURL(type, encoderOptions) {\r\n    const ctx = this.ctx();\r\n\r\n    if (!ctx) {\r\n      return '';\r\n    }\r\n\r\n    return ctx.canvas.toDataURL.apply(ctx.canvas, arguments);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#deleteRule\r\n   * @public\r\n   * @param {String} name - Name of the rule.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for deleting css styles in a style tag.\r\n   * Note: style element should be inside the document.\r\n   *\r\n   * @example\r\n   * style.deleteRule('img-size');\r\n   */\r\n  deleteRule(name) {\r\n    this.some((elem) => {\r\n      if (getName(elem) === 'style') {\r\n        const rule = new Arr(elem.sheet.cssRules).find((rule) => rule.dwayneData && rule.dwayneData.name === name);\r\n\r\n        if (rule) {\r\n          elem.sheet.deleteRule(rule.key);\r\n\r\n          return true;\r\n        }\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#dispatch\r\n   * @public\r\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\r\n   * @param {Object} [eventInit = {}] - See the link.\r\n   * @param {Boolean} [eventInit.bubbles = true] - See the link.\r\n   * @param {Boolean} [eventInit.cancelable = true] - See the link.\r\n   * @param {Object} [details = {}] - Object that is assigned to the event.\r\n   * @returns {Elem} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\r\n   * @description Synonym for\r\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\r\n   *\r\n   * @example\r\n   * elem.dispatch('click');\r\n   * elem.dispatch('click', { bubbles: false, cancellable: false });\r\n   * elem.dispatch(new CustomEvent('custom-event'));\r\n   */\r\n  dispatch(event, eventInit = {}, details = {}) {\r\n    const { bubbles = true, cancelable = true } = eventInit || {};\r\n    let finalEvent = event;\r\n\r\n    if (!/Event$/.test(toStringTag(finalEvent))) {\r\n      try {\r\n        finalEvent = new Event(finalEvent, { bubbles, cancelable });\r\n      } catch (err) {\r\n        finalEvent = nativeDocument.createEvent('Event');\r\n        finalEvent.initEvent(event, bubbles, cancelable);\r\n      }\r\n\r\n      assign(finalEvent, details);\r\n    }\r\n\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.dispatchEvent(finalEvent);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#elem\r\n   * @public\r\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\r\n   * @returns {Elem} New instance of Elem.\r\n   *\r\n   * @example\r\n   * elem.elem(1); // a wrap of the element in the set that has index 1\r\n   * elem.elem();  // a wrap of the element in the set that has index 0\r\n   */\r\n  elem(index = 0) {\r\n    if (index < 0) {\r\n      index = this.length + index;\r\n    }\r\n\r\n    return new Elem(this.$[index]);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#filter\r\n   * @public\r\n   * @param {String|Function|Element[]|Elem} [selector = Boolean] - If it's a string the method filters elements with the selector\r\n   * otherwise super.filter is called.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Method for filtering elements.\r\n   *\r\n   * @example\r\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\r\n   * elem.filter(elemsInArray);\r\n   * elem.filter(elemsInElem);\r\n   * elem.filter('.child');\r\n   */\r\n  filter(selector = Boolean) {\r\n    return new Elem(super.filter(filterSwitcher(selector)));\r\n  }\r\n\r\n  /**\r\n   * @method Elem#find\r\n   * @public\r\n   * @param {String|Function} selector - Selector to find.\r\n   * @returns {Elem|{ key: Key, value: * }|null} New instance of Elem if selector is a string\r\n   * otherwise super.find is called.\r\n   * @description Synonym for\r\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\r\n   */\r\n  find(selector) {\r\n    if (!isString(selector)) {\r\n      return super.find(selector);\r\n    }\r\n\r\n    return this.object((elems, elem) => {\r\n      elems.add(find(selector, elem));\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#first\r\n   * @public\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Synonym for elem.elem(0).\r\n   */\r\n  first() {\r\n    return this.elem(0);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#firstChild\r\n   * @public\r\n   * @param {String} [selector = null] - If present, finds first child in every elem that matches the selector.\r\n   * If not, finds first child of each element in the set.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Method for finding first children of each element in the set.\r\n   *\r\n   * @example\r\n   * elem.first();       // finds first child of each element in the elem set\r\n   * elem.first('.foo'); // find first child that has foo class of each element in the set\r\n   */\r\n  firstChild(selector = null) {\r\n    return this.object((elems, elem) => {\r\n      const { value: found } = new Elem(elem)\r\n        .children()\r\n        .find((elem) => new Elem(elem).is(selector)) || {};\r\n\r\n      elems.add(found);\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#focus\r\n   * @returns {Elem} Returns this.\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus\r\n   * @description Synonym for\r\n   * [HTMLElement#focus]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/focus}.\r\n   */\r\n  focus() {\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.focus();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#getRule\r\n   * @public\r\n   * @param {String} name - Name of the rule.\r\n   * @returns {{ selector: (String|void), rules: Object }} Set of the css rules.\r\n   * @description Method for getting set of the rules under the name.\r\n   * Note: style element should be inside the document.\r\n   *\r\n   * @example\r\n   * style.addRule('img-size', 'img.square', {\r\n   *   width: '40px',\r\n   *   height: '40px'\r\n   * });\r\n   * style.getRule('img-size');\r\n   * // {\r\n   * //   selector: 'img.square',\r\n   * //   rules: {\r\n   * //     width: '40px',\r\n   * //     height: '40px'\r\n   * //   }\r\n   * // }\r\n   */\r\n  getRule(name) {\r\n    let found = {\r\n      selector: undefined,\r\n      rules: {}\r\n    };\r\n\r\n    this.some((elem) => {\r\n      if (getName(elem) === 'style') {\r\n        const { value: rule } = new Arr(elem.sheet.cssRules).find((rule) => rule.dwayneData && rule.dwayneData.name === name) || {};\r\n\r\n        if (rule) {\r\n          found = {\r\n            selector: rule.selectorText,\r\n            rules: new Elem(rule).css().$\r\n          };\r\n\r\n          return true;\r\n        }\r\n      }\r\n    });\r\n\r\n    return found;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#hasAttr\r\n   * @public\r\n   * @param {String} attr - Name of the attribute.\r\n   * @returns {Boolean} If the first element in the set has the attribute.\r\n   * @description Method that returns if the first element in the set has the attribute or not.\r\n   *\r\n   * @example\r\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\r\n   * elem.removeAttr('attr').hasAttr('attr');    // false\r\n   */\r\n  hasAttr(attr) {\r\n    const elem = getElem(this);\r\n    const ns = attrNSSwitcher(attr, [new Elem(elem)]);\r\n\r\n    return isNull(ns)\r\n      ? elem.hasAttribute(attr)\r\n      : elem.hasAttributeNS(ns, attr);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#hasClass\r\n   * @public\r\n   * @param {String} cls - Name of the class.\r\n   * @returns {Boolean} If the first element in the set has the class.\r\n   * @description Method that returns if the first element in the set has the class or not.\r\n   *\r\n   * @example\r\n   * elem.addClass('cls').hasClass('cls');    // true\r\n   * elem.removeClass('cls').hasClass('cls'); // false\r\n   */\r\n  hasClass(cls) {\r\n    return getElem(this).classList.contains(cls);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#height\r\n   * @public\r\n   * @param {*|ElemValueCallback} [height] - Height to set.\r\n   * @returns {Elem|String} If no arguments passed height of the first element in the set returned.\r\n   * Otherwise all elements heights in the set are set to the height argument.\r\n   * @description Gets or sets height.\r\n   *\r\n   * @example\r\n   * elem.height(123);\r\n   * elem.height(); // 123\r\n   */\r\n  height(height) {\r\n    return this.prop.apply(this, new Arr(arguments).unshift('height').$);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#hide\r\n   * @public\r\n   * @returns {Elem} Returns this.\r\n   * @description Hides all elements in the set.\r\n   *\r\n   * @example\r\n   * elem.hide();\r\n   */\r\n  hide() {\r\n    return this.forEach((elem) => {\r\n      elem = new Elem(elem);\r\n\r\n      const currentDisplay = elem.css('display');\r\n\r\n      if (currentDisplay.indexOf('none')) {\r\n        elem.prop('dwayneData').previousDisplay = currentDisplay;\r\n      }\r\n\r\n      elem.css('display', 'none !important');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#html\r\n   * @public\r\n   * @param {String|ElemValueCallback|*} [html] - HTML to write instead of current HTML.\r\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\r\n   * Otherwise all elements HTML in the set are set to the html argument.\r\n   * @description Gets or sets HTML.\r\n   *\r\n   * @example\r\n   * elem.html('<div>1</div>');\r\n   * elem.html(); // '<div>1</div>'\r\n   */\r\n  html(html) {\r\n    if (!arguments.length) {\r\n      return getElem(this).innerHTML;\r\n    }\r\n\r\n    return this.forEach((elem, index) => {\r\n      if (isElement(elem)) {\r\n        elem.innerHTML = isFunction(html) ? html(elem.innerHTML, elem, index) : html;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#id\r\n   * @public\r\n   * @param {String|*} [id] - Id to set.\r\n   * @returns {Elem|String} If no arguments passed id of the first element in the set returned.\r\n   * Otherwise all elements ids in the set are set to the id argument.\r\n   * @description Gets id or sets ids.\r\n   *\r\n   * @example\r\n   * elem.id('unique');\r\n   * elem.id(); // 'unique'\r\n   */\r\n  id(id) {\r\n    if (!arguments.length) {\r\n      return getElem(this).id;\r\n    }\r\n\r\n    return this.forEach((elem) => {\r\n      if (isElement(elem)) {\r\n        elem.id = id;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @member {Number} Elem#innerHeight\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description Getter for finding how much height content of the first element can be.\r\n   *\r\n   * @example\r\n   * elem.css({\r\n   *   boxSizing: 'border-box',\r\n   *   height: '200px',\r\n   *   paddingTop: '2px',\r\n   *   paddingBottom: '3px',\r\n   *   borderTop: '1px solid black',\r\n   *   borderBottom: '4px solid black'\r\n   * }).innerHeight; // 190\r\n   * elem\r\n   *   .css('box-sizing', 'content-box')\r\n   *   .innerHeight; // 200\r\n   * elem\r\n   *   .css('box-sizing', 'padding-box')\r\n   *   .innerHeight; // 195\r\n   */\r\n  get innerHeight() {\r\n    const elem = this.$[0];\r\n\r\n    if (isWindow(elem)) {\r\n      return elem.innerHeight;\r\n    }\r\n\r\n    const {\r\n      borderTopWidth,\r\n      borderBottomWidth,\r\n      boxSizing,\r\n      height,\r\n      paddingTop,\r\n      paddingBottom\r\n    } = this.calcCSS();\r\n    const borders = px(borderTopWidth) + px(borderBottomWidth);\r\n    const paddings = px(paddingTop) + px(paddingBottom);\r\n\r\n    return px(height) - innerSwitcher(boxSizing, [paddings, borders]);\r\n  }\r\n\r\n  /**\r\n   * @member {Number} Elem#innerWidth\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description Getter for finding how much width content of the first element can be.\r\n   *\r\n   * @example\r\n   * elem.css({\r\n   *   boxSizing: 'border-box',\r\n   *   width: '200px',\r\n   *   paddingLeft: '2px',\r\n   *   paddingRight: '3px',\r\n   *   borderLeft: '1px solid black',\r\n   *   borderRight: '4px solid black'\r\n   * }).innerWidth; // 190\r\n   * elem\r\n   *   .css('box-sizing', 'content-box')\r\n   *   .innerWidth; // 200\r\n   * elem\r\n   *   .css('box-sizing', 'padding-box')\r\n   *   .innerWidth; // 195\r\n   */\r\n  get innerWidth() {\r\n    const elem = this.$[0];\r\n\r\n    if (isWindow(elem)) {\r\n      return elem.innerWidth;\r\n    }\r\n\r\n    const {\r\n      borderLeftWidth,\r\n      borderRightWidth,\r\n      boxSizing,\r\n      paddingLeft,\r\n      paddingRight,\r\n      width\r\n    } = this.calcCSS();\r\n    const borders = px(borderLeftWidth) + px(borderRightWidth);\r\n    const paddings = px(paddingLeft) + px(paddingRight);\r\n\r\n    return px(width) - innerSwitcher(boxSizing, [paddings, borders]);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#insertAfter\r\n   * @public\r\n   * @param {String|Elem|Element} element - Element to insert this element after or a selector of it.\r\n   * @returns {Elem} Returns this.\r\n   * @description Puts the elements from the set after the element specified by the argument.\r\n   * The elements remain in the same order.\r\n   *\r\n   * @example\r\n   * elem.insertAfter(elem2);\r\n   * elem.insertAfter(document.getElementById('id'));\r\n   * elem.insertAfter('#id div.c1');\r\n   */\r\n  insertAfter(element) {\r\n    element = toFind(element).first();\r\n\r\n    let parent = element.parent();\r\n\r\n    if (!parent.length) {\r\n      return this;\r\n    }\r\n\r\n    element = element.next().$[0];\r\n    parent = parent.$[0];\r\n\r\n    return this.forEach((elem) => {\r\n      if (element) {\r\n        parent.insertBefore(elem, element);\r\n      } else {\r\n        parent.appendChild(elem);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#insertBefore\r\n   * @public\r\n   * @param {String|Elem|Element} element - Element to insert this element before or a selector of it.\r\n   * @returns {Elem} Returns this.\r\n   * @description Puts the elements from the set before the element specified by the argument.\r\n   * The elements remain in the same order.\r\n   *\r\n   * @example\r\n   * elem.insertBefore(elem2);\r\n   * elem.insertBefore(document.getElementById('id'));\r\n   * elem.insertBefore('#id div.c1');\r\n   */\r\n  insertBefore(element) {\r\n    element = toFind(element).first();\r\n\r\n    let parent = element.parent();\r\n\r\n    if (!parent.length) {\r\n      return this;\r\n    }\r\n\r\n    element = element.$[0];\r\n    parent = parent.$[0];\r\n\r\n    return this.forEach((elem) => {\r\n      parent.insertBefore(elem, element);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#into\r\n   * @public\r\n   * @param {String|Elem|Element} element - Element to put this elements into or a selector of it.\r\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method is similar to\r\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\r\n   *\r\n   * @example\r\n   * elem.into(elem2);\r\n   * elem.into(document.getElementById('id'));\r\n   * elem.into('#id div.c1');\r\n   */\r\n  into(element, end = true) {\r\n    element = toFind(element).$[0];\r\n\r\n    if (\r\n      !element ||\r\n      isWindow(element) ||\r\n      isHTMLDocument(element) ||\r\n      isCommentOrText(element)\r\n    ) {\r\n      return this;\r\n    }\r\n\r\n    if (!end && element.firstChild) {\r\n      return this\r\n        .slice()\r\n        .reverse()\r\n        .forEach((elem) => {\r\n          element.insertBefore(elem, element.firstChild);\r\n        });\r\n    }\r\n\r\n    return this.forEach((elem) => {\r\n      element.appendChild(elem);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#is\r\n   * @public\r\n   * @param {String} selector\r\n   * @returns {Boolean} If the first element in the set matches the selector.\r\n   * If the selector is undefined or null always returns true. If it's not for not elements\r\n   * entries returns false.\r\n   * @description Synonym for\r\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\r\n   *\r\n   * @example\r\n   * elem.addClass('cls');\r\n   * elem.is('.cls');         // true\r\n   *\r\n   * elem.removeClass('cls');\r\n   * elem.is('.cls');         // false\r\n   */\r\n  is(selector) {\r\n    if (isNull(selector)) {\r\n      return true;\r\n    }\r\n\r\n    const elem = getElem(this);\r\n    const matches = (\r\n      elem.matches ||\r\n      elem.matchesSelector ||\r\n      elem.webkitMatchesSelector ||\r\n      elem.mozMatchesSelector ||\r\n      elem.msMatchesSelector ||\r\n      elem.oMatchesSelector\r\n    );\r\n\r\n    if (!isElement(this.$[0])) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      return matches.call(elem, selector);\r\n    } catch (err) {\r\n      console.error(`Selector '${ selector }' is not a valid selector (Elem#is)`);\r\n\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @method Elem#isBroken\r\n   * @public\r\n   * @returns {Boolean} If the first image in the set is broken.\r\n   * @description Returns if the first element in the set is broken. Not image and not loaded image is considered proper.\r\n   *\r\n   * @example\r\n   * const img = elem.img().on({\r\n   *   'load': onload,\r\n   *   'error': onload\r\n   * });\r\n   *\r\n   * onload = () => {\r\n   *   console.log(img.isBroken()); // true\r\n   * };\r\n   *\r\n   * img.ref('/some/non-existent/site/not-found.png');\r\n   */\r\n  isBroken() {\r\n    let isBroken = false;\r\n\r\n    this.some((elem) => {\r\n      if (getName(elem) === 'img') {\r\n        isBroken = !!(elem.complete && (!elem.naturalWidth || !elem.naturalHeight));\r\n\r\n        return true;\r\n      }\r\n    });\r\n\r\n    return isBroken;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#isWithinDocument\r\n   * @public\r\n   * @returns {Boolean} Returns if the first element in the set is within the document or not.\r\n   * @description Returns if the first element in the set is within the document or not.\r\n   *\r\n   * @example\r\n   * new Elem(document.body).isWithinDocument();  // true\r\n   * new Elem(document).div().isWithinDocument(); // false\r\n   */\r\n  isWithinDocument() {\r\n    return this.first().closest('html').length !== 0;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#last\r\n   * @public\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Synonym for elem.elem(-1).\r\n   */\r\n  last() {\r\n    return this.elem(-1);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#lastChild\r\n   * @public\r\n   * @param {String} [selector = null] - If present, finds last child in every elem that matches the selector.\r\n   * If not, finds last child of each element in the set.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Method for finding last children of each element in the set.\r\n   *\r\n   * @example\r\n   * elem.last();       // finds last child of each element in the elem set\r\n   * elem.last('.foo'); // find last child that has 'foo' class of each element in the set\r\n   */\r\n  lastChild(selector = null) {\r\n    return this.object((elems, elem) => {\r\n      const { value: found } = new Elem(elem)\r\n        .children()\r\n        .reverse()\r\n        .find((elem) => new Elem(elem).is(selector)) || {};\r\n\r\n      elems.add(found);\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#load\r\n   * @public\r\n   * @returns {Promise.<{ proper: Elem, broken: Elem }>} Promise with broken and proper images.\r\n   * @description Loads each image in the set and puts it to the proper or broken array.\r\n   *\r\n   * @example\r\n   * images.load().then(({ broken }) => {\r\n   *   broken.filter('img').ref('/fallback.png');\r\n   * });\r\n   */\r\n  load() {\r\n    const images = {\r\n      proper: new Elem(),\r\n      broken: new Elem()\r\n    };\r\n\r\n    return Promise.all(\r\n      this\r\n        .filter((elem) => getName(elem) === 'img')\r\n        .map((elem) => {\r\n          const $elem = new Elem(elem);\r\n\r\n          if (elem.complete) {\r\n            images[$elem.isBroken() ? 'broken' : 'proper'].push(elem);\r\n\r\n            return;\r\n          }\r\n\r\n          return new Promise((resolve) => {\r\n            const removeListeners = $elem.on({\r\n              load() {\r\n                images.proper.add(elem);\r\n\r\n                removeListeners();\r\n                resolve();\r\n              },\r\n              error() {\r\n                images.broken.add(elem);\r\n\r\n                removeListeners();\r\n                resolve();\r\n              }\r\n            });\r\n          });\r\n        })\r\n        .$\r\n    ).then(() => images);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#moveAttr\r\n   * @public\r\n   * @param {String} attr - Attribute to move to the first element.\r\n   * @param {String} [value = ''] - Value to set for the attribute. If not set attribute of the previous element or '' used.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for moving an attribute from previous element to the next one (first element in this set).\r\n   *\r\n   * @example\r\n   * elem1.moveAttr('attr', 'value');     // attribute 'attr' set to 'value' on elem1\r\n   * elem2.moveAttr('attr');              // attribute 'attr' removed from elem1. set to 'value' on elem2\r\n   * elem3.moveAttr('attr', 'new value'); // attribute 'attr' removed from elem2. set to 'new value' on elem3\r\n   */\r\n  moveAttr(attr, value = '') {\r\n    const prev = attrs[attr];\r\n    const elem = this.elem();\r\n\r\n    if (prev && elem.length) {\r\n      if (arguments.length < 2) {\r\n        value = prev.attr(attr);\r\n      }\r\n\r\n      prev.removeAttr(attr);\r\n    }\r\n\r\n    if (elem.length) {\r\n      attrs[attr] = elem.attr(attr, value);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#moveClass\r\n   * @public\r\n   * @param {String} cls - Class to move to the first element.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for moving a class from previous element to the next one (first element in this set).\r\n   *\r\n   * @example\r\n   * elem1.moveClass('cls'); // class 'cls' added to elem1\r\n   * elem2.moveClass('cls'); // class 'cls' removed from elem1. added to elem1\r\n   */\r\n  moveClass(cls) {\r\n    const prev = classes[cls];\r\n    const elem = this.elem();\r\n\r\n    if (prev && elem.length) {\r\n      prev.removeClass(cls);\r\n    }\r\n\r\n    if (elem.length) {\r\n      classes[cls] = elem.addClass(cls);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @member {String} Elem#name\r\n   * @type {String}\r\n   * @public\r\n   * @readonly\r\n   * @description nodeName (lowercased) of the first element in the set.\r\n   *\r\n   * @example\r\n   * const elem1 = elem.create('div');\r\n   * elem1.name // 'div'\r\n   */\r\n  get name() {\r\n    return getName(this.$[0]);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#next\r\n   * @public\r\n   * @param {String} [selector = null] - If present, finds next element to every elem that matches the selector.\r\n   * If not, finds next element to each element in the set.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Method for finding next element to each element in the set.\r\n   *\r\n   * @example\r\n   * elem.next();       // finds next element to each element in the set\r\n   * elem.next('.foo'); // finds next element to each element that has 'foo' class\r\n   */\r\n  next(selector = null) {\r\n    return this.object((elems, elem) => {\r\n      /* eslint no-cond-assign: 0 */\r\n      while (elem = elem.nextSibling) {\r\n        if (new Elem(elem).is(selector)) {\r\n          return elems.add(elem);\r\n        }\r\n      }\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#off\r\n   * @public\r\n   * @param {...ElemEventString} events - Events to remove.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method that removes all the listeners from each element in the set specified by the events arguments.\r\n   *\r\n   * @example\r\n   * elem.off('click');\r\n   * elem.off('click, input');\r\n   * elem.off('click, input', 'focus');\r\n   */\r\n  off(...events) {\r\n    return this.forEach((elem) => {\r\n      const { listeners } = elem.dwayneData;\r\n\r\n      iterate(arguments, (event) => {\r\n        iterate(event.split(eventSeparator), (event) => {\r\n          (listeners[event] || new Super()).forEach(({ removeListener }) => removeListener());\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#on\r\n   * @public\r\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\r\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\r\n   * @param {String} [selector = null] - Selector to filter event targets.\r\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\r\n   * specified event(s).\r\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\r\n   * @description Adds event listeners for all the elements in the set.\r\n   * For debugging: If you need to know what listeners are in work (and what selectors filter targets)\r\n   * you can look at the base property of the only dwayne listener that listens for the event\r\n   * and find all working listeners in listener.base.dwayneData.listeners[event].$.\r\n   *\r\n   * @example\r\n   * elem.on(\r\n   *   'change, input',\r\n   *   'input, select, textarea, datalist, keygen, output',\r\n   *   (e, elem, index) => console.log(elem.value)\r\n   * );\r\n   * elem.on(\r\n   *   'change, input',\r\n   *   (e, elem, index) => console.log(elem.value)\r\n   * );\r\n   * elem.on(\r\n   *   {\r\n   *     'change, input': (e, elem, index) => console.log(elem.value),\r\n   *     'blur': () => console.log('blur')\r\n   *   },\r\n   *   'input, select, textarea, datalist, keygen, output'\r\n   * );\r\n   *\r\n   * const removeListeners = elem.on({\r\n   *   'change, input': (e, elem, index) => console.log(elem.value),\r\n   *   'blur': () => console.log('blur')\r\n   * });\r\n   *\r\n   * removeListeners('click');\r\n   * removeListeners('blur, change');\r\n   * removeListeners('blur, change', 'input');\r\n   * removeListeners();\r\n   */\r\n  on(event, selector = null, listener) {\r\n    const allListeners = new Super({});\r\n\r\n    if (isFunction(selector)) {\r\n      listener = selector;\r\n      selector = null;\r\n    }\r\n\r\n    if (isString(event)) {\r\n      event = { [event]: listener };\r\n    }\r\n\r\n    event = new Super(event).object((listeners, listener, event) => {\r\n      iterate(event.split(eventSeparator), (event) => {\r\n        listeners[event] = listener;\r\n      });\r\n    });\r\n\r\n    this.forEach((elem) => {\r\n      if (!isElement(elem) && !isWindow(elem) && !isHTMLDocument(elem)) {\r\n        return;\r\n      }\r\n\r\n      const { listeners } = (windowsDwayneData.find(({ element }) => element === elem) || {}).value || elem.dwayneData;\r\n\r\n      event.forEach((listener, event) => {\r\n        const removeEventListeners = listeners[event] = listeners[event] || new Super({}).define('index', {\r\n          value: 0,\r\n          configurable: true,\r\n          writable: true\r\n        });\r\n        const index = removeEventListeners.prop('index');\r\n\r\n        if (!removeEventListeners.has('listener')) {\r\n          const newListener = (e) => {\r\n            removeEventListeners.forEach(({ selector, listener }) => {\r\n              if (new Elem(e.target).is(selector)) {\r\n                listener.call(elem, e, elem, index);\r\n              }\r\n            });\r\n          };\r\n\r\n          newListener.base = elem;\r\n\r\n          elem.addEventListener(event, newListener, false);\r\n          removeEventListeners.define('listener', {\r\n            value: newListener,\r\n            configurable: true,\r\n            writable: true\r\n          });\r\n        }\r\n\r\n        const removeListener = () => {\r\n          removeEventListeners.delete(index);\r\n\r\n          if (!removeEventListeners.count) {\r\n            elem.removeEventListener(event, removeEventListeners.prop('listener'), false);\r\n            removeEventListeners.delete('listener');\r\n          }\r\n        };\r\n\r\n        allListeners.prop(event, (allListeners.prop(event) || new Arr()).push(removeListener));\r\n\r\n        removeEventListeners.assign({\r\n          index: index + 1,\r\n          [index]: {\r\n            selector,\r\n            listener,\r\n            removeListener\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return function removeEventListeners(event) {\r\n      if (arguments.length) {\r\n        iterate(arguments, (event) => {\r\n          iterate(event.split(eventSeparator), (event) => {\r\n            if (allListeners.has(event)) {\r\n              allListeners.prop(event).forEach((removeListener) => removeListener());\r\n              allListeners.delete(event);\r\n            }\r\n          });\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      allListeners.forEach((removeListeners) => {\r\n        removeListeners.forEach((removeListener) => removeListener());\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @member {Number} Elem#outerHeight\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description Getter for finding how much height the element actually is.\r\n   *\r\n   * @example\r\n   * elem.css({\r\n   *   boxSizing: 'border-box',\r\n   *   height: '200px',\r\n   *   paddingTop: '2px',\r\n   *   paddingBottom: '3px',\r\n   *   borderTop: '1px solid black',\r\n   *   borderBottom: '4px solid black'\r\n   *   marginTop: '0px',\r\n   *   marginBottom: '5px'\r\n   * }).outerHeight; // 205\r\n   * elem\r\n   *   .css('box-sizing', 'content-box')\r\n   *   .outerHeight; // 215\r\n   * elem\r\n   *   .css('box-sizing', 'padding-box')\r\n   *   .outerHeight; // 210\r\n   */\r\n  get outerHeight() {\r\n    const elem = this.$[0];\r\n\r\n    if (isWindow(elem)) {\r\n      return elem.outerHeight;\r\n    }\r\n\r\n    const {\r\n      borderTopWidth,\r\n      borderBottomWidth,\r\n      boxSizing,\r\n      height,\r\n      marginTop,\r\n      marginBottom,\r\n      paddingTop,\r\n      paddingBottom\r\n    } = this.calcCSS();\r\n    const borders = px(borderTopWidth) + px(borderBottomWidth);\r\n    const paddings = px(paddingTop) + px(paddingBottom);\r\n\r\n    return px(height) + px(marginTop) + px(marginBottom) + outerSwitcher(boxSizing, [borders, paddings]);\r\n  }\r\n\r\n  /**\r\n   * @member {Number} Elem#outerWidth\r\n   * @type {Number}\r\n   * @public\r\n   * @readonly\r\n   * @description Getter for finding how much width the element actually is.\r\n   *\r\n   * @example\r\n   * elem.css({\r\n   *   boxSizing: 'border-box',\r\n   *   width: '200px',\r\n   *   paddingLeft: '2px',\r\n   *   paddingRight: '3px',\r\n   *   borderLeft: '1px solid black',\r\n   *   borderRight: '4px solid black'\r\n   *   marginLeft: '0px',\r\n   *   marginRight: '5px'\r\n   * }).outerWidth; // 205\r\n   * elem\r\n   *   .css('box-sizing', 'content-box')\r\n   *   .outerWidth; // 215\r\n   * elem\r\n   *   .css('box-sizing', 'padding-box')\r\n   *   .outerWidth; // 210\r\n   */\r\n  get outerWidth() {\r\n    const elem = this.$[0];\r\n\r\n    if (isWindow(elem)) {\r\n      return elem.outerWidth;\r\n    }\r\n\r\n    const {\r\n      borderLeftWidth,\r\n      borderRightWidth,\r\n      boxSizing,\r\n      marginLeft,\r\n      marginRight,\r\n      paddingLeft,\r\n      paddingRight,\r\n      width\r\n    } = this.calcCSS();\r\n    const borders = px(borderLeftWidth) + px(borderRightWidth);\r\n    const paddings = px(paddingLeft) + px(paddingRight);\r\n\r\n    return px(width) + px(marginLeft) + px(marginRight) + outerSwitcher(boxSizing, [borders, paddings]);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#parent\r\n   * @public\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\r\n   */\r\n  parent() {\r\n    return this.object((elems, elem) => elems.add(elem.parentNode), new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#parentTree\r\n   * @public\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Returns wrap of all parents of each element in the set.\r\n   *\r\n   * @example\r\n   * elem.parentTree(); // Elem\r\n   */\r\n  parentTree() {\r\n    return this.object((elems, elem) => {\r\n      while (elem = elem.parentNode) {\r\n        elems.add(elem);\r\n      }\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#prev\r\n   * @public\r\n   * @param {String} [selector = null] - If present, finds previous element to every elem that matches the selector.\r\n   * If not, finds previous element to each element in the set.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Method for finding previous element to each element in the set.\r\n   *\r\n   * @example\r\n   * elem.next();       // finds previous element to each element in the set\r\n   * elem.next('.foo'); // finds previous element to each element that has 'foo' class\r\n   */\r\n  prev(selector = null) {\r\n    return this.object((elems, elem) => {\r\n      /* eslint no-cond-assign: 0 */\r\n      while (elem = elem.previousSibling) {\r\n        if (new Elem(elem).is(selector)) {\r\n          return elems.add(elem);\r\n        }\r\n      }\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#prop\r\n   * @public\r\n   * @param {String|Object.<String, ElemValueCallback|*>} property - Either a string of a property or an assigned object.\r\n   * @param {ElemValueCallback|*} [value] - If a property parameter is a string\r\n   * this has to be an assigned value if it's present.\r\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\r\n   * @description Method that is either a property getter for the first element in the set\r\n   * or a setter for every element in the set.\r\n   *\r\n   * @example\r\n   * elem.prop('draggable', false);\r\n   * elem.prop('draggable'); // false\r\n   */\r\n  prop(property, value) {\r\n    if (arguments.length <= 1 && isString(property)) {\r\n      return this.$[0] ? this.$[0][property] : undefined;\r\n    }\r\n\r\n    if (arguments.length >= 2) {\r\n      property = { [property]: value };\r\n    }\r\n\r\n    return this.forEach((elem, index) => {\r\n      iterate(property, (value, prop) => {\r\n        elem[prop] = isFunction(value) ? value(elem[prop], elem, index) : value;\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#ref\r\n   * @public\r\n   * @param {String|ElemValueCallback} [link] - If it's present link to a resource.\r\n   * @returns {Elem|String} If the link argument isn't present it's a getter of the 'src' attribute\r\n   * for the one of following elements: img, script, iframe, audio, video; of the 'action' attribute\r\n   * for a form element and of the 'href' attribute for the rest. If it's present it's a setter\r\n   * of the same attribute for all the element in the set.\r\n   * @description Method for getting resources links and setting them.\r\n   *\r\n   * @example\r\n   * elem.ref('/some/cool/image.png');\r\n   * elem.ref(); // '/some/cool/image.png'\r\n   */\r\n  ref(link) {\r\n    if (!arguments.length) {\r\n      return this.attr(refSwitcher(this.name));\r\n    }\r\n\r\n    return this.forEach((elem) => {\r\n      elem = new Elem(elem);\r\n\r\n      elem.attr(refSwitcher(elem.name), link);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#remove\r\n   * @public\r\n   * @returns {Elem} Returns this.\r\n   * @description Removes all the elements from the set from the document.\r\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\r\n   *\r\n   * @example\r\n   * elem.remove();\r\n   */\r\n  remove() {\r\n    return this.forEach((elem) => {\r\n      const parent = elem.parentNode;\r\n\r\n      if (parent) {\r\n        parent.removeChild(elem);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#removeAttr\r\n   * @public\r\n   * @param {...String} attributes - Attributes to remove.\r\n   * @returns {Elem} Returns this.\r\n   * @description Removes all the attributes from arguments from all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.removeAttr('foo', 'bar', 'baz');\r\n   */\r\n  removeAttr(...attributes) {\r\n    return this.forEach((elem) => {\r\n      if (!isElement(elem)) {\r\n        return;\r\n      }\r\n\r\n      iterate(arguments, (attr) => {\r\n        const ns = attrNSSwitcher(attr, [new Elem(elem)]);\r\n\r\n        if (isNull(ns)) {\r\n          elem.removeAttribute(attr);\r\n        } else {\r\n          elem.removeAttributeNS(ns, attr);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#removeClass\r\n   * @public\r\n   * @param {...String} classes - Classes to remove.\r\n   * @returns {Elem} Returns this.\r\n   * @description Removes all the classes from arguments from all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.removeClass('foo', 'bar', 'baz');\r\n   */\r\n  removeClass(...classes) {\r\n    return this.forEach((elem) => {\r\n      const list = elem.classList;\r\n\r\n      iterate(isElement(elem) && arguments, (cls) => list.remove(cls));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#removeCSS\r\n   * @public\r\n   * @param {...String} props - CSS properties to remove.\r\n   * @returns {Elem} Returns this.\r\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\r\n   *\r\n   * @example\r\n   * elem.removeCSS('display', 'position', 'margin');\r\n   */\r\n  removeCSS(...props) {\r\n    return this.forEach((elem) => {\r\n      if (!isElement(elem)) {\r\n        return;\r\n      }\r\n\r\n      iterate(arguments, (css) => {\r\n        elem.style.removeProperty(css);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#replace\r\n   * @public\r\n   * @param {String|Elem|Element} element - Element to replace the first element in the set\r\n   * with a set of elements specified by the argument (Element, set of elements or a selector of them).\r\n   * @returns {Elem} Returns this.\r\n   * @description Method is similar to\r\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\r\n   *\r\n   * @example\r\n   * elem.replace(elem2);\r\n   * elem.replace(document.getElementById('id'));\r\n   * elem.replace('#id div.c1');\r\n   */\r\n  replace(element) {\r\n    element = toFind(element);\r\n\r\n    const parent = this.first().parent();\r\n\r\n    if (!parent.length) {\r\n      return this;\r\n    }\r\n\r\n    let elem = parent;\r\n    let method = 'into';\r\n    const next = this.next().first().$[0];\r\n    const prev = this.prev().first().$[0];\r\n\r\n    if (next) {\r\n      elem = next;\r\n      method = 'insertBefore';\r\n    } else if (prev) {\r\n      elem = prev;\r\n      method = 'insertAfter';\r\n    }\r\n\r\n    this.first().remove();\r\n\r\n    element[method](elem);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#setOf\r\n   * @public\r\n   * @param {String} type - HTML element type.\r\n   * @param {Number|Object|Array.<*>} iterator - A number (how many elements to create inside each element),\r\n   * an object or an array to iterate over.\r\n   * @param {ElemSetOfCallback} callback\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Function for creating set of elements inside each element in the set based on an array or an object.\r\n   *\r\n   * @example\r\n   * table.setOf('tr', [[1, 2], [3, 4], [5, 6]], (row, array) => {\r\n   *   D(row).setOf('td', array, (col, number) => {\r\n   *     D(col).text(number);\r\n   *   });\r\n   * });\r\n   */\r\n  setOf(type, iterator, callback) {\r\n    validate({ 2: callback }, { 2: ['function'] }, 'Elem#setOf');\r\n\r\n    iterator = new Super(iterator).$;\r\n\r\n    if (isNumber(iterator)) {\r\n      try {\r\n        validate({ 1: iterator }, { 1: ['intLike', '>=0'] }, 'Elem#setOf');\r\n      } catch (e) {\r\n        throw new Error('2nd argument must be either or non-negative integer, or object! (at Elem#setOf)');\r\n      }\r\n\r\n      iterator = array(iterator).$;\r\n    }\r\n\r\n    return this.object((elems, elem, index) => {\r\n      iterate(iterator, (value, key) => {\r\n        const created = new Elem(elem).create(type);\r\n\r\n        callback(created.$[0], value, key, iterator, elem, index);\r\n\r\n        elems.add(created);\r\n      });\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#show\r\n   * @public\r\n   * @returns {Elem} Returns this.\r\n   * @description Shows all elements in the set.\r\n   * If an element was hidden using {@link Elem#hide} previous display is set.\r\n   *\r\n   * @example\r\n   * elem.show();\r\n   */\r\n  show() {\r\n    return this.forEach((elem) => {\r\n      const { dwayneData } = elem;\r\n\r\n      elem = new Elem(elem);\r\n\r\n      if (elem.css('display').indexOf('none') === 0) {\r\n        elem.css('display', dwayneData.previousDisplay);\r\n      }\r\n\r\n      dwayneData.previousDisplay = '';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#text\r\n   * @public\r\n   * @param {String|ElemValueCallback|*} [text] - Text to write instead of current text.\r\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\r\n   * Otherwise all elements texts in the set are set to the text argument.\r\n   * @description Gets or sets text.\r\n   *\r\n   * @example\r\n   * elem.text('123');\r\n   * elem.text(); // '123'\r\n   */\r\n  text(text) {\r\n    if (!arguments.length) {\r\n      return this.prop(textProperty);\r\n    }\r\n\r\n    return this.forEach((elem, index) => {\r\n      const txt = elem[textProperty];\r\n\r\n      new Elem(elem).prop(\r\n        textProperty,\r\n        isFunction(text)\r\n          ? text(txt, elem, index)\r\n          : text\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#toggleAttr\r\n   * @public\r\n   * @param {String} attr - Attribute to toggle.\r\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\r\n   * with the '' value and if falsey method removes the attribute. If not present method adds\r\n   * the attribute if it doesn't exist and removes if it does.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for toggling attributes.\r\n   *\r\n   * @example\r\n   * elem.toggleAttr('attr');\r\n   * elem.toggleAttr('attr', someCondition);\r\n   */\r\n  toggleAttr(attr, condition) {\r\n    return this.forEach((elem) => {\r\n      elem = new Elem(elem);\r\n\r\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\r\n        elem.attr(attr, '');\r\n      } else {\r\n        elem.removeAttr(attr);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Elem#toggleAttr\r\n   * @public\r\n   * @param {String} cls - Class to toggle.\r\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\r\n   * and if falsey method removes the class. If not present method adds\r\n   * the class if it doesn't exist and removes if it does.\r\n   * @returns {Elem} Returns this.\r\n   * @description Method for toggling classes.\r\n   *\r\n   * @example\r\n   * elem.toggleClass('cls');\r\n   * elem.toggleClass('cls', someCondition);\r\n   */\r\n  toggleClass(cls, condition) {\r\n    return (arguments.length < 2 ? !this.hasClass(cls) : condition)\r\n      ? this.addClass(cls)\r\n      : this.removeClass(cls);\r\n  }\r\n\r\n  get toStringTag() {\r\n    return toStringTag(this.$$);\r\n  }\r\n\r\n  /**\r\n   * @method Elem#up\r\n   * @public\r\n   * @param {Integer} [level = 1] - What level up along the tree should be the parent.\r\n   * @returns {Elem} New instance of Elem.\r\n   * @description Creates a collection of parents of level &lt;level&gt;.\r\n   *\r\n   * @example\r\n   * elem.up();\r\n   * elem.up(2);\r\n   */\r\n  up(level = 1) {\r\n    validate([level], [['intLike', '>=0']], 'Elem#up');\r\n\r\n    level = Number(level);\r\n\r\n    return this.object((elems, elem) => {\r\n      let n = level;\r\n\r\n      while (n-- && elem) {\r\n        elem = elem.parentNode;\r\n      }\r\n\r\n      elems.add(elem);\r\n    }, new Elem());\r\n  }\r\n\r\n  /**\r\n   * @method Elem#validate\r\n   * @public\r\n   * @param {ValidateCallback} [validator] - If present, function that validates inputs.\r\n   * @returns {Elem|Object.<String, Error|*>|null}\r\n   * If a callback argument provided returns this. If no arguments provided returns either an object\r\n   * with input names keys and errors values or null if no errors found.\r\n   * @description If a callback argument provided adds it to the element validators list.\r\n   * If no arguments provided validates every input element in the set with its own functions.\r\n   * If an element is a form it validates all input elements inside it. After the validation\r\n   * fires 'validate' event with 'valid' and 'error' (if form it's errors) properties.\r\n   *\r\n   * @example\r\n   * form.on('input change', 'input', (value, input) => {\r\n   *   input = D(input);\r\n   *\r\n   *   if (Number(value) % 3) {\r\n   *     input.addClass('invalid');\r\n   *\r\n   *     throw new Error('The value should be divided by 3!');\r\n   *   }\r\n   *\r\n   *   input.removeClass('invalid');\r\n   * });\r\n   */\r\n  validate(validator) {\r\n    validate([validator], ['function||!'], 'Elem#validate');\r\n\r\n    if (validator) {\r\n      return this.forEach(({ dwayneData }) => {\r\n        dwayneData.validators.push(validator);\r\n      });\r\n    }\r\n\r\n    const errors = new Super({ errors: null });\r\n\r\n    this\r\n      .filter(`${ inputElements }, form`)\r\n      .forEach((elem, index) => {\r\n        if (getName(elem) === 'form') {\r\n          let formErrors = { errors: null };\r\n          const form = new Elem(elem);\r\n          const inputs = form.find(inputElements);\r\n\r\n          inputs.forEach((input, index) => {\r\n            validatorWrap(input, index, formErrors);\r\n          });\r\n\r\n          errors.deepAssign(formErrors);\r\n\r\n          formErrors = formErrors.errors;\r\n\r\n          form.dispatch('validate', {}, {\r\n            valid: !formErrors,\r\n            errors: formErrors\r\n          });\r\n\r\n          return inputs.forEach((input) => {\r\n            const inputError = (formErrors || {})[input.name];\r\n\r\n            new Elem(input).dispatch('validate', {}, {\r\n              valid: !inputError,\r\n              error: inputError || null\r\n            });\r\n          });\r\n        }\r\n\r\n        let inputError = { errors: null };\r\n\r\n        validatorWrap(elem, index, inputError);\r\n        errors.deepAssign(inputError);\r\n\r\n        inputError = (inputError.errors || {})[elem.name];\r\n\r\n        new Elem(elem).dispatch('validate', {}, {\r\n          valid: !inputError,\r\n          error: inputError || null\r\n        });\r\n      });\r\n\r\n    function validatorWrap(input, index, errors) {\r\n      try {\r\n        if (input.validity && !input.validity.valid) {\r\n          throw new Error(input.validationMessage);\r\n        }\r\n\r\n        input.dwayneData.validators.forEach((validator) => {\r\n          validator(input.value, input, index);\r\n        });\r\n      } catch (err) {\r\n        (errors.errors = errors.errors || {})[input.name] = err;\r\n      }\r\n    }\r\n\r\n    if (errors.every((error) => isNull(error))) {\r\n      return null;\r\n    }\r\n\r\n    return errors.$.errors;\r\n  }\r\n\r\n  /**\r\n   * @method Elem#width\r\n   * @public\r\n   * @param {*|ElemValueCallback} [width] - Width to set.\r\n   * @returns {Elem|String} If no arguments passed width of the first element in the set returned.\r\n   * Otherwise all elements widths in the set are set to the width argument.\r\n   * @description Gets or sets width.\r\n   *\r\n   * @example\r\n   * elem.width(123);\r\n   * elem.width(); // 123\r\n   */\r\n  width(width) {\r\n    return this.prop.apply(this, new Arr(arguments).unshift('width').$);\r\n  }\r\n}\r\n\r\ndefineProperties(Elem.prototype, {\r\n  [Symbol.toStringTag]: 'Elem'\r\n});\r\n\r\n/**\r\n * @const {Elem} win\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of window.\r\n */\r\nconst win = new Elem(global);\r\n\r\n/**\r\n * @const {Elem} doc\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.\r\n */\r\nconst doc = new Elem(nativeDocument);\r\n\r\n/**\r\n * @const {Elem} html\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.documentElement.\r\n */\r\nconst html = new Elem(nativeDocument.documentElement);\r\n\r\n/**\r\n * @const {Elem} body\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.body.\r\n */\r\nconst body = new Elem(nativeDocument.body);\r\n\r\n/**\r\n * @const {Elem} head\r\n * @type {Elem}\r\n * @public\r\n * @description Elem instance of document.head.\r\n */\r\nconst head = new Elem(nativeDocument.head);\r\n\r\nconst elements = new Arr(htmlElements).concat(svgElements).$;\r\nconst props = new Arr(elements).map((type) => new Str(type).toCamelCase().$).$;\r\n\r\ndynamicDefineProperties(Elem.prototype, props, (elem, i) => function () {\r\n  return this.create.apply(this, new Arr(arguments).unshift(elements[i]).$);\r\n});\r\n\r\ndynamicDefineProperties(Elem.prototype, canvasGetMethods, (method) => function () {\r\n  const ctx = this.ctx();\r\n\r\n  if (ctx) {\r\n    return ctx[method].apply(ctx, arguments);\r\n  }\r\n});\r\n\r\ndynamicDefineProperties(Elem.prototype, canvasRestMethods, (method) => function () {\r\n  const ctx = this.ctx();\r\n\r\n  if (ctx) {\r\n    ctx[method].apply(ctx, arguments);\r\n  }\r\n\r\n  return this;\r\n});\r\n\r\n/**\r\n * @function toFind\r\n * @private\r\n * @param {Element|Elem|String} elem - Element, selector of Elements or Elem.\r\n * @returns {Elem} Instance of Elem.\r\n */\r\nfunction toFind(elem) {\r\n  if (isElem(elem)) {\r\n    return elem;\r\n  }\r\n\r\n  if (isString(elem)) {\r\n    elem = find(elem);\r\n  }\r\n\r\n  return new Elem(elem);\r\n}\r\n\r\n/**\r\n * @function isElem\r\n * @private\r\n * @param {*} value - Value to check if it's Elem.\r\n * @returns {Boolean} If the value is Elem.\r\n * @description Returns if the value is Elem or not.\r\n */\r\nfunction isElem(value) {\r\n  return value instanceof Elem;\r\n}\r\n\r\n/**\r\n * @function isWindow\r\n * @private\r\n * @param {*} value - Value to check if it's Window.\r\n * @returns {Boolean} If the value is Window.\r\n * @description Returns if the value is Window or not.\r\n */\r\nfunction isWindow(value) {\r\n  return toStringTag(value) === 'Window';\r\n}\r\n\r\n/**\r\n * @function isHTMLDocument\r\n * @private\r\n * @param {*} value - Value to check if it's HTMLDocument.\r\n * @returns {Boolean} If the value is HTMLDocument.\r\n * @description Returns if the value is HTMLDocument or not.\r\n */\r\nfunction isHTMLDocument(value) {\r\n  return toStringTag(value) === 'HTMLDocument';\r\n}\r\n\r\n/**\r\n * @function isDocumentFragment\r\n * @private\r\n * @param {*} value - Value to check if it's a DocumentFragment.\r\n * @returns {Boolean} If the value is a DocumentFragment.\r\n * @description Returns if the value is a DocumentFragment or not.\r\n */\r\nfunction isDocumentFragment(value) {\r\n  return toStringTag(value) === 'DocumentFragment';\r\n}\r\n\r\n/**\r\n * @function isStyleRule\r\n * @private\r\n * @param {*} value - Value to check if it's a style rule.\r\n * @returns {Boolean} If the value is a style rule.\r\n * @description Returns if the value is a style rule or not.\r\n */\r\nfunction isStyleRule(value) {\r\n  return toStringTag(value) === 'CSSStyleRule';\r\n}\r\n\r\n/**\r\n * @function\r\n * @private\r\n * @param {*} value - Value to check if it's Comment or Text.\r\n * @returns {Boolean} If the value is HTMLDocument.\r\n * @description Returns if the value is Comment or Text or not.\r\n */\r\nfunction isCommentOrText(value) {\r\n  const tag = toStringTag(value);\r\n\r\n  return tag === 'Comment' || tag === 'Text';\r\n}\r\n\r\n/**\r\n * @function getElem\r\n * @private\r\n * @param {Elem} elem - Element to check.\r\n * @returns {Element} The argument or a fallback if needed.\r\n */\r\nfunction getElem(elem) {\r\n  return isElement(elem.$[0]) ? elem.$[0] : emptyDiv;\r\n}\r\n\r\n/**\r\n * @function getName\r\n * @private\r\n * @param {Element} [elem] - Element which name is needed to know.\r\n * @returns {String} Element name.\r\n */\r\nfunction getName(elem) {\r\n  return (elem && elem.nodeName && elem.nodeName.toLowerCase()) || '';\r\n}\r\n\r\n/**\r\n * @function addDwayneData\r\n * @private\r\n * @param {Element} elem - Element to add dwayneData to.\r\n * @returns {void}\r\n */\r\nfunction addDwayneData(elem) {\r\n  if (!{}.hasOwnProperty.call(elem, 'dwayneData') && !isWindow(elem)) {\r\n    /**\r\n     * @member Element#dwayneData\r\n     * @type {Object}\r\n     * @protected\r\n     * @property {String} previousDisplay - Parameter used for hiding/showing elements.\r\n     * @property {Object.<String, Super>} removeListeners - Parameter used for remove event listeners.\r\n     * @property {CanvasRenderingContext2D} [ctx] - Canvas rendering context.\r\n     * @property {Arr} validators - Validators assigned to element.\r\n     * @description D data.\r\n     */\r\n    Object.defineProperty(elem, 'dwayneData', {\r\n      value: {\r\n        previousDisplay: '',\r\n        listeners: {},\r\n        ctx: getName(elem) === 'canvas' && elem.getContext('2d'),\r\n        validators: new Arr([])\r\n      }\r\n    });\r\n  } else if (isWindow(elem) && !windowsDwayneData.some(({ element }) => element === elem)) {\r\n    windowsDwayneData.push({\r\n      element: elem,\r\n      listeners: {}\r\n    });\r\n  }\r\n}\r\n\r\nconstructors[2].push({\r\n  check: (elem) => (\r\n    isElement(elem) ||\r\n    isWindow(elem) ||\r\n    isHTMLDocument(elem) ||\r\n    isCommentOrText(elem) ||\r\n    isDocumentFragment(elem) ||\r\n    /^(HTMLCollection|NodeList)$/.test(toStringTag(elem))\r\n  ),\r\n  cls: Elem\r\n});\r\n\r\n/**\r\n * @function find\r\n * @public\r\n * @param {String} selector - Selector to find.\r\n * @param {Element} [base = document] - Base to find in.\r\n * @returns {Elem} New instance of Elem.\r\n * @description Synonym for\r\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\r\n */\r\nfunction find(selector, base = nativeDocument) {\r\n  return new Elem(\r\n    isElement(base) || isHTMLDocument(base)\r\n      ? base.querySelectorAll(String(selector))\r\n      : []\r\n  );\r\n}\r\n\r\n/**\r\n * @function parseHTML\r\n * @public\r\n * @param {String} html - HTML to parse.\r\n * @param {Boolean} [collapseWhiteSpace = false] - If the whitespace should be\r\n * collapsed during the parsing.\r\n * @returns {Elem} New instance of Elem.\r\n * @description Parses HTML and returns a wrap of #document-fragment containing the contents.\r\n *\r\n * @example\r\n * parseHTML('<div>123</div>'); // Elem\r\n */\r\nfunction parseHTML(html, collapseWhiteSpace) {\r\n  const json = markupToJSON(html, collapseWhiteSpace);\r\n  const template = doc.template();\r\n  const elem = new Elem(template.$[0].content);\r\n\r\n  json.forEach(function forEachNode(node) {\r\n    const {\r\n      name,\r\n      attrs,\r\n      value,\r\n      parent,\r\n      children\r\n    } = node;\r\n\r\n    const parentNode = parent.elem || elem;\r\n    const element = parentNode.create(name);\r\n\r\n    node.elem = element;\r\n\r\n    if (value) {\r\n      element.text(value);\r\n    }\r\n\r\n    if (attrs) {\r\n      element.attr(attrs);\r\n    }\r\n\r\n    if (name === 'template') {\r\n      node.elem = new Elem(element.prop('content'));\r\n    }\r\n\r\n    if (children) {\r\n      children.forEach(forEachNode);\r\n    }\r\n  });\r\n\r\n  return new Elem(elem);\r\n}\r\n\r\n/**\r\n * @function px\r\n * @public\r\n * @param {String|Number} size - String containing pixels value or a number.\r\n * @returns {Number} Number of pixels.\r\n * @description Function for parsing pixel strings.\r\n *\r\n * @example\r\n * px('0px');  // 0\r\n * px('42px'); // 42\r\n */\r\nfunction px(size) {\r\n  return Number(String(size).replace(/px$/, ''));\r\n}\r\n\r\nexport { Elem, win, doc, html, body, head, find, parseHTML, px };\r\n","export function registerDBlock(Block) {\r\n  class DBlock extends Block {\r\n    static template = '<d-elements value=\"{elems}\" />';\r\n\r\n    elems = null;\r\n\r\n    afterConstruct() {\r\n      const { children } = this.$$.parent;\r\n      const { name } = this.args;\r\n      let found;\r\n\r\n      if (name) {\r\n        found = children.find(({ name: nodeName }) => nodeName === `d-block-${ name }`);\r\n\r\n        if (found && found.value.children.length) {\r\n          this.elems = found.value.children;\r\n        }\r\n      } else {\r\n        this.elems = children;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-block',\r\n    value: DBlock\r\n  };\r\n}\r\n","import { Arr } from '../Arr';\r\nimport { Elem } from '../Elem';\r\nimport { Super } from '../Super';\r\nimport { assign } from '../helpers';\r\n\r\nexport function registerDEach(Block, createBlock) {\r\n  class DEach extends Block {\r\n    constructor(opts) {\r\n      super(opts);\r\n\r\n      const {\r\n        args: {\r\n          item: itemName = '$item',\r\n          index: indexName = '$index'\r\n        }\r\n      } = this;\r\n\r\n      assign(this.$$, {\r\n        uids: new Super({}),\r\n        items: new Arr([]),\r\n        UID: String(this.args.uid),\r\n        itemName,\r\n        indexName\r\n      });\r\n    }\r\n\r\n    afterRender() {\r\n      this.constructValues(this.args.set);\r\n      this.watchArgs('set', (set) => {\r\n        this.constructValues(set);\r\n      });\r\n    }\r\n\r\n    constructValues(set) {\r\n      const {\r\n        elems: {\r\n          start,\r\n          parent: parentElem\r\n        },\r\n        uids,\r\n        parent,\r\n        scope,\r\n        itemName,\r\n        indexName,\r\n        UID\r\n      } = this.$$;\r\n      const { children } = this;\r\n      const $uids = uids.$;\r\n      const newKeys = {};\r\n      const newUIDs = {};\r\n\r\n      new Super(set).forEach((item, index) => {\r\n        scope[itemName] = item;\r\n        scope[indexName] = index;\r\n\r\n        const uid = parent.$$.evaluate(String(UID), null, null, false, false, this);\r\n\r\n        newKeys[uid] = newKeys[uid] || {};\r\n        newKeys[uid][index] = true;\r\n        newUIDs[index] = uid;\r\n      });\r\n\r\n      scope[itemName] = null;\r\n      scope[indexName] = null;\r\n\r\n      uids.forEach((items, uid) => {\r\n        if (!newKeys[uid]) {\r\n          items.forEach((Item) => {\r\n            Item.remove();\r\n          });\r\n\r\n          return;\r\n        }\r\n\r\n        items.splice(Object.keys(newKeys[uid]).length).forEach((Item) => {\r\n          Item.remove();\r\n        });\r\n      });\r\n\r\n      let after = start;\r\n\r\n      new Super(set).forEach((item, index) => {\r\n        const uid = newUIDs[index];\r\n        let block;\r\n\r\n        if ($uids[uid] && $uids[uid].length) {\r\n          block = newKeys[uid][index] = uids.$[uid].shift();\r\n          block.$$.scope[indexName] = index;\r\n          block.$$.scope[itemName] = item;\r\n        } else {\r\n          block = newKeys[uid][index] = createBlock({\r\n            node: {\r\n              itemName,\r\n              indexName,\r\n              item,\r\n              index,\r\n              name: '#d-item',\r\n              block: parent,\r\n              children\r\n            },\r\n            after,\r\n            parent: parentElem,\r\n            parentBlock: this,\r\n            parentScope: parent\r\n          });\r\n        }\r\n\r\n        const {\r\n          start,\r\n          end\r\n        } = block.$$.elems;\r\n\r\n        if (start.prev().$[0] !== after.$[0]) {\r\n          const { content } = block.$$.elems;\r\n\r\n          new Elem([\r\n            start,\r\n            content,\r\n            end\r\n          ]).insertAfter(after);\r\n        }\r\n\r\n        after = end;\r\n      });\r\n\r\n      this.$$.uids = new Super(newKeys).map((items) => (\r\n        new Super(items).values()\r\n      ));\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-each',\r\n    value: DEach\r\n  };\r\n}\r\n","import { Arr } from '../Arr';\r\nimport { Elem } from '../Elem';\r\n\r\nexport function registerDElements(Block, createBlock) {\r\n  class DElements extends Block {\r\n    afterConstruct() {\r\n      this.watchArgs('value', (value) => {\r\n        const {\r\n          children,\r\n          mixins,\r\n          watchersToRemove,\r\n          elems: {\r\n            start,\r\n            content,\r\n            parent\r\n          }\r\n        } = this.$$;\r\n        let after = start;\r\n\r\n        children.forEach((child) => {\r\n          child.remove(true);\r\n        });\r\n        mixins.forEach((mixin) => {\r\n          mixin.remove(true);\r\n        });\r\n        content.remove();\r\n\r\n        this.$$.children = new Arr([]);\r\n        this.$$.mixins = new Arr([]);\r\n        this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\r\n          if (forDElements) {\r\n            return true;\r\n          }\r\n\r\n          const index = watchers.indexOf(watcher);\r\n\r\n          if (index !== -1) {\r\n            watchers.splice(index, 1);\r\n          }\r\n        });\r\n\r\n        const newContent = new Elem();\r\n\r\n        new Arr(value || []).forEach((child) => {\r\n          const block = createBlock({\r\n            node: child,\r\n            after,\r\n            parent,\r\n            parentBlock: this,\r\n            parentScope: this\r\n          });\r\n\r\n          if (block instanceof Block) {\r\n            const { elems } = block.$$;\r\n\r\n            after = elems.end;\r\n\r\n            newContent.add(elems.start, elems.content, elems.end);\r\n          } else {\r\n            after = block;\r\n\r\n            newContent.add(block);\r\n          }\r\n        });\r\n\r\n        this.$$.elems.content = newContent;\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-elements',\r\n    value: DElements\r\n  };\r\n}\r\n","export function registerDIf(Block) {\r\n  class DIf extends Block {\r\n    static template = '<d-elements value=\"{elems}\"/>';\r\n\r\n    index = Infinity;\r\n    elems = null;\r\n    values = this.children.map((child, i) => {\r\n      const {\r\n        name,\r\n        attrs,\r\n        children\r\n      } = child;\r\n      const cond = this.evaluateAndWatch(name === 'd-else' ? '{true}' : attrs.if || '{true}', (newValue) => {\r\n        if (!!newValue === this.values.$[i]) {\r\n          return;\r\n        }\r\n\r\n        this.values.$[i] = !!newValue;\r\n\r\n        if (i > this.index) {\r\n          return;\r\n        }\r\n\r\n        if (i < this.index) {\r\n          this.index = i;\r\n          this.elems = children;\r\n\r\n          return;\r\n        }\r\n\r\n        const found = this.values.find(Boolean);\r\n\r\n        if (found) {\r\n          this.index = found.key;\r\n          this.elems = this.children.$[found.key].children;\r\n        } else {\r\n          this.index = Infinity;\r\n          this.elems = null;\r\n        }\r\n      });\r\n\r\n      if (cond && this.index === Infinity) {\r\n        this.index = i;\r\n        this.elems = children;\r\n      }\r\n\r\n      return cond;\r\n    });\r\n  }\r\n\r\n  return {\r\n    name: 'd-if',\r\n    value: DIf\r\n  };\r\n}\r\n","export function registerDItem(Block) {\r\n  class DItem extends Block {\r\n    static template = '<d-elements value=\"{children}\"/>';\r\n  }\r\n\r\n  return {\r\n    name: '#d-item',\r\n    value: DItem\r\n  };\r\n}\r\n","import { Arr } from '../Arr';\r\nimport { Super } from '../Super';\r\n\r\nexport function registerDSwitch(Block) {\r\n  class DSwitch extends Block {\r\n    static template = '<d-elements value=\"{elems}\"/>';\r\n\r\n    index = Infinity;\r\n    elems = null;\r\n\r\n    constructor(opts) {\r\n      super(opts);\r\n\r\n      const {\r\n        args,\r\n        args: { value }\r\n      } = this;\r\n      let wasDefault;\r\n\r\n      this.values = this.children.object((values, child, i) => {\r\n        const {\r\n          name,\r\n          attrs,\r\n          children\r\n        } = child;\r\n\r\n        if (wasDefault) {\r\n          return;\r\n        }\r\n\r\n        if (name !== 'd-case' && name !== 'd-default') {\r\n          return;\r\n        }\r\n\r\n        if (name === 'd-default') {\r\n          wasDefault = true;\r\n        }\r\n\r\n        let val;\r\n\r\n        if (name === 'd-default') {\r\n          val = args.value;\r\n        } else {\r\n          val = this.evaluateAndWatch(attrs.if || '{undefined}', (newValue) => {\r\n            if (this.equals(this.values.$[i].value, newValue)) {\r\n              return;\r\n            }\r\n\r\n            this.values.$[i].value = newValue;\r\n\r\n            if (i > this.index) {\r\n              return;\r\n            }\r\n\r\n            if (i < this.index) {\r\n              this.index = i;\r\n              this.elems = children;\r\n\r\n              return;\r\n            }\r\n\r\n            const found = this.values.find(({ value }) => (\r\n              this.equals(value, args.value)\r\n            ));\r\n\r\n            if (found) {\r\n              this.index = found.key;\r\n              this.elems = found.value.children;\r\n            } else {\r\n              this.index = Infinity;\r\n              this.elems = null;\r\n            }\r\n          });\r\n        }\r\n\r\n        if (this.equals(val, value) && this.index === Infinity) {\r\n          this.index = i;\r\n          this.elems = children;\r\n        }\r\n\r\n        values.push({\r\n          name,\r\n          children,\r\n          value: val\r\n        });\r\n      }, new Arr([]));\r\n    }\r\n\r\n    afterConstruct() {\r\n      this.watchArgs('value', (newValue) => {\r\n        this.index = Infinity;\r\n        this.values.forEach(({ name, value, children }, i) => {\r\n          const val = name === 'd-default'\r\n            ? newValue\r\n            : value;\r\n\r\n          if (this.equals(val, newValue) && this.index === Infinity) {\r\n            this.index = i;\r\n            this.elems = children;\r\n          }\r\n        });\r\n\r\n        if (this.index === Infinity) {\r\n          this.elems = null;\r\n        }\r\n      });\r\n    }\r\n\r\n    equals(value1, value2) {\r\n      return new Super(value1).equals(value2);\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-switch',\r\n    value: DSwitch\r\n  };\r\n}\r\n","import { isNil } from '../helpers';\r\n\r\nexport function registerDText(Block) {\r\n  class DText extends Block {\r\n    static template = '<d-elements value=\"{[{ name: \\'#text\\', value: text }]}\"/>';\r\n\r\n    text = '';\r\n\r\n    afterConstruct() {\r\n      this.text = isNil(this.args.value) ? '' : this.args.value;\r\n\r\n      this.watchArgs('value', (newValue) => {\r\n        this.text = isNil(newValue) ? '' : newValue;\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-text',\r\n    value: DText\r\n  };\r\n}\r\n","import { Super } from '../Super';\r\n\r\nexport function registerDAttr(Mixin) {\r\n  class DAttr extends Mixin {\r\n    afterUpdate(newValue, oldValue) {\r\n      const { elem } = this;\r\n\r\n      newValue = new Super(newValue).$;\r\n\r\n      new Super(oldValue).forEach((value, prop) => {\r\n        if (!newValue[prop]) {\r\n          elem.removeAttr(prop);\r\n        }\r\n      });\r\n      elem.attr(newValue);\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-attr',\r\n    value: DAttr\r\n  };\r\n}\r\n\r\n","import { isFunction } from '../helpers';\r\n\r\nexport function registerDBind(Mixin) {\r\n  class DBind extends Mixin {\r\n    afterUpdate(value) {\r\n      if (this.off) {\r\n        this.off();\r\n      }\r\n\r\n      if (!isFunction(value)) {\r\n        return;\r\n      }\r\n\r\n      this.off = this.elem.on(this.match[0], value);\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-bind',\r\n    value: DBind\r\n  };\r\n}\r\n","import { Super } from '../Super';\r\nimport { isArray, isString, iterate } from '../helpers';\r\n\r\nexport function registerDClass(Mixin) {\r\n  class DClass extends Mixin {\r\n    classes = [];\r\n\r\n    afterUpdate(newValue) {\r\n      const {\r\n        elem,\r\n        classes\r\n      } = this;\r\n      const newClasses = [];\r\n\r\n      newValue = new Super(newValue).$;\r\n\r\n      if (isString(newValue)) {\r\n        newValue = newValue.split(/\\s+/);\r\n      }\r\n\r\n      if (isArray(newValue)) {\r\n        iterate(classes, (cls) => {\r\n          if (newValue.indexOf(cls) === -1) {\r\n            elem.removeClass(cls);\r\n          }\r\n        });\r\n        iterate(newValue, (cls) => {\r\n          if (isString(cls)) {\r\n            newClasses.push(cls);\r\n            elem.addClass(cls);\r\n          }\r\n        });\r\n      } else {\r\n        iterate(classes, (cls) => {\r\n          if (!newValue || !newValue[cls]) {\r\n            elem.removeClass(cls);\r\n          }\r\n        });\r\n        iterate(newValue, (val, cls) => {\r\n          if (val) {\r\n            newClasses.push(cls);\r\n            elem.addClass(cls);\r\n          }\r\n        });\r\n      }\r\n\r\n      this.classes = newClasses;\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-class',\r\n    value: DClass\r\n  };\r\n}\r\n","import { isFunction, isString } from '../helpers';\r\n\r\nexport function registerDElem(Mixin) {\r\n  class DElem extends Mixin {\r\n    static evaluate = false;\r\n\r\n    constructor(opts) {\r\n      super(opts);\r\n\r\n      const {\r\n        block,\r\n        elem\r\n      } = this;\r\n      const value = this.evaluateOnce();\r\n\r\n      if (isFunction(value)) {\r\n        value(elem);\r\n      } else if (isString(value)) {\r\n        block[value] = elem;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-elem',\r\n    value: DElem\r\n  };\r\n}\r\n","export function registerDHide(Mixin) {\r\n  class DHide extends Mixin {\r\n    afterUpdate(value) {\r\n      const { elem } = this;\r\n\r\n      if (value) {\r\n        elem.hide();\r\n      } else {\r\n        elem.show();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-hide',\r\n    value: DHide\r\n  };\r\n}\r\n","export function registerDOn(Mixin) {\r\n  class DOn extends Mixin {\r\n    static evaluate = false;\r\n\r\n    constructor(opts) {\r\n      super(opts);\r\n\r\n      this.elem.on(this.match[0], () => {\r\n        this.evaluateOnce();\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-on',\r\n    value: DOn\r\n  };\r\n}\r\n","export function registerDShow(Mixin) {\r\n  class DShow extends Mixin {\r\n    afterUpdate(value) {\r\n      const { elem } = this;\r\n\r\n      if (value) {\r\n        elem.show();\r\n      } else {\r\n        elem.hide();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-show',\r\n    value: DShow\r\n  };\r\n}\r\n","import { Super } from '../Super';\r\n\r\nexport function registerDStyle(Mixin) {\r\n  class DStyle extends Mixin {\r\n    afterUpdate(newValue, oldValue) {\r\n      const { elem } = this;\r\n\r\n      newValue = new Super(newValue).$;\r\n\r\n      new Super(oldValue).forEach((value, prop) => {\r\n        if (!newValue[prop]) {\r\n          elem.removeCSS(prop);\r\n        }\r\n      });\r\n      elem.css(newValue);\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-style',\r\n    value: DStyle\r\n  };\r\n}\r\n","import { isNil } from '../helpers';\r\n\r\nexport function registerDText(Mixin) {\r\n  class DText extends Mixin {\r\n    afterUpdate(value) {\r\n      this.elem.text(\r\n        isNil(value)\r\n          ? ''\r\n          : `${ value }`\r\n      );\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-text',\r\n    value: DText\r\n  };\r\n}\r\n","import { switcher } from '../Switcher';\nimport { isFunction } from '../helpers';\n\nconst listenerSwitcher = switcher('strictEquals', 'input')\n  .case('form', 'input, change')\n  .case('select', 'change')\n  .case('input', (type) => (\n    type === 'radio'\n    || type === 'checkbox'\n    || type === 'color'\n    || type === 'file'\n      ? 'change'\n      : 'input'\n  ));\n\nexport function registerDValidate(Mixin) {\n  class DValidate extends Mixin {\n    static evaluate = false;\n\n    constructor(opts) {\n      super(opts);\n\n      const { elem } = this;\n      const validator = this.evaluateOnce();\n\n      if (isFunction(validator)) {\n        elem.validate(validator);\n      } else if (validator === true) {\n        elem.on(listenerSwitcher(elem.name, [elem.prop('type')]), () => {\n          elem.validate();\n        });\n      }\n    }\n  }\n\n  return {\n    name: 'd-validate',\n    value: DValidate\n  };\n}\n","import { Arr } from '../Arr';\r\nimport { switcher } from '../Switcher';\r\nimport { isArray, isFunction, isNil } from '../helpers';\r\n\r\nconst propSwitcher = switcher('strictEquals', (type, elem) => (\r\n  elem.hasAttr('contenteditable') || elem.hasAttr('contentEditable')\r\n    ? 'text'\r\n    : 'value'\r\n))\r\n  .case('select', (type, elem) => (\r\n    elem.hasAttr('multiple')\r\n      ? 'multiple-select'\r\n      : 'value'\r\n  ))\r\n  .case('input', (type) => {\r\n    if (type === 'file') {\r\n      return 'files';\r\n    }\r\n\r\n    return type === 'radio' || type === 'checkbox'\r\n      ? 'checked'\r\n      : 'value';\r\n  });\r\nconst setValueSwitcher = switcher('strictEquals', (value) => value)\r\n  .case('input', (value, type, inputValue) => {\r\n    if (type !== 'radio' && type !== 'checkbox') {\r\n      return value;\r\n    }\r\n\r\n    if (type === 'radio') {\r\n      return value === inputValue;\r\n    }\r\n\r\n    return value.indexOf(inputValue) !== -1;\r\n  });\r\nconst getValueSwitcher = switcher('strictEquals', (value) => value)\r\n  .case('select', (value, type, inputValue, values, elem, options) => {\r\n    if (!elem.hasAttr('multiple')) {\r\n      return value;\r\n    }\r\n\r\n    return options\r\n      .object((values, { selected, value }) => {\r\n        if (selected && values.indexOf(value) === -1) {\r\n          values.push(value);\r\n        }\r\n      }, [])\r\n      .$;\r\n  })\r\n  .case('input', (value, type, inputValue, values, elem, options, init) => {\r\n    if (type !== 'radio' && type !== 'checkbox') {\r\n      return value;\r\n    }\r\n\r\n    if (type === 'radio') {\r\n      return value\r\n        ? inputValue\r\n        : null;\r\n    }\r\n\r\n    if (!value && init) {\r\n      return values;\r\n    }\r\n\r\n    if (value) {\r\n      if (values) {\r\n        return values.indexOf(inputValue) === -1\r\n          ? new Arr(values).concat(inputValue).$\r\n          : values;\r\n      }\r\n\r\n      return [inputValue];\r\n    }\r\n\r\n    if (!isArray(values)) {\r\n      return [];\r\n    }\r\n\r\n    const index = values.indexOf(inputValue);\r\n\r\n    if (index !== -1) {\r\n      return [\r\n        ...new Arr(values).slice(0, index).$,\r\n        ...new Arr(values).slice(index + 1).$\r\n      ];\r\n    }\r\n\r\n    return values;\r\n  });\r\nconst listenerSwitcher = switcher('strictEquals', 'input')\r\n  .case('select', 'change')\r\n  .case('input', (type) => (\r\n    type === 'radio'\r\n    || type === 'checkbox'\r\n    || type === 'color'\r\n    || type === 'file'\r\n      ? 'change'\r\n      : 'input'\r\n  ));\r\n\r\nexport function registerDValue(Mixin) {\r\n  class DValue extends Mixin {\r\n    static evaluate = false;\r\n\r\n    constructor(opts) {\r\n      super(opts);\r\n\r\n      const {\r\n        $$: { _value },\r\n        block,\r\n        elem,\r\n        node\r\n      } = this;\r\n      const name = elem.name;\r\n      const type = elem.prop('type');\r\n      const value = this.evaluateOnce();\r\n      let initialScopeValue = null;\r\n\r\n      this.prop = propSwitcher(name, [type, elem]);\r\n      this.name = name;\r\n      this.type = type;\r\n      this.value = value;\r\n      this.options = elem.find('option');\r\n\r\n      if (!isFunction(value)) {\r\n        initialScopeValue = block.$$.evaluate(`{${ _value }}`, (newValue) => {\r\n          this.currentValue = newValue;\r\n          this.setProp(newValue);\r\n        }, this);\r\n      }\r\n\r\n      const initialElemValue = this.getProp(initialScopeValue, true);\r\n      const isInitialScopeValueNull = isNil(initialScopeValue);\r\n      const isCheckbox = type === 'checkbox';\r\n\r\n      if (isInitialScopeValueNull || isCheckbox) {\r\n        this.currentValue = initialElemValue;\r\n        this.changeScope();\r\n\r\n        if (!isInitialScopeValueNull && isCheckbox) {\r\n          this.setProp(initialScopeValue);\r\n        }\r\n      } else {\r\n        this.currentValue = initialScopeValue;\r\n        this.setProp(initialScopeValue);\r\n      }\r\n\r\n      elem.on(listenerSwitcher(name, [type]), (e) => {\r\n        if (e.target === node) {\r\n          this.currentValue = this.getProp(this.currentValue);\r\n          this.changeScope();\r\n        }\r\n      });\r\n    }\r\n\r\n    changeScope() {\r\n      const {\r\n        block,\r\n        value,\r\n        currentValue\r\n      } = this;\r\n\r\n      if (isFunction(value)) {\r\n        value(currentValue);\r\n      } else {\r\n        block[value] = currentValue;\r\n      }\r\n    }\r\n\r\n    setProp(value) {\r\n      const {\r\n        elem,\r\n        name,\r\n        prop,\r\n        type,\r\n        node,\r\n        options\r\n      } = this;\r\n\r\n      if (prop === 'text') {\r\n        elem.text(value);\r\n      } else if (prop === 'multiple-select') {\r\n        options.forEach((option) => {\r\n          option.selected = value.indexOf(option.value) !== -1;\r\n        });\r\n      } else {\r\n        elem.prop(prop, setValueSwitcher(name, [value, type, node.value]));\r\n      }\r\n    }\r\n\r\n    getProp(values, init) {\r\n      const {\r\n        elem,\r\n        name,\r\n        prop,\r\n        type,\r\n        node,\r\n        options\r\n      } = this;\r\n\r\n      return prop === 'text'\r\n        ? elem.text()\r\n        : getValueSwitcher(name, [elem.prop(prop), type, node.value, values, elem, options, init]);\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: 'd-value',\r\n    value: DValue\r\n  };\r\n}\r\n","/**\r\n * @module Block\r\n * @private\r\n * @mixin\r\n * @description Exports Block class.\r\n */\r\n\r\nimport { Arr } from './Arr';\r\nimport { doc, Elem } from './Elem';\r\nimport { Str } from './Str';\r\nimport { Super } from './Super';\r\nimport {\r\n  iterate, validate,\r\n  isFunction, isNil, isUndefined\r\n} from './helpers';\r\nimport * as Blocks from './blocks';\r\nimport * as Mixins from './mixins';\r\nimport { htmlAllowedTagSymbols, htmlAllowedAttrSymbols } from './constants';\r\nimport markupToJSON from './helpers/markupToJSON';\r\n\r\n/**\r\n * @callback Watcher\r\n * @param {*} newValue - New value.\r\n * @param {*} oldValue - Old value.\r\n */\r\n\r\n/**\r\n * @callback Wrapper\r\n * @param {Block} Block class to wrap.\r\n * @returns {Block} New Block class.\r\n */\r\n\r\nconst rootBlocks = Object.create(null);\r\nconst rootMixins = Object.create(null);\r\nconst isPrototypeOf = {}.isPrototypeOf;\r\nconst tagName = new RegExp(`^${ htmlAllowedTagSymbols }$`, 'i');\r\nconst attrName = new RegExp(`^${ htmlAllowedAttrSymbols }$`);\r\nconst expressionRegExp = /^\\{[\\s\\S]+\\}$/;\r\nconst { document } = global;\r\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nlet onEvalError = (err) => {\r\n  console.error(`Eval error (evaluating \"${ err.expression }\" in context of block \"${ err.block.$$.name }\"):`, err);\r\n};\r\nlet evalMode;\r\nlet getting;\r\nlet changed;\r\n\r\n/**\r\n * @class Block\r\n * @public\r\n * @param {Object} opts - Element options.\r\n * @returns {Block} Instance of Block.\r\n * @description Class for dynamic templating.\r\n *\r\n * @example\r\n * import { D, Block, initApp, registerBlock } from 'dwayne';\r\n *\r\n * class App extends Block {\r\n *   static template = '<Hello text=\"{text}\"/>';\r\n *\r\n *   constructor(args, children) {\r\n *     super(args, children);\r\n *\r\n *     this.text = 'world (0)';\r\n *     this.times = 0;\r\n *\r\n *     this.setInterval();\r\n *   }\r\n *\r\n *   setInterval() {\r\n *     D(1000).interval(() => {\r\n *       this.text = `world (${ ++this.times })`;\r\n *     });\r\n *   }\r\n * }\r\n *\r\n * class Hello extends Block {\r\n *   static template = 'Hello, <d-text value=\"{args.text}\"/>!';\r\n * }\r\n *\r\n * Block.App = App;\r\n * Block.Hello = Hello;\r\n *\r\n * initApp();\r\n */\r\nclass Block {\r\n  static _blocks = Object.create(rootBlocks);\r\n  static _mixins = Object.create(rootMixins);\r\n\r\n  /**\r\n   * @member {Boolean} [Block.collapseWhiteSpace = true]\r\n   * @type {Boolean}\r\n   * @public\r\n   * @description If the whitespace between html elements and\r\n   * in the start and the end inside the tag should be omitted during parsing.\r\n   */\r\n  static collapseWhiteSpace = true;\r\n\r\n  static get onEvalError() {\r\n    return onEvalError;\r\n  }\r\n\r\n  static set onEvalError(listener) {\r\n    if (isFunction(listener)) {\r\n      onEvalError = listener;\r\n    } else {\r\n      onEvalError = null;\r\n    }\r\n  }\r\n\r\n  static getBlocks() {\r\n    return new Super({ ...this._blocks });\r\n  }\r\n\r\n  static getMixins() {\r\n    return new Super({ ...this._mixins });\r\n  }\r\n\r\n  /**\r\n   * @method Block.register\r\n   * @public\r\n   * @param {String} name - Block or mixin name.\r\n   * @param {Block|Mixin} Subclass - Subclass of Block or Mixin.\r\n   * @returns {void}\r\n   * @description Register block or mixin in the namespace of this.\r\n   */\r\n  static register(name, Subclass) {\r\n    const _this = new Super(this);\r\n\r\n    if (!_this.hasOwn('_blocks')) {\r\n      Subclass._blocks = Object.create(_this.proto().$._blocks);\r\n    }\r\n\r\n    if (!_this.hasOwn('_mixins')) {\r\n      Subclass._mixins = Object.create(_this.proto().$._mixins);\r\n    }\r\n\r\n    const {\r\n      _blocks,\r\n      _mixins\r\n    } = this;\r\n\r\n    if (!isInstanceOfBlock(Subclass) && !isInstanceOfMixin(Subclass)) {\r\n      console.warn(`The \"${ name }\" class does not extend Block or Mixin and will not be registered (Block.register)`);\r\n\r\n      return;\r\n    }\r\n\r\n    if (isInstanceOfBlock(Subclass)) {\r\n      if (rootBlocks[name]) {\r\n        console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.register)`);\r\n\r\n        return;\r\n      }\r\n\r\n      if (!tagName.test(name)) {\r\n        console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.register)`);\r\n\r\n        return;\r\n      }\r\n\r\n      Subclass._html = deepCloneChildren(\r\n        markupToJSON(\r\n          `${ Subclass.template || '' }`,\r\n          Subclass.collapseWhiteSpace\r\n        )\r\n      );\r\n\r\n      _blocks[name] = Subclass;\r\n    } else {\r\n      if (rootMixins[name]) {\r\n        console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.register)`);\r\n\r\n        return;\r\n      }\r\n\r\n      if (!attrName.test(name)) {\r\n        console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.register)`);\r\n\r\n        return;\r\n      }\r\n\r\n      Subclass._match = new RegExp(`^${ new Str(name).escapeRegExp().$ }(?:-([\\\\s\\\\S]+))?$`);\r\n\r\n      _mixins[name] = Subclass;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @member {String} Block.template\r\n   * @type {String}\r\n   * @public\r\n   * @description Block template.\r\n   */\r\n\r\n  /**\r\n   * @method Block.wrap\r\n   * @public\r\n   * @param {Wrapper} func - Function that returns wrapped block.\r\n   * @returns {Block} New block.\r\n   * @description Method for wrapping blocks into another blocks.\r\n   * It is considered best practice to just extends the old block with a new one.\r\n   *\r\n   * @example\r\n   * class MyBlock extends Block {\r\n   *   static template = '<div>123</div>';\r\n   * }\r\n   *\r\n   * MyBlock.wrap((Block) => {\r\n   *   return class extends Block {\r\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\r\n   *\r\n   *     constructor() {\r\n   *       this.additionalVar = 'additional';\r\n   *     }\r\n   *   };\r\n   * });\r\n   */\r\n  static wrap(func) {\r\n    validate([func], ['function']);\r\n\r\n    return func(this);\r\n  }\r\n\r\n  constructor(opts) {\r\n    const {\r\n      name,\r\n      args: originalArgs,\r\n      children,\r\n      parent,\r\n      parentBlock,\r\n      parentScope\r\n    } = opts;\r\n    const watchersToRemove = new Arr([]);\r\n\r\n    Object.defineProperties(this, {\r\n      /**\r\n       * @member {Block} Block#$\r\n       * @type {Block}\r\n       * @public\r\n       * @description This.\r\n       */\r\n      $: {\r\n        value: this\r\n      },\r\n\r\n      /**\r\n       * @member {Object} Block#$$\r\n       * @type {Object}\r\n       * @protected\r\n       * @property {Object} args - Private args scope.\r\n       * @property {Arr} children - Child blocks.\r\n       * @property {Arr} mixins - Child mixins.\r\n       * @property {Object} elems - Elements connected to the block.\r\n       * @property {Elem} elems.parent - Parent element.\r\n       * @property {Elem} elems.start - Start comment block.\r\n       * @property {Elem} elems.end - End comment block.\r\n       * @property {Elem} elems.content - Content elements.\r\n       * @property {Function} evaluate - Evaluate function.\r\n       * @property {Object} global - Private global scope.\r\n       * @property {Object} locals - Private locals scope.\r\n       * @property {Arr} watchersToRemove - Watchers to remove before removing element.\r\n       */\r\n      $$: {\r\n        value: {\r\n          name,\r\n          parent: parentScope,\r\n          parentBlock,\r\n          ns: new Super(this).proto().$.constructor,\r\n          children: new Arr([]),\r\n          mixins: new Arr([]),\r\n          elems: {\r\n            start: doc.createComment(` ${ name }: start `),\r\n            end: doc.createComment(` ${ name }: end `),\r\n            content: new Elem(),\r\n            parent\r\n          },\r\n          watchersToRemove,\r\n          evaluate: (expression, onChange, instance, forDElements, forDItem, forDEach) => {\r\n            if (!expressionRegExp.test(expression)) {\r\n              return expression || true;\r\n            }\r\n\r\n            forDElements = !!forDElements;\r\n            forDItem = !!forDItem;\r\n            expression = expression.replace(/^\\{|\\}$/g, '');\r\n\r\n            const store = (name === '#d-item' && !forDItem) || forDEach\r\n              ? (forDEach || this).$$.scope\r\n              : this;\r\n\r\n            /* eslint no-new-func: 0 */\r\n            const { watchersToRemove } = instance ? instance.$$ : {};\r\n            const func = new Function(\r\n              '',\r\n              'with(document.DwayneStore){$$.expr=eval(\"$$.expr=\"+$$.expr);return $$.expr}'\r\n            );\r\n\r\n            return evaluate.call(this);\r\n\r\n            function evaluate() {\r\n              let result;\r\n\r\n              if (onChange) {\r\n                evalMode = true;\r\n                getting = new Arr([]);\r\n              }\r\n\r\n              store.$$.expr = expression;\r\n              document.DwayneStore = store;\r\n\r\n              try {\r\n                result = func();\r\n              } catch (err) {\r\n                if (onEvalError) {\r\n                  err.expression = expression;\r\n                  err.block = this;\r\n                  onEvalError(err);\r\n                }\r\n              }\r\n\r\n              if (onChange) {\r\n                const localWatchers = new Arr([]);\r\n\r\n                getting.forEach((watchers) => {\r\n                  const watcher = () => {\r\n                    const newResult = evaluate.call(this);\r\n\r\n                    if (newResult !== result) {\r\n                      onChange(newResult, result);\r\n                    }\r\n                  };\r\n                  const watcherBlock = {\r\n                    forDElements,\r\n                    watcher,\r\n                    watchers\r\n                  };\r\n\r\n                  watcher.onRemove = () => {\r\n                    localWatchers.forEach((watcherBlock) => {\r\n                      const {\r\n                        watcher,\r\n                        watchers\r\n                      } = watcherBlock;\r\n                      const index1 = watchersToRemove.indexOf(watcherBlock);\r\n                      const index2 = watchers.indexOf(watcher);\r\n\r\n                      if (index1 !== -1) {\r\n                        watchersToRemove.splice(index1, 1);\r\n                      }\r\n\r\n                      if (index2 !== -1) {\r\n                        watchers.splice(index2, 1);\r\n                      }\r\n                    });\r\n                  };\r\n\r\n                  localWatchers.push(watcherBlock);\r\n                  watchersToRemove.push(watcherBlock);\r\n                  watchers.push(watcher);\r\n                });\r\n\r\n                evalMode = false;\r\n                getting = new Arr([]);\r\n              }\r\n\r\n              store.$$.expr = null;\r\n              document.DwayneStore = null;\r\n\r\n              return result;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    const args = new Super(originalArgs).map((value, arg) => {\r\n      if (name === 'd-each' && (\r\n        arg === 'item'\r\n        || arg === 'index'\r\n        || arg === 'uid'\r\n      )) {\r\n        return value;\r\n      }\r\n\r\n      const forDElements = name === 'd-elements' && arg === 'value';\r\n\r\n      return parentScope.$$.evaluate(value, (value) => {\r\n        this.args[arg] = value;\r\n      }, this, forDElements, forDElements && parentBlock.$$.name === '#d-item');\r\n    }).$;\r\n\r\n    this.args = args;\r\n    this.children = children || new Arr([]);\r\n    this.global = Object.create(\r\n      parentScope\r\n        ? Object.create(parentScope.global)\r\n        : null\r\n    );\r\n\r\n    this.$$.elems.start.$[0].DwayneBlock = this;\r\n    this.$$.elems.end.$[0].DwayneBlock = this;\r\n\r\n    if (parentBlock) {\r\n      parentBlock.$$.children.push(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @method Block#afterConstruct\r\n   * @public\r\n   * @description Is called after block construction (including all scopes)\r\n   * but before rendering the block and its children.\r\n   */\r\n  afterConstruct() {}\r\n\r\n  /**\r\n   * @method Block#afterRender\r\n   * @public\r\n   * @description Is called after block has been rendered.\r\n   */\r\n  afterRender() {}\r\n\r\n  /**\r\n   * @method Block#afterRender\r\n   * @public\r\n   * @description Is called before the block removal.\r\n   */\r\n  beforeRemove() {}\r\n\r\n  evaluateAndWatch(expression, callback) {\r\n    return this.$$.parent.$$.evaluate(expression, callback, this);\r\n  }\r\n\r\n  evaluateOnce(expression) {\r\n    return this.$$.parent.$$.evaluate(expression);\r\n  }\r\n\r\n  /**\r\n   * @method Block#remove\r\n   * @public\r\n   * @description Method fot forcing the block to be removed. Calls\r\n   * remove method for all of its child blocks and calls beforeRemove function.\r\n   */\r\n  remove(isParentSignal) {\r\n    const {\r\n      name,\r\n      parentBlock,\r\n      children,\r\n      mixins,\r\n      elems: {\r\n        start,\r\n        content,\r\n        end\r\n      },\r\n      watchersToRemove\r\n    } = this.$$;\r\n\r\n    removeWatchers(watchersToRemove);\r\n\r\n    children.forEach((child) => {\r\n      child.remove(true);\r\n    });\r\n\r\n    mixins.forEach((mixin) => {\r\n      mixin.remove(true);\r\n    });\r\n\r\n    try {\r\n      this.beforeRemove();\r\n    } catch (err) {\r\n      console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\r\n    }\r\n\r\n    if (!isParentSignal && parentBlock) {\r\n      const index = parentBlock.$$.children.indexOf(this);\r\n\r\n      if (index !== -1) {\r\n        parentBlock.$$.children.splice(index, 1);\r\n      }\r\n    }\r\n\r\n    new Elem([\r\n      start,\r\n      content,\r\n      end\r\n    ]).remove();\r\n  }\r\n\r\n  /**\r\n   * @method Block#watch\r\n   * @public\r\n   * @param {...String} [args] - Vars to watch (args, global or local).\r\n   * @param {Watcher} watcher - Called when watched vars are changed.\r\n   * @description Method for watching for vars. If no vars passed in arguments\r\n   * all vars are to be watched. Otherwise specified vars will be watched.\r\n   * Watchers should not be put inside the constructor. It is considered best\r\n   * practice to do it inside the {@link Block#afterConstruct} method.\r\n   * Note that these expressions (vars, i.e. \"args.arg\") are not to be\r\n   * evaluated so you cannot put there things like \"a[b]\" or any js code,\r\n   * only expressions like \"a\", \"b\", \"args.a\", \"args.b\" and \"global.a\", \"global.b\".\r\n   *\r\n   * @example\r\n   * class MyBlock extends Block {\r\n   *   static template = '<div />';\r\n   *\r\n   *   afterConstruct() {\r\n   *     this.watch('a', () => {});\r\n   *     this.watch('args.a', 'global.r', () => {});\r\n   *     this.watch(() => {});\r\n   *   }\r\n   * }\r\n   */\r\n  watch() {\r\n    const watcher = arguments[arguments.length - 1];\r\n\r\n    if (!isFunction(watcher)) {\r\n      return;\r\n    }\r\n\r\n    if (arguments.length === 1) {\r\n      for (const global in this.$$.global) {\r\n        /* eslint guard-for-in: 0 */\r\n        this.$$.global[global].watchers.perm.push(watcher);\r\n      }\r\n\r\n      iterate(this.$$.args, ({ watchers }) => {\r\n        watchers.perm.push(watcher);\r\n      });\r\n\r\n      return iterate(this.$$.locals, ({ watchers }) => {\r\n        watchers.perm.push(watcher);\r\n      });\r\n    }\r\n\r\n    iterate(arguments, (variable) => {\r\n      if (variable === watcher) {\r\n        return;\r\n      }\r\n\r\n      variable = `${ variable }`;\r\n\r\n      if (/^args\\./.test(variable)) {\r\n        variable = variable.replace(/^args\\./, '');\r\n\r\n        if (!this.$$.args[variable]) {\r\n          return;\r\n        }\r\n\r\n        this.$$.args[variable].watchers.perm.push(watcher);\r\n\r\n        return;\r\n      }\r\n\r\n      if (/^global\\./.test(variable)) {\r\n        variable = variable.replace(/^global\\./, '');\r\n\r\n        if (!this.$$.global[variable]) {\r\n          return;\r\n        }\r\n\r\n        this.$$.global[variable].watchers.perm.push(watcher);\r\n\r\n        return;\r\n      }\r\n\r\n      if (!this.$$.locals[variable]) {\r\n        return;\r\n      }\r\n\r\n      this.$$.locals[variable].watchers.perm.push(watcher);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Block#watchArgs\r\n   * @public\r\n   * @param {...String} [args] - Args to watch.\r\n   * @param {Watcher} watcher - Called when watched args are changed.\r\n   * @description Method for watching for args. If no args passed in arguments\r\n   * all args are to be watched. Otherwise specified args will be watched.\r\n   * Watchers should not be put inside the constructor. It is considered best\r\n   * practice to do it inside the {@link Block#afterConstruct} method.\r\n   *\r\n   * @example\r\n   * class MyBlock extends Block {\r\n   *   static template = '<div />';\r\n   *\r\n   *   afterConstruct() {\r\n   *     this.watchArgs('a', () => {});\r\n   *     this.watchArgs('a', 'b', () => {});\r\n   *     this.watchArgs(() => {});\r\n   *   }\r\n   * }\r\n   */\r\n  watchArgs() {\r\n    const watcher = arguments[arguments.length - 1];\r\n\r\n    if (!isFunction(watcher)) {\r\n      return;\r\n    }\r\n\r\n    if (arguments.length === 1) {\r\n      return iterate(this.$$.args, ({ watchers }) => {\r\n        watchers.perm.push(watcher);\r\n      });\r\n    }\r\n\r\n    iterate(arguments, (arg) => {\r\n      if (arg === watcher) {\r\n        return;\r\n      }\r\n\r\n      if (!this.$$.args[arg]) {\r\n        return;\r\n      }\r\n\r\n      this.$$.args[arg].watchers.perm.push(watcher);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Block#watchGlobal\r\n   * @public\r\n   * @param {...String} [globals] - Globals to watch.\r\n   * @param {Watcher} watcher - Called when watched globals are changed.\r\n   * @description Method for watching for globals. If no globals passed in arguments\r\n   * all globals are to be watched. Otherwise specified globals will be watched.\r\n   * Watchers should not be put inside the constructor. It is considered best\r\n   * practice to do it inside the {@link Block#afterConstruct} method.\r\n   *\r\n   * @example\r\n   * class MyBlock extends Block {\r\n   *   static template = '<div />';\r\n   *\r\n   *   afterConstruct() {\r\n   *     this.watchGlobal('a', () => {});\r\n   *     this.watchGlobal('a', 'b', () => {});\r\n   *     this.watchGlobal(() => {});\r\n   *   }\r\n   * }\r\n   */\r\n  watchGlobals() {\r\n    const watcher = arguments[arguments.length - 1];\r\n\r\n    if (!isFunction(watcher)) {\r\n      return;\r\n    }\r\n\r\n    if (arguments.length === 1) {\r\n      for (const global in this.$$.global) {\r\n        /* eslint guard-for-in: 0 */\r\n        this.$$.global[global].watchers.perm.push(watcher);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    iterate(arguments, (global) => {\r\n      if (global === watcher) {\r\n        return;\r\n      }\r\n\r\n      if (!this.$$.global[global]) {\r\n        return;\r\n      }\r\n\r\n      this.$$.global[global].watchers.perm.push(watcher);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Block#watchLocals\r\n   * @public\r\n   * @param {...String} [locals] - Locals to watch.\r\n   * @param {Watcher} watcher - Called when watched locals are changed.\r\n   * @description Method for watching for locals. If no locals passed in arguments\r\n   * all locals are to be watched. Otherwise specified locals will be watched.\r\n   * Watchers should not be put inside the constructor. It is considered best\r\n   * practice to do it inside the {@link Block#afterConstruct} method.\r\n   *\r\n   * @example\r\n   * class MyBlock extends Block {\r\n   *   static template = '<div />';\r\n   *\r\n   *   afterConstruct() {\r\n   *     this.watchLocals('a', () => {});\r\n   *     this.watchLocals('a', 'b', () => {});\r\n   *     this.watchLocals(() => {});\r\n   *   }\r\n   * }\r\n   */\r\n  watchLocals() {\r\n    const watcher = arguments[arguments.length - 1];\r\n\r\n    if (!isFunction(watcher)) {\r\n      return;\r\n    }\r\n\r\n    if (arguments.length === 1) {\r\n      return iterate(this.$$.locals, ({ watchers }) => {\r\n        watchers.perm.push(watcher);\r\n      });\r\n    }\r\n\r\n    iterate(arguments, (local) => {\r\n      if (local === watcher) {\r\n        return;\r\n      }\r\n\r\n      if (!this.$$.locals[local]) {\r\n        return;\r\n      }\r\n\r\n      this.$$.locals[local].watchers.perm.push(watcher);\r\n    });\r\n  }\r\n}\r\n\r\nregisterBuiltIns(Blocks, rootBlocks, Block);\r\n\r\nconst blocks = Block._blocks;\r\n\r\nclass Mixin {\r\n  static evaluate = true;\r\n\r\n  constructor(opts) {\r\n    const {\r\n      name,\r\n      value,\r\n      elem,\r\n      match,\r\n      parentBlock,\r\n      parentScope\r\n    } = opts;\r\n\r\n    Object.defineProperties(this, {\r\n      $$: {\r\n        value: {\r\n          name,\r\n          _value: value,\r\n          parent: parentScope,\r\n          parentBlock,\r\n          watchersToRemove: new Arr([])\r\n        }\r\n      }\r\n    });\r\n\r\n    this.match = new Arr(match).slice(1).$;\r\n    this.block = parentScope;\r\n    this.elem = elem;\r\n    this.node = elem.$[0];\r\n\r\n    if (parentBlock) {\r\n      parentBlock.$$.mixins.push(this);\r\n    }\r\n  }\r\n\r\n  afterUpdate() {}\r\n\r\n  beforeRemove() {}\r\n\r\n  evaluateAndWatch(callback) {\r\n    const {\r\n      _value,\r\n      parent\r\n    } = this.$$;\r\n\r\n    return parent.$$.evaluate(_value, callback, this);\r\n  }\r\n\r\n  evaluateOnce() {\r\n    const {\r\n      _value,\r\n      parent\r\n    } = this.$$;\r\n\r\n    return parent.$$.evaluate(_value);\r\n  }\r\n\r\n  /**\r\n   * @method Mixin#remove\r\n   * @public\r\n   * @description Method fot forcing the mixin to be removed.\r\n   */\r\n  remove(isParentSignal) {\r\n    const {\r\n      name,\r\n      parentBlock,\r\n      watchersToRemove\r\n    } = this.$$;\r\n\r\n    removeWatchers(watchersToRemove);\r\n\r\n    try {\r\n      this.beforeRemove();\r\n    } catch (err) {\r\n      console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\r\n    }\r\n\r\n    if (!isParentSignal && parentBlock) {\r\n      const index = parentBlock.$$.mixins.indexOf(this);\r\n\r\n      if (index !== -1) {\r\n        parentBlock.$$.mixins.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nregisterBuiltIns(Mixins, rootMixins, Mixin);\r\n\r\nconst mixins = Block._mixins;\r\n\r\nfunction initApp(block, node) {\r\n  if (!blocks[block]) {\r\n    throw new Error(`No \"${ block }\" block is registered! (initApp)`);\r\n  }\r\n\r\n  const start = doc.createComment(' d-root: start ');\r\n  const end = doc.createComment(' d-root: end ');\r\n  const parent = new Elem(node);\r\n\r\n  parent.html('');\r\n\r\n  new Elem([\r\n    start,\r\n    end\r\n  ]).into(parent);\r\n\r\n  createBlock({\r\n    node: {\r\n      name: block,\r\n      attrs: {},\r\n      children: new Arr([])\r\n    },\r\n    after: start,\r\n    parent\r\n  });\r\n}\r\n\r\nfunction registerBuiltIns(set, scope, proto) {\r\n  iterate(set, (register) => {\r\n    const {\r\n      name,\r\n      value\r\n    } = register(proto, createBlock);\r\n\r\n    if (proto === Block) {\r\n      value._html = deepCloneChildren(\r\n        markupToJSON(\r\n          `${ value.template || '' }`,\r\n          value.collapseWhiteSpace\r\n        )\r\n      );\r\n    } else {\r\n      value._match = new RegExp(`^${ new Str(name).escapeRegExp().$ }(?:-([\\\\s\\\\S]+))?$`);\r\n    }\r\n\r\n    scope[name] = value;\r\n  });\r\n}\r\n\r\nfunction createBlock({ node, after, parent, parentBlock, parentScope }) {\r\n  parentScope = (node && node.block) || parentScope;\r\n\r\n  const name = (node && node.name) || 'UnknownBlock';\r\n  const args = (node && node.attrs) || {};\r\n  const children = (node && node.children) || new Arr([]);\r\n  const elem = parent.prop('namespaceURI') === svgNS\r\n    ? doc.svg()\r\n    : new Elem(doc.template().$[0].content);\r\n  const localBlocks = parentScope ? parentScope.$$.ns._blocks : blocks;\r\n  const localMixins = parentScope ? parentScope.$$.ns._mixins : mixins;\r\n  let constructor = node && node.name && localBlocks[node.name];\r\n  let dBlockMatch;\r\n\r\n  if (!children.length && ((dBlockMatch = name.match(/^d-block-([\\s\\S]+)$/)) || name === 'd-block')) {\r\n    constructor = blocks['d-block'];\r\n    args.name = dBlockMatch ? dBlockMatch[1] : '{null}';\r\n  }\r\n\r\n  if (!constructor) {\r\n    const {\r\n      value,\r\n      children\r\n    } = node;\r\n\r\n    if (name === '#text' && expressionRegExp.test(value)) {\r\n      return createBlock({\r\n        node: {\r\n          name: 'd-text',\r\n          attrs: { value },\r\n          children: new Arr([]),\r\n          block: parentScope\r\n        },\r\n        after,\r\n        parent,\r\n        parentBlock,\r\n        parentScope\r\n      });\r\n    }\r\n\r\n    const element = elem.create(name);\r\n    const currentMixins = new Arr([]);\r\n\r\n    const attrs = new Super(args).object((object, value, attr) => {\r\n      let match;\r\n\r\n      for (const name in localMixins) {\r\n        const Mixin = localMixins[name];\r\n        const localMatch = attr.match(Mixin._match);\r\n\r\n        if (localMatch) {\r\n          match = {\r\n            match: localMatch,\r\n            Mixin,\r\n            name\r\n          };\r\n\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (match) {\r\n        currentMixins.push({\r\n          name: match.name,\r\n          Mixin: match.Mixin,\r\n          match: match.match,\r\n          value,\r\n          elem: element,\r\n          parentBlock,\r\n          parentScope\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      if (!value) {\r\n        object[attr] = '';\r\n\r\n        return;\r\n      }\r\n\r\n      object[attr] = parentScope.$$.evaluate(value, (value) => {\r\n        element.attr(attr, value);\r\n      }, parentBlock);\r\n    }).$;\r\n\r\n    if (!isNil(value)) {\r\n      element.text(value);\r\n    }\r\n\r\n    if (attrs) {\r\n      element.attr(attrs);\r\n    }\r\n\r\n    if (after.length) {\r\n      element.insertAfter(after);\r\n    } else {\r\n      element.into(parent);\r\n    }\r\n\r\n    after = new Elem();\r\n\r\n    if (children) {\r\n      transformDIfChildren(children).forEach((child) => {\r\n        const block = createBlock({\r\n          node: child,\r\n          after,\r\n          parent: element,\r\n          parentBlock,\r\n          parentScope\r\n        });\r\n\r\n        if (block instanceof Block) {\r\n          after = block.$$.elems.end;\r\n        } else {\r\n          after = block;\r\n        }\r\n      });\r\n    }\r\n\r\n    currentMixins.forEach((opts) => {\r\n      createMixin(opts);\r\n    });\r\n\r\n    return element;\r\n  }\r\n\r\n  const blockInstance = new constructor({\r\n    name,\r\n    args,\r\n    children,\r\n    parent,\r\n    parentBlock,\r\n    parentScope\r\n  });\r\n\r\n  Object.defineProperties(blockInstance, {\r\n    args: {\r\n      value: blockInstance.args\r\n    },\r\n    global: {\r\n      value: blockInstance.global\r\n    }\r\n  });\r\n\r\n  let html = name === 'd-elements'\r\n    ? new Arr(blockInstance.args.value || [])\r\n    : deepCloneChildren(constructor._html, blockInstance);\r\n\r\n  if (name === 'd-elements' && parentBlock.$$.name === '#d-item') {\r\n    html = deepCloneChildren(html, parentBlock);\r\n  }\r\n\r\n  const {\r\n    $$,\r\n    args: Args,\r\n    global,\r\n    ...locals\r\n  } = blockInstance;\r\n\r\n  delete locals.$;\r\n  delete locals.$$;\r\n\r\n  $$.args = constructPrivateScope(Args);\r\n  $$.locals = constructPrivateScope(locals);\r\n  $$.global = constructPrivateScope(global, 'global', parentScope);\r\n\r\n  if (name === '#d-item') {\r\n    const scopeValues = {\r\n      [node.itemName]: node.item,\r\n      [node.indexName]: node.index\r\n    };\r\n    let parent = blockInstance;\r\n    let scope = parentScope;\r\n    let DItemFound;\r\n\r\n    while (!DItemFound && (parent = parent.$$.parentBlock)) {\r\n      DItemFound = parent.$$.name === '#d-item';\r\n    }\r\n\r\n    if (DItemFound) {\r\n      scope = parent.$$.scope;\r\n    }\r\n\r\n    $$.ns = parentScope.$$.ns;\r\n    $$.privateScope = constructPrivateScope(scopeValues);\r\n    constructPublicScope($$.scope = Object.create(scope), scopeValues, $$.privateScope);\r\n  }\r\n\r\n  if (name === 'd-each') {\r\n    $$.scope = Object.create(parentScope);\r\n  }\r\n\r\n  constructPublicScope(Args, Args, $$.args);\r\n  constructPublicScope(global, global, $$.global);\r\n  constructPublicScope(blockInstance, locals, $$.locals);\r\n\r\n  try {\r\n    blockInstance.afterConstruct();\r\n  } catch (err) {\r\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\r\n  }\r\n\r\n  const elems = new Elem([\r\n    $$.elems.start,\r\n    $$.elems.end\r\n  ]);\r\n\r\n  if (after.length) {\r\n    elems.insertAfter(after);\r\n  } else {\r\n    elems.into(parent);\r\n  }\r\n\r\n  after = $$.elems.start;\r\n\r\n  transformDIfChildren(html).forEach((child) => {\r\n    const block = createBlock({\r\n      node: child,\r\n      after,\r\n      parent,\r\n      parentBlock: blockInstance,\r\n      parentScope\r\n    });\r\n\r\n    if (block instanceof Block) {\r\n      const { elems } = block.$$;\r\n\r\n      after = elems.end;\r\n\r\n      $$.elems.content.add(elems.start, elems.content, elems.end);\r\n    } else {\r\n      after = block;\r\n\r\n      $$.elems.content.add(block);\r\n    }\r\n  });\r\n\r\n  try {\r\n    blockInstance.afterRender();\r\n  } catch (err) {\r\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\r\n  }\r\n\r\n  return blockInstance;\r\n}\r\n\r\nfunction createMixin({ name, Mixin, value, match, elem, parentBlock, parentScope }) {\r\n  const mixin = new Mixin({\r\n    name,\r\n    value,\r\n    match,\r\n    elem,\r\n    parentBlock,\r\n    parentScope\r\n  });\r\n\r\n  if (Mixin.evaluate) {\r\n    const value = mixin.value = mixin.evaluateAndWatch((newValue, oldValue) => {\r\n      mixin.value = newValue;\r\n\r\n      try {\r\n        mixin.afterUpdate(newValue, oldValue);\r\n      } catch (err) {\r\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\r\n      }\r\n    });\r\n\r\n    mixin.afterUpdate(value);\r\n  }\r\n}\r\n\r\nfunction deepCloneChildren(children, block) {\r\n  return new Arr(children || []).map((child) => {\r\n    const {\r\n      name,\r\n      attrs,\r\n      value,\r\n      children\r\n    } = child;\r\n    const newChild = {\r\n      name,\r\n      value,\r\n      attrs: { ...attrs }\r\n    };\r\n\r\n    if (block) {\r\n      newChild.block = block;\r\n    }\r\n\r\n    if (children) {\r\n      newChild.children = deepCloneChildren(children, block);\r\n    }\r\n\r\n    return newChild;\r\n  });\r\n}\r\n\r\nfunction transformDIfChildren(children) {\r\n  return new Arr(children || [])\r\n    .concat({})\r\n    .object((object, child) => {\r\n      const { name } = child;\r\n      const {\r\n        html,\r\n        ifElse\r\n      } = object;\r\n\r\n      if (name !== 'd-else-if' && name !== 'd-else') {\r\n        if (ifElse) {\r\n          html.push({\r\n            name: 'd-if',\r\n            block: ifElse.$[0].block,\r\n            children: ifElse\r\n          });\r\n\r\n          object.ifElse = null;\r\n        }\r\n\r\n        if (name === 'd-if') {\r\n          object.ifElse = new Arr([child]);\r\n        } else if (!isUndefined(name)) {\r\n          html.push(child);\r\n        }\r\n      } else {\r\n        (ifElse || html).push(child);\r\n\r\n        if (name === 'd-else' && ifElse) {\r\n          html.push({\r\n            name: 'd-if',\r\n            block: ifElse.$[0].block,\r\n            children: ifElse\r\n          });\r\n\r\n          object.ifElse = null;\r\n        }\r\n      }\r\n    }, {\r\n      html: new Arr([]),\r\n      ifElse: null\r\n    }).$.html;\r\n}\r\n\r\nfunction isInstanceOfBlock(block) {\r\n  return isPrototypeOf.call(Block, block) && isPrototypeOf.call(Block.prototype, block.prototype);\r\n}\r\n\r\nfunction isInstanceOfMixin(mixin) {\r\n  return isPrototypeOf.call(Mixin, mixin) && isPrototypeOf.call(Mixin.prototype, mixin.prototype);\r\n}\r\n\r\nfunction removeWatchers(watchersToRemove) {\r\n  watchersToRemove.forEach(({ watcher, watchers }) => {\r\n    const index = watchers.indexOf(watcher);\r\n\r\n    if (index !== -1) {\r\n      watchers.splice(index, 1);\r\n    }\r\n  });\r\n}\r\n\r\nfunction constructPrivateScope(object, type, parentScope) {\r\n  let scope = {};\r\n\r\n  if (type === 'global') {\r\n    scope = Object.create(\r\n      parentScope\r\n        ? parentScope.$$.global\r\n        : null\r\n    );\r\n  }\r\n\r\n  return new Super(object).object((scope, value, key) => {\r\n    scope[key] = {\r\n      value,\r\n      watchers: {\r\n        temp: new Arr([]),\r\n        perm: new Arr([])\r\n      }\r\n    };\r\n  }, scope).$;\r\n}\r\n\r\nfunction constructPublicScope(scope, scopeValues, privateScope) {\r\n  new Super(scope).define(new Super(scopeValues).map((value, key) => {\r\n    const scope = privateScope[key];\r\n\r\n    return {\r\n      get() {\r\n        if (evalMode) {\r\n          if (getting.indexOf(scope.watchers.temp) === -1) {\r\n            getting.push(scope.watchers.temp);\r\n          }\r\n        }\r\n\r\n        return scope.value;\r\n      },\r\n      set(value) {\r\n        if (value === scope.value) {\r\n          return;\r\n        }\r\n\r\n        if (!changed) {\r\n          changed = [];\r\n        }\r\n\r\n        const oldTempWatchers = scope.watchers.temp.slice();\r\n        const oldValue = scope.value;\r\n\r\n        scope.watchers.temp = new Arr([]);\r\n        scope.value = value;\r\n\r\n        oldTempWatchers.forEach((watcher) => {\r\n          watcher.onRemove();\r\n          watcher();\r\n        });\r\n        changed.push({\r\n          scope,\r\n          oldValue,\r\n          value\r\n        });\r\n\r\n        setTimeout(() => {\r\n          if (!changed) {\r\n            return;\r\n          }\r\n\r\n          const was = new Arr([]);\r\n          const values = [];\r\n\r\n          for (let i = changed.length - 1; i >= 0; i--) {\r\n            const {\r\n              scope,\r\n              value,\r\n              oldValue\r\n            } = changed[i];\r\n\r\n            scope.watchers.perm.forEach((watcher) => {\r\n              const index = was.indexOf(watcher);\r\n\r\n              if (index === -1) {\r\n                was.push(watcher);\r\n                values.push({\r\n                  value,\r\n                  oldValue\r\n                });\r\n              } else {\r\n                values[index].oldValue = oldValue;\r\n              }\r\n            });\r\n\r\n            changed.splice(i, 1);\r\n          }\r\n\r\n          changed = null;\r\n\r\n          was.forEach((watcher, i) => {\r\n            const {\r\n              value,\r\n              oldValue\r\n            } = values[i];\r\n\r\n            watcher(value, oldValue);\r\n          });\r\n        }, 0);\r\n      }\r\n    };\r\n  }).$);\r\n}\r\n\r\nexport { Block, Mixin, initApp };\r\n","/**\r\n * @module constants/formats\r\n * @private\r\n * @description Exports different types of formatting for {@link Date#format}.\r\n */\r\n\r\nimport { Super } from '../Super';\r\nimport { Str } from '../Str';\r\n\r\nconst zero = new Str('0');\r\nconst daysOfTheWeekNames = [\r\n  'Sunday',\r\n  'Monday',\r\n  'Tuesday',\r\n  'Wednesday',\r\n  'Thursday',\r\n  'Friday',\r\n  'Saturday'\r\n];\r\nconst daysOfTheWeekAliases = new Super(daysOfTheWeekNames).map((value) => value.slice(0, 3)).$;\r\nconst monthsNames = [\r\n  'January',\r\n  'February',\r\n  'March',\r\n  'April',\r\n  'May',\r\n  'June',\r\n  'Jule',\r\n  'August',\r\n  'September',\r\n  'October',\r\n  'November',\r\n  'December'\r\n];\r\nconst monthsAliases = new Super(monthsNames).map((value) => value.slice(0, 3)).$;\r\n\r\n/**\r\n * @callback module:constants/formats~matchCallback\r\n * @param {Dat} date - D-wrap of a date to apply format to.\r\n * @param {String} string - Matched applied expression.\r\n */\r\n\r\n/**\r\n * @typedef {Object} module:constants/formats~formatExpr\r\n * @property {String} format - Matched format.\r\n * @property {module:constants/formats~matchCallback} match - Callback if there was a match.\r\n */\r\n\r\n/**\r\n * @type {module:constants/formats~formatExpr[]}\r\n * @description Array of different formats.\r\n */\r\nexport default [\r\n  {\r\n    format: 'ccc',\r\n    match: (date, utc) => round(date[utc]('c'), 3)\r\n  },\r\n  {\r\n    format: 'c',\r\n    match: (date, utc) => date[utc]('c')\r\n  },\r\n  {\r\n    format: 'ss',\r\n    match: (date, utc) => round(date[utc]('s'), 2)\r\n  },\r\n  {\r\n    format: 's',\r\n    match: (date, utc) => date[utc]('s')\r\n  },\r\n  {\r\n    format: 'mm',\r\n    match: (date, utc) => round(date[utc]('m'), 2)\r\n  },\r\n  {\r\n    format: 'm',\r\n    match: (date, utc) => date[utc]('m')\r\n  },\r\n  {\r\n    format: 'hh',\r\n    match: (date, utc) => round(date[utc]('h'), 2)\r\n  },\r\n  {\r\n    format: 'h',\r\n    match: (date, utc) => date[utc]('h')\r\n  },\r\n  {\r\n    format: 'dddd',\r\n    match: (date, utc) => daysOfTheWeekNames[date[utc]('dw')]\r\n  },\r\n  {\r\n    format: 'ddd',\r\n    match: (date, utc) => daysOfTheWeekAliases[date[utc]('dw')]\r\n  },\r\n  {\r\n    format: 'dd',\r\n    match: (date, utc) => round(date[utc]('d'), 2)\r\n  },\r\n  {\r\n    format: 'd',\r\n    match: (date, utc) => date[utc]('d')\r\n  },\r\n  {\r\n    format: 'MMMM',\r\n    match: (date, utc) => monthsNames[date[utc]('M') - 1]\r\n  },\r\n  {\r\n    format: 'MMM',\r\n    match: (date, utc) => monthsAliases[date[utc]('M') - 1]\r\n  },\r\n  {\r\n    format: 'MM',\r\n    match: (date, utc) => round(date[utc]('M'), 2)\r\n  },\r\n  {\r\n    format: 'M',\r\n    match: (date, utc) => date[utc]('M')\r\n  },\r\n  {\r\n    format: 'yyyy',\r\n    match: (date, utc) => round(date[utc]('y'), 4)\r\n  },\r\n  {\r\n    format: 'yy',\r\n    match: (date, utc) => String(date[utc]('y')).slice(-2)\r\n  },\r\n  {\r\n    format: 'y',\r\n    match: (date, utc) => date[utc]('y')\r\n  }\r\n];\r\n\r\n/**\r\n * @function round\r\n * @private\r\n * @param {Number} number - Number to round.\r\n * @param {Number} digits - Number of the digits of the output.\r\n * @returns {String} String with necessary additional starting zeroes.\r\n */\r\nfunction round(number, digits) {\r\n  const string = String(number);\r\n  let zeroes = digits - string.length;\r\n\r\n  zeroes = zeroes < 0 ? 0 : zeroes;\r\n\r\n  return zero.repeat(zeroes).$ + string;\r\n}\r\n","/**\r\n * @module Dat\r\n * @private\r\n * @mixin\r\n * @description Exports Dat class.\r\n */\r\n\r\nimport { Super } from './Super';\r\nimport { Num } from './Num';\r\nimport { Str } from './Str';\r\nimport { switcher } from './Switcher';\r\nimport { constructors } from './constants';\r\nimport formats from './constants/formats';\r\nimport { isDate, iterate, Symbol, defineProperties } from './helpers';\r\n\r\n/**\r\n * @typedef {*} DateLike\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} AddPeriod\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'dw'|'M'|'y'} GetPeriod\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} OfOnePeriod\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {'c'|'s'|'m'|'h'|'d'|'M'|'y'} SetPeriod\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {'ccc'|'c'|'ss'|'s'|'mm'|'m'|'hh'|'h'|'dddd'|'ddd'|'dd'|'d'|'MMMM'|'MMM'|'MM'|'M'|'yyyy'|'yy'|'y'} Format\r\n * @public\r\n */\r\n\r\nconst coeffs = {\r\n  c: 1,\r\n  s: 1000,\r\n  m: 60000,\r\n  h: 3600000,\r\n  d: 86400000,\r\n  w: 604800000,\r\n  M: 2592000000,\r\n  y: 31536000000\r\n};\r\n\r\nconst getSwitcher = switcher({\r\n  c: (date, utc) => date[`${ utc }Milliseconds`](),\r\n  s: (date, utc) => date[`${ utc }Seconds`](),\r\n  m: (date, utc) => date[`${ utc }Minutes`](),\r\n  h: (date, utc) => date[`${ utc }Hours`](),\r\n  d: (date, utc) => date[`${ utc }Date`](),\r\n  dw: (date, utc) => date[`${ utc }Day`](),\r\n  M: (date, utc) => date[`${ utc }Month`]() + 1,\r\n  y: (date, utc) => date[`${ utc }FullYear`]()\r\n}, 'equals', NaN);\r\nconst setSwitcher = switcher({\r\n  c: (date, value, utc) => date[`${ utc }Milliseconds`](value),\r\n  s: (date, value, utc) => date[`${ utc }Seconds`](value),\r\n  m: (date, value, utc) => date[`${ utc }Minutes`](value),\r\n  h: (date, value, utc) => date[`${ utc }Hours`](value),\r\n  d: (date, value, utc) => date[`${ utc }Date`](value),\r\n  M: (date, value, utc) => date[`${ utc }Month`](value - 1),\r\n  y: (date, value, utc) => date[`${ utc }FullYear`](value)\r\n});\r\n\r\n/**\r\n * @class Dat\r\n * @extends Super\r\n * @public\r\n * @param {Date} [date = new Date()] - A date to wrap.\r\n * @returns {Dat} Instance of Dat.\r\n * @description Wrap of a date.\r\n *\r\n * @example\r\n * const date = new Dat(new Date());\r\n */\r\nclass Dat extends Super {\r\n  constructor(date = new Date()) {\r\n    super(date);\r\n\r\n    /**\r\n     * @member Dat#$\r\n     * @type {Date}\r\n     * @public\r\n     * @description Original date.\r\n     */\r\n  }\r\n\r\n  /**\r\n   * @method Dat#add\r\n   * @public\r\n   * @param {AddPeriod|Object.<AddPeriod, Number>} what - What to add.\r\n   * @param {Number} [number] - Number of what to add if the first argument is a period string.\r\n   * @returns {Dat} Returns this.\r\n   * @description Method for adding amounts of time to the date. Returns new instance of Dat.\r\n   *\r\n   * @example\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add('c', 2).toISOString();         // '2000-01-01T00:00:00.001Z'\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).add({ c: 2, d: 5 }).toISOString(); // '2000-01-06T00:00:00.001Z'\r\n   */\r\n  add(what, number) {\r\n    if (arguments.length >= 2) {\r\n      what = { [what]: number };\r\n    }\r\n\r\n    return this.time(this.time() + new Super(what).sum((value, what) => coeffs[what] * value));\r\n  }\r\n\r\n  /**\r\n   * @method Dat#expires\r\n   * @public\r\n   * @param {*} [value = this] - Value to resolve after the date expires.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @description Method for defining when the date expires.\r\n   *\r\n   * @example\r\n   * new Dat().add('c', 500).expires('Expired').then((value) => {\r\n   *   // After 500 milliseconds\r\n   *   console.log(value); // 'Expired'\r\n   * });\r\n   */\r\n  expires(value) {\r\n    if (!arguments.length) {\r\n      value = this;\r\n    }\r\n\r\n    return new Num(this.$ - now()).timeout(value);\r\n  }\r\n\r\n  /**\r\n   * @method Dat#format\r\n   * @public\r\n   * @param {String} string - Template for the output.\r\n   * @param {String} [prefix = ''] - If needed [all special strings]{@link Format}\r\n   * are treated as they should be prefix with prefix.\r\n   * @returns {String} Formatted string.\r\n   * @description Method for creating formatted output based on a string.\r\n   *\r\n   * @example\r\n   * new Dat('1999-12-31T23:59:59.999Z').format('Seconds: $ss, milliseconds: $ccc.', '$');\r\n   * // 'Seconds: 59, milliseconds: 999.'\r\n   */\r\n  format(string, prefix = '') {\r\n    string = new Str(new Super(string).$);\r\n    prefix = String(new Super(prefix).$);\r\n\r\n    iterate(formats, (format) => {\r\n      string = string.replaceString(prefix + format.format, format.match(this, 'get'));\r\n    });\r\n\r\n    return string.$;\r\n  }\r\n\r\n  /**\r\n   * @method Dat#formatUTC\r\n   * @public\r\n   * @param {String} string - See {@link Dat#format}.\r\n   * @param {String} [prefix = ''] - See {@link Dat#format}.\r\n   * @returns {String} Formatted string.\r\n   * @description UTC version of {@link Dat#format}.\r\n   *\r\n   * @example\r\n   * new Dat('1999-07-07T03:09:09.099Z').formatUTC(\r\n   *   `\r\n   *     Milliseconds: $ccc|$c.\r\n   *     Seconds:      $ss|$s.\r\n   *     Minutes:      $mm|$m.\r\n   *     Hours:        $hh|$h.\r\n   *     Day:          $dddd|$ddd|$dd|$d.\r\n   *     Month:        $MMMM|$MMM|$MM|$M.\r\n   *     Year:         $yyyy|$yy|$y.\r\n   *   `,\r\n   *   '$'\r\n   * );\r\n   * // Milliseconds: 099|99.\r\n   * // Seconds:      09|9.\r\n   * // Minutes:      09|9.\r\n   * // Hours:        03|3.\r\n   * // Day:          Friday|Fri|07|7.\r\n   * // Month:        July|Jul|07|7.\r\n   * // Year:         1999|99|1999.\r\n   */\r\n  formatUTC(string, prefix = '') {\r\n    string = new Str(new Super(string).$);\r\n    prefix = String(new Super(prefix).$);\r\n\r\n    iterate(formats, (format) => {\r\n      string = string.replaceString(prefix + format.format, format.match(this, 'getUTC'));\r\n    });\r\n\r\n    return string.$;\r\n  }\r\n\r\n  /**\r\n   * @method Dat#get\r\n   * @public\r\n   * @param {GetPeriod} what - What to get.\r\n   * @returns {Number} Number of what to get.\r\n   * @description Method for getting values such as seconds or minutes.\r\n   *\r\n   * @example\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).get('s'); // 59\r\n   */\r\n  get(what) {\r\n    return getSwitcher(what, [this.$, 'get']);\r\n  }\r\n\r\n  /**\r\n   * @method Dat#getUTC\r\n   * @public\r\n   * @param {GetPeriod} what - See {@link Dat#get}.\r\n   * @returns {Number} Number of what to get.\r\n   * @description UTC version of {@link Dat#get}.\r\n   *\r\n   * @example\r\n   * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));\r\n   *\r\n   * date.getUTC('c');  // 999\r\n   * date.getUTC('s');  // 59\r\n   * date.getUTC('m');  // 59\r\n   * date.getUTC('h');  // 23\r\n   * date.getUTC('d');  // 31\r\n   * date.getUTC('dw'); // 5\r\n   * date.getUTC('M');  // 12\r\n   * date.getUTC('y');  // 1999\r\n   */\r\n  getUTC(what) {\r\n    return getSwitcher(what, [this.$, 'getUTC']);\r\n  }\r\n\r\n  /**\r\n   * @method Dat#isAfter\r\n   * @public\r\n   * @param {DateLike} date - Date to be compared to this date.\r\n   * @returns {Boolean} If this date is after the argument one.\r\n   * @description Finds out if this date is after the argument one.\r\n   *\r\n   * @example\r\n   * new Dat(new Date(333)).isAfter(new Date(334)); // false\r\n   * new Dat(new Date(333)).isAfter(new Date(332)); // true\r\n   */\r\n  isAfter(date) {\r\n    date = new Date(new Super(date).$);\r\n\r\n    return date.getTime() < this.$.getTime();\r\n  }\r\n\r\n  /**\r\n   * @method Dat#isBefore\r\n   * @public\r\n   * @param {DateLike} date - Date to be compared to this date.\r\n   * @returns {Boolean} If this date is before the argument one.\r\n   * @description Finds out if this date is before the argument one.\r\n   *\r\n   * @example\r\n   * new Dat(new Date(333)).isBefore(new Date(334)); // true\r\n   * new Dat(new Date(333)).isBefore(new Date(332)); // false\r\n   */\r\n  isBefore(date) {\r\n    date = new Date(new Super(date).$);\r\n\r\n    return date.getTime() > this.$.getTime();\r\n  }\r\n\r\n  /**\r\n   * @method Dat#isBetween\r\n   * @public\r\n   * @param {DateLike} date1 - Start of the range.\r\n   * @param {DateLike} date2 - End of the range.\r\n   * @returns {Boolean} If this date is after date1 and before date2.\r\n   * @description Finds out if this date is after date1 and before date2.\r\n   *\r\n   * @example\r\n   * new Dat(new Date(333)).isBetween(new Date(332), new Date(334)); // true\r\n   * new Dat(new Date(333)).isBetween(new Date(334), new Date(332)); // false\r\n   */\r\n  isBetween(date1, date2) {\r\n    const time = this.$.getTime();\r\n\r\n    date1 = new Date(new Super(date1).$);\r\n    date2 = new Date(new Super(date2).$);\r\n\r\n    return time > date1.getTime() && time < date2.getTime();\r\n  }\r\n\r\n  /**\r\n   * @method Dat#isInvalid\r\n   * @public\r\n   * @returns {Boolean} If the date is invalid.\r\n   * @description Returns if the date is invalid.\r\n   *\r\n   * @example\r\n   * new Dat(new Date('a')).isInvalid(); // true\r\n   * new Dat(new Date(1)).isInvalid();   // false\r\n   */\r\n  isInvalid() {\r\n    return this.$.toString() === 'Invalid Date';\r\n  }\r\n\r\n  /**\r\n   * @method Dat#isPassed\r\n   * @public\r\n   * @returns {Boolean} If the date is passed.\r\n   * @description Returns if the date is passed.\r\n   *\r\n   * @example\r\n   * new Dat(new Date(1)).isPassed(); // true\r\n   */\r\n  isPassed() {\r\n    return this.isBefore(now());\r\n  }\r\n\r\n  /**\r\n   * @method Dat#ofOne\r\n   * @public\r\n   * @param {OfOnePeriod} what - Period to check.\r\n   * @param {DateLike} date - Date to check.\r\n   * @returns {Boolean} If two dates are of one second, minute or something else.\r\n   * @description Returns if two dates are of one second, minute or something else.\r\n   *\r\n   * @example\r\n   * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:59.333Z')); // true\r\n   * new Dat(new Date('1999-12-31T23:59:59.000Z')).ofOne('s', new Date(1999-12-31T23:59:58.999Z')); // false\r\n   */\r\n  ofOne(what, date) {\r\n    if (!(what in coeffs) || what === 'w') {\r\n      return false;\r\n    }\r\n\r\n    date = new Dat(new Date(date));\r\n\r\n    let started;\r\n\r\n    return iterate(coeffs, (coeff, w) => {\r\n      if (w === what) {\r\n        started = true;\r\n      }\r\n\r\n      if (!started || w === 'w') {\r\n        return;\r\n      }\r\n\r\n      if (started && this.get(w) !== date.get(w)) {\r\n        return false;\r\n      }\r\n    }) !== false;\r\n  }\r\n\r\n  /**\r\n   * @method Dat#set\r\n   * @public\r\n   * @param {SetPeriod|Object.<SetPeriod, Number>} what - What to add.\r\n   * @param {Number} [number] - Number of what to set if the first argument is a period string.\r\n   * @returns {Dat} Returns this.\r\n   * @description Method for setting values such as seconds or minutes.\r\n   *\r\n   * @example\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).set('s', 58).get('s');           // 58\r\n   * new Dat(new Date('1999-12-31T23:59:59.999Z')).set({ c: 998, s: 58 }).get('c'); // 998\r\n   */\r\n  set(what, number) {\r\n    const date = this.$;\r\n\r\n    if (arguments.length >= 2) {\r\n      what = { [what]: number };\r\n    }\r\n\r\n    what = new Super(what).$;\r\n\r\n    iterate(what, (value, what) => {\r\n      setSwitcher(what, [date, value, 'set']);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Dat#setUTC\r\n   * @public\r\n   * @param {SetPeriod|Object.<SetPeriod, Number>} what - See {@link Dat#set}.\r\n   * @param {Number} [number] - See {@link Dat#set}.\r\n   * @returns {Dat} Returns this.\r\n   * @description UTC version of {@link Dat#set}.\r\n   *\r\n   * @example\r\n   * const date = new Dat(new Date('1999-12-31T23:59:59.999Z'));\r\n   *\r\n   * date.setUTC('ccc', 998).getUTC('ccc'); // 998\r\n   * date.setUTC({\r\n   *   s: 58,\r\n   *   m: 58,\r\n   *   h: 22\r\n   * });\r\n   *\r\n   * date.getUTC('s'); // 58\r\n   * date.getUTC('m'); // 58\r\n   * date.getUTC('h'); // 23\r\n   */\r\n  setUTC(what, number) {\r\n    const date = this.$;\r\n\r\n    if (arguments.length >= 2) {\r\n      what = { [what]: number };\r\n    }\r\n\r\n    what = new Super(what).$;\r\n\r\n    iterate(what, (value, what) => {\r\n      setSwitcher(what, [date, value, 'setUTC']);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Dat#setUTC\r\n   * @public\r\n   * @param {Number} [time] - Time to set.\r\n   * @returns {Dat|Number} - If the time argument is present this is returned otherwise the time is returned.\r\n   * @description Synonym for both\r\n   * [Date#getTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime} and\r\n   * [Date#setTime]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime}.\r\n   */\r\n  time(time) {\r\n    const date = this.$;\r\n\r\n    if (arguments.length) {\r\n      date.setTime(time);\r\n    }\r\n\r\n    return date.getTime();\r\n  }\r\n\r\n  toISOString() {\r\n    return this.$.toISOString();\r\n  }\r\n\r\n  toLocaleString() {\r\n    return this.$.toLocaleString();\r\n  }\r\n\r\n  toString() {\r\n    return this.$.toString();\r\n  }\r\n\r\n  valueOf() {\r\n    return this.$.valueOf();\r\n  }\r\n}\r\ndefineProperties(Dat.prototype, {\r\n  [Symbol.toStringTag]: 'Dat'\r\n});\r\n\r\nconstructors[1].push({\r\n  check: isDate,\r\n  cls: Dat\r\n});\r\n\r\n/**\r\n * @function now\r\n * @public\r\n * @returns {Number} Number of milliseconds.\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now\r\n * @description Synonym for\r\n * [Date.now]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now}.\r\n */\r\nfunction now() {\r\n  return Date.now();\r\n}\r\n\r\n/**\r\n * @function date\r\n * @public\r\n * @param {DateLike} [date = new Date()] - Date-like value that is passed to the Date constructor.\r\n * @returns {Dat} New instance of Dat.\r\n * @description Synonym for new Dat(new Date(date));\r\n */\r\nfunction date(date) {\r\n  if (!arguments.length) {\r\n    return new Dat(new Date(now()));\r\n  }\r\n\r\n  date = new Super(date).$;\r\n\r\n  return new Dat(new Date(date));\r\n}\r\n\r\nexport { Dat, now, date };\r\n","/**\r\n * @module helpers/constructURL\r\n * @private\r\n * @description Exports constructURL method.\r\n */\r\n\r\nimport { Arr } from '../Arr';\r\nimport { Str } from '../Str';\r\nimport { switcher } from '../Switcher';\r\nimport { isArray, isObject, isPlainObject } from './checkTypes';\r\nimport { iterate } from './iterate';\r\n\r\n/**\r\n * @type {RegExp}\r\n * @description Absolute URL pattern.\r\n */\r\nconst absoluteURLRegexp = /^(([a-z][a-z\\d+\\-.]*:)?\\/\\/|data:[a-z]+\\/[a-z]+;base64,)/i;\r\nconst querySwitcher = switcher('call', () => new Arr([]))\r\n  .case(isArray, (prefix, query) => {\r\n    let queryParams = new Arr([]);\r\n\r\n    iterate(query, (value) => {\r\n      if (isPlainObject(value) || isArray(value)) {\r\n        queryParams = queryParams.concat(querySwitcher(value, [`${ prefix }[]`]));\r\n\r\n        return;\r\n      }\r\n\r\n      queryParams.push({\r\n        param: `${ prefix }[]`,\r\n        value\r\n      });\r\n    });\r\n\r\n    return queryParams.$;\r\n  })\r\n  .case(isPlainObject, (prefix, query) => {\r\n    let queryParams = new Arr([]);\r\n\r\n    iterate(query, (value, param) => {\r\n      if (isPlainObject(value) || isArray(value)) {\r\n        queryParams = queryParams.concat(querySwitcher(value, [prefix ? `${ prefix }[${ param }]` : param]));\r\n\r\n        return;\r\n      }\r\n\r\n      queryParams.push({\r\n        param: prefix ? `${ prefix }[${ param }]` : param,\r\n        value: isObject(value) ? JSON.stringify(value) : String(value)\r\n      });\r\n    });\r\n\r\n    return queryParams.$;\r\n  });\r\n\r\n/**\r\n * @function constructURL\r\n * @param {String} baseURL - BaseURL of the output URL.\r\n * @param {String} url - Main part of the output URL.\r\n * @param {Object} params - Params to replace in the url expressions like \":param\".\r\n * @param {Object} query - Object with query params.\r\n * @param {Object} [hash = ''] - URL hash.\r\n * @param {Object} [encodeOptions = {}] - If you need to encode something.\r\n * @param {Object} [encodeOptions.params = true] - If you need to encode params.\r\n * @param {Object} [encodeOptions.query = true] - If you need to encode query params.\r\n * @returns {String} Constructed URL.\r\n * @description Function for constructing URL from the base URL, URL, params and query params.\r\n */\r\nexport default (baseURL, url, params, query, hash = '', encodeOptions = {}) => {\r\n  const {\r\n    params: encodeParams = true,\r\n    query: encodeQuery = true\r\n  } = encodeOptions;\r\n  let URL = isAbsolute(url)\r\n    ? url\r\n    : `${ String(baseURL).replace(/\\/+$/, '') }/${ String(url).replace(/^\\/+/, '') }`;\r\n\r\n  iterate(params, (value, param) => {\r\n    URL = new Str(URL).replaceString(`:${ param }`, encode(value, encodeParams)).$;\r\n  });\r\n\r\n  const queryParams = querySwitcher(query, ['']);\r\n\r\n  if (queryParams.length) {\r\n    URL += (URL.indexOf('?') === -1 ? '?' : '&') + queryParams\r\n      .map(({ param, value }) => `${ encode(param, encodeQuery) }=${ encode(value, encodeQuery) }`)\r\n      .join('&');\r\n  }\r\n\r\n  return `${ URL }${ hash ? `#${ hash }` : '' }`;\r\n};\r\n\r\n/**\r\n * @function isAbsolute\r\n * @param {String} url - URL to check if it is absolute or not.\r\n * @returns {Boolean} If the argument URL is absolute or not.\r\n */\r\nfunction isAbsolute(url) {\r\n  return absoluteURLRegexp.test(url);\r\n}\r\n\r\n/**\r\n * @function encode\r\n * @param {String} string - String to encode using encodeURIComponent.\r\n * @param {Boolean} isEncoded - If the string should be encoded.\r\n * @returns {String} Encoded string.\r\n */\r\nfunction encode(string, isEncoded) {\r\n  return isEncoded ? encodeURIComponent(string) : string;\r\n}\r\n","/**\r\n * @module Fetch\r\n * @private\r\n * @mixin\r\n * @description Exports Fetch class.\r\n */\r\n\r\nimport { Promise } from './Promise';\r\nimport { Super } from './Super';\r\nimport { Arr } from './Arr';\r\nimport { Str } from './Str';\r\nimport {\r\n  isArray, isFunction, isString,\r\n  assign, Symbol, validate, iterate, defineProperties\r\n} from './helpers';\r\nimport constructURL from './helpers/constructURL';\r\nimport parseHeaders from './helpers/parseHeaders';\r\nimport transformData from './helpers/transformData';\r\n\r\n/**\r\n * @typedef {'get'|'post'|'delete'|'head'|'put'|'patch'} FetchMethod\r\n * @public\r\n */\r\n\r\n/**\r\n * @typedef {Object} FetchConfig\r\n * @public\r\n * @property {Array.<AfterMiddleware|FetchErrorAfterMiddleware>} [after]\r\n * @property {Object} [auth]\r\n * @property {String} [auth.username]\r\n * @property {String} [auth.password]\r\n * @property {String} [baseURL]\r\n * @property {Array.<BeforeMiddleware|FetchErrorBeforeMiddleware>} [before]\r\n * @property {*} [data]\r\n * @property {Object.<String, String[]>} [headers]\r\n * @property {FetchMethod} [method]\r\n * @property {Object} [params]\r\n * @property {Object} [query]\r\n * @property {String} [responseType]\r\n * @property {Number} [timeout]\r\n * @property {String} [url]\r\n * @property {Boolean} [withCredentials]\r\n */\r\n\r\n/**\r\n * @typedef {Object} FetchResponse\r\n * @public\r\n * @property {FetchConfig} config\r\n * @property {*} data\r\n * @property {Object.<String, String>} headers\r\n * @property {Number} status\r\n * @property {String} statusText\r\n * @property {XMLHttpRequest} xhr\r\n */\r\n\r\n/**\r\n * @callback FetchAfterMiddleware\r\n * @public\r\n * @param {FetchResponse} config - Fetch response.\r\n */\r\n\r\n/**\r\n * @callback FetchErrorAfterMiddleware\r\n * @public\r\n * @param {Error|*} err - Thrown error.\r\n * @param {FetchResponse} config - Fetch response.\r\n */\r\n\r\n/**\r\n * @callback FetchBeforeMiddleware\r\n * @public\r\n * @param {FetchConfig} config - Fetch config.\r\n */\r\n\r\n/**\r\n * @callback FetchErrorBeforeMiddleware\r\n * @public\r\n * @param {Error|*} err - Thrown error.\r\n * @param {FetchConfig} config - Fetch config.\r\n */\r\n\r\n/**\r\n * @callback FetchConfigFunction\r\n * @public\r\n * @param {FetchConfig} config\r\n */\r\n\r\nconst defaults = {\r\n  after: [],\r\n  auth: {\r\n    username: '',\r\n    password: ''\r\n  },\r\n  baseURL: global.location.origin,\r\n  before: [],\r\n  data: null,\r\n  headers: {},\r\n  method: 'get',\r\n  params: {},\r\n  query: {},\r\n  responseType: '',\r\n  timeout: 0,\r\n  url: '',\r\n  withCredentials: false\r\n};\r\nconst uploadMethods = new Arr(['post', 'put']);\r\n\r\n/**\r\n * @class Fetch\r\n * @extends Function\r\n * @public\r\n * @param {FetchConfig} [config = {}] - A number to wrap.\r\n * @returns {Fetch} Instance of Fetch.\r\n * An instance of Fetch is a function that simply calls #request with the same arguments.\r\n * @description Class for fetching data.\r\n *\r\n * @example\r\n * const fetch = new Fetch();\r\n *\r\n * fetch('/data').then((res) => {\r\n *   console.log(res);\r\n * });\r\n */\r\nclass Fetch extends Function {\r\n  constructor(config = {}) {\r\n    super();\r\n\r\n    function fetch() {\r\n      return fetch.request.apply(fetch, arguments);\r\n    }\r\n\r\n    const conf = new Super({}).deepAssign(defaults, config).$;\r\n\r\n    if (conf.before.indexOf(fetchBeforeMiddleware) === -1) {\r\n      conf.before.push(fetchBeforeMiddleware);\r\n    }\r\n\r\n    /**\r\n     * @member {FetchConfig} Fetch#$$\r\n     * @type {FetchConfig}\r\n     * @public\r\n     * @description Fetch config.\r\n     */\r\n    Object.defineProperty(fetch, '$$', { value: conf });\r\n    Object.setPrototypeOf(fetch, Fetch.prototype);\r\n\r\n    return fetch;\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#after\r\n   * @public\r\n   * @param {FetchAfterMiddleware|FetchErrorAfterMiddleware} middleware - Middleware to add.\r\n   * @param {Boolean|*} [afterAll = true] - Boolean parameter where to put the middleware.\r\n   * Truthy parameter stands for \"to the end\" and falsey for \"to the beginning\".\r\n   * @returns {Fetch} Returns this.\r\n   * @description Middleware that is called after the request.\r\n   * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.\r\n   * If the middleware returns a promise it becomes a part of the middleware chain.\r\n   *\r\n   * @example\r\n   * const fetch = new Fetch()\r\n   *   .after((err, res) => {\r\n   *     console.log(err);\r\n   *\r\n   *     throw err;\r\n   *   })\r\n   *   .after((res) => {\r\n   *     res.json = D(res.data).parseJSON():\r\n   *   });\r\n   */\r\n  after(middleware, afterAll = true) {\r\n    validate([middleware], ['function'], 'Fetch#after');\r\n\r\n    const { after } = this.$$;\r\n\r\n    if (afterAll) {\r\n      after.push(middleware);\r\n    } else {\r\n      after.unshift(middleware);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#before\r\n   * @public\r\n   * @param {FetchBeforeMiddleware|FetchErrorBeforeMiddleware} middleware - Middleware to add.\r\n   * @param {Boolean|*} [beforeAll = true] - Boolean parameter where to put the middleware.\r\n   * Truthy parameter stands for \"to the beginning\" and falsey for \"to the end\".\r\n   * @returns {Fetch} Returns this.\r\n   * @description Middleware that is called before the request.\r\n   * If the middleware has 2 or less arguments it's treated as success middleware otherwise as an error one.\r\n   * If the middleware returns a promise it becomes a part of the middleware chain.\r\n   *\r\n   * @example\r\n   * const fetch = new Fetch()\r\n   *   .before((err, req) => {\r\n   *     console.log(err);\r\n   *\r\n   *     throw err;\r\n   *   })\r\n   *   .before((req) => {\r\n   *     if (req.url === '/veryLongRequest') {\r\n   *       req.timeout = 30000;\r\n   *     }\r\n   *   });\r\n   */\r\n  before(middleware, beforeAll = true) {\r\n    validate([middleware], ['function'], 'Fetch#before');\r\n\r\n    const { before } = this.$$;\r\n\r\n    if (beforeAll) {\r\n      before.unshift(middleware);\r\n    } else {\r\n      before.push(middleware);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#config\r\n   * @public\r\n   * @param {String|FetchConfig|FetchConfigFunction} [property] - If it's a function\r\n   * it's called with the fetch config argument, if it's a string the value argument\r\n   * is used for assigning this property to the fetch config\r\n   * otherwise it's assigned to the fetch config.\r\n   * @param {*} [value] - See the property argument.\r\n   * @returns {Fetch|FetchConfig} If the argument is present this is returned otherwise the fetch config is returned.\r\n   * @description Method for getting and setting config.\r\n   *\r\n   * @example\r\n   * const fetch = new Fetch();\r\n   *\r\n   * fetch.config({ baseURL: 5000 });\r\n   * fetch.config().timeout; // 5000\r\n   *\r\n   * fetch.config((config) => {\r\n   *   config.baseURL += '/api';\r\n   * });\r\n   */\r\n  config(property, value) {\r\n    const conf = this.$$;\r\n\r\n    if (!arguments.length) {\r\n      return conf;\r\n    }\r\n\r\n    if (isFunction(property)) {\r\n      property(conf);\r\n    } else {\r\n      if (arguments.length >= 2) {\r\n        property = { [property]: value };\r\n      }\r\n\r\n      new Super(conf).deepAssign(property);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#delete\r\n   * @public\r\n   * @param {String} [url] - See {@link Fetch#request}.\r\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n   * @description Shorthand for #request for delete requests.\r\n   *\r\n   * @example\r\n   * new Fetch().delete('/data').then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  delete(url, config = {}) {\r\n    if (!isString(url)) {\r\n      config = url;\r\n      url = undefined;\r\n    }\r\n\r\n    return this.request(url, assign({ method: 'delete' }, config));\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#get\r\n   * @public\r\n   * @param {String} [url] - See {@link Fetch#request}.\r\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n   * @description Shorthand for #request for get requests.\r\n   *\r\n   * @example\r\n   * new Fetch().get('/data').then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  get(url, config = {}) {\r\n    if (!isString(url)) {\r\n      config = url;\r\n      url = undefined;\r\n    }\r\n\r\n    return this.request(url, assign({ method: 'get' }, config));\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#head\r\n   * @public\r\n   * @param {String} [url] - See {@link Fetch#request}.\r\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n   * @description Shorthand for #request for head requests.\r\n   *\r\n   * @example\r\n   * new Fetch().head('/data').then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  head(url, config = {}) {\r\n    if (!isString(url)) {\r\n      config = url;\r\n      url = undefined;\r\n    }\r\n\r\n    return this.request(url, assign({ method: 'head' }, config));\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#headers\r\n   * @public\r\n   * @param {String|Object.<String, String|String[]>} header - A header string or an object of the following format:\r\n   * { [header]: [value1, value2, ...] }.\r\n   * @param {String|String[]} [value] - Header value. If the first argument is a string\r\n   * this has to be a header value or an array of header values.\r\n   * @returns {Fetch} Returns this.\r\n   * @description Method for setting request headers.\r\n   *\r\n   * @example\r\n   * const fetch = new Fetch()\r\n   *   .headers('Header1', 'Value')\r\n   *   .headers('Header2', ['Value1', 'Value2'])\r\n   *   .headers({\r\n   *     Header3: ['Value1', 'Value2']\r\n   *   });\r\n   */\r\n  headers(header, value) {\r\n    const { headers } = this.$$;\r\n\r\n    if (arguments.length >= 2) {\r\n      header = { [header]: value };\r\n    }\r\n\r\n    iterate(header, (value, header) => {\r\n      const array = headers[header] || [];\r\n      const toPush = isArray(value) ? value : [value];\r\n\r\n      (headers[header] = array).push.apply(array, toPush);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#instance\r\n   * @public\r\n   * @param {FetchConfig} [config] - New config if needed.\r\n   * @returns {Fetch} New instance of Fetch.\r\n   * @description Method for creating new fetch instances based on already existent.\r\n   *\r\n   * @example\r\n   * const mainFetch = new Fetch({\r\n   *   baseURL: '//other.domain.com/api',\r\n   *   withCredentials: true\r\n   * });\r\n   *\r\n   * const longFetch = mainFetch.instance({\r\n   *   timeout: 10000\r\n   * });\r\n   */\r\n  instance(config = {}) {\r\n    const dataConfig = new Super(config).hasOwn('data')\r\n      ? { data: config.data }\r\n      : {};\r\n\r\n    delete config.data;\r\n\r\n    const conf = new Super({})\r\n      .deepAssign(this.$$, config)\r\n      .assign(dataConfig)\r\n      .$;\r\n\r\n    return new Fetch(conf);\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#patch\r\n   * @public\r\n   * @param {String} [url] - See {@link Fetch#request}.\r\n   * @param {*} [data] - Additional parameter for uploading data.\r\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n   * @description Shorthand for #request for head requests.\r\n   *\r\n   * @example\r\n   * new Fetch().patch('/data', { user: 'John' }).then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  patch(url, data = {}, config = {}) {\r\n    if (arguments.length && !isString(url)) {\r\n      config = data;\r\n      data = url;\r\n      url = undefined;\r\n    }\r\n\r\n    return this.request(url, assign({ method: 'patch', data }, config));\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#post\r\n   * @public\r\n   * @param {String} [url] - See {@link Fetch#request}.\r\n   * @param {*} [data] - Additional parameter for uploading data.\r\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n   * @description Shorthand for #request for head requests.\r\n   *\r\n   * @example\r\n   * new Fetch().post('/data', { user: 'John' }).then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  post(url, data = {}, config = {}) {\r\n    if (arguments.length && !isString(url)) {\r\n      config = data;\r\n      data = url;\r\n      url = undefined;\r\n    }\r\n\r\n    return this.request(url, assign({ method: 'post', data }, config));\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#put\r\n   * @public\r\n   * @param {String} [url] - See {@link Fetch#request}.\r\n   * @param {*} [data] - Additional parameter for uploading data.\r\n   * @param {FetchConfig} [config] - See {@link Fetch#request}.\r\n   * @returns {Promise.<FetchResponse, Error>} See {@link Fetch#request}.\r\n   * @description Shorthand for #request for head requests.\r\n   *\r\n   * @example\r\n   * new Fetch().put('/data', { user: 'John' }).then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  put(url, data = {}, config = {}) {\r\n    if (arguments.length && !isString(url)) {\r\n      config = data;\r\n      data = url;\r\n      url = undefined;\r\n    }\r\n\r\n    return this.request(url, assign({ method: 'put', data }, config));\r\n  }\r\n\r\n  /**\r\n   * @method Fetch#request\r\n   * @public\r\n   * @param {String} [url] - URL for the request.\r\n   * @param {FetchConfig} [config] - Additional config for this particular request.\r\n   * @returns {Promise.<FetchResponse, Error>} Promise that is resolved with the request response.\r\n   * @description Main function for making requests. All request methods call this method\r\n   * including the fetch instance itself.\r\n   *\r\n   * @example\r\n   * const fetch = new Fetch();\r\n   *\r\n   * fetch.request('/data', { timeout: 1000 }).then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   *\r\n   * fetch.request({ timeout: 1000 }).then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   *\r\n   * fetch.request().then((res) => {\r\n   *   console.log(res);\r\n   * });\r\n   */\r\n  request(url, config = {}) {\r\n    if (arguments.length === 1 && !isString(url)) {\r\n      config = url;\r\n    }\r\n\r\n    const dataConfig = new Super(config).hasOwn('data')\r\n      ? { data: config.data }\r\n      : {};\r\n    const urlConfig = isString(url)\r\n      ? { url }\r\n      : {};\r\n\r\n    delete config.data;\r\n\r\n    const conf = new Super(this.$$)\r\n      .deepClone()\r\n      .deepAssign(urlConfig, config)\r\n      .assign(dataConfig)\r\n      .$;\r\n\r\n    let xhr;\r\n    let promise = Promise.resolve();\r\n\r\n    iterate(conf.before, (middleware) => {\r\n      promise = promise.then(() => {\r\n        if (middleware.length >= 2) {\r\n          return Promise.resolve();\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n          resolve(middleware(conf));\r\n        });\r\n      }, (err) => {\r\n        if (middleware.length < 2) {\r\n          return Promise.reject(err);\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n          resolve(middleware(err, conf));\r\n        });\r\n      });\r\n    });\r\n\r\n    promise = promise.then(() => new Promise((resolve, reject) => {\r\n      const {\r\n        after,\r\n        auth: {\r\n          username,\r\n          password\r\n        },\r\n        data,\r\n        headers,\r\n        method,\r\n        onprogress,\r\n        responseType,\r\n        timeout,\r\n        url,\r\n        withCredentials\r\n      } = conf;\r\n\r\n      xhr = new XMLHttpRequest();\r\n\r\n      xhr.open(method, url, true, username, password);\r\n\r\n      iterate(headers, (value, header) => {\r\n        xhr.setRequestHeader(header, value);\r\n      });\r\n\r\n      if (onprogress) {\r\n        if (uploadMethods.indexOfStrict(method) === -1) {\r\n          xhr.onprogress = onprogress;\r\n        } else {\r\n          xhr.upload.onprogress = onprogress;\r\n        }\r\n      }\r\n\r\n      xhr.onabort = () => {\r\n        const error = new Error('Request was aborted');\r\n\r\n        error.type = 'ABORT_ERROR';\r\n\r\n        reject(error);\r\n\r\n        xhr = null;\r\n      };\r\n\r\n      xhr.onerror = () => {\r\n        const error = new Error('Network error');\r\n\r\n        error.type = 'NETWORK_ERROR';\r\n\r\n        reject(error);\r\n\r\n        xhr = null;\r\n      };\r\n\r\n      xhr.ontimeout = () => {\r\n        const error = new Error('Request time exceeded');\r\n\r\n        error.type = 'TIMEOUT_ERROR';\r\n\r\n        reject(error);\r\n\r\n        xhr = null;\r\n      };\r\n\r\n      xhr.onreadystatechange = () => {\r\n        if (!xhr || !xhr.status || xhr.readyState !== 4) {\r\n          return;\r\n        }\r\n\r\n        const response = {\r\n          config: conf,\r\n          data: !responseType || responseType === 'text' ? xhr.responseText : xhr.response,\r\n          headers: parseHeaders(xhr.getAllResponseHeaders()),\r\n          status: xhr.status === 1223 ? 204 : xhr.status,\r\n          statusText: xhr.status === 1223 ? 'No Content' : xhr.statusText,\r\n          xhr\r\n        };\r\n\r\n        let promise = Promise.resolve();\r\n\r\n        iterate(after, (middleware) => {\r\n          promise = promise.then(() => {\r\n            if (middleware.length >= 2) {\r\n              return Promise.resolve();\r\n            }\r\n\r\n            return new Promise((resolve) => {\r\n              resolve(middleware(response));\r\n            });\r\n          }, (err) => {\r\n            if (middleware.length < 2) {\r\n              return Promise.reject(err);\r\n            }\r\n\r\n            return new Promise((resolve) => {\r\n              resolve(middleware(err, response));\r\n            });\r\n          });\r\n        });\r\n\r\n        resolve(promise\r\n          .then(() => response)\r\n          .catch((err) => {\r\n            try {\r\n              err.response = response;\r\n            } catch (e) {\r\n              throw err;\r\n            }\r\n\r\n            throw err;\r\n          })\r\n        );\r\n      };\r\n\r\n      xhr.responseType = responseType;\r\n      xhr.timeout = Number(timeout) || 0;\r\n      xhr.withCredentials = !!withCredentials;\r\n\r\n      xhr.send(data);\r\n    }));\r\n\r\n    promise.abort = function abort() {\r\n      if (xhr) {\r\n        xhr.abort();\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\n    return promise;\r\n  }\r\n}\r\n\r\ndefineProperties(Fetch.prototype, {\r\n  [Symbol.toStringTag]: 'Fetch'\r\n});\r\n\r\n/**\r\n * @function fetchBeforeMiddleware\r\n * @private\r\n * @param {FetchConfig} config\r\n * @description Built-in before middleware for url, data, method, headers construction.\r\n */\r\nfunction fetchBeforeMiddleware(config) {\r\n  const {\r\n    baseURL,\r\n    data,\r\n    headers,\r\n    method,\r\n    params,\r\n    query,\r\n    url\r\n  } = config;\r\n  const METHOD = method.toUpperCase();\r\n\r\n  config.method = METHOD;\r\n  config.url = constructURL(baseURL, url, params, query);\r\n  config.data = transformData(data, METHOD, headers);\r\n  config.headers = new Super(headers).object((headers, values, header) => {\r\n    header = new Str(header)\r\n      .toCapitalCase()\r\n      .replace(/\\s+/g, '-')\r\n      .$;\r\n\r\n    headers[header] = values.join(', ');\r\n  }).$;\r\n}\r\n\r\n/**\r\n * @const {Fetch} fetch\r\n * @type {Fetch}\r\n * @public\r\n * @description Empty instance of Fetch.\r\n */\r\nconst fetch = new Fetch();\r\n\r\nexport { Fetch, fetch };\r\n","/**\n * @module Router\n * @private\n * @mixin\n * @description Exports Router.\n */\n\nimport { Arr } from './Arr';\nimport { Elem, win } from './Elem';\nimport { self } from './Func';\nimport { Str } from './Str';\nimport { Super } from './Super';\nimport { switcher } from './Switcher';\nimport { assign, isNil, isRegExp, isString } from './helpers';\nimport constructURL from './helpers/constructURL';\nimport resolveURL from './helpers/resolveURL';\n\nconst Routes = new Arr([]);\nconst currentRoutes = new Arr([]);\nconst subscribers = new Super({});\nconst {\n  history,\n  location,\n  location: {\n    origin,\n    href\n  }\n} = global;\nlet initialized;\nlet pushed;\nlet wasRoot;\nlet wasDefault;\nlet rootRoute;\nlet redirectRoute;\nlet RedirectRoute;\nlet defaultRoute;\nlet DefaultRoute;\nlet currentRoute;\nlet currentRouteParams;\n\nconst pathSwitcher = switcher('call', () => {\n  throw new Error('State path must be a string, a regular expression or undefined! (at registerState)');\n})\n  .case(isRegExp, (path) => ({\n    path: path.source.replace(/\\\\\\//g, '/'),\n    url: path,\n    params: {}\n  }))\n  .case(isNil, () => ({\n    path: '/',\n    url: '/',\n    params: {}\n  }))\n  .case(isString, (path) => {\n    if (path.indexOf('/')) {\n      throw new Error('If route path is a string it must start with \"/\"! (at registerState)');\n    }\n\n    const index = path.indexOf('?');\n    const params = new Super({});\n    let newURL = '';\n    const newPath = new Str(path)\n      .slice(0, index === -1 ? path.length : index)\n      .replace(/^\\/|\\/$/g)\n      .split(/\\//)\n      .map((part, i, array) => {\n        if (!part && array.length > 1) {\n          throw new Error('If route path is a string it must not contain \"//\" or end with \"/\"! (at makeRoute)');\n        }\n\n        const index = part.indexOf(':');\n\n        if (index > 0) {\n          throw new Error('If route path is a string resource part must be either a string or an URL parameter! (at makeRoute)');\n        }\n\n        if (index === -1) {\n          return {\n            url: part,\n            value: part\n          };\n        }\n\n        const {\n          name,\n          regexp = /[^/]*/\n        } = resolveParameter(\n          part.slice(1),\n          'URL parameter must not be an empty string or contain characters besides \"a-zA-Z_$\"! (at makeRoute)',\n          'URL parameter regexp validator must be within parentheses (e.g. :userId(\\\\d+) and not contain ones)! (at makeRoute)'\n        );\n\n        params.$[name] = params.count;\n\n        return {\n          type: 'param',\n          url: `:${ name }`,\n          value: regexp\n        };\n      })\n      .word(({ type, url, value }) => {\n        let newPath;\n\n        if (type === 'param') {\n          newPath = `(${ value.source.replace(/\\\\\\//g, '/') })`;\n        } else {\n          newPath = new Str(value).escapeRegExp().$;\n        }\n\n        newURL += `/${ url }`;\n\n        return `/${ newPath }`;\n      });\n\n    return {\n      path: newPath,\n      url: newURL,\n      params: params.$\n    };\n  });\n\nclass Route {\n  constructor(options) {\n    options = options || {};\n\n    const {\n      name,\n      path = '/',\n      abstract = false,\n      parent,\n      decodeQuery = true,\n      encodeQuery = true,\n      decodeParams = true,\n      encodeParams = true\n    } = options || {};\n    const {\n      url: relativeURL,\n      path: relativePath,\n      params\n    } = pathSwitcher(path);\n    const query = {};\n\n    new Super(this).assign({\n      name,\n      parentName: parent,\n      abstract: !!abstract,\n      children: new Arr([]),\n      decodeParams: !!decodeParams,\n      decodeQuery: !!decodeQuery,\n      encodeParams: !!encodeParams,\n      encodeQuery: !!encodeQuery,\n      params,\n      query,\n      relativePath,\n      relativeURL\n    });\n\n    const index = isString(path) ? path.indexOf('?') : -1;\n\n    if (index !== -1) {\n      new Str(path)\n        .replace(/&$/)\n        .slice(index + 1)\n        .split('&')\n        .forEach((param) => {\n          const {\n            name,\n            regexp = /[\\s\\S]*/\n          } = resolveParameter(\n            param,\n            'Query parameter must not be an empty string or contain characters besides \"a-zA-Z_$\"! (at makeRoute)',\n            'Query parameter regexp validator must be within parentheses (e.g. :userId(\\\\d+)) and not contain them! (at makeRoute)'\n          );\n\n          query[name] = new RegExp(`^${ regexp.source.replace(/\\\\\\//g, '/') }$`);\n        });\n    }\n\n    if (name === defaultRoute && (\n        new Super(params).count\n        || new Super(query).count\n      )) {\n      throw new Error('Default route must not have URL or query params! (at makeRoute)');\n    }\n  }\n}\n\nconst baseRoute = new Route();\n\nfunction initRouter() {\n  if (initialized) {\n    return;\n  }\n\n  initialized = true;\n  RedirectRoute = (Routes.find(({ name }) => name === redirectRoute) || {}).value;\n  DefaultRoute = (Routes.find(({ name }) => name === defaultRoute) || {}).value;\n\n  if (redirectRoute && !RedirectRoute) {\n    throw new Error(`There is no specified fallback route (\"${ redirectRoute }\")! (at initRouter)`);\n  }\n\n  Routes\n    .forEach((route) => {\n      const {\n        parentName,\n        name\n      } = route;\n      const ParentName = parentName || rootRoute;\n      const { value: parent } = Routes.find(({ name }) => name === ParentName) || {};\n\n      if (!parent) {\n        throw new Error(`No such parent route (\"${ ParentName }\") found for the route (\"${ name }\")! (at initRouter)`);\n      }\n\n      if (!parent.abstract && name !== rootRoute) {\n        throw new Error(`Parent route must be abstract (for \"${ name }\")! (at initRouter)`);\n      }\n\n      if (name !== rootRoute) {\n        route.parentName = ParentName;\n      }\n\n      route.parent = name === rootRoute\n        ? baseRoute\n        : parent;\n    })\n    .forEach((route) => {\n      const {\n        name,\n        parent: {\n          params: parentParams,\n          query: parentQuery,\n          path\n        },\n        params,\n        query,\n        relativeURL,\n        relativePath\n      } = route;\n      let proto = route;\n      let count = 0;\n      let newPath = relativePath;\n      let newURL = '';\n\n      if (isRegExp(path)) {\n        throw new Error('URL regexp route cannot be extended! (at initRouter)');\n      }\n\n      while (proto = proto.parent) {\n        count += new Super(proto.params).count;\n        newPath = proto.relativePath + newPath;\n        newURL = proto.relativeURL + newURL;\n\n        proto.children.push(route);\n      }\n\n      newPath = new RegExp(`^${ newPath.replace(/\\/+/g, '/').replace(/\\/$/, '') || '/' }$`);\n      newURL = isRegExp(relativeURL)\n        ? newPath\n        : (newURL + relativeURL).replace(/\\/+/g, '/').replace(/\\/$/, '') || '/';\n\n      new Super(query).proto(parentQuery);\n      new Super(params)\n        .proto(parentParams)\n        .forEach((value, key, params) => {\n          params[key] += count;\n        });\n\n      if (name === defaultRoute && (\n          new Super(params).count\n          || new Super(query).count\n        )) {\n        throw new Error('Default route must not have URL or query params! (at initRouter)');\n      }\n\n      route.url = newURL;\n      route.validatePath = newPath;\n    });\n\n  changeRoute();\n\n  win.on({\n    popstate() {\n      if (location.href !== href) {\n        pushed = true;\n      }\n\n      if (pushed) {\n        changeRoute();\n      }\n    },\n    click(e) {\n      const closestLink = new Elem(e.target).closest('a');\n\n      if (closestLink.length && closestLink.attr('target') !== '_blank') {\n        const push = !closestLink.hasAttr('replace');\n\n        e.preventDefault();\n\n        forward(closestLink.attr('href') || '', push);\n      }\n    }\n  });\n}\n\nfunction makeRoute(options) {\n  return (Block) => {\n    options = assign({}, options, Block.routerOptions);\n\n    const {\n      name,\n      path,\n      abstract,\n      root,\n      fallbackTo,\n      default: isDefault\n    } = options || {};\n\n    if (initialized) {\n      console.warn('Router was already initialized (at makeRoute)');\n\n      return self;\n    }\n\n    if (wasRoot && root) {\n      throw new Error(`There can't be two root routes (\"${ rootRoute }\" and \"${ name }\")! (at makeRoute)`);\n    }\n\n    if (wasDefault && isDefault) {\n      throw new Error(`There can't be two default routes (\"${ defaultRoute }\" and \"${ name }\")! (at makeRoute)`);\n    }\n\n    if (!name) {\n      throw new Error('State must have a non-empty string \"name\" property! (at makeRoute)');\n    }\n\n    if (Routes.some(({ name: Name }) => Name === name)) {\n      throw new Error('State must have unique \"name\" property! (at makeRoute)');\n    }\n\n    if (root) {\n      wasRoot = true;\n      rootRoute = name;\n      options.parent = null;\n\n      if (fallbackTo) {\n        redirectRoute = fallbackTo;\n      }\n    }\n\n    if (isDefault) {\n      wasDefault = true;\n      defaultRoute = name;\n\n      if (abstract) {\n        throw new Error('Default route can\\'t be abstract! (at makeRoute)');\n      }\n\n      if (isRegExp(path)) {\n        throw new Error('Default route can\\'t have a regexp path! (at makeRoute)');\n      }\n    }\n\n    const route = new Route(options);\n\n    Routes.push(route);\n\n    let unsubscribe;\n    let routeLoaded;\n\n    return class extends Block {\n      /* eslint prefer-template: 0 */\n      static template = '<div'\n        + ` class=\"dwayne-route route-${ name }\"`\n        + ' d-class=\"{{ \\'active-route\\': __isCurrentRoute__ }}\"'\n        + ' d-show=\"{__isCurrentRoute__}\"'\n        + '>'\n        + Block.template\n        + '</div>';\n\n      constructor(opts) {\n        super(opts);\n\n        if (root) {\n          initRouter();\n\n          const router = {\n            buildURL(name, options = {}) {\n              const { value: route } = Routes.find(({ name: n }) => n === name) || {};\n\n              if (!route) {\n                throw new Error(`There are no routes with name \"${ name }\"! (at router.buildURL)`);\n              }\n\n              const {\n                url,\n                encodeParams,\n                encodeQuery\n              } = route;\n\n              if (isRegExp(url)) {\n                throw new Error('URL can be built only from the string URLs! (at router.buildURL)');\n              }\n\n              const {\n                params = {},\n                query = {},\n                hash = ''\n              } = options;\n\n              return constructURL(origin, url, params, query, hash, {\n                params: encodeParams,\n                query: encodeQuery\n              });\n            },\n            go(name, options) {\n              forward(router.buildURL(name, options), true);\n            },\n            goToURL(url) {\n              forward(url, true);\n            },\n            pushURL(url) {\n              changeHistory(url, true);\n            },\n            redirect(name, options) {\n              forward(router.buildURL(name, options));\n            },\n            redirectToURL(url) {\n              forward(url);\n            },\n            replaceURL(url) {\n              changeHistory(url);\n            }\n          };\n\n          this.global.router = router;\n        }\n\n        this.__routerInstance__ = route;\n        this.__isCurrentRoute__ = (\n          route === currentRoute\n          || route.children.indexOf(currentRoute) !== -1\n        );\n        this.args.route = currentRouteParams;\n\n        routeLoaded = false;\n        unsubscribe = subscribe(name, () => {\n          const isCurrentRoute = (\n            route === currentRoute\n            || route.children.indexOf(currentRoute) !== -1\n          );\n\n          if (isCurrentRoute) {\n            callBeforeLoad(this);\n          } else {\n            callBeforeLeave(this);\n          }\n\n          if (route === currentRoute) {\n            this.args.route = currentRouteParams;\n          }\n\n          this.__isCurrentRoute__ = isCurrentRoute;\n        });\n\n        if (this.__isCurrentRoute__) {\n          callBeforeLoad(this);\n        }\n      }\n\n      beforeRemove() {\n        unsubscribe();\n        unsubscribe = null;\n        callBeforeLeave(this);\n        super.beforeRemove();\n      }\n    };\n\n    function callBeforeLoad(route) {\n      if (routeLoaded) {\n        return;\n      }\n\n      const block = {\n        $$: {\n          children: new Arr([route])\n        }\n      };\n\n      block.$$.children.forEach(function beforeLoad(block) {\n        const route = block.__routerInstance__;\n\n        if (route) {\n          const index = currentRoutes.indexOf(block);\n          const isCurrentRoute = (\n            route === currentRoute\n            || route.children.indexOf(currentRoute) !== -1\n          );\n\n          if (index !== -1 || !isCurrentRoute) {\n            return;\n          }\n\n          currentRoutes.push(block);\n        }\n\n        const {\n          name,\n          children,\n          mixins\n        } = block.$$;\n\n        if (children) {\n          children.forEach(beforeLoad);\n        }\n\n        if (mixins) {\n          mixins.forEach(beforeLoad);\n        }\n\n        if (block.beforeLoadRoute) {\n          try {\n            block.beforeLoadRoute();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeLeave:`, err);\n          }\n        }\n      });\n\n      routeLoaded = true;\n    }\n\n    function callBeforeLeave(route) {\n      if (!routeLoaded) {\n        return;\n      }\n\n      const block = {\n        $$: {\n          children: new Arr([route])\n        }\n      };\n\n      block.$$.children.forEach(function beforeLeave(block) {\n        const route = block.__routerInstance__;\n\n        if (route) {\n          const index = currentRoutes.indexOf(block);\n          const isCurrentRoute = (\n            route === currentRoute\n            || route.children.indexOf(currentRoute) !== -1\n          );\n\n          if (index === -1 || isCurrentRoute) {\n            return;\n          }\n\n          currentRoutes.splice(index, 1);\n        }\n\n        const {\n          name,\n          children,\n          mixins\n        } = block.$$;\n\n        if (children) {\n          children.forEach(beforeLeave);\n        }\n\n        if (mixins) {\n          mixins.forEach(beforeLeave);\n        }\n\n        if (block.beforeLeaveRoute) {\n          try {\n            block.beforeLeaveRoute();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeLeave:`, err);\n          }\n        }\n      });\n\n      routeLoaded = false;\n    }\n  };\n}\n\nfunction subscribe(name, callback) {\n  subscribers.$[name] = callback;\n\n  return () => {\n    subscribers.delete(name);\n  };\n}\n\nfunction forward(url, push) {\n  changeHistory(url, push);\n  changeRoute();\n}\n\nfunction changeRoute() {\n  const route = findRouteByURL();\n\n  if (route) {\n    ({\n      route: currentRoute,\n      ...currentRouteParams\n    } = route);\n    assign(currentRouteParams, {\n      name: currentRoute.name,\n      host: location.host,\n      hostname: location.hostname,\n      href: location.href,\n      origin: location.origin,\n      pathname: location.pathname,\n      port: location.port,\n      protocol: location.protocol,\n      search: location.search\n    });\n  } else {\n    if (redirectRoute) {\n      const {\n        url,\n        encodeParams,\n        encodeQuery\n      } = RedirectRoute;\n\n      return forward(constructURL(origin, url, {}, {}, '', {\n        params: encodeParams,\n        query: encodeQuery\n      }));\n    }\n\n    currentRoute = null;\n    currentRouteParams = null;\n  }\n\n  subscribers.forEach((callback) => callback());\n}\n\nfunction findRouteByURL() {\n  const pathname = location.pathname || '/';\n  const search = location.search || '';\n  let urlParams;\n\n  Routes.some((route) => {\n    if (route.abstract) {\n      return;\n    }\n\n    const {\n      url: routeURL,\n      validatePath,\n      params,\n      query: requiredQuery,\n      decodeParams,\n      decodeQuery\n    } = route;\n    const resolved = resolveURL(decodeQuery);\n    const query = new Super(resolved.query);\n    const eventualParams = {};\n    const match = (\n      (pathname.replace(/\\/$/, '') || '/') +\n      (isRegExp(routeURL) ? search : '')\n    ).match(validatePath);\n\n    if (!match) {\n      return;\n    }\n\n    /* eslint guard-for-in: 0 */\n    for (const param in requiredQuery) {\n      if (!query.hasOwn(param) || !requiredQuery[param].test(query.$[param])) {\n        return;\n      }\n    }\n\n    match.shift();\n\n    for (const param in params) {\n      eventualParams[param] = decode(match[params[param]], decodeParams);\n    }\n\n    urlParams = {\n      route,\n      params: eventualParams,\n      query: query.$,\n      hash: resolved.hash\n    };\n\n    return true;\n  });\n\n  if (urlParams) {\n    return urlParams;\n  }\n\n  if (!defaultRoute) {\n    return;\n  }\n\n  return {\n    route: DefaultRoute,\n    params: {},\n    ...resolveURL(DefaultRoute.decodeQuery)\n  };\n}\n\nfunction decode(string, decodeParams) {\n  return decodeParams\n    ? decodeURIComponent(string)\n    : string;\n}\n\nfunction changeHistory(url, push) {\n  try {\n    history[push ? 'pushState' : 'replaceState'](null, null, url);\n    pushed = true;\n  } catch (err) {\n    location.href = url;\n  }\n}\n\nfunction resolveParameter(param, nameErrorName, valueErrorName) {\n  const nameMatch = param.match(/^[a-z_$]+/i);\n\n  if (!nameMatch) {\n    throw new Error(nameErrorName);\n  }\n\n  const name = nameMatch[0];\n  const value = param.slice(name.length);\n  let regexp;\n\n  if (value && (value.indexOf('(') || value.indexOf(')') !== value.length - 1)) {\n    throw new Error(valueErrorName);\n  }\n\n  if (value) {\n    regexp = new RegExp(value.slice(1, -1));\n  }\n\n  return {\n    name,\n    regexp\n  };\n}\n\nexport { makeRoute };\n","/* eslint no-nested-ternary: 0 */\r\n/* eslint no-negated-condition: 0 */\r\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\r\n","/**\r\n * @module constants/appliedRegExps\r\n * @private\r\n * @description Exports different types of syntax for {@link Elem#apply}.\r\n */\r\n\r\n/**\r\n * @callback matchAppliedExprCallback\r\n * @param {Elem} elem - D-elem of an element to apply expression to.\r\n * @param {String} string - Matched applied name.\r\n * @param {String} arg - Argument within the parentheses.\r\n */\r\n\r\n/**\r\n * @type {Object.<String, matchAppliedExprCallback|Object.<String, matchAppliedExprCallback>>}\r\n * @description Object of different types of syntax.\r\n */\r\n\r\nexport const appliedRegExps = {\r\n  '#'(elem, id) {\r\n    elem.id(id);\r\n  },\r\n  '.'(elem, cls) {\r\n    elem.addClass(cls);\r\n  },\r\n  $(elem, attr, value) {\r\n    elem.attr(attr, value);\r\n  },\r\n  '@'(elem, prop, value) {\r\n    elem.css(prop, value);\r\n  },\r\n  '&'(elem, name, html) {\r\n    elem.html(html);\r\n  },\r\n  '*'(elem, name, text) {\r\n    elem.text(text);\r\n  },\r\n  '-': {\r\n    '.'(elem, cls) {\r\n      elem.removeClass(cls);\r\n    },\r\n    $(elem, attr) {\r\n      elem.removeAttr(attr);\r\n    },\r\n    '@'(elem, prop) {\r\n      elem.removeCSS(prop);\r\n    }\r\n  }\r\n};\r\n","/**\r\n * @module constants/elements\r\n * @private\r\n * @description Exports different canvas methods for {@link Elem} for creating html-elements.\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {String[]}\r\n */\r\nexport const canvasGetMethods = [\r\n  /**\r\n   * @member {Function} Elem#createImageData\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {ImageData|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createImageData\r\n   */\r\n  'createImageData',\r\n\r\n  /**\r\n   * @member {Function} Elem#createLinearGradient\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {CanvasGradient|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createLinearGradient\r\n   */\r\n  'createLinearGradient',\r\n\r\n  /**\r\n   * @member {Function} Elem#createPattern\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {CanvasPattern|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createPattern\r\n   */\r\n  'createPattern',\r\n\r\n  /**\r\n   * @member {Function} Elem#createRadialGradient\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {CanvasGradient|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/createRadialGradient\r\n   */\r\n  'createRadialGradient',\r\n\r\n  /**\r\n   * @member {Function} Elem#getImageData\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {ImageData|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getImageData\r\n   */\r\n  'getImageData',\r\n\r\n  /**\r\n   * @member {Function} Elem#getLineDash\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Number[]|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/getLineDash\r\n   */\r\n  'getLineDash',\r\n\r\n  /**\r\n   * @member {Function} Elem#isPointInPath\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Boolean|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInPath\r\n   */\r\n  'isPointInPath',\r\n\r\n  /**\r\n   * @member {Function} Elem#isPointInStroke\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Boolean|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/isPointInStroke\r\n   */\r\n  'isPointInStroke',\r\n\r\n  /**\r\n   * @member {Function} Elem#measureText\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {TextMetrics|void}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/measureText\r\n   */\r\n  'measureText'\r\n];\r\n\r\nexport const canvasRestMethods = [\r\n  /**\r\n   * @member {Function} Elem#arc\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arc\r\n   */\r\n  'arc',\r\n\r\n  /**\r\n   * @member {Function} Elem#arcTo\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/arcTo\r\n   */\r\n  'arcTo',\r\n\r\n  /**\r\n   * @member {Function} Elem#beginPath\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/beginPath\r\n   */\r\n  'beginPath',\r\n\r\n  /**\r\n   * @member {Function} Elem#bezierCurveTo\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo\r\n   */\r\n  'bezierCurveTo',\r\n\r\n  /**\r\n   * @member {Function} Elem#clearRect\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clearRect\r\n   */\r\n  'clearRect',\r\n\r\n  /**\r\n   * @member {Function} Elem#clip\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/clip\r\n   */\r\n  'clip',\r\n\r\n  /**\r\n   * @member {Function} Elem#closePath\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/closePath\r\n   */\r\n  'closePath',\r\n\r\n  /**\r\n   * @member {Function} Elem#drawFocusIfNeeded\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawFocusIfNeeded\r\n   */\r\n  'drawFocusIfNeeded',\r\n\r\n  /**\r\n   * @member {Function} Elem#drawImage\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawImage\r\n   */\r\n  'drawImage',\r\n\r\n  /**\r\n   * @member {Function} Elem#ellipse\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/ellipse\r\n   */\r\n  'ellipse',\r\n\r\n  /**\r\n   * @member {Function} Elem#fill\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fill\r\n   */\r\n  'fill',\r\n\r\n  /**\r\n   * @member {Function} Elem#fillRect\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillRect\r\n   */\r\n  'fillRect',\r\n\r\n  /**\r\n   * @member {Function} Elem#fillText\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/fillText\r\n   */\r\n  'fillText',\r\n\r\n  /**\r\n   * @member {Function} Elem#lineTo\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineTo\r\n   */\r\n  'lineTo',\r\n\r\n  /**\r\n   * @member {Function} Elem#moveTo\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/moveTo\r\n   */\r\n  'moveTo',\r\n\r\n  /**\r\n   * @member {Function} Elem#putImageData\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/putImageData\r\n   */\r\n  'putImageData',\r\n\r\n  /**\r\n   * @member {Function} Elem#quadraticCurveTo\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/quadraticCurveTo\r\n   */\r\n  'quadraticCurveTo',\r\n\r\n  /**\r\n   * @member {Function} Elem#rect\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rect\r\n   */\r\n  'rect',\r\n\r\n  /**\r\n   * @member {Function} Elem#resetTransform\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/resetTransform\r\n   */\r\n  'resetTransform',\r\n\r\n  /**\r\n   * @member {Function} Elem#restore\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/restore\r\n   */\r\n  'restore',\r\n\r\n  /**\r\n   * @member {Function} Elem#rotate\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/rotate\r\n   */\r\n  'rotate',\r\n\r\n  /**\r\n   * @member {Function} Elem#save\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/save\r\n   */\r\n  'save',\r\n\r\n  /**\r\n   * @member {Function} Elem#scale\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/scale\r\n   */\r\n  'scale',\r\n\r\n  /**\r\n   * @member {Function} Elem#setLineDash\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setLineDash\r\n   */\r\n  'setLineDash',\r\n\r\n  /**\r\n   * @member {Function} Elem#setTransform\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/setTransform\r\n   */\r\n  'setTransform',\r\n\r\n  /**\r\n   * @member {Function} Elem#stroke\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/stroke\r\n   */\r\n  'stroke',\r\n\r\n  /**\r\n   * @member {Function} Elem#strokeRect\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeRect\r\n   */\r\n  'strokeRect',\r\n\r\n  /**\r\n   * @member {Function} Elem#strokeText\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/strokeText\r\n   */\r\n  'strokeText',\r\n\r\n  /**\r\n   * @member {Function} Elem#transform\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/transform\r\n   */\r\n  'transform',\r\n\r\n  /**\r\n   * @member {Function} Elem#translate\r\n   * @type {Function}\r\n   * @param {...*} args\r\n   * @returns {Elem}\r\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/translate\r\n   */\r\n  'translate'\r\n];\r\n","/**\r\n * @module constants/constructors\r\n * @private\r\n * @description Exports constructors levels.\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {Array[]}\r\n */\r\nexport const constructors = [\r\n  [],\r\n  [],\r\n  []\r\n];\r\n","/**\r\n * @module constants/elements\r\n * @private\r\n * @description Exports methods for {@link Elem} for creating html-elements.\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {String[]}\r\n */\r\nexport const htmlElements = [\r\n  /**\r\n   * @member {Function} Elem#a\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'a',\r\n\r\n  /**\r\n   * @member {Function} Elem#abbr\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'abbr',\r\n\r\n  /**\r\n   * @member {Function} Elem#address\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'address',\r\n\r\n  /**\r\n   * @member {Function} Elem#area\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'area',\r\n\r\n  /**\r\n   * @member {Function} Elem#article\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'article',\r\n\r\n  /**\r\n   * @member {Function} Elem#audio\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'audio',\r\n\r\n  /**\r\n   * @member {Function} Elem#b\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'b',\r\n\r\n  /**\r\n   * @member {Function} Elem#base\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'base',\r\n\r\n  /**\r\n   * @member {Function} Elem#bdi\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'bdi',\r\n\r\n  /**\r\n   * @member {Function} Elem#bdo\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'bdo',\r\n\r\n  /**\r\n   * @member {Function} Elem#blockquote\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'blockquote',\r\n\r\n  /**\r\n   * @member {Function} Elem#body\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'body',\r\n\r\n  /**\r\n   * @member {Function} Elem#br\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'br',\r\n\r\n  /**\r\n   * @member {Function} Elem#button\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'button',\r\n\r\n  /**\r\n   * @member {Function} Elem#canvas\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'canvas',\r\n\r\n  /**\r\n   * @member {Function} Elem#caption\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'caption',\r\n\r\n  /**\r\n   * @member {Function} Elem#cite\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'cite',\r\n\r\n  /**\r\n   * @member {Function} Elem#code\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'code',\r\n\r\n  /**\r\n   * @member {Function} Elem#col\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'col',\r\n\r\n  /**\r\n   * @member {Function} Elem#colgroup\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'colgroup',\r\n\r\n  /**\r\n   * @member {Function} Elem#content\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'content',\r\n\r\n  /**\r\n   * @member {Function} Elem#datalist\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'datalist',\r\n\r\n  /**\r\n   * @member {Function} Elem#dd\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'dd',\r\n\r\n  /**\r\n   * @member {Function} Elem#del\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'del',\r\n\r\n  /**\r\n   * @member {Function} Elem#details\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'details',\r\n\r\n  /**\r\n   * @member {Function} Elem#dfn\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'dfn',\r\n\r\n  /**\r\n   * @member {Function} Elem#dialog\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'dialog',\r\n\r\n  /**\r\n   * @member {Function} Elem#div\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'div',\r\n\r\n  /**\r\n   * @member {Function} Elem#dl\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'dl',\r\n\r\n  /**\r\n   * @member {Function} Elem#dt\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'dt',\r\n\r\n  /**\r\n   * @member {Function} Elem#element\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'element',\r\n\r\n  /**\r\n   * @member {Function} Elem#em\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'em',\r\n\r\n  /**\r\n   * @member {Function} Elem#embed\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'embed',\r\n\r\n  /**\r\n   * @member {Function} Elem#fieldset\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'fieldset',\r\n\r\n  /**\r\n   * @member {Function} Elem#figcaption\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'figcaption',\r\n\r\n  /**\r\n   * @member {Function} Elem#figure\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'figure',\r\n\r\n  /**\r\n   * @member {Function} Elem#footer\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'footer',\r\n\r\n  /**\r\n   * @member {Function} Elem#form\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'form',\r\n\r\n  /**\r\n   * @member {Function} Elem#h1\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'h1',\r\n\r\n  /**\r\n   * @member {Function} Elem#h2\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'h2',\r\n\r\n  /**\r\n   * @member {Function} Elem#h3\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'h3',\r\n\r\n  /**\r\n   * @member {Function} Elem#h4\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'h4',\r\n\r\n  /**\r\n   * @member {Function} Elem#h5\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'h5',\r\n\r\n  /**\r\n   * @member {Function} Elem#h6\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'h6',\r\n\r\n  /**\r\n   * @member {Function} Elem#head\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'head',\r\n\r\n  /**\r\n   * @member {Function} Elem#header\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'header',\r\n\r\n  /**\r\n   * @member {Function} Elem#hgroup\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'hgroup',\r\n\r\n  /**\r\n   * @member {Function} Elem#hr\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'hr',\r\n\r\n  /**\r\n   * @member {Function} Elem#i\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'i',\r\n\r\n  /**\r\n   * @member {Function} Elem#iframe\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'iframe',\r\n\r\n  /**\r\n   * @member {Function} Elem#img\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'img',\r\n\r\n  /**\r\n   * @member {Function} Elem#input\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'input',\r\n\r\n  /**\r\n   * @member {Function} Elem#ins\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'ins',\r\n\r\n  /**\r\n   * @member {Function} Elem#kbd\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'kbd',\r\n\r\n  /**\r\n   * @member {Function} Elem#label\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'label',\r\n\r\n  /**\r\n   * @member {Function} Elem#legend\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'legend',\r\n\r\n  /**\r\n   * @member {Function} Elem#li\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'li',\r\n\r\n  /**\r\n   * @member {Function} Elem#link\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'link',\r\n\r\n  /**\r\n   * @member {Function} Elem#main\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'main',\r\n\r\n  /**\r\n   * @member {Function} Elem#mark\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'mark',\r\n\r\n  /**\r\n   * @member {Function} Elem#menu\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'menu',\r\n\r\n  /**\r\n   * @member {Function} Elem#menuitem\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'menuitem',\r\n\r\n  /**\r\n   * @member {Function} Elem#meta\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'meta',\r\n\r\n  /**\r\n   * @member {Function} Elem#meter\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'meter',\r\n\r\n  /**\r\n   * @member {Function} Elem#nav\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'nav',\r\n\r\n  /**\r\n   * @member {Function} Elem#noscript\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'noscript',\r\n\r\n  /**\r\n   * @member {Function} Elem#ol\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'ol',\r\n\r\n  /**\r\n   * @member {Function} Elem#optgroup\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'optgroup',\r\n\r\n  /**\r\n   * @member {Function} Elem#option\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'option',\r\n\r\n  /**\r\n   * @member {Function} Elem#output\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'output',\r\n\r\n  /**\r\n   * @member {Function} Elem#p\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'p',\r\n\r\n  /**\r\n   * @member {Function} Elem#param\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'param',\r\n\r\n  /**\r\n   * @member {Function} Elem#pre\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'pre',\r\n\r\n  /**\r\n   * @member {Function} Elem#progress\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'progress',\r\n\r\n  /**\r\n   * @member {Function} Elem#q\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'q',\r\n\r\n  /**\r\n   * @member {Function} Elem#rp\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'rp',\r\n\r\n  /**\r\n   * @member {Function} Elem#rt\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'rt',\r\n\r\n  /**\r\n   * @member {Function} Elem#rtc\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'rtc',\r\n\r\n  /**\r\n   * @member {Function} Elem#ruby\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'ruby',\r\n\r\n  /**\r\n   * @member {Function} Elem#s\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  's',\r\n\r\n  /**\r\n   * @member {Function} Elem#samp\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'samp',\r\n\r\n  /**\r\n   * @member {Function} Elem#script\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'script',\r\n\r\n  /**\r\n   * @member {Function} Elem#section\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'section',\r\n\r\n  /**\r\n   * @member {Function} Elem#select\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'select',\r\n\r\n  /**\r\n   * @member {Function} Elem#shadow\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'shadow',\r\n\r\n  /**\r\n   * @member {Function} Elem#small\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'small',\r\n\r\n  /**\r\n   * @member {Function} Elem#source\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'source',\r\n\r\n  /**\r\n   * @member {Function} Elem#span\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'span',\r\n\r\n  /**\r\n   * @member {Function} Elem#strong\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'strong',\r\n\r\n  /**\r\n   * @member {Function} Elem#style\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'style',\r\n\r\n  /**\r\n   * @member {Function} Elem#sub\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'sub',\r\n\r\n  /**\r\n   * @member {Function} Elem#summary\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'summary',\r\n\r\n  /**\r\n   * @member {Function} Elem#sup\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'sup',\r\n\r\n  /**\r\n   * @member {Function} Elem#table\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'table',\r\n\r\n  /**\r\n   * @member {Function} Elem#tbody\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'tbody',\r\n\r\n  /**\r\n   * @member {Function} Elem#td\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'td',\r\n\r\n  /**\r\n   * @member {Function} Elem#template\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'template',\r\n\r\n  /**\r\n   * @member {Function} Elem#textarea\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'textarea',\r\n\r\n  /**\r\n   * @member {Function} Elem#tfoot\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'tfoot',\r\n\r\n  /**\r\n   * @member {Function} Elem#th\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'th',\r\n\r\n  /**\r\n   * @member {Function} Elem#thead\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'thead',\r\n\r\n  /**\r\n   * @member {Function} Elem#time\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'time',\r\n\r\n  /**\r\n   * @member {Function} Elem#title\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'title',\r\n\r\n  /**\r\n   * @member {Function} Elem#tr\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'tr',\r\n\r\n  /**\r\n   * @member {Function} Elem#track\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'track',\r\n\r\n  /**\r\n   * @member {Function} Elem#u\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'u',\r\n\r\n  /**\r\n   * @member {Function} Elem#ul\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'ul',\r\n\r\n  /**\r\n   * @member {Function} Elem#var\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'var',\r\n\r\n  /**\r\n   * @member {Function} Elem#video\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'video',\r\n\r\n  /**\r\n   * @member {Function} Elem#wbr\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'wbr'\r\n];\r\n\r\nexport const svgElements = [\r\n  /**\r\n   * @member {Function} Elem#altGlyph\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'altGlyph',\r\n\r\n  /**\r\n   * @member {Function} Elem#altGlyphDef\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'altGlyphDef',\r\n\r\n  /**\r\n   * @member {Function} Elem#altGlyphItem\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'altGlyphItem',\r\n\r\n  /**\r\n   * @member {Function} Elem#animate\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'animate',\r\n\r\n  /**\r\n   * @member {Function} Elem#animateColor\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'animateColor',\r\n\r\n  /**\r\n   * @member {Function} Elem#animateMotion\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'animateMotion',\r\n\r\n  /**\r\n   * @member {Function} Elem#animateTransform\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'animateTransform',\r\n\r\n  /**\r\n   * @member {Function} Elem#circle\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'circle',\r\n\r\n  /**\r\n   * @member {Function} Elem#clipPath\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'clipPath',\r\n\r\n  /**\r\n   * @member {Function} Elem#colorProfile\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'color-profile',\r\n\r\n  /**\r\n   * @member {Function} Elem#cursor\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'cursor',\r\n\r\n  /**\r\n   * @member {Function} Elem#defs\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'defs',\r\n\r\n  /**\r\n   * @member {Function} Elem#desc\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'desc',\r\n\r\n  /**\r\n   * @member {Function} Elem#discard\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'discard',\r\n\r\n  /**\r\n   * @member {Function} Elem#ellipse\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'ellipse',\r\n\r\n  /**\r\n   * @member {Function} Elem#feBlend\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feBlend',\r\n\r\n  /**\r\n   * @member {Function} Elem#feColorMatrix\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feColorMatrix',\r\n\r\n  /**\r\n   * @member {Function} Elem#feComponentTransfer\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feComponentTransfer',\r\n\r\n  /**\r\n   * @member {Function} Elem#feComposite\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feComposite',\r\n\r\n  /**\r\n   * @member {Function} Elem#feConvolveMatrix\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feConvolveMatrix',\r\n\r\n  /**\r\n   * @member {Function} Elem#feDiffuseLighting\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feDiffuseLighting',\r\n\r\n  /**\r\n   * @member {Function} Elem#feDisplacementMap\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feDisplacementMap',\r\n\r\n  /**\r\n   * @member {Function} Elem#feDistantLight\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feDistantLight',\r\n\r\n  /**\r\n   * @member {Function} Elem#feDropShadow\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feDropShadow',\r\n\r\n  /**\r\n   * @member {Function} Elem#feFlood\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feFlood',\r\n\r\n  /**\r\n   * @member {Function} Elem#feFuncA\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feFuncA',\r\n\r\n  /**\r\n   * @member {Function} Elem#feFuncB\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feFuncB',\r\n\r\n  /**\r\n   * @member {Function} Elem#feFuncG\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feFuncG',\r\n\r\n  /**\r\n   * @member {Function} Elem#feFuncR\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feFuncR',\r\n\r\n  /**\r\n   * @member {Function} Elem#feGaussianBlur\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feGaussianBlur',\r\n\r\n  /**\r\n   * @member {Function} Elem#feImage\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feImage',\r\n\r\n  /**\r\n   * @member {Function} Elem#feMerge\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feMerge',\r\n\r\n  /**\r\n   * @member {Function} Elem#feMergeNode\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feMergeNode',\r\n\r\n  /**\r\n   * @member {Function} Elem#feMorphology\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feMorphology',\r\n\r\n  /**\r\n   * @member {Function} Elem#feOffset\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feOffset',\r\n\r\n  /**\r\n   * @member {Function} Elem#fePointLight\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'fePointLight',\r\n\r\n  /**\r\n   * @member {Function} Elem#feSpecularLighting\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feSpecularLighting',\r\n\r\n  /**\r\n   * @member {Function} Elem#feSpotLight\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feSpotLight',\r\n\r\n  /**\r\n   * @member {Function} Elem#feTile\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feTile',\r\n\r\n  /**\r\n   * @member {Function} Elem#feTurbulence\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'feTurbulence',\r\n\r\n  /**\r\n   * @member {Function} Elem#font\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'font',\r\n\r\n  /**\r\n   * @member {Function} Elem#fontFace\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'font-face',\r\n\r\n  /**\r\n   * @member {Function} Elem#fontFaceFormat\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'font-face-format',\r\n\r\n  /**\r\n   * @member {Function} Elem#fontFaceName\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'font-face-name',\r\n\r\n  /**\r\n   * @member {Function} Elem#fontFaceSrc\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'font-face-src',\r\n\r\n  /**\r\n   * @member {Function} Elem#fontFaceUri\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'font-face-uri',\r\n\r\n  /**\r\n   * @member {Function} Elem#foreignObject\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'foreignObject',\r\n\r\n  /**\r\n   * @member {Function} Elem#g\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'g',\r\n\r\n  /**\r\n   * @member {Function} Elem#glyph\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'glyph',\r\n\r\n  /**\r\n   * @member {Function} Elem#glyphRef\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'glyphRef',\r\n\r\n  /**\r\n   * @member {Function} Elem#hatch\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'hatch',\r\n\r\n  /**\r\n   * @member {Function} Elem#hatchpath\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'hatchpath',\r\n\r\n  /**\r\n   * @member {Function} Elem#hkern\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'hkern',\r\n\r\n  /**\r\n   * @member {Function} Elem#image\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'image',\r\n\r\n  /**\r\n   * @member {Function} Elem#line\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'line',\r\n\r\n  /**\r\n   * @member {Function} Elem#linearGradient\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'linearGradient',\r\n\r\n  /**\r\n   * @member {Function} Elem#marker\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'marker',\r\n\r\n  /**\r\n   * @member {Function} Elem#mask\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'mask',\r\n\r\n  /**\r\n   * @member {Function} Elem#mesh\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'mesh',\r\n\r\n  /**\r\n   * @member {Function} Elem#meshgradient\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'meshgradient',\r\n\r\n  /**\r\n   * @member {Function} Elem#meshpatch\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'meshpatch',\r\n\r\n  /**\r\n   * @member {Function} Elem#meshrow\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'meshrow',\r\n\r\n  /**\r\n   * @member {Function} Elem#metadata\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'metadata',\r\n\r\n  /**\r\n   * @member {Function} Elem#missingGlyph\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'missing-glyph',\r\n\r\n  /**\r\n   * @member {Function} Elem#mpath\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'mpath',\r\n\r\n  /**\r\n   * @member {Function} Elem#path\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'path',\r\n\r\n  /**\r\n   * @member {Function} Elem#pattern\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'pattern',\r\n\r\n  /**\r\n   * @member {Function} Elem#polygon\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'polygon',\r\n\r\n  /**\r\n   * @member {Function} Elem#polyline\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'polyline',\r\n\r\n  /**\r\n   * @member {Function} Elem#radialGradient\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'radialGradient',\r\n\r\n  /**\r\n   * @member {Function} Elem#rect\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'rect',\r\n\r\n  /**\r\n   * @member {Function} Elem#set\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'set',\r\n\r\n  /**\r\n   * @member {Function} Elem#solidcolor\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'solidcolor',\r\n\r\n  /**\r\n   * @member {Function} Elem#stop\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'stop',\r\n\r\n  /**\r\n   * @member {Function} Elem#style\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'style',\r\n\r\n  /**\r\n   * @member {Function} Elem#svg\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'svg',\r\n\r\n  /**\r\n   * @member {Function} Elem#switch\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'switch',\r\n\r\n  /**\r\n   * @member {Function} Elem#symbol\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'symbol',\r\n\r\n  /**\r\n   * @member {Function} Elem#textPath\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'textPath',\r\n\r\n  /**\r\n   * @member {Function} Elem#tref\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'tref',\r\n\r\n  /**\r\n   * @member {Function} Elem#tspan\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'tspan',\r\n\r\n  /**\r\n   * @member {Function} Elem#unknown\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'unknown',\r\n\r\n  /**\r\n   * @member {Function} Elem#use\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'use',\r\n\r\n  /**\r\n   * @member {Function} Elem#view\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'view',\r\n\r\n  /**\r\n   * @member {Function} Elem#vkern\r\n   * @type {Function}\r\n   * @param {...String} appliedExpressions\r\n   * @returns {Elem}\r\n   */\r\n  'vkern'\r\n];\r\n\r\nexport const voidElements = [\r\n  'area',\r\n  'base',\r\n  'br',\r\n  'col',\r\n  'command',\r\n  'embed',\r\n  'hr',\r\n  'img',\r\n  'input',\r\n  'keygen',\r\n  'link',\r\n  'meta',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr'\r\n];\r\n","export const htmlAllowedTagSymbols = '[a-z][a-z\\\\d\\\\-_.:!@#\\\\$%\\\\^&*()\\\\[\\\\]{}\\\\\\\\=\\'\"]*';\r\nexport const htmlAllowedAttrSymbols = '[^\\\\u0000-\\\\u0020\\\\s\"\\'>/=]+';\r\n","/**\r\n * @module constants/regexpSpecialCharacters\r\n * @private\r\n * @description Exports special characters for RegExp.\r\n */\r\n\r\n/**\r\n * @const\r\n * @name module:constants/regexpSpecialCharacters~regexpSpecialCharacters\r\n * @type {String[]}\r\n */\r\nexport const regexpSpecialCharacters = [\r\n  '.',\r\n  '+', '*', '?',\r\n  '(', ')',\r\n  '[', ']',\r\n  '{', '}',\r\n  '<', '>',\r\n  '^', '$',\r\n  '!',\r\n  '=',\r\n  ':',\r\n  '-',\r\n  '|',\r\n  ',',\r\n  '\\\\'\r\n];\r\n","/**\r\n * @module constants/validateCheckExpressions\r\n * @private\r\n * @description Exports different types of validate expressions for {@link module:helpers/validate}.\r\n */\r\n\r\nimport * as methods from '../helpers/checkTypes';\r\n\r\n/**\r\n * @callback checkValidityCallback\r\n * @private\r\n * @param {*} value - Value to check.\r\n */\r\n\r\n/**\r\n * @typedef {Object} validateExpr\r\n * @private\r\n * @property {String} text - Text of the thrown error.\r\n * @property {Error} error - Type of the thrown error.\r\n * @property {checkValidityCallback} check - Callback for checking value.\r\n */\r\n\r\n/**\r\n * @type {validateExpr[]}\r\n * @private\r\n * @description Object of different types of validation.\r\n */\r\nexport const validateCheckExpressions = {\r\n  '>0': {\r\n    check: (n) => n > 0,\r\n    text: '$n argument must be positive!',\r\n    error: RangeError\r\n  },\r\n  '>=0': {\r\n    check: (n) => n >= 0,\r\n    text: '$n argument must be non-negative!',\r\n    error: RangeError\r\n  },\r\n  '<0': {\r\n    check: (n) => n < 0,\r\n    text: '$n argument must be negative!',\r\n    error: RangeError\r\n  },\r\n  '<=0': {\r\n    check: (n) => n <= 0,\r\n    text: '$n argument must be non-positive!',\r\n    error: RangeError\r\n  },\r\n  '!!': {\r\n    check: (v) => !methods.isNil(v),\r\n    text: '$n argument must be not null or undefined!',\r\n    error: TypeError\r\n  },\r\n  array: {\r\n    check: methods.isArray,\r\n    text: '$n argument must be an array!',\r\n    error: TypeError\r\n  },\r\n  'array||!': {\r\n    check: (a) => methods.isArray(a) || methods.isNil(a),\r\n    text: '$n argument must be an array, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  arrayLike: {\r\n    check: methods.isArrayLike,\r\n    text: '$n argument must be array-like!',\r\n    error: TypeError\r\n  },\r\n  'arrayLike||!': {\r\n    check: (a) => methods.isArrayLike(a) || methods.isNil(a),\r\n    text: '$n argument must be array-like, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  date: {\r\n    check: methods.isDate,\r\n    text: '$n argument must be a date!',\r\n    error: TypeError\r\n  },\r\n  'date||!': {\r\n    check: (d) => methods.isDate(d) || methods.isNil(d),\r\n    text: '$n argument must be a date, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  dateLike: {\r\n    check: methods.isDateLike,\r\n    text: '$n argument must be date-like!',\r\n    error: TypeError\r\n  },\r\n  'dateLike||!': {\r\n    check: (d) => methods.isDateLike(d) || methods.isNil(d),\r\n    text: '$n argument must be date-like, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  function: {\r\n    check: methods.isFunction,\r\n    text: '$n argument must be a function!',\r\n    error: TypeError\r\n  },\r\n  'function||!': {\r\n    check: (f) => methods.isFunction(f) || methods.isNil(f),\r\n    text: '$n argument must be a function, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  int: {\r\n    check: methods.isInteger,\r\n    text: '$n argument must be an integer!',\r\n    error: TypeError\r\n  },\r\n  'int||!': {\r\n    check: (i) => methods.isInteger(i) || methods.isNil(i),\r\n    text: '$n argument must be an integer, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  intLike: {\r\n    check: methods.isIntegerLike,\r\n    text: '$n argument must be integer-like!',\r\n    error: TypeError\r\n  },\r\n  'intLike||!': {\r\n    check: (i) => methods.isIntegerLike(i) || methods.isNil(i),\r\n    text: '$n argument must be integer-like, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  number: {\r\n    check: methods.isNumber,\r\n    text: '$n argument must be a number!',\r\n    error: TypeError\r\n  },\r\n  'number||!': {\r\n    check: (n) => methods.isNumber(n) || methods.isNil(n),\r\n    text: '$n argument must be a number, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  numberLike: {\r\n    check: methods.isNumberLike,\r\n    text: '$n argument must be number-like!',\r\n    error: TypeError\r\n  },\r\n  'numberLike||!': {\r\n    check: (n) => methods.isNumberLike(n) || methods.isNil(n),\r\n    text: '$n argument must be number-like, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  object: {\r\n    check: methods.isObject,\r\n    text: '$n argument must be an object!',\r\n    error: TypeError\r\n  },\r\n  'object||!': {\r\n    check: (o) => methods.isObject(o) || methods.isNil(o),\r\n    text: '$n argument must be an object, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  regexp: {\r\n    check: methods.isRegExp,\r\n    text: '$n argument must be a regular expression!',\r\n    error: TypeError\r\n  },\r\n  'regexp||!': {\r\n    check: (r) => methods.isRegExp(r) || methods.isNil(r),\r\n    text: '$n argument must be a regular expression, or undefined, or null!',\r\n    error: TypeError\r\n  },\r\n  string: {\r\n    check: methods.isString,\r\n    text: '$n argument must be a string!',\r\n    error: TypeError\r\n  },\r\n  'string||!': {\r\n    check: (s) => methods.isString(s) || methods.isNil(s),\r\n    text: '$n argument must be a string, or undefined, or null!',\r\n    error: TypeError\r\n  }\r\n};\r\n","/**\r\n * @module helpers/Symbol\r\n * @private\r\n * @description Exports Symbol class.\r\n */\r\n\r\nexport const Symbol = global.Symbol || {\r\n  toStringTag: 'Symbol.toStringTag',\r\n  iterator: Math.random().toString(36)\r\n};\r\n","/**\r\n * @module Promise\r\n * @private\r\n * @mixin\r\n * @description Exports Promise class.\r\n */\r\n\r\nimport { isFunction, defineProperties, Symbol } from './helpers';\r\n\r\n/**\r\n * @callback onFulfilledOrRejected\r\n * @public\r\n * @param {*} value - Promise value.\r\n * @param {Boolean} success - If the previous promise is fulfilled it's true and false if rejected.\r\n */\r\n\r\n/**\r\n * @callback onRejected\r\n * @public\r\n * @param {Error|*} err - Promise error.\r\n */\r\n\r\n/**\r\n * @callback onFulfilled\r\n * @public\r\n * @param {*} value - Promise value.\r\n */\r\n\r\nconst secret = {};\r\nconst iterator = Symbol.iterator;\r\n\r\n/**\r\n * @class Promise\r\n * @public\r\n * @param {Function} executor - Function that takes two arguments: resolve and reject functions.\r\n * Call the resolve function when you need to fulfill the promise and call the reject one\r\n * when you need to reject it.\r\n * @returns {Promise} Instance of Promise.\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n * @description Class with almost identical API to\r\n * [ES6 Promise]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.\r\n * There is a couple differences: set Promise.onError to a function with which you want to\r\n * subscribe to a promise error and set Promise.onUnhandledRejection to a function with which\r\n * you want to subscribe to an unhandled error\r\n * (defaults to console.error.bind(console, '%s %o', 'Uncaught (in promise)')).\r\n */\r\nclass Promise {\r\n  static onError = null;\r\n  static onUnhandledRejection = console.error.bind(console, '%s %o', 'Uncaught (in promise)');\r\n\r\n  constructor(executor) {\r\n    if (!isFunction(executor)) {\r\n      throw new TypeError(`Promise resolver ${ {}.toString.call(executor) } is not a function`);\r\n    }\r\n\r\n    let hiddenStatus;\r\n    let hiddenValue;\r\n\r\n    const\tonFulfill = [];\r\n    const onReject = [];\r\n    const realPromise = this;\r\n    const hiddenPromise = {\r\n      handled: false,\r\n      get status() {\r\n        return hiddenStatus;\r\n      },\r\n      set status(value) {\r\n        hiddenStatus = value;\r\n        realPromise.status = value;\r\n      },\r\n      get value() {\r\n        return hiddenValue;\r\n      },\r\n      set value(val) {\r\n        hiddenValue = val;\r\n        realPromise.value = val;\r\n      }\r\n    };\r\n\r\n    hiddenPromise.status = 'pending';\r\n    hiddenPromise.value = undefined;\r\n\r\n    /**\r\n     * @typedef {Object} hiddenPromise\r\n     * @private\r\n     * @property {Boolean|Object} handled - If the promise is handled or not.\r\n     * @property {'pending'|'fulfilled'|'rejected'} status - Status of the promise.\r\n     * @property {*} value - Value of the promise.\r\n     */\r\n\r\n    /**\r\n     * @member {Function} hiddenPromise#handle\r\n     * @private\r\n     * @param {('reject'|'resolve')} event - Type of the event to handle.\r\n     * @param {Function} handler - Handler itself.\r\n     * @param {Function} resolve - Resolve function.\r\n     * @param {Function} reject - Reject function.\r\n     * @param {Object} secret - Secret.\r\n     * @description Private method for handling promises.\r\n     */\r\n\r\n    /**\r\n     * @member {hiddenPromise} Promise#$$\r\n     * @protected\r\n     */\r\n    defineProperties(this.$$ = {}, {\r\n      'get/set handled': {\r\n        get() {\r\n          return hiddenPromise.handled;\r\n        },\r\n        set(key) {\r\n          if (key === secret) {\r\n            hiddenPromise.handled = true;\r\n          }\r\n        }\r\n      },\r\n      handle(status, f, resolve, reject, key) {\r\n        if (key === secret) {\r\n          const proxy = isFunction(f) ? (value) => {\r\n            try {\r\n              resolve(f(value));\r\n            } catch (err) {\r\n              reject(err);\r\n            }\r\n          } : null;\r\n\r\n          if (status === 'resolve') {\r\n            onFulfill.push(proxy || ((value) => resolve(value)));\r\n          } else if (status === 'reject') {\r\n            onReject.push(proxy || ((err) => reject(err)));\r\n          }\r\n        }\r\n      },\r\n      'get status'() {\r\n        return hiddenPromise.status;\r\n      },\r\n      'get value'() {\r\n        return hiddenPromise.value;\r\n      }\r\n    });\r\n\r\n    try {\r\n      executor(resolve, reject);\r\n    } catch (err) {\r\n      reject(err);\r\n    }\r\n\r\n    function reject(err) {\r\n      if (hiddenPromise.status === 'pending') {\r\n        hiddenPromise.status = 'rejected';\r\n        hiddenPromise.value = err;\r\n\r\n        for (let i = 0, length = onReject.length; i < length; i++) {\r\n          hiddenPromise.handled = true;\r\n\r\n          onReject[i](err);\r\n        }\r\n\r\n        const {\r\n          onUnhandledRejection,\r\n          onError\r\n        } = Promise;\r\n\r\n        if (isFunction(onError)) {\r\n          onError(err);\r\n        }\r\n\r\n        setTimeout(() => {\r\n          if (!hiddenPromise.handled && isFunction(onUnhandledRejection)) {\r\n            onUnhandledRejection(err);\r\n          }\r\n        }, 1);\r\n      }\r\n    }\r\n\r\n    function resolve(value) {\r\n      if (hiddenPromise.status === 'pending') {\r\n        if (value && isFunction(value.then)) {\r\n          return value.then((value) => {\r\n            resolve(value);\r\n          }, (err) => {\r\n            reject(err);\r\n          });\r\n        }\r\n\r\n        hiddenPromise.status = 'fulfilled';\r\n        hiddenPromise.value = value;\r\n\r\n        for (let i = 0, length = onFulfill.length; i < length; i++) {\r\n          hiddenPromise.handled = true;\r\n\r\n          onFulfill[i](value);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @method Promise.all\r\n   * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises\r\n   * or any values.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\r\n   */\r\n  static all(iterable) {\r\n    const array = [];\r\n\r\n    let toResolve = 0;\r\n\r\n    if (iterable[iterator]) {\r\n      iterable = iterable[iterator]();\r\n\r\n      return new Promise((resolve, reject) => {\r\n        let next;\r\n        let i = 0;\r\n\r\n        while (!(next = iterable.next()).done) {\r\n          const promise = Promise.resolve(next.value);\r\n\r\n          toResolve++;\r\n\r\n          ((i) => {\r\n            promise.then((value) => {\r\n              toResolve--;\r\n              array[i] = value;\r\n\r\n              setTimeout(() => {\r\n                if (next.done && !toResolve) {\r\n                  resolve(array);\r\n                }\r\n              }, 1);\r\n            }, reject);\r\n          })(i++);\r\n        }\r\n\r\n        if (!i) {\r\n          return Promise.resolve([]);\r\n        }\r\n      });\r\n    }\r\n\r\n    const length = iterable.length;\r\n\r\n    if (!length) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    toResolve = length;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      for (let i = 0; i < length; i++) {\r\n        const promise = Promise.resolve(iterable[i]);\r\n\r\n        promise.then((value) => {\r\n          toResolve--;\r\n          array[i] = value;\r\n\r\n          if (!toResolve) {\r\n            resolve(array);\r\n          }\r\n        }, reject);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Promise.race\r\n   * @param {(Array|Iterable).<Promise|*>} iterable - Iterable object (like array) of promises\r\n   * or any values.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\r\n   */\r\n  static race(iterable) {\r\n    if (iterable[iterator]) {\r\n      iterable = iterable[iterator]();\r\n\r\n      return new Promise((resolve, reject) => {\r\n        let next;\r\n\r\n        while (!(next = iterable.next()).done) {\r\n          next.value.then(resolve, reject);\r\n        }\r\n      });\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      for (let i = 0, length = iterable.length; i < length; i++) {\r\n        iterable[i].then(resolve, reject);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Promise.reject\r\n   * @param {*} value - Value to reject.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\r\n   */\r\n  static reject(value) {\r\n    return new Promise((resolve, reject) => {\r\n      reject(value);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @method Promise.resolve\r\n   * @param {Promise|Thenable|*} value - Promise, thenable or any value to resolve.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\r\n   */\r\n  static resolve(value) {\r\n    if (value && isFunction(value.then)) {\r\n      return value;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n      resolve(value);\r\n    });\r\n  }\r\n\r\n  abort() {}\r\n\r\n  /**\r\n   * @method Promise#catch\r\n   * @param {onRejected} onRejected - onRejected callback.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\r\n   */\r\n  catch(onRejected) {\r\n    return this.then(null, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @method Promise#finally\r\n   * @public\r\n   * @param {onFulfilledOrRejected} onFulfilledOrRejected - onFulfilledOrRejected callback.\r\n   * @returns {Promise}\r\n   * @description Method for catching both fulfilled and rejected promises.\r\n   *\r\n   * @example\r\n   * spinner.show();\r\n   * fetchData()\r\n   *   .then((data) => {\r\n   *     // do something with data\r\n   *   })\r\n   *   .catch((err) => {\r\n   *     // handle error somehow\r\n   *   })\r\n   *   .finally(() => {\r\n   *     spinner.hide();\r\n   *   });\r\n   */\r\n  finally(onFulfilledOrRejected) {\r\n    const isFunc = isFunction(onFulfilledOrRejected);\r\n\r\n    return this.then((value) => (\r\n      Promise\r\n        .resolve(\r\n          isFunc\r\n            ? onFulfilledOrRejected(value, true)\r\n            : 0\r\n        )\r\n        .then(() => value)\r\n    ), (err) => (\r\n      Promise\r\n        .resolve(\r\n          isFunc\r\n            ? onFulfilledOrRejected(err, false)\r\n            : 0\r\n        )\r\n        .then(() => Promise.reject(err))\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * @method Promise#then\r\n   * @param {onFulfilled} [onFulfilled] - onFulfilled callback.\r\n   * @param {onRejected} [onRejected] - onRejected callback.\r\n   * @returns {Promise} New instance of Promise.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\r\n   */\r\n  then(onFulfilled, onRejected) {\r\n    const promise = this.$$;\r\n\r\n    if (promise.status === 'pending') {\r\n      return new Promise((resolve, reject) => {\r\n        promise.handle('reject', onRejected, resolve, reject, secret);\r\n        promise.handle('resolve', onFulfilled, resolve, reject, secret);\r\n      });\r\n    }\r\n\r\n    promise.handled = secret;\r\n\r\n    const { value } = promise;\r\n\r\n    let method;\r\n    let handler;\r\n\r\n    if (promise.status === 'fulfilled') {\r\n      method = 'resolve';\r\n      handler = onFulfilled;\r\n    } else {\r\n      method = 'reject';\r\n      handler = onRejected;\r\n    }\r\n\r\n    if (!isFunction(handler)) {\r\n      return Promise[method](value);\r\n    }\r\n\r\n    try {\r\n      return Promise.resolve(handler(value));\r\n    } catch (err) {\r\n      return Promise.reject(err);\r\n    }\r\n  }\r\n}\r\n\r\ndefineProperties(Promise.prototype, {\r\n  [Symbol.toStringTag]: 'Promise'\r\n});\r\n\r\nexport { Promise };\r\n","/**\r\n * @module helpers/parseHeaders\r\n * @private\r\n * @description Exports parseHeaders method.\r\n */\r\n\r\nimport { Str } from '../Str';\r\nimport { iterate } from './iterate';\r\n\r\n/**\r\n * @function parseHeaders\r\n * @param {String} rawHeaders - Raw headers.\r\n * @returns {Object} Headers object\r\n * @description Function for parsing raw headers.\r\n */\r\nexport default (rawHeaders) => {\r\n  const headers = {};\r\n\r\n  iterate((rawHeaders || '').split('\\n'), (value) => {\r\n    const index = value.indexOf(':');\r\n    const key = new Str(value.substring(0, index))\r\n      .trim()\r\n      .toCamelCase().$;\r\n    const val = new Str(value.substring(index + 1)).trim().$;\r\n\r\n    if (key) {\r\n      headers[key] = (headers[key] ? `${ headers[key] }, ` : '') + val;\r\n    }\r\n  });\r\n\r\n  return headers;\r\n};\r\n","/**\r\n * @module helpers/transformData\r\n * @private\r\n * @description Exports transformData method.\r\n */\r\n\r\nimport { Arr } from '../Arr';\r\nimport { Super } from '../Super';\r\nimport { isObject, toStringTag } from './';\r\n\r\nconst notToTransform = new Arr(['FormData', 'File', 'Blob', 'ArrayBuffer', 'String', 'Number']);\r\nconst withoutBody = new Arr(['DELETE', 'GET', 'HEAD']);\r\n\r\n/**\r\n * @function transformData\r\n * @param {*} data - Data to transform\r\n * @param {String} method - HTTP method.\r\n * @param {Object} headers - Object with headers.\r\n * @returns {*} - Transformed data.\r\n */\r\nexport default (data, method, headers) => {\r\n  data = new Super(data).$;\r\n\r\n  if (withoutBody.indexOfStrict(method) !== -1) {\r\n    return null;\r\n  }\r\n\r\n  if (isObject(data) && notToTransform.indexOfStrict(toStringTag(data)) === -1) {\r\n    if (!headers.contentType) {\r\n      headers.contentType = ['application/json;charset=utf-8'];\r\n    }\r\n\r\n    return new Super(data).json();\r\n  }\r\n\r\n  return data;\r\n};\r\n","/**\r\n * @module helpers/resolveURL\r\n * @private\r\n * @description Exports Object.assign-like method.\r\n */\r\n\r\nimport { Str } from '../Str';\r\n\r\nconst { location } = global;\r\n\r\nexport default (decodeQuery) => {\r\n  const {\r\n    search: query,\r\n    hash\r\n  } = location;\r\n  const params = {\r\n    query: {},\r\n    hash: hash.replace(/^#/, '')\r\n  };\r\n\r\n  if (!query) {\r\n    return params;\r\n  }\r\n\r\n  new Str(query.replace(/^\\?/, ''))\r\n    .split('&')\r\n    .forEach((rawParam) => {\r\n      let [param, value = ''] = rawParam.split('=');\r\n\r\n      param = decodeQuery ? decodeURIComponent(param) : param;\r\n      value = decodeQuery ? decodeURIComponent(value) : value;\r\n\r\n      if (!/^[^[]+/.test(param)) {\r\n        return;\r\n      }\r\n\r\n      let paramName;\r\n      let paramObject = params.query;\r\n\r\n      new Str(param)\r\n        .match(/^[^[\\]]*|\\[[^[\\]]*]/g)\r\n        .forEach((name) => {\r\n          if (name.indexOf('[')) {\r\n            paramName = name;\r\n\r\n            return;\r\n          }\r\n\r\n          name = name.slice(1, -1);\r\n\r\n          paramObject = paramObject[paramName] = paramObject[paramName] || (name ? {} : []);\r\n          paramName = name || paramObject.length;\r\n        });\r\n\r\n      paramObject[paramName] = value;\r\n    });\r\n\r\n  return params;\r\n};\r\n","import * as statics from './lib/browser';\r\nimport { assign } from './lib/helpers/assign';\r\n\r\nconst { D } = statics;\r\n\r\nassign(D, statics);\r\n\r\ndelete D.D;\r\n\r\nglobal.D = D;\r\n"],"names":["toStringTag","object","toString","call","replace","isArray","value","isArrayLike","isFunction","length","isInteger","isBoolean","isDate","isDateLike","Date","isNaN","getTime","isElement","test","isFinite","isNumber","Number","Infinity","isIntegerLike","parseInt","isNull","isNil","isNumberLike","isObject","Object","isPlainObject","isPrimitive","proto","getPrototypeOf","constructor","isRegExp","isString","isSymbol","isUndefined","D","i","constructors","levelConstructors","k","len","cls","check","iterate","callback","array","iteratedKeys","iterated","key","hasOwnProperty","assign","target","objects","arguments","source","index","dynamicDefineProperties","properties","propertyGenerator","name","defineProperty","defineProperties","method","undefined","get","set","toArray","createNewArray","push","validate","args","options","number","checker","validateCheckExpressions","error","text","numbers","char","alphabet","string","ranges","split","range","Error","start","charCodeAt","end","String","fromCharCode","Alphabet","switcher","cases","mode","defaultValue","Switcher","when","condition","value1","value2","deepAssign","deepClone","clone","cloneSwitcher","deepEqual","o1","o2","strict","match","lastIndex","p1","p2","keys","deepEvery","n","tree","newTree","concat","deepFilter","nul","o","filtered","deepFind","result","deepForEach","deepForEachEntry","deepFreeze","freeze","deepMap","deepReduce","IV","deepSome","x","apply","noop","prop","self","rand","Math","random","floor","asc","y","Arr","blob","blobParts","BlobObject","Blob","trim","parseJSON","json","JSON","parse","dates","parsed","this","find","markup","elem","matches","rawTextSwitcher","Super","constructCloseTagRegExp","NODE_REGEX_SET","map","regex","returning","attrs","startMarkup","closeMatch","selfClosing","slice","TAG_OPEN_CLOSE","attr","ATTRIBUTE","min","NaN","tagName","RegExp","nearString","parseCharacterData","innerHTML","div","textContent","innerText","toFind","isElem","Elem","isWindow","isHTMLDocument","isDocumentFragment","isStyleRule","isCommentOrText","tag","getElem","$","emptyDiv","getName","nodeName","toLowerCase","addDwayneData","windowsDwayneData","some","element","getContext","selector","base","nativeDocument","querySelectorAll","parseHTML","html","collapseWhiteSpace","markupToJSON","template","doc","content","forEach","forEachNode","node","parent","children","parentNode","create","px","size","registerDBlock","Block","DBlock","elems","$$","found","registerDEach","createBlock","DEach","opts","item","itemName","indexName","_this","uid","constructValues","watchArgs","parentElem","uids","scope","UID","$uids","newKeys","newUIDs","evaluate","items","splice","Item","remove","after","block","shift","prev","insertAfter","values","registerDElements","DElements","_this2","mixins","watchersToRemove","child","mixin","filter","watchers","watcher","forDElements","indexOf","newContent","add","registerDIf","DIf","cond","evaluateAndWatch","if","newValue","Boolean","registerDItem","DItem","registerDSwitch","DSwitch","wasDefault","val","equals","registerDText","DText","registerDAttr","Mixin","DAttr","oldValue","removeAttr","registerDBind","DBind","off","on","registerDClass","DClass","classes","newClasses","removeClass","addClass","registerDElem","DElem","evaluateOnce","registerDHide","DHide","hide","show","registerDOn","DOn","registerDShow","DShow","registerDStyle","DStyle","removeCSS","css","registerDValidate","DValidate","validator","listenerSwitcher","registerDValue","DValue","_value","type","initialScopeValue","propSwitcher","currentValue","setProp","initialElemValue","getProp","isInitialScopeValueNull","isCheckbox","changeScope","e","option","selected","setValueSwitcher","init","getValueSwitcher","initApp","blocks","createComment","into","registerBuiltIns","register","_html","deepCloneChildren","_match","Str","escapeRegExp","parentBlock","parentScope","svgNS","svg","localBlocks","ns","_blocks","localMixins","_mixins","dBlockMatch","expressionRegExp","currentMixins","localMatch","blockInstance","global","Args","locals","constructPrivateScope","scopeValues","DItemFound","privateScope","afterConstruct","err","afterRender","createMixin","afterUpdate","newChild","transformDIfChildren","ifElse","isInstanceOfBlock","isPrototypeOf","prototype","isInstanceOfMixin","removeWatchers","constructPublicScope","define","evalMode","getting","temp","changed","oldTempWatchers","onRemove","was","perm","round","digits","zeroes","zero","repeat","now","date","Dat","isAbsolute","url","absoluteURLRegexp","encode","isEncoded","encodeURIComponent","fetchBeforeMiddleware","config","baseURL","data","headers","params","query","METHOD","toUpperCase","constructURL","transformData","header","toCapitalCase","join","initRouter","initialized","Routes","redirectRoute","defaultRoute","RedirectRoute","route","parentName","ParentName","rootRoute","abstract","baseRoute","parentParams","parentQuery","path","relativeURL","relativePath","count","newPath","newURL","validatePath","location","href","pushed","closestLink","closest","hasAttr","preventDefault","makeRoute","callBeforeLoad","routeLoaded","beforeLoad","__routerInstance__","currentRoutes","isCurrentRoute","currentRoute","beforeLoadRoute","callBeforeLeave","beforeLeave","beforeLeaveRoute","routerOptions","root","fallbackTo","isDefault","default","warn","wasRoot","Name","Route","unsubscribe","router","encodeParams","encodeQuery","hash","origin","buildURL","__isCurrentRoute__","currentRouteParams","subscribe","delete","forward","changeRoute","findRouteByURL","host","hostname","pathname","port","protocol","search","urlParams","routeURL","requiredQuery","decodeParams","decodeQuery","resolved","resolveURL","eventualParams","param","hasOwn","decode","DefaultRoute","decodeURIComponent","changeHistory","resolveParameter","nameErrorName","valueErrorName","nameMatch","regexp","window","appliedRegExps","id","canvasGetMethods","canvasRestMethods","htmlElements","svgElements","voidElements","htmlAllowedTagSymbols","htmlAllowedAttrSymbols","regexpSpecialCharacters","RangeError","v","methods","TypeError","a","d","f","r","s","Symbol","chars","word","token","def","ret","Case","case","eventualCases","setPrototypeOf","Function","deep","sum","func","descriptors","property","descriptor","props","getter","isFrozen","replacer","space","unshift","stringify","max","obj","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","isContextObject","startKey","setter","reduce","secret","iterator","Promise","executor","reject","hiddenPromise","status","onReject","handled","onUnhandledRejection","onError","resolve","then","onFulfill","hiddenStatus","hiddenValue","realPromise","proxy","onRejected","onFulfilledOrRejected","isFunc","onFulfilled","promise","handle","handler","iterable","toResolve","next","done","console","bind","Func","called","canBeCalled","before","sync","contextLocked","context","middleware","afterAll","beforeAll","bindContext","bindArgs","times","lockContext","lockArgs","argsLocked","mark","time","timeEnd","unbindContext","unbindArgs","toRadian","PI","toDegree","ln2","LN2","ln10","LN10","Num","toDegrees","acos","asin","atan","asDegrees","cos","abort","clearTimeout","timeout","aborted","setTimeout","interval","log","power","pow","sin","tan","rej","fractionDigits","toExponential","toFixed","precision","toPrecision","abs","sqrt","cbrt","ceil","exp","ln","sign","keyOf","keyOfStrict","separator","pop","reverse","randomIndex","begin","compareFunction","sort","deleteCount","URL","progress","reader","FileReader","toReject","onprogress","onerror","onload","anchor","document","createElement","dataURL","setAttribute","click","createObjectURL","htmlSpecials","regexpSpecialsRegexp","searchString","position","revert","startsWith","escaped","symbol","searchValue","fromIndex","lastIndexOf","str","beginSlice","endSlice","substr","indexStart","indexEnd","substring","submitString","nodeSwitcher","InternalParsingError","ParsingError","throwUnexpectedError","globalIndex","elements","eventSeparator","textProperty","Node","propertyDescriptor","inputElements","xmlNS","xlinkNS","xhtmlNS","typeSwitcher","documentElement","namespaceURI","createElementNS","createTextNode","refSwitcher","filterSwitcher","is","innerSwitcher","paddings","borders","outerSwitcher","attrNSSwitcher","list","classList","insertAdjacentHTML","style","sheet","cssRules","rules","toHyphenCase","insertRule","dwayneData","strings","applied","setApplied","np1","attributes","getAttribute","getAttributeNS","setAttributeNS","_this4","first","load","isBroken","canvas","width","height","drawImage","byteString","atob","ab","ArrayBuffer","ia","Uint8Array","blur","pseudo","getComputedStyle","rule","childNodes","className","cloneNode","contains","appliedExpressions","getPropertyValue","getPropertyPriority","removeProperty","setProperty","cssText","toCamelCase","ctx","dataset","encoderOptions","toDataURL","deleteRule","event","eventInit","details","bubbles","cancelable","finalEvent","Event","createEvent","initEvent","dispatchEvent","focus","selectorText","hasAttribute","hasAttributeNS","currentDisplay","previousDisplay","insertBefore","appendChild","firstChild","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","complete","naturalWidth","naturalHeight","images","all","$elem","removeListeners","proper","broken","nextSibling","events","listeners","removeListener","listener","allListeners","removeEventListeners","has","newListener","addEventListener","removeEventListener","previousSibling","link","removeChild","removeAttribute","removeAttributeNS","2","1","created","txt","_arguments6","hasClass","level","validatorWrap","input","errors","validity","valid","validationMessage","validators","formErrors","form","inputs","dispatch","inputError","every","innerHeight","calcCSS","borderTopWidth","borderBottomWidth","boxSizing","paddingTop","paddingBottom","innerWidth","borderLeftWidth","borderRightWidth","paddingLeft","paddingRight","outerHeight","marginTop","marginBottom","outerWidth","marginLeft","marginRight","win","body","head","inputValue","rootBlocks","rootMixins","attrName","onEvalError","expression","originalArgs","onChange","instance","forDItem","forDEach","expr","DwayneStore","store","localWatchers","newResult","watcherBlock","index1","index2","arg","DwayneBlock","Subclass","isParentSignal","beforeRemove","variable","_this5","_this6","local","_this7","Blocks","Mixins","daysOfTheWeekNames","daysOfTheWeekAliases","monthsNames","monthsAliases","utc","coeffs","getSwitcher","setSwitcher","what","prefix","formats","format","replaceString","date1","date2","isBefore","started","coeff","w","setTime","toISOString","toLocaleString","valueOf","querySwitcher","queryParams","encodeOptions","rawHeaders","notToTransform","withoutBody","indexOfStrict","contentType","defaults","uploadMethods","Fetch","fetch","request","conf","toPush","dataConfig","urlConfig","xhr","auth","username","password","responseType","withCredentials","XMLHttpRequest","open","setRequestHeader","upload","onabort","ontimeout","onreadystatechange","readyState","response","responseText","parseHeaders","getAllResponseHeaders","statusText","catch","send","rawParam","paramName","paramObject","subscribers","history","pathSwitcher","part","statics"],"mappings":"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","preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uL2xpYi9oZWxwZXJzL3RvU3RyaW5nVGFnLmpzIiwiLi4vbGliL2hlbHBlcnMvY2hlY2tUeXBlcy5qcyIsIi4uL2xpYi9ELmpzIiwiLi4vbGliL2hlbHBlcnMvaXRlcmF0ZS5qcyIsIi4uL2xpYi9oZWxwZXJzL2Fzc2lnbi5qcyIsIi4uL2xpYi9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vbGliL2hlbHBlcnMvdG9BcnJheS5qcyIsIi4uL2xpYi9oZWxwZXJzL3ZhbGlkYXRlLmpzIiwiLi4vbGliL0FscGhhYmV0LmpzIiwiLi4vbGliL1N3aXRjaGVyLmpzIiwiLi4vbGliL1N1cGVyLmpzIiwiLi4vbGliL0Z1bmMuanMiLCIuLi9saWIvTnVtLmpzIiwiLi4vbGliL0Fyci5qcyIsIi4uL2xpYi9CbG9iT2JqZWN0LmpzIiwiLi4vbGliL1N0ci5qcyIsIi4uL2xpYi9oZWxwZXJzL21hcmt1cFRvSlNPTi5qcyIsIi4uL2xpYi9FbGVtLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWJsb2NrLmpzIiwiLi4vbGliL2Jsb2Nrcy9kLWVhY2guanMiLCIuLi9saWIvYmxvY2tzL2QtZWxlbWVudHMuanMiLCIuLi9saWIvYmxvY2tzL2QtaWYuanMiLCIuLi9saWIvYmxvY2tzL2QtaXRlbS5qcyIsIi4uL2xpYi9ibG9ja3MvZC1zd2l0Y2guanMiLCIuLi9saWIvYmxvY2tzL2QtdGV4dC5qcyIsIi4uL2xpYi9taXhpbnMvZC1hdHRyLmpzIiwiLi4vbGliL21peGlucy9kLWJpbmQuanMiLCIuLi9saWIvbWl4aW5zL2QtY2xhc3MuanMiLCIuLi9saWIvbWl4aW5zL2QtZWxlbS5qcyIsIi4uL2xpYi9taXhpbnMvZC1oaWRlLmpzIiwiLi4vbGliL21peGlucy9kLW9uLmpzIiwiLi4vbGliL21peGlucy9kLXNob3cuanMiLCIuLi9saWIvbWl4aW5zL2Qtc3R5bGUuanMiLCIuLi9saWIvbWl4aW5zL2QtdGV4dC5qcyIsIi4uL2xpYi9taXhpbnMvZC12YWxpZGF0ZS5qcyIsIi4uL2xpYi9taXhpbnMvZC12YWx1ZS5qcyIsIi4uL2xpYi9CbG9jay5qcyIsIi4uL2xpYi9jb25zdGFudHMvZm9ybWF0cy5qcyIsIi4uL2xpYi9EYXQuanMiLCIuLi9saWIvaGVscGVycy9jb25zdHJ1Y3RVUkwuanMiLCIuLi9saWIvRmV0Y2guanMiLCIuLi9saWIvUm91dGVyLmpzIiwiLi4vbGliL2NvbnN0YW50cy9nbG9iYWwuanMiLCIuLi9saWIvY29uc3RhbnRzL2FwcGxpZWRSZWdFeHBzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9jYW52YXNNZXRob2RzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9jb25zdHJ1Y3RvcnMuanMiLCIuLi9saWIvY29uc3RhbnRzL2VsZW1lbnRzLmpzIiwiLi4vbGliL2NvbnN0YW50cy9odG1sQWxsb3dlZFRhZ1N5bWJvbHMuanMiLCIuLi9saWIvY29uc3RhbnRzL3JlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzLmpzIiwiLi4vbGliL2NvbnN0YW50cy92YWxpZGF0ZUNoZWNrRXhwcmVzc2lvbnMuanMiLCIuLi9saWIvaGVscGVycy9TeW1ib2wuanMiLCIuLi9saWIvUHJvbWlzZS5qcyIsIi4uL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIi4uL2xpYi9oZWxwZXJzL3RyYW5zZm9ybURhdGEuanMiLCIuLi9saWIvaGVscGVycy9yZXNvbHZlVVJMLmpzIiwiLi4vYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3RvU3RyaW5nVGFnXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRvU3RyaW5nVGFnIG1ldGhvZC5cclxuICovXHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIHRvU3RyaW5nVGFnXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGdldCB0b1N0cmluZ1RhZyBvZi5cclxuICogQHJldHVybnMge1N0cmluZ30gQ3V0IHN0cmluZy5cclxuICogQGRlc2NyaXB0aW9uIEN1dCBcIlR5cGVcIiBzdHJpbmcgZnJvbSBcIltvYmplY3QgVHlwZV1cIiBzdHJpbmcgdGhhdCBnb3R0ZW4gZnJvbSB7fS50b1N0cmluZyxjYWxsKG9iamVjdCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqZWN0KS5yZXBsYWNlKC9eXFxbb2JqZWN0IHxdJC9nLCAnJyk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9jaGVja1R5cGVzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBpczxUeXBlPiBtZXRob2RzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IHRvU3RyaW5nVGFnIH0gZnJvbSAnLi90b1N0cmluZ1RhZyc7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzQXJyYXlcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYW4gYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgb3Igbm90LlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogaXNBcnJheShbXSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzQXJyYXkoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7IC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdBcnJheSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNBcnJheUxpa2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYXJyYXktbGlrZS5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhcnJheS1saWtlIG9yIG5vdC5cclxuICogQGRlc2NyaXB0aW9uIEJhc2ljYWxseSByZXR1cm5zIGlmIHRoZSBhcmd1bWVudCBoYXMgbm9uLW5lZ2F0aXZlIGludGVnZXIgXCJsZW5ndGhcIiBwcm9wZXJ0eSBhbmQgaXNuJ3QgYSBmdW5jdGlvbi5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzQXJyYXlMaWtlKFtdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNBcnJheUxpa2UoJycpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc0FycmF5TGlrZSgoKSA9PiB7fSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc0FycmF5TGlrZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpOyAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcclxuICBpZiAoIXZhbHVlIHx8IGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcclxuICBcclxuICByZXR1cm4gaXNJbnRlZ2VyKGxlbmd0aCkgJiYgbGVuZ3RoID49IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNCb29sZWFuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgYm9vbGVhbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIGJvb2xlYW4gb3Igbm90LlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogaXNCb29sZWFuKHRydWUpOyAgICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNCb29sZWFuKG5ldyBCb29sZWFuKGZhbHNlKSk7IC8vIHRydWVcclxuICogaXNCb29sZWFuKG51bGwpOyAgICAgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Jvb2xlYW4nO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzRGF0ZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIGRhdGUuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBkYXRlIG9yIG5vdC5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzRGF0ZShuZXcgRGF0ZSgpKTsgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNEYXRlKCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKTsgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRGF0ZSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNEYXRlTGlrZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBkYXRlLWxpa2UuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgZGF0ZS1saWtlIG9yIG5vdC5cclxuICogQGRlc2NyaXB0aW9uIEJhc2ljYWxseSByZXR1cm5zIGlmIG5ldyBEYXRlKGFyZ3VtZW50KSBpcyBub3QgaW52YWxpZCBkYXRlLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogaXNEYXRlTGlrZShuZXcgRGF0ZSgpKTsgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNEYXRlTGlrZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJyk7IC8vIHRydWVcclxuICogaXNEYXRlTGlrZSgwKTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVMaWtlKHZhbHVlKSB7XHJcbiAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgXHJcbiAgcmV0dXJuICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzRWxlbWVudFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhbiBlbGVtZW50LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGVsZW1lbnQgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0VsZW1lbnQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpKTsgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xyXG4gIHJldHVybiAvRWxlbWVudCQvLnRlc3QodG9TdHJpbmdUYWcodmFsdWUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0Zpbml0ZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBmaW5pdGUuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgZmluaXRlIG9yIG5vdC5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzRmluaXRlKDApOyAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc0Zpbml0ZSgnMCcpOyAgICAgIC8vIGZhbHNlXHJcbiAqIGlzRmluaXRlKEluZmluaXR5KTsgLy8gZmFsc2VcclxuICogaXNGaW5pdGUoTmFOKTsgICAgICAvLyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XHJcbiAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG5cclxuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0Z1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiBvciBub3QuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc0Z1bmN0aW9uKCgpID0+IHt9KTsgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIFxyXG4gKiBjb25zdCBmdW5jID0gKCkgPT4ge307XHJcbiAqIE9iamVjdC5zZXRQcm90b3R5cGVPZihmdW5jLCB7fSk7XHJcbiAqIGlzRnVuY3Rpb24oZnVuYyk7ICAgICAgICAgICAgICAgIC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNJbnRlZ2VyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW50ZWdlciBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzSW50ZWdlcigwKTsgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc0ludGVnZXIoMC4xKTsgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqIGlzSW50ZWdlcihuZXcgTnVtYmVyKDApKTsgLy8gdHJ1ZVxyXG4gKiBpc0ludGVnZXIoJzAnKTsgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqIGlzSW50ZWdlcihJbmZpbml0eSk7ICAgICAgLy8gZmFsc2VcclxuICogaXNJbnRlZ2VyKE5hTik7ICAgICAgICAgICAvLyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xyXG4gIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgJSAxID09PSAwO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzSW50ZWdlckxpa2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgaW50ZWdlci1saWtlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGludGVnZXItbGlrZSBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzSW50ZWdlckxpa2UoMCk7ICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNJbnRlZ2VyTGlrZShuZXcgTnVtYmVyKDApKTsgLy8gdHJ1ZVxyXG4gKiBpc0ludGVnZXJMaWtlKDAuMSk7ICAgICAgICAgICAvLyBmYWxzZVxyXG4gKiBpc0ludGVnZXJMaWtlKCcwJyk7ICAgICAgICAgICAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyTGlrZSh2YWx1ZSkge1xyXG4gIHZhbHVlID0gcGFyc2VJbnQoTnVtYmVyKHZhbHVlKSk7XHJcblxyXG4gIHJldHVybiAhISh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNOYU5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgTmFOLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIE5hTiBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzTmFOKDApOyAgICAgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqIGlzTmFOKCdOYU4nKTsgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqIGlzTmFOKE5hTik7ICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNOYU4obmV3IE51bWJlcihOYU4pKTsgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XHJcbiAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG5cclxuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzTnVsbFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIG51bGwgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc051bGwobnVsbCk7ICAgICAgLy8gdHJ1ZVxyXG4gKiBpc051bGwodW5kZWZpbmVkKTsgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNOaWxcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc05pbChudWxsKTsgICAgICAvLyB0cnVlXHJcbiAqIGlzTmlsKHVuZGVmaW5lZCk7IC8vIHRydWVcclxuICogaXNOaWwoZmFsc2UpOyAgICAgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzTnVtYmVyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgbnVtYmVyLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNOdW1iZXIoMCk7ICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNOdW1iZXIobmV3IE51bWJlcigwKSk7IC8vIHRydWVcclxuICogaXNOdW1iZXIoTmFOKTsgICAgICAgICAgIC8vIHRydWVcclxuICogaXNOdW1iZXIoJzAnKTsgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnTnVtYmVyJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc051bWJlckxpa2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgbnVtYmVyLWxpa2UuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVtYmVyLWxpa2Ugb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc051bWJlckxpa2UoMCk7ICAgICAgICAgIC8vIHRydWVcclxuICogaXNOdW1iZXJMaWtlKCcwJyk7ICAgICAgICAvLyB0cnVlXHJcbiAqIGlzTnVtYmVyTGlrZSgnSW5maW5pdHknKTsgLy8gdHJ1ZVxyXG4gKiBpc051bWJlckxpa2UoJ05hTicpOyAgICAgIC8vIHRydWVcclxuICogaXNOdW1iZXJMaWtlKE5hTik7ICAgICAgICAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJMaWtlKHZhbHVlKSB7XHJcbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ05hTicpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBcclxuICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgXHJcbiAgcmV0dXJuICEhKHZhbHVlIHx8IHZhbHVlID09PSAwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc09iamVjdFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhbiBvYmplY3QuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYW4gb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNPYmplY3Qoe30pOyAgIC8vIHRydWVcclxuICogaXNPYmplY3QoMSk7ICAgIC8vIGZhbHNlXHJcbiAqIGlzT2JqZWN0KG51bGwpOyAvLyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ09iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNQbGFpbk9iamVjdFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHBsYWluIG9iamVjdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIHBsYWluIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IG9iaiA9IHt9O1xyXG4gKlxyXG4gKiBpZlBsYWluT2JqZWN0KG9iaik7IC8vIHRydWVcclxuICpcclxuICogT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iamVjdCwgbnVsbCk7XHJcbiAqXHJcbiAqIGlmUGxhaW5PYmplY3Qob2JqKTsgLy8gdHJ1ZVxyXG4gKlxyXG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqZWN0LCB7fSk7XHJcbiAqXHJcbiAqIGlmUGxhaW5PYmplY3Qob2JqKTsgLy8gZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xyXG5cclxuICBpZiAoaXNOdWxsKHByb3RvKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xyXG5cclxuICByZXR1cm4gaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiZcclxuICAgIGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgY29uc3RydWN0b3IgJiZcclxuICAgIGlzTnVsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc1ByaW1pdGl2ZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBwcmltaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgcHJpbWl0aXZlIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNQcmltaXRpdmUoMSk7ICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNQcmltaXRpdmUoe30pOyAgICAgICAgICAgIC8vIGZhbHNlXHJcbiAqIGlzUHJpbWl0aXZlKCcnKTsgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzUHJpbWl0aXZlKG5ldyBOdW1iZXIoMCkpOyAvLyBmYWxzZVxyXG4gKiBpc1ByaW1pdGl2ZSh0cnVlKTsgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc1ByaW1pdGl2ZShTeW1ib2woJ2ZvbycpKTsgLy8gdHJ1ZVxyXG4gKiBpc1ByaW1pdGl2ZShudWxsKTsgICAgICAgICAgLy8gdHJ1ZVxyXG4gKiBpc1ByaW1pdGl2ZSh1bmRlZmluZWQpOyAgICAgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzTnVsbCh2YWx1ZSkgfHwgL14obnVtYmVyfHN0cmluZ3xib29sZWFufHN5bWJvbHx1bmRlZmluZWQpJC8udGVzdCh0eXBlb2YgdmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzUmVnRXhwXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaXNSZWdFeHAoL2Zvby8pOyAgICAgICAgICAgICAvLyB0cnVlXHJcbiAqIGlzUmVnRXhwKCcvZm9vLycpOyAgICAgICAgICAgLy8gZmFsc2VcclxuICogaXNSZWdFeHAobmV3IFJlZ0V4cCgnZm9vJykpOyAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnUmVnRXhwJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc1N0cmluZ1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZy5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZyBvciBub3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGlzU3RyaW5nKCcwJyk7ICAgICAgICAgICAgIC8vIHRydWVcclxuICogaXNTdHJpbmcobmV3IFN0cmluZygnMCcpKTsgLy8gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1N0cmluZyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNTeW1ib2xcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSBzeW1ib2wuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBzeW1ib2wgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc1N5bWJvbChTeW1ib2woJzEnKSk7IC8vIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdTeW1ib2wnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzVW5kZWZpbmVkXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIHVuZGVmaW5lZC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWQgb3Igbm90LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpc1VuZGVmaW5lZChudWxsKTsgICAgICAvLyBmYWxzZVxyXG4gKiBpc1VuZGVmaW5lZCh1bmRlZmluZWQpOyAvLyB0cnVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBEXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEQgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBEXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gQW55IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7RFdyYXB9IFdyYXAgb2YgdGhlIGFyZ3VtZW50LlxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgRC13cmFwIG9mIGFuIG9iamVjdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogRCh7fSk7ICAgICAgICAgICAgLy8gU3VwZXJcclxuICogRCgoKSA9PiB7fSk7ICAgICAgLy8gRnVuY1xyXG4gKiBEKFtdKTsgICAgICAgICAgICAvLyBBcnJcclxuICogRCgxKTsgICAgICAgICAgICAgLy8gTnVtXHJcbiAqIEQoJzEnKTsgICAgICAgICAgIC8vIFN0clxyXG4gKiBEKG5ldyBEYXRlKCkpOyAgICAvLyBEYXRcclxuICogRChkb2N1bWVudC5ib2R5KTsgLy8gRWxlbVxyXG4gKi9cclxuZnVuY3Rpb24gRCh2YWx1ZSkge1xyXG4gIGZvciAobGV0IGkgPSBjb25zdHJ1Y3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgIGNvbnN0IGxldmVsQ29uc3RydWN0b3JzID0gY29uc3RydWN0b3JzW2ldO1xyXG5cclxuICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBsZXZlbENvbnN0cnVjdG9ycy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGxldmVsQ29uc3RydWN0b3JzW2tdO1xyXG5cclxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29uc3RydWN0b3IuY2xzKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29uc3RydWN0b3IuY2hlY2sodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3Rvci5jbHModmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMvY2hlY2tUeXBlcyc7XHJcbmV4cG9ydCB7IEQgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9pdGVyYXRlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGl0ZXJhdGUgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGlzQXJyYXlMaWtlLCBpc1VuZGVmaW5lZCB9IGZyb20gJy4vY2hlY2tUeXBlcyc7XHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEl0ZXJhdGlvbkNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBJdGVyYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gSXRlcmF0aW9uIGtleS5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJbml0aWFsIGl0ZXJhYmxlIG9iamVjdC5cclxuICovXHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGl0ZXJhdGVcclxuICogQHBhcmFtIHsoT2JqZWN0fEFycmF5fG51bGx8dW5kZWZpbmVkKX0gb2JqZWN0IC0gVmFsdWUgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMgeyp9IElmIGNhbGxiYWNrIHJldHVybnMgbm90IHVuZGVmaW5lZCB0aGVuIGl0ZXJhdGUgcmV0dXJucyB0aGlzIHZhbHVlLlxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGl0ZXJhdGluZyBvdmVyIGFsbCB0eXBlcyBvZiB2YWx1ZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXRlcmF0ZShvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgY29uc3QgYXJyYXkgPSBpc0FycmF5TGlrZShvYmplY3QpO1xyXG4gIGNvbnN0IGl0ZXJhdGVkS2V5cyA9IHt9O1xyXG5cclxuICBsZXQgaXRlcmF0ZWQgPSAwO1xyXG5cclxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhdGVkS2V5cywga2V5KSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlZEtleXNba2V5XSA9IHRydWU7XHJcblxyXG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XHJcbiAgICAgIGlmIChhcnJheSAmJiBpdGVyYXRlZCsrID49IG9iamVjdC5sZW5ndGgpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdmFsdWUgPSBjYWxsYmFjayhvYmplY3Rba2V5XSwgYXJyYXkgPyBOdW1iZXIoa2V5KSA6IGtleSwgb2JqZWN0KTtcclxuXHJcbiAgICAgIGlmICghaXNVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvYXNzaWduXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIE9iamVjdC5hc3NpZ24tbGlrZSBtZXRob2QuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgaXRlcmF0ZSB9IGZyb20gJy4vaXRlcmF0ZSc7XHJcblxyXG4vKipcclxuICogQGNvbnN0XHJcbiAqIEBmdW5jdGlvbiBhc3NpZ25cclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCB0byBhc3NpZ24gcmVzdCBvZiBhcmd1bWVudHMgdG8uXHJcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzIC0gT2JqZWN0cyB0aGF0IGFyZSBhc3NpZ25lZCB0byB0aGUgdGFyZ2V0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgLi4ub2JqZWN0cykge1xyXG4gIGl0ZXJhdGUoYXJndW1lbnRzLCAoc291cmNlLCBpbmRleCkgPT4ge1xyXG4gICAgaWYgKGluZGV4KSB7XHJcbiAgICAgIGl0ZXJhdGUoc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gICAgXHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL2RlZmluZVByb3BlcnR5XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRlZmluZVByb3BlcnR5IGFuZCBkeW5hbWljRGVmaW5lUHJvcGVydGllcyBtZXRob2RzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBwcm9wZXJ0eUdlbmVyYXRvckNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gSW5kZXggb2YgdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyB7Kn0gR2VuZXJhdGVkIHByb3BlcnR5LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZHluYW1pY0RlZmluZVByb3BlcnRpZXNcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXMgLSBPYmplY3Qgd2hpY2gga2V5cyBhcmUgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtwcm9wZXJ0eUdlbmVyYXRvckNhbGxiYWNrfSBwcm9wZXJ0eUdlbmVyYXRvciAtIENhbGxiYWNrIGZvciBldmVyeSBwcm9wZXJ0eS5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiBmb3IgZHluYW1pYyBjcmVhdGluZyBwcm9wZXJ0aWVzIGJhc2VkIG9uIG5hbWUgb2YgdGhlIG1ldGhvZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljRGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMsIHByb3BlcnR5R2VuZXJhdG9yKSB7XHJcbiAgaXRlcmF0ZShwcm9wZXJ0aWVzLCAobmFtZSwgaSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICB2YWx1ZTogcHJvcGVydHlHZW5lcmF0b3IobmFtZSwgaSksXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBkZWZpbmluZyBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xyXG4gIGl0ZXJhdGUocHJvcGVydGllcywgKG1ldGhvZCwgbmFtZSkgPT4ge1xyXG4gICAgaWYgKC9eZ2V0IC8udGVzdChuYW1lKSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLnJlcGxhY2UoL15nZXQgLywgJycpLCB7XHJcbiAgICAgICAgZ2V0OiBtZXRob2QsXHJcbiAgICAgICAgc2V0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgvXnNldCAvLnRlc3QobmFtZSkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZS5yZXBsYWNlKC9ec2V0IC8sICcnKSwge1xyXG4gICAgICAgIHNldDogbWV0aG9kLFxyXG4gICAgICAgIGdldDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoL15nZXRcXC9zZXQgLy50ZXN0KG5hbWUpKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUucmVwbGFjZSgvXmdldFxcL3NldCAvLCAnJyksIHtcclxuICAgICAgICBnZXQ6IG1ldGhvZC5nZXQsXHJcbiAgICAgICAgc2V0OiBtZXRob2Quc2V0LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmFtZSAhPT0gJ1N5bWJvbC50b1N0cmluZ1RhZycpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBtZXRob2QsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvdG9BcnJheVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyB0b0FycmF5IG1ldGhvZC5cclxuICovXHJcblxyXG5pbXBvcnQgeyBpc0FycmF5LCBpc0FycmF5TGlrZSwgaXNTdHJpbmcgfSBmcm9tICcuL2NoZWNrVHlwZXMnO1xyXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gdG9BcnJheVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQW55IHZhbHVlLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjcmVhdGVOZXdBcnJheSA9IGZhbHNlXSAtIElmIGl0IGlzIG5lZWRlZCB0byBjcmVhdGUgbmV3IGFycmF5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IENyZWF0ZSBhcnJheS5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBhcnJheSBvZiBhbnkgdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgY3JlYXRlTmV3QXJyYXkpIHtcclxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgIWNyZWF0ZU5ld0FycmF5KSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBhcnJheSA9IFtdO1xyXG5cclxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmICFpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgIGl0ZXJhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xyXG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhcnJheS5wdXNoKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhcnJheTtcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3ZhbGlkYXRlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHZhbGlkYXRlIG1ldGhvZC5cclxuICovXHJcblxyXG5pbXBvcnQgeyB2YWxpZGF0ZUNoZWNrRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnLi9pdGVyYXRlJztcclxuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4vY2hlY2tUeXBlcyc7XHJcblxyXG5jb25zdCBudW1iZXJzID0gWycxc3QnLCAnMm5kJywgJzNyZCcsICc0dGgnLCAnNXRoJywgJzZ0aCcsICc3dGgnXTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gdmFsaWRhdGVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHMgb2YgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHdpdGggdmFsaWRhdGUgcGFyYW1ldGVycy5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHdoYXQgY2FsbGVkIHZhbGlkYXRlLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjaGVja2luZyBhcmd1bWVudHMgb2Ygb3RoZXIgZnVuY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGFyZ3MsIG9wdGlvbnMsIG5hbWUpIHtcclxuICBpdGVyYXRlKG9wdGlvbnMsIChhcnJheSwgbnVtYmVyKSA9PiB7XHJcbiAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgIGFycmF5ID0gW2FycmF5XTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGFycmF5LCAoY2hlY2tlcikgPT4ge1xyXG4gICAgICBjaGVja2VyID0gdmFsaWRhdGVDaGVja0V4cHJlc3Npb25zW2NoZWNrZXJdO1xyXG5cclxuICAgICAgaWYgKCFjaGVja2VyLmNoZWNrKGFyZ3NbbnVtYmVyXSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY2hlY2tlci5lcnJvcihjaGVja2VyLnRleHQucmVwbGFjZSgnJG4nLCBudW1iZXJzW251bWJlcl0pICsgKG5hbWUgPyBgIChhdCAkeyBuYW1lIH0pYCA6ICcnKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIEFscGhhYmV0XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBBbHBoYWJldCBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBpc1N0cmluZywgdmFsaWRhdGUsIGRlZmluZVByb3BlcnRpZXMsIFN5bWJvbCB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge1N0cmluZ30gQ2hhclxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBBIHN0cmluZyBvZiBvbmUgY2hhci5cclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIEFscGhhYmV0XHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtBcnJheUxpa2V9IGFscGhhYmV0IC0gQWxwaGFiZXQgdG8gd3JhcC5cclxuICogQHJldHVybnMge0FscGhhYmV0fSBJbnN0YW5jZSBvZiBBbHBoYWJldC5cclxuICogQGRlc2NyaXB0aW9uIENsYXNzIGZvciBhbHBoYWJldCBtYW5pcHVsYXRpb25zOiBhZGQsIGRlbGV0ZSBzeW1ib2xzLCBnZW5lcmF0ZSBhIHRva2VuIGZyb20gYW4gYWxwaGFiZXQsXHJcbiAqIGNoZWNrIGlmIGFuIGFscGhhYmV0IGNvbnRhaW5zIGEgd29yZC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogbmV3IEFscGhhYmV0KFsnYScsICdiJywgJ2MnXSk7XHJcbiAqL1xyXG5jbGFzcyBBbHBoYWJldCB7XHJcbiAgY29uc3RydWN0b3IoYWxwaGFiZXQgPSBbXSkge1xyXG4gICAgY29uc3QgYSA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhbHBoYWJldC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjaGFyID0gYWxwaGFiZXRbaV07XHJcblxyXG4gICAgICBpZiAoIWNoZWNrKGNoYXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgbXVzdCBiZSBhIHNpbmdsZSBjaGFyISAoaW4gQWxwaGFiZXQpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFbY2hhcl0gPSBjaGFyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBBbHBoYWJldCMkJFxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBhbHBoYWJldC5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICckJCcsIHsgdmFsdWU6IGEgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFscGhhYmV0I2FkZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLkNoYXJ9IGNoYXJzIC0gQ2hhcnMgdG8gYWRkLlxyXG4gICAqIEByZXR1cm5zIHtBbHBoYWJldH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgbGV0dGVycyB0byB0aGUgYWxwaGFiZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGFscGhhYmV0ID0gbmV3IEFscGhhYmV0KFsnYScsICdiJywgJ2MnXSk7XHJcbiAgICpcclxuICAgKiBhbHBoYWJldC5hZGQoJ2QnLCAnZScpO1xyXG4gICAqXHJcbiAgICogYWxwaGFiZXQuZ2V0KCkuJDsgLy8gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxyXG4gICAqL1xyXG4gIGFkZCguLi5jaGFycykge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc1tpXTtcclxuXHJcbiAgICAgIGlmICghY2hlY2soY2hhcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VhY2ggYXJndW1lbnQgbXVzdCBiZSBhIHNpbmdsZSBjaGFyISAoaW4gQWxwaGFiZXQjYWRkKScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLiQkW2NoYXJdID0gY2hhcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQWxwaGFiZXQjY29udGFpbnNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHdvcmQgLSBXb3JkIHRvIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBhbHBoYWJldCBvciBub3QuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB3b3JkIGluIHRoZSBhbHBoYWJldCBvciBub3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgYSB3b3JkIGlzIGluIGFscGhhYmV0IG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgYWxwaGFiZXQgPSBuZXcgQWxwaGFiZXQoWydmJywgJ2InLCAnbycsICdhJywgJ3InXSk7XHJcbiAgICpcclxuICAgKiBhbHBoYWJldC5jb250YWlucygnZm9vJyk7IC8vIHRydWVcclxuICAgKiBhbHBoYWJldC5jb250YWlucygnYmFyJyk7IC8vIHRydWVcclxuICAgKiBhbHBoYWJldC5jb250YWlucygnYmF6Jyk7IC8vIGZhbHNlXHJcbiAgICovXHJcbiAgY29udGFpbnMod29yZCkge1xyXG4gICAgdmFsaWRhdGUoW3dvcmRdLCBbJ3N0cmluZyddLCAnQWxwaGFiZXQjY29udGFpbnMnKTtcclxuXHJcbiAgICBjb25zdCBhbHBoYWJldCA9IHRoaXMuJCQ7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHdvcmQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFhbHBoYWJldFt3b3JkW2ldXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBbHBoYWJldCNkZWxldGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5DaGFyfSBjaGFycyAtIENoYXJzIHRvIGRlbGV0ZS5cclxuICAgKiBAcmV0dXJucyB7QWxwaGFiZXR9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWxldGluZyBsZXR0ZXJzIGZyb20gdGhlIGFscGhhYmV0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldChbJ2EnLCAnYicsICdjJywgJ2QnXSk7XHJcbiAgICpcclxuICAgKiBhbHBoYWJldC5kZWxldGUoJ2EnKTtcclxuICAgKlxyXG4gICAqIGFscGhhYmV0LmdldCgpLiQ7IC8vIFsnYicsICdjJywgJ2QnXVxyXG4gICAqXHJcbiAgICogYWxwaGFiZXQuZGVsZXRlKCdiJywgJ2QnKTtcclxuICAgKlxyXG4gICAqIGFscGhhYmV0LmdldCgpLiQ7IC8vIFsnYyddXHJcbiAgICovXHJcbiAgZGVsZXRlKC4uLmNoYXJzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY2hhcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xyXG5cclxuICAgICAgaWYgKCFjaGVjayhjaGFyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRWFjaCBhcmd1bWVudCBtdXN0IGJlIGEgc2luZ2xlIGNoYXIhIChpbiBBbHBoYWJldCNkZWxldGUpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRlbGV0ZSB0aGlzLiQkW2NoYXJdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBbHBoYWJldCNnZXRcclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFdyYXAgb2YgYW4gYXJyYXkgb2YgYWxwaGFiZXQgbGV0dGVycy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIGFycmF5IG9mIGFscGhhYmV0IGxldHRlcnMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBBbHBoYWJldChbJ2EnLCAnYicsICdjJ10pLmdldCgpLiQ7IC8vIFsnYScsICdiJywgJ2MnXVxyXG4gICAqL1xyXG4gIGdldCgpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiQkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQWxwaGFiZXQjdG9rZW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRva2VuIGxlbmd0aC5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUb2tlbi5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZW5lcmF0aW5nIHJhbmRvbSB0b2tlbiB3aXRoIGdpdmVuIGxlbmd0aC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFscGhhYmV0KFsnYScsICdiJywgJ2MnXSkudG9rZW4oNCk7IC8vICdhYmNiJ1xyXG4gICAqL1xyXG4gIHRva2VuKGxlbmd0aCkge1xyXG4gICAgdmFsaWRhdGUoW2xlbmd0aF0sIFtbJ2ludExpa2UnLCAnPjAnXV0sICdBbHBoYWJldCN0b2tlbicpO1xyXG5cclxuICAgIGNvbnN0IGFscGhhYmV0ID0gT2JqZWN0LmtleXModGhpcy4kJCk7XHJcbiAgICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGg7XHJcbiAgICBsZXQgdG9rZW4gPSAnJztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRva2VuICs9IGFscGhhYmV0W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbildO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b2tlbjtcclxuICB9XHJcbn1cclxuXHJcbmRlZmluZVByb3BlcnRpZXMoQWxwaGFiZXQucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdBbHBoYWJldCdcclxufSk7XHJcblxyXG5mdW5jdGlvbiBjaGVjayhjaGFyKSB7XHJcbiAgcmV0dXJuIGlzU3RyaW5nKGNoYXIpICYmIGNoYXIubGVuZ3RoID09PSAxO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGFscGhhYmV0XHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIFN0cmluZyB0byBnZW5lcmF0ZSBhbiBhbHBoYWJldCBmcm9tLlxyXG4gKiBAcmV0dXJucyB7QWxwaGFiZXR9IE5ldyBpbnN0YW5jZSBvZiBBbHBoYWJldC5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBhbHBoYWJldCBmcm9tIGEgc3RyaW5nIHRoYXQgaGFzIGZvcm1hdCBsaWtlIHRoaXM6XHJcbiAqICcmbHQ7Y2hhcjEmZ3Q7LSZsdDtjaGFyMiZndDsgJmx0O2NoYXIzJmd0Oy0mbHQ7Y2hhcjQmZ3Q7J1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBhMSA9IGFscGhhYmV0KCdhLWMgMS0zJyk7XHJcbiAqIGNvbnN0IGEyID0gYWxwaGFiZXQoJzUtNWYtZycpO1xyXG4gKlxyXG4gKiBhMS5nZXQoKS4kOyAvLyBbJzEnLCAnMicsICczJywgJ2EnLCAnYicsICdjJ11cclxuICogYTIuZ2V0KCkuJDsgLy8gWyc1JywgJ2YnLCAnZyddXHJcbiAqL1xyXG5mdW5jdGlvbiBhbHBoYWJldChzdHJpbmcpIHtcclxuICB2YWxpZGF0ZShbc3RyaW5nXSwgWydzdHJpbmcnXSk7XHJcblxyXG4gIGNvbnN0IHJhbmdlcyA9IHN0cmluZy5zcGxpdCgvKFtcXHNcXFNdLStbXFxzXFxTXSk/L2cpO1xyXG4gIGNvbnN0IGxlbmd0aCA9IHJhbmdlcy5sZW5ndGg7XHJcbiAgY29uc3QgYWxwaGFiZXQgPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07XHJcblxyXG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZSA9PT0gJyAnKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgvLS8udGVzdChyYW5nZSkgJiYgIS9bXFxzXFxTXS0rW1xcc1xcU10vLnRlc3QocmFuZ2UpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcGFydCBvZiB0aGUgc3RyaW5nICgkeyByYW5nZSB9KSEgKGluIGFscGhhYmV0KWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgvLS8udGVzdChyYW5nZSkpIHtcclxuICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5jaGFyQ29kZUF0KDApO1xyXG4gICAgICBjb25zdCBlbmQgPSByYW5nZS5jaGFyQ29kZUF0KDIpO1xyXG5cclxuICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFydCBvZiB0aGUgcmFuZ2UgbXVzdCBiZSBiZWZvcmUgaXRzIGVuZCEgKGluIGFscGhhYmV0KScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gZW5kIC0gc3RhcnQgKyAxOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgICBhbHBoYWJldC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQgKyBrKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgYWxwaGFiZXQucHVzaChyYW5nZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IEFscGhhYmV0KGFscGhhYmV0KTtcclxufVxyXG5cclxuZXhwb3J0IHsgQWxwaGFiZXQsIGFscGhhYmV0IH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIFN3aXRjaGVyXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtaXhpblxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBTd2l0Y2hlciBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCxcclxuICBpdGVyYXRlLCBTeW1ib2wsIHRvQXJyYXksIGRlZmluZVByb3BlcnRpZXNcclxufSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsnYm9vbGVhbid8J2VxdWFscyd8J3N0cmljdEVxdWFscyd8J2NhbGwnfSBTd2l0Y2hlck1vZGVcclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRW51bSB0eXBlIG9mIHN3aXRjaGVyIG1vZGVzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgU3dpdGNoZXJDYWxsQ2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gU3dpdGNoZXIgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufCp9IE9uIHdoYXQgdGhlIGNhbGxiYWNrIHJldHVybnMgZGVwZW5kcyBpZiB0aGUgY2FzZSBpcyBhIG1hdGNoICh0cnV0aHkgZm9yIHRoZSBtYXRjaCkuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBTd2l0Y2hlck1hdGNoQ2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgLSBBcmd1bWVudHMgZnJvbSB0aGUgc2Vjb25kIGFyZ3VtZW50IHRoYXQgc3dpdGNoZXIgd2FzIGNhbGxlZCB3aXRoLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gU3dpdGNoZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Kn0gbWF0Y2hlZCAtIFN3aXRjaGVyIG1hdGNoZWQgY2FzZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIFN3aXRjaGVyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtPYmplY3R9IFtjYXNlcyA9IHt9XSAtIE9iamVjdCBvZiBjYXNlcy5cclxuICogQHBhcmFtIHtTd2l0Y2hlck1vZGV9IFttb2RlID0gJ2VxdWFscyddIC0gU3dpdGNoZXIgbW9kZS5cclxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSAtIFN3aXRjaGVyIGRlZmF1bHQgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtTd2l0Y2hlcn0gLSBJbnN0YW5jZSBvZiBTd2l0Y2hlci5cclxuICogQGRlc2NyaXB0aW9uIFN3aXRjaGVyIGNsYXNzIGZvciBjcmVhdGluZyBmdW5jdGlvbnMgd29ya2luZyBzaW1pbGFyIHRvIHN3aXRjaCAodmFsdWUpIHt9IGNvbnN0cnVjdGlvbixcclxuICogYnV0IHdpdGggdGhlIHZhbHVlIGFzc2lnbm1lbnQuIFN3aXRjaGVyIGluc3RhbmNlIGlzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgdmFsdWUgYXJndW1lbnQgYW5kIGFuIG9wdGlvbmFsXHJcbiAqIGFyZ3MgYXJndW1lbnQuIEFyZ3Mgd2l0aCBhZGRpdGlvbmFsIHN3aXRjaGVyIHZhbHVlIGFuZCBtYXRjaGVkIGNhc2VcclxuICogYXJlIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvbiBvZiB0aGUgbWF0Y2hlZCBjYXNlIChpZiBpdCBpcyBhIGZ1bmN0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3Qgc3dpdGNoZXIgPSBuZXcgU3dpdGNoZXIoKTtcclxuICogY29uc3Qgc3dpdGNoZXIgPSBuZXcgU3dpdGNoZXIoe1xyXG4gKiAgIGNhc2UxOiAndmFsdWUxJyxcclxuICogICBjYXNlMjogJ3ZhbHVlMidcclxuICogfSk7XHJcbiAqIGNvbnN0IHN3aXRjaGVyID0gbmV3IFN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnKTtcclxuICogY29uc3Qgc3dpdGNoZXIgPSBuZXcgU3dpdGNoZXIoe1xyXG4gKiAgIGNhc2UxOiAndmFsdWUxJyxcclxuICogICBjYXNlMjogJ3ZhbHVlMidcclxuICogfSwgJ3N0cmljdEVxdWFscycpO1xyXG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgJ2RlZmF1bHRWYWx1ZScpO1xyXG4gKiBjb25zdCBzd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XHJcbiAqICAgY2FzZTE6ICd2YWx1ZTEnLFxyXG4gKiAgIGNhc2UyOiAndmFsdWUyJ1xyXG4gKiB9LCAnc3RyaWN0RXF1YWxzJywgJ2RlZmF1bHRWYWx1ZScpO1xyXG4gKlxyXG4gKiAvLyBTZWUgW3N3aXRjaGVyXXtAbGluayBzd2l0Y2hlcn0gZXhhbXBsZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5jbGFzcyBTd2l0Y2hlciBleHRlbmRzIEZ1bmN0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihjYXNlcyA9IHt9LCBtb2RlID0gJ2VxdWFscycsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBpZiAoaXNTdHJpbmcoY2FzZXMpKSB7XHJcbiAgICAgIGlmICghaXNVbmRlZmluZWQoYXJndW1lbnRzWzFdKSkge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IG1vZGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1vZGUgPSBjYXNlcztcclxuICAgICAgY2FzZXMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBldmVudHVhbENhc2VzID0gW107XHJcblxyXG4gICAgaXRlcmF0ZShjYXNlcywgKHZhbHVlLCBDYXNlKSA9PiB7XHJcbiAgICAgIGV2ZW50dWFsQ2FzZXMucHVzaCh7IGNhc2U6IENhc2UsIHZhbHVlIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3dpdGNoZXIodmFsdWUsIGFyZ3MgPSBbXSkge1xyXG4gICAgICBjb25zdCB7IG1vZGUsIGRlZmF1bHQ6IGRlZiwgY2FzZXMgfSA9IHN3aXRjaGVyLiQkO1xyXG5cclxuICAgICAgbGV0IHJldCA9IGl0ZXJhdGUoY2FzZXMsICh7IHZhbHVlOiB2YWwsIGNhc2U6IENhc2UgfSkgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIChtb2RlID09PSAnYm9vbGVhbicgJiYgQ2FzZSkgfHxcclxuICAgICAgICAgIC8qIGVzbGludCBlcWVxZXE6IDAgKi9cclxuICAgICAgICAgIChtb2RlID09PSAnZXF1YWxzJyAmJiBDYXNlID09IHZhbHVlKSB8fFxyXG4gICAgICAgICAgKG1vZGUgPT09ICdzdHJpY3RFcXVhbHMnICYmIENhc2UgPT09IHZhbHVlKSB8fFxyXG4gICAgICAgICAgKG1vZGUgPT09ICdjYWxsJyAmJiBDYXNlKHZhbHVlKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiB7IGNhc2U6IENhc2UsIHZhbHVlOiB2YWwgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHJldCkpIHtcclxuICAgICAgICByZXQgPSB7IHZhbHVlOiBkZWYgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJldC52YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcmV0LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcmdzID0gdG9BcnJheShhcmdzLCB0cnVlKTtcclxuICAgICAgYXJncy5wdXNoKHZhbHVlLCByZXQuY2FzZSk7XHJcblxyXG4gICAgICByZXR1cm4gcmV0LnZhbHVlLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciBTd2l0Y2hlciMkJFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNhc2VzIC0gQXJyYXkgb2YgY2FzZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge1N3aXRjaGVyTW9kZX0gbW9kZSAtIFN3aXRjaGVyIG1vZGUuXHJcbiAgICAgKiBAcHJvcGVydHkgeyp9IGRlZmF1bHQgLSBTd2l0Y2hlciBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbmZpZyBwYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3dpdGNoZXIsICckJCcsIHtcclxuICAgICAgdmFsdWU6IHtcclxuICAgICAgICBjYXNlczogZXZlbnR1YWxDYXNlcyxcclxuICAgICAgICBtb2RlLFxyXG4gICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRWYWx1ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihzd2l0Y2hlciwgU3dpdGNoZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICByZXR1cm4gc3dpdGNoZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN3aXRjaGVyI2Nhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfFN3aXRjaGVyQ2FsbENhbGxiYWNrfEFycmF5LjwqfFN3aXRjaGVyQ2FsbENhbGxiYWNrPn0gY2FzZXMgLSBDYXNlIG9yIGFuIGFycmF5IG9mIGNhc2VzLlxyXG4gICAqIEBwYXJhbSB7KnxTd2l0Y2hlck1hdGNoQ2FsbGJhY2t9IHZhbHVlIC0gVmFsdWUgdGhhdCBoYXMgdG8gYmUgYXNzaWduZWQgb3IgYSBmdW5jdGlvblxyXG4gICAqIHRoYXQgaXMgY2FsbGVkIHdpdGggc3dpdGNoZXIgdmFsdWUsIGlmIGl0J3MgdGhlIGNhc2UuXHJcbiAgICogQHJldHVybnMge1N3aXRjaGVyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZGVmaW5pbmcgbmV3IGNhc2VzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBzdyA9IG5ldyBTd2l0Y2hlcigpXHJcbiAgICogICAuY2FzZSgxLCAnb25lJylcclxuICAgKiAgIC5jYXNlKDIsICd0d28nKTtcclxuICAgKlxyXG4gICAqIHN3KDEpOyAvLyAnb25lJ1xyXG4gICAqIHN3KDIpOyAvLyAndHdvJ1xyXG4gICAqL1xyXG4gIGNhc2UoY2FzZXMsIHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoY2FzZXMpKSB7XHJcbiAgICAgIGNhc2VzID0gW2Nhc2VzXTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGNhc2VzLCAoQ2FzZSkgPT4ge1xyXG4gICAgICB0aGlzLiQkLmNhc2VzLnB1c2goeyBjYXNlOiBDYXNlLCB2YWx1ZSB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTd2l0Y2hlciNkZWZhdWx0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gZGVmIC0gTmV3IGRlZmF1bHQgdmFsdWUuXHJcbiAgICogQHJldHVybnMge1N3aXRjaGVyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcmVkZWZpbmluZyBkZWZhdWx0IHN3aXRjaGVyIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBzdyA9IG5ldyBTd2l0Y2hlcigpXHJcbiAgICogICAuY2FzZSgxLCAnb25lJylcclxuICAgKiAgIC5kZWZhdWx0KCd0aHJlZScpO1xyXG4gICAqXHJcbiAgICogc3coMSk7IC8vICdvbmUnXHJcbiAgICogc3coMik7IC8vICd0aHJlZSdcclxuICAgKi9cclxuICBkZWZhdWx0KGRlZikge1xyXG4gICAgdGhpcy4kJC5kZWZhdWx0ID0gZGVmO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTd2l0Y2hlciNtb2RlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3dpdGNoZXJNb2RlfSBtb2RlIC0gTmV3IHN3aXRjaGVyIG1vZGUuXHJcbiAgICogQHJldHVybnMge1N3aXRjaGVyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcmVkZWZpbmluZyBzd2l0Y2hlciBtb2RlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBzdyA9IG5ldyBTd2l0Y2hlcigpXHJcbiAgICogICAubW9kZSgnc3RyaWN0RXF1YWxzJylcclxuICAgKiAgIC5jYXNlKDEsICdudW1iZXInKVxyXG4gICAqICAgLmNhc2UoJzEnLCAnc3RyaW5nJyk7XHJcbiAgICpcclxuICAgKiBzdygxKTsgICAvLyAnbnVtYmVyJ1xyXG4gICAqIHN3KCcxJyk7IC8vICdzdHJpbmcnXHJcbiAgICovXHJcbiAgbW9kZShtb2RlKSB7XHJcbiAgICB0aGlzLiQkLm1vZGUgPSBtb2RlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhTd2l0Y2hlci5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1N3aXRjaGVyJ1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gc3dpdGNoZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW2Nhc2VzID0ge31dIC0gT2JqZWN0IG9mIGNhc2VzLlxyXG4gKiBAcGFyYW0ge1N3aXRjaGVyTW9kZX0gW21vZGUgPSAnZXF1YWxzJ10gLSBTd2l0Y2hlciBtb2RlLlxyXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIC0gU3dpdGNoZXIgZGVmYXVsdCB2YWx1ZS5cclxuICogQHJldHVybnMge1N3aXRjaGVyfSBOZXcgaW5zdGFuY2Ugb2YgU3dpdGNoZXIuXHJcbiAqIEBkZXNjcmlwdGlvbiBTaW1wbGUgd3JhcCBvZiBbbmV3IFN3aXRjaGVyKC4uLilde0BsaW5rIFN3aXRjaGVyfS5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IHN3ID0gc3dpdGNoZXIoe1xyXG4gKiAgIDE6ICdmb28nLFxyXG4gKiAgIDI6ICdiYXInXHJcbiAqIH0pO1xyXG4gKiBzdygxKTsgLy8gJ2ZvbydcclxuICogc3coMik7IC8vICdiYXInXHJcbiAqIHN3KDMpOyAvLyB1bmRlZmluZWRcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IHN3ID0gc3dpdGNoZXIoKVxyXG4gKiAgIC5jYXNlKFsxLCAyXSwgJ2ZvbycpXHJcbiAqICAgLmNhc2UoMywgJ2JhcicpO1xyXG4gKiAgIFxyXG4gKiBzdygxKTsgLy8gJ2ZvbydcclxuICogc3coMik7IC8vICdmb28nXHJcbiAqIHN3KDMpOyAvLyAnYmFyJ1xyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogY29uc3Qgc3cgPSBzd2l0Y2hlcignY2FsbCcpXHJcbiAqICAgLmNhc2UoaXNBcnJheSwgJ2FycmF5JylcclxuICogICAuY2FzZShpc1N0cmluZywgJ3N0cmluZycpXHJcbiAqICAgLmNhc2UoaXNOdW1iZXIsICdudW1iZXInKVxyXG4gKiAgIC5kZWZhdWx0KCdyZXN0Jyk7XHJcbiAqICAgXHJcbiAqIHN3KFtdKTsgICAgLy8gJ2FycmF5J1xyXG4gKiBzdygnZm9vJyk7IC8vICdzdHJpbmcnXHJcbiAqIHN3KDEyMyk7ICAgLy8gJ251bWJlcidcclxuICogc3coe30pOyAgICAvLyAncmVzdCdcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IHN3ID0gc3dpdGNoZXIoe1xyXG4gKiAgIDE6ICh2YWx1ZSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codmFsdWUgKyAxKTtcclxuICogICB9LFxyXG4gKiAgIDI6ICgpID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHZhbHVlIC0gMSk7XHJcbiAqICAgfVxyXG4gKiB9KTtcclxuICogXHJcbiAqIHN3KDEpOyAvLyAyXHJcbiAqIHN3KDIpOyAvLyAxXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBzdyA9IHN3aXRjaGVyKHtcclxuICogICBmaXJzdDogKGFycmF5KSA9PiBhcnJheVswXSxcclxuICogICBsYXN0OiAoYXJyYXkpID0+IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdXHJcbiAqIH0sICdlcXVhbHMnLCAoYXJyYXksIGluZGV4KSA9PiBhcnJheVtpbmRleF0pO1xyXG4gKiBjb25zdCBhcnJheSA9IFsxLCAyLCAzLCA0XTtcclxuICogXHJcbiAqIHN3KCdmaXJzdCcsIFthcnJheV0pOyAvLyAxXHJcbiAqIHN3KCdsYXN0JywgW2FycmF5XSk7ICAvLyA0XHJcbiAqIHN3KDEsIFthcnJheV0pOyAgICAgICAvLyAyXHJcbiAqIHN3KDIsIFthcnJheV0pOyAgICAgICAvLyAzXHJcbiAqL1xyXG5mdW5jdGlvbiBzd2l0Y2hlcihjYXNlcywgbW9kZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgcmV0dXJuIG5ldyBTd2l0Y2hlciguLi5hcmd1bWVudHMpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIHdoZW5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW58Kn0gY29uZGl0aW9uIC0gQ29uZGl0aW9uIHVzZWQgZm9yIHJldHVybmluZyB0aGUgcHJvcGVyIHZhbHVlLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlMSAtIFZhbHVlIGlmIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlMiAtIFZhbHVlIGlmIHRoZSBjb25kaXRpb24gaXMgZmFsc2V5LlxyXG4gKiBAcmV0dXJucyB7Kn0gdmFsdWUxIG9yIHZhbHVlMi5cclxuICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAqIFt0ZXJuYXJ5IG9wZXJhdG9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ubC9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQ29uZGl0aW9uYWxfT3BlcmF0b3J9LlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogd2hlbih0cnVlLCAndHJ1ZScsICdmYWxzZScpOyAvLyAndHJ1ZSdcclxuICovXHJcbmZ1bmN0aW9uIHdoZW4oY29uZGl0aW9uLCB2YWx1ZTEsIHZhbHVlMikge1xyXG4gIHJldHVybiBjb25kaXRpb24gPyB2YWx1ZTEgOiB2YWx1ZTI7XHJcbn1cclxuXHJcbmV4cG9ydCB7IFN3aXRjaGVyLCBzd2l0Y2hlciwgd2hlbiB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBTdXBlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgU3VwZXIgY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRCB9IGZyb20gJy4vRCc7XHJcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi9Td2l0Y2hlcic7XHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycyB9IGZyb20gJy4vY29uc3RhbnRzL2NvbnN0cnVjdG9ycyc7XHJcbmltcG9ydCB7XHJcbiAgaXNBcnJheSwgaXNBcnJheUxpa2UsIGlzRGF0ZSwgaXNFbGVtZW50LCBpc0Z1bmN0aW9uLCBpc05pbCwgaXNOYU4sIGlzTnVsbCxcclxuICBpc09iamVjdCwgaXNQbGFpbk9iamVjdCwgaXNQcmltaXRpdmUsIGlzUmVnRXhwLCBpc1N0cmluZywgaXNVbmRlZmluZWQsXHJcbiAgdmFsaWRhdGUsIHRvU3RyaW5nVGFnLCBpdGVyYXRlLCBTeW1ib2wsIGRlZmluZVByb3BlcnRpZXNcclxufSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtTdXBlcnxBcnJ8RnVuY3xFbGVtfFN0cnxOdW18RGF0fEJsb2JPYmplY3R9IERXcmFwXHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEFueSBraW5kIG9mIEQtV3JhcC5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ8bnVsbH0gS2V5XHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEtleSB0eXBlIHVzZWQgaW4gbWFueSBtZXRob2RzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7VHJlZUVsZW1lbnRbXX0gVHJlZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyZWVFbGVtZW50XHJcbiAqIEBwdWJsaWNcclxuICogQHByb3BlcnR5IHtLZXl9IGtleSAtIFRyZWUgZWxlbWVudCBrZXkuXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWUgLSBUcmVlIGVsZW1lbnQgdmFsdWUuXHJcbiAqIEBkZXNjcmlwdGlvbiB7QGxpbmsgVHJlZX0gZWxlbWVudC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIERlZXBJdGVyYXRpb25DYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGl0ZXJhdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgLSBDdXJyZW50IGl0ZXJhdGlvbiBrZXkvaW5kZXguXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gSXRlcmF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBlbGVtZW50cy5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIERlZXBSZWR1Y2VDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSAtIFByZXZpb3VzIHZhbHVlLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQ3VycmVudCBpdGVyYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IC0gQ3VycmVudCBpdGVyYXRpb24ga2V5L2luZGV4LlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIEl0ZXJhdGlvbiBvYmplY3QuXHJcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZSAtIFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gZWxlbWVudHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGl0ZXJhdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgLSBDdXJyZW50IGl0ZXJhdGlvbiBrZXkvaW5kZXguXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gSXRlcmF0aW9uIG9iamVjdC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEpTT05DYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IGtleSAtIEN1cnJlbnQgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBDdXJyZW50IGtleS5cclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIEl0ZXJhdGlvbiBvYmplY3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBPYmplY3RDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPYmplY3QgLSBUaGUgbmV3IG9iamVjdC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQgaXRlcmF0aW9uIHZhbHVlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEN1cnJlbnQgaXRlcmF0aW9uIGtleS9pbmRleC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgUmVkdWNlQ2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgLSBQcmV2aW91cyB2YWx1ZS5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEN1cnJlbnQgaXRlcmF0aW9uIHZhbHVlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleSAtIEN1cnJlbnQgaXRlcmF0aW9uIGtleS9pbmRleC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBJdGVyYXRpb24gb2JqZWN0LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgU3VwZXJNZXRob2RcclxuICogQHB1YmxpY1xyXG4gKiBAdGhpcyB7RFdyYXB9XHJcbiAqL1xyXG5cclxuY29uc3QgY2xvbmVTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgKG9iamVjdCkgPT4gb2JqZWN0KVxyXG4gIC5jYXNlKFxyXG4gICAgKG9iamVjdCkgPT4gbmV3IFN1cGVyKG9iamVjdCkgPT09IG9iamVjdCxcclxuICAgIChvYmplY3QpID0+IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IpKG5ldyBTdXBlcihvYmplY3QuJCkuZGVlcENsb25lKCkuJClcclxuICApXHJcbiAgLmNhc2UoaXNFbGVtZW50LCAob2JqZWN0LCBkZWVwKSA9PiBvYmplY3QuY2xvbmUoZGVlcCkpXHJcbiAgLmNhc2UoaXNEYXRlLCAob2JqZWN0KSA9PiBuZXcgRGF0ZShvYmplY3QpKVxyXG4gIC5jYXNlKGlzUmVnRXhwLCAob2JqZWN0KSA9PiBuZXcgUmVnRXhwKG9iamVjdC5zb3VyY2UsIG9iamVjdC50b1N0cmluZygpLm1hdGNoKC9bZ2ltdXldKiQvKVswXSkpXHJcbiAgLmNhc2UoaXNBcnJheSwgKCkgPT4gW10pXHJcbiAgLmNhc2UoaXNQbGFpbk9iamVjdCwgKCkgPT4gKHt9KSk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFN1cGVyXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSBbb2JqZWN0XSAtIEFuIG9iamVjdCB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7RFdyYXB9IEluc3RhbmNlIG9mIFN1cGVyLlxyXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhbnkgdmFsdWUuIEFuZCB0aGVyZSBpcyBubyB3YXkgdG8gY3JlYXRlIGEgbmVzdGVkIHdyYXAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5ldyBTdXBlcih7fSk7IC8vIFN1cGVyXHJcbiAqL1xyXG5jbGFzcyBTdXBlciB7XHJcbiAgY29uc3RydWN0b3Iob2JqZWN0KSB7XHJcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3VwZXIpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIgU3VwZXIjJFxyXG4gICAgICogQHR5cGUgeyp9XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gV3JhcHBlZCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJCcsIHsgdmFsdWU6IG9iamVjdCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIuYWRkU3RhdGljUHJvcGVydGllc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYW4gb2JqZWN0XHJcbiAgICogd2l0aCBwcm9wZXJ0aWVzIGtleXMgYW5kIHZhbHVlcyB2YWx1ZXMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGlzIGhhcyB0byBiZSBhIHByb3BlcnR5IHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHt0aGlzfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFNldHMgc3RhdGljIHByb3BlcnRpZXMgZm9yIERXcmFwIGNvbnN0cnVjdG9ycy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogU3VwZXIuYWRkU3RhdGljUHJvcGVydGllcygnY29vbCcsIDQyKTtcclxuICAgKiBTdXBlci5hZGRTdGF0aWNQcm9wZXJ0aWVzKCdzdXBlckNvb2wnLCA0Mio0Mik7XHJcbiAgICovXHJcbiAgc3RhdGljIGFkZFN0YXRpY1Byb3BlcnRpZXMocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcGVydHkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlci5hZGRJbnN0YW5jZVByb3BlcnRpZXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGFuIG9iamVjdFxyXG4gICAqIHdpdGggcHJvcGVydGllcyBrZXlzIGFuZCB2YWx1ZXMgdmFsdWVzLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVdIC0gSWYgYSBwcm9wZXJ0eSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhpcyBoYXMgdG8gYmUgYSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7dGhpc30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBEV3JhcCBwcm90b3R5cGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBTdXBlci5hZGRJbnN0YW5jZVByb3BlcnRpZXMoJ2Nvb2wnLCA0Mik7XHJcbiAgICogU3VwZXIuYWRkSW5zdGFuY2VQcm9wZXJ0aWVzKCdzdXBlckNvb2wnLCA0Mio0Mik7XHJcbiAgICovXHJcbiAgc3RhdGljIGFkZEluc3RhbmNlUHJvcGVydGllcyhwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLnByb3RvdHlwZSwgcHJvcGVydHkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNhc3NpZ25cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi4oT2JqZWN0fFN1cGVyfCopfSBvYmplY3RzIC0gT2JqZWN0cyB0byBiZSBhc3NpZ25lZCB0byB0aGUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtPYmplY3QuYXNzaWduXVxyXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWdufS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiB9KS5hc3NpZ24oeyBhOiAzIH0sIHsgYzogMywgZDogNCB9LCB7IGQ6IDUgfSkuJDsgLy8geyBhOiAzLCBiOiAyLCBjOiAzLCBkOiA1IH1cclxuICAgKi9cclxuICBhc3NpZ24oLi4ub2JqZWN0cykge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGl0ZXJhdGUob2JqZWN0ICYmIGFyZ3VtZW50cywgKG8pID0+IHtcclxuICAgICAgaXRlcmF0ZShuZXcgU3VwZXIobykuJCwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNhdmVyYWdlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IG51bGxdIC0gQ2FsbGJhY2sgdGhhdCBpcyBwYXNzZWQgdG8ge0BsaW5rIFN1cGVyI3N1bX0uXHJcbiAgICogQHJldHVybnMge051bWJlcn0gQXZlcmFnZSB2YWx1ZS5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3Igb2JqZWN0LnN1bShjYWxsYmFjaykgLyBvYmplY3QuY291bnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuYXZlcmFnZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogNSB9KS5hdmVyYWdlKCh2YWx1ZSkgPT4gdmFsdWUgKiB2YWx1ZSk7IC8vIDEwXHJcbiAgICovXHJcbiAgYXZlcmFnZShjYWxsYmFjayA9IG51bGwpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb258fCEnXSwgJ1N1cGVyI2F2ZXJhZ2UnKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdW0oY2FsbGJhY2spIC8gdGhpcy5jb3VudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjY2FsbFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N1cGVyTWV0aG9kfSBmdW5jIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhpcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyAtIEFyZ3VtZW50cyB0byBiZSBjYWxsZWQgd2l0aC5cclxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJuIG9mIGZ1bmN0aW9uIGNhbGwuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIGZ1bmMuY2FsbChET2JqZWN0LCAuLi5hcmdzKTtcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSB9KS5jYWxsKGZ1bmN0aW9uIChiLCBjKSB7XHJcbiAgICogICByZXR1cm4gdGhpcy5hICsgYiArIGM7XHJcbiAgICogfSwgMiwgMyk7IC8vIDZcclxuICAgKi9cclxuICBjYWxsKGZ1bmMsIC4uLmFyZ3MpIHtcclxuICAgIHZhbGlkYXRlKFtmdW5jXSwgWydmdW5jdGlvbiddLCAnU3VwZXIjY2FsbCcpO1xyXG5cclxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNjbG9uZVxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IG9iamVjdC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGFzc2lnbnMgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IHRvIGFuIGVtcHR5IG9uZSBhbmQgcmV0dXJucyB0aGUgbmV3IG9uZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyIH0gfSkuY2xvbmUoKS4kOyAvLyB7IGE6IDEsIGI6IHsgYzogMiB9IH1cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuICAgIGNvbnN0IGNsb25lID0gY2xvbmVTd2l0Y2hlcihvYmplY3QsIFtvYmplY3QsIGZhbHNlXSk7XHJcblxyXG4gICAgaWYgKGNsb25lICE9PSBvYmplY3QpIHtcclxuICAgICAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgY2xvbmVba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoY2xvbmUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBTdXBlciNjb3VudFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBrZXlzIG9mIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIgfSkuY291bnQ7IC8vIDJcclxuICAgKi9cclxuICBnZXQgY291bnQoKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gb2JqZWN0Lmxlbmd0aCA6IE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNjcmVhdGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXNjcmlwdG9yc10gLSBEZXNjcmlwdG9ycyBwYXNzZWQgdG8gT2JqZWN0LmNyZWF0ZS5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IE5ldyBpbnN0YW5jZSBvZiBELVdyYXAuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5jcmVhdGVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGV9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoe30pLmNyZWF0ZSh7XHJcbiAgICogICBhOiB7XHJcbiAgICogICAgIHZhbHVlOiAxLFxyXG4gICAqICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgKiAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICogICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgKiAgIH1cclxuICAgKiB9KS4kOyAvLyB7IGE6IDEgfVxyXG4gICAqL1xyXG4gIGNyZWF0ZShkZXNjcmlwdG9ycykge1xyXG4gICAgcmV0dXJuIEQoaXNQcmltaXRpdmUodGhpcy4kKSA/IHVuZGVmaW5lZCA6IE9iamVjdC5jcmVhdGUodGhpcy4kLCBkZXNjcmlwdG9ycykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwQXNzaWduXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uKn0gb2JqZWN0cyAtIE9iamVjdHMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIG9iamVjdC5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjYXNzaWdufS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSB9KS5kZWVwQXNzaWduKFxyXG4gICAqICAge1xyXG4gICAqICAgICBiOiB7XHJcbiAgICogICAgICAgYzogMlxyXG4gICAqICAgICB9XHJcbiAgICogICB9LFxyXG4gICAqICAge1xyXG4gICAqICAgICBhOiB7XHJcbiAgICogICAgICAgYjogMVxyXG4gICAqICAgICB9XHJcbiAgICogICB9LFxyXG4gICAqICAge1xyXG4gICAqICAgICBhOiB7XHJcbiAgICogICAgICAgYzoge1xyXG4gICAqICAgICAgICAgZDogMVxyXG4gICAqICAgICAgIH1cclxuICAgKiAgICAgfSxcclxuICAgKiAgICAgYjogMlxyXG4gICAqICAgfSxcclxuICAgKiAgIG51bGxcclxuICAgKiB9KTtcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICBhOiB7XHJcbiAgICogLy8gICAgIGI6IDEsXHJcbiAgICogLy8gICAgIGM6IHtcclxuICAgKiAvLyAgICAgICBkOiAxXHJcbiAgICogLy8gICAgIH1cclxuICAgKiAvLyAgIH0sXHJcbiAgICogLy8gICBiOiAyLFxyXG4gICAqIC8vIH1cclxuICAgKi9cclxuICBkZWVwQXNzaWduKC4uLm9iamVjdHMpIHtcclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0KSkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKG8pID0+IHtcclxuICAgICAgZGVlcEFzc2lnbihvYmplY3QsIG8pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBDbG9uZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IE5ldyBpbnN0YW5jZSBvZiBEV3JhcC5cclxuICAgKiBAZGVzY3JpcHRpb24gRGVlcCBjbG9uaW5nIG1ldGhvZC4gQ2xvbmVzIHBsYWluIG9iamVjdHMsIGFycmF5cywgcmVndWxhciBleHByZXNzaW9ucyBhbmQgZWxlbWVudHMsIHRoZSByZXN0IHN0YXlzIHRoZSBzYW1lLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiBbMiwgM10sIGM6IHsgZDogNCB9IH0pLmRlZXBDbG9uZSgpLiQ7XHJcbiAgICogLy8ge1xyXG4gICAqIC8vICAgYTogMSxcclxuICAgKiAvLyAgIGI6IFsyLCAzXSxcclxuICAgKiAvLyAgIGM6IHsgZDogNCB9XHJcbiAgICogLy8gfVxyXG4gICAqL1xyXG4gIGRlZXBDbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihkZWVwQ2xvbmUodGhpcy4kKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBFcXVhbHNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbb2JqZWN0XSAtIE9iamVjdCB0byBjb21wYXJlIHRvLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRoZSBvYmplY3RzIGFyZSBkZWVwIGVxdWFsIG9yIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWVwIGNvbXBhcmlzb24gb2YgdHdvIG9iamVjdHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEgfSkuZGVlcEVxdWFscyh7IGE6ICcxJyB9KTsgLy8gdHJ1ZVxyXG4gICAqIG5ldyBTdXBlcigvMS8pLmRlZXBFcXVhbHMoLzEvKTsgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGRlZXBFcXVhbHMob2JqZWN0ID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLiQsIG9iamVjdCwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwRXZlcnlcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IGl0ZXJhdGlvbiBnb2VzIG9uIGFuZCBpZiBmYWxzZXkgaXQgc3RvcHMuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBhbGwgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBib29sZWFuIGlmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqIE90aGVyd2lzZSBmYWxzZS4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZXZlcnl9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA8IDQpOyAvLyB0cnVlXHJcbiAgICogbmV3IFN1cGVyKHsgYToge30sIGI6IHt9LCBjOiB7fSB9KS5kZWVwRXZlcnkoKCkgPT4gZmFsc2UpOyAgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGRlZXBFdmVyeShjYWxsYmFjaywgbikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgIG4gPSBjYWxsYmFjaztcclxuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIG4gPSBJbmZpbml0eTtcclxuICAgIH0gZWxzZSBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgbiA9IEluZmluaXR5O1xyXG4gICAgICBjYWxsYmFjayA9IEJvb2xlYW47XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrLCBuXSwgWydmdW5jdGlvbicsIFsnbnVtYmVyTGlrZScsICc+MCddXSwgJ1N1cGVyI2RlZXBFdmVyeScpO1xyXG5cclxuICAgIG4gPSBOdW1iZXIobik7XHJcblxyXG4gICAgcmV0dXJuIGRlZXBFdmVyeSh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwRmlsdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBJZiByZXR1cm5zIHRydXRoeSB0aGUgZWxlbWVudCBpcyBpbmNsdWRlZCBhbmQgaWYgZmFsc2V5IGl0J3MgZXhjbHVkZWQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gTmV3IEQtV3JhcCBvZiBmaWx0ZXJlZCBvYmplY3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgZmlsdGVyZWQgYnkgdGhlIGNhbGxiYWNrIG9iamVjdC4gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZmlsdGVyfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcEZpbHRlcigodmFsdWUpID0+IHZhbHVlJTIpLiQ7ICAgICAvLyB7IGE6IDEsIGI6IHsgZDogMyB9IH1cclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPT09IDEpLiQ7IC8vIHsgYTogMSB9XHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcEZpbHRlcigodmFsdWUpID0+IHZhbHVlID4gMykuJDsgICAvLyB7fVxyXG4gICAqL1xyXG4gIGRlZXBGaWx0ZXIoY2FsbGJhY2ssIG4pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICBuID0gY2FsbGJhY2s7XHJcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcclxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBuID0gSW5maW5pdHk7XHJcbiAgICB9IGVsc2UgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIG4gPSBJbmZpbml0eTtcclxuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwRmlsdGVyJyk7XHJcblxyXG4gICAgY29uc3QgZmlsdGVyZWQgPSBkZWVwRmlsdGVyKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSk7XHJcblxyXG4gICAgcmV0dXJuIEQoaXNOaWwoZmlsdGVyZWQpID8gZmlsdGVyZWQgOiBmaWx0ZXJlZCB8fCB7fSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBGaW5kXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBJZiByZXR1cm5zIHRydXRoeSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIGZhbHNleSBpdCBjb250aW51ZXMuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtUcmVlfG51bGx9IFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gaWYgc29tZXRoaW5nIGZvdW5kIGFuZCBudWxsIGlmIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cmVlIG9mIHRoZSBlbGVtZW50cyBpZiBzb21ldGhpbmcgZm91bmQgYW5kIG51bGwgaWYgbm90aGluZyBmb3VuZC5cclxuICAgKiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNmaW5kfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcEZpbmQoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gMik7XHJcbiAgICogLy8gW1xyXG4gICAqIC8vICAgeyBrZXk6ICdjJywgdmFsdWU6IDIgfSxcclxuICAgKiAvLyAgIHsga2V5OiAnYicsIHZhbHVlOiB7IGM6IDIsIGQ6IDMgfSB9LFxyXG4gICAqIC8vICAgeyBrZXk6IG51bGwsIHZhbHVlOiA8aW5pdGlhbCBvYmplY3Q+IH1cclxuICAgKiAvLyBdXHJcbiAgICovXHJcbiAgZGVlcEZpbmQoY2FsbGJhY2ssIG4pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICBuID0gY2FsbGJhY2s7XHJcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcclxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBuID0gSW5maW5pdHk7XHJcbiAgICB9IGVsc2UgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIG4gPSBJbmZpbml0eTtcclxuICAgICAgY2FsbGJhY2sgPSBCb29sZWFuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwRmluZCcpO1xyXG5cclxuICAgIHJldHVybiBkZWVwRmluZCh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwRm9yRWFjaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGl0ZXJhdGluZyBvdmVyIGFueSBvYmplY3QuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2ZvckVhY2h9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRm9yRWFjaCgodmFsdWUsIGtleSwgb2JqZWN0KSA9PiBvYmplY3Rba2V5XSA9IHZhbHVlICogdmFsdWUpLiQ7XHJcbiAgICogLy8geyBhOiAxLCBiOiB7IGM6IDQsIGQ6IDkgfSB9XHJcbiAgICovXHJcbiAgZGVlcEZvckVhY2goY2FsbGJhY2ssIG4gPSBJbmZpbml0eSkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrLCBuXSwgWydmdW5jdGlvbicsIFsnbnVtYmVyTGlrZScsICc+MCddXSwgJ1N1cGVyI2RlZXBGb3JFYWNoJyk7XHJcblxyXG4gICAgbiA9IE51bWJlcihuKTtcclxuXHJcbiAgICBkZWVwRm9yRWFjaCh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwRm9yRWFjaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGl0ZXJhdGluZyBvdmVyIGFueSBvYmplY3QuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI2ZvckVhY2h9LlxyXG4gICAqIFVubGlrZSB7QGxpbmsgU3VwZXIjZGVlcEZvckVhY2h9IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgb24gZXZlcnkgdmFsdWUgb2YgZXZlcnkgb2JqZWN0IGluc2lkZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwRm9yRWFjaCgodmFsdWUsIGtleSwgb2JqZWN0KSA9PiBvYmplY3Rba2V5XSA9IHZhbHVlICogdmFsdWUpLiQ7XHJcbiAgICogLy8geyBhOiAxLCBiOiB7IGM6IDQsIGQ6IDkgfSB9XHJcbiAgICovXHJcbiAgZGVlcEZvckVhY2hFbnRyeShjYWxsYmFjaywgbiA9IEluZmluaXR5KSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcEZvckVhY2gnKTtcclxuXHJcbiAgICBuID0gTnVtYmVyKG4pO1xyXG5cclxuICAgIGRlZXBGb3JFYWNoRW50cnkodGhpcy4kLCBjYWxsYmFjaywgbiwgW3sga2V5OiBudWxsLCB2YWx1ZTogdGhpcy4kIH1dKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZGVlcEZyZWV6ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gRGVlcCBhbmFsb2d1ZSBvZiB7QGxpbmsgU3VwZXIjZnJlZXplfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogeyBjOiAyLCBkOiAzIH0gfSkuZGVlcEZyZWV6ZSgpOyAvLyBTdXBlclxyXG4gICAqL1xyXG4gIGRlZXBGcmVlemUoKSB7XHJcbiAgICBkZWVwRnJlZXplKHRoaXMuJCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBNYXBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEZWVwSXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gRC1XcmFwIG9mIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgd3JhcCBvZiBhIG5ldyBvYmplY3QgdXNpbmcgdGhlIGNhbGxiYWNrLiBEZWVwIGFuYWxvZ3VlIG9mIHtAbGluayBTdXBlciNtYXB9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwTWFwKCh2YWx1ZSkgPT4gdmFsdWUgKiB2YWx1ZSkuJDtcclxuICAgKiAvLyB7IGE6IDEsIGI6IHsgYzogNCwgZDogOSB9IH1cclxuICAgKi9cclxuICBkZWVwTWFwKGNhbGxiYWNrLCBuID0gSW5maW5pdHkpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFjaywgbl0sIFsnZnVuY3Rpb24nLCBbJ251bWJlckxpa2UnLCAnPjAnXV0sICdTdXBlciNkZWVwTWFwJyk7XHJcblxyXG4gICAgbiA9IE51bWJlcihuKTtcclxuXHJcbiAgICByZXR1cm4gRChkZWVwTWFwKHRoaXMuJCwgY2FsbGJhY2ssIG4sIFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwUmVkdWNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGVlcFJlZHVjZUNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBSZXR1cm4gdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBuZXh0IGNhbGxiYWNrIGNhbGwuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEBwYXJhbSB7Kn0gW0lWID0gPGZpcnN0IHZhbHVlPnx1bmRlZmluZWRdIC0gSW5pdGlhbCB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7Kn0gTW9kaWZpZWQgSVYuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgbW9kaWZpZWQgSVYuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI3JlZHVjZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IHsgYzogMiwgZDogMyB9IH0pLmRlZXBSZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlICogdmFsdWUsIEluZmluaXR5LCAwKTsgLy8gMTRcclxuICAgKi9cclxuICBkZWVwUmVkdWNlKGNhbGxiYWNrLCBuID0gSW5maW5pdHksIElWKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcFJlZHVjZScpO1xyXG5cclxuICAgIG4gPSBOdW1iZXIobik7XHJcblxyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG4gICAgY29uc3QgdHJlZSA9IFt7IGtleTogbnVsbCwgdmFsdWU6IHRoaXMuJCB9XTtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgcmV0dXJuIGRlZXBSZWR1Y2Uob2JqZWN0LCBjYWxsYmFjaywgbiwgZmFsc2UsIHVuZGVmaW5lZCwgdHJlZSkuSVY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlZXBSZWR1Y2Uob2JqZWN0LCBjYWxsYmFjaywgbiwgZmFsc2UsIHsgSVYgfSwgdHJlZSkuSVY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2RlZXBTb21lXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBJZiByZXR1cm5zIHRydXRoeSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIGZhbHNleSBpdCBjb250aW51ZXMuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuID0gSW5maW5pdHldIC0gSXRlcmF0aW9uIGRlcHRoLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBhbGwgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cnVlIGlmIHNvbWUgb2YgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cclxuICAgKiBPdGhlcndpc2UgZmFsc2UuIERlZXAgYW5hbG9ndWUgb2Yge0BsaW5rIFN1cGVyI3NvbWV9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiB7IGM6IDIsIGQ6IDMgfSB9KS5kZWVwU29tZSgodmFsdWUpID0+IHZhbHVlID4gNCk7IC8vIGZhbHNlXHJcbiAgICogbmV3IFN1cGVyKHsgYToge30sIGI6IHt9LCBjOiB7fSB9KS5kZWVwU29tZSgoKSA9PiB0cnVlKTsgICAgICAgICAgICAgICAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGRlZXBTb21lKGNhbGxiYWNrLCBuKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgbiA9IGNhbGxiYWNrO1xyXG4gICAgICBjYWxsYmFjayA9IEJvb2xlYW47XHJcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgbiA9IEluZmluaXR5O1xyXG4gICAgfSBlbHNlIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBuID0gSW5maW5pdHk7XHJcbiAgICAgIGNhbGxiYWNrID0gQm9vbGVhbjtcclxuICAgIH1cclxuXHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2ssIG5dLCBbJ2Z1bmN0aW9uJywgWydudW1iZXJMaWtlJywgJz4wJ11dLCAnU3VwZXIjZGVlcFNvbWUnKTtcclxuXHJcbiAgICBuID0gTnVtYmVyKG4pO1xyXG5cclxuICAgIHJldHVybiBkZWVwU29tZSh0aGlzLiQsIGNhbGxiYWNrLCBuLCBbeyBrZXk6IG51bGwsIHZhbHVlOiB0aGlzLiQgfV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWVwU3RyaWN0RXF1YWxzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gW29iamVjdF0gLSBPYmplY3QgdG8gY29tcGFyZSB0by5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBJZiB0aGUgb2JqZWN0cyBhcmUgZGVlcCBzdHJpY3QgZXF1YWwgb3Igbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZXAgc3RyaWN0IGNvbXBhcmlzb24gb2YgdHdvIG9iamVjdHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEgfSkuZGVlcFN0cmljdEVxdWFscyh7IGE6ICcxJyB9KTsgLy8gZmFsc2VcclxuICAgKiBuZXcgU3VwZXIoLzEvKS5kZWVwU3RyaWN0RXF1YWxzKC8xLyk7ICAgICAgICAgICAgIC8vIHRydWVcclxuICAgKi9cclxuICBkZWVwU3RyaWN0RXF1YWxzKG9iamVjdCA9IG51bGwpIHtcclxuICAgIHJldHVybiBkZWVwRXF1YWwodGhpcy4kLCBvYmplY3QsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWZpbmVcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYSBkZXNjcmlwdG9ycyBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXNjcmlwdG9yXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgcHJvcGVydHkgZGVzY3JpcHRvci5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgYm90aFxyXG4gICAqIFtPYmplY3QuZGVmaW5lUHJvcGVydHlde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9kZWZpbmVQcm9wZXJ0eX1cclxuICAgKiBhbmRcclxuICAgKiBbT2JqZWN0LmRlZmluZVByb3BlcnRpZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9kZWZpbmVQcm9wZXJ0aWVzfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHt9KS5kZWZpbmUoJ2EnLCB7XHJcbiAgICogICB2YWx1ZTogMSxcclxuICAgKiAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAqICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICogICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICogfSkuJDsgLy8geyBhOiAxIH1cclxuICAgKiBuZXcgU3VwZXIoe30pLmRlZmluZSh7XHJcbiAgICogICBhOiB7XHJcbiAgICogICAgIHZhbHVlOiAxLFxyXG4gICAqICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgKiAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICogICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgKiAgIH1cclxuICAgKiB9KS4kOyAvLyB7IGE6IDEgfVxyXG4gICAqL1xyXG4gIGRlZmluZShwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogZGVzY3JpcHRvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3BlcnR5ID0gbmV3IFN1cGVyKHByb3BlcnR5KS4kO1xyXG5cclxuICAgIGlmIChpc09iamVjdCh0aGlzLiQpKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuJCwgcHJvcGVydHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNkZWxldGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IHByb3BzIC0gTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGRlbGV0ZS5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9kZWxldGVcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgbXVsdGlwbGVcclxuICAgKiBbXCJkZWxldGVcIiBvcGVyYXRvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL2RlbGV0ZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuZGVsZXRlKCdjJywgJ2EnKS4kOyAvLyB7IGI6IDIgfVxyXG4gICAqL1xyXG4gIGRlbGV0ZSguLi5wcm9wcykge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGl0ZXJhdGUob2JqZWN0ICYmIHByb3BzLCAocHJvcGVydHkpID0+IHtcclxuICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZXF1YWxzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gW29iamVjdF0gLSBPYmplY3QgdG8gY29tcGFyZS5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIG9iamVjdHMgYXJlIGVxdWFsIG9yIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cnVlIGlmIG9iamVjdHMgYXJlIGVxdWFsIHVzaW5nICc9PScgb3BlcmF0b3IgYW5kIGZhbHNlIGlmIG5vdC4gTmFOcyBhcmUgY29uc2lkZXJlZCB0byBiZSBlcXVhbC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKDMpLmVxdWFscygnMycpOyAgIC8vIHRydWVcclxuICAgKiBuZXcgU3VwZXIoTmFOKS5lcXVhbHMoTmFOKTsgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGVxdWFscyhvYmplY3QpIHtcclxuICAgIGNvbnN0IG8gPSB0aGlzLiQ7XHJcblxyXG4gICAgb2JqZWN0ID0gbmV3IFN1cGVyKG9iamVjdCkuJDtcclxuXHJcbiAgICAvKiBlc2xpbnQgZXFlcWVxOiAwICovXHJcbiAgICByZXR1cm4gbyA9PSBvYmplY3QgfHwgKGlzTmFOKG8pICYmIGlzTmFOKG9iamVjdCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNldmVyeVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBJZiByZXR1cm5zIHRydXRoeSBpdGVyYXRpb24gZ29lcyBvbiBhbmQgaWYgZmFsc2V5IGl0IHN0b3BzLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBhbGwgdGhlIGNhbGxiYWNrIGNhbGxzIHJldHVybmVkIHRydXRoeSB2YWx1ZS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBib29sZWFuIGlmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmV2ZXJ5KCh2YWx1ZSkgPT4gdmFsdWUgPCA0KTsgLy8gdHJ1ZVxyXG4gICAqIG5ldyBTdXBlcih7fSkuZXZlcnkoKCkgPT4gZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXHJcbiAgICovXHJcbiAgZXZlcnkoY2FsbGJhY2sgPSBCb29sZWFuKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNldmVyeScpO1xyXG5cclxuICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pICE9PSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZmlsdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IFtjYWxsYmFjayA9IEJvb2xlYW5dIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBlbGVtZW50IGlzIGluY2x1ZGVkIGFuZCBpZiBmYWxzZXkgaXQncyBleGNsdWRlZC5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IE5ldyBELVdyYXAgb2YgZmlsdGVyZWQgb2JqZWN0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGZpbHRlcmVkIGJ5IHRoZSBjYWxsYmFjayBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUlMikuJDsgLy8geyBhOiAxLCBjOiAzIH1cclxuICAgKiBuZXcgU3VwZXIobnVsbCkuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUlMikuJDsgICAgICAgICAgICAgICAgIC8vIG51bGxcclxuICAgKi9cclxuICBmaWx0ZXIoY2FsbGJhY2sgPSBCb29sZWFuKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNmaWx0ZXInKTtcclxuXHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcbiAgICBjb25zdCBhcnJheSA9IGlzQXJyYXlMaWtlKG9iamVjdCk7XHJcblxyXG4gICAgLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXHJcbiAgICBjb25zdCBvID0gYXJyYXkgPyBbXSA6IGlzTmlsKG9iamVjdCkgPyBvYmplY3QgOiB7fTtcclxuXHJcbiAgICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcclxuICAgICAgICBpZiAoYXJyYXkpIHtcclxuICAgICAgICAgIG8ucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEQobyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2ZpbmRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gQm9vbGVhbl0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogSWYgcmV0dXJucyB0cnV0aHkgaXRlcmF0aW9uIHN0b3BzIGFuZCBpZiBmYWxzZXkgaXQgY29udGludWVzLlxyXG4gICAqIEByZXR1cm5zIHt7IGtleTogS2V5LCB2YWx1ZTogKiB9fG51bGx9IHsga2V5LCB2YWx1ZSB9IGlmIGZvdW5kIGFuZCBudWxsIGlmIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBmb3VuZCB7IGtleSwgdmFsdWUgfSBpZiBzb21ldGhpbmcgZm91bmQgYW5kIG51bGwgaWYgbm90aGluZyBmb3VuZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5maW5kKCh2YWx1ZSkgPT4gdmFsdWUgPT09IDIpOyAvLyB7IGtleTogJ2InLCB2YWx1ZTogMiB9XHJcbiAgICogbmV3IFN1cGVyKFsxLCAyLCAzXSkuZmluZCgodmFsdWUpID0+IHZhbHVlID09PSAyKTsgICAgICAgICAgICAvLyB7IGtleTogMSwgdmFsdWU6IDIgfVxyXG4gICAqL1xyXG4gIGZpbmQoY2FsbGJhY2spIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI2ZpbmQnKTtcclxuXHJcbiAgICByZXR1cm4gaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcclxuICAgICAgICByZXR1cm4geyBrZXksIHZhbHVlIH07XHJcbiAgICAgIH1cclxuICAgIH0pIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2ZvckVhY2hcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgaXRlcmF0aW5nIG92ZXIgYW55IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgKiAgIG9iamVjdFtrZXldID0gdmFsdWUgKiB2YWx1ZTtcclxuICAgKiB9KS4kOyAvLyB7IGE6IDEsIGI6IHsgYzogNCwgZDogNSB9IH1cclxuICAgKi9cclxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNmb3JFYWNoJyk7XHJcblxyXG4gICAgaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgICAgY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNmcmVlemVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZnJlZXplXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5mcmVlemVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9mcmVlemV9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmZyZWV6ZSgpOyAvLyBTdXBlclxyXG4gICAqL1xyXG4gIGZyZWV6ZSgpIHtcclxuICAgIE9iamVjdC5mcmVlemUodGhpcy4kKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjZ2V0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IHByb3BlcnR5IC0gRWl0aGVyIGEgc3RyaW5nIG9mIGEgcHJvcGVydHkgb3IgYSBnZXR0ZXJzIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2V0dGVyXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgZ2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZmluaW5nIGdldHRlcnMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IG9iamVjdDEgPSBuZXcgU3VwZXIoe30pLmdldCgnYScsICgpID0+IDEpLiQ7XHJcbiAgICogb2JqZWN0MS5hOyAvLyAxXHJcbiAgICpcclxuICAgKiBjb25zdCBvYmplY3QyID0gbmV3IFN1cGVyKHt9KS5nZXQoe1xyXG4gICAqICAgYTogKCkgPT4gMlxyXG4gICAqIH0pLiQ7XHJcbiAgICogb2JqZWN0Mi5hOyAvLyAyXHJcbiAgICovXHJcbiAgZ2V0KHByb3BlcnR5LCBnZXR0ZXIpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IGdldHRlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuXHJcbiAgICBpdGVyYXRlKGlzT2JqZWN0KG9iamVjdCkgJiYgbmV3IFN1cGVyKHByb3BlcnR5KS4kLCAoZ2V0dGVyLCBwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyBnZXQ6IGdldHRlciB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNoYXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0ga2V5IC0gUHJvcGVydHkgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyB0aGUga2V5IGFuZCBmYWxzZSBpZiBub3QuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvaW5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbXCJpblwiIG9wZXJhdG9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvaW59LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmhhcygnYicpOyAvLyB0cnVlXHJcbiAgICovXHJcbiAgaGFzKGtleSkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGtleSBpbiBvYmplY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2hhc093blxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBrZXkgLSBQcm9wZXJ0eSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaGFzIGl0cyBvd24ga2V5IGFuZCBmYWxzZSBpZiBub3QuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaGFzT3duUHJvcGVydHlcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0I2hhc093blByb3BlcnR5XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaGFzT3duUHJvcGVydHl9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmhhc093bignYicpOyAgICAgICAgICAgICAgLy8gdHJ1ZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuaGFzT3duKCdoYXNPd25Qcm9wZXJ0eScpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGhhc093bihrZXkpIHtcclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjaW5zdGFuY2VvZlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciAtIENvbnN0cnVjdG9yIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL2luc3RhbmNlb2ZcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbXCJpbnN0YW5jZW9mXCIgb3BlcmF0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9pbnN0YW5jZW9mfS5cclxuICAgKi9cclxuICBpbnN0YW5jZW9mKGNvbnN0cnVjdG9yKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kIGluc3RhbmNlb2YgY29uc3RydWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2lzRnJvemVuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgb2JqZWN0IGlzIGZyb3plbi5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0Zyb3plblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtPYmplY3QuaXNGcm96ZW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0Zyb3plbn0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7fSkuZnJlZXplKCkuaXNGcm96ZW4oKTsgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGlzRnJvemVuKCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbih0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNqc29uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SlNPTkNhbGxiYWNrfFN0cmluZ1tdfSBbcmVwbGFjZXJdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW3NwYWNlXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBKU09OIHN0cmluZy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0pTT04uc3RyaW5naWZ5XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuanNvbigpOyAvLyAne1wiYVwiOjEsXCJiXCI6MixcImNcIjozfSdcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmpzb24oJyAgICAnKTtcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICAgIFwiYVwiOiAxLFxyXG4gICAqIC8vICAgICBcImJcIjogMixcclxuICAgKiAvLyAgICAgXCJjXCI6IDNcclxuICAgKiAvLyB9XHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5qc29uKChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICogICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAqICAgICByZXR1cm4gdmFsdWUlMiA/IGtleSArIHZhbHVlMCA6IHVuZGVmaW5lZDtcclxuICAgKiAgIH1cclxuICAgKlxyXG4gICAqICAgcmV0dXJuIHZhbHVlO1xyXG4gICAqIH0sIDIpO1xyXG4gICAqIC8vIHtcclxuICAgKiAvLyAgIFwiYVwiOiBcImExXCIsXHJcbiAgICogLy8gICBcImNcIjogXCJjM1wiXHJcbiAgICogLy8gfVxyXG4gICAqL1xyXG4gIGpzb24ocmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhaXNGdW5jdGlvbihyZXBsYWNlcikgJiYgIWlzQXJyYXkocmVwbGFjZXIpKSB7XHJcbiAgICAgIFtdLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIFtdLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsIHRoaXMuJCk7XHJcblxyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5LmFwcGx5KEpTT04sIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI2tleU9mXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBmaW5kLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfG51bGx9IEEga2V5IG9yIGFuIGluZGV4IGlmIGZvdW5kIGFuZCBudWxsIGlmIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIGVxdWFsIHRvIHRoZSBhcmd1bWVudCB2YWx1ZSBpbiB0aGUgb2JqZWN0LiBOYU5zIGFyZSBjb25zaWRlcmVkIHRvIGJlIGVxdWFsLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLmtleU9mKDIpOyAgIC8vICdiJ1xyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkua2V5T2YoJzInKTsgLy8gJ2InXHJcbiAgICovXHJcbiAga2V5T2YodmFsdWUpIHtcclxuICAgIGNvbnN0IGtleSA9IGl0ZXJhdGUodGhpcy4kLCAodmFsLCBrZXkpID0+IHtcclxuICAgICAgaWYgKHZhbCA9PSB2YWx1ZSB8fCAoaXNOYU4odmFsKSAmJiBpc05hTih2YWx1ZSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGtleSkgPyBudWxsIDoga2V5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNrZXlPZlN0cmljdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gZmluZC5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcnxudWxsfSBBIGtleSBvciBhbiBpbmRleCBpZiBmb3VuZCBhbmQgbnVsbCBpZiBub3QuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBzdHJpY3QgZXF1YWwgdG8gdGhlIGFyZ3VtZW50IHZhbHVlIGluIHRoZSBvYmplY3QuIE5hTnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgZXF1YWwuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkua2V5T2ZTdHJpY3QoMik7ICAgLy8gJ2InXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5rZXlPZlN0cmljdCgnMicpOyAvLyAnYidcclxuICAgKi9cclxuICBrZXlPZlN0cmljdCh2YWx1ZSkge1xyXG4gICAgY29uc3Qga2V5ID0gaXRlcmF0ZSh0aGlzLiQsICh2YWwsIGtleSkgPT4ge1xyXG4gICAgICBpZiAodmFsID09PSB2YWx1ZSB8fCAoaXNOYU4odmFsKSAmJiBpc05hTih2YWx1ZSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGtleSkgPyBudWxsIDoga2V5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNrZXlzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gQSB3cmFwIG9mIHRoZSBrZXlzIGFycmF5LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXNcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbT2JqZWN0LmtleXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5rZXlzKCkuJDsgLy8gWydhJywgJ2InLCAnYyddXHJcbiAgICogbmV3IFN1cGVyKG51bGwpLmtleXMoKS4kOyAgICAgICAgICAgICAgICAgLy8gW11cclxuICAgKi9cclxuICBrZXlzKCkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIHJldHVybiBEKGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3Qua2V5cyhvYmplY3QpIDogW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNtYXBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdC5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IEQtV3JhcCBvZiB0aGUgbmV3IG9iamVjdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHdyYXAgb2YgYSBuZXcgb2JqZWN0IHVzaW5nIHRoZSBjYWxsYmFjay5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5tYXAoKHZhbHVlKSA9PiB2YWx1ZSAqIDIpLiQ7IC8vIHsgYTogMiwgYjogNCwgYzogNiB9XHJcbiAgICogbmV3IFN1cGVyKG51bGwpLm1hcCgodmFsdWUpID0+IHZhbHVlICogMikuJDsgICAgICAgICAgICAgICAgIC8vIG51bGxcclxuICAgKi9cclxuICBtYXAoY2FsbGJhY2spIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI21hcCcpO1xyXG5cclxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuJDtcclxuICAgIGNvbnN0IG8gPSBpc0FycmF5TGlrZShvYmplY3QpID8gW10gOiBpc051bGwob2JqZWN0KSA/IG51bGwgOiB7fTtcclxuXHJcbiAgICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgb1trZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBEKG8pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNtYXhcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIGNvbXBhcmlzb24gd2l0aCB0aGUgcHJldmlvdXMgbWF4IHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHt7a2V5OiBLZXksIHZhbHVlOiBOdW1iZXJ9fSBPYmplY3Qgd2l0aCBtYXggdmFsdWUgYW5kIGtleSBvZiB0aGUgbWF4IHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbWF4IHZhbHVlIGluIHRoZSBvYmplY3QuXHJcbiAgICogSWYgbm8gY2FsbGJhY2sgaXMgcHJlc2VudCBjb21wYXJpc29uIGlzIGJldHdlZW4gdmFsdWVzIG9mIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkubWF4KCk7ICAgICAgICAgICAgICAgICAgICAgLy8geyBrZXk6ICdjJywgdmFsdWU6IDMgfVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkubWF4KCh2YWx1ZSkgPT4gNCAtIHZhbHVlKTsgLy8geyBrZXk6ICdhJywgdmFsdWU6IDMgfVxyXG4gICAqIG5ldyBTdXBlcih7IGE6ICdhJywgYjogJ2InLCBjOiAnYycgfSkubWF4KCk7ICAgICAgICAgICAgICAgLy8geyBrZXk6IG51bGwsIHZhbHVlOiAtSW5maW5pdHkgfVxyXG4gICAqL1xyXG4gIG1heChjYWxsYmFjayA9IG51bGwpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb258fCEnXSwgJ1N1cGVyI21heCcpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgobWF4LCB2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgICAgY29uc3QgdmFsID0gTnVtYmVyKGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSA6IHZhbHVlKTtcclxuXHJcbiAgICAgIGlmICh2YWwgPiBtYXgudmFsdWUpIHtcclxuICAgICAgICBtYXgua2V5ID0ga2V5O1xyXG4gICAgICAgIG1heC52YWx1ZSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfSwgeyBrZXk6IG51bGwsIHZhbHVlOiAtSW5maW5pdHkgfSkuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjbWluXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7SXRlcmF0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAqIFJldHVybiB2YWx1ZSBpcyB1c2VkIGZvciBjb21wYXJpc29uIHdpdGggdGhlIHByZXZpb3VzIG1pbiB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7e2tleTogS2V5LCB2YWx1ZTogTnVtYmVyfX0gT2JqZWN0IHdpdGggbWluIHZhbHVlIGFuZCBrZXkgb2YgdGhlIG1pbiB2YWx1ZS5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBmaW5kaW5nIG1pbiB2YWx1ZSBpbiB0aGUgb2JqZWN0LlxyXG4gICAqIElmIG5vIGNhbGxiYWNrIGlzIHByZXNlbnQgY29tcGFyaXNvbiBpcyBiZXR3ZWVuIHZhbHVlcyBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLm1pbigpOyAgICAgICAgICAgICAgICAgICAgIC8vIHsga2V5OiAnYScsIHZhbHVlOiAxIH1cclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLm1pbigodmFsdWUpID0+IDQgLSB2YWx1ZSk7IC8vIHsga2V5OiAnYycsIHZhbHVlOiAxIH1cclxuICAgKiBuZXcgU3VwZXIoeyBhOiAnYScsIGI6ICdiJywgYzogJ2MnIH0pLm1pbigpOyAgICAgICAgICAgICAgIC8vIHsga2V5OiBudWxsLCB2YWx1ZTogSW5maW5pdHkgfVxyXG4gICAqL1xyXG4gIG1pbihjYWxsYmFjayA9IG51bGwpIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb258fCEnXSwgJ1N1cGVyI21pbicpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgobWluLCB2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgICAgY29uc3QgdmFsID0gTnVtYmVyKGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSA6IHZhbHVlKTtcclxuXHJcbiAgICAgIGlmICh2YWwgPCBtaW4udmFsdWUpIHtcclxuICAgICAgICBtaW4ua2V5ID0ga2V5O1xyXG4gICAgICAgIG1pbi52YWx1ZSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfSwgeyBrZXk6IG51bGwsIHZhbHVlOiBJbmZpbml0eSB9KS4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNvYmplY3RcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtPYmplY3RDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogQHBhcmFtIHtPYmplY3R8Kn0gW29iamVjdCA9IHt9XSAtIE9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBXcmFwIG9mIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBUeXBlIG9mIHtAbGluayBTdXBlciNyZWR1Y2V9LlxyXG4gICAqIFRoZSBvYmplY3QgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IGludG8gdGhlIGNhbGxiYWNrLiBUaGUgb3V0cHV0IGlzIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyIH0pLm9iamVjdCgob2JqZWN0LCB2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICogICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gICAqICAgb2JqZWN0W2tleSArIGtleV0gPSB2YWx1ZSAqIDI7XHJcbiAgICogfSkuJDsgLy8geyBhOiAxLCBhYTogMiwgYjogMiwgYmI6IDQgfVxyXG4gICAqL1xyXG4gIG9iamVjdChjYWxsYmFjaywgb2JqZWN0ID0ge30pIHtcclxuICAgIHZhbGlkYXRlKFtjYWxsYmFja10sIFsnZnVuY3Rpb24nXSwgJ1N1cGVyI29iamVjdCcpO1xyXG5cclxuICAgIGl0ZXJhdGUodGhpcy4kLCAodmFsdWUsIGtleSwgb2JqKSA9PiB7XHJcbiAgICAgIGNhbGxiYWNrKG9iamVjdCwgdmFsdWUsIGtleSwgb2JqKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBEKG9iamVjdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3Byb3BcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsICo+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGFuIGFzc2lnbmVkIG9iamVjdC5cclxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZ1xyXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB8Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3MgYSBzZXR0ZXIgb3IgYSB2YWx1ZSBpZiBnZXR0ZXIuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnByb3AoJ2EnKTsgICAgICAgICAgICAgIC8vIDFcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnByb3AoJ2EnLCA3KS4kOyAgICAgICAgIC8vIHsgYTogNywgYjogMiwgYzogMyB9XHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5wcm9wKHsgYTogNywgYjogOCB9KS4kOyAvLyB7IGE6IDcsIGI6IDgsIGM6IDMgfVxyXG4gICAqL1xyXG4gIHByb3AocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xyXG4gICAgICByZXR1cm4gdGhpcy4kID8gdGhpcy4kW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmFzc2lnbihwcm9wZXJ0eSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3Byb3BlcnR5RGVzY3JpcHRvclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBQcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSBQcm9wZXJ0eSBkZXNjcmlwdG9yLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5RGVzY3JpcHRvclxyXG4gICAqIEBkZXNjcmlwdG9yIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3J9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxIH0pLnByb3BlcnR5RGVzY3JpcHRvcignYScpO1xyXG4gICAqIC8vIHtcclxuICAgKiAvLyAgIHZhbHVlOiAxLFxyXG4gICAqIC8vICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgKiAvLyAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAqIC8vICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICogLy8gfVxyXG4gICAqL1xyXG4gIHByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0eSkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSA6IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjcHJvcGVydHlOYW1lc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IEQtV3JhcCBvZiB0aGUgbmFtZXMgYXJyYXkuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlOYW1lc1xyXG4gICAqIEBkZXNjcmlwdG9yIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlOYW1lc30uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIgfSkuZGVmaW5lKCdjJywgeyB2YWx1ZTogMyB9KS4kOyAvLyBbJ2EnLCAnYicsICdjJ11cclxuICAgKi9cclxuICBwcm9wZXJ0eU5hbWVzKCkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIHJldHVybiBEKGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpIDogW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNwcm9wZXJ0eVN5bWJvbHNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0RXcmFwfSBELVdyYXAgb2YgdGhlIG5hbWVzIGFycmF5LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5U3ltYm9sc1xyXG4gICAqIEBkZXNjcmlwdG9yIFN5bm9ueW0gZm9yXHJcbiAgICogW09iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBbU3ltYm9sKCdmb28nKV06IDEgfSkuZGVmaW5lKFN5bWJvbCgnYmFyJyksIHsgdmFsdWU6IDIgfSkuJDsgLy8gW1N5bWJvbCgnZm9vJyksIFN5bWJvbCgnYmFyJyldXHJcbiAgICovXHJcbiAgcHJvcGVydHlTeW1ib2xzKCkge1xyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIHJldHVybiBEKGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkgOiBbXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3Byb3RvXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gW3Byb3RvXSAtIElmIGl0J3MgcHJlc2VudCBpdCdzIHNldCBhcyBhIHByb3RvdHlwZSB0byB0aGUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gSW4gZ2V0dGVyIG1vZGUgcmV0dXJucyB3cmFwIG9mIHRoZSBwcm90b3R5cGUgYW5kIGluIHNldHRlciBtb2RlIHJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgYm90aFxyXG4gICAqIFtPYmplY3QuZ2V0UHJvdG90eXBlT2Zde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRQcm90b3R5cGVPZn1cclxuICAgKiBhbmRcclxuICAgKiBbT2JqZWN0LnNldFByb3RvdHlwZU9mXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvc2V0UHJvdG90eXBlT2Z9LlxyXG4gICAqL1xyXG4gIHByb3RvKHByb3RvKSB7XHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcbiAgICBjb25zdCBpc0NvbnRleHRPYmplY3QgPSAhaXNOaWwob2JqZWN0KTtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBpZiAoaXNDb250ZXh0T2JqZWN0ICYmIChpc09iamVjdChwcm90bykgfHwgaXNOdWxsKHByb3RvKSkpIHtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqZWN0LCBwcm90byk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc0NvbnRleHRPYmplY3QgPyBuZXcgU3VwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkpIDogbmV3IFN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3JlZHVjZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1JlZHVjZUNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBSZXR1cm4gdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBuZXh0IGNhbGxiYWNrIGNhbGwuXHJcbiAgICogQHBhcmFtIHsqfSBbSVYgPSA8Zmlyc3QgdmFsdWU+fHVuZGVmaW5lZF0gLSBJbml0aWFsIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHsqfSBNb2RpZmllZCBJVi5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBtb2RpZmllZCBJVi4gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBub3QgcHJlc2VudCBmaXJzdCB2YWx1ZSBpbiB0aGUgb2JqZWN0IGlzIHRha2VuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSAqIHZhbHVlLCAwKTsgLy8gMTRcclxuICAgKi9cclxuICByZWR1Y2UoY2FsbGJhY2ssIElWKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9uJ10sICdTdXBlciNyZWR1Y2UnKTtcclxuXHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgbGV0IHN0YXJ0S2V5O1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIHN0YXJ0S2V5ID0ga2V5O1xyXG4gICAgICAgIElWID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgaWYgKGtleSAhPT0gc3RhcnRLZXkpIHtcclxuICAgICAgICBJViA9IGNhbGxiYWNrKElWLCB2YWx1ZSwga2V5LCBvYmplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gSVY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN1cGVyI3NldFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgRnVuY3Rpb24+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGEgc2V0dGVycyBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHRlcl0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGlzIGhhcyB0byBiZSBhIHNldHRlciBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJucyB7RFdyYXB9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWZpbmluZyBzZXR0ZXJzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBvYmplY3QgPSBuZXcgU3VwZXIoe30pXHJcbiAgICogICAuZ2V0KCdwdWJsaWMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICogICAgIHJldHVybiB0aGlzLl9wcml2YXRlO1xyXG4gICAqICAgfSlcclxuICAgKiAgIC5zZXQoJ3B1YmxpYycsIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAqICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAqICAgICAgIHRoaXMuX3ByaXZhdGUgPSB2YWx1ZTtcclxuICAgKiAgICAgfVxyXG4gICAqICAgfSk7XHJcbiAgICogb2JqZWN0LnByb3AoJ3B1YmxpYycsICcxJykuJDsgLy8geyBwdWJsaWM6IHVuZGVmaW5lZCB9XHJcbiAgICogb2JqZWN0LnByb3AoJ3B1YmxpYycsIDEpLiQ7ICAgLy8geyBwdWJsaWM6IDEsIF9wcml2YXRlOiAxIH1cclxuICAgKlxyXG4gICAqIG5ldyBTdXBlcih7fSkuc2V0KHtcclxuICAgKiAgIHB1YmxpYyh2YWx1ZSkge1xyXG4gICAqICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAqICAgICAgIHRoaXMuX3ByaXZhdGUgPSB2YWx1ZTtcclxuICAgKiAgICAgfVxyXG4gICAqICAgfVxyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHNldChwcm9wZXJ0eSwgc2V0dGVyKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHByb3BlcnR5ID0geyBbcHJvcGVydHldOiBzZXR0ZXIgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLiQ7XHJcblxyXG4gICAgaXRlcmF0ZShpc09iamVjdChvYmplY3QpICYmIG5ldyBTdXBlcihwcm9wZXJ0eSkuJCwgKHNldHRlciwgcHJvcGVydHkpID0+IHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgc2V0OiBzZXR0ZXIgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjc29tZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2sgPSBCb29sZWFuXSAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBJZiByZXR1cm5zIHRydXRoeSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIGZhbHNleSBpdCBjb250aW51ZXMuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGFsbCB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRydWUgaWYgc29tZSBvZiB0aGUgY2FsbGJhY2sgY2FsbHMgcmV0dXJuZWQgdHJ1dGh5IHZhbHVlLiBPdGhlcndpc2UgZmFsc2UuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkuc29tZSgodmFsdWUpID0+IHZhbHVlID4gNCk7IC8vIGZhbHNlXHJcbiAgICogbmV3IFN1cGVyKHt9KS5zb21lKCgpID0+IHRydWUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcclxuICAgKi9cclxuICBzb21lKGNhbGxiYWNrID0gQm9vbGVhbikge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbiddLCAnU3VwZXIjc29tZScpO1xyXG5cclxuICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSB8fCBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjc3RyaWN0RXF1YWxzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gW29iamVjdF0gLSBPYmplY3QgdG8gY29tcGFyZS5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIG9iamVjdHMgYXJlIGVxdWFsIG9yIG5vdC5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cnVlIGlmIG9iamVjdHMgYXJlIGVxdWFsIHVzaW5nICc9PT0nIG9wZXJhdG9yIGFuZCBmYWxzZSBpZiBub3QuXHJcbiAgICogTmFOcyBhcmUgY29uc2lkZXJlZCB0byBiZSBzdHJpY3QgZXF1YWwuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcigzKS5zdHJpY3RFcXVhbHMoJzMnKTsgICAvLyBmYWxzZVxyXG4gICAqIG5ldyBTdXBlcihOYU4pLnN0cmljdEVxdWFscyhOYU4pOyAvLyB0cnVlXHJcbiAgICovXHJcbiAgc3RyaWN0RXF1YWxzKG9iamVjdCkge1xyXG4gICAgY29uc3QgbyA9IHRoaXMuJDtcclxuXHJcbiAgICBvYmplY3QgPSBuZXcgU3VwZXIob2JqZWN0KS4kO1xyXG5cclxuICAgIHJldHVybiBvID09PSBvYmplY3QgfHwgKGlzTmFOKG8pICYmIGlzTmFOKG9iamVjdCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdXBlciNzdW1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gW2NhbGxiYWNrID0gbnVsbF0gLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICogQHJldHVybnMge051bWJlcn0gU3VtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBUeXBlIG9mIHtAbGluayBTdXBlciNyZWR1Y2V9LlxyXG4gICAqIElmIHRoZSBjYWxsYmFjayBpcyBwcmVzZW50IGl0J3MgdXNlZCBmb3Igc3VtbWluZy4gSWYgbm90IHRoZSB2YWx1ZSBpcyB1c2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLnN1bSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2XHJcbiAgICogbmV3IFN1cGVyKHsgYTogMSwgYjogMiwgYzogMyB9KS5zdW0oKHZhbHVlKSA9PiB2YWx1ZSAqIHZhbHVlKTsgLy8gMTRcclxuICAgKi9cclxuICBzdW0oY2FsbGJhY2sgPSBudWxsKSB7XHJcbiAgICB2YWxpZGF0ZShbY2FsbGJhY2tdLCBbJ2Z1bmN0aW9ufHwhJ10sICdTdXBlciNzdW0nKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoKHN1bSwgdmFsdWUsIGtleSwgb2JqZWN0KSA9PiAoXHJcbiAgICAgIHN1bSArIE51bWJlcihjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkgOiB2YWx1ZSlcclxuICAgICksIDApO1xyXG4gIH1cclxuXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgU3VwZXIjdG9TdHJpbmdUYWdcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0b1N0cmluZyB0YWcgb2YgdGhlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN1cGVyKHt9KS50b1N0cmluZ1RhZzsgLy8gJ09iamVjdCdcclxuICAgKiBuZXcgU3VwZXIoW10pLnRvU3RyaW5nVGFnOyAvLyAnQXJyYXknXHJcbiAgICogbmV3IFN1cGVyKDEpLnRvU3RyaW5nVGFnOyAgLy8gJ051bWJlcidcclxuICAgKi9cclxuICBnZXQgdG9TdHJpbmdUYWcoKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcodGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgU3VwZXIjdHlwZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtcInR5cGVvZlwiIG9wZXJhdG9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvaW5zdGFuY2VvZn0uLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoe30pLnR5cGU7ICAgLy8gJ29iamVjdCdcclxuICAgKiBuZXcgU3VwZXIoMSkudHlwZTsgICAgLy8gJ251bWJlcidcclxuICAgKiBuZXcgU3VwZXIoJzEnKS50eXBlOyAgLy8gJ3N0cmluZydcclxuICAgKiBuZXcgU3VwZXIodHJ1ZSkudHlwZTsgLy8gJ2Jvb2xlYW4nXHJcbiAgICovXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjdmFsdWVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsICo+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGEgdmFsdWVzIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCAqPn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoaXMgaGFzIHRvIGJlIGEgdmFsdWUgdG8gYmUgc2V0LlxyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGRlZmluaW5nIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG5vbi1jb25maWd1cmFibGUgdmFsdWVzLlxyXG4gICAqIFN5bm9ueW0gZm9yIG9iamVjdC5kZWZpbmUocHJvcGVydHksIHsgdmFsdWU6IHZhbHVlIH0pLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoe30pLnZhbHVlKCdhJywgMSkuJDsgLy8geyBhOiAxIH1cclxuICAgKiBuZXcgU3VwZXIoe30pLnZhbHVlKHtcclxuICAgKiAgIGE6IDFcclxuICAgKiB9KS4kOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geyBhOiAxIH1cclxuICAgKi9cclxuICB2YWx1ZShwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy4kO1xyXG5cclxuICAgIGl0ZXJhdGUoaXNPYmplY3Qob2JqZWN0KSAmJiBuZXcgU3VwZXIocHJvcGVydHkpLiQsICh2YWx1ZSwgcHJvcGVydHkpID0+IHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgdmFsdWUgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjdmFsdWVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtEV3JhcH0gQSB3cmFwIG9mIHRoZSB2YWx1ZXMgYXJyYXkuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgRC1XcmFwIG9mIHRoZSB2YWx1ZXMgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdXBlcih7IGE6IDEsIGI6IDIsIGM6IDMgfSkudmFsdWVzKCkuJDsgLy8gWzEsIDIsIDNdXHJcbiAgICogbmV3IFN1cGVyKG51bGwpLnZhbHVlcygpLiQ7ICAgICAgICAgICAgICAgICAvLyBbXVxyXG4gICAqL1xyXG4gIHZhbHVlcygpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gW107XHJcblxyXG4gICAgaXRlcmF0ZSh0aGlzLiQsICh2YWx1ZSkgPT4ge1xyXG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBEKGFycmF5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3VwZXIjd29yZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0l0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDb25jYXRlbmF0ZWQgc3RyaW5nLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBUeXBlIG9mIHtAbGluayBTdXBlciNyZWR1Y2V9LlxyXG4gICAqIElmIHRoZSBjYWxsYmFjayBpcyBwcmVzZW50IGl0J3MgdXNlZCBmb3IgY29uY2F0ZW5hdGluZy4gSWYgbm90IHRoZSB2YWx1ZSBpcyB1c2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLndvcmQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyMydcclxuICAgKiBuZXcgU3VwZXIoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLndvcmQoKHZhbHVlKSA9PiB2YWx1ZSArIHZhbHVlKTsgLy8gJzExMjIzMydcclxuICAgKi9cclxuICB3b3JkKGNhbGxiYWNrID0gbnVsbCkge1xyXG4gICAgdmFsaWRhdGUoW2NhbGxiYWNrXSwgWydmdW5jdGlvbnx8ISddLCAnU3VwZXIjd29yZCcpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnJlZHVjZSgod29yZCwgdmFsdWUsIGtleSwgb2JqZWN0KSA9PiAoXHJcbiAgICAgIHdvcmQgKyBTdHJpbmcoY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpIDogdmFsdWUpXHJcbiAgICApLCAnJyk7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKFN1cGVyLnByb3RvdHlwZSwge1xyXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnU3VwZXInXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwQXNzaWduXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IC0gT2JqZWN0IHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvLlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBhc3NpZ24gcHJvcGVydGllcyBmcm9tLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0LCBvYmplY3QpIHtcclxuICBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgIGlmIChpc1ByaW1pdGl2ZSh0YXJnZXRba2V5XSkgfHwgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XHJcbiAgICAgIHRhcmdldFtrZXldID0gZGVlcENsb25lKHZhbHVlKTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzUHJpbWl0aXZlKHRhcmdldFtrZXldKSkge1xyXG4gICAgICBkZWVwQXNzaWduKHRhcmdldFtrZXldLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcENsb25lXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNsb25lLlxyXG4gKiBAZGVzY3JpcHRpb24gRG9lcyB0aGUgZGVlcCBjbG9uaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENsb25lKG9iamVjdCkge1xyXG4gIGNvbnN0IGNsb25lID0gY2xvbmVTd2l0Y2hlcihvYmplY3QsIFtvYmplY3QsIHRydWVdKTtcclxuXHJcbiAgaWYgKGNsb25lICE9PSBvYmplY3QpIHtcclxuICAgIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICBjbG9uZVtrZXldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNsb25lO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBFcXVhbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG8xIC0gRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7Kn0gbzIgLSBTZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyaWN0IC0gSWYgY29tcGFyaXNvbiBzaG91bGQgYmUgc3RyaWN0IG9yIG5vdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG9iamVjdCBhcmUgZGVlcCBlcXVhbCBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXF1YWwobzEsIG8yLCBzdHJpY3QpIHtcclxuICBpZiAobzEgPT09IG8yKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChpc05hTihvMSkgJiYgaXNOYU4obzIpICYmIGlzUHJpbWl0aXZlKG8xKSAmJiBpc1ByaW1pdGl2ZShvMikpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTmFOKG8xKSB8fCBpc05hTihvMikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChpc1ByaW1pdGl2ZShvMSkgfHwgaXNQcmltaXRpdmUobzIpKSB7XHJcbiAgICByZXR1cm4gc3RyaWN0ID8gbzEgPT09IG8yIDogbzEgPT0gbzI7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNEYXRlKG8xKSAmJiBpc0RhdGUobzIpKSB7XHJcbiAgICByZXR1cm4gbzEuZ2V0VGltZSgpID09PSBvMi5nZXRUaW1lKCk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNEYXRlKG8xKSB8fCBpc0RhdGUobzIpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNSZWdFeHAobzEpICYmIGlzUmVnRXhwKG8yKSkge1xyXG4gICAgcmV0dXJuIG8xLnNvdXJjZSA9PT0gbzIuc291cmNlICYmXHJcbiAgICAgIG8xLnRvU3RyaW5nKCkubWF0Y2goL1tnaW11eV0qJC8pWzBdID09PSBvMi50b1N0cmluZygpLm1hdGNoKC9bZ2ltdXldKiQvKVswXSAmJlxyXG4gICAgICBvMS5sYXN0SW5kZXggPT09IG8yLmxhc3RJbmRleDtcclxuICB9XHJcblxyXG4gIGlmIChpc1JlZ0V4cChvMSkgfHwgaXNSZWdFeHAobzIpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoKCFpc1BsYWluT2JqZWN0KG8xKSAmJiAhaXNBcnJheShvMSkpIHx8ICghaXNQbGFpbk9iamVjdChvMikgJiYgIWlzQXJyYXkobzIpKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcDEgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzEpO1xyXG4gIGNvbnN0IHAyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG8xKTtcclxuXHJcbiAgaWYgKE9iamVjdC5rZXlzKG8xKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG8yKS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChwMSAmJiBwMiAmJiAodG9TdHJpbmdUYWcocDEuY29uc3RydWN0b3IpICE9PSB0b1N0cmluZ1RhZyhwMi5jb25zdHJ1Y3RvcikpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXRlcmF0ZShvMSwgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgIGlmICghKGtleSBpbiBvMikgfHwgIWRlZXBFcXVhbCh2YWx1ZSwgbzJba2V5XSwgc3RyaWN0KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSkgIT09IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBFdmVyeVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBpdGVyYXRpb24gZ29lcyBvbiBhbmQgaWYgbm90IGl0IHN0b3BzLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbiAtIERlcHRoIG9mIGl0ZXJhdGlvbi5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgYWxsIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXZlcnkob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xyXG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XHJcblxyXG4gIHJldHVybiBpdGVyYXRlKG9iamVjdCwgKHZhbHVlLCBrZXksIG9iamVjdCkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IFt7IGtleSwgdmFsdWUgfV0uY29uY2F0KHRyZWUpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgZW5kIHx8IGlzUHJpbWl0aXZlKHZhbHVlKVxyXG4gICAgICAgID8gIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSlcclxuICAgICAgICA6ICFkZWVwRXZlcnkodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSlcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSkgIT09IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBGaWx0ZXJcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxyXG4gKiBJZiByZXR1cm5zIHRydXRoeSB0aGUgZWxlbWVudCBpcyBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0IGFuZCBpZiBub3QgaXQncyBleGNsdWRlZC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZSAtIFRyZWUgb2YgeyBrZXksIHZhbHVlIH0gb2JqZWN0cyBvZiBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHsqfSBGaWx0ZXJlZCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRmlsdGVyKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcclxuICBjb25zdCBhcnJheSA9IGlzQXJyYXlMaWtlKG9iamVjdCk7XHJcbiAgY29uc3QgbnVsID0gaXNOaWwob2JqZWN0KTtcclxuICBjb25zdCBvID0gYXJyYXkgPyBbXSA6IG51bCA/IG9iamVjdCA6IHt9O1xyXG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XHJcblxyXG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XHJcblxyXG4gICAgaWYgKChlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpKSAmJiBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpKSB7XHJcbiAgICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgIG8ucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb1trZXldID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVuZCkge1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZCA9IGRlZXBGaWx0ZXIodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSk7XHJcblxyXG4gICAgICBpZiAoZmlsdGVyZWQpIHtcclxuICAgICAgICBpZiAoYXJyYXkpIHtcclxuICAgICAgICAgIG8ucHVzaChmaWx0ZXJlZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9ba2V5XSA9IGZpbHRlcmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoYXJyYXkpIHtcclxuICAgIHJldHVybiBvLmxlbmd0aCA/IG8gOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBpZiAoIW51bCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmxlbmd0aCA/IG8gOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwRmluZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIG5vdCBpdCBjb250aW51ZXMuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7VHJlZXxudWxsfSAtIElmIGZvdW5kIHRoZSB3aG9sZSB0cmVlIGlzIHJldHVybmVkIGFuZCBpZiBub3QgaXQncyBudWxsIHdoYXQncyByZXR1cm5lZC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBGaW5kKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcclxuICBjb25zdCBlbmQgPSBuID09PSAxO1xyXG5cclxuICByZXR1cm4gaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcclxuXHJcbiAgICBpZiAoZW5kIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkge1xyXG4gICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0LCBuZXdUcmVlKSkge1xyXG4gICAgICAgIHJldHVybiBuZXdUcmVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gZGVlcEZpbmQodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSk7XHJcblxyXG4gICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pIHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcEZvckVhY2hcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbiAtIERlcHRoIG9mIGl0ZXJhdGlvbi5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRm9yRWFjaChvYmplY3QsIGNhbGxiYWNrLCBuLCB0cmVlKSB7XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgaXRlcmF0ZShvYmplY3QsICh2YWx1ZSwga2V5LCBvYmplY3QpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBbeyBrZXksIHZhbHVlIH1dLmNvbmNhdCh0cmVlKTtcclxuXHJcbiAgICBpZiAoZW5kIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkge1xyXG4gICAgICBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGVlcEZvckVhY2godmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcEZvckVhY2hFbnRyeVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBGb3JFYWNoRW50cnkob2JqZWN0LCBjYWxsYmFjaywgbiwgdHJlZSkge1xyXG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XHJcblxyXG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XHJcblxyXG4gICAgY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0LCBuZXdUcmVlKTtcclxuXHJcbiAgICBpZiAoIWVuZCAmJiAhaXNQcmltaXRpdmUodmFsdWUpKSB7XHJcbiAgICAgIGRlZXBGb3JFYWNoRW50cnkodmFsdWUsIGNhbGxiYWNrLCBuIC0gMSwgbmV3VHJlZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGVlcEZyZWV6ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBmcmVlemUuXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEZyZWV6ZShvYmplY3QpIHtcclxuICBPYmplY3QuZnJlZXplKG9iamVjdCk7XHJcbiAgaXRlcmF0ZShvYmplY3QsIGRlZXBGcmVlemUpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGRlZXBNYXBcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0RlZXBJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50LlxyXG4gKiBSZXR1cm5lZCB2YWx1ZSBpcyB1c2VkIHRvIGNyZWF0ZSB0byBuZXcgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbiAtIERlcHRoIG9mIGl0ZXJhdGlvbi5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMgeyp9IE5ldyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwTWFwKG9iamVjdCwgY2FsbGJhY2ssIG4sIHRyZWUpIHtcclxuICBjb25zdCBvID0gaXNBcnJheUxpa2Uob2JqZWN0KSA/IFtdIDogaXNOaWwob2JqZWN0KSA/IG9iamVjdCA6IHt9O1xyXG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XHJcblxyXG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XHJcblxyXG4gICAgb1trZXldID0gZW5kIHx8IGlzUHJpbWl0aXZlKHZhbHVlKVxyXG4gICAgICA/IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCwgbmV3VHJlZSlcclxuICAgICAgOiBkZWVwTWFwKHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIG5ld1RyZWUpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gbztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwUmVkdWNlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtEZWVwUmVkdWNlQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgZWxlbWVudC5cclxuICogUmV0dXJuZWQgdmFsdWUgaXMgdXNlZCB0byBjcmVhdGUgdG8gbmV3IG9iamVjdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBEZXB0aCBvZiBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhcnQgLSBJZiBjYWxsYmFjayB3YXMgY2FsbGVkIGFscmVhZHkgb3Igbm90LlxyXG4gKiBAcGFyYW0ge3sgSVY6ICogfXx1bmRlZmluZWR9IElWIC0gSWYgY2FsbGJhY2sgd2FzIGNhbGxlZCBhbHJlYWR5IG9yIG5vdC5cclxuICogQHBhcmFtIHtUcmVlfSB0cmVlIC0gVHJlZSBvZiB7IGtleSwgdmFsdWUgfSBvYmplY3RzIG9mIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMge3sgSVY6ICogfX0gVHJhbnNmb3JtZWQgSVYuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwUmVkdWNlKG9iamVjdCwgY2FsbGJhY2ssIG4sIHN0YXJ0LCBJViwgdHJlZSkge1xyXG4gIGNvbnN0IGVuZCA9IG4gPT09IDE7XHJcblxyXG4gIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICBpZiAoIUlWICYmIChlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpKSAmJiAhc3RhcnQpIHtcclxuICAgICAgSVYgPSB7IElWOiB2YWx1ZSB9O1xyXG4gICAgICBzdGFydCA9IHRydWU7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmV3VHJlZSA9IFt7IGtleSwgdmFsdWUgfV0uY29uY2F0KHRyZWUpO1xyXG5cclxuICAgIElWID0gZW5kIHx8IGlzUHJpbWl0aXZlKHZhbHVlKVxyXG4gICAgICA/IHsgSVY6IGNhbGxiYWNrKElWLklWLCB2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpIH1cclxuICAgICAgOiBkZWVwUmVkdWNlKHZhbHVlLCBjYWxsYmFjaywgbiAtIDEsIHN0YXJ0LCBJViwgbmV3VHJlZSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBJVjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBkZWVwU29tZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RGVlcEl0ZXJhdGlvbkNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQuXHJcbiAqIElmIHJldHVybnMgdHJ1dGh5IHRoZSBpdGVyYXRpb24gc3RvcHMgYW5kIGlmIG5vdCBpdCBjb250aW51ZXMuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gRGVwdGggb2YgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWUgLSBUcmVlIG9mIHsga2V5LCB2YWx1ZSB9IG9iamVjdHMgb2YgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBJZiBzb21lIG9mIHRoZSBjYWxsYmFjayBjYWxscyByZXR1cm5lZCB0cnV0aHkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwU29tZShvYmplY3QsIGNhbGxiYWNrLCBuLCB0cmVlKSB7XHJcbiAgY29uc3QgZW5kID0gbiA9PT0gMTtcclxuXHJcbiAgcmV0dXJuIGl0ZXJhdGUob2JqZWN0LCAodmFsdWUsIGtleSwgb2JqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gW3sga2V5LCB2YWx1ZSB9XS5jb25jYXQodHJlZSk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBlbmQgfHwgaXNQcmltaXRpdmUodmFsdWUpXHJcbiAgICAgICAgPyBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QsIG5ld1RyZWUpXHJcbiAgICAgICAgOiBkZWVwU29tZSh2YWx1ZSwgY2FsbGJhY2ssIG4gLSAxLCBuZXdUcmVlKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pIHx8IGZhbHNlO1xyXG59XHJcblxyXG5jb25zdHJ1Y3RvcnNbMF0ucHVzaCh7XHJcbiAgY2hlY2s6ICgpID0+IHRydWUsXHJcbiAgY2xzOiBTdXBlclxyXG59KTtcclxuXHJcbmV4cG9ydCB7IFN1cGVyIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIEZ1bmNcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEZ1bmMgY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcclxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgaXNGdW5jdGlvbiwgdmFsaWRhdGUsIHRvQXJyYXksIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllcywgaXRlcmF0ZSB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEJlZm9yZU1pZGRsZXdhcmVcclxuICogQHBhcmFtIHtBcnJheX0gYXJncyAtIFByZXZpb3VzIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtGdW5jfSBmdW5jIC0gVGhpcyBmdW5jdGlvbi5cclxuICogQHJldHVybnMge0FycmF5fSAtIE5ldyBhcmd1bWVudHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBBZnRlck1pZGRsZXdhcmVcclxuICogQHBhcmFtIHsqfSByZXR1cm5WYWx1ZSAtIFByZXZpb3VzIHJldHVybiB2YWx1ZS5cclxuICogQHBhcmFtIHtGdW5jfSBmdW5jIC0gVGhpcyBmdW5jdGlvbi5cclxuICogQHJldHVybnMgeyp9IC0gTmV3IHJldHVybiB2YWx1ZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIEZ1bmNcclxuICogQGV4dGVuZHMgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZnVuYyA9IGZ1bmN0aW9uICgpIHt9XSAtIEZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtGdW5jfSBJbnN0YW5jZSBvZiBGdW5jLlxyXG4gKiBAZGVzY3JpcHRpb24gQSB3cmFwIG9mIGEgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhNYXRoLm1heCk7XHJcbiAqXHJcbiAqIGZ1bmMoMSwgNCwgLTIsIDUpOyAvLyA1XHJcbiAqL1xyXG5jbGFzcyBGdW5jIGV4dGVuZHMgU3VwZXIge1xyXG4gIGNvbnN0cnVjdG9yKGZ1bmMgPSAoKSA9PiB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgaWYgKCsrcHJveHkuJCQuY2FsbGVkIDwgcHJveHkuJCQuY2FuQmVDYWxsZWQpIHtcclxuICAgICAgICBjb25zdCB7IGJlZm9yZSwgYWZ0ZXIsIHN5bmMsIGNvbnRleHRMb2NrZWQgfSA9IHByb3h5LiQkO1xyXG4gICAgICAgIGxldCB7IGNvbnRleHQsIGFyZ3MgfSA9IHByb3h5LiQkO1xyXG4gICAgICAgIGxldCByZXQ7XHJcblxyXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0TG9ja2VkID8gY29udGV4dCA6IGNvbnRleHQgfHwgdGhpcztcclxuICAgICAgICBhcmdzID0gYXJncy5jb25jYXQodG9BcnJheShhcmd1bWVudHMpKTtcclxuXHJcbiAgICAgICAgaWYgKHN5bmMpIHtcclxuICAgICAgICAgIGl0ZXJhdGUoYmVmb3JlLCAobWlkZGxld2FyZSkgPT4ge1xyXG4gICAgICAgICAgICBhcmdzID0gbWlkZGxld2FyZS5jYWxsKGNvbnRleHQsIHRvQXJyYXkoYXJncyksIHByb3h5KTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHJldCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgdG9BcnJheShhcmdzKSk7XHJcblxyXG4gICAgICAgICAgaXRlcmF0ZShhZnRlciwgKG1pZGRsZXdhcmUpID0+IHtcclxuICAgICAgICAgICAgcmV0ID0gbWlkZGxld2FyZS5jYWxsKGNvbnRleHQsIHJldCwgcHJveHkpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFyZ3MpO1xyXG5cclxuICAgICAgICBpdGVyYXRlKGJlZm9yZSwgKG1pZGRsZXdhcmUpID0+IHtcclxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKGFyZ3MpID0+IG1pZGRsZXdhcmUuY2FsbChjb250ZXh0LCB0b0FycmF5KGFyZ3MpLCBwcm94eSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKChhcmdzKSA9PiBmdW5jLmFwcGx5KGNvbnRleHQsIHRvQXJyYXkoYXJncykpKTtcclxuXHJcbiAgICAgICAgaXRlcmF0ZShhZnRlciwgKG1pZGRsZXdhcmUpID0+IHtcclxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKHJldCkgPT4gbWlkZGxld2FyZS5jYWxsKGNvbnRleHQsIHJldCwgcHJveHkpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge09iamVjdH0gRnVuYyMkJFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFmdGVyIC0gQWZ0ZXIgbWlkZGxld2FyZSBhcnJheS5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFyZ3MgLSBMb2NrZWQgYW5kIGJvdW5kIGFyZ3VtZW50cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFyZ3NMb2NrZWQgLSBMb2NrZWQgYXJndW1lbnRzLlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gYmVmb3JlIC0gQmVmb3JlIG1pZGRsZXdhcmUgYXJyYXkuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY2FsbGVkIC0gSG93IG1hbnkgdGltZXMgdGhlIGZ1bmN0aW9uIHdhcyBjYWxsZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY2FuQmVDYWxsZWQgLSBIb3cgbWFueSB0aW1lcyB0aGUgZnVuY3Rpb24gY2FuIGJlIGFjdHVhbGx5IGNhbGxlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Kn0gY29udGV4dCAtIExvY2tlZCBvciBib3VuZCBjb250ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb250ZXh0TG9ja2VkIC0gSXMgY29udGV4dCBsb2NrZWQgb3Igbm90LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzeW5jIC0gSXMgZnVuY3Rpb24gc3luY2hyb25vdXMgb3Igbm90LlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbmZpZyBwYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICckJCcsIHtcclxuICAgICAgdmFsdWU6IHtcclxuICAgICAgICBhZnRlcjogW10sXHJcbiAgICAgICAgYXJnczogW10sXHJcbiAgICAgICAgYXJnc0xvY2tlZDogW10sXHJcbiAgICAgICAgYmVmb3JlOiBbXSxcclxuICAgICAgICBjYWxsZWQ6IDAsXHJcbiAgICAgICAgY2FuQmVDYWxsZWQ6IEluZmluaXR5LFxyXG4gICAgICAgIGNvbnRleHQ6IG51bGwsXHJcbiAgICAgICAgY29udGV4dExvY2tlZDogZmFsc2UsXHJcbiAgICAgICAgc3luYzogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBGdW5jIyRcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCAnJCcsIHsgdmFsdWU6IGZ1bmMgfSk7XHJcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJveHksIEZ1bmMucHJvdG90eXBlKTtcclxuXHJcbiAgICByZXR1cm4gcHJveHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjYWZ0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtBZnRlck1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBBZnRlciBtaWRkbGV3YXJlLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYWZ0ZXJBbGwgPSB0cnVlXSAtIEJvb2xlYW4gcGFyYW1ldGVyIHdoZXJlIHRvIHB1dCBtaWRkbGV3YXJlLlxyXG4gICAqIFRydXRoeSBwYXJhbWV0ZXIgc3RhbmRzIGZvciBcInRvIHRoZSBlbmRcIiBhbmQgZmFsc2V5IGZvciBcInRvIHRoZSBiZWdpbm5pbmdcIi5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGFmdGVyIG1pZGRsZXdhcmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpXHJcbiAgICogICAuYWZ0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0ICogcmVzdWx0KTtcclxuICAgKlxyXG4gICAqIGZ1bmMoNCk7ICAvLyAyNVxyXG4gICAqIGZ1bmMoLTQpOyAvLyA5XHJcbiAgICovXHJcbiAgYWZ0ZXIobWlkZGxld2FyZSwgYWZ0ZXJBbGwgPSB0cnVlKSB7XHJcbiAgICB2YWxpZGF0ZShbbWlkZGxld2FyZV0sIFsnZnVuY3Rpb24nXSwgJ0Z1bmMjYWZ0ZXInKTtcclxuXHJcbiAgICBjb25zdCB7IGFmdGVyIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmIChhZnRlckFsbCkge1xyXG4gICAgICBhZnRlci5wdXNoKG1pZGRsZXdhcmUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWZ0ZXIudW5zaGlmdChtaWRkbGV3YXJlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNhcHBseVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIENvbnRleHQgdG8gY2FsbCB3aXRoLlxyXG4gICAqIEBwYXJhbSB7KEFycmF5fEFyZ3VtZW50cyl9IFthcmdzXSAtIEFyZ3VtZW50cyB0byBjYWxsIHdpdGguXHJcbiAgICogQHJldHVybnMgeyp9IFJldHVybiBvZiBmdW5jdGlvbiBjYWxsLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHlcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbRnVuY3Rpb24jYXBwbHlde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2FwcGx5fS5cclxuICAgKi9cclxuICBhcHBseShjb250ZXh0LCBhcmdzKSB7XHJcbiAgICByZXR1cm4gKCgpID0+IHt9KS5hcHBseS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2FzeW5jXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHRoZSBmdW5jdGlvbiBzaG91bGQgYmUgc3luY2hyb25vdXMgb3Igbm90LlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSBmdW5jdGlvbiBzaG91bGQgYmUgc3luY2hyb25vdXMgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEpID0+IGEgKyAxKS5hc3luYygpO1xyXG4gICAqXHJcbiAgICogZnVuYyg0KS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIDVcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBhc3luYyhjb25kaXRpb24gPSB0cnVlKSB7XHJcbiAgICB0aGlzLiQkLnN5bmMgPSAhY29uZGl0aW9uO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2JlZm9yZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0JlZm9yZU1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBCZWZvcmUgbWlkZGxld2FyZS5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2JlZm9yZUFsbCA9IHRydWVdIC0gQm9vbGVhbiBwYXJhbWV0ZXIgd2hlcmUgdG8gcHV0IG1pZGRsZXdhcmUuXHJcbiAgICogVHJ1dGh5IHBhcmFtZXRlciBzdGFuZHMgZm9yIFwidG8gdGhlIGJlZ2lubmluZ1wiIGFuZCBmYWxzZXkgZm9yIFwidG8gdGhlIGVuZFwiLlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIEFkZHMgYmVmb3JlIG1pZGRsZXdhcmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpXHJcbiAgICogICAuYmVmb3JlKChbYXJnXSkgPT4gW2FyZyAqIGFyZ10pO1xyXG4gICAqXHJcbiAgICogZnVuYyg0KTsgLy8gMTdcclxuICAgKiBmdW5jKDMpOyAvLyAxMFxyXG4gICAqL1xyXG4gIGJlZm9yZShtaWRkbGV3YXJlLCBiZWZvcmVBbGwgPSB0cnVlKSB7XHJcbiAgICB2YWxpZGF0ZShbbWlkZGxld2FyZV0sIFsnZnVuY3Rpb24nXSwgJ0Z1bmMjYmVmb3JlJyk7XHJcblxyXG4gICAgY29uc3QgeyBiZWZvcmUgfSA9IHRoaXMuJCQ7XHJcblxyXG4gICAgaWYgKGJlZm9yZUFsbCkge1xyXG4gICAgICBiZWZvcmUudW5zaGlmdChtaWRkbGV3YXJlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJlZm9yZS5wdXNoKG1pZGRsZXdhcmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2JpbmRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dCB0byBiaW5kLlxyXG4gICAqIEBwYXJhbSB7Li4uKEFycmF5fEFyZ3VtZW50c3wqKX0gYXJncyAtIEFyZ3VtZW50cyB0byBiaW5kLlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIENvbXBvc2l0aW9uIG9mIHtAbGluayBGdW5jI2JpbmRDb250ZXh0fSBhbmQge0BsaW5rIEZ1bmMjYmluZEFyZ3N9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgKiAgIHJldHVybiB0aGlzLmEgKyBhICsgYjtcclxuICAgKiB9KS5iaW5kKHsgYTogMiB9LCAxKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSk7IC8vIDRcclxuICAgKiBmdW5jKDMpOyAvLyA2XHJcbiAgICovXHJcbiAgYmluZChjb250ZXh0LCAuLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAuYmluZENvbnRleHQoY29udGV4dClcclxuICAgICAgLmJpbmRBcmdzKGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2JpbmRBcmdzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7KEFycmF5fEFyZ3VtZW50cyl9IGFyZ3MgLSBBcmd1bWVudHMgdG8gYmluZC5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBCaW5kcyBhcmd1bWVudHMgaW4gYWRkaXRpb24gdG8gYWxyZWFkeSBsb2NrZWQgYW5kIGJvdW5kIG9uZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoLi4uYXJncykgPT4ge1xyXG4gICAqICAgbGV0IHN1bSA9IDA7XHJcbiAgICpcclxuICAgKiAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAqICAgICBzdW0gKz0gYXJnc1tpXTtcclxuICAgKiAgIH1cclxuICAgKlxyXG4gICAqICAgcmV0dXJuIHN1bTtcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSwgMiwgMyk7IC8vIDZcclxuICAgKlxyXG4gICAqIGZ1bmMuYmluZEFyZ3MoWzRdKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSwgMiwgMyk7IC8vIDEwXHJcbiAgICpcclxuICAgKiBmdW5jLmJpbmRBcmdzKFs1XSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxNVxyXG4gICAqL1xyXG4gIGJpbmRBcmdzKGFyZ3MpIHtcclxuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xyXG5cclxuICAgIGZ1bmMuYXJncyA9IGZ1bmMuYXJncy5jb25jYXQodG9BcnJheShhcmdzKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjYmluZENvbnRleHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dCB0byBiaW5kLlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIEJpbmQgbmV3IGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBsb2NrZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhmdW5jdGlvbiAoKSB7XHJcbiAgICogICByZXR1cm4gdGhpcy5hO1xyXG4gICAqIH0pLmJpbmRDb250ZXh0KHsgYTogMSB9KTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gMVxyXG4gICAqXHJcbiAgICogZnVuYy5iaW5kQ29udGV4dCh7IGE6IDIgfSk7XHJcbiAgICpcclxuICAgKiBmdW5jKCk7IC8vIDJcclxuICAgKi9cclxuICBiaW5kQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBmdW5jID0gdGhpcy4kJDtcclxuXHJcbiAgICBpZiAoIWZ1bmMuY29udGV4dExvY2tlZCkge1xyXG4gICAgICBmdW5jLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2NhbGxcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gLSBDb250ZXh0IHRvIGNhbGwgd2l0aC5cclxuICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIEFyZ3VtZW50cyB0byBjYWxsIHdpdGguXHJcbiAgICogQHJldHVybnMgeyp9IFJldHVybiBvZiBmdW5jdGlvbiBjYWxsLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtGdW5jdGlvbiNjYWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9jYWxsfS5cclxuICAgKi9cclxuICBjYWxsKGNvbnRleHQsIC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiAoKCkgPT4ge30pLmNhbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge051bWJlcn0gRnVuYyNjYWxsZWRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaG93IG1hbnkgdGltZXMgdGhlIGZ1bmN0aW9uIHdhcyBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpO1xyXG4gICAqXHJcbiAgICogZnVuYygpO1xyXG4gICAqIGZ1bmMoKTtcclxuICAgKlxyXG4gICAqIGZ1bmMuY2FsbGVkIC8vIDJcclxuICAgKi9cclxuICBnZXQgY2FsbGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJCQuY2FsbGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2NhbkJlQ2FsbGVkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lcyAtIE51bWJlciBvZiBtYXhpbXVtIHRpbWVzIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgKG1pZGRsZXdhcmVzIGFyZSBhbHNvIHRha2VuIGZvciBhIGNvdW50KS5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGxpbWl0aW5nIGNhbGwgdGltZXMgb2YgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYygoYSkgPT4gYSArIDEpXHJcbiAgICogICAuY2FuQmVDYWxsZWQoMSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEpOyAvLyAyXHJcbiAgICogZnVuYygxKTsgLy8gdW5kZWZpbmVkXHJcbiAgICovXHJcbiAgY2FuQmVDYWxsZWQodGltZXMpIHtcclxuICAgIHRoaXMuJCQuY2FuQmVDYWxsZWQgPSB0aW1lcztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNsaW1pdEFyZ3NUb1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTnVtYmVyIG9mIGFyZ3VtZW50cyB0byBsaW1pdCB0by5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsdC1pbiBiZWZvcmUgbWlkZGxld2FyZSBmb3IgbGltaXRpbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAqIHRoYXQgaXMgcHV0IHRvIHRoZSBlbmQgb2YgYmVmb3JlIG1pZGRsZXdhcmVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKGEsIGIpID0+IFthLCBiXSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIpOyAvLyBbMSwgMl1cclxuICAgKlxyXG4gICAqIGZ1bmMubGltaXRBcmdzVG8oMSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIpOyAvLyBbMSwgdW5kZWZpbmVkXVxyXG4gICAqL1xyXG4gIGxpbWl0QXJnc1RvKG51bWJlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlKChhcmdzKSA9PiBhcmdzLnNsaWNlKDAsIG51bWJlciksIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNsb2NrXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgdG8gbG9jay5cclxuICAgKiBAcGFyYW0geyhBcnJheXxBcmd1bWVudHN8Kil9IGFyZ3MgLSBBcmd1bWVudHMgdG8gbG9jay5cclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBDb21wb3NpdGlvbiBvZiB7QGxpbmsgRnVuYyNsb2NrQ29udGV4dH0gYW5kIHtAbGluayBGdW5jI2xvY2tBcmdzfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICogICByZXR1cm4gdGhpcy5hICsgYSArIGI7XHJcbiAgICogfSkubG9jayh7IGE6IDIgfSwgWzFdKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSk7IC8vIDRcclxuICAgKiBmdW5jKDMpOyAvLyA2XHJcbiAgICovXHJcbiAgbG9jayhjb250ZXh0LCBhcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAubG9ja0NvbnRleHQoY29udGV4dClcclxuICAgICAgLmxvY2tBcmdzKGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI2xvY2tBcmdzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7KEFycmF5fEFyZ3VtZW50c3wqKX0gYXJncyAtIEFyZ3VtZW50cyB0byBsb2NrLlxyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIEVyYXNlcyBib3VuZCBhcmd1bWVudHMgYW5kIGFkZHMgbmV3IGFyZ3VtZW50cyB0byBhbHJlYWR5IGxvY2tlZCBvbmVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKC4uLmFyZ3MpID0+IHtcclxuICAgKiAgIGxldCBzdW0gPSAwO1xyXG4gICAqXHJcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgKiAgICAgc3VtICs9IGFyZ3NbaV07XHJcbiAgICogICB9XHJcbiAgICpcclxuICAgKiAgIHJldHVybiBzdW07XHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyA2XHJcbiAgICpcclxuICAgKiBmdW5jLmxvY2tBcmdzKFs0XSk7XHJcbiAgICpcclxuICAgKiBmdW5jKDEsIDIsIDMpOyAvLyAxMFxyXG4gICAqXHJcbiAgICogZnVuYy5iaW5kQXJncyhbNiwgN10pO1xyXG4gICAqIGZ1bmMubG9ja0FyZ3MoWzVdKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSwgMiwgMyk7IC8vIDE1XHJcbiAgICovXHJcbiAgbG9ja0FyZ3MoYXJncykge1xyXG4gICAgY29uc3QgZnVuYyA9IHRoaXMuJCQ7XHJcblxyXG4gICAgZnVuYy5hcmdzID0gZnVuYy5hcmdzTG9ja2VkID0gZnVuYy5hcmdzTG9ja2VkLmNvbmNhdCh0b0FycmF5KGFyZ3MpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyNsb2NrQ29udGV4dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgLSBDb250ZXh0IHRvIGxvY2suXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTG9ja3MgY29udGV4dCBpZiBpdCdzIG5vdCBhbHJlYWR5IGxvY2tlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKGZ1bmN0aW9uICgpIHtcclxuICAgKiAgIHJldHVybiB0aGlzLmE7XHJcbiAgICogfSkubG9ja0NvbnRleHQoeyBhOiAxIH0pO1xyXG4gICAqXHJcbiAgICogZnVuYygpOyAvLyAxXHJcbiAgICpcclxuICAgKiBmdW5jLmxvY2tDb250ZXh0KHsgYTogMiB9KTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gMVxyXG4gICAqL1xyXG4gIGxvY2tDb250ZXh0KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmICghZnVuYy5jb250ZXh0TG9ja2VkKSB7XHJcbiAgICAgIGZ1bmMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgIGZ1bmMuY29udGV4dExvY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZ1bmMjdGltaW5nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrIC0gQXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdG8gY29uc29sZS50aW1lKCkgYW5kIGNvbnNvbGUudGltZUVuZCgpLlxyXG4gICAqIEJ5IGRlZmF1bHQgbmFtZSBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24sIG9yIGlmIGl0J3Mgbm90IHByZXNlbnQsICdhbm9ueW1vdXMnIGlzIHVzZWQuXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gQnVpbHQtaW4gYmVmb3JlIGFuZCBhZnRlciBtaWRkbGV3YXJlcyBmb3Igbm90aW5nIGNhbGxpbmcgdGltZS5cclxuICAgKiBJbiBjYXNlIG9mIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgaXQgbm90ZXMgdGltZSBiZXR3ZWVuIGNhbGxpbmcgZnVuY3Rpb24gYW5kIHJlc29sdmluZyBvciByZWplY3RpbmcgdGhlIHJlc3VsdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZnVuYyA9IG5ldyBGdW5jKChhKSA9PiBhICsgMSlcclxuICAgKiAgIC50aW1pbmcoJ3BsdXMgMScpO1xyXG4gICAqXHJcbiAgICogZnVuYygyKTsgLy8gcGx1cyAxOiAwLjAxMG1zXHJcbiAgICpcclxuICAgKiBjb25zdCBhc3luYyA9IG5ldyBGdW5jKCgpID0+IG5ldyBQcm9taXNlKCgpID0+IHtcclxuICAgKiAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKTtcclxuICAgKiAgIH0pKVxyXG4gICAqICAgLmFzeW5jKClcclxuICAgKiAgIC50aW1pbmcoKTtcclxuICAgKlxyXG4gICAqIGFzeW5jKCk7XHJcbiAgICogLy8gQWZ0ZXIgMSBzZWNvbmQuLi5cclxuICAgKiAvLyBhbm9ueW1vdXM6IDEwMDAuMDEwbXNcclxuICAgKi9cclxuICB0aW1pbmcobWFyaykge1xyXG4gICAgbWFyayA9IGFyZ3VtZW50cy5sZW5ndGggPyBTdHJpbmcobWFyaykgOiB0aGlzLiQubmFtZSB8fCAnYW5vbnltb3VzJztcclxuXHJcbiAgICB0aGlzLmJlZm9yZSgoYXJncykgPT4ge1xyXG4gICAgICBjb25zb2xlLnRpbWUobWFyayk7XHJcblxyXG4gICAgICByZXR1cm4gYXJncztcclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLmFmdGVyKChyZXQpID0+IHtcclxuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmspO1xyXG5cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuICgoKSA9PiB7fSkudG9TdHJpbmcuY2FsbCh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI3VuYmluZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RnVuY30gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBDb21wb3NpdGlvbiBvZiB7QGxpbmsgRnVuYyN1bmJpbmRDb250ZXh0fSBhbmQge0BsaW5rIEZ1bmMjdW5iaW5kQXJnc30uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZ1bmMgPSBuZXcgRnVuYyhmdW5jdGlvbiAoYSkge1xyXG4gICAqICAgcmV0dXJuIHRoaXMuZm9vICsgJyAmICcgKyAgYTtcclxuICAgKiB9KS5iaW5kKHsgZm9vOiAyIH0sIDEpO1xyXG4gICAqXHJcbiAgICogZnVuYygpOyAvLyAnMiAmIDEnXHJcbiAgICpcclxuICAgKiBmdW5jLnVuYmluZCgpO1xyXG4gICAqXHJcbiAgICogZnVuYygpOyAvLyAndW5kZWZpbmVkICYgdW5kZWZpbmVkJ1xyXG4gICAqL1xyXG4gIHVuYmluZCgpIHtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgICAgIC51bmJpbmRDb250ZXh0KClcclxuICAgICAgLnVuYmluZEFyZ3MoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRnVuYyN1bmJpbmRBcmdzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtGdW5jfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIEVyYXNlcyBhbGwgYm91bmQgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoKC4uLmFyZ3MpID0+IHtcclxuICAgKiAgIGxldCBzdW0gPSAwO1xyXG4gICAqXHJcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgKiAgICAgc3VtICs9IGFyZ3NbaV07XHJcbiAgICogICB9XHJcbiAgICpcclxuICAgKiAgIHJldHVybiBzdW07XHJcbiAgICogfSkuYmluZEFyZ3MoWzQsIDVdKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSwgMiwgMyk7IC8vIDE1XHJcbiAgICpcclxuICAgKiBmdW5jLnVuYmluZEFyZ3MoKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoMSwgMiwgMyk7IC8vIDZcclxuICAgKi9cclxuICB1bmJpbmRBcmdzKCkge1xyXG4gICAgY29uc3QgZnVuYyA9IHRoaXMuJCQ7XHJcblxyXG4gICAgZnVuYy5hcmdzID0gZnVuYy5hcmdzTG9ja2VkO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGdW5jI3VuYmluZENvbnRleHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Z1bmN9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gRXJhc2VzIGNvbnRleHQgaWYgaXQncyBub3QgbG9ja2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmdW5jID0gbmV3IEZ1bmMoZnVuY3Rpb24gKCkge1xyXG4gICAqICAgcmV0dXJuIHRoaXMuZm9vO1xyXG4gICAqIH0pLmJpbmRDb250ZXh0KHsgZm9vOiAxIH0pO1xyXG4gICAqXHJcbiAgICogZnVuYygpOyAvLyAxXHJcbiAgICpcclxuICAgKiBmdW5jLnVuYmluZEFyZ3MoKTtcclxuICAgKlxyXG4gICAqIGZ1bmMoKTsgLy8gdW5kZWZpbmVkXHJcbiAgICovXHJcbiAgdW5iaW5kQ29udGV4dCgpIHtcclxuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmICghZnVuYy5jb250ZXh0TG9ja2VkKSB7XHJcbiAgICAgIGZ1bmMuY29udGV4dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmMucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdGdW5jJ1xyXG59KTtcclxuXHJcbmNvbnN0cnVjdG9yc1sxXS5wdXNoKHtcclxuICBjaGVjazogaXNGdW5jdGlvbixcclxuICBjbHM6IEZ1bmNcclxufSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIG1ldGhvZFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBNZXRob2QgdG8gY2FsbC5cclxuICogQHBhcmFtIHsoQXJyYXl8QXJndW1lbnRzfCopfSBhcmdzIC0gQXJndW1lbnRzIHRvIGNhbGwgdGhlIG1ldGhvZCB3aXRoLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgY2FsbHMgc3RhdGVkIG1ldGhvZCB3aXRoIGdpdmVuIGFyZ3VtZW50cy5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZnVuY3Rpb25cclxuICogdGhhdCBjYWxscyBzdGF0ZWQgbWV0aG9kIG9mIGl0cyBmaXJzdCBhcmd1bWVudCB3aXRoIGdpdmVuIGFyZ3VtZW50cy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogWzEuMjM0NSwgMi43ODksIDMuMTRdLm1hcChtZXRob2QoJ3RvRml4ZWQnLCBbMl0pKTsgLy8gWycxLjIzJywgJzIuNzknLCAnMy4xNCddXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXRob2QobWV0aG9kLCBhcmdzID0gW10pIHtcclxuICByZXR1cm4gKHgpID0+IHhbbWV0aG9kXS5hcHBseSh4LCB0b0FycmF5KGFyZ3MpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBub29wXHJcbiAqIEBwdWJsaWNcclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqIEBkZXNjcmlwdGlvbiBFbXB0eSBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBwcm9wXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgLSBQcm9wZXJ0eSB0byByZXR1cm4uXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGdpdmVuIHByb3BlcnR5IG9mIGl0cyBmaXJzdCBhcmd1bWVudC5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIHRoYXQgcmV0dXJuIHRoZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZ2l2ZW4gcHJvcGVydHkgb2YgaXRzIGZpcnN0IGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBbJ2ZvbycsICcxMicsICc3ODkwJ10ubWFwKHByb3AoJ2xlbmd0aCcpKTsgLy8gWzMsIDIsIDRdXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9wKHByb3ApIHtcclxuICByZXR1cm4gKHsgW3Byb3BdOiB2YWx1ZSB9KSA9PiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBzZWxmXHJcbiAqIEBwdWJsaWNcclxuICogQHJldHVybnMgeyp9IEZpcnN0IGFyZ3VtZW50IGl0c2VsZi5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFsxLCAyXS5tYXAoc2VsZik7ICAgICAgICAgICAgICAgICAgICAgLy8gWzEsIDJdXHJcbiAqIFsxLCAzLCBOYU4sIDAsIDcsIG51bGxdLmZpbHRlcihzZWxmKTsgLy8gWzEsIDMsIDddXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWxmKCkge1xyXG4gIHJldHVybiBhcmd1bWVudHNbMF07XHJcbn1cclxuXHJcbmV4cG9ydCB7IEZ1bmMsIG1ldGhvZCwgbm9vcCwgcHJvcCwgc2VsZiB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBOdW1cclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIE51bSBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xyXG5pbXBvcnQgeyBGdW5jIH0gZnJvbSAnLi9GdW5jJztcclxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBpc051bWJlciwgaXNGaW5pdGUsIHRvQXJyYXksXHJcbiAgZGVmaW5lUHJvcGVydGllcywgdmFsaWRhdGUsIFN5bWJvbFxyXG59IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG5jb25zdCB0b1JhZGlhbiA9IE1hdGguUEkgLyAxODA7XHJcbmNvbnN0IHRvRGVncmVlID0gMTgwIC8gTWF0aC5QSTtcclxuY29uc3QgbG4yID0gTWF0aC5MTjI7XHJcbmNvbnN0IGxuMTAgPSBNYXRoLkxOMTA7XHJcblxyXG4vKipcclxuICogQGNsYXNzIE51bVxyXG4gKiBAZXh0ZW5kcyBTdXBlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyID0gMF0gLSBBIG51bWJlciB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7TnVtfSBJbnN0YW5jZSBvZiBOdW0uXHJcbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBudW0gPSBuZXcgTnVtKDEpO1xyXG4gKi9cclxuY2xhc3MgTnVtIGV4dGVuZHMgU3VwZXIge1xyXG4gIGNvbnN0cnVjdG9yKG51bWJlciA9IDApIHtcclxuICAgIHN1cGVyKCtudW1iZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciBOdW0jJFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hbCBudW1iZXIuXHJcbiAgICAgKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2Fic1xyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hYnNcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5hYnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWJzfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSgxKS5hYnM7ICAvLyAxXHJcbiAgICogbmV3IE51bSgtMSkuYWJzOyAvLyAxXHJcbiAgICovXHJcbiAgZ2V0IGFicygpIHtcclxuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jYWNvc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW3RvRGVncmVlcyA9IGZhbHNlXSBJZiBpdCBpcyB0cnV0aHkgdGhlIHJldHVybiB2YWx1ZSBpcyB0cmFuc2Zvcm1lZCBpbnRvIGRlZ3JlZXMuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gQXJjY29zaW5lIG9mIHRoZSBudW1iZXIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fjb3NcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5hY29zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fjb3N9LlxyXG4gICAqL1xyXG4gIGFjb3ModG9EZWdyZWVzKSB7XHJcbiAgICByZXR1cm4gKHRvRGVncmVlcyA/IHRvRGVncmVlIDogMSkgKiBNYXRoLmFjb3ModGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2Fjb3NoXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fjb3NoXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguYWNvc2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYWNvc2h9LlxyXG4gICAqL1xyXG4gIGdldCBhY29zaCgpIHtcclxuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5sb2cobnVtYmVyICsgTWF0aC5zcXJ0KG51bWJlciAqIG51bWJlciAtIDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2FzaW5oXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2FzaW5oXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguYXNpbmhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXNpbmh9LlxyXG4gICAqL1xyXG4gIGdldCBhc2luaCgpIHtcclxuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5sb2cobnVtYmVyICsgTWF0aC5zcXJ0KG51bWJlciAqIG51bWJlciArIDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI2FzaW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFt0b0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSByZXR1cm4gdmFsdWUgaXMgdHJhbnNmb3JtZWQgaW50byBkZWdyZWVzLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IEFyY3NpbmUgb2YgdGhlIG51bWJlci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXNpblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmFzaW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXNpbn0uXHJcbiAgICovXHJcbiAgYXNpbih0b0RlZ3JlZXMpIHtcclxuICAgIHJldHVybiAodG9EZWdyZWVzID8gdG9EZWdyZWUgOiAxKSAqIE1hdGguYXNpbih0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jYXRhblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW3RvRGVncmVlcyA9IGZhbHNlXSBJZiBpdCBpcyB0cnV0aHkgdGhlIHJldHVybiB2YWx1ZSBpcyB0cmFuc2Zvcm1lZCBpbnRvIGRlZ3JlZXMuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gQXJjc2luZSBvZiB0aGUgbnVtYmVyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hdGFuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguYXRhbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hdGFufS5cclxuICAgKi9cclxuICBhdGFuKHRvRGVncmVlcykge1xyXG4gICAgcmV0dXJuICh0b0RlZ3JlZXMgPyB0b0RlZ3JlZSA6IDEpICogTWF0aC5hdGFuKHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNhdGFuaFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hdGFuaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmF0YW5oXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2F0YW5ofS5cclxuICAgKi9cclxuICBnZXQgYXRhbmgoKSB7XHJcbiAgICBjb25zdCBudW1iZXIgPSB0aGlzLiQ7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubG9nKCgxICsgbnVtYmVyKSAvICgxIC0gbnVtYmVyKSkgLyAyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jY2JydFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jYnJ0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguY2JydF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jYnJ0fS5cclxuICAgKi9cclxuICBnZXQgY2JydCgpIHtcclxuICAgIGNvbnN0IGNicnQgPSBNYXRoLnBvdyhNYXRoLmFicyh0aGlzLiQpLCAxIC8gMyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJCA+IDAgPyBjYnJ0IDogLWNicnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNjZWlsXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NlaWxcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5jZWlsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NlaWx9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDEuMSkuY2VpbDsgIC8vIDJcclxuICAgKiBuZXcgTnVtKC0xLjEpLmNlaWw7IC8vIC0xXHJcbiAgICovXHJcbiAgZ2V0IGNlaWwoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSNjb3NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFthc0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSBudW1iZXIgaXMgdHJlYXRlZCBhcyBhIGRlZ3JlZSB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBDb3NpbmUgb2YgdGhlIG51bWJlci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY29zXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguY29zXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Nvc30uXHJcbiAgICovXHJcbiAgY29zKGFzRGVncmVlcykge1xyXG4gICAgcmV0dXJuIE1hdGguY29zKChhc0RlZ3JlZXMgPyB0b1JhZGlhbiA6IDEpICogdGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2Nvc2hcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY29zaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmNvc2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY29zaH0uXHJcbiAgICovXHJcbiAgZ2V0IGNvc2goKSB7XHJcbiAgICBjb25zdCBleHAgPSB0aGlzLmV4cDtcclxuXHJcbiAgICByZXR1cm4gKGV4cCArIDEgLyBleHApIC8gMjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2N1YmVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gQ3ViZSBvZiB0aGUgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDIpLmN1YmU7ICAvLyA4XHJcbiAgICogbmV3IE51bSgtMykuY2VpbDsgLy8gLTI3XHJcbiAgICovXHJcbiAgZ2V0IGN1YmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kICogdGhpcy4kICogdGhpcy4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jZXhwXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2V4cFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmV4cF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9leHB9LlxyXG4gICAqL1xyXG4gIGdldCBleHAoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5leHAodGhpcy4kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2Zsb29yXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Zsb29yXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguZmxvb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvZmxvb3J9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDEuMSkuZmxvb3I7ICAvLyAxXHJcbiAgICogbmV3IE51bSgtMS4xKS5mbG9vcjsgLy8gLTJcclxuICAgKi9cclxuICBnZXQgZmxvb3IoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jaW50ZXJ2YWxcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGV2ZXJ5IDxudW1iZXI+IG1pbGxpc2Vjb25kcy5cclxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gLSBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgYWJvcnRzIHRoZSBpbnRlcnZhbC4gVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uIChpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kKVxyXG4gICAqIGlzIHRoZSBvYmplY3Qgd2l0aCB0aGUgYWJvcnQgbWV0aG9kLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zZXRJbnRlcnZhbFxyXG4gICAqIEBkZXNjcmlwdGlvbiBBbmFsb2d1ZSBvZiB0aGVcclxuICAgKiBbc2V0SW50ZXJ2YWxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0SW50ZXJ2YWx9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCB0aW1lcyA9IDA7XHJcbiAgICogbmV3IE51bSg1MCkuaW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAqICAgaWYgKCsrdGltZXMgPT09IDEwKSB7XHJcbiAgICogICAgIHRoaXMuYWJvcnQoKTtcclxuICAgKiAgIH1cclxuICAgKiB9KTtcclxuICAgKi9cclxuICBpbnRlcnZhbChmdW5jLCBhcmdzID0gW10pIHtcclxuICAgIHZhbGlkYXRlKFtmdW5jXSwgWydmdW5jdGlvbiddLCAnTnVtI2ludGVydmFsJyk7XHJcblxyXG4gICAgZnVuYyA9IG5ldyBGdW5jKGZ1bmMpLmJpbmRDb250ZXh0KHsgYWJvcnQgfSk7XHJcbiAgICBhcmdzID0gdG9BcnJheShhcmdzKTtcclxuXHJcbiAgICBjb25zdCBudW1iZXIgPSB0aGlzLiQ7XHJcblxyXG4gICAgbGV0IGFib3J0ZWQ7XHJcbiAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gaW50ZXJ2YWwoKSB7XHJcbiAgICAgIGlmICghYWJvcnRlZCkge1xyXG4gICAgICAgIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XHJcblxyXG4gICAgICAgIGlmICghYWJvcnRlZCkge1xyXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoaW50ZXJ2YWwsIG51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCAwKTtcclxuXHJcbiAgICByZXR1cm4gYWJvcnQ7XHJcblxyXG4gICAgZnVuY3Rpb24gYWJvcnQoKSB7XHJcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI2xuXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZ1xyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmxvZ117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2d9LlxyXG4gICAqL1xyXG4gIGdldCBsbigpIHtcclxuICAgIHJldHVybiBNYXRoLmxvZyh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jbG9nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgLSBOdW1iZXIgdG8gZ2V0IGxvZ2FyaXRobSBvZi5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBMb2dhcml0aG0gb2YgdGhlIGFyZ3VtZW50IG51bWJlciB0byB0aGUgbnVtYmVyIGJhc2UuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGxvZ2FyaXRobSBvZiB0aGUgYXJndW1lbnQgbnVtYmVyIHRvIHRoZSBudW1iZXIgYmFzZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IE51bSgyKS5sb2coMTYpOyAgLy8gNFxyXG4gICAqIG5ldyBOdW0oMykubG9nKDI0Myk7IC8vIDVcclxuICAgKi9cclxuICBsb2cobnVtYmVyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5sb2cobnVtYmVyKSAvIE1hdGgubG9nKHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNsb2cyXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZzJcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5sb2cyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZzJ9LlxyXG4gICAqL1xyXG4gIGdldCBsb2cyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG4gLyBsbjI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSNsb2cxMFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2cxMFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLmxvZzEwXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZzEwfS5cclxuICAgKi9cclxuICBnZXQgbG9nMTAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sbiAvIGxuMTA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSNwb3dcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvd2VyIC0gUG93ZXIgdGhlIG51bWJlciBzaG91bGQgYmUgcmFpc2VkIHRvLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgdG8gdGhlIDxwb3dlcj4gcG93ZXIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3Bvd1xyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLnBvd117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9wb3d9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDQpLnBvdyguNSk7IC8vIDJcclxuICAgKiBuZXcgTnVtKDMpLnBvdygyKTsgIC8vIDlcclxuICAgKi9cclxuICBwb3cocG93ZXIpIHtcclxuICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLiQsIHBvd2VyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgTnVtI3Jvb3RcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvd2VyIC0gUG93ZXIgdGhlIG51bWJlciBzaG91bGQgYmUgcmFpc2VkIHRvLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSA8cG93ZXI+IHJvb3Qgb2YgdGhlIG51bWJlci5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3IgbnVtYmVyLnBvdygxIC8gcG93ZXIpO1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDQpLnJvb3QoMik7ICAgLy8gMC41XHJcbiAgICogbmV3IE51bSgyNDMpLnJvb3QoNSk7IC8vIDNcclxuICAgKi9cclxuICByb290KHBvd2VyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5wb3codGhpcy4kLCAxIC8gcG93ZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jcm91bmRcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcm91bmRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5yb3VuZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9yb3VuZH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBOdW0oMS4xKS5mbG9vcjsgIC8vIDFcclxuICAgKiBuZXcgTnVtKC0xLjEpLmZsb29yOyAvLyAtMVxyXG4gICAqIG5ldyBOdW0oMS41KS5mbG9vcjsgIC8vIDJcclxuICAgKi9cclxuICBnZXQgcm91bmQoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jc2lnblxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguc2lnbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWdufS5cclxuICAgKi9cclxuICBnZXQgc2lnbigpIHtcclxuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoIW51bWJlcikge1xyXG4gICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudW1iZXIgPiAwID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jc2luXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbYXNEZWdyZWVzID0gZmFsc2VdIElmIGl0IGlzIHRydXRoeSB0aGUgbnVtYmVyIGlzIHRyZWF0ZWQgYXMgYSBkZWdyZWUgdmFsdWUuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gU2luZSBvZiB0aGUgbnVtYmVyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaW5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC5zaW5de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lufS5cclxuICAgKi9cclxuICBzaW4oYXNEZWdyZWVzKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zaW4oKGFzRGVncmVlcyA/IHRvUmFkaWFuIDogMSkgKiB0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jc2luaFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaW5oXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW01hdGguc2luaF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaW5ofS5cclxuICAgKi9cclxuICBnZXQgc2luaCgpIHtcclxuICAgIGNvbnN0IGV4cCA9IHRoaXMuZXhwO1xyXG5cclxuICAgIHJldHVybiAoZXhwIC0gMSAvIGV4cCkgLyAyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBOdW0jc3FcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHNxdWFyZSBvZiB0aGUgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDIpLnNxOyAgLy8gNFxyXG4gICAqIG5ldyBOdW0oLTMpLnNxOyAvLyA5XHJcbiAgICovXHJcbiAgZ2V0IHNxKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJCAqIHRoaXMuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgTnVtI3NxcnRcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc3FydFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLnNxcnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc3FydH0uXHJcbiAgICovXHJcbiAgZ2V0IHNxcnQoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSN0YW5cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFthc0RlZ3JlZXMgPSBmYWxzZV0gSWYgaXQgaXMgdHJ1dGh5IHRoZSBudW1iZXIgaXMgdHJlYXRlZCBhcyBhIGRlZ3JlZSB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUYW5nZW50IG9mIHRoZSBudW1iZXIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RhblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtNYXRoLnRhbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90YW59LlxyXG4gICAqL1xyXG4gIHRhbihhc0RlZ3JlZXMpIHtcclxuICAgIHJldHVybiBNYXRoLnRhbigoYXNEZWdyZWVzID8gdG9SYWRpYW4gOiAxKSAqIHRoaXMuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIE51bSN0YW5oXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RhbmhcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTWF0aC50YW5oXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3Rhbmh9LlxyXG4gICAqL1xyXG4gIGdldCB0YW5oKCkge1xyXG4gICAgY29uc3QgbnVtYmVyID0gdGhpcy4kO1xyXG5cclxuICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaWduO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV4cCA9IE1hdGguZXhwKDIgKiBudW1iZXIpO1xyXG5cclxuICAgIHJldHVybiAoZXhwIC0gMSkgLyAoZXhwICsgMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSN0aW1lb3V0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIFZhbHVlIHRvIGJlIHJlc29sdmVkIGJ5IHRoZSBwcm9taXNlLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgY291bGQgYmUgYWJvcnRlZC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0VGltZW91dFxyXG4gICAqIEBkZXNjcmlwdGlvbiBQcm9taXNlLWJhc2VkIGFuYWxvZ3VlIG9mXHJcbiAgICogW3NldFRpbWVvdXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0VGltZW91dH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBOdW0oNTApLnRpbWVvdXQoJ3Jlc29sdmVkJykudGhlbigodmFsdWUpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJ3Jlc29sdmVkJ1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogY29uc3QgcHJvbWlzZSA9IG5ldyBOdW0oNTApLnRpbWVvdXQoKTtcclxuICAgKiBwcm9taXNlLmFib3J0KCk7XHJcbiAgICovXHJcbiAgdGltZW91dCh2YWx1ZSkge1xyXG4gICAgbGV0IHRpbWVvdXQ7XHJcbiAgICBsZXQgcmVqZWN0O1xyXG5cclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqKSA9PiB7XHJcbiAgICAgIHJlamVjdCA9IHJlajtcclxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy4kLCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuXHJcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQgd2FzIGFib3J0ZWQnKSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSN0b0Jhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtiYXNlID0gMTBdIC0gQmFzZSB0aGF0IHRoZSBudW1iZXIgc2hvdWxkIGludmVydGVkIHRvLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgaW4gPGJhc2U+IGJhc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9TdHJpbmdcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTnVtYmVyI3RvU3RyaW5nXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9TdHJpbmd9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgTnVtKDQpLnRvQmFzZSgyKTsgLy8gMTAwXHJcbiAgICogbmV3IE51bSgzKS50b0Jhc2UoKTsgIC8vIDNcclxuICAgKi9cclxuICB0b0Jhc2UoYmFzZSA9IDEwKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnRvU3RyaW5nKGJhc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jdG9FeHBvbmVudGlhbFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyIGluIHRoZSBleHBvbmVudGlhbCBmb3JtYXQuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9FeHBvbmVudGlhbFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtOdW1iZXIjdG9FeHBvbmVudGlhbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvRXhwb25lbnRpYWx9LlxyXG4gICAqL1xyXG4gIHRvRXhwb25lbnRpYWwoZnJhY3Rpb25EaWdpdHMpIHtcclxuICAgIHJldHVybiB0aGlzLiQudG9FeHBvbmVudGlhbChmcmFjdGlvbkRpZ2l0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIE51bSN0b0ZpeGVkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGlnaXRzID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gRml4ZWQtcG9pbnQgZm9ybWF0dGVkIG51bWJlci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b0ZpeGVkXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW051bWJlciN0b0ZpeGVkXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9GaXhlZH0uXHJcbiAgICovXHJcbiAgdG9GaXhlZChkaWdpdHMpIHtcclxuICAgIHJldHVybiB0aGlzLiQudG9GaXhlZChkaWdpdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBOdW0jdG9QcmVjaXNpb25cclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmVjaXNpb25dIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgdG8gdGhlIHNwZWNpZmllZCBwcmVjaXNpb24uXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9QcmVjaXNpb25cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbTnVtYmVyI3RvUHJlY2lzaW9uXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9QcmVjaXNpb259LlxyXG4gICAqL1xyXG4gIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuJC50b1ByZWNpc2lvbihwcmVjaXNpb24pO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVPZigpIHtcclxuICAgIHJldHVybiBOdW1iZXIodGhpcy4kKTtcclxuICB9XHJcbn1cclxuXHJcbmRlZmluZVByb3BlcnRpZXMoTnVtLnByb3RvdHlwZSwge1xyXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnTnVtJ1xyXG59KTtcclxuXHJcbmNvbnN0cnVjdG9yc1sxXS5wdXNoKHtcclxuICBjaGVjazogaXNOdW1iZXIsXHJcbiAgY2xzOiBOdW1cclxufSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIHJhbmRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0ID0gMF0gLSBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kID0gMV0gLSBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSYW5kb20gbnVtYmVyLlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiByYW5kKDEsIDUpOyAvLyAyLjMxNVxyXG4gKiByYW5kKDEsIDUpOyAvLyA0LjM1Njc2M1xyXG4gKi9cclxuZnVuY3Rpb24gcmFuZChzdGFydCA9IDAsIGVuZCA9IDEpIHtcclxuICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogTWF0aC5yYW5kb20oKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiByYW5kb21cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHN0YXJ0IC0gU3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGVuZCAtIEVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJhbmRvbSBpbnRlZ2VyLlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBpbiB0aGUgcmFuZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIHJhbmRvbSgxLCA1KTsgLy8gM1xyXG4gKiByYW5kb20oMSwgNSk7IC8vIDFcclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbShzdGFydCwgZW5kKSB7XHJcbiAgdmFsaWRhdGUoW3N0YXJ0LCBlbmRdLCBbJ2ludExpa2UnLCAnaW50TGlrZSddLCAncmFuZG9tJyk7XHJcblxyXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgZmlyc3QhJywgJ3JhbmRvbScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE1hdGguZmxvb3IocmFuZChzdGFydCwgZW5kICsgMSkpO1xyXG59XHJcblxyXG5leHBvcnQgeyBOdW0sIHJhbmQsIHJhbmRvbSB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBBcnJcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEFyciBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyByYW5kb20gfSBmcm9tICcuL051bSc7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IGNvbnN0cnVjdG9ycyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBpc0FycmF5TGlrZSwgaXNOYU4sIGlzTnVtYmVyLCBpc1N0cmluZyxcclxuICB0b0FycmF5LCB2YWxpZGF0ZSwgaXRlcmF0ZSBhcyBpdGVyYXRvciwgU3ltYm9sLCBkZWZpbmVQcm9wZXJ0aWVzXHJcbn0gZnJvbSAnLi9oZWxwZXJzJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7QXJyYXl8Kn0gQXJyYXlMaWtlXHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEFycmF5LWxpa2UgdHlwZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEFycmF5Q2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gaSAtIEl0ZXJhdGlvbiBpbmRleC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEl0ZXJhdGVDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gSXRlcmF0aW9uIGluZGV4LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgQ29tcGFyZUZ1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHsqfSB4IC0gRmlyc3QgdmFsdWUgdG8gYmUgY29tcGFyZWQuXHJcbiAqIEBwYXJhbSB7Kn0geSAtIFNlY29uZCB2YWx1ZSB0byBiZSBjb21wYXJlZC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIEFyclxyXG4gKiBAZXh0ZW5kcyBTdXBlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheSA9IFtdXSAtIEFuIGFycmF5IHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtBcnJ9IEluc3RhbmNlIG9mIEFyci5cclxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5ldyBBcnIoWzEsIDJdKTtcclxuICovXHJcbmNsYXNzIEFyciBleHRlbmRzIFN1cGVyIHtcclxuICBjb25zdHJ1Y3RvcihhcnJheSA9IFtdKSB7XHJcbiAgICBzdXBlcih0b0FycmF5KGFycmF5IGluc3RhbmNlb2YgQXJyID8gYXJyYXkuJCA6IGFycmF5KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIEFyciMkXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gTWFkZSBhcnJheS5cclxuICAgICAqL1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjY29uY2F0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uKEFycmF5fEFycnwqKX0gdmFsdWVzIC0gQXJyYXlzIG9yIGFueSBvdGhlciB2YWx1ZXMgdG8gY29uY2F0IHRoZSBhcnJheSB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHtBcnJ9IE5ldyBpbnN0YW5jZSBvZiBBcnIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9jb25jYXRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbQXJyYXkjY29uY2F0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9jb25jYXR9LlxyXG4gICAqL1xyXG4gIGNvbmNhdCguLi52YWx1ZXMpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gdG9BcnJheSh0aGlzLiQsIHRydWUpO1xyXG5cclxuICAgIGl0ZXJhdG9yKGFyZ3VtZW50cywgKHZhbHVlKSA9PiB7XHJcbiAgICAgIHZhbHVlID0gbmV3IFN1cGVyKHZhbHVlKS4kO1xyXG5cclxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAhaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgaXRlcmF0b3IodmFsdWUsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoYXJyYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBBcnIjZmlyc3RcclxuICAgKiBAdHlwZSB7Kn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuZmlyc3Q7IC8vIDFcclxuICAgKiBuZXcgQXJyKFtdKS5maXJzdDsgICAgICAgIC8vIHVuZGVmaW5lZFxyXG4gICAqL1xyXG4gIGdldCBmaXJzdCgpIHtcclxuICAgIHJldHVybiB0aGlzLiRbMF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNpbmRleE9mXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBzZWFyY2guXHJcbiAgICogQHJldHVybnMge051bWJlcn0gSW5kZXggb2YgdGhlIGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBBbG1vc3QgdGhlIHNhbWUgYXMge0BsaW5rIFN1cGVyI2tleU9mfS4gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCBpZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kXHJcbiAgICogLTEgcmV0dXJuZWQgaW5zdGVhZCBvZiBudWxsIGFuZCBpZiBmb3VuZCBOdW1iZXIoa2V5KSByZXR1cm5lZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2YoMSk7ICAgICAgIC8vIDBcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuaW5kZXhPZignMScpOyAgICAgLy8gMFxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIDNdKS5pbmRleE9mKDMpOyAgICAgICAvLyAtMVxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIE5hTl0pLmluZGV4T2YoTmFOKTsgICAvLyAyXHJcbiAgICovXHJcbiAgaW5kZXhPZih2YWx1ZSkge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZih2YWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIGtleSA9PT0gbnVsbCA/IC0xIDogTnVtYmVyKGtleSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNpbmRleE9mU3RyaWN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBzZWFyY2guXHJcbiAgICogQHJldHVybnMge051bWJlcn0gSW5kZXggb2YgdGhlIGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBBbG1vc3QgdGhlIHNhbWUgYXMge0BsaW5rIFN1cGVyI2tleU9mU3RyaWN0fS4gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCBpZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kXHJcbiAgICogLTEgcmV0dXJuZWQgaW5zdGVhZCBvZiBudWxsIGFuZCBpZiBmb3VuZCBOdW1iZXIoa2V5KSByZXR1cm5lZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLmluZGV4T2ZTdHJpY3QoMSk7ICAgICAgIC8vIDBcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuaW5kZXhPZlN0cmljdCgnMScpOyAgICAgLy8gLTFcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkuaW5kZXhPZlN0cmljdCgzKTsgICAgICAgLy8gLTFcclxuICAgKiBuZXcgQXJyKFsxLCAyLCBOYU5dKS5pbmRleE9mU3RyaWN0KE5hTik7ICAgLy8gMlxyXG4gICAqL1xyXG4gIGluZGV4T2ZTdHJpY3QodmFsdWUpIHtcclxuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5T2ZTdHJpY3QodmFsdWUpO1xyXG5cclxuICAgIHJldHVybiBrZXkgPT09IG51bGwgPyAtMSA6IE51bWJlcihrZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjam9pblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcGFyYXRvciA9ICcsJ10gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gLSBTdHJpbmcgb2Ygam9pbmVkIGFycmF5LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvam9pblxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNqb2luXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9qb2lufS5cclxuICAgKi9cclxuICBqb2luKHNlcGFyYXRvcikge1xyXG4gICAgcmV0dXJuIHRoaXMuJC5qb2luLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgQXJyI2xhc3RcclxuICAgKiBAdHlwZSB7Kn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQXJyKFsxLCAyLCAzXSkubGFzdDsgLy8gM1xyXG4gICAqIG5ldyBBcnIoW10pLmxhc3Q7ICAgICAgICAvLyB1bmRlZmluZWRcclxuICAgKi9cclxuICBnZXQgbGFzdCgpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gdGhpcy4kO1xyXG5cclxuICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgQXJyI2xlbmd0aFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGVuZ3RoXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I2xlbmd0aF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGVuZ3RofS5cclxuICAgKi9cclxuICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNwb3BcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgZGVsZXRlZCBlbGVtZW50LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3BvcF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wfS5cclxuICAgKi9cclxuICBwb3AoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnBvcCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjcHVzaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLip9IHZhbHVlcyBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHRoaXMge0Fycn1cclxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wdXNoXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3B1c2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2h9XHJcbiAgICogYmVzaWRlcyByZXR1cm5pbmcgdGhpcy5cclxuICAgKi9cclxuICBwdXNoKC4uLnZhbHVlcykge1xyXG4gICAgdGhpcy4kLnB1c2guYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjcmFuZG9tXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHsqfSBSYW5kb20gaXRlbSBvZiB0aGUgYXJyYXkuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyByYW5kb20gaXRlbXMgb2YgdGhlIGFycmF5LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQXJyKFsxLCA1LCAzXSkucmFuZG9tKCk7IC8vIDNcclxuICAgKiBuZXcgQXJyKFsxLCA1LCAzXSkucmFuZG9tKCk7IC8vIDVcclxuICAgKi9cclxuICByYW5kb20oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kW3JhbmRvbSgwLCB0aGlzLiQubGVuZ3RoIC0gMSldO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjcmV2ZXJzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7QXJyfSBBIHdyYXAgb2YgdGhlIHJldmVyc2VkIGFycmF5LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmV2ZXJzZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtBcnJheSNyZXZlcnNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZXZlcnNlfS5cclxuICAgKi9cclxuICByZXZlcnNlKCkge1xyXG4gICAgdGhpcy4kLnJldmVyc2UoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3NoaWZ0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGRlbGV0ZWQgZWxlbWVudC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NoaWZ0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3NoaWZ0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zaGlmdH0uXHJcbiAgICovXHJcbiAgc2hpZnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnNoaWZ0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzaHVmZmxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtBcnJ9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBzaHVmZmxpbmcuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBBcnIoWzEsIDIsIDMsIDRdKS5zaHVmZmxlKCkuJDsgLy8gWzQsIDIsIDMsIDFdXHJcbiAgICogbmV3IEFycihbMSwgMiwgMywgNF0pLnNodWZmbGUoKS4kOyAvLyBbMSwgMywgNCwgMl1cclxuICAgKi9cclxuICBzaHVmZmxlKCkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4kLmxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgsIGFycmF5KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gaW5kZXggKyBNYXRoLmZsb29yKChsZW5ndGggLSBpbmRleCkgKiBNYXRoLnJhbmRvbSgpKTtcclxuXHJcbiAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcclxuICAgICAgYXJyYXlbcmFuZG9tSW5kZXhdID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3NsaWNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW4gPSAwXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZCA9IGFycmF5Lmxlbmd0aF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0Fycn0gQSB3cmFwIG9mIGEgc2xpY2VkIGFycmF5LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2VcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbQXJyYXkjc2xpY2Vde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlfS5cclxuICAgKi9cclxuICBzbGljZShiZWdpbiwgZW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy4kLnNsaWNlLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzb3J0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Q29tcGFyZUZ1bmN0aW9ufSBbY29tcGFyZUZ1bmN0aW9uXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0XHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0FycmF5I3NvcnRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnR9LlxyXG4gICAqL1xyXG4gIHNvcnQoY29tcGFyZUZ1bmN0aW9uKSB7XHJcbiAgICB2YWxpZGF0ZShbY29tcGFyZUZ1bmN0aW9uXSwgWydmdW5jdGlvbnx8ISddLCAnQXJyI3NvcnQnKTtcclxuXHJcbiAgICB0aGlzLiQuc29ydChjb21wYXJlRnVuY3Rpb24pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjc29ydEFzY1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7QXJyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYXNjZW5kaW5nIHNvcnRpbmcuIFB1dHMgbm9uLW51bWJlcnMgZmlyc3QsIHRoZW4gTmFOcywgdGhlbiBzb3J0ZWQgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQXJyKFtOYU4sIDEsIC03LCAnMTAwJywgNV0pLnNvcnRBc2MoKS4kOyAvLyBbJzEwMCcsIE5hTiwgLTcsIDEsIDVdXHJcbiAgICovXHJcbiAgc29ydEFzYygpIHtcclxuICAgIHJldHVybiB0aGlzLnNvcnQoYXNjKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3NvcnREZXNjXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtBcnJ9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZXNjZW5kaW5nIHNvcnRpbmcuIFB1dHMgc29ydGVkIHZhbHVlcyBmaXJzdCwgdGhlbiBOYU5zLCB0aGVuIG5vbi1udW1iZXJzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQXJyKFtOYU4sIDEsIC03LCAnMTAwJywgNV0pLnNvcnREZXNjKCkuJDsgLy8gWzUsIDEsIC03LCBOYU4sICcxMDAnXVxyXG4gICAqL1xyXG4gIHNvcnREZXNjKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc29ydCgoeSwgeCkgPT4gYXNjKHgsIHkpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQXJyI3NwbGljZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbGV0ZUNvdW50XSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0gey4uLip9IFtpdGVtc10gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0Fycn0gQSB3cmFwIG9mIHJldHVybiB2YWx1ZSBvZiAjc3BsaWNlIGNhbGwuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2VcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbQXJyYXkjc3BsaWNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2V9LlxyXG4gICAqL1xyXG4gIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XHJcbiAgICByZXR1cm4gbmV3IEFycih0aGlzLiQuc3BsaWNlLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEFyciNzdHJpbmdcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gQ29uY2F0ZW5hdGVkIGFycmF5LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBhcnJheS5qb2luKCcnKS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEFycihbMSwgMiwgM10pLnN0cmluZygpOyAvLyAnMTIzJ1xyXG4gICAqL1xyXG4gIHN0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLmpvaW4oJycpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBBcnIjdW5zaGlmdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtBcnJ9IFJldHVybnMgdGhpcy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbQXJyYXkjdW5zaGlmdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvdW5zaGlmdH1cclxuICAgKiBiZXNpZGVzIHJldHVybmluZyB0aGlzLlxyXG4gICAqL1xyXG4gIHVuc2hpZnQoLi4udmFsdWVzKSB7XHJcbiAgICB0aGlzLiQudW5zaGlmdC5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKEFyci5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0FycidcclxufSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGFzY1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHggLSBGaXJzdCB2YWx1ZSB0byBiZSBjb21wYXJlZC5cclxuICogQHBhcmFtIHsqfSB5IC0gU2Vjb25kIHZhbHVlIHRvIGJlIGNvbXBhcmVkLlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBXaGVyZSB0byBwdXQgdGhlIGZpcnN0IGVsZW1lbnQ6IGJlZm9yZSBvciBhZnRlci5cclxuICovXHJcbmZ1bmN0aW9uIGFzYyh4LCB5KSB7XHJcbiAgaWYgKCFpc051bWJlcih4KSAmJiAhaXNOdW1iZXIoeSkpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpc051bWJlcih4KSkge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpc051bWJlcih5KSkge1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNOYU4oeCkgJiYgaXNOYU4oeSkpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTmFOKHgpKSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNOYU4oeSkpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHggLSB5O1xyXG59XHJcblxyXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XHJcbiAgY2hlY2s6IGlzQXJyYXlMaWtlLFxyXG4gIGNsczogQXJyXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBhcnJheVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgLSBMZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5Q2FsbGJhY2t9IFtjYWxsYmFja10gLSBJZiBpdCdzIHByZXNlbnQgaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb25cclxuICogdGhhdCByZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgaXMgcHVzaGVkIHRvIHRoZSBuZXcgYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtBcnJ9IE5ldyBpbnN0YW5jZSBvZiBBcnIuXHJcbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBhcnJheSBmcm9tIHRoZSBsZW5ndGggdXNpbmcgb3B0aW9uYWwgY2FsbGJhY2suXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGFycmF5KDMpLiQ7ICAgICAgICAgICAgICAgLy8gWzAsIDEsIDJdXHJcbiAqIGFycmF5KDMsIChpKSA9PiBpICogMikuJDsgLy8gWzAsIDIsIDRdXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheShudW1iZXIsIGNhbGxiYWNrKSB7XHJcbiAgdmFsaWRhdGUoW251bWJlciwgY2FsbGJhY2tdLCBbWydpbnRMaWtlJywgJz49MCddLCAnZnVuY3Rpb258fCEnXSwgJ2FycmF5Jyk7XHJcblxyXG4gIGNvbnN0IGFycmF5ID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcclxuICAgIGFycmF5LnB1c2goY2FsbGJhY2sgPyBjYWxsYmFjayhpKSA6IGkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBBcnIoYXJyYXkpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGl0ZXJhdGVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIC0gTnVtYmVyIG9mIGl0ZXJhdGlvbnMuXHJcbiAqIEBwYXJhbSB7SXRlcmF0ZUNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggaXRlcmF0aW9uIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleC5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHJlcGxhY2luZyBmb3IgKC4uLikgY29uc3RydWN0aW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpdGVyYXRlKCk7XHJcbiAqL1xyXG5mdW5jdGlvbiBpdGVyYXRlKG51bWJlciwgY2FsbGJhY2spIHtcclxuICB2YWxpZGF0ZShbbnVtYmVyLCBjYWxsYmFja10sIFtbJ2ludExpa2UnLCAnPj0wJ10sICdmdW5jdGlvbiddLCAnaXRlcmF0ZScpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlcjsgaSsrKSB7XHJcbiAgICBjYWxsYmFjayhpKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IEFyciwgYXJyYXksIGl0ZXJhdGUgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgQmxvYk9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgQmxvYk9iamVjdCBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xyXG5pbXBvcnQgeyBQcm9taXNlIH0gZnJvbSAnLi9Qcm9taXNlJztcclxuaW1wb3J0IHsgY29uc3RydWN0b3JzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQge1xyXG4gIGlzQXJyYXksIGlzRnVuY3Rpb24sXHJcbiAgdG9TdHJpbmdUYWcsIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllc1xyXG59IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge3sgYnVmZmVyOiBTdHJpbmcsIGJpbmFyeTogU3RyaW5nLCBkYXRhVVJMOiBTdHJpbmcsIHRleHQ6IFN0cmluZyB9fSBtZXRob2RzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBMaXN0IG9mIHJlYWQgYmxvYiBtZXRob2RzLlxyXG4gKi9cclxuY29uc3QgbWV0aG9kcyA9IHtcclxuICBidWZmZXI6ICdBcnJheUJ1ZmZlcicsXHJcbiAgYmluYXJ5OiAnQmluYXJ5U3RyaW5nJyxcclxuICBkYXRhVVJMOiAnRGF0YVVSTCcsXHJcbiAgdGV4dDogJ1RleHQnXHJcbn07XHJcbmNvbnN0IHsgVVJMIH0gPSBnbG9iYWw7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeygnYnVmZmVyJ3wnYmluYXJ5J3wnZGF0YVVSTCd8J3RleHQnKX0gUmVhZEJsb2JNZXRob2RcclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRW51bSB0eXBlIG9mIHJlYWQgYmxvYiBtZXRob2RzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fEJsb2J8U3RyaW5nfSBCbG9iUGFydHNcclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gQWxsb3dlZCBibG9iIHBhcnRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgUmVhZGVyRXZlbnRMaXN0ZW5lclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBGaXJlZCBldmVudC5cclxuICogQHBhcmFtIHtGaWxlUmVhZGVyfSByZWFkZXIgLSBGaWxlUmVhZGVyLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgQmxvYk9iamVjdFxyXG4gKiBAZXh0ZW5kcyBTdXBlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7QmxvYn0gYmxvYiAtIEJsb2IgdG8gd3JhcC5cclxuICogQHJldHVybnMge0Jsb2JPYmplY3R9IEluc3RhbmNlIG9mIEJsb2JPYmplY3QuXHJcbiAqIEBkZXNjcmlwdGlvbiBXcmFwIG9mIGEgYmxvYi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogbmV3IEJsb2JPYmplY3QobmV3IEJsb2IoWyd7XCJmb29cIjpcImJhclwifSddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSk7XHJcbiAqL1xyXG5jbGFzcyBCbG9iT2JqZWN0IGV4dGVuZHMgU3VwZXIge1xyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIgQmxvYk9iamVjdCMkXHJcbiAgICogQHR5cGUge0Jsb2J9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hbCBCbG9iLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEJsb2JPYmplY3QjZGF0YVVSTFxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGRhdGFVUkwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJsb2IuXHJcbiAgICovXHJcbiAgZ2V0IGRhdGFVUkwoKSB7XHJcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLiQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBCbG9iT2JqZWN0I3JlYWRBc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1JlYWRCbG9iTWV0aG9kfSBtZXRob2QgLSBNZXRob2QgdGhhdCBpcyB1c2VkIGZvciByZWFkaW5nIGZyb20gYmxvYi5cclxuICAgKiBAcGFyYW0ge1JlYWRlckV2ZW50TGlzdGVuZXJ9IFtwcm9ncmVzc10gLSBQcm9ncmVzcyBsaXN0ZW5lci5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGNvdWxkIGJlIGFib3J0ZWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcmVhZGluZyBmcm9tIGJsb2JzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQmxvYk9iamVjdChuZXcgQmxvYihbJ3tcImZvb1wiOlwiYmFyXCJ9J10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pKVxyXG4gICAqICAgLnJlYWRBcygndGV4dCcpXHJcbiAgICogICAudGhlbigodmFsdWUpID0+IHtcclxuICAgKiAgICAgY29uc29sZS5sb2codmFsdWUpOyAvLyAne1wiZm9vXCI6XCJiYXJcIn0nXHJcbiAgICogICB9KTtcclxuICAgKi9cclxuICByZWFkQXMobWV0aG9kLCBwcm9ncmVzcykge1xyXG4gICAgaWYgKCFtZXRob2RzW21ldGhvZF0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCcxc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgZm9sbG93aW5nIHZhbHVlczogYnVmZmVyLCBiaW5hcnksIGRhdGFVUkwsIHRleHQnKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgIGxldCB0b1JlamVjdDtcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihwcm9ncmVzcykpIHtcclxuICAgICAgcmVhZGVyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHByb2dyZXNzKGUsIHRoaXMpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRvUmVqZWN0ID0gcmVqZWN0O1xyXG5cclxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gICAgICAgIGlmIChyZWFkZXIpIHtcclxuICAgICAgICAgIHJlamVjdCh0YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gICAgICAgIHJlc29sdmUodGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZWFkZXJbYHJlYWRBcyR7IG1ldGhvZHNbbWV0aG9kXSB9YF0odGhpcy4kKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHByb21pc2UuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcclxuICAgICAgdG9SZWplY3QobmV3IEVycm9yKCdSZWFkaW5nIHdhcyBhYm9ydGVkJykpO1xyXG5cclxuICAgICAgcmVhZGVyLmFib3J0KCk7XHJcblxyXG4gICAgICByZWFkZXIgPSBudWxsO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBCbG9iT2JqZWN0I3NhdmVBc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gTmFtZSB0aGF0IGlzIHVzZWQgZm9yIHNhdmluZyBmaWxlLlxyXG4gICAqIEByZXR1cm5zIHtCbG9iT2JqZWN0fSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2F2aW5nIGJsb2JzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgQmxvYk9iamVjdChuZXcgQmxvYihbJ3tcImZvb1wiOlwiYmFyXCJ9J10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pKVxyXG4gICAqICAgLnNhdmVBcygnYmxvYi5qc29uJyk7XHJcbiAgICovXHJcbiAgc2F2ZUFzKG5hbWUgPSAnZG93bmxvYWQnKSB7XHJcbiAgICBjb25zdCBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcblxyXG4gICAgYW5jaG9yLmhyZWYgPSB0aGlzLmRhdGFVUkw7XHJcbiAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIG5hbWUpO1xyXG4gICAgYW5jaG9yLmNsaWNrKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKEJsb2JPYmplY3QucHJvdG90eXBlLCB7XHJcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdCbG9iT2JqZWN0J1xyXG59KTtcclxuXHJcbmNvbnN0cnVjdG9yc1sxXS5wdXNoKHtcclxuICBjaGVjazogKGJsb2IpID0+IC9eKEJsb2J8RmlsZSkkLy50ZXN0KHRvU3RyaW5nVGFnKGJsb2IpKSxcclxuICBjbHM6IEJsb2JPYmplY3RcclxufSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGJsb2JcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyhCbG9iUGFydHNbXXxCbG9iUGFydHMpfSBibG9iUGFydHMgLSBCbG9iIHBhcnRzIHRoYXQgYXJlIHBhc3NlZCB0b1xyXG4gKiBbQmxvYl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYn0gY29uc3RydWN0b3IuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0b1xyXG4gKiBbQmxvYl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYn0gY29uc3RydWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCbG9iT2JqZWN0fSBOZXcgaW5zdGFuY2Ugb2YgQmxvYk9iamVjdC5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBibG9icyBub3QgaW52b2x2aW5nIEJsb2JPYmplY3QgYW5kIEJsb2IgY29uc3RydWN0b3JzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmxvYihibG9iUGFydHMsIG9wdGlvbnMgPSB7fSkge1xyXG4gIGlmICghaXNBcnJheShibG9iUGFydHMpKSB7XHJcbiAgICBibG9iUGFydHMgPSBbYmxvYlBhcnRzXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgQmxvYk9iamVjdChuZXcgQmxvYihibG9iUGFydHMsIG9wdGlvbnMpKTtcclxufVxyXG5cclxuZXhwb3J0IHsgQmxvYk9iamVjdCwgYmxvYiB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBTdHJcclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIFN0ciBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBEIH0gZnJvbSAnLi9EJztcclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcclxuaW1wb3J0IHsgY29uc3RydWN0b3JzLCByZWdleHBTcGVjaWFsQ2hhcmFjdGVycyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBpc0Z1bmN0aW9uLCBpc051bWJlckxpa2UsIGlzT2JqZWN0LCBpc1N0cmluZyxcclxuICB2YWxpZGF0ZSwgU3ltYm9sLCBkZWZpbmVQcm9wZXJ0aWVzLCBpdGVyYXRlXHJcbn0gZnJvbSAnLi9oZWxwZXJzJztcclxuXHJcbmNvbnN0IGh0bWxTcGVjaWFscyA9IHtcclxuICAnJic6ICcmYW1wOycsXHJcbiAgJzwnOiAnJmx0OycsXHJcbiAgJz4nOiAnJmd0OydcclxufTtcclxuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxyXG4gIG5ldyBTdXBlcihyZWdleHBTcGVjaWFsQ2hhcmFjdGVycylcclxuICAgIC53b3JkKCh4KSA9PiBgXFxcXCR7IHggfXxgKVxyXG4gICAgLnJlcGxhY2UoL1xcfCQvLCAnJyksXHJcbiAgJ2cnXHJcbik7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFN0clxyXG4gKiBAZXh0ZW5kcyBTdXBlclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RyaW5nID0gJyddIC0gQSBzdHJpbmcgdG8gd3JhcC5cclxuICogQHJldHVybnMge1N0cn0gSW5zdGFuY2Ugb2YgU3RyLlxyXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhIHN0cmluZy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgcyA9IG5ldyBOdW0oJzEnKTtcclxuICovXHJcbmNsYXNzIFN0ciBleHRlbmRzIFN1cGVyIHtcclxuICBjb25zdHJ1Y3RvcihzdHJpbmcgPSAnJykge1xyXG4gICAgc3VwZXIoYCR7IHN0cmluZyB9YCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIFN0ciMkXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWdpbmFsIHN0cmluZy5cclxuICAgICAqL1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjY2FwaXRhbGl6ZUZpcnN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IENhcGl0YWxpemVkIHN0cmluZy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGNhcGl0YWxpemluZyB0aGUgZmlyc3Qgc3ltYm9sLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdmb28nKS5jYXBpdGFsaXplRmlyc3QoKS4kOyAvLyAnRm9vJ1xyXG4gICAqL1xyXG4gIGNhcGl0YWxpemVGaXJzdCgpIHtcclxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuJDtcclxuXHJcbiAgICByZXR1cm4gbmV3IFN0cihzdHJpbmcuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNlbmRzV2l0aFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb24gPSBzdHJpbmcubGVuZ3RoXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHN0cmluZyBlbmRzIHdpdGggdGhlIGFyZ3VtZW50IHN0cmluZy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjZW5kc1dpdGhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aH0uXHJcbiAgICovXHJcbiAgZW5kc1dpdGgoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgIHBvc2l0aW9uID0gdGhpcy4kLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAuc2xpY2UoMCwgcG9zaXRpb24pXHJcbiAgICAgIC5yZXZlcnQoKVxyXG4gICAgICAuc3RhcnRzV2l0aChuZXcgU3RyKHNlYXJjaFN0cmluZykucmV2ZXJ0KCkuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNlc2NhcGVIVE1MXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZHMgZXNjYXBpbmcgXCImXCIsIFwiPFwiIGFuZCBcIj5cIiBzeW1ib2xzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdcIjEgPCAyXCIgJiBcIjcgPiA0XCIgYXJlIHRydWUgZXhwcmVzc2lvbnMuJykuZXNjYXBlSFRNTCgpLiQ7XHJcbiAgICogLy8gJ1wiMSAmbHQ7IDJcIiAmYW1wIFwiNyAmZ3Q7IDJcIiBhcmUgdHJ1ZSBleHByZXNzaW9ucy4nXHJcbiAgICovXHJcbiAgZXNjYXBlSFRNTCgpIHtcclxuICAgIGxldCBzdHJpbmcgPSB0aGlzLiQ7XHJcblxyXG4gICAgaXRlcmF0ZShodG1sU3BlY2lhbHMsIChlc2NhcGVkLCBzeW1ib2wpID0+IHtcclxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChzeW1ib2wsICdnJyksIGVzY2FwZWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBTdHIoc3RyaW5nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI2VzY2FwZVJlZ0V4cFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZXNjYXBpbmcgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignKDIxMy45OCAtIFtdIHt9KScpLmVzY2FwZVJlZ0V4cCgpLiQ7IC8vICdcXCgyMTNcXC45OCBcXC0gXFxbXFxdIFxce1xcfVxcKSdcclxuICAgKi9cclxuICBlc2NhcGVSZWdFeHAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNpblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayB0aGUgc3RyaW5nIGFzIGEgcHJvcGVydHkgaW4uXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGl0IGlzIGluIHRoZSBvYmplY3Qgb3Igbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHN0cmluZyBpbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ2EnKS5pbih7IGE6IDEgfSk7IC8vIHRydWVcclxuICAgKiBuZXcgU3RyKCd0b0ZpeGVkJykuaW4oMSk7ICAvLyBmYWxzZVxyXG4gICAqIG5ldyBTdHIoJ2EnKS5pbihudWxsKTsgICAgIC8vIGZhbHNlXHJcbiAgICovXHJcbiAgaW4ob2JqZWN0KSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLiQgaW4gb2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjaW5kZXhPZlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoVmFsdWUgLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXggPSAwXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBGb3VuZCBpbmRleCBvciAtMS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmRleE9mXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNpbmRleE9mXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5kZXhPZn0uXHJcbiAgICovXHJcbiAgaW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLmluZGV4T2YuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjbGFzdEluZGV4T2ZcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFZhbHVlIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4ID0gc3RyaW5nLmxlbmd0aF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gRm91bmQgaW5kZXggb3IgLTEuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbGFzdEluZGV4T2ZcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI2xhc3RJbmRleE9mXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbGFzdEluZGV4T2Z9LlxyXG4gICAqL1xyXG4gIGxhc3RJbmRleE9mKHNlYXJjaFZhbHVlLCBmcm9tSW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLiQubGFzdEluZGV4T2YuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciBTdHIjbGVuZ3RoXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbGVuZ3RoXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNsZW5ndGhde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9sZW5ndGh9LlxyXG4gICAqL1xyXG4gIGdldCBsZW5ndGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI21hdGNoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtBcnJ8U3VwZXJ9IEQtV3JhcCBvZiBmb3VuZCBtYXRjaC5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjbWF0Y2hde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaH0uXHJcbiAgICovXHJcbiAgbWF0Y2gocmVnZXhwKSB7XHJcbiAgICByZXR1cm4gRCh0aGlzLiQubWF0Y2guYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3JlcGVhdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHRpbWVzIC0gVGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3JlcGVhdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJzEyMycpLnJlcGVhdCgyKS4kOyAvLyAnMTIzMTIzJ1xyXG4gICAqIG5ldyBTdHIoJzEyMycpLnJlcGVhdCgwKS4kOyAvLyAnJ1xyXG4gICAqL1xyXG4gIHJlcGVhdCh0aW1lcykge1xyXG4gICAgdmFsaWRhdGUoW3RpbWVzXSwgW1snaW50TGlrZScsICc+PTAnXV0sICdTdHIjcmVwZWF0Jyk7XHJcblxyXG4gICAgdGltZXMgPSArdGltZXM7XHJcblxyXG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy4kO1xyXG5cclxuICAgIGxldCBzID0gJyc7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lczsgaSsrKSB7XHJcbiAgICAgIHMgKz0gc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgU3RyKHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjcmVwbGFjZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHJlZ2V4cCAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW3JlcGxhY2VyID0gJyddIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjcmVwbGFjZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGxhY2V9XHJcbiAgICogYmVzaWRlcyB0aGF0IHJlcGxhY2VyIGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgJycuXHJcbiAgICovXHJcbiAgcmVwbGFjZShyZWdleHAsIHJlcGxhY2VyID0gJycpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC5yZXBsYWNlKHJlZ2V4cCwgcmVwbGFjZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3JlcGxhY2VTdHJpbmdcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIFN0cmluZyB0byByZXBsYWNlLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwbGFjZXIgPSAnJ10gLSBTdHJpbmcgdG8gcmVwbGFjZSB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2xvYmFsIHN0cmluZyByZXBsYWNlaW5nLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCcxMjMxMjMnKS5yZXBsYWNlU3RyaW5nKCcxJywgJzQnKS4kOyAvLyAnNDIzNDIzJ1xyXG4gICAqIG5ldyBTdHIoJzEyMzEyMycpLnJlcGxhY2VTdHJpbmcoJzEnKS4kOyAgICAgIC8vICcyMzIzJ1xyXG4gICAqL1xyXG4gIHJlcGxhY2VTdHJpbmcoc3RyaW5nLCByZXBsYWNlciA9ICcnKSB7XHJcbiAgICBzdHJpbmcgPSBuZXcgU3VwZXIoc3RyaW5nKS4kO1xyXG5cclxuICAgIHZhbGlkYXRlKFtzdHJpbmddLCBbJ3N0cmluZyddLCAnU3RyI3JlcGxhY2VTdHJpbmcnKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQuc3BsaXQoc3RyaW5nKS5qb2luKHJlcGxhY2VyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNyZXZlcnRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIHN0cmluZy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciByZXZlcnRpbmcgYSBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJzEyMzQnKS5yZXZlcnQoKS4kOyAvLyAnNDMyMSdcclxuICAgKi9cclxuICByZXZlcnQoKSB7XHJcbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLiQ7XHJcbiAgICBsZXQgc3RyID0gJyc7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IHN0cmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBzdHIgKz0gc3RyaW5nW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgU3RyKHN0cik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNzZWFyY2hcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cCAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBJbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2gsIGlmIGZvdW5kLCBhbmQgLTEgaWYgbm90LlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NlYXJjaFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjc2VhcmNoXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc2VhcmNofS5cclxuICAgKi9cclxuICBzZWFyY2gocmVnZXhwKSB7XHJcbiAgICB2YWxpZGF0ZShbcmVnZXhwXSwgWydyZWdleHAnXSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJC5zZWFyY2guYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjc2xpY2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtiZWdpblNsaWNlID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRTbGljZSA9IHN0cmluZy5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc2xpY2VcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3NsaWNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc2xpY2V9LlxyXG4gICAqL1xyXG4gIHNsaWNlKGJlZ2luU2xpY2UsIGVuZFNsaWNlKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQuc2xpY2UuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3NwbGl0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gW3NlcGFyYXRvcl0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0FycnxTdXBlcn0gRC1XcmFwIG9mIHRoZSBhcnJheS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zcGxpdFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjc3BsaXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zcGxpdH0uXHJcbiAgICovXHJcbiAgc3BsaXQoc2VwYXJhdG9yKSB7XHJcbiAgICByZXR1cm4gRCh0aGlzLiQuc3BsaXQuYXBwbHkodGhpcy4kLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3N0YXJ0c1dpdGhcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZyAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBhcmd1bWVudCBzdHJpbmcuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjc3RhcnRzV2l0aF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGh9LlxyXG4gICAqL1xyXG4gIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLiQuaW5kZXhPZi5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cykgPT09IHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjc3Vic3RyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQgPSAwXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aCA9IHN0cmluZy5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNzdWJzdHJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdWJzdHJ9LlxyXG4gICAqL1xyXG4gIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLiQuc3Vic3RyLmFwcGx5KHRoaXMuJCwgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciNzdWJzdHJpbmdcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleFN0YXJ0ID0gMF0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleEVuZCA9IHN0cmluZy5sZW5ndGhdIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyaW5nXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyNzdWJzdHJpbmdde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdWJzdHJpbmd9LlxyXG4gICAqL1xyXG4gIHN1YnN0cmluZyhpbmRleFN0YXJ0LCBpbmRleEVuZCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnN1YnN0cmluZy5hcHBseSh0aGlzLiQsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdG9DYW1lbENhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBmb2xsb3dpbmcgcmVnZXhwIC9cXHNcXC1fXFwuLyBtYWtpbmcgdGhlIHN0cmluZyBjYW1lbCBjYXNlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignc3BpbmFsLWNhc2UnKS50b0NhbWVsQ2FzZSgpLiQ7ICAvLyAnc3BpbmFsQ2FzZSdcclxuICAgKiBuZXcgU3RyKCdfc25ha2VfY2FzZV8nKS50b0NhbWVsQ2FzZSgpLiQ7IC8vICdzbmFrZUNhc2UnXHJcbiAgICovXHJcbiAgdG9DYW1lbENhc2UoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcclxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICctJylcclxuICAgICAgLnJlcGxhY2UoLy1bXi1dL2csIChtYXRjaCkgPT4gbWF0Y2hbMV0udG9VcHBlckNhc2UoKSlcclxuICAgICAgLnJlcGxhY2UoL15bXFxTXS8sIChtYXRjaCkgPT4gbWF0Y2gudG9Mb3dlckNhc2UoKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0b0NhcGl0YWxDYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFwtX1xcLi8gbWFraW5nIHRoZSBzdHJpbmcgY2FwaXRhbCBsZXR0ZXIgY2FzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ3NwaW5hbC1jYXNlJykudG9DYXBpdGFsQ2FzZSgpLiQ7ICAvLyAnU3BpbmFsIENhc2UnXHJcbiAgICogbmV3IFN0cignX3NuYWtlX2Nhc2VfJykudG9DYXBpdGFsQ2FzZSgpLiQ7IC8vICdTbmFrZSBDYXNlJ1xyXG4gICAqL1xyXG4gIHRvQ2FwaXRhbENhc2UoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcclxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICcgJylcclxuICAgICAgLnJlcGxhY2UoL1tcXFNdL2csIChtYXRjaCkgPT4gKFxyXG4gICAgICAgIG1hdGNoLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoID8gbWF0Y2ggOiBgICR7IG1hdGNoIH1gXHJcbiAgICAgICkpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHNbXFxTXS9nLCAobWF0Y2gpID0+IG1hdGNoLnRvVXBwZXJDYXNlKCkpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcclxuICAgICAgLnJlcGxhY2UoL15cXHMvLCAnJylcclxuICAgICAgLnJlcGxhY2UoL15bXFxTXS8sIChtYXRjaCkgPT4gbWF0Y2gudG9VcHBlckNhc2UoKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0b0RvdENhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBmb2xsb3dpbmcgcmVnZXhwIC9cXC1fXFwuLyBtYWtpbmcgdGhlIHN0cmluZyBkb3QgY2FzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ3NwaW5hbC1jYXNlJykudG9Eb3RDYXNlKCkuJDsgIC8vICdzcGluYWwuY2FzZSdcclxuICAgKiBuZXcgU3RyKCdfc25ha2VfY2FzZV8nKS50b0RvdENhc2UoKS4kOyAvLyAnc25ha2UuY2FzZSdcclxuICAgKi9cclxuICB0b0RvdENhc2UoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcclxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICcuJylcclxuICAgICAgLnJlcGxhY2UoL1teLl0vZywgKG1hdGNoKSA9PiAoXHJcbiAgICAgICAgbWF0Y2gudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2ggPyBtYXRjaCA6IGAuJHsgbWF0Y2ggfWBcclxuICAgICAgKSlcclxuICAgICAgLnJlcGxhY2UoL1xcLisvZywgJy4nKVxyXG4gICAgICAucmVwbGFjZSgvXlxcLi8sICcnKVxyXG4gICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RvSHlwaGVuQ2FzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGZvbGxvd2luZyByZWdleHAgL1xcc1xcLV9cXC4vIG1ha2luZyB0aGUgc3RyaW5nIGNhbWVsIGNhc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgU3RyKCdjYW1lbENhc2UnKS50b1NwaW5hbENhc2UoKS4kOyAgICAvLyAnY2FtZWwtY2FzZSdcclxuICAgKiBuZXcgU3RyKCdfc25ha2VfY2FzZV8nKS50b1NwaW5hbENhc2UoKS4kOyAvLyAnc25ha2UtY2FzZSdcclxuICAgKi9cclxuICB0b0h5cGhlbkNhc2UoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcclxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICctJylcclxuICAgICAgLnJlcGxhY2UoL1teLV0vZywgKG1hdGNoKSA9PiAoXHJcbiAgICAgICAgbWF0Y2gudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2ggPyBtYXRjaCA6IGAtJHsgbWF0Y2ggfWBcclxuICAgICAgKSlcclxuICAgICAgLnJlcGxhY2UoLy0rL2csICctJylcclxuICAgICAgLnJlcGxhY2UoL14tLywgJycpXHJcbiAgICAgIC50b0xvd2VyQ2FzZSgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdG9Mb3dlckNhc2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90b0xvd2VyQ2FzZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtTdHJpbmcjdG9Mb3dlckNhc2Vde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90b0xvd2VyQ2FzZX0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ1VQUEVSLUNBU0UnKS50b0xvd2VyQ2FzZSgpLiQ7ICAvLyAndXBwZXItY2FzZSdcclxuICAgKi9cclxuICB0b0xvd2VyQ2FzZSgpIHtcclxuICAgIHJldHVybiBuZXcgU3RyKHRoaXMuJC50b0xvd2VyQ2FzZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RvU25ha2VDYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFxzXFwtXFwuLyBtYWtpbmcgdGhlIHN0cmluZyBzcGluYWwgY2FzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ3NwaW5hbC1jYXNlJykudG9TbmFrZUNhc2UoKS4kOyAvLyAnc3BpbmFsX2Nhc2UnXHJcbiAgICogbmV3IFN0cignY2FtZWxDYXNlJykudG9TbmFrZUNhc2UoKS4kOyAgIC8vICdjYW1lbF9jYXNlJ1xyXG4gICAqL1xyXG4gIHRvU25ha2VDYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodHJpbSh0aGlzLiQpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFxzXFwtXy5dKy9nLCAnXycpXHJcbiAgICAgIC5yZXBsYWNlKC9bXl9dL2csIChtYXRjaCkgPT4gKFxyXG4gICAgICAgIG1hdGNoLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoID8gbWF0Y2ggOiBgXyR7IG1hdGNoIH1gXHJcbiAgICAgICkpXHJcbiAgICAgIC5yZXBsYWNlKC9fKy9nLCAnXycpXHJcbiAgICAgIC5yZXBsYWNlKC9eXy8sICcnKVxyXG4gICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RvU3BhY2VDYXNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZm9sbG93aW5nIHJlZ2V4cCAvXFwtX1xcLi8gbWFraW5nIHRoZSBzdHJpbmcgc3BhY2UgY2FzZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBTdHIoJ3NwaW5hbC1jYXNlJykudG9TcGFjZUNhc2UoKS4kOyAgLy8gJ3NwaW5hbCBjYXNlJ1xyXG4gICAqIG5ldyBTdHIoJ19zbmFrZV9jYXNlXycpLnRvU3BhY2VDYXNlKCkuJDsgLy8gJ3NuYWtlIGNhc2UnXHJcbiAgICovXHJcbiAgdG9TcGFjZUNhc2UoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cih0cmltKHRoaXMuJClcclxuICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fLl0rL2csICcgJylcclxuICAgICAgLnJlcGxhY2UoL1tcXFNdL2csIChtYXRjaCkgPT4gKFxyXG4gICAgICAgIG1hdGNoLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoID8gbWF0Y2ggOiBgICR7IG1hdGNoIH1gXHJcbiAgICAgICkpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcclxuICAgICAgLnJlcGxhY2UoL15cXHMvLCAnJylcclxuICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLiQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0b1VwcGVyQ2FzZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RvVXBwZXJDYXNlXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RvVXBwZXJDYXNlfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IFN0cignbG93ZXItY2FzZScpLnRvVXBwZXJDYXNlKCkuJDsgIC8vICdMT1dFUi1DQVNFJ1xyXG4gICAqL1xyXG4gIHRvVXBwZXJDYXNlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnRvVXBwZXJDYXNlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBTdHIjdHJpbVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7U3RyfSBOZXcgaW5zdGFuY2Ugb2YgU3RyLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW1cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3RyaW1de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltfS5cclxuICAgKi9cclxuICB0cmltKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnJlcGxhY2UoL15bXFxzXFx1ZmVmZlxcdTAwYTBdK3xbXFxzXFx1ZmVmZlxcdTAwYTBdKyQvZywgJycpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgU3RyI3RyaW1MZWZ0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtTdHJ9IE5ldyBpbnN0YW5jZSBvZiBTdHIuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbUxlZnRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3RyaW1MZWZ0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbUxlZnR9LlxyXG4gICAqL1xyXG4gIHRyaW1MZWZ0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnJlcGxhY2UoL15bXFxzXFx1ZmVmZlxcdTAwYTBdKy8sICcnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFN0ciN0cmltUmlnaHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0cn0gTmV3IGluc3RhbmNlIG9mIFN0ci5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltUmlnaHRcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbU3RyaW5nI3RyaW1SaWdodF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW1SaWdodH0uXHJcbiAgICovXHJcbiAgdHJpbVJpZ2h0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHIodGhpcy4kLnJlcGxhY2UoL1tcXHNcXHVmZWZmXFx1MDBhMF0rJC8sICcnKSk7XHJcbiAgfVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKFN0ci5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1N0cidcclxufSk7XHJcblxyXG5jb25zdHJ1Y3RvcnNbMl0ucHVzaCh7XHJcbiAgY2hlY2s6IGlzU3RyaW5nLFxyXG4gIGNsczogU3RyXHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcclxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL15bXFxzXFwtXy5dK3xbXFxzXFwtXy5dKyQvZywgJycpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIHBhcnNlSlNPTlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbanNvbiA9IG51bGxdIC0gU3RyaW5nIHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucy5cclxuICogQHBhcmFtIHtCb29sZWFufCp9IFtvcHRpb25zLm51bWJlcnNdIC0gSWYgaXQgaXMgbmVlZGVkIHRvIHBhcnNlIG51bWJlci1saWtlIHN0cmluZ3MgYXMgbnVtYmVycy5cclxuICogQHBhcmFtIHtCb29sZWFufCp9IFtvcHRpb25zLmRhdGVzXSAtIElmIGl0IGlzIG5lZWRlZCB0byBwYXJzZSBkYXRlLWxpa2Ugc3RyaW5nIGFzIGRhdGVzLlxyXG4gKiBEYXRlLWxpa2Ugc3RyaW5nIGlzIGNvbnNpZGVyZWQgdG8gbWF0Y2ggXlxcZFxcZFxcZFxcZC1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkXFxkXFxkWj8kXHJcbiAqIEBwYXJhbSB7SlNPTkNhbGxiYWNrfSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgdGhhdCBjYWxsZWQgb24gZXZlcnkgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7RFdyYXB9IEQtV3JhcCBvZiBmb3VuZCBtYXRjaC5cclxuICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgcGFyc2luZyBqc29uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBwYXJzZUpTT04oJ3sgXCJhXCI6IDEgfScpLiQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHsgYTogMSB9XHJcbiAqIHBhcnNlSlNPTigneyBcImFcIjogXCIxXCIgfScsIHsgbnVtYmVyczogdHJ1ZSB9KS4kOyAgICAgICAgICAgICAgICAgICAgICAvLyB7IG51bWJlcnM6IHRydWUgfVxyXG4gKiBwYXJzZUpTT04oJ3sgXCJhXCI6IFwiMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaXCIgfScsIHsgZGF0ZXM6IHRydWUgfSkuJDsgLy8geyBhOiBEYXRlIHsuLi59IH1cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSlNPTihqc29uID0gbnVsbCwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgIHJldHVybiBEKEpTT04ucGFyc2UoanNvbikpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcclxuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgIG9wdGlvbnMgPSB7fTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgbnVtYmVycywgZGF0ZXMgfSA9IG9wdGlvbnM7XHJcbiAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKGRhdGVzICYmIC9eXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGRcXGRcXGRaPyQvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmIChudW1iZXJzICYmIGlzTnVtYmVyTGlrZSh2YWx1ZSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdmFsdWU7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBEKHBhcnNlZCk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IFN0ciwgcGFyc2VKU09OIH07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvbWFya3VwVG9KU09OXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIG1hcmt1cFRvSlNPTiBtZXRob2QuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcclxuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi4vU3RyJztcclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XHJcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi4vU3dpdGNoZXInO1xyXG5pbXBvcnQgeyBodG1sQWxsb3dlZFRhZ1N5bWJvbHMsIGh0bWxBbGxvd2VkQXR0clN5bWJvbHMsIHZvaWRFbGVtZW50cyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gTWFya3VwRWxlbWVudFxyXG4gKiBAcHJvcGVydHkgeydjb21tZW50J3wndGV4dCd8J2VsZW1lbnQnfSB0eXBlIC0gVHlwZSBvZiB0aGUgbm9kZS5cclxuICogQHByb3BlcnR5IHtNYXJrdXBFbGVtZW50fSBwYXJlbnQgLSBUeXBlIG9mIHRoZSBub2RlLlxyXG4gKiBAcHJvcGVydHkge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBhdHRycyAtIE5vZGUgYXR0cmlidXRlc1xyXG4gKiBAcHJvcGVydHkge01hcmt1cEVsZW1lbnRbXX0gY2hpbGRyZW4gLSBOb2RlIGNoaWxkcmVuLlxyXG4gKi9cclxuXHJcbmNvbnN0IHN1Ym1pdFN0cmluZyA9ICdQbGVhc2UsIHN1Ym1pdCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZHdheW5lanMvZHdheW5lL2lzc3Vlcy4nO1xyXG5jb25zdCBOT0RFX1JFR0VYX1NFVCA9IG5ldyBTdXBlcih7XHJcbiAgJ3RhZy1vcGVuJzogbmV3IFJlZ0V4cChgPCgkeyBodG1sQWxsb3dlZFRhZ1N5bWJvbHMgfSlcXFxccypgLCAnaScpLFxyXG4gICd0YWctY2xvc2UnOiBjb25zdHJ1Y3RDbG9zZVRhZ1JlZ0V4cChodG1sQWxsb3dlZFRhZ1N5bWJvbHMpLFxyXG4gIGNvbW1lbnQ6IC88IS0tKCg/Oi1bXlxcLT5dfFteXFwtPl0pKD86LT9bXi1dKSpbXi1dP3wpLS0+L1xyXG59KTtcclxuY29uc3QgVEFHX09QRU5fQ0xPU0UgPSAvXihcXC8/KT4vO1xyXG4vLyBjb25zdCBBVFRSSUJVVEUgPSAvXihbXlxcdTAwMDAtXFx1MDAyMFxcc1wiJz5cXC89XSspKD86XFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInxbXlxcc1wiJ2A8Pj1dKykpP1xccyovO1xyXG5jb25zdCBBVFRSSUJVVEUgPSBuZXcgUmVnRXhwKGBeKCR7IGh0bWxBbGxvd2VkQXR0clN5bWJvbHMgfSkoPzpcXFxccyo9XFxcXHMqKCdbXiddKid8XCJbXlwiXSpcInxbXlxcXFxzXCInXFxgPD49XSspKT9cXFxccypgKTtcclxuY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbmNvbnN0IG5vZGVTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAoZWxlbSkgPT4gZWxlbSlcclxuICAuY2FzZSgndGFnLW9wZW4nLCAoZWxlbSwgbm9kZSkgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB2YWx1ZTogbmFtZSxcclxuICAgICAgc2VsZkNsb3NpbmdcclxuICAgIH0gPSBub2RlO1xyXG5cclxuICAgIG5vZGUgPSB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGF0dHJzOiBuZXcgU3VwZXIobm9kZS5hdHRycykubWFwKCh2YWx1ZSkgPT4gKFxyXG4gICAgICAgIHBhcnNlQ2hhcmFjdGVyRGF0YSh2YWx1ZSlcclxuICAgICAgKSkuJCxcclxuICAgICAgcGFyZW50OiBlbGVtLFxyXG4gICAgICBjaGlsZHJlbjogbmV3IEFycihbXSlcclxuICAgIH07XHJcblxyXG4gICAgZWxlbS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG5cclxuICAgIGlmICghc2VsZkNsb3NpbmcgJiYgdm9pZEVsZW1lbnRzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XHJcbiAgICAgIGVsZW0gPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtO1xyXG4gIH0pXHJcbiAgLmNhc2UoJ3RhZy1jbG9zZScsIChlbGVtLCBub2RlKSA9PiB7XHJcbiAgICBpZiAoZWxlbS5uYW1lID09PSBub2RlLnZhbHVlKSB7XHJcbiAgICAgIGVsZW0gPSBlbGVtLnBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbTtcclxuICB9KVxyXG4gIC5jYXNlKFsnY29tbWVudCcsICd0ZXh0J10sIChlbGVtLCBub2RlLCBjb2xsYXBzZVdoaXRlU3BhY2UsIHR5cGUpID0+IHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB7XHJcbiAgICAgIG5hbWU6IGAjJHsgdHlwZSB9YCxcclxuICAgICAgcGFyZW50OiBlbGVtLFxyXG4gICAgICB2YWx1ZTogbm9kZS52YWx1ZVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnICYmIGVsZW0ubmFtZSAhPT0gJ3NjcmlwdCcgJiYgZWxlbS5uYW1lICE9PSAnc3R5bGUnKSB7XHJcbiAgICAgIGVsZW1lbnQudmFsdWUgPSBwYXJzZUNoYXJhY3RlckRhdGEoZWxlbWVudC52YWx1ZSk7XHJcblxyXG4gICAgICBpZiAoY29sbGFwc2VXaGl0ZVNwYWNlKSB7XHJcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ldyBTdHIoZWxlbWVudC52YWx1ZSkudHJpbSgpLiQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbGxhcHNlV2hpdGVTcGFjZSB8fCAhL15cXHMqJC8udGVzdChlbGVtZW50LnZhbHVlKSkge1xyXG4gICAgICBlbGVtLmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW07XHJcbiAgfSk7XHJcbmNvbnN0IHJhd1RleHRTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCBmYWxzZSlcclxuICAuY2FzZShbJ3RpdGxlJywgJ3RleHRhcmVhJywgJ3N0eWxlJywgJ3NjcmlwdCddLCB0cnVlKTtcclxuXHJcbmNsYXNzIEludGVybmFsUGFyc2luZ0Vycm9yIHtcclxuICBjb25zdHJ1Y3RvcihpbmRleCkge1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUGFyc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIHR5cGUgPSAnUEFSU0lOR19FUlJPUic7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gbWFya3VwVG9KU09OXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrdXAgLSBNYXJrdXAgdG8gcGFyc2UgdG8gSlNPTi5cclxuICogQHBhcmFtIHtCb29sZWFufSBbY29sbGFwc2VXaGl0ZVNwYWNlID0gZmFsc2VdIC0gSWYgdGhlIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIGNvbGxhcHNlZC5cclxuICogQHJldHVybnMge0Fyci48TWFya3VwRWxlbWVudD59IE1hcmt1cCBlbGVtZW50cyBhcnJheS5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBwYXJzaW5nIGh0bWwgYW5kIHhtbCB0byBKU09OLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgKG1hcmt1cCwgY29sbGFwc2VXaGl0ZVNwYWNlKSA9PiB7XHJcbiAgY29sbGFwc2VXaGl0ZVNwYWNlID0gISFjb2xsYXBzZVdoaXRlU3BhY2U7XHJcblxyXG4gIGNvbnN0IGVsZW1lbnRzID0gbmV3IEFycihbXSk7XHJcbiAgY29uc3Qgc3RhcnRNYXJrdXAgPSBtYXJrdXA7XHJcbiAgbGV0IGZvdW5kO1xyXG4gIGxldCBnbG9iYWxJbmRleCA9IDA7XHJcbiAgbGV0IGVsZW0gPSB7XHJcbiAgICBuYW1lOiBudWxsLFxyXG4gICAgY2hpbGRyZW46IGVsZW1lbnRzXHJcbiAgfTtcclxuXHJcbiAgd2hpbGUgKG1hcmt1cC5sZW5ndGgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZvdW5kID0gZmluZChtYXJrdXAsIGVsZW0pO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEludGVybmFsUGFyc2luZ0Vycm9yKSkge1xyXG4gICAgICAgIHRocm93VW5leHBlY3RlZEVycm9yKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoYFBhcnNpbmcgZXJyb3IgbmVhciBpbmRleCAkeyBuZWFyU3RyaW5nKHN0YXJ0TWFya3VwLCBnbG9iYWxJbmRleCArIGVyci5pbmRleCkgfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgdHlwZSxcclxuICAgICAgYXR0cnMsXHJcbiAgICAgIHNlbGZDbG9zaW5nLFxyXG4gICAgICBpbmRleCxcclxuICAgICAgdmFsdWVcclxuICAgIH0gPSBmb3VuZDtcclxuXHJcbiAgICBnbG9iYWxJbmRleCArPSBpbmRleDtcclxuXHJcbiAgICBpZiAoIWluZGV4KSB7XHJcbiAgICAgIHRocm93VW5leHBlY3RlZEVycm9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgbm9kZSA9IHtcclxuICAgICAgdHlwZSxcclxuICAgICAgdmFsdWVcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICd0YWctb3BlbicpIHtcclxuICAgICAgbm9kZS5hdHRycyA9IGF0dHJzO1xyXG4gICAgICBub2RlLnNlbGZDbG9zaW5nID0gc2VsZkNsb3Npbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbSA9IG5vZGVTd2l0Y2hlcihub2RlLnR5cGUsIFtlbGVtLCBub2RlLCBjb2xsYXBzZVdoaXRlU3BhY2VdKTtcclxuXHJcbiAgICBtYXJrdXAgPSBtYXJrdXAuc2xpY2UoaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRzO1xyXG5cclxuICBmdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWRFcnJvcigpIHtcclxuICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoYFVuZXhwZWN0ZWQgcGFyc2luZyBlcnJvciBuZWFyIGluZGV4ICR7IG5lYXJTdHJpbmcoc3RhcnRNYXJrdXAsIGdsb2JhbEluZGV4KSB9LiAkeyBzdWJtaXRTdHJpbmcgfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGZpbmQobWFya3VwLCBlbGVtKSB7XHJcbiAgY29uc3QgeyBuYW1lIH0gPSBlbGVtO1xyXG4gIGxldCBtYXRjaGVzO1xyXG5cclxuICBpZiAocmF3VGV4dFN3aXRjaGVyKG5hbWUpKSB7XHJcbiAgICBtYXRjaGVzID0gbmV3IFN1cGVyKHtcclxuICAgICAgJ3RhZy1jbG9zZSc6IG1hcmt1cC5tYXRjaChjb25zdHJ1Y3RDbG9zZVRhZ1JlZ0V4cChuYW1lKSlcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtYXRjaGVzID0gTk9ERV9SRUdFWF9TRVQubWFwKChyZWdleCkgPT4gKFxyXG4gICAgICBtYXJrdXAubWF0Y2gocmVnZXgpXHJcbiAgICApKTtcclxuICB9XHJcblxyXG4gIGxldCBtYXRjaDtcclxuXHJcbiAgaWYgKFxyXG4gICAgbWF0Y2ggPSBtYXRjaGVzLmZpbmQoKG1hdGNoKSA9PiAoXHJcbiAgICAgIG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwXHJcbiAgICApKVxyXG4gICkge1xyXG4gICAgY29uc3QgcmV0dXJuaW5nID0ge1xyXG4gICAgICB0eXBlOiBtYXRjaC5rZXksXHJcbiAgICAgIGluZGV4OiBtYXRjaC52YWx1ZVswXS5sZW5ndGgsXHJcbiAgICAgIHZhbHVlOiBtYXRjaC52YWx1ZVsxXVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGF0dHJzID0ge307XHJcblxyXG4gICAgaWYgKG1hdGNoLmtleSA9PT0gJ3RhZy1vcGVuJykge1xyXG4gICAgICBjb25zdCBzdGFydE1hcmt1cCA9IG1hcmt1cDtcclxuICAgICAgbGV0IGNsb3NlTWF0Y2g7XHJcblxyXG4gICAgICByZXR1cm5pbmcuc2VsZkNsb3NpbmcgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuaW5nLmF0dHJzID0gYXR0cnM7XHJcblxyXG4gICAgICB3aGlsZSAoXHJcbiAgICAgICAgKG1hcmt1cCA9IHN0YXJ0TWFya3VwLnNsaWNlKHJldHVybmluZy5pbmRleCkpICYmXHJcbiAgICAgICAgIShjbG9zZU1hdGNoID0gbWFya3VwLm1hdGNoKFRBR19PUEVOX0NMT1NFKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IG1hcmt1cC5tYXRjaChBVFRSSUJVVEUpO1xyXG5cclxuICAgICAgICBpZiAoIWF0dHIpIHtcclxuICAgICAgICAgIHJldHVybmluZy5pbmRleCArPSAxO1xyXG5cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXR0cnNbYXR0clsxXV0gPSAoYXR0clsyXSB8fCAnJykucmVwbGFjZSgvXihcInwnKXwoXCJ8JykkL2csICcnKTtcclxuICAgICAgICByZXR1cm5pbmcuaW5kZXggKz0gYXR0clswXS5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjbG9zZU1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuaW5nLmluZGV4ICs9IGNsb3NlTWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybmluZy5zZWxmQ2xvc2luZyA9ICEhY2xvc2VNYXRjaFsxXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXR1cm5pbmc7XHJcbiAgfVxyXG5cclxuICBsZXQgeyB2YWx1ZTogaW5kZXggfSA9IG1hdGNoZXMubWluKChtYXRjaCkgPT4gKFxyXG4gICAgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IE5hTlxyXG4gICkpO1xyXG5cclxuICBpZiAoaW5kZXggPT09IEluZmluaXR5KSB7XHJcbiAgICBpbmRleCA9IG1hcmt1cC5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ3RleHQnLFxyXG4gICAgaW5kZXgsXHJcbiAgICB2YWx1ZTogbWFya3VwLnNsaWNlKDAsIGluZGV4KVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnN0cnVjdENsb3NlVGFnUmVnRXhwKHRhZ05hbWUpIHtcclxuICByZXR1cm4gbmV3IFJlZ0V4cChgPC8oJHsgdGFnTmFtZSB9KVxcXFxzKj5gLCAnaScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBuZWFyU3RyaW5nKG1hcmt1cCwgaW5kZXgpIHtcclxuICByZXR1cm4gYCR7IGluZGV4IH0gKH5+fiBcIiR7IG1hcmt1cC5zbGljZShpbmRleCwgaW5kZXggKyAxNSkgfVwiIH5+fiwgdGhlIHN0cmluZyBpdHNlbGYgaXMgXCIkeyBtYXJrdXAgfVwiKWA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyRGF0YShzdHJpbmcpIHtcclxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyYoXFx3K3wjeD9cXGQrKTsvZywgKG1hdGNoKSA9PiB7XHJcbiAgICBkaXYuaW5uZXJIVE1MID0gbWF0Y2g7XHJcblxyXG4gICAgcmV0dXJuIGRpdi50ZXh0Q29udGVudCB8fCBkaXYuaW5uZXJUZXh0O1xyXG4gIH0pO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIEVsZW1cclxuICogQHByaXZhdGVcclxuICogQG1peGluXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIEVsZW0gY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuL1N1cGVyJztcclxuaW1wb3J0IHsgQXJyLCBhcnJheSwgaXRlcmF0ZSBhcyB0aW1lcyB9IGZyb20gJy4vQXJyJztcclxuaW1wb3J0IHsgYmxvYiB9IGZyb20gJy4vQmxvYk9iamVjdCc7XHJcbmltcG9ydCB7IG1ldGhvZCB9IGZyb20gJy4vRnVuYyc7XHJcbmltcG9ydCB7IFByb21pc2UgfSBmcm9tICcuL1Byb21pc2UnO1xyXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuL1N0cic7XHJcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi9Td2l0Y2hlcic7XHJcbmltcG9ydCB7XHJcbiAgY29uc3RydWN0b3JzLCBhcHBsaWVkUmVnRXhwcywgaHRtbEVsZW1lbnRzLCBzdmdFbGVtZW50cyxcclxuICBjYW52YXNHZXRNZXRob2RzLCBjYW52YXNSZXN0TWV0aG9kc1xyXG59IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBpc0FycmF5LCBpc0FycmF5TGlrZSwgaXNFbGVtZW50LCBpc0Z1bmN0aW9uLFxyXG4gIGlzSW50ZWdlciwgaXNOaWwsIGlzTnVtYmVyLCBpc051bGwsIGlzU3RyaW5nLFxyXG4gIGFzc2lnbiwgZHluYW1pY0RlZmluZVByb3BlcnRpZXMsIGRlZmluZVByb3BlcnRpZXMsIHRvQXJyYXksXHJcbiAgdmFsaWRhdGUsIHRvU3RyaW5nVGFnLCBpdGVyYXRlLCBTeW1ib2xcclxufSBmcm9tICcuL2hlbHBlcnMnO1xyXG5pbXBvcnQgbWFya3VwVG9KU09OIGZyb20gJy4vaGVscGVycy9tYXJrdXBUb0pTT04nO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtTdHJpbmd9IEVsZW1FdmVudFN0cmluZ1xyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBBIHN0cmluZyBjb250YWluaW5nIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBjb21tYSB3aXRoIHplcm8gb3IgbW9yZSBzcGFjZXMgb3IganVzdCBzcGFjZXMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBFbGVtVmFsdWVDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIE9sZCB2YWx1ZS5cclxuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gQ3VycmVudCBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBpbiB0aGUgc2V0IG9mIHRoZSBlbGVtZW50cy5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIEVsZW1TZXRPZkNhbGxiYWNrXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtFbGVtZW50fSBjcmVhdGVkIC0gQ3JlYXRlZCBlbGVtZW50LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIGl0ZXJhdGVkIGVsZW1lbnQgaW4gdGhlIG9iamVjdC5cclxuICogQHBhcmFtIHtLZXl9IGtleSAtIEtleSBvZiB0aGUgaXRlcmF0ZWQgZWxlbWVudCBpbiB0aGUgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0aGF0IGlzIGl0ZXJhdGVkIG92ZXIuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEN1cnJlbnQgZWxlbWVudC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIFZhbGlkYXRlQ2FsbGJhY2tcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gRWxlbWVudCB2YWx1ZS5cclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gRWxlbWVudCB0byB2YWxpZGF0ZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGVsZW1lbnQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBDdHhDYWxsYmFja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBDYW52YXMgcmVuZGVyaW5nIGNvbnRleHQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBFbGVtTGlzdGVuZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0V2ZW50fSBlIC0gRmlyZWQgZXZlbnQuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgY2FsbGVkLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgRWxlbVJlbW92ZUxpc3RlbmVyc1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7Li4uRWxlbUV2ZW50U3RyaW5nfSBldmVudHMgLSBJZiBhdCBsZWFzdCBvbmUgYXJndW1lbnQgcHJlc2VudCBvbmx5IHJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIHNwZWNpZmllZFxyXG4gKiBieSB0aGUgZXZlbnRzIGluIHRoZSBhcmd1bWVudHMuXHJcbiAqL1xyXG5cclxuY29uc3QgbmF0aXZlRG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XHJcbmNvbnN0IGVtcHR5RGl2ID0gbmF0aXZlRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbmNvbnN0IGV2ZW50U2VwYXJhdG9yID0gLygsfCApICovO1xyXG5jb25zdCB0ZXh0UHJvcGVydHkgPSBuZXcgU3VwZXIoTm9kZS5wcm90b3R5cGUpLnByb3BlcnR5RGVzY3JpcHRvcigndGV4dENvbnRlbnQnKSA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcclxuY29uc3QgY2xhc3NlcyA9IHt9O1xyXG5jb25zdCBhdHRycyA9IHt9O1xyXG5jb25zdCB3aW5kb3dzRHdheW5lRGF0YSA9IG5ldyBBcnIoW10pO1xyXG5jb25zdCBpbnB1dEVsZW1lbnRzID0gJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBkYXRhbGlzdCwga2V5Z2VuLCBvdXRwdXQnO1xyXG5jb25zdCBjbGljayA9IG1ldGhvZCgnY2xpY2snKTtcclxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5jb25zdCB4bWxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XHJcbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbmNvbnN0IHhodG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XHJcbmNvbnN0IHR5cGVTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgKGVsZW0sIHR5cGUpID0+IHtcclxuICBjb25zdCBucyA9IHR5cGUgPT09ICdzdmcnXHJcbiAgICA/IHN2Z05TXHJcbiAgICA6IGVsZW0ucHJvcCgnbmFtZXNwYWNlVVJJJykgfHwgbmF0aXZlRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSB8fCB4aHRtbE5TO1xyXG5cclxuICByZXR1cm4gbmF0aXZlRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0eXBlKTtcclxufSlcclxuICAuY2FzZShcclxuICAgICh0eXBlKSA9PiB0eXBlID09PSAnI2NvbW1lbnQnLFxyXG4gICAgKCkgPT4gbmF0aXZlRG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJylcclxuICApXHJcbiAgLmNhc2UoXHJcbiAgICAodHlwZSkgPT4gdHlwZSA9PT0gJyN0ZXh0JyxcclxuICAgICgpID0+IG5hdGl2ZURvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxyXG4gICk7XHJcbmNvbnN0IHJlZlN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsICdocmVmJylcclxuICAuY2FzZShcclxuICAgIFsnaW1nJywgJ3NjcmlwdCcsICdpZnJhbWUnLCAnYXVkaW8nLCAndmlkZW8nXSxcclxuICAgICdzcmMnXHJcbiAgKVxyXG4gIC5jYXNlKFxyXG4gICAgJ2Zvcm0nLFxyXG4gICAgJ2FjdGlvbidcclxuICApO1xyXG5jb25zdCBmaWx0ZXJTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgKHNlbGVjdG9yKSA9PiBzZWxlY3RvcilcclxuICAuY2FzZShcclxuICAgIGlzU3RyaW5nLFxyXG4gICAgKHNlbGVjdG9yKSA9PiAoXHJcbiAgICAgIChlbGVtKSA9PiBuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcilcclxuICAgIClcclxuICApXHJcbiAgLmNhc2UoXHJcbiAgICBbaXNBcnJheSwgaXNFbGVtXSxcclxuICAgIChlbGVtcykgPT4ge1xyXG4gICAgICBlbGVtcyA9IG5ldyBBcnIoZWxlbXMpO1xyXG5cclxuICAgICAgcmV0dXJuIChlbGVtKSA9PiBlbGVtcy5pbmRleE9mKGVsZW0pICE9PSAtMTtcclxuICAgIH1cclxuICApO1xyXG5jb25zdCBpbm5lclN3aXRjaGVyID0gc3dpdGNoZXIoJ3N0cmljdEVxdWFscycsIDApXHJcbiAgLmNhc2UoJ3BhZGRpbmctYm94JywgKHBhZGRpbmdzKSA9PiBwYWRkaW5ncylcclxuICAuY2FzZSgnYm9yZGVyLWJveCcsIChwYWRkaW5ncywgYm9yZGVycykgPT4gcGFkZGluZ3MgKyBib3JkZXJzKTtcclxuY29uc3Qgb3V0ZXJTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAoYm9yZGVycywgcGFkZGluZ3MpID0+IGJvcmRlcnMgKyBwYWRkaW5ncylcclxuICAuY2FzZSgncGFkZGluZy1ib3gnLCAoYm9yZGVycykgPT4gYm9yZGVycylcclxuICAuY2FzZSgnYm9yZGVyLWJveCcsIDApO1xyXG5jb25zdCBhdHRyTlNTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgbnVsbClcclxuICAuY2FzZSgoYXR0cikgPT4gYXR0ciA9PT0gJ3htbG5zJyB8fCBhdHRyID09PSAneG1sbnM6eGxpbmsnLCAoZWxlbSkgPT4gKFxyXG4gICAgZWxlbS5uYW1lID09PSAnc3ZnJ1xyXG4gICAgICA/IHhtbE5TXHJcbiAgICAgIDogbnVsbFxyXG4gICkpXHJcbiAgLmNhc2UoKGF0dHIpID0+IC9eeGxpbms6XFx3Ly50ZXN0KGF0dHIpLCAoZWxlbSkgPT4gKFxyXG4gICAgZWxlbS5jbG9zZXN0KCdzdmcnKS5sZW5ndGhcclxuICAgICAgPyB4bGlua05TXHJcbiAgICAgIDogbnVsbFxyXG4gICkpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBFbGVtXHJcbiAqIEBleHRlbmRzIEFyclxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IFtlbGVtID0gW11dIC0gQW4gZWxlbWVudCBvciBhbiBhcnJheSBvZiBlbGVtZW50cyB0byB3cmFwLlxyXG4gKiBAcmV0dXJucyB7RWxlbX0gSW5zdGFuY2Ugb2YgRWxlbS5cclxuICogQGRlc2NyaXB0aW9uIFdyYXAgb2YgYW4gZWxlbWVudHMgc2V0LiBBbHNvIGhhcyBhbGwgbWV0aG9kcyBmcm9tIGZyb21cclxuICogW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0uXHJcbiAqIEdldHRlcnMgbWV0aG9kcyByZXR1cm4gdGhlIHNhbWUgYXMgbWV0aG9kcyBmcm9tIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBhbmQgdGhlIHJlc3QgcmV0dXJuIHRoaXMuXHJcbiAqIFdvcmsgZm9yIHRoZSBmaXJzdCBjYW52YXMgZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBuZXcgRWxlbShkb2N1bWVudC5ib2R5KTtcclxuICogbmV3IEVsZW0oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNscycpKTtcclxuICogbmV3IEVsZW0oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xzJykpO1xyXG4gKi9cclxuY2xhc3MgRWxlbSBleHRlbmRzIEFyciB7XHJcbiAgY29uc3RydWN0b3IoZWxlbSA9IFtdKSB7XHJcbiAgICBzdXBlcigoKCkgPT4ge1xyXG4gICAgICBsZXQgZWxlbWVudCA9IGVsZW07XHJcblxyXG4gICAgICBpZiAoaXNBcnJheUxpa2UoZWxlbWVudCkgJiYgKFxyXG4gICAgICAgIGlzV2luZG93KGVsZW1lbnQpIHx8XHJcbiAgICAgICAgaXNIVE1MRG9jdW1lbnQoZWxlbWVudCkgfHxcclxuICAgICAgICBpc0RvY3VtZW50RnJhZ21lbnQoZWxlbWVudCkgfHxcclxuICAgICAgICBpc0VsZW1lbnQoZWxlbWVudCkgfHxcclxuICAgICAgICBpc0NvbW1lbnRPclRleHQoZWxlbWVudCkgfHxcclxuICAgICAgICBpc1N0eWxlUnVsZShlbGVtZW50KVxyXG4gICAgICApKSB7XHJcbiAgICAgICAgZWxlbWVudCA9IFtlbGVtZW50XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBBcnIodG9BcnJheShuZXcgU3VwZXIoZWxlbWVudCkuJCwgdHJ1ZSkpLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgICBpZiAoZWxlbXMuaW5kZXhPZihlbGVtKSA9PT0gLTEgJiYgKFxyXG4gICAgICAgICAgaXNFbGVtZW50KGVsZW0pIHx8XHJcbiAgICAgICAgICBpc1dpbmRvdyhlbGVtKSB8fFxyXG4gICAgICAgICAgaXNIVE1MRG9jdW1lbnQoZWxlbSkgfHxcclxuICAgICAgICAgIGlzRG9jdW1lbnRGcmFnbWVudChlbGVtKSB8fFxyXG4gICAgICAgICAgaXNDb21tZW50T3JUZXh0KGVsZW0pIHx8XHJcbiAgICAgICAgICBpc1N0eWxlUnVsZShlbGVtKVxyXG4gICAgICAgICkpIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtcy5wdXNoKGVsZW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRWxlbShlbGVtKSkge1xyXG4gICAgICAgICAgZWxlbXMucHVzaC5hcHBseShlbGVtcywgZWxlbS4kKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIFtdKS4kO1xyXG4gICAgfSkoKSk7XHJcblxyXG4gICAgdGhpcy4kJCA9IGVsZW07XHJcblxyXG4gICAgdGhpcy5mb3JFYWNoKGFkZER3YXluZURhdGEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7QXJyYXkuPE5vZGV8V2luZG93Pn0gRWxlbSMkXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE5vZGV8V2luZG93Pn1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb25zdHJ1Y3RlZCBlbGVtZW50IHNldC5cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7Kn0gRWxlbSMkJFxyXG4gICAgICogQHR5cGUgeyp9XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbCBlbGVtZW50IHNldC5cclxuICAgICAqL1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2FkZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLihTdHJpbmd8RWxlbXxFbGVtZW50fEVsZW1lbnRbXSl9IGVsZW1lbnRzIC0gRWFjaCBhcmd1bWVudCBpcyBhIHNlbGVjdG9yLCBvciBFbGVtLCBvciBFbGVtZW50LCBvciBhcnJheSBvZiBFbGVtZW50cy5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBuZXcgZWxlbWVudHMgdG8gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbTEuZmluZCgnLmNsczEnKVxyXG4gICAqICAgLmFkZChlbGVtMi5maW5kKCcuY2xzMicpKVxyXG4gICAqICAgLmhpZGUoKTtcclxuICAgKi9cclxuICBhZGQoLi4uZWxlbWVudHMpIHtcclxuICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAoZWxlbSkgPT4ge1xyXG4gICAgICB0b0ZpbmQoZWxlbSkuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmluZGV4T2YoZWxlbSkgPT09IC0xKSB7XHJcbiAgICAgICAgICB0aGlzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2FkZENsYXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byBhZGQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgY2xhc3NlcyB0byB0aGUgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmFkZENsYXNzKCdyZWQnLCAncm91bmQnKTtcclxuICAgKi9cclxuICBhZGRDbGFzcyguLi5jbGFzc2VzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuXHJcbiAgICAgIGl0ZXJhdGUoaXNFbGVtZW50KGVsZW0pICYmIGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5hZGQoY2xzKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhZGRDb21tZW50XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dCBvZiBjb21tZW50IHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBjb21tZW50IHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSBpdCdzIGluc2VydGVkIHRvIHRoZSBzdGFydC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBjb21tZW50IHRvIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5hZGRIVE1MKCc8ZGl2PjE8L2Rpdj4nKTtcclxuICAgKi9cclxuICBhZGRDb21tZW50KHRleHQsIGVuZCA9IHRydWUpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIGVsZW0uaW5zZXJ0QWRqYWNlbnRIVE1MKGVuZCA/ICdiZWZvcmVlbmQnIDogJ2FmdGVyYmVnaW4nLCBgPCEtLSR7IHRleHQgfS0tPmApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNhZGRIVE1MXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIC0gSFRNTCB0byBhZGQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmQgLSBJZiB0aGUgSFRNTCBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgaXQncyBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgSFRNTCB0byBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYWRkSFRNTCgnPGRpdj4xPC9kaXY+Jyk7XHJcbiAgICovXHJcbiAgYWRkSFRNTChodG1sLCBlbmQgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICBlbGVtLmluc2VydEFkamFjZW50SFRNTChlbmQgPyAnYmVmb3JlZW5kJyA6ICdhZnRlcmJlZ2luJywgaHRtbCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2FkZFJ1bGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBydWxlLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIGZvciB0aGUgcnVsZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IHN0eWxlIC0gU3R5bGUgZm9yIHRoZSBzZWxlY3Rvci5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBjc3Mgc3R5bGVzIGludG8gdGhlIGZpcnN0IHN0eWxlIHRhZyBpbiB0aGUgc2V0LlxyXG4gICAqIE5vdGU6IHN0eWxlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2lkZSB0aGUgZG9jdW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHN0eWxlLmFkZFJ1bGUoJ2ltZy1zaXplJywgJ2ltZy5zcXVhcmUnLCB7XHJcbiAgICogICB3aWR0aDogJzQwcHggIWltcG9ydGFudCcsXHJcbiAgICogICBoZWlnaHQ6ICc0MHB4ICFpbXBvcnRhbnQnXHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgYWRkUnVsZShuYW1lLCBzZWxlY3Rvciwgc3R5bGUpIHtcclxuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoZ2V0TmFtZShlbGVtKSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgIGNvbnN0IHsgc2hlZXQgfSA9IGVsZW07XHJcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHNoZWV0LmNzc1J1bGVzO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVzID0gbmV3IFN1cGVyKHN0eWxlKS53b3JkKCh2YWx1ZSwgcHJvcGVydHkpID0+IChcclxuICAgICAgICAgIGAkeyBuZXcgU3RyKHByb3BlcnR5KS50b0h5cGhlbkNhc2UoKSB9OiAkeyB2YWx1ZSB9O1xcbmBcclxuICAgICAgICApKTtcclxuXHJcbiAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShcclxuICAgICAgICAgIGAkeyBzZWxlY3RvciB9IHskeyBydWxlcyAmJiAnXFxuJyB9JHsgcnVsZXMgfX1gLFxyXG4gICAgICAgICAgbGVuZ3RoXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzaGVldC5jc3NSdWxlc1tsZW5ndGhdLmR3YXluZURhdGEgPSB7IG5hbWUgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2FkZFRleHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUZXh0IHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSB0ZXh0IHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSBpdCdzIGluc2VydGVkIHRvIHRoZSBzdGFydC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyB0ZXh0IHRvIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5hZGRUZXh0KCcxMjMnKTtcclxuICAgKi9cclxuICBhZGRUZXh0KHRleHQsIGVuZCA9IHRydWUpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpLmludG8oZWxlbSwgZW5kKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2FwcGx5XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBzdHJpbmdzIC0gU3RyaW5ncyB0byBhcHBseS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCBpcyBhIHNob3J0aGFuZCBmb3IgbWFueSBvdGhlciBtZXRob2RzLlxyXG4gICAqIEFsbCBzaG9ydGhhbmRzIGNhbiBiZSBzZXBhcmF0ZWQgd2l0aCBzcGFjZSBhbmQgd3JpdHRlbiB3aXRoaW4gb25lIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5hcHBseShcclxuICAgKiAgICcjaWQgLmMxIC5jMiBAYm9yZGVyKDFweCBzb2xpZCBibGFjaykgJGRpc2FibGVkICRhdHRyKHNvbWUgdmFsdWUpICooQ2xpY2sgbWUhKSdcclxuICAgKiApO1xyXG4gICAqIC8vIHNob3J0aGFuZCBmb3JcclxuICAgKiAvLyBlbGVtXHJcbiAgICogLy8gICAuaWQoJ2lkJylcclxuICAgKiAvLyAgIC5hZGRDbGFzcygnYzEnLCAnYzInKVxyXG4gICAqIC8vICAgLmNzcygnYm9yZGVyJywgJzFweCBzb2xpZCBibGFjaycpXHJcbiAgICogLy8gICAuYXR0cih7XHJcbiAgICogLy8gICAgIGF0dHIsICdzb21lIHZhbHVlJ1xyXG4gICAqIC8vICAgICBkaXNhYmxlZDogJydcclxuICAgKiAvLyAgIH0pXHJcbiAgICogLy8gICAudGV4dCgnQ2xpY2sgbWUhJyk7XHJcbiAgICogLy8gVGhlcmUgaXMgYSBmdWxsIGxpc3Qgb2YgcG9zc2libGUgdHlwZXMgb2Ygc3ludGF4IGJlbG93Li4uXHJcbiAgICpcclxuICAgKiBlbGVtLmFwcGx5KCcjaWQnKTsgICAgICAgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5pZCgnaWQnKTtcclxuICAgKiBlbGVtLmFwcGx5KCcuYzEgLmMyJyk7ICAgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5hZGRDbGFzcygnYzEnLCAnYzInKTtcclxuICAgKiBlbGVtLmFwcGx5KCctLmMxIC0uYzInKTsgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5yZW1vdmVDbGFzcygnYzEnLCAnYzInKTtcclxuICAgKiBlbGVtLmFwcGx5KCctQGZsb2F0IC1AZGlzcGxheScpOyAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5yZW1vdmVDU1MoJ2Zsb2F0JywgJ2Rpc3BsYXknKTtcclxuICAgKiBlbGVtLmFwcGx5KCctJGExIC0kYTInKTsgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBmb3IgZWxlbS5yZW1vdmVBdHRyKCdhMScsICdhMicpO1xyXG4gICAqIGVsZW0uYXBwbHkoJyooc29tZSB0ZXh0KScpOyAgICAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLnRleHQoJ3NvbWUgdGV4dCcpO1xyXG4gICAqIGVsZW0uYXBwbHkoJyYoPGRpdj4xPC9kaXY+KScpOyAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmh0bWwoJzxkaXY+MTwvZGl2PicpO1xyXG4gICAqIGVsZW0uYXBwbHkoJ0BmbG9hdChyaWdodCknKTsgICAgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmNzcygnZmxvYXQnLCAncmlnaHQnKTtcclxuICAgKiBlbGVtLmFwcGx5KCdAdHJhbnNmb3JtKHNjYWxlKDVweCkpJyk7IC8vIHNob3J0aGFuZCBmb3IgZWxlbS5jc3MoJ3RyYW5zZm9ybScsICdzY2FsZSg1cHgpJyk7XHJcbiAgICogZWxlbS5hcHBseSgnQG1hcmdpbigycHggMnB4KScpOyAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uY3NzKCdtYXJnaW4nLCAnMnB4IDJweCcpO1xyXG4gICAqIGVsZW0uYXBwbHkoJ0BtYXJnaW5MZWZ0KDJweCknKTsgICAgICAgLy8gc2hvcnRoYW5kIGZvciBlbGVtLmNzcygnbWFyZ2luTGVmdCcsICcycHggMnB4Jyk7XHJcbiAgICogZWxlbS5hcHBseSgnQG1hcmdpbi1sZWZ0KDJweCknKTsgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uY3NzKCdtYXJnaW4tbGVmdCcsICcycHggMnB4Jyk7XHJcbiAgICogZWxlbS5hcHBseSgnJGF0dHIoc29tZSB2YWx1ZSknKTsgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uYXR0cignYXR0cicsICdzb21lIHZhbHVlJyk7XHJcbiAgICogZWxlbS5hcHBseSgnJGF0dHInKTsgICAgICAgICAgICAgICAgICAvLyBzaG9ydGhhbmQgZm9yIGVsZW0uYXR0cignYXR0cicsICcnKTtcclxuICAgKi9cclxuICBhcHBseSguLi5zdHJpbmdzKSB7XHJcbiAgICBsZXQgYXBwbGllZDtcclxuICAgIGxldCBzZXRBcHBsaWVkO1xyXG4gICAgbGV0IGNhbGxiYWNrO1xyXG4gICAgbGV0IG5hbWU7XHJcbiAgICBsZXQgbnAxO1xyXG4gICAgbGV0IHNsaWNlO1xyXG5cclxuICAgIG5ldyBTdHIobmV3IEFycihhcmd1bWVudHMpLmpvaW4oJyAnKSlcclxuICAgICAgLnNwbGl0KC8oXFxzKykvKVxyXG4gICAgICAuZm9yRWFjaCgoc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhcHBsaWVkKSB7XHJcbiAgICAgICAgICBucDEgPSBzdHJpbmcuc2xpY2UoMCwgMSk7XHJcbiAgICAgICAgICBjYWxsYmFjayA9IGFwcGxpZWRSZWdFeHBzW25wMV07XHJcbiAgICAgICAgICBzbGljZSA9IDE7XHJcblxyXG4gICAgICAgICAgaWYgKGNhbGxiYWNrICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrW3N0cmluZy5zbGljZSgxLCAyKV07XHJcbiAgICAgICAgICAgIHNsaWNlID0gMjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdChzdHJpbmcpIHx8ICFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbmFtZSA9IHN0cmluZy5zbGljZShzbGljZSkubWF0Y2goL15bXigpXSsvKTtcclxuXHJcbiAgICAgICAgICBpZiAoIW5hbWUgJiYgKG5wMSAhPT0gJyonICYmIG5wMSAhPT0gJyYnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYXBwbGllZCA9IHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSA/IG5hbWVbMF0gOiAnJyxcclxuICAgICAgICAgICAgYXJnczogc3RyaW5nLnNsaWNlKHNsaWNlICsgKG5hbWUgPyBuYW1lWzBdIDogJycpLmxlbmd0aCksXHJcbiAgICAgICAgICAgIGNhbGxiYWNrXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHNldEFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFzZXRBcHBsaWVkKSB7XHJcbiAgICAgICAgICBhcHBsaWVkLmFyZ3MgKz0gc3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhcHBsaWVkLmFyZ3MgfHwgL15cXChbXFxzXFxTXStcXCkkLy50ZXN0KGFwcGxpZWQuYXJncykpIHtcclxuICAgICAgICAgIGFwcGxpZWQuY2FsbGJhY2sodGhpcywgYXBwbGllZC5uYW1lLCBhcHBsaWVkLmFyZ3MucmVwbGFjZSgvXlxcKHxcXCkkL2csICcnKSk7XHJcbiAgICAgICAgICBhcHBsaWVkID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldEFwcGxpZWQgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jYXR0clxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrPn0gW2F0dHJdIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCBvclxyXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW2F0dHJOYW1lXTogdmFsdWUsIC4uLiB9IHRvIHNldCBhdHRyaWJ1dGVzLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbdmFsdWVdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nXHJcbiAgICogaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cclxuICAgKiBAcmV0dXJucyB7U3VwZXJ8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBhdHRyaWJ1dGVzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKiByZXR1cm5lZCwgaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKiByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmF0dHIoJ2F0dHIxJywgJ3ZhbHVlMScpOyAvLyBhdHRyaWJ1dGUgYXR0cjEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXHJcbiAgICogZWxlbS5hdHRyKCdhdHRyMScpOyAgICAgICAgICAgLy8gJ3ZhbHVlMSdcclxuICAgKiBlbGVtLmF0dHIoe1xyXG4gICAqICAgYXR0cjE6ICd2YWx1ZTMnLCAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBhdHRyMSBzZXQgdG8gJ3ZhbHVlMydcclxuICAgKiAgIGF0dHIyOiAndmFsdWUyJyAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjIgc2V0IHRvICd2YWx1ZTInXHJcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxyXG4gICAqIGVsZW0uYXR0cigpLiQ7ICAgICAgICAgICAgICAgIC8vIHsgYXR0cjE6ICd2YWx1ZTMnLCBhdHRyMjogJ3ZhbHVlMicgfVxyXG4gICAqL1xyXG4gIGF0dHIoYXR0ciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGVsZW0gPSBnZXRFbGVtKHRoaXMpO1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbmV3IFN1cGVyKGVsZW0uYXR0cmlidXRlcykub2JqZWN0KChvLCBhdHRyKSA9PiB7XHJcbiAgICAgICAgb1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhhdHRyKSkge1xyXG4gICAgICBjb25zdCBucyA9IGF0dHJOU1N3aXRjaGVyKGF0dHIsIFtuZXcgRWxlbShlbGVtKV0pO1xyXG5cclxuICAgICAgcmV0dXJuIGlzTnVsbChucylcclxuICAgICAgICA/IGVsZW0uZ2V0QXR0cmlidXRlKGF0dHIpXHJcbiAgICAgICAgOiBlbGVtLmdldEF0dHJpYnV0ZU5TKG5zLCBhdHRyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGF0dHIgPSB7IFthdHRyXTogdmFsdWUgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmV3IFN1cGVyKGF0dHIpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQXR0cihrZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlKG5ldyBFbGVtKGVsZW0pLmF0dHIoa2V5KSwgZWxlbSwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUF0dHIoa2V5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5zID0gYXR0ck5TU3dpdGNoZXIoa2V5LCBbbmV3IEVsZW0oZWxlbSldKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVsbChucykpIHtcclxuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZU5TKG5zLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jYmxvYlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMgPSB7fV0gLSBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCBpbnRvIHtAbGluayBibG9ifS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QmxvYk9iamVjdD59IE5ldyBpbnN0YW5jZSBvZiBwcm9taXNlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEge0BsaW5rIEJsb2JPYmplY3R9IFByb21pc2UuIFdvcmtzIHdpdGggaW1hZ2Ugb3IgY2FudmFzIGZpcnN0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGltYWdlLmJsb2IoKS50aGVuKChibG9iKSA9PiBjb25zb2xlLmxvZyhibG9iKSk7ICAvLyBCbG9iT2JqZWN0XHJcbiAgICogY2FudmFzLmJsb2IoKS50aGVuKChibG9iKSA9PiBjb25zb2xlLmxvZyhibG9iKSk7IC8vIEJsb2JPYmplY3RcclxuICAgKi9cclxuICBibG9iKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgZWxlbSA9IHRoaXMuZmlyc3QoKTtcclxuICAgICAgY29uc3QgeyBuYW1lIH0gPSBlbGVtO1xyXG5cclxuICAgICAgaWYgKG5hbWUgIT09ICdpbWcnICYmIG5hbWUgIT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGlzblxcJ3QgYW4gaW1hZ2Ugb3IgYSBjYW52YXMhIChFbGVtI2Jsb2IpJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobmFtZSA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZShlbGVtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbVxyXG4gICAgICAgIC5sb2FkKClcclxuICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZWxlbS5pc0Jyb2tlbigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdUaGUgaW1hZ2UgaXMgYnJva2VuISAoRWxlbSNibG9iKScpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBuZXcgRWxlbShuYXRpdmVEb2N1bWVudCkuY2FudmFzKCk7XHJcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGVsZW0ud2lkdGgoKTtcclxuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGVsZW0uaGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgY2FudmFzXHJcbiAgICAgICAgICAgIC53aWR0aCh3aWR0aClcclxuICAgICAgICAgICAgLmhlaWdodChoZWlnaHQpXHJcbiAgICAgICAgICAgIC5kcmF3SW1hZ2UoZWxlbS4kWzBdLCAwLCAwKTtcclxuXHJcbiAgICAgICAgICByZXNvbHZlKGNhbnZhcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KS50aGVuKChjYW52YXMpID0+IHtcclxuICAgICAgY29uc3QgZGF0YVVSTCA9IGNhbnZhcy5kYXRhVVJMKCk7XHJcbiAgICAgIGNvbnN0IGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFVUkwuc3BsaXQoJywnKVsxXSk7XHJcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVTdHJpbmcubGVuZ3RoO1xyXG4gICAgICBjb25zdCBhYiA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xyXG4gICAgICBjb25zdCBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcclxuXHJcbiAgICAgIHRpbWVzKGxlbmd0aCwgKGkpID0+IHtcclxuICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gYmxvYihhYiwgb3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNibHVyXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9ibHVyXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0hUTUxFbGVtZW50I2JsdXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9ibHVyfS5cclxuICAgKi9cclxuICBibHVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgZWxlbS5ibHVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2NhbGNDU1NcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BzZXVkb10gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0NTU1N0eWxlRGVjbGFyYXRpb259IFNlZSB0aGUgbGluay5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9XaW5kb3cvZ2V0Q29tcHV0ZWRTdHlsZVxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtnZXRDb21wdXRlZFN0eWxlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvV2luZG93L2dldENvbXB1dGVkU3R5bGV9LlxyXG4gICAqIFJldHVybnMgY29tcHV0ZWQgc3R5bGUgZm9yIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgb3IgdW5kZWZpbmVkLlxyXG4gICAqL1xyXG4gIGNhbGNDU1MocHNldWRvID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZ2V0RWxlbSh0aGlzKSwgcHNldWRvKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjaGFuZ2VSdWxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcnVsZS5cclxuICAgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBzdHlsZSAtIFN0eWxlIGZvciB0aGUgc2VsZWN0b3IuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjaGFuZ2luZyBjc3Mgc3R5bGVzIGluIHRoZSBmaXJzdCBzdHlsZSB0YWcgaW4gdGhlIHNldC5cclxuICAgKiBOb3RlOiBzdHlsZSBlbGVtZW50IHNob3VsZCBiZSBpbnNpZGUgdGhlIGRvY3VtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBzdHlsZS5jaGFuZ2VSdWxlKCdpbWctc2l6ZScsIHtcclxuICAgKiAgIHdpZHRoOiAnNTBweCAhaW1wb3J0YW50JyxcclxuICAgKiAgIGhlaWdodDogJzUwcHggIWltcG9ydGFudCdcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBjaGFuZ2VSdWxlKG5hbWUsIHN0eWxlKSB7XHJcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBydWxlIH0gPSBuZXcgQXJyKGVsZW0uc2hlZXQuY3NzUnVsZXMpLmZpbmQoKHJ1bGUpID0+IHJ1bGUuZHdheW5lRGF0YSAmJiBydWxlLmR3YXluZURhdGEubmFtZSA9PT0gbmFtZSkgfHwge307XHJcblxyXG4gICAgICAgIGlmIChydWxlKSB7XHJcbiAgICAgICAgICBuZXcgRWxlbShydWxlKS5jc3Moc3R5bGUpO1xyXG5cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY2hpbGRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEVsZW18RWxlbWVudHxFbGVtZW50W119IGVsZW1lbnQgLSBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIgYSB3cmFwIG9mIHRoZSBzZXQgb2YgdGhlIGNoaWxkcmVuXHJcbiAgICogb2YgdGhpcyBpbmRleCBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZCBvdGhlcndpc2UgYW4gZWxlbWVudCB0byBwdXQgaW50byB0aGlzIGVsZW1lbnQsIGEgY29sbGVjdGlvblxyXG4gICAqIG9yIGEgc2VsZWN0b3Igb2YgaXQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmQgLSBJZiB0aGUgZWxlbWVudHMgc2hvdWxkIGJlIGluc2VydGVkIHRvIHRoZSBlbmQuIElmIGZhbHNlIHRoZXkgYXJlIGluc2VydGVkIHRvIHRoZSBzdGFydC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyBhIHdyYXAgb2YgY2hpbGRyZW4gb3IgaW5zZXJ0ZWQgZWxlbWVudHMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBzaW1pbGFyIHRvXHJcbiAgICogW05vZGUjYXBwZW5kQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2FwcGVuZENoaWxkfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgY2hpbGQgPSBlbGVtLmNoaWxkKDEpO1xyXG4gICAqXHJcbiAgICogZWxlbS5jaGlsZChlbGVtMik7XHJcbiAgICogZWxlbS5jaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XHJcbiAgICogZWxlbS5jaGlsZCgnI2lkIGRpdi5jMScpO1xyXG4gICAqL1xyXG4gIGNoaWxkKGVsZW1lbnQsIGVuZCA9IHRydWUpIHtcclxuICAgIGlmIChpc0ludGVnZXIoZWxlbWVudCkgJiYgZWxlbWVudCA+PSAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuKCkuZWxlbShlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdG9GaW5kKGVsZW1lbnQpLmludG8odGhpcywgZW5kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjaGlsZHJlblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gRC1XcmFwIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgZWxlbWVudCdzIGNoaWxkcmVuLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBjaGlsZHJlbiA9IGVsZW0uY2hpbGRyZW4oKTtcclxuICAgKi9cclxuICBjaGlsZHJlbigpIHtcclxuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzLmxlbmd0aCA/IHRoaXMuJFswXS5jaGlsZE5vZGVzIDogW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2NsYXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY2xzXSAtIElmIGl0J3MgcHJlc2VudCBpdCBoYXMgdG8gY29udGFpbiBjbGFzcyBhdHRyaWJ1dGUgdG8gc2V0LlxyXG4gICAqIEByZXR1cm5zIHtBcnJ8RWxlbX0gSWYgdGhlIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhpcyByZXR1cm5lZCBvdGhlcndpc2UgYSB3cmFwIG9mIHRoZSBjbGFzc2VzIGFycmF5IHJldHVybmVkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcvc2V0dGluZyBjbGFzc2VzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmNsYXNzKCdjMSBjMicpOyAvLyBjbGFzcyBzZXQgdG8gJ2MxIGMyJ1xyXG4gICAqIGVsZW0uY2xhc3MoKS4kOyAgICAgIC8vIFsnYzEnLCAnYzInXVxyXG4gICAqL1xyXG4gIGNsYXNzKGNscykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQXJyKGdldEVsZW0odGhpcykuY2xhc3NOYW1lLnNwbGl0KCcgJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xzO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjbGlja1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvY2xpY2tcclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbSFRNTEVsZW1lbnQjY2xpY2tde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9jbGlja30uXHJcbiAgICovXHJcbiAgY2xpY2soKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICBlbGVtLmNsaWNrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2Nsb25lXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbZGVlcCA9IGZhbHNlXSAtIFNlZSB0aGVlIGxpbmsuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvY2xvbmVOb2RlXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW05vZGUjY2xvbmVOb2RlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvTm9kZS9jbG9uZU5vZGV9LlxyXG4gICAqL1xyXG4gIGNsb25lKGRlZXAgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICBlbGVtcy5hZGQoZWxlbS5jbG9uZU5vZGUoISFkZWVwKSk7XHJcbiAgICB9LCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjbG9zZXN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gU2V0IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnRzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtFbGVtZW50I2Nsb3Nlc3Rde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3R9LlxyXG4gICAqL1xyXG4gIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IHtcclxuICAgICAgd2hpbGUgKGVsZW0pIHtcclxuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWxlbXMuYWRkKGVsZW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgfVxyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY29udGFpbnNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBmaW5kIG91dCBpZiBpdCdzIHdpdGhpbiB0aGUgZmlyc3QgZWxlbWVudFxyXG4gICAqIGluIHRoZSBzZXQgb3IgYSBzZWxlY3RvciBvZiBpdC5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgYXJndW1lbnQgd2l0aGluIHRoaXMgZWxlbWVudC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGlzIGV4dGVuc2lvbiBmb3JcclxuICAgKiBbTm9kZSNjb250YWluc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvY29udGFpbnN9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtMS5jb250YWlucyhlbGVtMik7ICAgLy8gdHJ1ZXxmYWxzZVxyXG4gICAqIGVsZW0uY29udGFpbnMoc2VsZWN0b3IpOyAvLyB0cnVlfGZhbHNlXHJcbiAgICovXHJcbiAgY29udGFpbnMoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA9IHRvRmluZChlbGVtZW50KTtcclxuXHJcbiAgICByZXR1cm4gZ2V0RWxlbSh0aGlzKS5jb250YWlucyhnZXRFbGVtKGVsZW1lbnQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUeXBlIG9mIGNyZWF0ZWQgZWxlbWVudC4gSWYgdHlwZSBpcyBcIiN0ZXh0XCIgYSB0ZXh0IG5vZGUgaXMgY3JlYXRlZC5cclxuICAgKiBJZiB0eXBlIGlzIFwiI2NvbW1lbnRcIiBhIGNvbW1lbnQgbm9kZSBpcyBjcmVhdGVkLlxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnMgLSBTdHJpbmdzIHRoYXQgYXJlIHBhc3NlZCBpbnRvIHtAbGluayBFbGVtI2FwcGx5fS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGVsZW1lbnRzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQuXHJcbiAgICogSWYgdGhpcyBlbGVtZW50IGlzIG5vdCBhbiBFbGVtZW50IHRoZSBlbGVtZW50IGlzIGp1c3QgY3JlYXRlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jcmVhdGUoJ2RpdicsICcjaWQgLmMxIC5jMiAqU29tZSB0ZXh0KicpO1xyXG4gICAqXHJcbiAgICogLy8gYWxzbyB0aGVyZSBhcmUgc2hvcnRoYW5kcyBmb3IgYWxtb3N0IGV2ZXJ5IEhUTUwtZWxlbWVudFxyXG4gICAqIGVsZW0uZGl2KCk7XHJcbiAgICogZWxlbS5pbnB1dCgnJHR5cGUoY2hlY2tib3gpICRuYW1lKGNvdW50cnkpJyk7XHJcbiAgICovXHJcbiAgY3JlYXRlKHR5cGUsIC4uLmFwcGxpZWRFeHByZXNzaW9ucykge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCBlbGVtZW50ID0gbmV3IEVsZW0odHlwZVN3aXRjaGVyKHR5cGUsIFtuZXcgRWxlbShlbGVtKV0pKTtcclxuXHJcbiAgICAgIGVsZW1lbnQuaW50byhlbGVtKTtcclxuXHJcbiAgICAgIGVsZW1zLmFkZChlbGVtZW50LmFwcGx5LmFwcGx5KGVsZW1lbnQsIGFwcGxpZWRFeHByZXNzaW9ucykpO1xyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jY3JlYXRlQ29tbWVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIGNvbW1lbnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtIC0gd3JhcCBvZiB0aGUgY3JlYXRlZCBjb21tZW50cy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBjb21tZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxyXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgY29tbWVudCBpcyBqdXN0IGNyZWF0ZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uY3JlYXRlQ29tbWVudCgnY29tbWVudCcpO1xyXG4gICAqL1xyXG4gIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLmNyZWF0ZSgnI2NvbW1lbnQnKVxyXG4gICAgICAudGV4dCh0ZXh0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVUZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGV4dC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIHRleHQgbm9kZXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY3JlYXRpbmcgdGV4dCBub2RlcyBpbnNpZGUgdGhpcyBlbGVtZW50LlxyXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBub3QgYW4gRWxlbWVudCB0aGUgdGV4dCBub2RlIGlzIGp1c3QgY3JlYXRlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jcmVhdGVUZXh0KCd0ZXh0Jyk7XHJcbiAgICovXHJcbiAgY3JlYXRlVGV4dCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAuY3JlYXRlKCcjdGV4dCcpXHJcbiAgICAgIC50ZXh0KHRleHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2Nzc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrPn0gW3Byb3BlcnR5XSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldCBvclxyXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW3Byb3BlcnR5XTogdmFsdWUsIC4uLiB9IHRvIHNldCBzdHlsZXMuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2t9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IHByb3BlcnR5LlxyXG4gICAqIEByZXR1cm5zIHtTdXBlcnxTdHJpbmd8RWxlbX0gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgRC1XcmFwIG9mIGNzcyBzdHlsZXMgb2YgdGhlIGVsZW1lbnQgcmV0dXJuZWQsXHJcbiAgICogaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgc3R5bGVzLiBTdXBwb3J0cyAhaW1wb3J0YW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmNzcygnZGlzcGxheScsICdub25lJyk7IC8vIGRpc3BsYXkgc2V0IHRvICdub25lJyBhbmQgdGhpcyByZXR1cm5lZFxyXG4gICAqIGVsZW0uY3NzKCdkaXNwbGF5Jyk7ICAgICAgICAgLy8gJ25vbmUnXHJcbiAgICogZWxlbS5jc3Moe1xyXG4gICAqICAgZGlzcGxheTogJ2lubGluZScsICAgICAgICAgLy8gZGlzcGxheSBzZXQgdG8gJ2lubGluZSdcclxuICAgKiAgIGN1cnNvcjogJ3BvaW50ZXInICAgICAgICAgIC8vIGN1cnNvciBzZXQgdG8gJ3BvaW50ZXInXHJcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXHJcbiAgICogZWxlbS5jc3MoKS4kOyAgICAgICAgICAgICAgICAvLyB7IGRpc3BsYXk6ICdub25lJywgY3Vyc29yOiAncG9pbnRlcicgfVxyXG4gICAqL1xyXG4gIGNzcyhwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGxldCBzdHlsZSA9IGdldEVsZW0odGhpcykuc3R5bGU7XHJcblxyXG4gICAgaWYgKGlzU3R5bGVSdWxlKHRoaXMuJFswXSkpIHtcclxuICAgICAgc3R5bGUgPSB0aGlzLiRbMF0uc3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU3RyKHN0eWxlLmNzc1RleHQpXHJcbiAgICAgICAgLnNwbGl0KC87ID8vKVxyXG4gICAgICAgIC5vYmplY3QoKG8sIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdCgvOiAvKTtcclxuXHJcbiAgICAgICAgICAgIG9bbmV3IFN0cihwcm9wZXJ0eVswXSkudG9DYW1lbENhc2UoKS4kXSA9IHByb3BlcnR5WzFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcocHJvcGVydHkpKSB7XHJcbiAgICAgIHByb3BlcnR5ID0gbmV3IFN0cihwcm9wZXJ0eSkudG9IeXBoZW5DYXNlKCkuJDtcclxuXHJcbiAgICAgIHJldHVybiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSArIChzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHByb3BlcnR5KSA/ICcgIWltcG9ydGFudCcgOiAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtKSAmJiAhaXNTdHlsZVJ1bGUoZWxlbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5ldyBTdXBlcihwcm9wZXJ0eSkuZm9yRWFjaCgodmFsdWUsIHByb3BlcnR5KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUNTUyhwcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9wZXJ0eSA9IG5ldyBTdHIocHJvcGVydHkpLnRvSHlwaGVuQ2FzZSgpLiQ7XHJcblxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZShuZXcgRWxlbShlbGVtKS5jc3MocHJvcGVydHkpLCBlbGVtLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNOaWwodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQXR0cihrZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XHJcbiAgICAgICAgZWxlbS5zdHlsZS5zZXRQcm9wZXJ0eShcclxuICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgdmFsdWUucmVwbGFjZSgvID8haW1wb3J0YW50JC8sICcnKSxcclxuICAgICAgICAgIC8haW1wb3J0YW50JC8udGVzdCh2YWx1ZSkgPyAnaW1wb3J0YW50JyA6ICcnXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNjdHhcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEN0eENhbGxiYWNrfSBbcHJvcGVydHldIC0gSWYgcHJlc2VudCBhbmQgb2JqZWN0XHJcbiAgICogaXQncyBhc3NpZ25lZCB0byB0aGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0LCBpZiBmdW5jdGlvblxyXG4gICAqIGl0J3MgY2FsbGVkIHdpdGggY2FudmFzIHJlbmRlcmluZyBjb250ZXh0IGFyZ3VtZW50LCBpZiBzdHJpbmdcclxuICAgKiB0aGUgdmFsdWUgZnJvbSB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHVzZWQgZm9yIGFzc2lnbmluZ1xyXG4gICAqIHRoaXMgcHJvcGVydHkgdG8gY2FudmFzIHJlbmRlcmluZyBjb250ZXh0IGFuZCBpZiBub3QgcHJlc2VudFxyXG4gICAqIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dCByZXR1cm5lZC5cclxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBTZWUgdGhlIHByb3BlcnR5IGFyZ3VtZW50LlxyXG4gICAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8RWxlbX1cclxuICAgKiBAZGVzY3JpcHRpb24gUmVuZGVyaW5nIGNvbnRleHQgb2YgdGhlIGZpcnN0IGNhbnZhcyBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjYW52YXMuY3R4OyAvLyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgKi9cclxuICBjdHgocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICBsZXQgY3R4O1xyXG5cclxuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoZ2V0TmFtZShlbGVtKSA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgICBjdHggPSBlbGVtLmR3YXluZURhdGEuY3R4O1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjdHgpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24ocHJvcGVydHkpKSB7XHJcbiAgICAgIHByb3BlcnR5KGN0eCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFzc2lnbihjdHgsIHByb3BlcnR5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNkYXRhXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2s+fSBba2V5XSAtIE5hbWUgb2YgdGhlIGRhdGEgYXR0cmlidXRlICh3aXRob3V0IGRhdGEtIHByZWZpeClcclxuICAgKiB0byBnZXQgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtYXQgeyBbYXR0ck5hbWVdOiB2YWx1ZSwgLi4uIH0gdG8gc2V0IGF0dHJpYnV0ZXMuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2t9IFt2YWx1ZV0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGEgdmFsdWUgdG8gc2V0IGZvciB0aGF0IGF0dHJpYnV0ZS5cclxuICAgKiBAcmV0dXJucyB7U3VwZXJ8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBkYXRhc2V0IG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxyXG4gICAqIGlmIDEgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgYXR0cmlidXRlIHJldHVybmVkIG90aGVyd2lzZSByZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGRhdGEgYXR0cmlidXRlcy4gU2VlXHJcbiAgICogW0hUTUxFbGVtZW50I2RhdGFzZXRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9kYXRhc2V0fS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScsICd2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTEnIGFuZCB0aGlzIHJldHVybmVkXHJcbiAgICogZWxlbS5kYXRhKCdzb21lS2V5MScpOyAgICAgICAgICAvLyAndmFsdWUxJ1xyXG4gICAqIGVsZW0uZGF0YSh7XHJcbiAgICogICBzb21lS2V5MTogJ3ZhbHVlMycsICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTEgc2V0IHRvICd2YWx1ZTMnXHJcbiAgICogICBzb21lS2V5MjogJ3ZhbHVlMicgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZGF0YS1zb21lLWtleTIgc2V0IHRvICd2YWx1ZTInXHJcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXHJcbiAgICogZWxlbS5kYXRhKCkuJDsgICAgICAgICAgICAgICAgICAvLyB7IHNvbWVLZXkxOiAndmFsdWUzJywgc29tZUtleTI6ICd2YWx1ZTInIH1cclxuICAgKi9cclxuICBkYXRhKGtleSwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGRhdGFzZXQgPSBnZXRFbGVtKHRoaXMpLmRhdGFzZXQ7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU3VwZXIoZGF0YXNldCkub2JqZWN0KChvLCB2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgb1trZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzU3RyaW5nKGtleSkpIHtcclxuICAgICAgcmV0dXJuIGRhdGFzZXRba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGtleSA9IHsgW2tleV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZXJhdGUoa2V5LCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGVsZW0uZGF0YXNldFtrZXldID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZShlbGVtLmRhdGFzZXRba2V5XSwgZWxlbSwgaW5kZXgpIDogdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZGF0YVVSTFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZSA9ICdpbWFnZS9wbmcnXSAtIFNlZSB0aGUgbGlua1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5jb2Rlck9wdGlvbnMgPSAwLjkyXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBEYXRhIFVSTCBmb3IgdGhlIGZpcnN0IGNhbnZhcyBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9EYXRhVVJMXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0hUTUxDYW52YXNFbGVtZW50I3RvRGF0YVVSTF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNhbnZhcy5kYXRhVVJMKCk7XHJcbiAgICovXHJcbiAgZGF0YVVSTCh0eXBlLCBlbmNvZGVyT3B0aW9ucykge1xyXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHgoKTtcclxuXHJcbiAgICBpZiAoIWN0eCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN0eC5jYW52YXMudG9EYXRhVVJMLmFwcGx5KGN0eC5jYW52YXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZGVsZXRlUnVsZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWxldGluZyBjc3Mgc3R5bGVzIGluIGEgc3R5bGUgdGFnLlxyXG4gICAqIE5vdGU6IHN0eWxlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2lkZSB0aGUgZG9jdW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHN0eWxlLmRlbGV0ZVJ1bGUoJ2ltZy1zaXplJyk7XHJcbiAgICovXHJcbiAgZGVsZXRlUnVsZShuYW1lKSB7XHJcbiAgICB0aGlzLnNvbWUoKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICBjb25zdCBydWxlID0gbmV3IEFycihlbGVtLnNoZWV0LmNzc1J1bGVzKS5maW5kKChydWxlKSA9PiBydWxlLmR3YXluZURhdGEgJiYgcnVsZS5kd2F5bmVEYXRhLm5hbWUgPT09IG5hbWUpO1xyXG5cclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgZWxlbS5zaGVldC5kZWxldGVSdWxlKHJ1bGUua2V5KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2Rpc3BhdGNoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fSBldmVudCAtIEV2ZW50IG9yIGEgc3RyaW5nIChuZXcgRXZlbnQoZXZlbnQpIGlzIGNyZWF0ZWQpLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRJbml0ID0ge31dIC0gU2VlIHRoZSBsaW5rLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2V2ZW50SW5pdC5idWJibGVzID0gdHJ1ZV0gLSBTZWUgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZXZlbnRJbml0LmNhbmNlbGFibGUgPSB0cnVlXSAtIFNlZSB0aGUgbGluay5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2RldGFpbHMgPSB7fV0gLSBPYmplY3QgdGhhdCBpcyBhc3NpZ25lZCB0byB0aGUgZXZlbnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FdmVudC9FdmVudFxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtFdmVudFRhcmdldCNkaXNwYXRjaEV2ZW50XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvZGlzcGF0Y2hFdmVudH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJyk7XHJcbiAgICogZWxlbS5kaXNwYXRjaCgnY2xpY2snLCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxsYWJsZTogZmFsc2UgfSk7XHJcbiAgICogZWxlbS5kaXNwYXRjaChuZXcgQ3VzdG9tRXZlbnQoJ2N1c3RvbS1ldmVudCcpKTtcclxuICAgKi9cclxuICBkaXNwYXRjaChldmVudCwgZXZlbnRJbml0ID0ge30sIGRldGFpbHMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBidWJibGVzID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUgfSA9IGV2ZW50SW5pdCB8fCB7fTtcclxuICAgIGxldCBmaW5hbEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgaWYgKCEvRXZlbnQkLy50ZXN0KHRvU3RyaW5nVGFnKGZpbmFsRXZlbnQpKSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZpbmFsRXZlbnQgPSBuZXcgRXZlbnQoZmluYWxFdmVudCwgeyBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBmaW5hbEV2ZW50ID0gbmF0aXZlRG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhc3NpZ24oZmluYWxFdmVudCwgZGV0YWlscyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGZpbmFsRXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNlbGVtXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXggPSAwXSAtIEluZGV4IG9mIHRoZSBlbGVtZW50IG9mIHRoZSBzZXQgdG8gZ2V0LiBOZWdhdGl2ZSBpbmRleCBtZWFucyBlbGVtLmxlbmd0aCArIGluZGV4LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5lbGVtKDEpOyAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAxXHJcbiAgICogZWxlbS5lbGVtKCk7ICAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAwXHJcbiAgICovXHJcbiAgZWxlbShpbmRleCA9IDApIHtcclxuICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCArIGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzLiRbaW5kZXhdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNmaWx0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258RWxlbWVudFtdfEVsZW19IFtzZWxlY3RvciA9IEJvb2xlYW5dIC0gSWYgaXQncyBhIHN0cmluZyB0aGUgbWV0aG9kIGZpbHRlcnMgZWxlbWVudHMgd2l0aCB0aGUgc2VsZWN0b3JcclxuICAgKiBvdGhlcndpc2Ugc3VwZXIuZmlsdGVyIGlzIGNhbGxlZC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmZpbHRlcigoZWxlbSkgPT4gbmV3IEVsZW0oZWxlbSkuY2xvc2VzdCgnLnBhcmVudCcpKTtcclxuICAgKiBlbGVtLmZpbHRlcihlbGVtc0luQXJyYXkpO1xyXG4gICAqIGVsZW0uZmlsdGVyKGVsZW1zSW5FbGVtKTtcclxuICAgKiBlbGVtLmZpbHRlcignLmNoaWxkJyk7XHJcbiAgICovXHJcbiAgZmlsdGVyKHNlbGVjdG9yID0gQm9vbGVhbikge1xyXG4gICAgcmV0dXJuIG5ldyBFbGVtKHN1cGVyLmZpbHRlcihmaWx0ZXJTd2l0Y2hlcihzZWxlY3RvcikpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNmaW5kXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXHJcbiAgICogQHJldHVybnMge0VsZW18eyBrZXk6IEtleSwgdmFsdWU6ICogfXxudWxsfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbSBpZiBzZWxlY3RvciBpcyBhIHN0cmluZ1xyXG4gICAqIG90aGVyd2lzZSBzdXBlci5maW5kIGlzIGNhbGxlZC5cclxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICAgKiBbRWxlbWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cclxuICAgKi9cclxuICBmaW5kKHNlbGVjdG9yKSB7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xyXG4gICAgICByZXR1cm4gc3VwZXIuZmluZChzZWxlY3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICBlbGVtcy5hZGQoZmluZChzZWxlY3RvciwgZWxlbSkpO1xyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZmlyc3RcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBlbGVtLmVsZW0oMCkuXHJcbiAgICovXHJcbiAgZmlyc3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbGVtKDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2ZpcnN0Q2hpbGRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RvciA9IG51bGxdIC0gSWYgcHJlc2VudCwgZmluZHMgZmlyc3QgY2hpbGQgaW4gZXZlcnkgZWxlbSB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxyXG4gICAqIElmIG5vdCwgZmluZHMgZmlyc3QgY2hpbGQgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgZmlyc3QgY2hpbGRyZW4gb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uZmlyc3QoKTsgICAgICAgLy8gZmluZHMgZmlyc3QgY2hpbGQgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBlbGVtIHNldFxyXG4gICAqIGVsZW0uZmlyc3QoJy5mb28nKTsgLy8gZmluZCBmaXJzdCBjaGlsZCB0aGF0IGhhcyBmb28gY2xhc3Mgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKi9cclxuICBmaXJzdENoaWxkKHNlbGVjdG9yID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCB7IHZhbHVlOiBmb3VuZCB9ID0gbmV3IEVsZW0oZWxlbSlcclxuICAgICAgICAuY2hpbGRyZW4oKVxyXG4gICAgICAgIC5maW5kKChlbGVtKSA9PiBuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcikpIHx8IHt9O1xyXG5cclxuICAgICAgZWxlbXMuYWRkKGZvdW5kKTtcclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2ZvY3VzXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9mb2N1c1xyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxyXG4gICAqIFtIVE1MRWxlbWVudCNmb2N1c117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L2ZvY3VzfS5cclxuICAgKi9cclxuICBmb2N1cygpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIGVsZW0uZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jZ2V0UnVsZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAgICogQHJldHVybnMge3sgc2VsZWN0b3I6IChTdHJpbmd8dm9pZCksIHJ1bGVzOiBPYmplY3QgfX0gU2V0IG9mIHRoZSBjc3MgcnVsZXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBzZXQgb2YgdGhlIHJ1bGVzIHVuZGVyIHRoZSBuYW1lLlxyXG4gICAqIE5vdGU6IHN0eWxlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2lkZSB0aGUgZG9jdW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHN0eWxlLmFkZFJ1bGUoJ2ltZy1zaXplJywgJ2ltZy5zcXVhcmUnLCB7XHJcbiAgICogICB3aWR0aDogJzQwcHgnLFxyXG4gICAqICAgaGVpZ2h0OiAnNDBweCdcclxuICAgKiB9KTtcclxuICAgKiBzdHlsZS5nZXRSdWxlKCdpbWctc2l6ZScpO1xyXG4gICAqIC8vIHtcclxuICAgKiAvLyAgIHNlbGVjdG9yOiAnaW1nLnNxdWFyZScsXHJcbiAgICogLy8gICBydWxlczoge1xyXG4gICAqIC8vICAgICB3aWR0aDogJzQwcHgnLFxyXG4gICAqIC8vICAgICBoZWlnaHQ6ICc0MHB4J1xyXG4gICAqIC8vICAgfVxyXG4gICAqIC8vIH1cclxuICAgKi9cclxuICBnZXRSdWxlKG5hbWUpIHtcclxuICAgIGxldCBmb3VuZCA9IHtcclxuICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZCxcclxuICAgICAgcnVsZXM6IHt9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoZ2V0TmFtZShlbGVtKSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHJ1bGUgfSA9IG5ldyBBcnIoZWxlbS5zaGVldC5jc3NSdWxlcykuZmluZCgocnVsZSkgPT4gcnVsZS5kd2F5bmVEYXRhICYmIHJ1bGUuZHdheW5lRGF0YS5uYW1lID09PSBuYW1lKSB8fCB7fTtcclxuXHJcbiAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgIGZvdW5kID0ge1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogcnVsZS5zZWxlY3RvclRleHQsXHJcbiAgICAgICAgICAgIHJ1bGVzOiBuZXcgRWxlbShydWxlKS5jc3MoKS4kXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2hhc0F0dHJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBhdHRyaWJ1dGUuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGF0dHJpYnV0ZSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYXR0cignYXR0cicsICd2YWx1ZScpLmhhc0F0dHIoJ2F0dHInKTsgLy8gdHJ1ZVxyXG4gICAqIGVsZW0ucmVtb3ZlQXR0cignYXR0cicpLmhhc0F0dHIoJ2F0dHInKTsgICAgLy8gZmFsc2VcclxuICAgKi9cclxuICBoYXNBdHRyKGF0dHIpIHtcclxuICAgIGNvbnN0IGVsZW0gPSBnZXRFbGVtKHRoaXMpO1xyXG4gICAgY29uc3QgbnMgPSBhdHRyTlNTd2l0Y2hlcihhdHRyLCBbbmV3IEVsZW0oZWxlbSldKTtcclxuXHJcbiAgICByZXR1cm4gaXNOdWxsKG5zKVxyXG4gICAgICA/IGVsZW0uaGFzQXR0cmlidXRlKGF0dHIpXHJcbiAgICAgIDogZWxlbS5oYXNBdHRyaWJ1dGVOUyhucywgYXR0cik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQ2xhc3NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNscyAtIE5hbWUgb2YgdGhlIGNsYXNzLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3MuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGNsYXNzIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJykuaGFzQ2xhc3MoJ2NscycpOyAgICAvLyB0cnVlXHJcbiAgICogZWxlbS5yZW1vdmVDbGFzcygnY2xzJykuaGFzQ2xhc3MoJ2NscycpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGhhc0NsYXNzKGNscykge1xyXG4gICAgcmV0dXJuIGdldEVsZW0odGhpcykuY2xhc3NMaXN0LmNvbnRhaW5zKGNscyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaGVpZ2h0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7KnxFbGVtVmFsdWVDYWxsYmFja30gW2hlaWdodF0gLSBIZWlnaHQgdG8gc2V0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgbm8gYXJndW1lbnRzIHBhc3NlZCBoZWlnaHQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cclxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIGhlaWdodHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSBoZWlnaHQgYXJndW1lbnQuXHJcbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyBoZWlnaHQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uaGVpZ2h0KDEyMyk7XHJcbiAgICogZWxlbS5oZWlnaHQoKTsgLy8gMTIzXHJcbiAgICovXHJcbiAgaGVpZ2h0KGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvcC5hcHBseSh0aGlzLCBuZXcgQXJyKGFyZ3VtZW50cykudW5zaGlmdCgnaGVpZ2h0JykuJCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaGlkZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBIaWRlcyBhbGwgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5oaWRlKCk7XHJcbiAgICovXHJcbiAgaGlkZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xyXG5cclxuICAgICAgY29uc3QgY3VycmVudERpc3BsYXkgPSBlbGVtLmNzcygnZGlzcGxheScpO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnREaXNwbGF5LmluZGV4T2YoJ25vbmUnKSkge1xyXG4gICAgICAgIGVsZW0ucHJvcCgnZHdheW5lRGF0YScpLnByZXZpb3VzRGlzcGxheSA9IGN1cnJlbnREaXNwbGF5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtLmNzcygnZGlzcGxheScsICdub25lICFpbXBvcnRhbnQnKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2h0bWxcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2t8Kn0gW2h0bWxdIC0gSFRNTCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgSFRNTC5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgSFRNTCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxyXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgSFRNTCBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIGh0bWwgYXJndW1lbnQuXHJcbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyBIVE1MLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmh0bWwoJzxkaXY+MTwvZGl2PicpO1xyXG4gICAqIGVsZW0uaHRtbCgpOyAvLyAnPGRpdj4xPC9kaXY+J1xyXG4gICAqL1xyXG4gIGh0bWwoaHRtbCkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBnZXRFbGVtKHRoaXMpLmlubmVySFRNTDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgZWxlbS5pbm5lckhUTUwgPSBpc0Z1bmN0aW9uKGh0bWwpID8gaHRtbChlbGVtLmlubmVySFRNTCwgZWxlbSwgaW5kZXgpIDogaHRtbDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaWRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW2lkXSAtIElkIHRvIHNldC5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgaWQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cclxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIGlkcyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIGlkIGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIGlkIG9yIHNldHMgaWRzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmlkKCd1bmlxdWUnKTtcclxuICAgKiBlbGVtLmlkKCk7IC8vICd1bmlxdWUnXHJcbiAgICovXHJcbiAgaWQoaWQpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZ2V0RWxlbSh0aGlzKS5pZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbSkpIHtcclxuICAgICAgICBlbGVtLmlkID0gaWQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7TnVtYmVyfSBFbGVtI2lubmVySGVpZ2h0XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIEdldHRlciBmb3IgZmluZGluZyBob3cgbXVjaCBoZWlnaHQgY29udGVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCBjYW4gYmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uY3NzKHtcclxuICAgKiAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAqICAgaGVpZ2h0OiAnMjAwcHgnLFxyXG4gICAqICAgcGFkZGluZ1RvcDogJzJweCcsXHJcbiAgICogICBwYWRkaW5nQm90dG9tOiAnM3B4JyxcclxuICAgKiAgIGJvcmRlclRvcDogJzFweCBzb2xpZCBibGFjaycsXHJcbiAgICogICBib3JkZXJCb3R0b206ICc0cHggc29saWQgYmxhY2snXHJcbiAgICogfSkuaW5uZXJIZWlnaHQ7IC8vIDE5MFxyXG4gICAqIGVsZW1cclxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAnY29udGVudC1ib3gnKVxyXG4gICAqICAgLmlubmVySGVpZ2h0OyAvLyAyMDBcclxuICAgKiBlbGVtXHJcbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ3BhZGRpbmctYm94JylcclxuICAgKiAgIC5pbm5lckhlaWdodDsgLy8gMTk1XHJcbiAgICovXHJcbiAgZ2V0IGlubmVySGVpZ2h0KCkge1xyXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuJFswXTtcclxuXHJcbiAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuICAgICAgcmV0dXJuIGVsZW0uaW5uZXJIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBib3JkZXJUb3BXaWR0aCxcclxuICAgICAgYm9yZGVyQm90dG9tV2lkdGgsXHJcbiAgICAgIGJveFNpemluZyxcclxuICAgICAgaGVpZ2h0LFxyXG4gICAgICBwYWRkaW5nVG9wLFxyXG4gICAgICBwYWRkaW5nQm90dG9tXHJcbiAgICB9ID0gdGhpcy5jYWxjQ1NTKCk7XHJcbiAgICBjb25zdCBib3JkZXJzID0gcHgoYm9yZGVyVG9wV2lkdGgpICsgcHgoYm9yZGVyQm90dG9tV2lkdGgpO1xyXG4gICAgY29uc3QgcGFkZGluZ3MgPSBweChwYWRkaW5nVG9wKSArIHB4KHBhZGRpbmdCb3R0b20pO1xyXG5cclxuICAgIHJldHVybiBweChoZWlnaHQpIC0gaW5uZXJTd2l0Y2hlcihib3hTaXppbmcsIFtwYWRkaW5ncywgYm9yZGVyc10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7TnVtYmVyfSBFbGVtI2lubmVyV2lkdGhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gR2V0dGVyIGZvciBmaW5kaW5nIGhvdyBtdWNoIHdpZHRoIGNvbnRlbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgY2FuIGJlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmNzcyh7XHJcbiAgICogICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgKiAgIHdpZHRoOiAnMjAwcHgnLFxyXG4gICAqICAgcGFkZGluZ0xlZnQ6ICcycHgnLFxyXG4gICAqICAgcGFkZGluZ1JpZ2h0OiAnM3B4JyxcclxuICAgKiAgIGJvcmRlckxlZnQ6ICcxcHggc29saWQgYmxhY2snLFxyXG4gICAqICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgYmxhY2snXHJcbiAgICogfSkuaW5uZXJXaWR0aDsgLy8gMTkwXHJcbiAgICogZWxlbVxyXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdjb250ZW50LWJveCcpXHJcbiAgICogICAuaW5uZXJXaWR0aDsgLy8gMjAwXHJcbiAgICogZWxlbVxyXG4gICAqICAgLmNzcygnYm94LXNpemluZycsICdwYWRkaW5nLWJveCcpXHJcbiAgICogICAuaW5uZXJXaWR0aDsgLy8gMTk1XHJcbiAgICovXHJcbiAgZ2V0IGlubmVyV2lkdGgoKSB7XHJcbiAgICBjb25zdCBlbGVtID0gdGhpcy4kWzBdO1xyXG5cclxuICAgIGlmIChpc1dpbmRvdyhlbGVtKSkge1xyXG4gICAgICByZXR1cm4gZWxlbS5pbm5lcldpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgYm9yZGVyTGVmdFdpZHRoLFxyXG4gICAgICBib3JkZXJSaWdodFdpZHRoLFxyXG4gICAgICBib3hTaXppbmcsXHJcbiAgICAgIHBhZGRpbmdMZWZ0LFxyXG4gICAgICBwYWRkaW5nUmlnaHQsXHJcbiAgICAgIHdpZHRoXHJcbiAgICB9ID0gdGhpcy5jYWxjQ1NTKCk7XHJcbiAgICBjb25zdCBib3JkZXJzID0gcHgoYm9yZGVyTGVmdFdpZHRoKSArIHB4KGJvcmRlclJpZ2h0V2lkdGgpO1xyXG4gICAgY29uc3QgcGFkZGluZ3MgPSBweChwYWRkaW5nTGVmdCkgKyBweChwYWRkaW5nUmlnaHQpO1xyXG5cclxuICAgIHJldHVybiBweCh3aWR0aCkgLSBpbm5lclN3aXRjaGVyKGJveFNpemluZywgW3BhZGRpbmdzLCBib3JkZXJzXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaW5zZXJ0QWZ0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGFmdGVyIG9yIGEgc2VsZWN0b3Igb2YgaXQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gUHV0cyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGFmdGVyIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgYXJndW1lbnQuXHJcbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XHJcbiAgICogZWxlbS5pbnNlcnRBZnRlcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XHJcbiAgICogZWxlbS5pbnNlcnRBZnRlcignI2lkIGRpdi5jMScpO1xyXG4gICAqL1xyXG4gIGluc2VydEFmdGVyKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQgPSB0b0ZpbmQoZWxlbWVudCkuZmlyc3QoKTtcclxuXHJcbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcclxuXHJcbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudCA9IGVsZW1lbnQubmV4dCgpLiRbMF07XHJcbiAgICBwYXJlbnQgPSBwYXJlbnQuJFswXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtLCBlbGVtZW50KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYmVmb3JlIG9yIGEgc2VsZWN0b3Igb2YgaXQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gUHV0cyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGJlZm9yZSB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50LlxyXG4gICAqIFRoZSBlbGVtZW50cyByZW1haW4gaW4gdGhlIHNhbWUgb3JkZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKGVsZW0yKTtcclxuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XHJcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoJyNpZCBkaXYuYzEnKTtcclxuICAgKi9cclxuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA9IHRvRmluZChlbGVtZW50KS5maXJzdCgpO1xyXG5cclxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xyXG5cclxuICAgIGlmICghcGFyZW50Lmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC4kWzBdO1xyXG4gICAgcGFyZW50ID0gcGFyZW50LiRbMF07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaW50b1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHB1dCB0aGlzIGVsZW1lbnRzIGludG8gb3IgYSBzZWxlY3RvciBvZiBpdC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCAtIElmIHRoZSBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIGVuZC4gSWYgZmFsc2UgdGhleSBhcmUgaW5zZXJ0ZWQgdG8gdGhlIHN0YXJ0LlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBzaW1pbGFyIHRvXHJcbiAgICogW05vZGUjYXBwZW5kQ2hpbGRde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Ob2RlL2FwcGVuZENoaWxkfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5pbnRvKGVsZW0yKTtcclxuICAgKiBlbGVtLmludG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xyXG4gICAqIGVsZW0uaW50bygnI2lkIGRpdi5jMScpO1xyXG4gICAqL1xyXG4gIGludG8oZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xyXG4gICAgZWxlbWVudCA9IHRvRmluZChlbGVtZW50KS4kWzBdO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIWVsZW1lbnQgfHxcclxuICAgICAgaXNXaW5kb3coZWxlbWVudCkgfHxcclxuICAgICAgaXNIVE1MRG9jdW1lbnQoZWxlbWVudCkgfHxcclxuICAgICAgaXNDb21tZW50T3JUZXh0KGVsZW1lbnQpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFlbmQgJiYgZWxlbWVudC5maXJzdENoaWxkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgLnNsaWNlKClcclxuICAgICAgICAucmV2ZXJzZSgpXHJcbiAgICAgICAgLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXHJcbiAgICogSWYgdGhlIHNlbGVjdG9yIGlzIHVuZGVmaW5lZCBvciBudWxsIGFsd2F5cyByZXR1cm5zIHRydWUuIElmIGl0J3Mgbm90IGZvciBub3QgZWxlbWVudHNcclxuICAgKiBlbnRyaWVzIHJldHVybnMgZmFsc2UuXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXHJcbiAgICogW0VsZW1lbnQjbWF0Y2hlc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlc30uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpO1xyXG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXHJcbiAgICpcclxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKTtcclxuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcclxuICAgKi9cclxuICBpcyhzZWxlY3Rvcikge1xyXG4gICAgaWYgKGlzTnVsbChzZWxlY3RvcikpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZWxlbSA9IGdldEVsZW0odGhpcyk7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gKFxyXG4gICAgICBlbGVtLm1hdGNoZXMgfHxcclxuICAgICAgZWxlbS5tYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgZWxlbS5tc01hdGNoZXNTZWxlY3RvciB8fFxyXG4gICAgICBlbGVtLm9NYXRjaGVzU2VsZWN0b3JcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFpc0VsZW1lbnQodGhpcy4kWzBdKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtLCBzZWxlY3Rvcik7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgU2VsZWN0b3IgJyR7IHNlbGVjdG9yIH0nIGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yIChFbGVtI2lzKWApO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2lzQnJva2VuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgaW1hZ2UgaW4gdGhlIHNldCBpcyBicm9rZW4uXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBpcyBicm9rZW4uIE5vdCBpbWFnZSBhbmQgbm90IGxvYWRlZCBpbWFnZSBpcyBjb25zaWRlcmVkIHByb3Blci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgaW1nID0gZWxlbS5pbWcoKS5vbih7XHJcbiAgICogICAnbG9hZCc6IG9ubG9hZCxcclxuICAgKiAgICdlcnJvcic6IG9ubG9hZFxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogb25sb2FkID0gKCkgPT4ge1xyXG4gICAqICAgY29uc29sZS5sb2coaW1nLmlzQnJva2VuKCkpOyAvLyB0cnVlXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIGltZy5yZWYoJy9zb21lL25vbi1leGlzdGVudC9zaXRlL25vdC1mb3VuZC5wbmcnKTtcclxuICAgKi9cclxuICBpc0Jyb2tlbigpIHtcclxuICAgIGxldCBpc0Jyb2tlbiA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc29tZSgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoZ2V0TmFtZShlbGVtKSA9PT0gJ2ltZycpIHtcclxuICAgICAgICBpc0Jyb2tlbiA9ICEhKGVsZW0uY29tcGxldGUgJiYgKCFlbGVtLm5hdHVyYWxXaWR0aCB8fCAhZWxlbS5uYXR1cmFsSGVpZ2h0KSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaXNCcm9rZW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jaXNXaXRoaW5Eb2N1bWVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBpZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGlzIHdpdGhpbiB0aGUgZG9jdW1lbnQgb3Igbm90LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgd2l0aGluIHRoZSBkb2N1bWVudCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpLmlzV2l0aGluRG9jdW1lbnQoKTsgIC8vIHRydWVcclxuICAgKiBuZXcgRWxlbShkb2N1bWVudCkuZGl2KCkuaXNXaXRoaW5Eb2N1bWVudCgpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGlzV2l0aGluRG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maXJzdCgpLmNsb3Nlc3QoJ2h0bWwnKS5sZW5ndGggIT09IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jbGFzdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yIGVsZW0uZWxlbSgtMSkuXHJcbiAgICovXHJcbiAgbGFzdCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW0oLTEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2xhc3RDaGlsZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yID0gbnVsbF0gLSBJZiBwcmVzZW50LCBmaW5kcyBsYXN0IGNoaWxkIGluIGV2ZXJ5IGVsZW0gdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cclxuICAgKiBJZiBub3QsIGZpbmRzIGxhc3QgY2hpbGQgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbGFzdCBjaGlsZHJlbiBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5sYXN0KCk7ICAgICAgIC8vIGZpbmRzIGxhc3QgY2hpbGQgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBlbGVtIHNldFxyXG4gICAqIGVsZW0ubGFzdCgnLmZvbycpOyAvLyBmaW5kIGxhc3QgY2hpbGQgdGhhdCBoYXMgJ2ZvbycgY2xhc3Mgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKi9cclxuICBsYXN0Q2hpbGQoc2VsZWN0b3IgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgdmFsdWU6IGZvdW5kIH0gPSBuZXcgRWxlbShlbGVtKVxyXG4gICAgICAgIC5jaGlsZHJlbigpXHJcbiAgICAgICAgLnJldmVyc2UoKVxyXG4gICAgICAgIC5maW5kKChlbGVtKSA9PiBuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcikpIHx8IHt9O1xyXG5cclxuICAgICAgZWxlbXMuYWRkKGZvdW5kKTtcclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI2xvYWRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPHsgcHJvcGVyOiBFbGVtLCBicm9rZW46IEVsZW0gfT59IFByb21pc2Ugd2l0aCBicm9rZW4gYW5kIHByb3BlciBpbWFnZXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIExvYWRzIGVhY2ggaW1hZ2UgaW4gdGhlIHNldCBhbmQgcHV0cyBpdCB0byB0aGUgcHJvcGVyIG9yIGJyb2tlbiBhcnJheS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogaW1hZ2VzLmxvYWQoKS50aGVuKCh7IGJyb2tlbiB9KSA9PiB7XHJcbiAgICogICBicm9rZW4uZmlsdGVyKCdpbWcnKS5yZWYoJy9mYWxsYmFjay5wbmcnKTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBsb2FkKCkge1xyXG4gICAgY29uc3QgaW1hZ2VzID0ge1xyXG4gICAgICBwcm9wZXI6IG5ldyBFbGVtKCksXHJcbiAgICAgIGJyb2tlbjogbmV3IEVsZW0oKVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXHJcbiAgICAgIHRoaXNcclxuICAgICAgICAuZmlsdGVyKChlbGVtKSA9PiBnZXROYW1lKGVsZW0pID09PSAnaW1nJylcclxuICAgICAgICAubWFwKChlbGVtKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCAkZWxlbSA9IG5ldyBFbGVtKGVsZW0pO1xyXG5cclxuICAgICAgICAgIGlmIChlbGVtLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIGltYWdlc1skZWxlbS5pc0Jyb2tlbigpID8gJ2Jyb2tlbicgOiAncHJvcGVyJ10ucHVzaChlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gJGVsZW0ub24oe1xyXG4gICAgICAgICAgICAgIGxvYWQoKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZXMucHJvcGVyLmFkZChlbGVtKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGVycm9yKCkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmJyb2tlbi5hZGQoZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLiRcclxuICAgICkudGhlbigoKSA9PiBpbWFnZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI21vdmVBdHRyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gQXR0cmlidXRlIHRvIG1vdmUgdG8gdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZSA9ICcnXSAtIFZhbHVlIHRvIHNldCBmb3IgdGhlIGF0dHJpYnV0ZS4gSWYgbm90IHNldCBhdHRyaWJ1dGUgb2YgdGhlIHByZXZpb3VzIGVsZW1lbnQgb3IgJycgdXNlZC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIG1vdmluZyBhbiBhdHRyaWJ1dGUgZnJvbSBwcmV2aW91cyBlbGVtZW50IHRvIHRoZSBuZXh0IG9uZSAoZmlyc3QgZWxlbWVudCBpbiB0aGlzIHNldCkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0xLm1vdmVBdHRyKCdhdHRyJywgJ3ZhbHVlJyk7ICAgICAvLyBhdHRyaWJ1dGUgJ2F0dHInIHNldCB0byAndmFsdWUnIG9uIGVsZW0xXHJcbiAgICogZWxlbTIubW92ZUF0dHIoJ2F0dHInKTsgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSAnYXR0cicgcmVtb3ZlZCBmcm9tIGVsZW0xLiBzZXQgdG8gJ3ZhbHVlJyBvbiBlbGVtMlxyXG4gICAqIGVsZW0zLm1vdmVBdHRyKCdhdHRyJywgJ25ldyB2YWx1ZScpOyAvLyBhdHRyaWJ1dGUgJ2F0dHInIHJlbW92ZWQgZnJvbSBlbGVtMi4gc2V0IHRvICduZXcgdmFsdWUnIG9uIGVsZW0zXHJcbiAgICovXHJcbiAgbW92ZUF0dHIoYXR0ciwgdmFsdWUgPSAnJykge1xyXG4gICAgY29uc3QgcHJldiA9IGF0dHJzW2F0dHJdO1xyXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuZWxlbSgpO1xyXG5cclxuICAgIGlmIChwcmV2ICYmIGVsZW0ubGVuZ3RoKSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIHZhbHVlID0gcHJldi5hdHRyKGF0dHIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmV2LnJlbW92ZUF0dHIoYXR0cik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW0ubGVuZ3RoKSB7XHJcbiAgICAgIGF0dHJzW2F0dHJdID0gZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNtb3ZlQ2xhc3NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNscyAtIENsYXNzIHRvIG1vdmUgdG8gdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBtb3ZpbmcgYSBjbGFzcyBmcm9tIHByZXZpb3VzIGVsZW1lbnQgdG8gdGhlIG5leHQgb25lIChmaXJzdCBlbGVtZW50IGluIHRoaXMgc2V0KS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbTEubW92ZUNsYXNzKCdjbHMnKTsgLy8gY2xhc3MgJ2NscycgYWRkZWQgdG8gZWxlbTFcclxuICAgKiBlbGVtMi5tb3ZlQ2xhc3MoJ2NscycpOyAvLyBjbGFzcyAnY2xzJyByZW1vdmVkIGZyb20gZWxlbTEuIGFkZGVkIHRvIGVsZW0xXHJcbiAgICovXHJcbiAgbW92ZUNsYXNzKGNscykge1xyXG4gICAgY29uc3QgcHJldiA9IGNsYXNzZXNbY2xzXTtcclxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLmVsZW0oKTtcclxuXHJcbiAgICBpZiAocHJldiAmJiBlbGVtLmxlbmd0aCkge1xyXG4gICAgICBwcmV2LnJlbW92ZUNsYXNzKGNscyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW0ubGVuZ3RoKSB7XHJcbiAgICAgIGNsYXNzZXNbY2xzXSA9IGVsZW0uYWRkQ2xhc3MoY2xzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge1N0cmluZ30gRWxlbSNuYW1lXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uIG5vZGVOYW1lIChsb3dlcmNhc2VkKSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBlbGVtMSA9IGVsZW0uY3JlYXRlKCdkaXYnKTtcclxuICAgKiBlbGVtMS5uYW1lIC8vICdkaXYnXHJcbiAgICovXHJcbiAgZ2V0IG5hbWUoKSB7XHJcbiAgICByZXR1cm4gZ2V0TmFtZSh0aGlzLiRbMF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI25leHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RvciA9IG51bGxdIC0gSWYgcHJlc2VudCwgZmluZHMgbmV4dCBlbGVtZW50IHRvIGV2ZXJ5IGVsZW0gdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cclxuICAgKiBJZiBub3QsIGZpbmRzIG5leHQgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBuZXh0IGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ubmV4dCgpOyAgICAgICAvLyBmaW5kcyBuZXh0IGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcclxuICAgKiBlbGVtLm5leHQoJy5mb28nKTsgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCB0aGF0IGhhcyAnZm9vJyBjbGFzc1xyXG4gICAqL1xyXG4gIG5leHQoc2VsZWN0b3IgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XHJcbiAgICAgIC8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xyXG4gICAgICB3aGlsZSAoZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICBpZiAobmV3IEVsZW0oZWxlbSkuaXMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWxlbXMuYWRkKGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jb2ZmXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uRWxlbUV2ZW50U3RyaW5nfSBldmVudHMgLSBFdmVudHMgdG8gcmVtb3ZlLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJlbW92ZXMgYWxsIHRoZSBsaXN0ZW5lcnMgZnJvbSBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBzcGVjaWZpZWQgYnkgdGhlIGV2ZW50cyBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ub2ZmKCdjbGljaycpO1xyXG4gICAqIGVsZW0ub2ZmKCdjbGljaywgaW5wdXQnKTtcclxuICAgKiBlbGVtLm9mZignY2xpY2ssIGlucHV0JywgJ2ZvY3VzJyk7XHJcbiAgICovXHJcbiAgb2ZmKC4uLmV2ZW50cykge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCB7IGxpc3RlbmVycyB9ID0gZWxlbS5kd2F5bmVEYXRhO1xyXG5cclxuICAgICAgaXRlcmF0ZShhcmd1bWVudHMsIChldmVudCkgPT4ge1xyXG4gICAgICAgIGl0ZXJhdGUoZXZlbnQuc3BsaXQoZXZlbnRTZXBhcmF0b3IpLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgIChsaXN0ZW5lcnNbZXZlbnRdIHx8IG5ldyBTdXBlcigpKS5mb3JFYWNoKCh7IHJlbW92ZUxpc3RlbmVyIH0pID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI29uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RWxlbUV2ZW50U3RyaW5nfE9iamVjdC48RWxlbUV2ZW50U3RyaW5nfEVsZW1MaXN0ZW5lcj59IGV2ZW50IC0gRWl0aGVyIGEge0BsaW5rIEVsZW1FdmVudFN0cmluZ30gc3RyaW5nXHJcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggZXZlbnQga2V5cyAoYSBrZXkgaXMgYWxzbyBFbGVtRXZlbnRTdHJpbmcpIGFuZCBsaXN0ZW5lcnMgdmFsdWVzLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3IgPSBudWxsXSAtIFNlbGVjdG9yIHRvIGZpbHRlciBldmVudCB0YXJnZXRzLlxyXG4gICAqIEBwYXJhbSB7RWxlbUxpc3RlbmVyfSBbbGlzdGVuZXJdIC0gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGl0IG11c3QgYmUgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3JcclxuICAgKiBzcGVjaWZpZWQgZXZlbnQocykuXHJcbiAgICogQHJldHVybnMge0VsZW1SZW1vdmVMaXN0ZW5lcnN9IEZ1bmN0aW9uIHRoYXQgdGFrZXMgb3B0aW9uYWwgZXZlbnQgYXJndW1lbnQuXHJcbiAgICogQGRlc2NyaXB0aW9uIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICogRm9yIGRlYnVnZ2luZzogSWYgeW91IG5lZWQgdG8ga25vdyB3aGF0IGxpc3RlbmVycyBhcmUgaW4gd29yayAoYW5kIHdoYXQgc2VsZWN0b3JzIGZpbHRlciB0YXJnZXRzKVxyXG4gICAqIHlvdSBjYW4gbG9vayBhdCB0aGUgYmFzZSBwcm9wZXJ0eSBvZiB0aGUgb25seSBkd2F5bmUgbGlzdGVuZXIgdGhhdCBsaXN0ZW5zIGZvciB0aGUgZXZlbnRcclxuICAgKiBhbmQgZmluZCBhbGwgd29ya2luZyBsaXN0ZW5lcnMgaW4gbGlzdGVuZXIuYmFzZS5kd2F5bmVEYXRhLmxpc3RlbmVyc1tldmVudF0uJC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5vbihcclxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcclxuICAgKiAgICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgZGF0YWxpc3QsIGtleWdlbiwgb3V0cHV0JyxcclxuICAgKiAgIChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSlcclxuICAgKiApO1xyXG4gICAqIGVsZW0ub24oXHJcbiAgICogICAnY2hhbmdlLCBpbnB1dCcsXHJcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXHJcbiAgICogKTtcclxuICAgKiBlbGVtLm9uKFxyXG4gICAqICAge1xyXG4gICAqICAgICAnY2hhbmdlLCBpbnB1dCc6IChlLCBlbGVtLCBpbmRleCkgPT4gY29uc29sZS5sb2coZWxlbS52YWx1ZSksXHJcbiAgICogICAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxyXG4gICAqICAgfSxcclxuICAgKiAgICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgZGF0YWxpc3QsIGtleWdlbiwgb3V0cHV0J1xyXG4gICAqICk7XHJcbiAgICpcclxuICAgKiBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBlbGVtLm9uKHtcclxuICAgKiAgICdjaGFuZ2UsIGlucHV0JzogKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKSxcclxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdjbGljaycpO1xyXG4gICAqIHJlbW92ZUxpc3RlbmVycygnYmx1ciwgY2hhbmdlJyk7XHJcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdibHVyLCBjaGFuZ2UnLCAnaW5wdXQnKTtcclxuICAgKiByZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgKi9cclxuICBvbihldmVudCwgc2VsZWN0b3IgPSBudWxsLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgYWxsTGlzdGVuZXJzID0gbmV3IFN1cGVyKHt9KTtcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcclxuICAgICAgbGlzdGVuZXIgPSBzZWxlY3RvcjtcclxuICAgICAgc2VsZWN0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1N0cmluZyhldmVudCkpIHtcclxuICAgICAgZXZlbnQgPSB7IFtldmVudF06IGxpc3RlbmVyIH07XHJcbiAgICB9XHJcblxyXG4gICAgZXZlbnQgPSBuZXcgU3VwZXIoZXZlbnQpLm9iamVjdCgobGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnQpID0+IHtcclxuICAgICAgaXRlcmF0ZShldmVudC5zcGxpdChldmVudFNlcGFyYXRvciksIChldmVudCkgPT4ge1xyXG4gICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcjtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbSkgJiYgIWlzV2luZG93KGVsZW0pICYmICFpc0hUTUxEb2N1bWVudChlbGVtKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgeyBsaXN0ZW5lcnMgfSA9ICh3aW5kb3dzRHdheW5lRGF0YS5maW5kKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudCA9PT0gZWxlbSkgfHwge30pLnZhbHVlIHx8IGVsZW0uZHdheW5lRGF0YTtcclxuXHJcbiAgICAgIGV2ZW50LmZvckVhY2goKGxpc3RlbmVyLCBldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyc1tldmVudF0gfHwgbmV3IFN1cGVyKHt9KS5kZWZpbmUoJ2luZGV4Jywge1xyXG4gICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMucHJvcCgnaW5kZXgnKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZW1vdmVFdmVudExpc3RlbmVycy5oYXMoJ2xpc3RlbmVyJykpIHtcclxuICAgICAgICAgIGNvbnN0IG5ld0xpc3RlbmVyID0gKGUpID0+IHtcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgoeyBzZWxlY3RvciwgbGlzdGVuZXIgfSkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChuZXcgRWxlbShlLnRhcmdldCkuaXMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGVsZW0sIGUsIGVsZW0sIGluZGV4KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBuZXdMaXN0ZW5lci5iYXNlID0gZWxlbTtcclxuXHJcbiAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG5ld0xpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVycy5kZWZpbmUoJ2xpc3RlbmVyJywge1xyXG4gICAgICAgICAgICB2YWx1ZTogbmV3TGlzdGVuZXIsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVycy5kZWxldGUoaW5kZXgpO1xyXG5cclxuICAgICAgICAgIGlmICghcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuY291bnQpIHtcclxuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCByZW1vdmVFdmVudExpc3RlbmVycy5wcm9wKCdsaXN0ZW5lcicpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzLmRlbGV0ZSgnbGlzdGVuZXInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBhbGxMaXN0ZW5lcnMucHJvcChldmVudCwgKGFsbExpc3RlbmVycy5wcm9wKGV2ZW50KSB8fCBuZXcgQXJyKCkpLnB1c2gocmVtb3ZlTGlzdGVuZXIpKTtcclxuXHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuYXNzaWduKHtcclxuICAgICAgICAgIGluZGV4OiBpbmRleCArIDEsXHJcbiAgICAgICAgICBbaW5kZXhdOiB7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yLFxyXG4gICAgICAgICAgICBsaXN0ZW5lcixcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZXZlbnQpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICBpdGVyYXRlKGV2ZW50LnNwbGl0KGV2ZW50U2VwYXJhdG9yKSwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhbGxMaXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgIGFsbExpc3RlbmVycy5wcm9wKGV2ZW50KS5mb3JFYWNoKChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XHJcbiAgICAgICAgICAgICAgYWxsTGlzdGVuZXJzLmRlbGV0ZShldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFsbExpc3RlbmVycy5mb3JFYWNoKChyZW1vdmVMaXN0ZW5lcnMpID0+IHtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcnMuZm9yRWFjaCgocmVtb3ZlTGlzdGVuZXIpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IEVsZW0jb3V0ZXJIZWlnaHRcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gR2V0dGVyIGZvciBmaW5kaW5nIGhvdyBtdWNoIGhlaWdodCB0aGUgZWxlbWVudCBhY3R1YWxseSBpcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5jc3Moe1xyXG4gICAqICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICogICBoZWlnaHQ6ICcyMDBweCcsXHJcbiAgICogICBwYWRkaW5nVG9wOiAnMnB4JyxcclxuICAgKiAgIHBhZGRpbmdCb3R0b206ICczcHgnLFxyXG4gICAqICAgYm9yZGVyVG9wOiAnMXB4IHNvbGlkIGJsYWNrJyxcclxuICAgKiAgIGJvcmRlckJvdHRvbTogJzRweCBzb2xpZCBibGFjaydcclxuICAgKiAgIG1hcmdpblRvcDogJzBweCcsXHJcbiAgICogICBtYXJnaW5Cb3R0b206ICc1cHgnXHJcbiAgICogfSkub3V0ZXJIZWlnaHQ7IC8vIDIwNVxyXG4gICAqIGVsZW1cclxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAnY29udGVudC1ib3gnKVxyXG4gICAqICAgLm91dGVySGVpZ2h0OyAvLyAyMTVcclxuICAgKiBlbGVtXHJcbiAgICogICAuY3NzKCdib3gtc2l6aW5nJywgJ3BhZGRpbmctYm94JylcclxuICAgKiAgIC5vdXRlckhlaWdodDsgLy8gMjEwXHJcbiAgICovXHJcbiAgZ2V0IG91dGVySGVpZ2h0KCkge1xyXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuJFswXTtcclxuXHJcbiAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuICAgICAgcmV0dXJuIGVsZW0ub3V0ZXJIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBib3JkZXJUb3BXaWR0aCxcclxuICAgICAgYm9yZGVyQm90dG9tV2lkdGgsXHJcbiAgICAgIGJveFNpemluZyxcclxuICAgICAgaGVpZ2h0LFxyXG4gICAgICBtYXJnaW5Ub3AsXHJcbiAgICAgIG1hcmdpbkJvdHRvbSxcclxuICAgICAgcGFkZGluZ1RvcCxcclxuICAgICAgcGFkZGluZ0JvdHRvbVxyXG4gICAgfSA9IHRoaXMuY2FsY0NTUygpO1xyXG4gICAgY29uc3QgYm9yZGVycyA9IHB4KGJvcmRlclRvcFdpZHRoKSArIHB4KGJvcmRlckJvdHRvbVdpZHRoKTtcclxuICAgIGNvbnN0IHBhZGRpbmdzID0gcHgocGFkZGluZ1RvcCkgKyBweChwYWRkaW5nQm90dG9tKTtcclxuXHJcbiAgICByZXR1cm4gcHgoaGVpZ2h0KSArIHB4KG1hcmdpblRvcCkgKyBweChtYXJnaW5Cb3R0b20pICsgb3V0ZXJTd2l0Y2hlcihib3hTaXppbmcsIFtib3JkZXJzLCBwYWRkaW5nc10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7TnVtYmVyfSBFbGVtI291dGVyV2lkdGhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVzY3JpcHRpb24gR2V0dGVyIGZvciBmaW5kaW5nIGhvdyBtdWNoIHdpZHRoIHRoZSBlbGVtZW50IGFjdHVhbGx5IGlzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLmNzcyh7XHJcbiAgICogICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgKiAgIHdpZHRoOiAnMjAwcHgnLFxyXG4gICAqICAgcGFkZGluZ0xlZnQ6ICcycHgnLFxyXG4gICAqICAgcGFkZGluZ1JpZ2h0OiAnM3B4JyxcclxuICAgKiAgIGJvcmRlckxlZnQ6ICcxcHggc29saWQgYmxhY2snLFxyXG4gICAqICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgYmxhY2snXHJcbiAgICogICBtYXJnaW5MZWZ0OiAnMHB4JyxcclxuICAgKiAgIG1hcmdpblJpZ2h0OiAnNXB4J1xyXG4gICAqIH0pLm91dGVyV2lkdGg7IC8vIDIwNVxyXG4gICAqIGVsZW1cclxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAnY29udGVudC1ib3gnKVxyXG4gICAqICAgLm91dGVyV2lkdGg7IC8vIDIxNVxyXG4gICAqIGVsZW1cclxuICAgKiAgIC5jc3MoJ2JveC1zaXppbmcnLCAncGFkZGluZy1ib3gnKVxyXG4gICAqICAgLm91dGVyV2lkdGg7IC8vIDIxMFxyXG4gICAqL1xyXG4gIGdldCBvdXRlcldpZHRoKCkge1xyXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuJFswXTtcclxuXHJcbiAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuICAgICAgcmV0dXJuIGVsZW0ub3V0ZXJXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGJvcmRlckxlZnRXaWR0aCxcclxuICAgICAgYm9yZGVyUmlnaHRXaWR0aCxcclxuICAgICAgYm94U2l6aW5nLFxyXG4gICAgICBtYXJnaW5MZWZ0LFxyXG4gICAgICBtYXJnaW5SaWdodCxcclxuICAgICAgcGFkZGluZ0xlZnQsXHJcbiAgICAgIHBhZGRpbmdSaWdodCxcclxuICAgICAgd2lkdGhcclxuICAgIH0gPSB0aGlzLmNhbGNDU1MoKTtcclxuICAgIGNvbnN0IGJvcmRlcnMgPSBweChib3JkZXJMZWZ0V2lkdGgpICsgcHgoYm9yZGVyUmlnaHRXaWR0aCk7XHJcbiAgICBjb25zdCBwYWRkaW5ncyA9IHB4KHBhZGRpbmdMZWZ0KSArIHB4KHBhZGRpbmdSaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHB4KHdpZHRoKSArIHB4KG1hcmdpbkxlZnQpICsgcHgobWFyZ2luUmlnaHQpICsgb3V0ZXJTd2l0Y2hlcihib3hTaXppbmcsIFtib3JkZXJzLCBwYWRkaW5nc10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3BhcmVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCByZXR1cm5zIHdyYXAgb2YgdGhlIHNldCBvZiB0aGUgcGFyZW50IGVsZW1lbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqL1xyXG4gIHBhcmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm9iamVjdCgoZWxlbXMsIGVsZW0pID0+IGVsZW1zLmFkZChlbGVtLnBhcmVudE5vZGUpLCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRUcmVlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB3cmFwIG9mIGFsbCBwYXJlbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLnBhcmVudFRyZWUoKTsgLy8gRWxlbVxyXG4gICAqL1xyXG4gIHBhcmVudFRyZWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XHJcbiAgICAgIHdoaWxlIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgZWxlbXMuYWRkKGVsZW0pO1xyXG4gICAgICB9XHJcbiAgICB9LCBuZXcgRWxlbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNwcmV2XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3IgPSBudWxsXSAtIElmIHByZXNlbnQsIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZXZlcnkgZWxlbSB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxyXG4gICAqIElmIG5vdCwgZmluZHMgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZmluZGluZyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLm5leHQoKTsgICAgICAgLy8gZmluZHMgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxyXG4gICAqIGVsZW0ubmV4dCgnLmZvbycpOyAvLyBmaW5kcyBwcmV2aW91cyBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCB0aGF0IGhhcyAnZm9vJyBjbGFzc1xyXG4gICAqL1xyXG4gIHByZXYoc2VsZWN0b3IgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtKSA9PiB7XHJcbiAgICAgIC8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xyXG4gICAgICB3aGlsZSAoZWxlbSA9IGVsZW0ucHJldmlvdXNTaWJsaW5nKSB7XHJcbiAgICAgICAgaWYgKG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW1zLmFkZChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3Byb3BcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIEVsZW1WYWx1ZUNhbGxiYWNrfCo+fSBwcm9wZXJ0eSAtIEVpdGhlciBhIHN0cmluZyBvZiBhIHByb3BlcnR5IG9yIGFuIGFzc2lnbmVkIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge0VsZW1WYWx1ZUNhbGxiYWNrfCp9IFt2YWx1ZV0gLSBJZiBhIHByb3BlcnR5IHBhcmFtZXRlciBpcyBhIHN0cmluZ1xyXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cclxuICAgKiBAcmV0dXJucyB7RWxlbXwqfSBSZXR1cm5zIHRoaXMgaWYgaXQncyBzZXR0ZXIgb3IgYSB2YWx1ZSBpZiBnZXR0ZXIuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IGlzIGVpdGhlciBhIHByb3BlcnR5IGdldHRlciBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxyXG4gICAqIG9yIGEgc2V0dGVyIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJywgZmFsc2UpO1xyXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJyk7IC8vIGZhbHNlXHJcbiAgICovXHJcbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgJiYgaXNTdHJpbmcocHJvcGVydHkpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiRbMF0gPyB0aGlzLiRbMF1bcHJvcGVydHldIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaXRlcmF0ZShwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgZWxlbVtwcm9wXSA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUoZWxlbVtwcm9wXSwgZWxlbSwgaW5kZXgpIDogdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jcmVmXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1WYWx1ZUNhbGxiYWNrfSBbbGlua10gLSBJZiBpdCdzIHByZXNlbnQgbGluayB0byBhIHJlc291cmNlLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfFN0cmluZ30gSWYgdGhlIGxpbmsgYXJndW1lbnQgaXNuJ3QgcHJlc2VudCBpdCdzIGEgZ2V0dGVyIG9mIHRoZSAnc3JjJyBhdHRyaWJ1dGVcclxuICAgKiBmb3IgdGhlIG9uZSBvZiBmb2xsb3dpbmcgZWxlbWVudHM6IGltZywgc2NyaXB0LCBpZnJhbWUsIGF1ZGlvLCB2aWRlbzsgb2YgdGhlICdhY3Rpb24nIGF0dHJpYnV0ZVxyXG4gICAqIGZvciBhIGZvcm0gZWxlbWVudCBhbmQgb2YgdGhlICdocmVmJyBhdHRyaWJ1dGUgZm9yIHRoZSByZXN0LiBJZiBpdCdzIHByZXNlbnQgaXQncyBhIHNldHRlclxyXG4gICAqIG9mIHRoZSBzYW1lIGF0dHJpYnV0ZSBmb3IgYWxsIHRoZSBlbGVtZW50IGluIHRoZSBzZXQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyByZXNvdXJjZXMgbGlua3MgYW5kIHNldHRpbmcgdGhlbS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5yZWYoJy9zb21lL2Nvb2wvaW1hZ2UucG5nJyk7XHJcbiAgICogZWxlbS5yZWYoKTsgLy8gJy9zb21lL2Nvb2wvaW1hZ2UucG5nJ1xyXG4gICAqL1xyXG4gIHJlZihsaW5rKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cihyZWZTd2l0Y2hlcih0aGlzLm5hbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcclxuXHJcbiAgICAgIGVsZW0uYXR0cihyZWZTd2l0Y2hlcihlbGVtLm5hbWUpLCBsaW5rKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGZyb20gdGhlIGRvY3VtZW50LlxyXG4gICAqIE5vdGU6IGl0IGRvZXNuJ3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2V0IHNvIHdhdGNoIG91dCBmb3IgdGhlIG1lbW9yeSBsZWFrcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5yZW1vdmUoKTtcclxuICAgKi9cclxuICByZW1vdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUF0dHJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5yZW1vdmVBdHRyKCdmb28nLCAnYmFyJywgJ2JheicpO1xyXG4gICAqL1xyXG4gIHJlbW92ZUF0dHIoLi4uYXR0cmlidXRlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXRlcmF0ZShhcmd1bWVudHMsIChhdHRyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbnMgPSBhdHRyTlNTd2l0Y2hlcihhdHRyLCBbbmV3IEVsZW0oZWxlbSldKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVsbChucykpIHtcclxuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBhdHRyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ2xhc3NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGNsYXNzZXMgLSBDbGFzc2VzIHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgY2xhc3NlcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5yZW1vdmVDbGFzcygnZm9vJywgJ2JhcicsICdiYXonKTtcclxuICAgKi9cclxuICByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuXHJcbiAgICAgIGl0ZXJhdGUoaXNFbGVtZW50KGVsZW0pICYmIGFyZ3VtZW50cywgKGNscykgPT4gbGlzdC5yZW1vdmUoY2xzKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVDU1NcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IHByb3BzIC0gQ1NTIHByb3BlcnRpZXMgdG8gcmVtb3ZlLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBDU1MgcHJvcGVydGllcyBmcm9tIGFyZ3VtZW50cyBmcm9tIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNldC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5yZW1vdmVDU1MoJ2Rpc3BsYXknLCAncG9zaXRpb24nLCAnbWFyZ2luJyk7XHJcbiAgICovXHJcbiAgcmVtb3ZlQ1NTKC4uLnByb3BzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgIGlmICghaXNFbGVtZW50KGVsZW0pKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGNzcykgPT4ge1xyXG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkoY3NzKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSNyZXBsYWNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gcmVwbGFjZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XHJcbiAgICogd2l0aCBhIHNldCBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIGFyZ3VtZW50IChFbGVtZW50LCBzZXQgb2YgZWxlbWVudHMgb3IgYSBzZWxlY3RvciBvZiB0aGVtKS5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xyXG4gICAqIFtOb2RlI3JlcGxhY2VDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvcmVwbGFjZUNoaWxkfS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS5yZXBsYWNlKGVsZW0yKTtcclxuICAgKiBlbGVtLnJlcGxhY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xyXG4gICAqIGVsZW0ucmVwbGFjZSgnI2lkIGRpdi5jMScpO1xyXG4gICAqL1xyXG4gIHJlcGxhY2UoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA9IHRvRmluZChlbGVtZW50KTtcclxuXHJcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpcnN0KCkucGFyZW50KCk7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlbGVtID0gcGFyZW50O1xyXG4gICAgbGV0IG1ldGhvZCA9ICdpbnRvJztcclxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHQoKS5maXJzdCgpLiRbMF07XHJcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5wcmV2KCkuZmlyc3QoKS4kWzBdO1xyXG5cclxuICAgIGlmIChuZXh0KSB7XHJcbiAgICAgIGVsZW0gPSBuZXh0O1xyXG4gICAgICBtZXRob2QgPSAnaW5zZXJ0QmVmb3JlJztcclxuICAgIH0gZWxzZSBpZiAocHJldikge1xyXG4gICAgICBlbGVtID0gcHJldjtcclxuICAgICAgbWV0aG9kID0gJ2luc2VydEFmdGVyJztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZpcnN0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgZWxlbWVudFttZXRob2RdKGVsZW0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3NldE9mXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gSFRNTCBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fEFycmF5LjwqPn0gaXRlcmF0b3IgLSBBIG51bWJlciAoaG93IG1hbnkgZWxlbWVudHMgdG8gY3JlYXRlIGluc2lkZSBlYWNoIGVsZW1lbnQpLFxyXG4gICAqIGFuIG9iamVjdCBvciBhbiBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICogQHBhcmFtIHtFbGVtU2V0T2ZDYWxsYmFja30gY2FsbGJhY2tcclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBzZXQgb2YgZWxlbWVudHMgaW5zaWRlIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IGJhc2VkIG9uIGFuIGFycmF5IG9yIGFuIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogdGFibGUuc2V0T2YoJ3RyJywgW1sxLCAyXSwgWzMsIDRdLCBbNSwgNl1dLCAocm93LCBhcnJheSkgPT4ge1xyXG4gICAqICAgRChyb3cpLnNldE9mKCd0ZCcsIGFycmF5LCAoY29sLCBudW1iZXIpID0+IHtcclxuICAgKiAgICAgRChjb2wpLnRleHQobnVtYmVyKTtcclxuICAgKiAgIH0pO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHNldE9mKHR5cGUsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgdmFsaWRhdGUoeyAyOiBjYWxsYmFjayB9LCB7IDI6IFsnZnVuY3Rpb24nXSB9LCAnRWxlbSNzZXRPZicpO1xyXG5cclxuICAgIGl0ZXJhdG9yID0gbmV3IFN1cGVyKGl0ZXJhdG9yKS4kO1xyXG5cclxuICAgIGlmIChpc051bWJlcihpdGVyYXRvcikpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YWxpZGF0ZSh7IDE6IGl0ZXJhdG9yIH0sIHsgMTogWydpbnRMaWtlJywgJz49MCddIH0sICdFbGVtI3NldE9mJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzJuZCBhcmd1bWVudCBtdXN0IGJlIGVpdGhlciBvciBub24tbmVnYXRpdmUgaW50ZWdlciwgb3Igb2JqZWN0ISAoYXQgRWxlbSNzZXRPZiknKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXRlcmF0b3IgPSBhcnJheShpdGVyYXRvcikuJDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3QoKGVsZW1zLCBlbGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICBpdGVyYXRlKGl0ZXJhdG9yLCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBuZXcgRWxlbShlbGVtKS5jcmVhdGUodHlwZSk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKGNyZWF0ZWQuJFswXSwgdmFsdWUsIGtleSwgaXRlcmF0b3IsIGVsZW0sIGluZGV4KTtcclxuXHJcbiAgICAgICAgZWxlbXMuYWRkKGNyZWF0ZWQpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIG5ldyBFbGVtKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3Nob3dcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvd3MgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXHJcbiAgICogSWYgYW4gZWxlbWVudCB3YXMgaGlkZGVuIHVzaW5nIHtAbGluayBFbGVtI2hpZGV9IHByZXZpb3VzIGRpc3BsYXkgaXMgc2V0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLnNob3coKTtcclxuICAgKi9cclxuICBzaG93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBjb25zdCB7IGR3YXluZURhdGEgfSA9IGVsZW07XHJcblxyXG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XHJcblxyXG4gICAgICBpZiAoZWxlbS5jc3MoJ2Rpc3BsYXknKS5pbmRleE9mKCdub25lJykgPT09IDApIHtcclxuICAgICAgICBlbGVtLmNzcygnZGlzcGxheScsIGR3YXluZURhdGEucHJldmlvdXNEaXNwbGF5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZHdheW5lRGF0YS5wcmV2aW91c0Rpc3BsYXkgPSAnJztcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3RleHRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbVZhbHVlQ2FsbGJhY2t8Kn0gW3RleHRdIC0gVGV4dCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgdGV4dC5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgdGV4dCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxyXG4gICAqIE90aGVyd2lzZSBhbGwgZWxlbWVudHMgdGV4dHMgaW4gdGhlIHNldCBhcmUgc2V0IHRvIHRoZSB0ZXh0IGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgdGV4dC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS50ZXh0KCcxMjMnKTtcclxuICAgKiBlbGVtLnRleHQoKTsgLy8gJzEyMydcclxuICAgKi9cclxuICB0ZXh0KHRleHQpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9wKHRleHRQcm9wZXJ0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgdHh0ID0gZWxlbVt0ZXh0UHJvcGVydHldO1xyXG5cclxuICAgICAgbmV3IEVsZW0oZWxlbSkucHJvcChcclxuICAgICAgICB0ZXh0UHJvcGVydHksXHJcbiAgICAgICAgaXNGdW5jdGlvbih0ZXh0KVxyXG4gICAgICAgICAgPyB0ZXh0KHR4dCwgZWxlbSwgaW5kZXgpXHJcbiAgICAgICAgICA6IHRleHRcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgLSBBdHRyaWJ1dGUgdG8gdG9nZ2xlLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBhdHRyaWJ1dGVcclxuICAgKiB3aXRoIHRoZSAnJyB2YWx1ZSBhbmQgaWYgZmFsc2V5IG1ldGhvZCByZW1vdmVzIHRoZSBhdHRyaWJ1dGUuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXHJcbiAgICogdGhlIGF0dHJpYnV0ZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFuZCByZW1vdmVzIGlmIGl0IGRvZXMuXHJcbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB0b2dnbGluZyBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBlbGVtLnRvZ2dsZUF0dHIoJ2F0dHInKTtcclxuICAgKiBlbGVtLnRvZ2dsZUF0dHIoJ2F0dHInLCBzb21lQ29uZGl0aW9uKTtcclxuICAgKi9cclxuICB0b2dnbGVBdHRyKGF0dHIsIGNvbmRpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xyXG4gICAgICBlbGVtID0gbmV3IEVsZW0oZWxlbSk7XHJcblxyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhZWxlbS5oYXNBdHRyKGF0dHIpIDogY29uZGl0aW9uKSB7XHJcbiAgICAgICAgZWxlbS5hdHRyKGF0dHIsICcnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3RvZ2dsZUF0dHJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNscyAtIENsYXNzIHRvIHRvZ2dsZS5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2NvbmRpdGlvbl0gLSBJZiBwcmVzZW50IGFuZCB0aGUgY29uZGl0aW9uIGlzIHRydXRoeSBtZXRob2QgYWRkcyB0aGUgY2xhc3NcclxuICAgKiBhbmQgaWYgZmFsc2V5IG1ldGhvZCByZW1vdmVzIHRoZSBjbGFzcy4gSWYgbm90IHByZXNlbnQgbWV0aG9kIGFkZHNcclxuICAgKiB0aGUgY2xhc3MgaWYgaXQgZG9lc24ndCBleGlzdCBhbmQgcmVtb3ZlcyBpZiBpdCBkb2VzLlxyXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgY2xhc3Nlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJyk7XHJcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJywgc29tZUNvbmRpdGlvbik7XHJcbiAgICovXHJcbiAgdG9nZ2xlQ2xhc3MoY2xzLCBjb25kaXRpb24pIHtcclxuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAhdGhpcy5oYXNDbGFzcyhjbHMpIDogY29uZGl0aW9uKVxyXG4gICAgICA/IHRoaXMuYWRkQ2xhc3MoY2xzKVxyXG4gICAgICA6IHRoaXMucmVtb3ZlQ2xhc3MoY2xzKTtcclxuICB9XHJcblxyXG4gIGdldCB0b1N0cmluZ1RhZygpIHtcclxuICAgIHJldHVybiB0b1N0cmluZ1RhZyh0aGlzLiQkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRWxlbSN1cFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtsZXZlbCA9IDFdIC0gV2hhdCBsZXZlbCB1cCBhbG9uZyB0aGUgdHJlZSBzaG91bGQgYmUgdGhlIHBhcmVudC5cclxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9mIHBhcmVudHMgb2YgbGV2ZWwgJmx0O2xldmVsJmd0Oy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogZWxlbS51cCgpO1xyXG4gICAqIGVsZW0udXAoMik7XHJcbiAgICovXHJcbiAgdXAobGV2ZWwgPSAxKSB7XHJcbiAgICB2YWxpZGF0ZShbbGV2ZWxdLCBbWydpbnRMaWtlJywgJz49MCddXSwgJ0VsZW0jdXAnKTtcclxuXHJcbiAgICBsZXZlbCA9IE51bWJlcihsZXZlbCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0KChlbGVtcywgZWxlbSkgPT4ge1xyXG4gICAgICBsZXQgbiA9IGxldmVsO1xyXG5cclxuICAgICAgd2hpbGUgKG4tLSAmJiBlbGVtKSB7XHJcbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbXMuYWRkKGVsZW0pO1xyXG4gICAgfSwgbmV3IEVsZW0oKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEVsZW0jdmFsaWRhdGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtWYWxpZGF0ZUNhbGxiYWNrfSBbdmFsaWRhdG9yXSAtIElmIHByZXNlbnQsIGZ1bmN0aW9uIHRoYXQgdmFsaWRhdGVzIGlucHV0cy5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxPYmplY3QuPFN0cmluZywgRXJyb3J8Kj58bnVsbH1cclxuICAgKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHByb3ZpZGVkIHJldHVybnMgdGhpcy4gSWYgbm8gYXJndW1lbnRzIHByb3ZpZGVkIHJldHVybnMgZWl0aGVyIGFuIG9iamVjdFxyXG4gICAqIHdpdGggaW5wdXQgbmFtZXMga2V5cyBhbmQgZXJyb3JzIHZhbHVlcyBvciBudWxsIGlmIG5vIGVycm9ycyBmb3VuZC5cclxuICAgKiBAZGVzY3JpcHRpb24gSWYgYSBjYWxsYmFjayBhcmd1bWVudCBwcm92aWRlZCBhZGRzIGl0IHRvIHRoZSBlbGVtZW50IHZhbGlkYXRvcnMgbGlzdC5cclxuICAgKiBJZiBubyBhcmd1bWVudHMgcHJvdmlkZWQgdmFsaWRhdGVzIGV2ZXJ5IGlucHV0IGVsZW1lbnQgaW4gdGhlIHNldCB3aXRoIGl0cyBvd24gZnVuY3Rpb25zLlxyXG4gICAqIElmIGFuIGVsZW1lbnQgaXMgYSBmb3JtIGl0IHZhbGlkYXRlcyBhbGwgaW5wdXQgZWxlbWVudHMgaW5zaWRlIGl0LiBBZnRlciB0aGUgdmFsaWRhdGlvblxyXG4gICAqIGZpcmVzICd2YWxpZGF0ZScgZXZlbnQgd2l0aCAndmFsaWQnIGFuZCAnZXJyb3InIChpZiBmb3JtIGl0J3MgZXJyb3JzKSBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBmb3JtLm9uKCdpbnB1dCBjaGFuZ2UnLCAnaW5wdXQnLCAodmFsdWUsIGlucHV0KSA9PiB7XHJcbiAgICogICBpbnB1dCA9IEQoaW5wdXQpO1xyXG4gICAqXHJcbiAgICogICBpZiAoTnVtYmVyKHZhbHVlKSAlIDMpIHtcclxuICAgKiAgICAgaW5wdXQuYWRkQ2xhc3MoJ2ludmFsaWQnKTtcclxuICAgKlxyXG4gICAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBzaG91bGQgYmUgZGl2aWRlZCBieSAzIScpO1xyXG4gICAqICAgfVxyXG4gICAqXHJcbiAgICogICBpbnB1dC5yZW1vdmVDbGFzcygnaW52YWxpZCcpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHZhbGlkYXRlKHZhbGlkYXRvcikge1xyXG4gICAgdmFsaWRhdGUoW3ZhbGlkYXRvcl0sIFsnZnVuY3Rpb258fCEnXSwgJ0VsZW0jdmFsaWRhdGUnKTtcclxuXHJcbiAgICBpZiAodmFsaWRhdG9yKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvckVhY2goKHsgZHdheW5lRGF0YSB9KSA9PiB7XHJcbiAgICAgICAgZHdheW5lRGF0YS52YWxpZGF0b3JzLnB1c2godmFsaWRhdG9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXJyb3JzID0gbmV3IFN1cGVyKHsgZXJyb3JzOiBudWxsIH0pO1xyXG5cclxuICAgIHRoaXNcclxuICAgICAgLmZpbHRlcihgJHsgaW5wdXRFbGVtZW50cyB9LCBmb3JtYClcclxuICAgICAgLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgaWYgKGdldE5hbWUoZWxlbSkgPT09ICdmb3JtJykge1xyXG4gICAgICAgICAgbGV0IGZvcm1FcnJvcnMgPSB7IGVycm9yczogbnVsbCB9O1xyXG4gICAgICAgICAgY29uc3QgZm9ybSA9IG5ldyBFbGVtKGVsZW0pO1xyXG4gICAgICAgICAgY29uc3QgaW5wdXRzID0gZm9ybS5maW5kKGlucHV0RWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yV3JhcChpbnB1dCwgaW5kZXgsIGZvcm1FcnJvcnMpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgZXJyb3JzLmRlZXBBc3NpZ24oZm9ybUVycm9ycyk7XHJcblxyXG4gICAgICAgICAgZm9ybUVycm9ycyA9IGZvcm1FcnJvcnMuZXJyb3JzO1xyXG5cclxuICAgICAgICAgIGZvcm0uZGlzcGF0Y2goJ3ZhbGlkYXRlJywge30sIHtcclxuICAgICAgICAgICAgdmFsaWQ6ICFmb3JtRXJyb3JzLFxyXG4gICAgICAgICAgICBlcnJvcnM6IGZvcm1FcnJvcnNcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHJldHVybiBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRFcnJvciA9IChmb3JtRXJyb3JzIHx8IHt9KVtpbnB1dC5uYW1lXTtcclxuXHJcbiAgICAgICAgICAgIG5ldyBFbGVtKGlucHV0KS5kaXNwYXRjaCgndmFsaWRhdGUnLCB7fSwge1xyXG4gICAgICAgICAgICAgIHZhbGlkOiAhaW5wdXRFcnJvcixcclxuICAgICAgICAgICAgICBlcnJvcjogaW5wdXRFcnJvciB8fCBudWxsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaW5wdXRFcnJvciA9IHsgZXJyb3JzOiBudWxsIH07XHJcblxyXG4gICAgICAgIHZhbGlkYXRvcldyYXAoZWxlbSwgaW5kZXgsIGlucHV0RXJyb3IpO1xyXG4gICAgICAgIGVycm9ycy5kZWVwQXNzaWduKGlucHV0RXJyb3IpO1xyXG5cclxuICAgICAgICBpbnB1dEVycm9yID0gKGlucHV0RXJyb3IuZXJyb3JzIHx8IHt9KVtlbGVtLm5hbWVdO1xyXG5cclxuICAgICAgICBuZXcgRWxlbShlbGVtKS5kaXNwYXRjaCgndmFsaWRhdGUnLCB7fSwge1xyXG4gICAgICAgICAgdmFsaWQ6ICFpbnB1dEVycm9yLFxyXG4gICAgICAgICAgZXJyb3I6IGlucHV0RXJyb3IgfHwgbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3JXcmFwKGlucHV0LCBpbmRleCwgZXJyb3JzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGlucHV0LnZhbGlkaXR5ICYmICFpbnB1dC52YWxpZGl0eS52YWxpZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGlucHV0LnZhbGlkYXRpb25NZXNzYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlucHV0LmR3YXluZURhdGEudmFsaWRhdG9ycy5mb3JFYWNoKCh2YWxpZGF0b3IpID0+IHtcclxuICAgICAgICAgIHZhbGlkYXRvcihpbnB1dC52YWx1ZSwgaW5wdXQsIGluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgKGVycm9ycy5lcnJvcnMgPSBlcnJvcnMuZXJyb3JzIHx8IHt9KVtpbnB1dC5uYW1lXSA9IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChlcnJvcnMuZXZlcnkoKGVycm9yKSA9PiBpc051bGwoZXJyb3IpKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXJyb3JzLiQuZXJyb3JzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBFbGVtI3dpZHRoXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7KnxFbGVtVmFsdWVDYWxsYmFja30gW3dpZHRoXSAtIFdpZHRoIHRvIHNldC5cclxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgd2lkdGggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cclxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIHdpZHRocyBpbiB0aGUgc2V0IGFyZSBzZXQgdG8gdGhlIHdpZHRoIGFyZ3VtZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBHZXRzIG9yIHNldHMgd2lkdGguXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGVsZW0ud2lkdGgoMTIzKTtcclxuICAgKiBlbGVtLndpZHRoKCk7IC8vIDEyM1xyXG4gICAqL1xyXG4gIHdpZHRoKHdpZHRoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcm9wLmFwcGx5KHRoaXMsIG5ldyBBcnIoYXJndW1lbnRzKS51bnNoaWZ0KCd3aWR0aCcpLiQpO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhFbGVtLnByb3RvdHlwZSwge1xyXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnRWxlbSdcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtFbGVtfSB3aW5cclxuICogQHR5cGUge0VsZW19XHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2Ygd2luZG93LlxyXG4gKi9cclxuY29uc3Qgd2luID0gbmV3IEVsZW0oZ2xvYmFsKTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge0VsZW19IGRvY1xyXG4gKiBAdHlwZSB7RWxlbX1cclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cclxuICovXHJcbmNvbnN0IGRvYyA9IG5ldyBFbGVtKG5hdGl2ZURvY3VtZW50KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge0VsZW19IGh0bWxcclxuICogQHR5cGUge0VsZW19XHJcbiAqIEBwdWJsaWNcclxuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LlxyXG4gKi9cclxuY29uc3QgaHRtbCA9IG5ldyBFbGVtKG5hdGl2ZURvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtFbGVtfSBib2R5XHJcbiAqIEB0eXBlIHtFbGVtfVxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmJvZHkuXHJcbiAqL1xyXG5jb25zdCBib2R5ID0gbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQuYm9keSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtFbGVtfSBoZWFkXHJcbiAqIEB0eXBlIHtFbGVtfVxyXG4gKiBAcHVibGljXHJcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXHJcbiAqL1xyXG5jb25zdCBoZWFkID0gbmV3IEVsZW0obmF0aXZlRG9jdW1lbnQuaGVhZCk7XHJcblxyXG5jb25zdCBlbGVtZW50cyA9IG5ldyBBcnIoaHRtbEVsZW1lbnRzKS5jb25jYXQoc3ZnRWxlbWVudHMpLiQ7XHJcbmNvbnN0IHByb3BzID0gbmV3IEFycihlbGVtZW50cykubWFwKCh0eXBlKSA9PiBuZXcgU3RyKHR5cGUpLnRvQ2FtZWxDYXNlKCkuJCkuJDtcclxuXHJcbmR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzKEVsZW0ucHJvdG90eXBlLCBwcm9wcywgKGVsZW0sIGkpID0+IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5jcmVhdGUuYXBwbHkodGhpcywgbmV3IEFycihhcmd1bWVudHMpLnVuc2hpZnQoZWxlbWVudHNbaV0pLiQpO1xyXG59KTtcclxuXHJcbmR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzKEVsZW0ucHJvdG90eXBlLCBjYW52YXNHZXRNZXRob2RzLCAobWV0aG9kKSA9PiBmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3QgY3R4ID0gdGhpcy5jdHgoKTtcclxuXHJcbiAgaWYgKGN0eCkge1xyXG4gICAgcmV0dXJuIGN0eFttZXRob2RdLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICB9XHJcbn0pO1xyXG5cclxuZHluYW1pY0RlZmluZVByb3BlcnRpZXMoRWxlbS5wcm90b3R5cGUsIGNhbnZhc1Jlc3RNZXRob2RzLCAobWV0aG9kKSA9PiBmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3QgY3R4ID0gdGhpcy5jdHgoKTtcclxuXHJcbiAgaWYgKGN0eCkge1xyXG4gICAgY3R4W21ldGhvZF0uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB0b0ZpbmRcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtFbGVtZW50fEVsZW18U3RyaW5nfSBlbGVtIC0gRWxlbWVudCwgc2VsZWN0b3Igb2YgRWxlbWVudHMgb3IgRWxlbS5cclxuICogQHJldHVybnMge0VsZW19IEluc3RhbmNlIG9mIEVsZW0uXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0ZpbmQoZWxlbSkge1xyXG4gIGlmIChpc0VsZW0oZWxlbSkpIHtcclxuICAgIHJldHVybiBlbGVtO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzU3RyaW5nKGVsZW0pKSB7XHJcbiAgICBlbGVtID0gZmluZChlbGVtKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgRWxlbShlbGVtKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0VsZW1cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0J3MgRWxlbS5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB2YWx1ZSBpcyBFbGVtLlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgRWxlbSBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VsZW0odmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzV2luZG93XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIFdpbmRvdy5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB2YWx1ZSBpcyBXaW5kb3cuXHJcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBXaW5kb3cgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNXaW5kb3codmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnV2luZG93JztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0hUTUxEb2N1bWVudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBIVE1MRG9jdW1lbnQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgSFRNTERvY3VtZW50LlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgSFRNTERvY3VtZW50IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzSFRNTERvY3VtZW50KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0hUTUxEb2N1bWVudCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIGEgRG9jdW1lbnRGcmFnbWVudC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB2YWx1ZSBpcyBhIERvY3VtZW50RnJhZ21lbnQuXHJcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBhIERvY3VtZW50RnJhZ21lbnQgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0RvY3VtZW50RnJhZ21lbnQnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGlzU3R5bGVSdWxlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCdzIGEgc3R5bGUgcnVsZS5cclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB2YWx1ZSBpcyBhIHN0eWxlIHJ1bGUuXHJcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBhIHN0eWxlIHJ1bGUgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNTdHlsZVJ1bGUodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQ1NTU3R5bGVSdWxlJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQncyBDb21tZW50IG9yIFRleHQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdmFsdWUgaXMgSFRNTERvY3VtZW50LlxyXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgQ29tbWVudCBvciBUZXh0IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzQ29tbWVudE9yVGV4dCh2YWx1ZSkge1xyXG4gIGNvbnN0IHRhZyA9IHRvU3RyaW5nVGFnKHZhbHVlKTtcclxuXHJcbiAgcmV0dXJuIHRhZyA9PT0gJ0NvbW1lbnQnIHx8IHRhZyA9PT0gJ1RleHQnO1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGdldEVsZW1cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtFbGVtfSBlbGVtIC0gRWxlbWVudCB0byBjaGVjay5cclxuICogQHJldHVybnMge0VsZW1lbnR9IFRoZSBhcmd1bWVudCBvciBhIGZhbGxiYWNrIGlmIG5lZWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEVsZW0oZWxlbSkge1xyXG4gIHJldHVybiBpc0VsZW1lbnQoZWxlbS4kWzBdKSA/IGVsZW0uJFswXSA6IGVtcHR5RGl2O1xyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uIGdldE5hbWVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtFbGVtZW50fSBbZWxlbV0gLSBFbGVtZW50IHdoaWNoIG5hbWUgaXMgbmVlZGVkIHRvIGtub3cuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEVsZW1lbnQgbmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE5hbWUoZWxlbSkge1xyXG4gIHJldHVybiAoZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgfHwgJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gYWRkRHdheW5lRGF0YVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBFbGVtZW50IHRvIGFkZCBkd2F5bmVEYXRhIHRvLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmZ1bmN0aW9uIGFkZER3YXluZURhdGEoZWxlbSkge1xyXG4gIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChlbGVtLCAnZHdheW5lRGF0YScpICYmICFpc1dpbmRvdyhlbGVtKSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIEVsZW1lbnQjZHdheW5lRGF0YVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcmV2aW91c0Rpc3BsYXkgLSBQYXJhbWV0ZXIgdXNlZCBmb3IgaGlkaW5nL3Nob3dpbmcgZWxlbWVudHMuXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48U3RyaW5nLCBTdXBlcj59IHJlbW92ZUxpc3RlbmVycyAtIFBhcmFtZXRlciB1c2VkIGZvciByZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICogQHByb3BlcnR5IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIC0gQ2FudmFzIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJ9IHZhbGlkYXRvcnMgLSBWYWxpZGF0b3JzIGFzc2lnbmVkIHRvIGVsZW1lbnQuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgJ2R3YXluZURhdGEnLCB7XHJcbiAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgcHJldmlvdXNEaXNwbGF5OiAnJyxcclxuICAgICAgICBsaXN0ZW5lcnM6IHt9LFxyXG4gICAgICAgIGN0eDogZ2V0TmFtZShlbGVtKSA9PT0gJ2NhbnZhcycgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgICAgIHZhbGlkYXRvcnM6IG5ldyBBcnIoW10pXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAoaXNXaW5kb3coZWxlbSkgJiYgIXdpbmRvd3NEd2F5bmVEYXRhLnNvbWUoKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50ID09PSBlbGVtKSkge1xyXG4gICAgd2luZG93c0R3YXluZURhdGEucHVzaCh7XHJcbiAgICAgIGVsZW1lbnQ6IGVsZW0sXHJcbiAgICAgIGxpc3RlbmVyczoge31cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3RydWN0b3JzWzJdLnB1c2goe1xyXG4gIGNoZWNrOiAoZWxlbSkgPT4gKFxyXG4gICAgaXNFbGVtZW50KGVsZW0pIHx8XHJcbiAgICBpc1dpbmRvdyhlbGVtKSB8fFxyXG4gICAgaXNIVE1MRG9jdW1lbnQoZWxlbSkgfHxcclxuICAgIGlzQ29tbWVudE9yVGV4dChlbGVtKSB8fFxyXG4gICAgaXNEb2N1bWVudEZyYWdtZW50KGVsZW0pIHx8XHJcbiAgICAvXihIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdCkkLy50ZXN0KHRvU3RyaW5nVGFnKGVsZW0pKVxyXG4gICksXHJcbiAgY2xzOiBFbGVtXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBmaW5kXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cclxuICogQHBhcmFtIHtFbGVtZW50fSBbYmFzZSA9IGRvY3VtZW50XSAtIEJhc2UgdG8gZmluZCBpbi5cclxuICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxyXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICogW0RvY3VtZW50I3F1ZXJ5U2VsZWN0b3JBbGxde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yQWxsfS5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGJhc2UgPSBuYXRpdmVEb2N1bWVudCkge1xyXG4gIHJldHVybiBuZXcgRWxlbShcclxuICAgIGlzRWxlbWVudChiYXNlKSB8fCBpc0hUTUxEb2N1bWVudChiYXNlKVxyXG4gICAgICA/IGJhc2UucXVlcnlTZWxlY3RvckFsbChTdHJpbmcoc2VsZWN0b3IpKVxyXG4gICAgICA6IFtdXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBwYXJzZUhUTUxcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbCAtIEhUTUwgdG8gcGFyc2UuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbGxhcHNlV2hpdGVTcGFjZSA9IGZhbHNlXSAtIElmIHRoZSB3aGl0ZXNwYWNlIHNob3VsZCBiZVxyXG4gKiBjb2xsYXBzZWQgZHVyaW5nIHRoZSBwYXJzaW5nLlxyXG4gKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXHJcbiAqIEBkZXNjcmlwdGlvbiBQYXJzZXMgSFRNTCBhbmQgcmV0dXJucyBhIHdyYXAgb2YgI2RvY3VtZW50LWZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBwYXJzZUhUTUwoJzxkaXY+MTIzPC9kaXY+Jyk7IC8vIEVsZW1cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSFRNTChodG1sLCBjb2xsYXBzZVdoaXRlU3BhY2UpIHtcclxuICBjb25zdCBqc29uID0gbWFya3VwVG9KU09OKGh0bWwsIGNvbGxhcHNlV2hpdGVTcGFjZSk7XHJcbiAgY29uc3QgdGVtcGxhdGUgPSBkb2MudGVtcGxhdGUoKTtcclxuICBjb25zdCBlbGVtID0gbmV3IEVsZW0odGVtcGxhdGUuJFswXS5jb250ZW50KTtcclxuXHJcbiAganNvbi5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hOb2RlKG5vZGUpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgYXR0cnMsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBwYXJlbnQsXHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9ID0gbm9kZTtcclxuXHJcbiAgICBjb25zdCBwYXJlbnROb2RlID0gcGFyZW50LmVsZW0gfHwgZWxlbTtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJlbnROb2RlLmNyZWF0ZShuYW1lKTtcclxuXHJcbiAgICBub2RlLmVsZW0gPSBlbGVtZW50O1xyXG5cclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdHRycykge1xyXG4gICAgICBlbGVtZW50LmF0dHIoYXR0cnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuYW1lID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgIG5vZGUuZWxlbSA9IG5ldyBFbGVtKGVsZW1lbnQucHJvcCgnY29udGVudCcpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmb3JFYWNoTm9kZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBuZXcgRWxlbShlbGVtKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBweFxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gc2l6ZSAtIFN0cmluZyBjb250YWluaW5nIHBpeGVscyB2YWx1ZSBvciBhIG51bWJlci5cclxuICogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIHBpeGVscy5cclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBwYXJzaW5nIHBpeGVsIHN0cmluZ3MuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIHB4KCcwcHgnKTsgIC8vIDBcclxuICogcHgoJzQycHgnKTsgLy8gNDJcclxuICovXHJcbmZ1bmN0aW9uIHB4KHNpemUpIHtcclxuICByZXR1cm4gTnVtYmVyKFN0cmluZyhzaXplKS5yZXBsYWNlKC9weCQvLCAnJykpO1xyXG59XHJcblxyXG5leHBvcnQgeyBFbGVtLCB3aW4sIGRvYywgaHRtbCwgYm9keSwgaGVhZCwgZmluZCwgcGFyc2VIVE1MLCBweCB9O1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQmxvY2soQmxvY2spIHtcclxuICBjbGFzcyBEQmxvY2sgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSAnPGQtZWxlbWVudHMgdmFsdWU9XCJ7ZWxlbXN9XCIgLz4nO1xyXG5cclxuICAgIGVsZW1zID0gbnVsbDtcclxuXHJcbiAgICBhZnRlckNvbnN0cnVjdCgpIHtcclxuICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy4kJC5wYXJlbnQ7XHJcbiAgICAgIGNvbnN0IHsgbmFtZSB9ID0gdGhpcy5hcmdzO1xyXG4gICAgICBsZXQgZm91bmQ7XHJcblxyXG4gICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIGZvdW5kID0gY2hpbGRyZW4uZmluZCgoeyBuYW1lOiBub2RlTmFtZSB9KSA9PiBub2RlTmFtZSA9PT0gYGQtYmxvY2stJHsgbmFtZSB9YCk7XHJcblxyXG4gICAgICAgIGlmIChmb3VuZCAmJiBmb3VuZC52YWx1ZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZC52YWx1ZS5jaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtYmxvY2snLFxyXG4gICAgdmFsdWU6IERCbG9ja1xyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi4vQXJyJztcclxuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uL0VsZW0nO1xyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcclxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi4vaGVscGVycyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJERWFjaChCbG9jaywgY3JlYXRlQmxvY2spIHtcclxuICBjbGFzcyBERWFjaCBleHRlbmRzIEJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgc3VwZXIob3B0cyk7XHJcblxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgYXJnczoge1xyXG4gICAgICAgICAgaXRlbTogaXRlbU5hbWUgPSAnJGl0ZW0nLFxyXG4gICAgICAgICAgaW5kZXg6IGluZGV4TmFtZSA9ICckaW5kZXgnXHJcbiAgICAgICAgfVxyXG4gICAgICB9ID0gdGhpcztcclxuXHJcbiAgICAgIGFzc2lnbih0aGlzLiQkLCB7XHJcbiAgICAgICAgdWlkczogbmV3IFN1cGVyKHt9KSxcclxuICAgICAgICBpdGVtczogbmV3IEFycihbXSksXHJcbiAgICAgICAgVUlEOiBTdHJpbmcodGhpcy5hcmdzLnVpZCksXHJcbiAgICAgICAgaXRlbU5hbWUsXHJcbiAgICAgICAgaW5kZXhOYW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFmdGVyUmVuZGVyKCkge1xyXG4gICAgICB0aGlzLmNvbnN0cnVjdFZhbHVlcyh0aGlzLmFyZ3Muc2V0KTtcclxuICAgICAgdGhpcy53YXRjaEFyZ3MoJ3NldCcsIChzZXQpID0+IHtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdFZhbHVlcyhzZXQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RWYWx1ZXMoc2V0KSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBlbGVtczoge1xyXG4gICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudEVsZW1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHVpZHMsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIHNjb3BlLFxyXG4gICAgICAgIGl0ZW1OYW1lLFxyXG4gICAgICAgIGluZGV4TmFtZSxcclxuICAgICAgICBVSURcclxuICAgICAgfSA9IHRoaXMuJCQ7XHJcbiAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0ICR1aWRzID0gdWlkcy4kO1xyXG4gICAgICBjb25zdCBuZXdLZXlzID0ge307XHJcbiAgICAgIGNvbnN0IG5ld1VJRHMgPSB7fTtcclxuXHJcbiAgICAgIG5ldyBTdXBlcihzZXQpLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgc2NvcGVbaXRlbU5hbWVdID0gaXRlbTtcclxuICAgICAgICBzY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XHJcblxyXG4gICAgICAgIGNvbnN0IHVpZCA9IHBhcmVudC4kJC5ldmFsdWF0ZShTdHJpbmcoVUlEKSwgbnVsbCwgbnVsbCwgZmFsc2UsIGZhbHNlLCB0aGlzKTtcclxuXHJcbiAgICAgICAgbmV3S2V5c1t1aWRdID0gbmV3S2V5c1t1aWRdIHx8IHt9O1xyXG4gICAgICAgIG5ld0tleXNbdWlkXVtpbmRleF0gPSB0cnVlO1xyXG4gICAgICAgIG5ld1VJRHNbaW5kZXhdID0gdWlkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNjb3BlW2l0ZW1OYW1lXSA9IG51bGw7XHJcbiAgICAgIHNjb3BlW2luZGV4TmFtZV0gPSBudWxsO1xyXG5cclxuICAgICAgdWlkcy5mb3JFYWNoKChpdGVtcywgdWlkKSA9PiB7XHJcbiAgICAgICAgaWYgKCFuZXdLZXlzW3VpZF0pIHtcclxuICAgICAgICAgIGl0ZW1zLmZvckVhY2goKEl0ZW0pID0+IHtcclxuICAgICAgICAgICAgSXRlbS5yZW1vdmUoKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGl0ZW1zLnNwbGljZShPYmplY3Qua2V5cyhuZXdLZXlzW3VpZF0pLmxlbmd0aCkuZm9yRWFjaCgoSXRlbSkgPT4ge1xyXG4gICAgICAgICAgSXRlbS5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBsZXQgYWZ0ZXIgPSBzdGFydDtcclxuXHJcbiAgICAgIG5ldyBTdXBlcihzZXQpLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdWlkID0gbmV3VUlEc1tpbmRleF07XHJcbiAgICAgICAgbGV0IGJsb2NrO1xyXG5cclxuICAgICAgICBpZiAoJHVpZHNbdWlkXSAmJiAkdWlkc1t1aWRdLmxlbmd0aCkge1xyXG4gICAgICAgICAgYmxvY2sgPSBuZXdLZXlzW3VpZF1baW5kZXhdID0gdWlkcy4kW3VpZF0uc2hpZnQoKTtcclxuICAgICAgICAgIGJsb2NrLiQkLnNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcclxuICAgICAgICAgIGJsb2NrLiQkLnNjb3BlW2l0ZW1OYW1lXSA9IGl0ZW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJsb2NrID0gbmV3S2V5c1t1aWRdW2luZGV4XSA9IGNyZWF0ZUJsb2NrKHtcclxuICAgICAgICAgICAgbm9kZToge1xyXG4gICAgICAgICAgICAgIGl0ZW1OYW1lLFxyXG4gICAgICAgICAgICAgIGluZGV4TmFtZSxcclxuICAgICAgICAgICAgICBpdGVtLFxyXG4gICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgIG5hbWU6ICcjZC1pdGVtJyxcclxuICAgICAgICAgICAgICBibG9jazogcGFyZW50LFxyXG4gICAgICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFmdGVyLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudEVsZW0sXHJcbiAgICAgICAgICAgIHBhcmVudEJsb2NrOiB0aGlzLFxyXG4gICAgICAgICAgICBwYXJlbnRTY29wZTogcGFyZW50XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgZW5kXHJcbiAgICAgICAgfSA9IGJsb2NrLiQkLmVsZW1zO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnQucHJldigpLiRbMF0gIT09IGFmdGVyLiRbMF0pIHtcclxuICAgICAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gYmxvY2suJCQuZWxlbXM7XHJcblxyXG4gICAgICAgICAgbmV3IEVsZW0oW1xyXG4gICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgZW5kXHJcbiAgICAgICAgICBdKS5pbnNlcnRBZnRlcihhZnRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZnRlciA9IGVuZDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLiQkLnVpZHMgPSBuZXcgU3VwZXIobmV3S2V5cykubWFwKChpdGVtcykgPT4gKFxyXG4gICAgICAgIG5ldyBTdXBlcihpdGVtcykudmFsdWVzKClcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtZWFjaCcsXHJcbiAgICB2YWx1ZTogREVhY2hcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XHJcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi9FbGVtJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRFbGVtZW50cyhCbG9jaywgY3JlYXRlQmxvY2spIHtcclxuICBjbGFzcyBERWxlbWVudHMgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICBhZnRlckNvbnN0cnVjdCgpIHtcclxuICAgICAgdGhpcy53YXRjaEFyZ3MoJ3ZhbHVlJywgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgICBtaXhpbnMsXHJcbiAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxyXG4gICAgICAgICAgZWxlbXM6IHtcclxuICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgIHBhcmVudFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gPSB0aGlzLiQkO1xyXG4gICAgICAgIGxldCBhZnRlciA9IHN0YXJ0O1xyXG5cclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgY2hpbGQucmVtb3ZlKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xyXG4gICAgICAgICAgbWl4aW4ucmVtb3ZlKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuJCQuY2hpbGRyZW4gPSBuZXcgQXJyKFtdKTtcclxuICAgICAgICB0aGlzLiQkLm1peGlucyA9IG5ldyBBcnIoW10pO1xyXG4gICAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JERWxlbWVudHMgfSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGZvckRFbGVtZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHdhdGNoZXJzLmluZGV4T2Yod2F0Y2hlcik7XHJcblxyXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB3YXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBuZXdDb250ZW50ID0gbmV3IEVsZW0oKTtcclxuXHJcbiAgICAgICAgbmV3IEFycih2YWx1ZSB8fCBbXSkuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGJsb2NrID0gY3JlYXRlQmxvY2soe1xyXG4gICAgICAgICAgICBub2RlOiBjaGlsZCxcclxuICAgICAgICAgICAgYWZ0ZXIsXHJcbiAgICAgICAgICAgIHBhcmVudCxcclxuICAgICAgICAgICAgcGFyZW50QmxvY2s6IHRoaXMsXHJcbiAgICAgICAgICAgIHBhcmVudFNjb3BlOiB0aGlzXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGVsZW1zIH0gPSBibG9jay4kJDtcclxuXHJcbiAgICAgICAgICAgIGFmdGVyID0gZWxlbXMuZW5kO1xyXG5cclxuICAgICAgICAgICAgbmV3Q29udGVudC5hZGQoZWxlbXMuc3RhcnQsIGVsZW1zLmNvbnRlbnQsIGVsZW1zLmVuZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhZnRlciA9IGJsb2NrO1xyXG5cclxuICAgICAgICAgICAgbmV3Q29udGVudC5hZGQoYmxvY2spO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLiQkLmVsZW1zLmNvbnRlbnQgPSBuZXdDb250ZW50O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1lbGVtZW50cycsXHJcbiAgICB2YWx1ZTogREVsZW1lbnRzXHJcbiAgfTtcclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJESWYoQmxvY2spIHtcclxuICBjbGFzcyBESWYgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSAnPGQtZWxlbWVudHMgdmFsdWU9XCJ7ZWxlbXN9XCIvPic7XHJcblxyXG4gICAgaW5kZXggPSBJbmZpbml0eTtcclxuICAgIGVsZW1zID0gbnVsbDtcclxuICAgIHZhbHVlcyA9IHRoaXMuY2hpbGRyZW4ubWFwKChjaGlsZCwgaSkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBhdHRycyxcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgICB9ID0gY2hpbGQ7XHJcbiAgICAgIGNvbnN0IGNvbmQgPSB0aGlzLmV2YWx1YXRlQW5kV2F0Y2gobmFtZSA9PT0gJ2QtZWxzZScgPyAne3RydWV9JyA6IGF0dHJzLmlmIHx8ICd7dHJ1ZX0nLCAobmV3VmFsdWUpID0+IHtcclxuICAgICAgICBpZiAoISFuZXdWYWx1ZSA9PT0gdGhpcy52YWx1ZXMuJFtpXSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52YWx1ZXMuJFtpXSA9ICEhbmV3VmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChpID4gdGhpcy5pbmRleCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkgPCB0aGlzLmluZGV4KSB7XHJcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcclxuICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXMudmFsdWVzLmZpbmQoQm9vbGVhbik7XHJcblxyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgdGhpcy5pbmRleCA9IGZvdW5kLmtleTtcclxuICAgICAgICAgIHRoaXMuZWxlbXMgPSB0aGlzLmNoaWxkcmVuLiRbZm91bmQua2V5XS5jaGlsZHJlbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5pbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChjb25kICYmIHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGk7XHJcbiAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY29uZDtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLWlmJyxcclxuICAgIHZhbHVlOiBESWZcclxuICB9O1xyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRJdGVtKEJsb2NrKSB7XHJcbiAgY2xhc3MgREl0ZW0gZXh0ZW5kcyBCbG9jayB7XHJcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSAnPGQtZWxlbWVudHMgdmFsdWU9XCJ7Y2hpbGRyZW59XCIvPic7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJyNkLWl0ZW0nLFxyXG4gICAgdmFsdWU6IERJdGVtXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBBcnIgfSBmcm9tICcuLi9BcnInO1xyXG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRTd2l0Y2goQmxvY2spIHtcclxuICBjbGFzcyBEU3dpdGNoIGV4dGVuZHMgQmxvY2sge1xyXG4gICAgc3RhdGljIHRlbXBsYXRlID0gJzxkLWVsZW1lbnRzIHZhbHVlPVwie2VsZW1zfVwiLz4nO1xyXG5cclxuICAgIGluZGV4ID0gSW5maW5pdHk7XHJcbiAgICBlbGVtcyA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICBzdXBlcihvcHRzKTtcclxuXHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBhcmdzLFxyXG4gICAgICAgIGFyZ3M6IHsgdmFsdWUgfVxyXG4gICAgICB9ID0gdGhpcztcclxuICAgICAgbGV0IHdhc0RlZmF1bHQ7XHJcblxyXG4gICAgICB0aGlzLnZhbHVlcyA9IHRoaXMuY2hpbGRyZW4ub2JqZWN0KCh2YWx1ZXMsIGNoaWxkLCBpKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGF0dHJzLFxyXG4gICAgICAgICAgY2hpbGRyZW5cclxuICAgICAgICB9ID0gY2hpbGQ7XHJcblxyXG4gICAgICAgIGlmICh3YXNEZWZhdWx0KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSAhPT0gJ2QtY2FzZScgJiYgbmFtZSAhPT0gJ2QtZGVmYXVsdCcpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09PSAnZC1kZWZhdWx0Jykge1xyXG4gICAgICAgICAgd2FzRGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdmFsO1xyXG5cclxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZGVmYXVsdCcpIHtcclxuICAgICAgICAgIHZhbCA9IGFyZ3MudmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhbCA9IHRoaXMuZXZhbHVhdGVBbmRXYXRjaChhdHRycy5pZiB8fCAne3VuZGVmaW5lZH0nLCAobmV3VmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKHRoaXMudmFsdWVzLiRbaV0udmFsdWUsIG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy52YWx1ZXMuJFtpXS52YWx1ZSA9IG5ld1ZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgPiB0aGlzLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA8IHRoaXMuaW5kZXgpIHtcclxuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcclxuICAgICAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLnZhbHVlcy5maW5kKCh7IHZhbHVlIH0pID0+IChcclxuICAgICAgICAgICAgICB0aGlzLmVxdWFscyh2YWx1ZSwgYXJncy52YWx1ZSlcclxuICAgICAgICAgICAgKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gZm91bmQua2V5O1xyXG4gICAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBmb3VuZC52YWx1ZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbGVtcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKHZhbCwgdmFsdWUpICYmIHRoaXMuaW5kZXggPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcclxuICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhbHVlcy5wdXNoKHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICAgIHZhbHVlOiB2YWxcclxuICAgICAgICB9KTtcclxuICAgICAgfSwgbmV3IEFycihbXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGFmdGVyQ29uc3RydWN0KCkge1xyXG4gICAgICB0aGlzLndhdGNoQXJncygndmFsdWUnLCAobmV3VmFsdWUpID0+IHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaCgoeyBuYW1lLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdmFsID0gbmFtZSA9PT0gJ2QtZGVmYXVsdCdcclxuICAgICAgICAgICAgPyBuZXdWYWx1ZVxyXG4gICAgICAgICAgICA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLmVxdWFscyh2YWwsIG5ld1ZhbHVlKSAmJiB0aGlzLmluZGV4ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtcyA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgIHRoaXMuZWxlbXMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU3VwZXIodmFsdWUxKS5lcXVhbHModmFsdWUyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1zd2l0Y2gnLFxyXG4gICAgdmFsdWU6IERTd2l0Y2hcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGlzTmlsIH0gZnJvbSAnLi4vaGVscGVycyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEVGV4dChCbG9jaykge1xyXG4gIGNsYXNzIERUZXh0IGV4dGVuZHMgQmxvY2sge1xyXG4gICAgc3RhdGljIHRlbXBsYXRlID0gJzxkLWVsZW1lbnRzIHZhbHVlPVwie1t7IG5hbWU6IFxcJyN0ZXh0XFwnLCB2YWx1ZTogdGV4dCB9XX1cIi8+JztcclxuXHJcbiAgICB0ZXh0ID0gJyc7XHJcblxyXG4gICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XHJcbiAgICAgIHRoaXMudGV4dCA9IGlzTmlsKHRoaXMuYXJncy52YWx1ZSkgPyAnJyA6IHRoaXMuYXJncy52YWx1ZTtcclxuXHJcbiAgICAgIHRoaXMud2F0Y2hBcmdzKCd2YWx1ZScsIChuZXdWYWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IGlzTmlsKG5ld1ZhbHVlKSA/ICcnIDogbmV3VmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLXRleHQnLFxyXG4gICAgdmFsdWU6IERUZXh0XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRBdHRyKE1peGluKSB7XHJcbiAgY2xhc3MgREF0dHIgZXh0ZW5kcyBNaXhpbiB7XHJcbiAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgY29uc3QgeyBlbGVtIH0gPSB0aGlzO1xyXG5cclxuICAgICAgbmV3VmFsdWUgPSBuZXcgU3VwZXIobmV3VmFsdWUpLiQ7XHJcblxyXG4gICAgICBuZXcgU3VwZXIob2xkVmFsdWUpLmZvckVhY2goKHZhbHVlLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgaWYgKCFuZXdWYWx1ZVtwcm9wXSkge1xyXG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGVsZW0uYXR0cihuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2QtYXR0cicsXHJcbiAgICB2YWx1ZTogREF0dHJcclxuICB9O1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vaGVscGVycyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEQmluZChNaXhpbikge1xyXG4gIGNsYXNzIERCaW5kIGV4dGVuZHMgTWl4aW4ge1xyXG4gICAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcclxuICAgICAgaWYgKHRoaXMub2ZmKSB7XHJcbiAgICAgICAgdGhpcy5vZmYoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5vZmYgPSB0aGlzLmVsZW0ub24odGhpcy5tYXRjaFswXSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLWJpbmQnLFxyXG4gICAgdmFsdWU6IERCaW5kXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBTdXBlciB9IGZyb20gJy4uL1N1cGVyJztcclxuaW1wb3J0IHsgaXNBcnJheSwgaXNTdHJpbmcsIGl0ZXJhdGUgfSBmcm9tICcuLi9oZWxwZXJzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRDbGFzcyhNaXhpbikge1xyXG4gIGNsYXNzIERDbGFzcyBleHRlbmRzIE1peGluIHtcclxuICAgIGNsYXNzZXMgPSBbXTtcclxuXHJcbiAgICBhZnRlclVwZGF0ZShuZXdWYWx1ZSkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgZWxlbSxcclxuICAgICAgICBjbGFzc2VzXHJcbiAgICAgIH0gPSB0aGlzO1xyXG4gICAgICBjb25zdCBuZXdDbGFzc2VzID0gW107XHJcblxyXG4gICAgICBuZXdWYWx1ZSA9IG5ldyBTdXBlcihuZXdWYWx1ZSkuJDtcclxuXHJcbiAgICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcclxuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0FycmF5KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgIGl0ZXJhdGUoY2xhc3NlcywgKGNscykgPT4ge1xyXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlLmluZGV4T2YoY2xzKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0ZXJhdGUobmV3VmFsdWUsIChjbHMpID0+IHtcclxuICAgICAgICAgIGlmIChpc1N0cmluZyhjbHMpKSB7XHJcbiAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpO1xyXG4gICAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXRlcmF0ZShjbGFzc2VzLCAoY2xzKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8ICFuZXdWYWx1ZVtjbHNdKSB7XHJcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpdGVyYXRlKG5ld1ZhbHVlLCAodmFsLCBjbHMpID0+IHtcclxuICAgICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XHJcbiAgICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jbGFzc2VzID0gbmV3Q2xhc3NlcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1jbGFzcycsXHJcbiAgICB2YWx1ZTogRENsYXNzXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL2hlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyREVsZW0oTWl4aW4pIHtcclxuICBjbGFzcyBERWxlbSBleHRlbmRzIE1peGluIHtcclxuICAgIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgc3VwZXIob3B0cyk7XHJcblxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgYmxvY2ssXHJcbiAgICAgICAgZWxlbVxyXG4gICAgICB9ID0gdGhpcztcclxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xyXG5cclxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUoZWxlbSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgYmxvY2tbdmFsdWVdID0gZWxlbTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdkLWVsZW0nLFxyXG4gICAgdmFsdWU6IERFbGVtXHJcbiAgfTtcclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJESGlkZShNaXhpbikge1xyXG4gIGNsYXNzIERIaWRlIGV4dGVuZHMgTWl4aW4ge1xyXG4gICAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcclxuICAgICAgY29uc3QgeyBlbGVtIH0gPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgZWxlbS5oaWRlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbS5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1oaWRlJyxcclxuICAgIHZhbHVlOiBESGlkZVxyXG4gIH07XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRE9uKE1peGluKSB7XHJcbiAgY2xhc3MgRE9uIGV4dGVuZHMgTWl4aW4ge1xyXG4gICAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICBzdXBlcihvcHRzKTtcclxuXHJcbiAgICAgIHRoaXMuZWxlbS5vbih0aGlzLm1hdGNoWzBdLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5ldmFsdWF0ZU9uY2UoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2Qtb24nLFxyXG4gICAgdmFsdWU6IERPblxyXG4gIH07XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFNob3coTWl4aW4pIHtcclxuICBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcclxuICAgIGFmdGVyVXBkYXRlKHZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcclxuXHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIGVsZW0uc2hvdygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW0uaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ2Qtc2hvdycsXHJcbiAgICB2YWx1ZTogRFNob3dcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi4vU3VwZXInO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFN0eWxlKE1peGluKSB7XHJcbiAgY2xhc3MgRFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xyXG4gICAgYWZ0ZXJVcGRhdGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcclxuXHJcbiAgICAgIG5ld1ZhbHVlID0gbmV3IFN1cGVyKG5ld1ZhbHVlKS4kO1xyXG5cclxuICAgICAgbmV3IFN1cGVyKG9sZFZhbHVlKS5mb3JFYWNoKCh2YWx1ZSwgcHJvcCkgPT4ge1xyXG4gICAgICAgIGlmICghbmV3VmFsdWVbcHJvcF0pIHtcclxuICAgICAgICAgIGVsZW0ucmVtb3ZlQ1NTKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGVsZW0uY3NzKG5ld1ZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC1zdHlsZScsXHJcbiAgICB2YWx1ZTogRFN0eWxlXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBpc05pbCB9IGZyb20gJy4uL2hlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFRleHQoTWl4aW4pIHtcclxuICBjbGFzcyBEVGV4dCBleHRlbmRzIE1peGluIHtcclxuICAgIGFmdGVyVXBkYXRlKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuZWxlbS50ZXh0KFxyXG4gICAgICAgIGlzTmlsKHZhbHVlKVxyXG4gICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgOiBgJHsgdmFsdWUgfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC10ZXh0JyxcclxuICAgIHZhbHVlOiBEVGV4dFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgc3dpdGNoZXIgfSBmcm9tICcuLi9Td2l0Y2hlcic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vaGVscGVycyc7XG5cbmNvbnN0IGxpc3RlbmVyU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgJ2lucHV0JylcbiAgLmNhc2UoJ2Zvcm0nLCAnaW5wdXQsIGNoYW5nZScpXG4gIC5jYXNlKCdzZWxlY3QnLCAnY2hhbmdlJylcbiAgLmNhc2UoJ2lucHV0JywgKHR5cGUpID0+IChcbiAgICB0eXBlID09PSAncmFkaW8nXG4gICAgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgIHx8IHR5cGUgPT09ICdjb2xvcidcbiAgICB8fCB0eXBlID09PSAnZmlsZSdcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogJ2lucHV0J1xuICApKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFZhbGlkYXRlKE1peGluKSB7XG4gIGNsYXNzIERWYWxpZGF0ZSBleHRlbmRzIE1peGluIHtcbiAgICBzdGF0aWMgZXZhbHVhdGUgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG4gICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICAgIGVsZW0udmFsaWRhdGUodmFsaWRhdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsaWRhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIGVsZW0ub24obGlzdGVuZXJTd2l0Y2hlcihlbGVtLm5hbWUsIFtlbGVtLnByb3AoJ3R5cGUnKV0pLCAoKSA9PiB7XG4gICAgICAgICAgZWxlbS52YWxpZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdkLXZhbGlkYXRlJyxcbiAgICB2YWx1ZTogRFZhbGlkYXRlXG4gIH07XG59XG4iLCJpbXBvcnQgeyBBcnIgfSBmcm9tICcuLi9BcnInO1xyXG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4uL1N3aXRjaGVyJztcclxuaW1wb3J0IHsgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNOaWwgfSBmcm9tICcuLi9oZWxwZXJzJztcclxuXHJcbmNvbnN0IHByb3BTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAodHlwZSwgZWxlbSkgPT4gKFxyXG4gIGVsZW0uaGFzQXR0cignY29udGVudGVkaXRhYmxlJykgfHwgZWxlbS5oYXNBdHRyKCdjb250ZW50RWRpdGFibGUnKVxyXG4gICAgPyAndGV4dCdcclxuICAgIDogJ3ZhbHVlJ1xyXG4pKVxyXG4gIC5jYXNlKCdzZWxlY3QnLCAodHlwZSwgZWxlbSkgPT4gKFxyXG4gICAgZWxlbS5oYXNBdHRyKCdtdWx0aXBsZScpXHJcbiAgICAgID8gJ211bHRpcGxlLXNlbGVjdCdcclxuICAgICAgOiAndmFsdWUnXHJcbiAgKSlcclxuICAuY2FzZSgnaW5wdXQnLCAodHlwZSkgPT4ge1xyXG4gICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xyXG4gICAgICByZXR1cm4gJ2ZpbGVzJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnXHJcbiAgICAgID8gJ2NoZWNrZWQnXHJcbiAgICAgIDogJ3ZhbHVlJztcclxuICB9KTtcclxuY29uc3Qgc2V0VmFsdWVTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAodmFsdWUpID0+IHZhbHVlKVxyXG4gIC5jYXNlKCdpbnB1dCcsICh2YWx1ZSwgdHlwZSwgaW5wdXRWYWx1ZSkgPT4ge1xyXG4gICAgaWYgKHR5cGUgIT09ICdyYWRpbycgJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlID09PSBpbnB1dFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGlucHV0VmFsdWUpICE9PSAtMTtcclxuICB9KTtcclxuY29uc3QgZ2V0VmFsdWVTd2l0Y2hlciA9IHN3aXRjaGVyKCdzdHJpY3RFcXVhbHMnLCAodmFsdWUpID0+IHZhbHVlKVxyXG4gIC5jYXNlKCdzZWxlY3QnLCAodmFsdWUsIHR5cGUsIGlucHV0VmFsdWUsIHZhbHVlcywgZWxlbSwgb3B0aW9ucykgPT4ge1xyXG4gICAgaWYgKCFlbGVtLmhhc0F0dHIoJ211bHRpcGxlJykpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvcHRpb25zXHJcbiAgICAgIC5vYmplY3QoKHZhbHVlcywgeyBzZWxlY3RlZCwgdmFsdWUgfSkgPT4ge1xyXG4gICAgICAgIGlmIChzZWxlY3RlZCAmJiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBbXSlcclxuICAgICAgLiQ7XHJcbiAgfSlcclxuICAuY2FzZSgnaW5wdXQnLCAodmFsdWUsIHR5cGUsIGlucHV0VmFsdWUsIHZhbHVlcywgZWxlbSwgb3B0aW9ucywgaW5pdCkgPT4ge1xyXG4gICAgaWYgKHR5cGUgIT09ICdyYWRpbycgJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgPyBpbnB1dFZhbHVlXHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdmFsdWUgJiYgaW5pdCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpID09PSAtMVxyXG4gICAgICAgICAgPyBuZXcgQXJyKHZhbHVlcykuY29uY2F0KGlucHV0VmFsdWUpLiRcclxuICAgICAgICAgIDogdmFsdWVzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW2lucHV0VmFsdWVdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNBcnJheSh2YWx1ZXMpKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpO1xyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICAuLi5uZXcgQXJyKHZhbHVlcykuc2xpY2UoMCwgaW5kZXgpLiQsXHJcbiAgICAgICAgLi4ubmV3IEFycih2YWx1ZXMpLnNsaWNlKGluZGV4ICsgMSkuJFxyXG4gICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgfSk7XHJcbmNvbnN0IGxpc3RlbmVyU3dpdGNoZXIgPSBzd2l0Y2hlcignc3RyaWN0RXF1YWxzJywgJ2lucHV0JylcclxuICAuY2FzZSgnc2VsZWN0JywgJ2NoYW5nZScpXHJcbiAgLmNhc2UoJ2lucHV0JywgKHR5cGUpID0+IChcclxuICAgIHR5cGUgPT09ICdyYWRpbydcclxuICAgIHx8IHR5cGUgPT09ICdjaGVja2JveCdcclxuICAgIHx8IHR5cGUgPT09ICdjb2xvcidcclxuICAgIHx8IHR5cGUgPT09ICdmaWxlJ1xyXG4gICAgICA/ICdjaGFuZ2UnXHJcbiAgICAgIDogJ2lucHV0J1xyXG4gICkpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRFZhbHVlKE1peGluKSB7XHJcbiAgY2xhc3MgRFZhbHVlIGV4dGVuZHMgTWl4aW4ge1xyXG4gICAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICBzdXBlcihvcHRzKTtcclxuXHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICAkJDogeyBfdmFsdWUgfSxcclxuICAgICAgICBibG9jayxcclxuICAgICAgICBlbGVtLFxyXG4gICAgICAgIG5vZGVcclxuICAgICAgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLm5hbWU7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBlbGVtLnByb3AoJ3R5cGUnKTtcclxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlT25jZSgpO1xyXG4gICAgICBsZXQgaW5pdGlhbFNjb3BlVmFsdWUgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy5wcm9wID0gcHJvcFN3aXRjaGVyKG5hbWUsIFt0eXBlLCBlbGVtXSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgdGhpcy5vcHRpb25zID0gZWxlbS5maW5kKCdvcHRpb24nKTtcclxuXHJcbiAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICBpbml0aWFsU2NvcGVWYWx1ZSA9IGJsb2NrLiQkLmV2YWx1YXRlKGB7JHsgX3ZhbHVlIH19YCwgKG5ld1ZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgdGhpcy5zZXRQcm9wKG5ld1ZhbHVlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaW5pdGlhbEVsZW1WYWx1ZSA9IHRoaXMuZ2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSwgdHJ1ZSk7XHJcbiAgICAgIGNvbnN0IGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsID0gaXNOaWwoaW5pdGlhbFNjb3BlVmFsdWUpO1xyXG4gICAgICBjb25zdCBpc0NoZWNrYm94ID0gdHlwZSA9PT0gJ2NoZWNrYm94JztcclxuXHJcbiAgICAgIGlmIChpc0luaXRpYWxTY29wZVZhbHVlTnVsbCB8fCBpc0NoZWNrYm94KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBpbml0aWFsRWxlbVZhbHVlO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc0luaXRpYWxTY29wZVZhbHVlTnVsbCAmJiBpc0NoZWNrYm94KSB7XHJcbiAgICAgICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluaXRpYWxTY29wZVZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW0ub24obGlzdGVuZXJTd2l0Y2hlcihuYW1lLCBbdHlwZV0pLCAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLmdldFByb3AodGhpcy5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgdGhpcy5jaGFuZ2VTY29wZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlU2NvcGUoKSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBibG9jayxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBjdXJyZW50VmFsdWVcclxuICAgICAgfSA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZShjdXJyZW50VmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJsb2NrW3ZhbHVlXSA9IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFByb3AodmFsdWUpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGVsZW0sXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBwcm9wLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgIH0gPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHByb3AgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgIGVsZW0udGV4dCh2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ211bHRpcGxlLXNlbGVjdCcpIHtcclxuICAgICAgICBvcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtLnByb3AocHJvcCwgc2V0VmFsdWVTd2l0Y2hlcihuYW1lLCBbdmFsdWUsIHR5cGUsIG5vZGUudmFsdWVdKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRQcm9wKHZhbHVlcywgaW5pdCkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgZWxlbSxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHByb3AsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIG9wdGlvbnNcclxuICAgICAgfSA9IHRoaXM7XHJcblxyXG4gICAgICByZXR1cm4gcHJvcCA9PT0gJ3RleHQnXHJcbiAgICAgICAgPyBlbGVtLnRleHQoKVxyXG4gICAgICAgIDogZ2V0VmFsdWVTd2l0Y2hlcihuYW1lLCBbZWxlbS5wcm9wKHByb3ApLCB0eXBlLCBub2RlLnZhbHVlLCB2YWx1ZXMsIGVsZW0sIG9wdGlvbnMsIGluaXRdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnZC12YWx1ZScsXHJcbiAgICB2YWx1ZTogRFZhbHVlXHJcbiAgfTtcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBCbG9ja1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgQmxvY2sgY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQXJyIH0gZnJvbSAnLi9BcnInO1xyXG5pbXBvcnQgeyBkb2MsIEVsZW0gfSBmcm9tICcuL0VsZW0nO1xyXG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuL1N0cic7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7XHJcbiAgaXRlcmF0ZSwgdmFsaWRhdGUsXHJcbiAgaXNGdW5jdGlvbiwgaXNOaWwsIGlzVW5kZWZpbmVkXHJcbn0gZnJvbSAnLi9oZWxwZXJzJztcclxuaW1wb3J0ICogYXMgQmxvY2tzIGZyb20gJy4vYmxvY2tzJztcclxuaW1wb3J0ICogYXMgTWl4aW5zIGZyb20gJy4vbWl4aW5zJztcclxuaW1wb3J0IHsgaHRtbEFsbG93ZWRUYWdTeW1ib2xzLCBodG1sQWxsb3dlZEF0dHJTeW1ib2xzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgbWFya3VwVG9KU09OIGZyb20gJy4vaGVscGVycy9tYXJrdXBUb0pTT04nO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBXYXRjaGVyXHJcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgLSBOZXcgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBXcmFwcGVyXHJcbiAqIEBwYXJhbSB7QmxvY2t9IEJsb2NrIGNsYXNzIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtCbG9ja30gTmV3IEJsb2NrIGNsYXNzLlxyXG4gKi9cclxuXHJcbmNvbnN0IHJvb3RCbG9ja3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5jb25zdCByb290TWl4aW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuY29uc3QgaXNQcm90b3R5cGVPZiA9IHt9LmlzUHJvdG90eXBlT2Y7XHJcbmNvbnN0IHRhZ05hbWUgPSBuZXcgUmVnRXhwKGBeJHsgaHRtbEFsbG93ZWRUYWdTeW1ib2xzIH0kYCwgJ2knKTtcclxuY29uc3QgYXR0ck5hbWUgPSBuZXcgUmVnRXhwKGBeJHsgaHRtbEFsbG93ZWRBdHRyU3ltYm9scyB9JGApO1xyXG5jb25zdCBleHByZXNzaW9uUmVnRXhwID0gL15cXHtbXFxzXFxTXStcXH0kLztcclxuY29uc3QgeyBkb2N1bWVudCB9ID0gZ2xvYmFsO1xyXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbmxldCBvbkV2YWxFcnJvciA9IChlcnIpID0+IHtcclxuICBjb25zb2xlLmVycm9yKGBFdmFsIGVycm9yIChldmFsdWF0aW5nIFwiJHsgZXJyLmV4cHJlc3Npb24gfVwiIGluIGNvbnRleHQgb2YgYmxvY2sgXCIkeyBlcnIuYmxvY2suJCQubmFtZSB9XCIpOmAsIGVycik7XHJcbn07XHJcbmxldCBldmFsTW9kZTtcclxubGV0IGdldHRpbmc7XHJcbmxldCBjaGFuZ2VkO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBCbG9ja1xyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gRWxlbWVudCBvcHRpb25zLlxyXG4gKiBAcmV0dXJucyB7QmxvY2t9IEluc3RhbmNlIG9mIEJsb2NrLlxyXG4gKiBAZGVzY3JpcHRpb24gQ2xhc3MgZm9yIGR5bmFtaWMgdGVtcGxhdGluZy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IHsgRCwgQmxvY2ssIGluaXRBcHAsIHJlZ2lzdGVyQmxvY2sgfSBmcm9tICdkd2F5bmUnO1xyXG4gKlxyXG4gKiBjbGFzcyBBcHAgZXh0ZW5kcyBCbG9jayB7XHJcbiAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxIZWxsbyB0ZXh0PVwie3RleHR9XCIvPic7XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IoYXJncywgY2hpbGRyZW4pIHtcclxuICogICAgIHN1cGVyKGFyZ3MsIGNoaWxkcmVuKTtcclxuICpcclxuICogICAgIHRoaXMudGV4dCA9ICd3b3JsZCAoMCknO1xyXG4gKiAgICAgdGhpcy50aW1lcyA9IDA7XHJcbiAqXHJcbiAqICAgICB0aGlzLnNldEludGVydmFsKCk7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIHNldEludGVydmFsKCkge1xyXG4gKiAgICAgRCgxMDAwKS5pbnRlcnZhbCgoKSA9PiB7XHJcbiAqICAgICAgIHRoaXMudGV4dCA9IGB3b3JsZCAoJHsgKyt0aGlzLnRpbWVzIH0pYDtcclxuICogICAgIH0pO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBjbGFzcyBIZWxsbyBleHRlbmRzIEJsb2NrIHtcclxuICogICBzdGF0aWMgdGVtcGxhdGUgPSAnSGVsbG8sIDxkLXRleHQgdmFsdWU9XCJ7YXJncy50ZXh0fVwiLz4hJztcclxuICogfVxyXG4gKlxyXG4gKiBCbG9jay5BcHAgPSBBcHA7XHJcbiAqIEJsb2NrLkhlbGxvID0gSGVsbG87XHJcbiAqXHJcbiAqIGluaXRBcHAoKTtcclxuICovXHJcbmNsYXNzIEJsb2NrIHtcclxuICBzdGF0aWMgX2Jsb2NrcyA9IE9iamVjdC5jcmVhdGUocm9vdEJsb2Nrcyk7XHJcbiAgc3RhdGljIF9taXhpbnMgPSBPYmplY3QuY3JlYXRlKHJvb3RNaXhpbnMpO1xyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtCb29sZWFufSBbQmxvY2suY29sbGFwc2VXaGl0ZVNwYWNlID0gdHJ1ZV1cclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAcHVibGljXHJcbiAgICogQGRlc2NyaXB0aW9uIElmIHRoZSB3aGl0ZXNwYWNlIGJldHdlZW4gaHRtbCBlbGVtZW50cyBhbmRcclxuICAgKiBpbiB0aGUgc3RhcnQgYW5kIHRoZSBlbmQgaW5zaWRlIHRoZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQgZHVyaW5nIHBhcnNpbmcuXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbGxhcHNlV2hpdGVTcGFjZSA9IHRydWU7XHJcblxyXG4gIHN0YXRpYyBnZXQgb25FdmFsRXJyb3IoKSB7XHJcbiAgICByZXR1cm4gb25FdmFsRXJyb3I7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2V0IG9uRXZhbEVycm9yKGxpc3RlbmVyKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcikpIHtcclxuICAgICAgb25FdmFsRXJyb3IgPSBsaXN0ZW5lcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9uRXZhbEVycm9yID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRCbG9ja3MoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN1cGVyKHsgLi4udGhpcy5fYmxvY2tzIH0pO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldE1peGlucygpIHtcclxuICAgIHJldHVybiBuZXcgU3VwZXIoeyAuLi50aGlzLl9taXhpbnMgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrLnJlZ2lzdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gQmxvY2sgb3IgbWl4aW4gbmFtZS5cclxuICAgKiBAcGFyYW0ge0Jsb2NrfE1peGlufSBTdWJjbGFzcyAtIFN1YmNsYXNzIG9mIEJsb2NrIG9yIE1peGluLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlciBibG9jayBvciBtaXhpbiBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoaXMuXHJcbiAgICovXHJcbiAgc3RhdGljIHJlZ2lzdGVyKG5hbWUsIFN1YmNsYXNzKSB7XHJcbiAgICBjb25zdCBfdGhpcyA9IG5ldyBTdXBlcih0aGlzKTtcclxuXHJcbiAgICBpZiAoIV90aGlzLmhhc093bignX2Jsb2NrcycpKSB7XHJcbiAgICAgIFN1YmNsYXNzLl9ibG9ja3MgPSBPYmplY3QuY3JlYXRlKF90aGlzLnByb3RvKCkuJC5fYmxvY2tzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIV90aGlzLmhhc093bignX21peGlucycpKSB7XHJcbiAgICAgIFN1YmNsYXNzLl9taXhpbnMgPSBPYmplY3QuY3JlYXRlKF90aGlzLnByb3RvKCkuJC5fbWl4aW5zKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIF9ibG9ja3MsXHJcbiAgICAgIF9taXhpbnNcclxuICAgIH0gPSB0aGlzO1xyXG5cclxuICAgIGlmICghaXNJbnN0YW5jZU9mQmxvY2soU3ViY2xhc3MpICYmICFpc0luc3RhbmNlT2ZNaXhpbihTdWJjbGFzcykpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBjbGFzcyBkb2VzIG5vdCBleHRlbmQgQmxvY2sgb3IgTWl4aW4gYW5kIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLnJlZ2lzdGVyKWApO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0luc3RhbmNlT2ZCbG9jayhTdWJjbGFzcykpIHtcclxuICAgICAgaWYgKHJvb3RCbG9ja3NbbmFtZV0pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIGJsb2NrIGlzIGEgYnVpbHQtaW4gYmxvY2sgc28gdGhlIGJsb2NrIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLnJlZ2lzdGVyKWApO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGFnTmFtZS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIGJsb2NrcyBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2sucmVnaXN0ZXIpYCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgU3ViY2xhc3MuX2h0bWwgPSBkZWVwQ2xvbmVDaGlsZHJlbihcclxuICAgICAgICBtYXJrdXBUb0pTT04oXHJcbiAgICAgICAgICBgJHsgU3ViY2xhc3MudGVtcGxhdGUgfHwgJycgfWAsXHJcbiAgICAgICAgICBTdWJjbGFzcy5jb2xsYXBzZVdoaXRlU3BhY2VcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBfYmxvY2tzW25hbWVdID0gU3ViY2xhc3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocm9vdE1peGluc1tuYW1lXSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgbWl4aW4gaXMgYSBidWlsdC1pbiBtaXhpbiBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2sucmVnaXN0ZXIpYCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFhdHRyTmFtZS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIG1peGlucyBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2sucmVnaXN0ZXIpYCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgU3ViY2xhc3MuX21hdGNoID0gbmV3IFJlZ0V4cChgXiR7IG5ldyBTdHIobmFtZSkuZXNjYXBlUmVnRXhwKCkuJCB9KD86LShbXFxcXHNcXFxcU10rKSk/JGApO1xyXG5cclxuICAgICAgX21peGluc1tuYW1lXSA9IFN1YmNsYXNzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7U3RyaW5nfSBCbG9jay50ZW1wbGF0ZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayB0ZW1wbGF0ZS5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBCbG9jay53cmFwXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7V3JhcHBlcn0gZnVuYyAtIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB3cmFwcGVkIGJsb2NrLlxyXG4gICAqIEByZXR1cm5zIHtCbG9ja30gTmV3IGJsb2NrLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIGJsb2NrcyBpbnRvIGFub3RoZXIgYmxvY2tzLlxyXG4gICAqIEl0IGlzIGNvbnNpZGVyZWQgYmVzdCBwcmFjdGljZSB0byBqdXN0IGV4dGVuZHMgdGhlIG9sZCBibG9jayB3aXRoIGEgbmV3IG9uZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY2xhc3MgTXlCbG9jayBleHRlbmRzIEJsb2NrIHtcclxuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2PjEyMzwvZGl2Pic7XHJcbiAgICogfVxyXG4gICAqXHJcbiAgICogTXlCbG9jay53cmFwKChCbG9jaykgPT4ge1xyXG4gICAqICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgQmxvY2sge1xyXG4gICAqICAgICBzdGF0aWMgdGVtcGxhdGUgPSBgPHNlY3Rpb24gY2xhc3M9XCJ3cmFwcGVyXCI+JHsgQmxvY2sudGVtcGxhdGUgfTwvc2VjdGlvbj5gO1xyXG4gICAqXHJcbiAgICogICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAqICAgICAgIHRoaXMuYWRkaXRpb25hbFZhciA9ICdhZGRpdGlvbmFsJztcclxuICAgKiAgICAgfVxyXG4gICAqICAgfTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBzdGF0aWMgd3JhcChmdW5jKSB7XHJcbiAgICB2YWxpZGF0ZShbZnVuY10sIFsnZnVuY3Rpb24nXSk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmModGhpcyk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGFyZ3M6IG9yaWdpbmFsQXJncyxcclxuICAgICAgY2hpbGRyZW4sXHJcbiAgICAgIHBhcmVudCxcclxuICAgICAgcGFyZW50QmxvY2ssXHJcbiAgICAgIHBhcmVudFNjb3BlXHJcbiAgICB9ID0gb3B0cztcclxuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBuZXcgQXJyKFtdKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyIHtCbG9ja30gQmxvY2sjJFxyXG4gICAgICAgKiBAdHlwZSB7QmxvY2t9XHJcbiAgICAgICAqIEBwdWJsaWNcclxuICAgICAgICogQGRlc2NyaXB0aW9uIFRoaXMuXHJcbiAgICAgICAqL1xyXG4gICAgICAkOiB7XHJcbiAgICAgICAgdmFsdWU6IHRoaXNcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrIyQkXHJcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFyZ3MgLSBQcml2YXRlIGFyZ3Mgc2NvcGUuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7QXJyfSBjaGlsZHJlbiAtIENoaWxkIGJsb2Nrcy5cclxuICAgICAgICogQHByb3BlcnR5IHtBcnJ9IG1peGlucyAtIENoaWxkIG1peGlucy5cclxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGVsZW1zIC0gRWxlbWVudHMgY29ubmVjdGVkIHRvIHRoZSBibG9jay5cclxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBlbGVtcy5wYXJlbnQgLSBQYXJlbnQgZWxlbWVudC5cclxuICAgICAgICogQHByb3BlcnR5IHtFbGVtfSBlbGVtcy5zdGFydCAtIFN0YXJ0IGNvbW1lbnQgYmxvY2suXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gZWxlbXMuZW5kIC0gRW5kIGNvbW1lbnQgYmxvY2suXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbX0gZWxlbXMuY29udGVudCAtIENvbnRlbnQgZWxlbWVudHMuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGV2YWx1YXRlIC0gRXZhbHVhdGUgZnVuY3Rpb24uXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnbG9iYWwgLSBQcml2YXRlIGdsb2JhbCBzY29wZS5cclxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGxvY2FscyAtIFByaXZhdGUgbG9jYWxzIHNjb3BlLlxyXG4gICAgICAgKiBAcHJvcGVydHkge0Fycn0gd2F0Y2hlcnNUb1JlbW92ZSAtIFdhdGNoZXJzIHRvIHJlbW92ZSBiZWZvcmUgcmVtb3ZpbmcgZWxlbWVudC5cclxuICAgICAgICovXHJcbiAgICAgICQkOiB7XHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudFNjb3BlLFxyXG4gICAgICAgICAgcGFyZW50QmxvY2ssXHJcbiAgICAgICAgICBuczogbmV3IFN1cGVyKHRoaXMpLnByb3RvKCkuJC5jb25zdHJ1Y3RvcixcclxuICAgICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyKFtdKSxcclxuICAgICAgICAgIG1peGluczogbmV3IEFycihbXSksXHJcbiAgICAgICAgICBlbGVtczoge1xyXG4gICAgICAgICAgICBzdGFydDogZG9jLmNyZWF0ZUNvbW1lbnQoYCAkeyBuYW1lIH06IHN0YXJ0IGApLFxyXG4gICAgICAgICAgICBlbmQ6IGRvYy5jcmVhdGVDb21tZW50KGAgJHsgbmFtZSB9OiBlbmQgYCksXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IG5ldyBFbGVtKCksXHJcbiAgICAgICAgICAgIHBhcmVudFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHdhdGNoZXJzVG9SZW1vdmUsXHJcbiAgICAgICAgICBldmFsdWF0ZTogKGV4cHJlc3Npb24sIG9uQ2hhbmdlLCBpbnN0YW5jZSwgZm9yREVsZW1lbnRzLCBmb3JESXRlbSwgZm9yREVhY2gpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFleHByZXNzaW9uUmVnRXhwLnRlc3QoZXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbiB8fCB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3JERWxlbWVudHMgPSAhIWZvckRFbGVtZW50cztcclxuICAgICAgICAgICAgZm9yREl0ZW0gPSAhIWZvckRJdGVtO1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKC9eXFx7fFxcfSQvZywgJycpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSAobmFtZSA9PT0gJyNkLWl0ZW0nICYmICFmb3JESXRlbSkgfHwgZm9yREVhY2hcclxuICAgICAgICAgICAgICA/IChmb3JERWFjaCB8fCB0aGlzKS4kJC5zY29wZVxyXG4gICAgICAgICAgICAgIDogdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1uZXctZnVuYzogMCAqL1xyXG4gICAgICAgICAgICBjb25zdCB7IHdhdGNoZXJzVG9SZW1vdmUgfSA9IGluc3RhbmNlID8gaW5zdGFuY2UuJCQgOiB7fTtcclxuICAgICAgICAgICAgY29uc3QgZnVuYyA9IG5ldyBGdW5jdGlvbihcclxuICAgICAgICAgICAgICAnJyxcclxuICAgICAgICAgICAgICAnd2l0aChkb2N1bWVudC5Ed2F5bmVTdG9yZSl7JCQuZXhwcj1ldmFsKFwiJCQuZXhwcj1cIiskJC5leHByKTtyZXR1cm4gJCQuZXhwcn0nXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xyXG4gICAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgZXZhbE1vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZ2V0dGluZyA9IG5ldyBBcnIoW10pO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgc3RvcmUuJCQuZXhwciA9IGV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnQuRHdheW5lU3RvcmUgPSBzdG9yZTtcclxuXHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKTtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbkV2YWxFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICBlcnIuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICAgIGVyci5ibG9jayA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgIG9uRXZhbEVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAob25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2F0Y2hlcnMgPSBuZXcgQXJyKFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZXR0aW5nLmZvckVhY2goKHdhdGNoZXJzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHdhdGNoZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmVzdWx0ID0gZXZhbHVhdGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jlc3VsdCAhPT0gcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdSZXN1bHQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyQmxvY2sgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yREVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcclxuICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXIub25SZW1vdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxXYXRjaGVycy5mb3JFYWNoKCh3YXRjaGVyQmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcclxuICAgICAgICAgICAgICAgICAgICAgIH0gPSB3YXRjaGVyQmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleDEgPSB3YXRjaGVyc1RvUmVtb3ZlLmluZGV4T2Yod2F0Y2hlckJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4MiA9IHdhdGNoZXJzLmluZGV4T2Yod2F0Y2hlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4MSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZS5zcGxpY2UoaW5kZXgxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVycy5zcGxpY2UoaW5kZXgyLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGxvY2FsV2F0Y2hlcnMucHVzaCh3YXRjaGVyQmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLnB1c2god2F0Y2hlckJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGV2YWxNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBnZXR0aW5nID0gbmV3IEFycihbXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBzdG9yZS4kJC5leHByID0gbnVsbDtcclxuICAgICAgICAgICAgICBkb2N1bWVudC5Ed2F5bmVTdG9yZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGFyZ3MgPSBuZXcgU3VwZXIob3JpZ2luYWxBcmdzKS5tYXAoKHZhbHVlLCBhcmcpID0+IHtcclxuICAgICAgaWYgKG5hbWUgPT09ICdkLWVhY2gnICYmIChcclxuICAgICAgICBhcmcgPT09ICdpdGVtJ1xyXG4gICAgICAgIHx8IGFyZyA9PT0gJ2luZGV4J1xyXG4gICAgICAgIHx8IGFyZyA9PT0gJ3VpZCdcclxuICAgICAgKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZm9yREVsZW1lbnRzID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnICYmIGFyZyA9PT0gJ3ZhbHVlJztcclxuXHJcbiAgICAgIHJldHVybiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hcmdzW2FyZ10gPSB2YWx1ZTtcclxuICAgICAgfSwgdGhpcywgZm9yREVsZW1lbnRzLCBmb3JERWxlbWVudHMgJiYgcGFyZW50QmxvY2suJCQubmFtZSA9PT0gJyNkLWl0ZW0nKTtcclxuICAgIH0pLiQ7XHJcblxyXG4gICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBuZXcgQXJyKFtdKTtcclxuICAgIHRoaXMuZ2xvYmFsID0gT2JqZWN0LmNyZWF0ZShcclxuICAgICAgcGFyZW50U2NvcGVcclxuICAgICAgICA/IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuZ2xvYmFsKVxyXG4gICAgICAgIDogbnVsbFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLiQkLmVsZW1zLnN0YXJ0LiRbMF0uRHdheW5lQmxvY2sgPSB0aGlzO1xyXG4gICAgdGhpcy4kJC5lbGVtcy5lbmQuJFswXS5Ed2F5bmVCbG9jayA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHBhcmVudEJsb2NrKSB7XHJcbiAgICAgIHBhcmVudEJsb2NrLiQkLmNoaWxkcmVuLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyQ29uc3RydWN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgY29uc3RydWN0aW9uIChpbmNsdWRpbmcgYWxsIHNjb3BlcylcclxuICAgKiBidXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgYmxvY2sgYW5kIGl0cyBjaGlsZHJlbi5cclxuICAgKi9cclxuICBhZnRlckNvbnN0cnVjdCgpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJSZW5kZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBoYXMgYmVlbiByZW5kZXJlZC5cclxuICAgKi9cclxuICBhZnRlclJlbmRlcigpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sjYWZ0ZXJSZW5kZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBiZWZvcmUgdGhlIGJsb2NrIHJlbW92YWwuXHJcbiAgICovXHJcbiAgYmVmb3JlUmVtb3ZlKCkge31cclxuXHJcbiAgZXZhbHVhdGVBbmRXYXRjaChleHByZXNzaW9uLCBjYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIHRoaXMuJCQucGFyZW50LiQkLmV2YWx1YXRlKGV4cHJlc3Npb24sIGNhbGxiYWNrLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIGV2YWx1YXRlT25jZShleHByZXNzaW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnQuJCQuZXZhbHVhdGUoZXhwcmVzc2lvbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEJsb2NrI3JlbW92ZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvdCBmb3JjaW5nIHRoZSBibG9jayB0byBiZSByZW1vdmVkLiBDYWxsc1xyXG4gICAqIHJlbW92ZSBtZXRob2QgZm9yIGFsbCBvZiBpdHMgY2hpbGQgYmxvY2tzIGFuZCBjYWxscyBiZWZvcmVSZW1vdmUgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgcmVtb3ZlKGlzUGFyZW50U2lnbmFsKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICBjaGlsZHJlbixcclxuICAgICAgbWl4aW5zLFxyXG4gICAgICBlbGVtczoge1xyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIH0sXHJcbiAgICAgIHdhdGNoZXJzVG9SZW1vdmVcclxuICAgIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xyXG5cclxuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgIGNoaWxkLnJlbW92ZSh0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xyXG4gICAgICBtaXhpbi5yZW1vdmUodHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVSZW1vdmU6YCwgZXJyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50QmxvY2suJCQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmV3IEVsZW0oW1xyXG4gICAgICBzdGFydCxcclxuICAgICAgY29udGVudCxcclxuICAgICAgZW5kXHJcbiAgICBdKS5yZW1vdmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sjd2F0Y2hcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IFthcmdzXSAtIFZhcnMgdG8gd2F0Y2ggKGFyZ3MsIGdsb2JhbCBvciBsb2NhbCkuXHJcbiAgICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyIC0gQ2FsbGVkIHdoZW4gd2F0Y2hlZCB2YXJzIGFyZSBjaGFuZ2VkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdhdGNoaW5nIGZvciB2YXJzLiBJZiBubyB2YXJzIHBhc3NlZCBpbiBhcmd1bWVudHNcclxuICAgKiBhbGwgdmFycyBhcmUgdG8gYmUgd2F0Y2hlZC4gT3RoZXJ3aXNlIHNwZWNpZmllZCB2YXJzIHdpbGwgYmUgd2F0Y2hlZC5cclxuICAgKiBXYXRjaGVycyBzaG91bGQgbm90IGJlIHB1dCBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yLiBJdCBpcyBjb25zaWRlcmVkIGJlc3RcclxuICAgKiBwcmFjdGljZSB0byBkbyBpdCBpbnNpZGUgdGhlIHtAbGluayBCbG9jayNhZnRlckNvbnN0cnVjdH0gbWV0aG9kLlxyXG4gICAqIE5vdGUgdGhhdCB0aGVzZSBleHByZXNzaW9ucyAodmFycywgaS5lLiBcImFyZ3MuYXJnXCIpIGFyZSBub3QgdG8gYmVcclxuICAgKiBldmFsdWF0ZWQgc28geW91IGNhbm5vdCBwdXQgdGhlcmUgdGhpbmdzIGxpa2UgXCJhW2JdXCIgb3IgYW55IGpzIGNvZGUsXHJcbiAgICogb25seSBleHByZXNzaW9ucyBsaWtlIFwiYVwiLCBcImJcIiwgXCJhcmdzLmFcIiwgXCJhcmdzLmJcIiBhbmQgXCJnbG9iYWwuYVwiLCBcImdsb2JhbC5iXCIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdiAvPic7XHJcbiAgICpcclxuICAgKiAgIGFmdGVyQ29uc3RydWN0KCkge1xyXG4gICAqICAgICB0aGlzLndhdGNoKCdhJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoKCdhcmdzLmEnLCAnZ2xvYmFsLnInLCAoKSA9PiB7fSk7XHJcbiAgICogICAgIHRoaXMud2F0Y2goKCkgPT4ge30pO1xyXG4gICAqICAgfVxyXG4gICAqIH1cclxuICAgKi9cclxuICB3YXRjaCgpIHtcclxuICAgIGNvbnN0IHdhdGNoZXIgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGlmICghaXNGdW5jdGlvbih3YXRjaGVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgZm9yIChjb25zdCBnbG9iYWwgaW4gdGhpcy4kJC5nbG9iYWwpIHtcclxuICAgICAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXHJcbiAgICAgICAgdGhpcy4kJC5nbG9iYWxbZ2xvYmFsXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZXJhdGUodGhpcy4kJC5hcmdzLCAoeyB3YXRjaGVycyB9KSA9PiB7XHJcbiAgICAgICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBpdGVyYXRlKHRoaXMuJCQubG9jYWxzLCAoeyB3YXRjaGVycyB9KSA9PiB7XHJcbiAgICAgICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKHZhcmlhYmxlKSA9PiB7XHJcbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gd2F0Y2hlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyaWFibGUgPSBgJHsgdmFyaWFibGUgfWA7XHJcblxyXG4gICAgICBpZiAoL15hcmdzXFwuLy50ZXN0KHZhcmlhYmxlKSkge1xyXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUucmVwbGFjZSgvXmFyZ3NcXC4vLCAnJyk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy4kJC5hcmdzW3ZhcmlhYmxlXSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy4kJC5hcmdzW3ZhcmlhYmxlXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKC9eZ2xvYmFsXFwuLy50ZXN0KHZhcmlhYmxlKSkge1xyXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUucmVwbGFjZSgvXmdsb2JhbFxcLi8sICcnKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLiQkLmdsb2JhbFt2YXJpYWJsZV0pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuJCQuZ2xvYmFsW3ZhcmlhYmxlXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLiQkLmxvY2Fsc1t2YXJpYWJsZV0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJCQubG9jYWxzW3ZhcmlhYmxlXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sjd2F0Y2hBcmdzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBbYXJnc10gLSBBcmdzIHRvIHdhdGNoLlxyXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlciAtIENhbGxlZCB3aGVuIHdhdGNoZWQgYXJncyBhcmUgY2hhbmdlZC5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB3YXRjaGluZyBmb3IgYXJncy4gSWYgbm8gYXJncyBwYXNzZWQgaW4gYXJndW1lbnRzXHJcbiAgICogYWxsIGFyZ3MgYXJlIHRvIGJlIHdhdGNoZWQuIE90aGVyd2lzZSBzcGVjaWZpZWQgYXJncyB3aWxsIGJlIHdhdGNoZWQuXHJcbiAgICogV2F0Y2hlcnMgc2hvdWxkIG5vdCBiZSBwdXQgaW5zaWRlIHRoZSBjb25zdHJ1Y3Rvci4gSXQgaXMgY29uc2lkZXJlZCBiZXN0XHJcbiAgICogcHJhY3RpY2UgdG8gZG8gaXQgaW5zaWRlIHRoZSB7QGxpbmsgQmxvY2sjYWZ0ZXJDb25zdHJ1Y3R9IG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY2xhc3MgTXlCbG9jayBleHRlbmRzIEJsb2NrIHtcclxuICAgKiAgIHN0YXRpYyB0ZW1wbGF0ZSA9ICc8ZGl2IC8+JztcclxuICAgKlxyXG4gICAqICAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XHJcbiAgICogICAgIHRoaXMud2F0Y2hBcmdzKCdhJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoQXJncygnYScsICdiJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoQXJncygoKSA9PiB7fSk7XHJcbiAgICogICB9XHJcbiAgICogfVxyXG4gICAqL1xyXG4gIHdhdGNoQXJncygpIHtcclxuICAgIGNvbnN0IHdhdGNoZXIgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGlmICghaXNGdW5jdGlvbih3YXRjaGVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGl0ZXJhdGUodGhpcy4kJC5hcmdzLCAoeyB3YXRjaGVycyB9KSA9PiB7XHJcbiAgICAgICAgd2F0Y2hlcnMucGVybS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpdGVyYXRlKGFyZ3VtZW50cywgKGFyZykgPT4ge1xyXG4gICAgICBpZiAoYXJnID09PSB3YXRjaGVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMuJCQuYXJnc1thcmddKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLiQkLmFyZ3NbYXJnXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sjd2F0Y2hHbG9iYWxcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IFtnbG9iYWxzXSAtIEdsb2JhbHMgdG8gd2F0Y2guXHJcbiAgICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyIC0gQ2FsbGVkIHdoZW4gd2F0Y2hlZCBnbG9iYWxzIGFyZSBjaGFuZ2VkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdhdGNoaW5nIGZvciBnbG9iYWxzLiBJZiBubyBnbG9iYWxzIHBhc3NlZCBpbiBhcmd1bWVudHNcclxuICAgKiBhbGwgZ2xvYmFscyBhcmUgdG8gYmUgd2F0Y2hlZC4gT3RoZXJ3aXNlIHNwZWNpZmllZCBnbG9iYWxzIHdpbGwgYmUgd2F0Y2hlZC5cclxuICAgKiBXYXRjaGVycyBzaG91bGQgbm90IGJlIHB1dCBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yLiBJdCBpcyBjb25zaWRlcmVkIGJlc3RcclxuICAgKiBwcmFjdGljZSB0byBkbyBpdCBpbnNpZGUgdGhlIHtAbGluayBCbG9jayNhZnRlckNvbnN0cnVjdH0gbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjbGFzcyBNeUJsb2NrIGV4dGVuZHMgQmxvY2sge1xyXG4gICAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXYgLz4nO1xyXG4gICAqXHJcbiAgICogICBhZnRlckNvbnN0cnVjdCgpIHtcclxuICAgKiAgICAgdGhpcy53YXRjaEdsb2JhbCgnYScsICgpID0+IHt9KTtcclxuICAgKiAgICAgdGhpcy53YXRjaEdsb2JhbCgnYScsICdiJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoR2xvYmFsKCgpID0+IHt9KTtcclxuICAgKiAgIH1cclxuICAgKiB9XHJcbiAgICovXHJcbiAgd2F0Y2hHbG9iYWxzKCkge1xyXG4gICAgY29uc3Qgd2F0Y2hlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHdhdGNoZXIpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGdsb2JhbCBpbiB0aGlzLiQkLmdsb2JhbCkge1xyXG4gICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cclxuICAgICAgICB0aGlzLiQkLmdsb2JhbFtnbG9iYWxdLndhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAoZ2xvYmFsKSA9PiB7XHJcbiAgICAgIGlmIChnbG9iYWwgPT09IHdhdGNoZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy4kJC5nbG9iYWxbZ2xvYmFsXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy4kJC5nbG9iYWxbZ2xvYmFsXS53YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgQmxvY2sjd2F0Y2hMb2NhbHNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IFtsb2NhbHNdIC0gTG9jYWxzIHRvIHdhdGNoLlxyXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlciAtIENhbGxlZCB3aGVuIHdhdGNoZWQgbG9jYWxzIGFyZSBjaGFuZ2VkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdhdGNoaW5nIGZvciBsb2NhbHMuIElmIG5vIGxvY2FscyBwYXNzZWQgaW4gYXJndW1lbnRzXHJcbiAgICogYWxsIGxvY2FscyBhcmUgdG8gYmUgd2F0Y2hlZC4gT3RoZXJ3aXNlIHNwZWNpZmllZCBsb2NhbHMgd2lsbCBiZSB3YXRjaGVkLlxyXG4gICAqIFdhdGNoZXJzIHNob3VsZCBub3QgYmUgcHV0IGluc2lkZSB0aGUgY29uc3RydWN0b3IuIEl0IGlzIGNvbnNpZGVyZWQgYmVzdFxyXG4gICAqIHByYWN0aWNlIHRvIGRvIGl0IGluc2lkZSB0aGUge0BsaW5rIEJsb2NrI2FmdGVyQ29uc3RydWN0fSBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XHJcbiAgICogICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdiAvPic7XHJcbiAgICpcclxuICAgKiAgIGFmdGVyQ29uc3RydWN0KCkge1xyXG4gICAqICAgICB0aGlzLndhdGNoTG9jYWxzKCdhJywgKCkgPT4ge30pO1xyXG4gICAqICAgICB0aGlzLndhdGNoTG9jYWxzKCdhJywgJ2InLCAoKSA9PiB7fSk7XHJcbiAgICogICAgIHRoaXMud2F0Y2hMb2NhbHMoKCkgPT4ge30pO1xyXG4gICAqICAgfVxyXG4gICAqIH1cclxuICAgKi9cclxuICB3YXRjaExvY2FscygpIHtcclxuICAgIGNvbnN0IHdhdGNoZXIgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGlmICghaXNGdW5jdGlvbih3YXRjaGVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGl0ZXJhdGUodGhpcy4kJC5sb2NhbHMsICh7IHdhdGNoZXJzIH0pID0+IHtcclxuICAgICAgICB3YXRjaGVycy5wZXJtLnB1c2god2F0Y2hlcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZXJhdGUoYXJndW1lbnRzLCAobG9jYWwpID0+IHtcclxuICAgICAgaWYgKGxvY2FsID09PSB3YXRjaGVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMuJCQubG9jYWxzW2xvY2FsXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy4kJC5sb2NhbHNbbG9jYWxdLndhdGNoZXJzLnBlcm0ucHVzaCh3YXRjaGVyKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJCdWlsdElucyhCbG9ja3MsIHJvb3RCbG9ja3MsIEJsb2NrKTtcclxuXHJcbmNvbnN0IGJsb2NrcyA9IEJsb2NrLl9ibG9ja3M7XHJcblxyXG5jbGFzcyBNaXhpbiB7XHJcbiAgc3RhdGljIGV2YWx1YXRlID0gdHJ1ZTtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgZWxlbSxcclxuICAgICAgbWF0Y2gsXHJcbiAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICBwYXJlbnRTY29wZVxyXG4gICAgfSA9IG9wdHM7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAkJDoge1xyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgX3ZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgIHBhcmVudDogcGFyZW50U2NvcGUsXHJcbiAgICAgICAgICBwYXJlbnRCbG9jayxcclxuICAgICAgICAgIHdhdGNoZXJzVG9SZW1vdmU6IG5ldyBBcnIoW10pXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1hdGNoID0gbmV3IEFycihtYXRjaCkuc2xpY2UoMSkuJDtcclxuICAgIHRoaXMuYmxvY2sgPSBwYXJlbnRTY29wZTtcclxuICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICB0aGlzLm5vZGUgPSBlbGVtLiRbMF07XHJcblxyXG4gICAgaWYgKHBhcmVudEJsb2NrKSB7XHJcbiAgICAgIHBhcmVudEJsb2NrLiQkLm1peGlucy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWZ0ZXJVcGRhdGUoKSB7fVxyXG5cclxuICBiZWZvcmVSZW1vdmUoKSB7fVxyXG5cclxuICBldmFsdWF0ZUFuZFdhdGNoKGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIF92YWx1ZSxcclxuICAgICAgcGFyZW50XHJcbiAgICB9ID0gdGhpcy4kJDtcclxuXHJcbiAgICByZXR1cm4gcGFyZW50LiQkLmV2YWx1YXRlKF92YWx1ZSwgY2FsbGJhY2ssIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZXZhbHVhdGVPbmNlKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBfdmFsdWUsXHJcbiAgICAgIHBhcmVudFxyXG4gICAgfSA9IHRoaXMuJCQ7XHJcblxyXG4gICAgcmV0dXJuIHBhcmVudC4kJC5ldmFsdWF0ZShfdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBNaXhpbiNyZW1vdmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3QgZm9yY2luZyB0aGUgbWl4aW4gdG8gYmUgcmVtb3ZlZC5cclxuICAgKi9cclxuICByZW1vdmUoaXNQYXJlbnRTaWduYWwpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgcGFyZW50QmxvY2ssXHJcbiAgICAgIHdhdGNoZXJzVG9SZW1vdmVcclxuICAgIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgcGFyZW50QmxvY2spIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRCbG9jay4kJC5taXhpbnMuaW5kZXhPZih0aGlzKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBwYXJlbnRCbG9jay4kJC5taXhpbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJCdWlsdElucyhNaXhpbnMsIHJvb3RNaXhpbnMsIE1peGluKTtcclxuXHJcbmNvbnN0IG1peGlucyA9IEJsb2NrLl9taXhpbnM7XHJcblxyXG5mdW5jdGlvbiBpbml0QXBwKGJsb2NrLCBub2RlKSB7XHJcbiAgaWYgKCFibG9ja3NbYmxvY2tdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIFwiJHsgYmxvY2sgfVwiIGJsb2NrIGlzIHJlZ2lzdGVyZWQhIChpbml0QXBwKWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhcnQgPSBkb2MuY3JlYXRlQ29tbWVudCgnIGQtcm9vdDogc3RhcnQgJyk7XHJcbiAgY29uc3QgZW5kID0gZG9jLmNyZWF0ZUNvbW1lbnQoJyBkLXJvb3Q6IGVuZCAnKTtcclxuICBjb25zdCBwYXJlbnQgPSBuZXcgRWxlbShub2RlKTtcclxuXHJcbiAgcGFyZW50Lmh0bWwoJycpO1xyXG5cclxuICBuZXcgRWxlbShbXHJcbiAgICBzdGFydCxcclxuICAgIGVuZFxyXG4gIF0pLmludG8ocGFyZW50KTtcclxuXHJcbiAgY3JlYXRlQmxvY2soe1xyXG4gICAgbm9kZToge1xyXG4gICAgICBuYW1lOiBibG9jayxcclxuICAgICAgYXR0cnM6IHt9LFxyXG4gICAgICBjaGlsZHJlbjogbmV3IEFycihbXSlcclxuICAgIH0sXHJcbiAgICBhZnRlcjogc3RhcnQsXHJcbiAgICBwYXJlbnRcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJCdWlsdElucyhzZXQsIHNjb3BlLCBwcm90bykge1xyXG4gIGl0ZXJhdGUoc2V0LCAocmVnaXN0ZXIpID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgdmFsdWVcclxuICAgIH0gPSByZWdpc3Rlcihwcm90bywgY3JlYXRlQmxvY2spO1xyXG5cclxuICAgIGlmIChwcm90byA9PT0gQmxvY2spIHtcclxuICAgICAgdmFsdWUuX2h0bWwgPSBkZWVwQ2xvbmVDaGlsZHJlbihcclxuICAgICAgICBtYXJrdXBUb0pTT04oXHJcbiAgICAgICAgICBgJHsgdmFsdWUudGVtcGxhdGUgfHwgJycgfWAsXHJcbiAgICAgICAgICB2YWx1ZS5jb2xsYXBzZVdoaXRlU3BhY2VcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZS5fbWF0Y2ggPSBuZXcgUmVnRXhwKGBeJHsgbmV3IFN0cihuYW1lKS5lc2NhcGVSZWdFeHAoKS4kIH0oPzotKFtcXFxcc1xcXFxTXSspKT8kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2NvcGVbbmFtZV0gPSB2YWx1ZTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2soeyBub2RlLCBhZnRlciwgcGFyZW50LCBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUgfSkge1xyXG4gIHBhcmVudFNjb3BlID0gKG5vZGUgJiYgbm9kZS5ibG9jaykgfHwgcGFyZW50U2NvcGU7XHJcblxyXG4gIGNvbnN0IG5hbWUgPSAobm9kZSAmJiBub2RlLm5hbWUpIHx8ICdVbmtub3duQmxvY2snO1xyXG4gIGNvbnN0IGFyZ3MgPSAobm9kZSAmJiBub2RlLmF0dHJzKSB8fCB7fTtcclxuICBjb25zdCBjaGlsZHJlbiA9IChub2RlICYmIG5vZGUuY2hpbGRyZW4pIHx8IG5ldyBBcnIoW10pO1xyXG4gIGNvbnN0IGVsZW0gPSBwYXJlbnQucHJvcCgnbmFtZXNwYWNlVVJJJykgPT09IHN2Z05TXHJcbiAgICA/IGRvYy5zdmcoKVxyXG4gICAgOiBuZXcgRWxlbShkb2MudGVtcGxhdGUoKS4kWzBdLmNvbnRlbnQpO1xyXG4gIGNvbnN0IGxvY2FsQmxvY2tzID0gcGFyZW50U2NvcGUgPyBwYXJlbnRTY29wZS4kJC5ucy5fYmxvY2tzIDogYmxvY2tzO1xyXG4gIGNvbnN0IGxvY2FsTWl4aW5zID0gcGFyZW50U2NvcGUgPyBwYXJlbnRTY29wZS4kJC5ucy5fbWl4aW5zIDogbWl4aW5zO1xyXG4gIGxldCBjb25zdHJ1Y3RvciA9IG5vZGUgJiYgbm9kZS5uYW1lICYmIGxvY2FsQmxvY2tzW25vZGUubmFtZV07XHJcbiAgbGV0IGRCbG9ja01hdGNoO1xyXG5cclxuICBpZiAoIWNoaWxkcmVuLmxlbmd0aCAmJiAoKGRCbG9ja01hdGNoID0gbmFtZS5tYXRjaCgvXmQtYmxvY2stKFtcXHNcXFNdKykkLykpIHx8IG5hbWUgPT09ICdkLWJsb2NrJykpIHtcclxuICAgIGNvbnN0cnVjdG9yID0gYmxvY2tzWydkLWJsb2NrJ107XHJcbiAgICBhcmdzLm5hbWUgPSBkQmxvY2tNYXRjaCA/IGRCbG9ja01hdGNoWzFdIDogJ3tudWxsfSc7XHJcbiAgfVxyXG5cclxuICBpZiAoIWNvbnN0cnVjdG9yKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IG5vZGU7XHJcblxyXG4gICAgaWYgKG5hbWUgPT09ICcjdGV4dCcgJiYgZXhwcmVzc2lvblJlZ0V4cC50ZXN0KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gY3JlYXRlQmxvY2soe1xyXG4gICAgICAgIG5vZGU6IHtcclxuICAgICAgICAgIG5hbWU6ICdkLXRleHQnLFxyXG4gICAgICAgICAgYXR0cnM6IHsgdmFsdWUgfSxcclxuICAgICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyKFtdKSxcclxuICAgICAgICAgIGJsb2NrOiBwYXJlbnRTY29wZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWZ0ZXIsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICAgIHBhcmVudFNjb3BlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtLmNyZWF0ZShuYW1lKTtcclxuICAgIGNvbnN0IGN1cnJlbnRNaXhpbnMgPSBuZXcgQXJyKFtdKTtcclxuXHJcbiAgICBjb25zdCBhdHRycyA9IG5ldyBTdXBlcihhcmdzKS5vYmplY3QoKG9iamVjdCwgdmFsdWUsIGF0dHIpID0+IHtcclxuICAgICAgbGV0IG1hdGNoO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBuYW1lIGluIGxvY2FsTWl4aW5zKSB7XHJcbiAgICAgICAgY29uc3QgTWl4aW4gPSBsb2NhbE1peGluc1tuYW1lXTtcclxuICAgICAgICBjb25zdCBsb2NhbE1hdGNoID0gYXR0ci5tYXRjaChNaXhpbi5fbWF0Y2gpO1xyXG5cclxuICAgICAgICBpZiAobG9jYWxNYXRjaCkge1xyXG4gICAgICAgICAgbWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIG1hdGNoOiBsb2NhbE1hdGNoLFxyXG4gICAgICAgICAgICBNaXhpbixcclxuICAgICAgICAgICAgbmFtZVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGN1cnJlbnRNaXhpbnMucHVzaCh7XHJcbiAgICAgICAgICBuYW1lOiBtYXRjaC5uYW1lLFxyXG4gICAgICAgICAgTWl4aW46IG1hdGNoLk1peGluLFxyXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLm1hdGNoLFxyXG4gICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICBlbGVtOiBlbGVtZW50LFxyXG4gICAgICAgICAgcGFyZW50QmxvY2ssXHJcbiAgICAgICAgICBwYXJlbnRTY29wZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICBvYmplY3RbYXR0cl0gPSAnJztcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvYmplY3RbYXR0cl0gPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgZWxlbWVudC5hdHRyKGF0dHIsIHZhbHVlKTtcclxuICAgICAgfSwgcGFyZW50QmxvY2spO1xyXG4gICAgfSkuJDtcclxuXHJcbiAgICBpZiAoIWlzTmlsKHZhbHVlKSkge1xyXG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdHRycykge1xyXG4gICAgICBlbGVtZW50LmF0dHIoYXR0cnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhZnRlci5sZW5ndGgpIHtcclxuICAgICAgZWxlbWVudC5pbnNlcnRBZnRlcihhZnRlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50LmludG8ocGFyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBhZnRlciA9IG5ldyBFbGVtKCk7XHJcblxyXG4gICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgIHRyYW5zZm9ybURJZkNoaWxkcmVuKGNoaWxkcmVuKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrID0gY3JlYXRlQmxvY2soe1xyXG4gICAgICAgICAgbm9kZTogY2hpbGQsXHJcbiAgICAgICAgICBhZnRlcixcclxuICAgICAgICAgIHBhcmVudDogZWxlbWVudCxcclxuICAgICAgICAgIHBhcmVudEJsb2NrLFxyXG4gICAgICAgICAgcGFyZW50U2NvcGVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcclxuICAgICAgICAgIGFmdGVyID0gYmxvY2suJCQuZWxlbXMuZW5kO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhZnRlciA9IGJsb2NrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudE1peGlucy5mb3JFYWNoKChvcHRzKSA9PiB7XHJcbiAgICAgIGNyZWF0ZU1peGluKG9wdHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBjb25zdCBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcclxuICAgIG5hbWUsXHJcbiAgICBhcmdzLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBwYXJlbnQsXHJcbiAgICBwYXJlbnRCbG9jayxcclxuICAgIHBhcmVudFNjb3BlXHJcbiAgfSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGJsb2NrSW5zdGFuY2UsIHtcclxuICAgIGFyZ3M6IHtcclxuICAgICAgdmFsdWU6IGJsb2NrSW5zdGFuY2UuYXJnc1xyXG4gICAgfSxcclxuICAgIGdsb2JhbDoge1xyXG4gICAgICB2YWx1ZTogYmxvY2tJbnN0YW5jZS5nbG9iYWxcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgbGV0IGh0bWwgPSBuYW1lID09PSAnZC1lbGVtZW50cydcclxuICAgID8gbmV3IEFycihibG9ja0luc3RhbmNlLmFyZ3MudmFsdWUgfHwgW10pXHJcbiAgICA6IGRlZXBDbG9uZUNoaWxkcmVuKGNvbnN0cnVjdG9yLl9odG1sLCBibG9ja0luc3RhbmNlKTtcclxuXHJcbiAgaWYgKG5hbWUgPT09ICdkLWVsZW1lbnRzJyAmJiBwYXJlbnRCbG9jay4kJC5uYW1lID09PSAnI2QtaXRlbScpIHtcclxuICAgIGh0bWwgPSBkZWVwQ2xvbmVDaGlsZHJlbihodG1sLCBwYXJlbnRCbG9jayk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7XHJcbiAgICAkJCxcclxuICAgIGFyZ3M6IEFyZ3MsXHJcbiAgICBnbG9iYWwsXHJcbiAgICAuLi5sb2NhbHNcclxuICB9ID0gYmxvY2tJbnN0YW5jZTtcclxuXHJcbiAgZGVsZXRlIGxvY2Fscy4kO1xyXG4gIGRlbGV0ZSBsb2NhbHMuJCQ7XHJcblxyXG4gICQkLmFyZ3MgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoQXJncyk7XHJcbiAgJCQubG9jYWxzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGxvY2Fscyk7XHJcbiAgJCQuZ2xvYmFsID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGdsb2JhbCwgJ2dsb2JhbCcsIHBhcmVudFNjb3BlKTtcclxuXHJcbiAgaWYgKG5hbWUgPT09ICcjZC1pdGVtJykge1xyXG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSB7XHJcbiAgICAgIFtub2RlLml0ZW1OYW1lXTogbm9kZS5pdGVtLFxyXG4gICAgICBbbm9kZS5pbmRleE5hbWVdOiBub2RlLmluZGV4XHJcbiAgICB9O1xyXG4gICAgbGV0IHBhcmVudCA9IGJsb2NrSW5zdGFuY2U7XHJcbiAgICBsZXQgc2NvcGUgPSBwYXJlbnRTY29wZTtcclxuICAgIGxldCBESXRlbUZvdW5kO1xyXG5cclxuICAgIHdoaWxlICghREl0ZW1Gb3VuZCAmJiAocGFyZW50ID0gcGFyZW50LiQkLnBhcmVudEJsb2NrKSkge1xyXG4gICAgICBESXRlbUZvdW5kID0gcGFyZW50LiQkLm5hbWUgPT09ICcjZC1pdGVtJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoREl0ZW1Gb3VuZCkge1xyXG4gICAgICBzY29wZSA9IHBhcmVudC4kJC5zY29wZTtcclxuICAgIH1cclxuXHJcbiAgICAkJC5ucyA9IHBhcmVudFNjb3BlLiQkLm5zO1xyXG4gICAgJCQucHJpdmF0ZVNjb3BlID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKHNjb3BlVmFsdWVzKTtcclxuICAgIGNvbnN0cnVjdFB1YmxpY1Njb3BlKCQkLnNjb3BlID0gT2JqZWN0LmNyZWF0ZShzY29wZSksIHNjb3BlVmFsdWVzLCAkJC5wcml2YXRlU2NvcGUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5hbWUgPT09ICdkLWVhY2gnKSB7XHJcbiAgICAkJC5zY29wZSA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0UHVibGljU2NvcGUoQXJncywgQXJncywgJCQuYXJncyk7XHJcbiAgY29uc3RydWN0UHVibGljU2NvcGUoZ2xvYmFsLCBnbG9iYWwsICQkLmdsb2JhbCk7XHJcbiAgY29uc3RydWN0UHVibGljU2NvcGUoYmxvY2tJbnN0YW5jZSwgbG9jYWxzLCAkJC5sb2NhbHMpO1xyXG5cclxuICB0cnkge1xyXG4gICAgYmxvY2tJbnN0YW5jZS5hZnRlckNvbnN0cnVjdCgpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyQ29uc3RydWN0OmAsIGVycik7XHJcbiAgfVxyXG5cclxuICBjb25zdCBlbGVtcyA9IG5ldyBFbGVtKFtcclxuICAgICQkLmVsZW1zLnN0YXJ0LFxyXG4gICAgJCQuZWxlbXMuZW5kXHJcbiAgXSk7XHJcblxyXG4gIGlmIChhZnRlci5sZW5ndGgpIHtcclxuICAgIGVsZW1zLmluc2VydEFmdGVyKGFmdGVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZWxlbXMuaW50byhwYXJlbnQpO1xyXG4gIH1cclxuXHJcbiAgYWZ0ZXIgPSAkJC5lbGVtcy5zdGFydDtcclxuXHJcbiAgdHJhbnNmb3JtRElmQ2hpbGRyZW4oaHRtbCkuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgIGNvbnN0IGJsb2NrID0gY3JlYXRlQmxvY2soe1xyXG4gICAgICBub2RlOiBjaGlsZCxcclxuICAgICAgYWZ0ZXIsXHJcbiAgICAgIHBhcmVudCxcclxuICAgICAgcGFyZW50QmxvY2s6IGJsb2NrSW5zdGFuY2UsXHJcbiAgICAgIHBhcmVudFNjb3BlXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xyXG4gICAgICBjb25zdCB7IGVsZW1zIH0gPSBibG9jay4kJDtcclxuXHJcbiAgICAgIGFmdGVyID0gZWxlbXMuZW5kO1xyXG5cclxuICAgICAgJCQuZWxlbXMuY29udGVudC5hZGQoZWxlbXMuc3RhcnQsIGVsZW1zLmNvbnRlbnQsIGVsZW1zLmVuZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZnRlciA9IGJsb2NrO1xyXG5cclxuICAgICAgJCQuZWxlbXMuY29udGVudC5hZGQoYmxvY2spO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICB0cnkge1xyXG4gICAgYmxvY2tJbnN0YW5jZS5hZnRlclJlbmRlcigpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyUmVuZGVyOmAsIGVycik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYmxvY2tJbnN0YW5jZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTWl4aW4oeyBuYW1lLCBNaXhpbiwgdmFsdWUsIG1hdGNoLCBlbGVtLCBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUgfSkge1xyXG4gIGNvbnN0IG1peGluID0gbmV3IE1peGluKHtcclxuICAgIG5hbWUsXHJcbiAgICB2YWx1ZSxcclxuICAgIG1hdGNoLFxyXG4gICAgZWxlbSxcclxuICAgIHBhcmVudEJsb2NrLFxyXG4gICAgcGFyZW50U2NvcGVcclxuICB9KTtcclxuXHJcbiAgaWYgKE1peGluLmV2YWx1YXRlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IG1peGluLnZhbHVlID0gbWl4aW4uZXZhbHVhdGVBbmRXYXRjaCgobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XHJcbiAgICAgIG1peGluLnZhbHVlID0gbmV3VmFsdWU7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG1peGluLmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclVwZGF0ZTpgLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtaXhpbi5hZnRlclVwZGF0ZSh2YWx1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWVwQ2xvbmVDaGlsZHJlbihjaGlsZHJlbiwgYmxvY2spIHtcclxuICByZXR1cm4gbmV3IEFycihjaGlsZHJlbiB8fCBbXSkubWFwKChjaGlsZCkgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBhdHRycyxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9ID0gY2hpbGQ7XHJcbiAgICBjb25zdCBuZXdDaGlsZCA9IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIGF0dHJzOiB7IC4uLmF0dHJzIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKGJsb2NrKSB7XHJcbiAgICAgIG5ld0NoaWxkLmJsb2NrID0gYmxvY2s7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgIG5ld0NoaWxkLmNoaWxkcmVuID0gZGVlcENsb25lQ2hpbGRyZW4oY2hpbGRyZW4sIGJsb2NrKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3Q2hpbGQ7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybURJZkNoaWxkcmVuKGNoaWxkcmVuKSB7XHJcbiAgcmV0dXJuIG5ldyBBcnIoY2hpbGRyZW4gfHwgW10pXHJcbiAgICAuY29uY2F0KHt9KVxyXG4gICAgLm9iamVjdCgob2JqZWN0LCBjaGlsZCkgPT4ge1xyXG4gICAgICBjb25zdCB7IG5hbWUgfSA9IGNoaWxkO1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgaHRtbCxcclxuICAgICAgICBpZkVsc2VcclxuICAgICAgfSA9IG9iamVjdDtcclxuXHJcbiAgICAgIGlmIChuYW1lICE9PSAnZC1lbHNlLWlmJyAmJiBuYW1lICE9PSAnZC1lbHNlJykge1xyXG4gICAgICAgIGlmIChpZkVsc2UpIHtcclxuICAgICAgICAgIGh0bWwucHVzaCh7XHJcbiAgICAgICAgICAgIG5hbWU6ICdkLWlmJyxcclxuICAgICAgICAgICAgYmxvY2s6IGlmRWxzZS4kWzBdLmJsb2NrLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogaWZFbHNlXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBvYmplY3QuaWZFbHNlID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09PSAnZC1pZicpIHtcclxuICAgICAgICAgIG9iamVjdC5pZkVsc2UgPSBuZXcgQXJyKFtjaGlsZF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG5hbWUpKSB7XHJcbiAgICAgICAgICBodG1sLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAoaWZFbHNlIHx8IGh0bWwpLnB1c2goY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAobmFtZSA9PT0gJ2QtZWxzZScgJiYgaWZFbHNlKSB7XHJcbiAgICAgICAgICBodG1sLnB1c2goe1xyXG4gICAgICAgICAgICBuYW1lOiAnZC1pZicsXHJcbiAgICAgICAgICAgIGJsb2NrOiBpZkVsc2UuJFswXS5ibG9jayxcclxuICAgICAgICAgICAgY2hpbGRyZW46IGlmRWxzZVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgb2JqZWN0LmlmRWxzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGh0bWw6IG5ldyBBcnIoW10pLFxyXG4gICAgICBpZkVsc2U6IG51bGxcclxuICAgIH0pLiQuaHRtbDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnN0YW5jZU9mQmxvY2soYmxvY2spIHtcclxuICByZXR1cm4gaXNQcm90b3R5cGVPZi5jYWxsKEJsb2NrLCBibG9jaykgJiYgaXNQcm90b3R5cGVPZi5jYWxsKEJsb2NrLnByb3RvdHlwZSwgYmxvY2sucHJvdG90eXBlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnN0YW5jZU9mTWl4aW4obWl4aW4pIHtcclxuICByZXR1cm4gaXNQcm90b3R5cGVPZi5jYWxsKE1peGluLCBtaXhpbikgJiYgaXNQcm90b3R5cGVPZi5jYWxsKE1peGluLnByb3RvdHlwZSwgbWl4aW4ucHJvdG90eXBlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSkge1xyXG4gIHdhdGNoZXJzVG9SZW1vdmUuZm9yRWFjaCgoeyB3YXRjaGVyLCB3YXRjaGVycyB9KSA9PiB7XHJcbiAgICBjb25zdCBpbmRleCA9IHdhdGNoZXJzLmluZGV4T2Yod2F0Y2hlcik7XHJcblxyXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICB3YXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcml2YXRlU2NvcGUob2JqZWN0LCB0eXBlLCBwYXJlbnRTY29wZSkge1xyXG4gIGxldCBzY29wZSA9IHt9O1xyXG5cclxuICBpZiAodHlwZSA9PT0gJ2dsb2JhbCcpIHtcclxuICAgIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShcclxuICAgICAgcGFyZW50U2NvcGVcclxuICAgICAgICA/IHBhcmVudFNjb3BlLiQkLmdsb2JhbFxyXG4gICAgICAgIDogbnVsbFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgU3VwZXIob2JqZWN0KS5vYmplY3QoKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICBzY29wZVtrZXldID0ge1xyXG4gICAgICB2YWx1ZSxcclxuICAgICAgd2F0Y2hlcnM6IHtcclxuICAgICAgICB0ZW1wOiBuZXcgQXJyKFtdKSxcclxuICAgICAgICBwZXJtOiBuZXcgQXJyKFtdKVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIHNjb3BlKS4kO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xyXG4gIG5ldyBTdXBlcihzY29wZSkuZGVmaW5lKG5ldyBTdXBlcihzY29wZVZhbHVlcykubWFwKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICBjb25zdCBzY29wZSA9IHByaXZhdGVTY29wZVtrZXldO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldCgpIHtcclxuICAgICAgICBpZiAoZXZhbE1vZGUpIHtcclxuICAgICAgICAgIGlmIChnZXR0aW5nLmluZGV4T2Yoc2NvcGUud2F0Y2hlcnMudGVtcCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGdldHRpbmcucHVzaChzY29wZS53YXRjaGVycy50ZW1wKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY29wZS52YWx1ZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBzY29wZS52YWx1ZSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaGFuZ2VkKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBvbGRUZW1wV2F0Y2hlcnMgPSBzY29wZS53YXRjaGVycy50ZW1wLnNsaWNlKCk7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzY29wZS52YWx1ZTtcclxuXHJcbiAgICAgICAgc2NvcGUud2F0Y2hlcnMudGVtcCA9IG5ldyBBcnIoW10pO1xyXG4gICAgICAgIHNjb3BlLnZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIG9sZFRlbXBXYXRjaGVycy5mb3JFYWNoKCh3YXRjaGVyKSA9PiB7XHJcbiAgICAgICAgICB3YXRjaGVyLm9uUmVtb3ZlKCk7XHJcbiAgICAgICAgICB3YXRjaGVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2hhbmdlZC5wdXNoKHtcclxuICAgICAgICAgIHNjb3BlLFxyXG4gICAgICAgICAgb2xkVmFsdWUsXHJcbiAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGlmICghY2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3Qgd2FzID0gbmV3IEFycihbXSk7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgc2NvcGUsXHJcbiAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgb2xkVmFsdWVcclxuICAgICAgICAgICAgfSA9IGNoYW5nZWRbaV07XHJcblxyXG4gICAgICAgICAgICBzY29wZS53YXRjaGVycy5wZXJtLmZvckVhY2goKHdhdGNoZXIpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHdhcy5pbmRleE9mKHdhdGNoZXIpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB3YXMucHVzaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjaGFuZ2VkLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjaGFuZ2VkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICB3YXMuZm9yRWFjaCgod2F0Y2hlciwgaSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgb2xkVmFsdWVcclxuICAgICAgICAgICAgfSA9IHZhbHVlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHdhdGNoZXIodmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pLiQpO1xyXG59XHJcblxyXG5leHBvcnQgeyBCbG9jaywgTWl4aW4sIGluaXRBcHAgfTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2Zvcm1hdHNcclxuICogQHByaXZhdGVcclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgZGlmZmVyZW50IHR5cGVzIG9mIGZvcm1hdHRpbmcgZm9yIHtAbGluayBEYXRlI2Zvcm1hdH0uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU3VwZXIgfSBmcm9tICcuLi9TdXBlcic7XHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XHJcblxyXG5jb25zdCB6ZXJvID0gbmV3IFN0cignMCcpO1xyXG5jb25zdCBkYXlzT2ZUaGVXZWVrTmFtZXMgPSBbXHJcbiAgJ1N1bmRheScsXHJcbiAgJ01vbmRheScsXHJcbiAgJ1R1ZXNkYXknLFxyXG4gICdXZWRuZXNkYXknLFxyXG4gICdUaHVyc2RheScsXHJcbiAgJ0ZyaWRheScsXHJcbiAgJ1NhdHVyZGF5J1xyXG5dO1xyXG5jb25zdCBkYXlzT2ZUaGVXZWVrQWxpYXNlcyA9IG5ldyBTdXBlcihkYXlzT2ZUaGVXZWVrTmFtZXMpLm1hcCgodmFsdWUpID0+IHZhbHVlLnNsaWNlKDAsIDMpKS4kO1xyXG5jb25zdCBtb250aHNOYW1lcyA9IFtcclxuICAnSmFudWFyeScsXHJcbiAgJ0ZlYnJ1YXJ5JyxcclxuICAnTWFyY2gnLFxyXG4gICdBcHJpbCcsXHJcbiAgJ01heScsXHJcbiAgJ0p1bmUnLFxyXG4gICdKdWxlJyxcclxuICAnQXVndXN0JyxcclxuICAnU2VwdGVtYmVyJyxcclxuICAnT2N0b2JlcicsXHJcbiAgJ05vdmVtYmVyJyxcclxuICAnRGVjZW1iZXInXHJcbl07XHJcbmNvbnN0IG1vbnRoc0FsaWFzZXMgPSBuZXcgU3VwZXIobW9udGhzTmFtZXMpLm1hcCgodmFsdWUpID0+IHZhbHVlLnNsaWNlKDAsIDMpKS4kO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBtb2R1bGU6Y29uc3RhbnRzL2Zvcm1hdHN+bWF0Y2hDYWxsYmFja1xyXG4gKiBAcGFyYW0ge0RhdH0gZGF0ZSAtIEQtd3JhcCBvZiBhIGRhdGUgdG8gYXBwbHkgZm9ybWF0IHRvLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gTWF0Y2hlZCBhcHBsaWVkIGV4cHJlc3Npb24uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpjb25zdGFudHMvZm9ybWF0c35mb3JtYXRFeHByXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmb3JtYXQgLSBNYXRjaGVkIGZvcm1hdC5cclxuICogQHByb3BlcnR5IHttb2R1bGU6Y29uc3RhbnRzL2Zvcm1hdHN+bWF0Y2hDYWxsYmFja30gbWF0Y2ggLSBDYWxsYmFjayBpZiB0aGVyZSB3YXMgYSBtYXRjaC5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGUge21vZHVsZTpjb25zdGFudHMvZm9ybWF0c35mb3JtYXRFeHByW119XHJcbiAqIEBkZXNjcmlwdGlvbiBBcnJheSBvZiBkaWZmZXJlbnQgZm9ybWF0cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IFtcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdjY2MnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnYycpLCAzKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnYycsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCdjJylcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ3NzJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ3MnKSwgMilcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ3MnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgncycpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdtbScsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gcm91bmQoZGF0ZVt1dGNdKCdtJyksIDIpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdtJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW3V0Y10oJ20nKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnaGgnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnaCcpLCAyKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnaCcsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCdoJylcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ2RkZGQnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRheXNPZlRoZVdlZWtOYW1lc1tkYXRlW3V0Y10oJ2R3JyldXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdkZGQnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRheXNPZlRoZVdlZWtBbGlhc2VzW2RhdGVbdXRjXSgnZHcnKV1cclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ2RkJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiByb3VuZChkYXRlW3V0Y10oJ2QnKSwgMilcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ2QnLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IGRhdGVbdXRjXSgnZCcpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdNTU1NJyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBtb250aHNOYW1lc1tkYXRlW3V0Y10oJ00nKSAtIDFdXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICdNTU0nLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IG1vbnRoc0FsaWFzZXNbZGF0ZVt1dGNdKCdNJykgLSAxXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnTU0nLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgnTScpLCAyKVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAnTScsXHJcbiAgICBtYXRjaDogKGRhdGUsIHV0YykgPT4gZGF0ZVt1dGNdKCdNJylcclxuICB9LFxyXG4gIHtcclxuICAgIGZvcm1hdDogJ3l5eXknLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IHJvdW5kKGRhdGVbdXRjXSgneScpLCA0KVxyXG4gIH0sXHJcbiAge1xyXG4gICAgZm9ybWF0OiAneXknLFxyXG4gICAgbWF0Y2g6IChkYXRlLCB1dGMpID0+IFN0cmluZyhkYXRlW3V0Y10oJ3knKSkuc2xpY2UoLTIpXHJcbiAgfSxcclxuICB7XHJcbiAgICBmb3JtYXQ6ICd5JyxcclxuICAgIG1hdGNoOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW3V0Y10oJ3knKVxyXG4gIH1cclxuXTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gcm91bmRcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAtIE51bWJlciB0byByb3VuZC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0cyAtIE51bWJlciBvZiB0aGUgZGlnaXRzIG9mIHRoZSBvdXRwdXQuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyB3aXRoIG5lY2Vzc2FyeSBhZGRpdGlvbmFsIHN0YXJ0aW5nIHplcm9lcy5cclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kKG51bWJlciwgZGlnaXRzKSB7XHJcbiAgY29uc3Qgc3RyaW5nID0gU3RyaW5nKG51bWJlcik7XHJcbiAgbGV0IHplcm9lcyA9IGRpZ2l0cyAtIHN0cmluZy5sZW5ndGg7XHJcblxyXG4gIHplcm9lcyA9IHplcm9lcyA8IDAgPyAwIDogemVyb2VzO1xyXG5cclxuICByZXR1cm4gemVyby5yZXBlYXQoemVyb2VzKS4kICsgc3RyaW5nO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIERhdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgRGF0IGNsYXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IE51bSB9IGZyb20gJy4vTnVtJztcclxuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9TdHInO1xyXG5pbXBvcnQgeyBzd2l0Y2hlciB9IGZyb20gJy4vU3dpdGNoZXInO1xyXG5pbXBvcnQgeyBjb25zdHJ1Y3RvcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBmb3JtYXRzIGZyb20gJy4vY29uc3RhbnRzL2Zvcm1hdHMnO1xyXG5pbXBvcnQgeyBpc0RhdGUsIGl0ZXJhdGUsIFN5bWJvbCwgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeyp9IERhdGVMaWtlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeydjJ3wncyd8J20nfCdoJ3wnZCd8J3cnfCdNJ3wneSd9IEFkZFBlcmlvZFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsnYyd8J3MnfCdtJ3wnaCd8J2QnfCdkdyd8J00nfCd5J30gR2V0UGVyaW9kXHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeydjJ3wncyd8J20nfCdoJ3wnZCd8J00nfCd5J30gT2ZPbmVQZXJpb2RcclxuICogQHB1YmxpY1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7J2MnfCdzJ3wnbSd8J2gnfCdkJ3wnTSd8J3knfSBTZXRQZXJpb2RcclxuICogQHB1YmxpY1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7J2NjYyd8J2MnfCdzcyd8J3MnfCdtbSd8J20nfCdoaCd8J2gnfCdkZGRkJ3wnZGRkJ3wnZGQnfCdkJ3wnTU1NTSd8J01NTSd8J01NJ3wnTSd8J3l5eXknfCd5eSd8J3knfSBGb3JtYXRcclxuICogQHB1YmxpY1xyXG4gKi9cclxuXHJcbmNvbnN0IGNvZWZmcyA9IHtcclxuICBjOiAxLFxyXG4gIHM6IDEwMDAsXHJcbiAgbTogNjAwMDAsXHJcbiAgaDogMzYwMDAwMCxcclxuICBkOiA4NjQwMDAwMCxcclxuICB3OiA2MDQ4MDAwMDAsXHJcbiAgTTogMjU5MjAwMDAwMCxcclxuICB5OiAzMTUzNjAwMDAwMFxyXG59O1xyXG5cclxuY29uc3QgZ2V0U3dpdGNoZXIgPSBzd2l0Y2hlcih7XHJcbiAgYzogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1NaWxsaXNlY29uZHNgXSgpLFxyXG4gIHM6IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9U2Vjb25kc2BdKCksXHJcbiAgbTogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1NaW51dGVzYF0oKSxcclxuICBoOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfUhvdXJzYF0oKSxcclxuICBkOiAoZGF0ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfURhdGVgXSgpLFxyXG4gIGR3OiAoZGF0ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfURheWBdKCksXHJcbiAgTTogKGRhdGUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1Nb250aGBdKCkgKyAxLFxyXG4gIHk6IChkYXRlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9RnVsbFllYXJgXSgpXHJcbn0sICdlcXVhbHMnLCBOYU4pO1xyXG5jb25zdCBzZXRTd2l0Y2hlciA9IHN3aXRjaGVyKHtcclxuICBjOiAoZGF0ZSwgdmFsdWUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1NaWxsaXNlY29uZHNgXSh2YWx1ZSksXHJcbiAgczogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9U2Vjb25kc2BdKHZhbHVlKSxcclxuICBtOiAoZGF0ZSwgdmFsdWUsIHV0YykgPT4gZGF0ZVtgJHsgdXRjIH1NaW51dGVzYF0odmFsdWUpLFxyXG4gIGg6IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfUhvdXJzYF0odmFsdWUpLFxyXG4gIGQ6IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfURhdGVgXSh2YWx1ZSksXHJcbiAgTTogKGRhdGUsIHZhbHVlLCB1dGMpID0+IGRhdGVbYCR7IHV0YyB9TW9udGhgXSh2YWx1ZSAtIDEpLFxyXG4gIHk6IChkYXRlLCB2YWx1ZSwgdXRjKSA9PiBkYXRlW2AkeyB1dGMgfUZ1bGxZZWFyYF0odmFsdWUpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBEYXRcclxuICogQGV4dGVuZHMgU3VwZXJcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlID0gbmV3IERhdGUoKV0gLSBBIGRhdGUgdG8gd3JhcC5cclxuICogQHJldHVybnMge0RhdH0gSW5zdGFuY2Ugb2YgRGF0LlxyXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhIGRhdGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IGRhdGUgPSBuZXcgRGF0KG5ldyBEYXRlKCkpO1xyXG4gKi9cclxuY2xhc3MgRGF0IGV4dGVuZHMgU3VwZXIge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGUgPSBuZXcgRGF0ZSgpKSB7XHJcbiAgICBzdXBlcihkYXRlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIgRGF0IyRcclxuICAgICAqIEB0eXBlIHtEYXRlfVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWdpbmFsIGRhdGUuXHJcbiAgICAgKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2FkZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0FkZFBlcmlvZHxPYmplY3QuPEFkZFBlcmlvZCwgTnVtYmVyPn0gd2hhdCAtIFdoYXQgdG8gYWRkLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyXSAtIE51bWJlciBvZiB3aGF0IHRvIGFkZCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBwZXJpb2Qgc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtEYXR9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBhZGRpbmcgYW1vdW50cyBvZiB0aW1lIHRvIHRoZSBkYXRlLiBSZXR1cm5zIG5ldyBpbnN0YW5jZSBvZiBEYXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5hZGQoJ2MnLCAyKS50b0lTT1N0cmluZygpOyAgICAgICAgIC8vICcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMVonXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykpLmFkZCh7IGM6IDIsIGQ6IDUgfSkudG9JU09TdHJpbmcoKTsgLy8gJzIwMDAtMDEtMDZUMDA6MDA6MDAuMDAxWidcclxuICAgKi9cclxuICBhZGQod2hhdCwgbnVtYmVyKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHdoYXQgPSB7IFt3aGF0XTogbnVtYmVyIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGltZSh0aGlzLnRpbWUoKSArIG5ldyBTdXBlcih3aGF0KS5zdW0oKHZhbHVlLCB3aGF0KSA9PiBjb2VmZnNbd2hhdF0gKiB2YWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjZXhwaXJlc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZSA9IHRoaXNdIC0gVmFsdWUgdG8gcmVzb2x2ZSBhZnRlciB0aGUgZGF0ZSBleHBpcmVzLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBkZWZpbmluZyB3aGVuIHRoZSBkYXRlIGV4cGlyZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQoKS5hZGQoJ2MnLCA1MDApLmV4cGlyZXMoJ0V4cGlyZWQnKS50aGVuKCh2YWx1ZSkgPT4ge1xyXG4gICAqICAgLy8gQWZ0ZXIgNTAwIG1pbGxpc2Vjb25kc1xyXG4gICAqICAgY29uc29sZS5sb2codmFsdWUpOyAvLyAnRXhwaXJlZCdcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBleHBpcmVzKHZhbHVlKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgdmFsdWUgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgTnVtKHRoaXMuJCAtIG5vdygpKS50aW1lb3V0KHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2Zvcm1hdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gVGVtcGxhdGUgZm9yIHRoZSBvdXRwdXQuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXggPSAnJ10gLSBJZiBuZWVkZWQgW2FsbCBzcGVjaWFsIHN0cmluZ3Nde0BsaW5rIEZvcm1hdH1cclxuICAgKiBhcmUgdHJlYXRlZCBhcyB0aGV5IHNob3VsZCBiZSBwcmVmaXggd2l0aCBwcmVmaXguXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gRm9ybWF0dGVkIHN0cmluZy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBmb3JtYXR0ZWQgb3V0cHV0IGJhc2VkIG9uIGEgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KCcxOTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKS5mb3JtYXQoJ1NlY29uZHM6ICRzcywgbWlsbGlzZWNvbmRzOiAkY2NjLicsICckJyk7XHJcbiAgICogLy8gJ1NlY29uZHM6IDU5LCBtaWxsaXNlY29uZHM6IDk5OS4nXHJcbiAgICovXHJcbiAgZm9ybWF0KHN0cmluZywgcHJlZml4ID0gJycpIHtcclxuICAgIHN0cmluZyA9IG5ldyBTdHIobmV3IFN1cGVyKHN0cmluZykuJCk7XHJcbiAgICBwcmVmaXggPSBTdHJpbmcobmV3IFN1cGVyKHByZWZpeCkuJCk7XHJcblxyXG4gICAgaXRlcmF0ZShmb3JtYXRzLCAoZm9ybWF0KSA9PiB7XHJcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlU3RyaW5nKHByZWZpeCArIGZvcm1hdC5mb3JtYXQsIGZvcm1hdC5tYXRjaCh0aGlzLCAnZ2V0JykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN0cmluZy4kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjZm9ybWF0VVRDXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBTZWUge0BsaW5rIERhdCNmb3JtYXR9LlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4ID0gJyddIC0gU2VlIHtAbGluayBEYXQjZm9ybWF0fS5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBGb3JtYXR0ZWQgc3RyaW5nLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBVVEMgdmVyc2lvbiBvZiB7QGxpbmsgRGF0I2Zvcm1hdH0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQoJzE5OTktMDctMDdUMDM6MDk6MDkuMDk5WicpLmZvcm1hdFVUQyhcclxuICAgKiAgIGBcclxuICAgKiAgICAgTWlsbGlzZWNvbmRzOiAkY2NjfCRjLlxyXG4gICAqICAgICBTZWNvbmRzOiAgICAgICRzc3wkcy5cclxuICAgKiAgICAgTWludXRlczogICAgICAkbW18JG0uXHJcbiAgICogICAgIEhvdXJzOiAgICAgICAgJGhofCRoLlxyXG4gICAqICAgICBEYXk6ICAgICAgICAgICRkZGRkfCRkZGR8JGRkfCRkLlxyXG4gICAqICAgICBNb250aDogICAgICAgICRNTU1NfCRNTU18JE1NfCRNLlxyXG4gICAqICAgICBZZWFyOiAgICAgICAgICR5eXl5fCR5eXwkeS5cclxuICAgKiAgIGAsXHJcbiAgICogICAnJCdcclxuICAgKiApO1xyXG4gICAqIC8vIE1pbGxpc2Vjb25kczogMDk5fDk5LlxyXG4gICAqIC8vIFNlY29uZHM6ICAgICAgMDl8OS5cclxuICAgKiAvLyBNaW51dGVzOiAgICAgIDA5fDkuXHJcbiAgICogLy8gSG91cnM6ICAgICAgICAwM3wzLlxyXG4gICAqIC8vIERheTogICAgICAgICAgRnJpZGF5fEZyaXwwN3w3LlxyXG4gICAqIC8vIE1vbnRoOiAgICAgICAgSnVseXxKdWx8MDd8Ny5cclxuICAgKiAvLyBZZWFyOiAgICAgICAgIDE5OTl8OTl8MTk5OS5cclxuICAgKi9cclxuICBmb3JtYXRVVEMoc3RyaW5nLCBwcmVmaXggPSAnJykge1xyXG4gICAgc3RyaW5nID0gbmV3IFN0cihuZXcgU3VwZXIoc3RyaW5nKS4kKTtcclxuICAgIHByZWZpeCA9IFN0cmluZyhuZXcgU3VwZXIocHJlZml4KS4kKTtcclxuXHJcbiAgICBpdGVyYXRlKGZvcm1hdHMsIChmb3JtYXQpID0+IHtcclxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2VTdHJpbmcocHJlZml4ICsgZm9ybWF0LmZvcm1hdCwgZm9ybWF0Lm1hdGNoKHRoaXMsICdnZXRVVEMnKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc3RyaW5nLiQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNnZXRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtHZXRQZXJpb2R9IHdoYXQgLSBXaGF0IHRvIGdldC5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2Ygd2hhdCB0byBnZXQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyB2YWx1ZXMgc3VjaCBhcyBzZWNvbmRzIG9yIG1pbnV0ZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKS5nZXQoJ3MnKTsgLy8gNTlcclxuICAgKi9cclxuICBnZXQod2hhdCkge1xyXG4gICAgcmV0dXJuIGdldFN3aXRjaGVyKHdoYXQsIFt0aGlzLiQsICdnZXQnXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNnZXRVVENcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtHZXRQZXJpb2R9IHdoYXQgLSBTZWUge0BsaW5rIERhdCNnZXR9LlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiB3aGF0IHRvIGdldC5cclxuICAgKiBAZGVzY3JpcHRpb24gVVRDIHZlcnNpb24gb2Yge0BsaW5rIERhdCNnZXR9LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBkYXRlID0gbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykpO1xyXG4gICAqXHJcbiAgICogZGF0ZS5nZXRVVEMoJ2MnKTsgIC8vIDk5OVxyXG4gICAqIGRhdGUuZ2V0VVRDKCdzJyk7ICAvLyA1OVxyXG4gICAqIGRhdGUuZ2V0VVRDKCdtJyk7ICAvLyA1OVxyXG4gICAqIGRhdGUuZ2V0VVRDKCdoJyk7ICAvLyAyM1xyXG4gICAqIGRhdGUuZ2V0VVRDKCdkJyk7ICAvLyAzMVxyXG4gICAqIGRhdGUuZ2V0VVRDKCdkdycpOyAvLyA1XHJcbiAgICogZGF0ZS5nZXRVVEMoJ00nKTsgIC8vIDEyXHJcbiAgICogZGF0ZS5nZXRVVEMoJ3knKTsgIC8vIDE5OTlcclxuICAgKi9cclxuICBnZXRVVEMod2hhdCkge1xyXG4gICAgcmV0dXJuIGdldFN3aXRjaGVyKHdoYXQsIFt0aGlzLiQsICdnZXRVVEMnXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNpc0FmdGVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7RGF0ZUxpa2V9IGRhdGUgLSBEYXRlIHRvIGJlIGNvbXBhcmVkIHRvIHRoaXMgZGF0ZS5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhpcyBkYXRlIGlzIGFmdGVyIHRoZSBhcmd1bWVudCBvbmUuXHJcbiAgICogQGRlc2NyaXB0aW9uIEZpbmRzIG91dCBpZiB0aGlzIGRhdGUgaXMgYWZ0ZXIgdGhlIGFyZ3VtZW50IG9uZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgzMzMpKS5pc0FmdGVyKG5ldyBEYXRlKDMzNCkpOyAvLyBmYWxzZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNBZnRlcihuZXcgRGF0ZSgzMzIpKTsgLy8gdHJ1ZVxyXG4gICAqL1xyXG4gIGlzQWZ0ZXIoZGF0ZSkge1xyXG4gICAgZGF0ZSA9IG5ldyBEYXRlKG5ldyBTdXBlcihkYXRlKS4kKTtcclxuXHJcbiAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPCB0aGlzLiQuZ2V0VGltZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjaXNCZWZvcmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtEYXRlTGlrZX0gZGF0ZSAtIERhdGUgdG8gYmUgY29tcGFyZWQgdG8gdGhpcyBkYXRlLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBhcmd1bWVudCBvbmUuXHJcbiAgICogQGRlc2NyaXB0aW9uIEZpbmRzIG91dCBpZiB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBhcmd1bWVudCBvbmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNCZWZvcmUobmV3IERhdGUoMzM0KSk7IC8vIHRydWVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDMzMykpLmlzQmVmb3JlKG5ldyBEYXRlKDMzMikpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIGlzQmVmb3JlKGRhdGUpIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZShuZXcgU3VwZXIoZGF0ZSkuJCk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID4gdGhpcy4kLmdldFRpbWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2lzQmV0d2VlblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0RhdGVMaWtlfSBkYXRlMSAtIFN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICAgKiBAcGFyYW0ge0RhdGVMaWtlfSBkYXRlMiAtIEVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoaXMgZGF0ZSBpcyBhZnRlciBkYXRlMSBhbmQgYmVmb3JlIGRhdGUyLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBGaW5kcyBvdXQgaWYgdGhpcyBkYXRlIGlzIGFmdGVyIGRhdGUxIGFuZCBiZWZvcmUgZGF0ZTIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMzMzKSkuaXNCZXR3ZWVuKG5ldyBEYXRlKDMzMiksIG5ldyBEYXRlKDMzNCkpOyAvLyB0cnVlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgzMzMpKS5pc0JldHdlZW4obmV3IERhdGUoMzM0KSwgbmV3IERhdGUoMzMyKSk7IC8vIGZhbHNlXHJcbiAgICovXHJcbiAgaXNCZXR3ZWVuKGRhdGUxLCBkYXRlMikge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuJC5nZXRUaW1lKCk7XHJcblxyXG4gICAgZGF0ZTEgPSBuZXcgRGF0ZShuZXcgU3VwZXIoZGF0ZTEpLiQpO1xyXG4gICAgZGF0ZTIgPSBuZXcgRGF0ZShuZXcgU3VwZXIoZGF0ZTIpLiQpO1xyXG5cclxuICAgIHJldHVybiB0aW1lID4gZGF0ZTEuZ2V0VGltZSgpICYmIHRpbWUgPCBkYXRlMi5nZXRUaW1lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNpc0ludmFsaWRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBkYXRlIGlzIGludmFsaWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIGRhdGUgaXMgaW52YWxpZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnYScpKS5pc0ludmFsaWQoKTsgLy8gdHJ1ZVxyXG4gICAqIG5ldyBEYXQobmV3IERhdGUoMSkpLmlzSW52YWxpZCgpOyAgIC8vIGZhbHNlXHJcbiAgICovXHJcbiAgaXNJbnZhbGlkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I2lzUGFzc2VkXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZGF0ZSBpcyBwYXNzZWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaWYgdGhlIGRhdGUgaXMgcGFzc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRGF0KG5ldyBEYXRlKDEpKS5pc1Bhc3NlZCgpOyAvLyB0cnVlXHJcbiAgICovXHJcbiAgaXNQYXNzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc0JlZm9yZShub3coKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIERhdCNvZk9uZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge09mT25lUGVyaW9kfSB3aGF0IC0gUGVyaW9kIHRvIGNoZWNrLlxyXG4gICAqIEBwYXJhbSB7RGF0ZUxpa2V9IGRhdGUgLSBEYXRlIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0d28gZGF0ZXMgYXJlIG9mIG9uZSBzZWNvbmQsIG1pbnV0ZSBvciBzb21ldGhpbmcgZWxzZS5cclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpZiB0d28gZGF0ZXMgYXJlIG9mIG9uZSBzZWNvbmQsIG1pbnV0ZSBvciBzb21ldGhpbmcgZWxzZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS4wMDBaJykpLm9mT25lKCdzJywgbmV3IERhdGUoMTk5OS0xMi0zMVQyMzo1OTo1OS4zMzNaJykpOyAvLyB0cnVlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS4wMDBaJykpLm9mT25lKCdzJywgbmV3IERhdGUoMTk5OS0xMi0zMVQyMzo1OTo1OC45OTlaJykpOyAvLyBmYWxzZVxyXG4gICAqL1xyXG4gIG9mT25lKHdoYXQsIGRhdGUpIHtcclxuICAgIGlmICghKHdoYXQgaW4gY29lZmZzKSB8fCB3aGF0ID09PSAndycpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGUgPSBuZXcgRGF0KG5ldyBEYXRlKGRhdGUpKTtcclxuXHJcbiAgICBsZXQgc3RhcnRlZDtcclxuXHJcbiAgICByZXR1cm4gaXRlcmF0ZShjb2VmZnMsIChjb2VmZiwgdykgPT4ge1xyXG4gICAgICBpZiAodyA9PT0gd2hhdCkge1xyXG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXN0YXJ0ZWQgfHwgdyA9PT0gJ3cnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhcnRlZCAmJiB0aGlzLmdldCh3KSAhPT0gZGF0ZS5nZXQodykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pICE9PSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I3NldFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1NldFBlcmlvZHxPYmplY3QuPFNldFBlcmlvZCwgTnVtYmVyPn0gd2hhdCAtIFdoYXQgdG8gYWRkLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyXSAtIE51bWJlciBvZiB3aGF0IHRvIHNldCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBwZXJpb2Qgc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtEYXR9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBzZXR0aW5nIHZhbHVlcyBzdWNoIGFzIHNlY29uZHMgb3IgbWludXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykpLnNldCgncycsIDU4KS5nZXQoJ3MnKTsgICAgICAgICAgIC8vIDU4XHJcbiAgICogbmV3IERhdChuZXcgRGF0ZSgnMTk5OS0xMi0zMVQyMzo1OTo1OS45OTlaJykpLnNldCh7IGM6IDk5OCwgczogNTggfSkuZ2V0KCdjJyk7IC8vIDk5OFxyXG4gICAqL1xyXG4gIHNldCh3aGF0LCBudW1iZXIpIHtcclxuICAgIGNvbnN0IGRhdGUgPSB0aGlzLiQ7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICB3aGF0ID0geyBbd2hhdF06IG51bWJlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHdoYXQgPSBuZXcgU3VwZXIod2hhdCkuJDtcclxuXHJcbiAgICBpdGVyYXRlKHdoYXQsICh2YWx1ZSwgd2hhdCkgPT4ge1xyXG4gICAgICBzZXRTd2l0Y2hlcih3aGF0LCBbZGF0ZSwgdmFsdWUsICdzZXQnXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRGF0I3NldFVUQ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1NldFBlcmlvZHxPYmplY3QuPFNldFBlcmlvZCwgTnVtYmVyPn0gd2hhdCAtIFNlZSB7QGxpbmsgRGF0I3NldH0uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtudW1iZXJdIC0gU2VlIHtAbGluayBEYXQjc2V0fS5cclxuICAgKiBAcmV0dXJucyB7RGF0fSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFVUQyB2ZXJzaW9uIG9mIHtAbGluayBEYXQjc2V0fS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZGF0ZSA9IG5ldyBEYXQobmV3IERhdGUoJzE5OTktMTItMzFUMjM6NTk6NTkuOTk5WicpKTtcclxuICAgKlxyXG4gICAqIGRhdGUuc2V0VVRDKCdjY2MnLCA5OTgpLmdldFVUQygnY2NjJyk7IC8vIDk5OFxyXG4gICAqIGRhdGUuc2V0VVRDKHtcclxuICAgKiAgIHM6IDU4LFxyXG4gICAqICAgbTogNTgsXHJcbiAgICogICBoOiAyMlxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogZGF0ZS5nZXRVVEMoJ3MnKTsgLy8gNThcclxuICAgKiBkYXRlLmdldFVUQygnbScpOyAvLyA1OFxyXG4gICAqIGRhdGUuZ2V0VVRDKCdoJyk7IC8vIDIzXHJcbiAgICovXHJcbiAgc2V0VVRDKHdoYXQsIG51bWJlcikge1xyXG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHdoYXQgPSB7IFt3aGF0XTogbnVtYmVyIH07XHJcbiAgICB9XHJcblxyXG4gICAgd2hhdCA9IG5ldyBTdXBlcih3aGF0KS4kO1xyXG5cclxuICAgIGl0ZXJhdGUod2hhdCwgKHZhbHVlLCB3aGF0KSA9PiB7XHJcbiAgICAgIHNldFN3aXRjaGVyKHdoYXQsIFtkYXRlLCB2YWx1ZSwgJ3NldFVUQyddKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBEYXQjc2V0VVRDXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gLSBUaW1lIHRvIHNldC5cclxuICAgKiBAcmV0dXJucyB7RGF0fE51bWJlcn0gLSBJZiB0aGUgdGltZSBhcmd1bWVudCBpcyBwcmVzZW50IHRoaXMgaXMgcmV0dXJuZWQgb3RoZXJ3aXNlIHRoZSB0aW1lIGlzIHJldHVybmVkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBib3RoXHJcbiAgICogW0RhdGUjZ2V0VGltZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRUaW1lfSBhbmRcclxuICAgKiBbRGF0ZSNzZXRUaW1lXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFRpbWV9LlxyXG4gICAqL1xyXG4gIHRpbWUodGltZSkge1xyXG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuJDtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBkYXRlLnNldFRpbWUodGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xyXG4gIH1cclxuXHJcbiAgdG9JU09TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kLnRvSVNPU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICB0b0xvY2FsZVN0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLiQudG9Mb2NhbGVTdHJpbmcoKTtcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJC50b1N0cmluZygpO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVPZigpIHtcclxuICAgIHJldHVybiB0aGlzLiQudmFsdWVPZigpO1xyXG4gIH1cclxufVxyXG5kZWZpbmVQcm9wZXJ0aWVzKERhdC5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0RhdCdcclxufSk7XHJcblxyXG5jb25zdHJ1Y3RvcnNbMV0ucHVzaCh7XHJcbiAgY2hlY2s6IGlzRGF0ZSxcclxuICBjbHM6IERhdFxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gbm93XHJcbiAqIEBwdWJsaWNcclxuICogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL25vd1xyXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcclxuICogW0RhdGUubm93XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL25vd30uXHJcbiAqL1xyXG5mdW5jdGlvbiBub3coKSB7XHJcbiAgcmV0dXJuIERhdGUubm93KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZGF0ZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RGF0ZUxpa2V9IFtkYXRlID0gbmV3IERhdGUoKV0gLSBEYXRlLWxpa2UgdmFsdWUgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIERhdGUgY29uc3RydWN0b3IuXHJcbiAqIEByZXR1cm5zIHtEYXR9IE5ldyBpbnN0YW5jZSBvZiBEYXQuXHJcbiAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvciBuZXcgRGF0KG5ldyBEYXRlKGRhdGUpKTtcclxuICovXHJcbmZ1bmN0aW9uIGRhdGUoZGF0ZSkge1xyXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXQobmV3IERhdGUobm93KCkpKTtcclxuICB9XHJcblxyXG4gIGRhdGUgPSBuZXcgU3VwZXIoZGF0ZSkuJDtcclxuXHJcbiAgcmV0dXJuIG5ldyBEYXQobmV3IERhdGUoZGF0ZSkpO1xyXG59XHJcblxyXG5leHBvcnQgeyBEYXQsIG5vdywgZGF0ZSB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL2NvbnN0cnVjdFVSTFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBjb25zdHJ1Y3RVUkwgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XHJcbmltcG9ydCB7IHN3aXRjaGVyIH0gZnJvbSAnLi4vU3dpdGNoZXInO1xyXG5pbXBvcnQgeyBpc0FycmF5LCBpc09iamVjdCwgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vY2hlY2tUeXBlcyc7XHJcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtSZWdFeHB9XHJcbiAqIEBkZXNjcmlwdGlvbiBBYnNvbHV0ZSBVUkwgcGF0dGVybi5cclxuICovXHJcbmNvbnN0IGFic29sdXRlVVJMUmVnZXhwID0gL14oKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC98ZGF0YTpbYS16XStcXC9bYS16XSs7YmFzZTY0LCkvaTtcclxuY29uc3QgcXVlcnlTd2l0Y2hlciA9IHN3aXRjaGVyKCdjYWxsJywgKCkgPT4gbmV3IEFycihbXSkpXHJcbiAgLmNhc2UoaXNBcnJheSwgKHByZWZpeCwgcXVlcnkpID0+IHtcclxuICAgIGxldCBxdWVyeVBhcmFtcyA9IG5ldyBBcnIoW10pO1xyXG5cclxuICAgIGl0ZXJhdGUocXVlcnksICh2YWx1ZSkgPT4ge1xyXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBxdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvbmNhdChxdWVyeVN3aXRjaGVyKHZhbHVlLCBbYCR7IHByZWZpeCB9W11gXSkpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHF1ZXJ5UGFyYW1zLnB1c2goe1xyXG4gICAgICAgIHBhcmFtOiBgJHsgcHJlZml4IH1bXWAsXHJcbiAgICAgICAgdmFsdWVcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcXVlcnlQYXJhbXMuJDtcclxuICB9KVxyXG4gIC5jYXNlKGlzUGxhaW5PYmplY3QsIChwcmVmaXgsIHF1ZXJ5KSA9PiB7XHJcbiAgICBsZXQgcXVlcnlQYXJhbXMgPSBuZXcgQXJyKFtdKTtcclxuXHJcbiAgICBpdGVyYXRlKHF1ZXJ5LCAodmFsdWUsIHBhcmFtKSA9PiB7XHJcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXMuY29uY2F0KHF1ZXJ5U3dpdGNoZXIodmFsdWUsIFtwcmVmaXggPyBgJHsgcHJlZml4IH1bJHsgcGFyYW0gfV1gIDogcGFyYW1dKSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcXVlcnlQYXJhbXMucHVzaCh7XHJcbiAgICAgICAgcGFyYW06IHByZWZpeCA/IGAkeyBwcmVmaXggfVskeyBwYXJhbSB9XWAgOiBwYXJhbSxcclxuICAgICAgICB2YWx1ZTogaXNPYmplY3QodmFsdWUpID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBxdWVyeVBhcmFtcy4kO1xyXG4gIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBjb25zdHJ1Y3RVUkxcclxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VVUkwgLSBCYXNlVVJMIG9mIHRoZSBvdXRwdXQgVVJMLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gTWFpbiBwYXJ0IG9mIHRoZSBvdXRwdXQgVVJMLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1zIHRvIHJlcGxhY2UgaW4gdGhlIHVybCBleHByZXNzaW9ucyBsaWtlIFwiOnBhcmFtXCIuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeSAtIE9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtcy5cclxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNoID0gJyddIC0gVVJMIGhhc2guXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW5jb2RlT3B0aW9ucyA9IHt9XSAtIElmIHlvdSBuZWVkIHRvIGVuY29kZSBzb21ldGhpbmcuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW5jb2RlT3B0aW9ucy5wYXJhbXMgPSB0cnVlXSAtIElmIHlvdSBuZWVkIHRvIGVuY29kZSBwYXJhbXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW5jb2RlT3B0aW9ucy5xdWVyeSA9IHRydWVdIC0gSWYgeW91IG5lZWQgdG8gZW5jb2RlIHF1ZXJ5IHBhcmFtcy5cclxuICogQHJldHVybnMge1N0cmluZ30gQ29uc3RydWN0ZWQgVVJMLlxyXG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGNvbnN0cnVjdGluZyBVUkwgZnJvbSB0aGUgYmFzZSBVUkwsIFVSTCwgcGFyYW1zIGFuZCBxdWVyeSBwYXJhbXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCAoYmFzZVVSTCwgdXJsLCBwYXJhbXMsIHF1ZXJ5LCBoYXNoID0gJycsIGVuY29kZU9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gIGNvbnN0IHtcclxuICAgIHBhcmFtczogZW5jb2RlUGFyYW1zID0gdHJ1ZSxcclxuICAgIHF1ZXJ5OiBlbmNvZGVRdWVyeSA9IHRydWVcclxuICB9ID0gZW5jb2RlT3B0aW9ucztcclxuICBsZXQgVVJMID0gaXNBYnNvbHV0ZSh1cmwpXHJcbiAgICA/IHVybFxyXG4gICAgOiBgJHsgU3RyaW5nKGJhc2VVUkwpLnJlcGxhY2UoL1xcLyskLywgJycpIH0vJHsgU3RyaW5nKHVybCkucmVwbGFjZSgvXlxcLysvLCAnJykgfWA7XHJcblxyXG4gIGl0ZXJhdGUocGFyYW1zLCAodmFsdWUsIHBhcmFtKSA9PiB7XHJcbiAgICBVUkwgPSBuZXcgU3RyKFVSTCkucmVwbGFjZVN0cmluZyhgOiR7IHBhcmFtIH1gLCBlbmNvZGUodmFsdWUsIGVuY29kZVBhcmFtcykpLiQ7XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID0gcXVlcnlTd2l0Y2hlcihxdWVyeSwgWycnXSk7XHJcblxyXG4gIGlmIChxdWVyeVBhcmFtcy5sZW5ndGgpIHtcclxuICAgIFVSTCArPSAoVVJMLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgcXVlcnlQYXJhbXNcclxuICAgICAgLm1hcCgoeyBwYXJhbSwgdmFsdWUgfSkgPT4gYCR7IGVuY29kZShwYXJhbSwgZW5jb2RlUXVlcnkpIH09JHsgZW5jb2RlKHZhbHVlLCBlbmNvZGVRdWVyeSkgfWApXHJcbiAgICAgIC5qb2luKCcmJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYCR7IFVSTCB9JHsgaGFzaCA/IGAjJHsgaGFzaCB9YCA6ICcnIH1gO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBpc0Fic29sdXRlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBVUkwgdG8gY2hlY2sgaWYgaXQgaXMgYWJzb2x1dGUgb3Igbm90LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IFVSTCBpcyBhYnNvbHV0ZSBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Fic29sdXRlKHVybCkge1xyXG4gIHJldHVybiBhYnNvbHV0ZVVSTFJlZ2V4cC50ZXN0KHVybCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBTdHJpbmcgdG8gZW5jb2RlIHVzaW5nIGVuY29kZVVSSUNvbXBvbmVudC5cclxuICogQHBhcmFtIHtCb29sZWFufSBpc0VuY29kZWQgLSBJZiB0aGUgc3RyaW5nIHNob3VsZCBiZSBlbmNvZGVkLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBFbmNvZGVkIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZShzdHJpbmcsIGlzRW5jb2RlZCkge1xyXG4gIHJldHVybiBpc0VuY29kZWQgPyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSA6IHN0cmluZztcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBGZXRjaFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgRmV0Y2ggY2xhc3MuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4vUHJvbWlzZSc7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi9TdXBlcic7XHJcbmltcG9ydCB7IEFyciB9IGZyb20gJy4vQXJyJztcclxuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9TdHInO1xyXG5pbXBvcnQge1xyXG4gIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLFxyXG4gIGFzc2lnbiwgU3ltYm9sLCB2YWxpZGF0ZSwgaXRlcmF0ZSwgZGVmaW5lUHJvcGVydGllc1xyXG59IGZyb20gJy4vaGVscGVycyc7XHJcbmltcG9ydCBjb25zdHJ1Y3RVUkwgZnJvbSAnLi9oZWxwZXJzL2NvbnN0cnVjdFVSTCc7XHJcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi9oZWxwZXJzL3BhcnNlSGVhZGVycyc7XHJcbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vaGVscGVycy90cmFuc2Zvcm1EYXRhJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7J2dldCd8J3Bvc3QnfCdkZWxldGUnfCdoZWFkJ3wncHV0J3wncGF0Y2gnfSBGZXRjaE1ldGhvZFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZldGNoQ29uZmlnXHJcbiAqIEBwdWJsaWNcclxuICogQHByb3BlcnR5IHtBcnJheS48QWZ0ZXJNaWRkbGV3YXJlfEZldGNoRXJyb3JBZnRlck1pZGRsZXdhcmU+fSBbYWZ0ZXJdXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYXV0aF1cclxuICogQHByb3BlcnR5IHtTdHJpbmd9IFthdXRoLnVzZXJuYW1lXVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW2F1dGgucGFzc3dvcmRdXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYmFzZVVSTF1cclxuICogQHByb3BlcnR5IHtBcnJheS48QmVmb3JlTWlkZGxld2FyZXxGZXRjaEVycm9yQmVmb3JlTWlkZGxld2FyZT59IFtiZWZvcmVdXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gW2RhdGFdXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZ1tdPn0gW2hlYWRlcnNdXHJcbiAqIEBwcm9wZXJ0eSB7RmV0Y2hNZXRob2R9IFttZXRob2RdXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcGFyYW1zXVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3F1ZXJ5XVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3Jlc3BvbnNlVHlwZV1cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aW1lb3V0XVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3VybF1cclxuICogQHByb3BlcnR5IHtCb29sZWFufSBbd2l0aENyZWRlbnRpYWxzXVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGZXRjaFJlc3BvbnNlXHJcbiAqIEBwdWJsaWNcclxuICogQHByb3BlcnR5IHtGZXRjaENvbmZpZ30gY29uZmlnXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gZGF0YVxyXG4gKiBAcHJvcGVydHkge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBoZWFkZXJzXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGF0dXNcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHN0YXR1c1RleHRcclxuICogQHByb3BlcnR5IHtYTUxIdHRwUmVxdWVzdH0geGhyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEFmdGVyTWlkZGxld2FyZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RmV0Y2hSZXNwb25zZX0gY29uZmlnIC0gRmV0Y2ggcmVzcG9uc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtFcnJvcnwqfSBlcnIgLSBUaHJvd24gZXJyb3IuXHJcbiAqIEBwYXJhbSB7RmV0Y2hSZXNwb25zZX0gY29uZmlnIC0gRmV0Y2ggcmVzcG9uc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEJlZm9yZU1pZGRsZXdhcmVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBjb25maWcgLSBGZXRjaCBjb25maWcuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaEVycm9yQmVmb3JlTWlkZGxld2FyZVxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7RXJyb3J8Kn0gZXJyIC0gVGhyb3duIGVycm9yLlxyXG4gKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBjb25maWcgLSBGZXRjaCBjb25maWcuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBGZXRjaENvbmZpZ0Z1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtGZXRjaENvbmZpZ30gY29uZmlnXHJcbiAqL1xyXG5cclxuY29uc3QgZGVmYXVsdHMgPSB7XHJcbiAgYWZ0ZXI6IFtdLFxyXG4gIGF1dGg6IHtcclxuICAgIHVzZXJuYW1lOiAnJyxcclxuICAgIHBhc3N3b3JkOiAnJ1xyXG4gIH0sXHJcbiAgYmFzZVVSTDogZ2xvYmFsLmxvY2F0aW9uLm9yaWdpbixcclxuICBiZWZvcmU6IFtdLFxyXG4gIGRhdGE6IG51bGwsXHJcbiAgaGVhZGVyczoge30sXHJcbiAgbWV0aG9kOiAnZ2V0JyxcclxuICBwYXJhbXM6IHt9LFxyXG4gIHF1ZXJ5OiB7fSxcclxuICByZXNwb25zZVR5cGU6ICcnLFxyXG4gIHRpbWVvdXQ6IDAsXHJcbiAgdXJsOiAnJyxcclxuICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlXHJcbn07XHJcbmNvbnN0IHVwbG9hZE1ldGhvZHMgPSBuZXcgQXJyKFsncG9zdCcsICdwdXQnXSk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIEZldGNoXHJcbiAqIEBleHRlbmRzIEZ1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtGZXRjaENvbmZpZ30gW2NvbmZpZyA9IHt9XSAtIEEgbnVtYmVyIHRvIHdyYXAuXHJcbiAqIEByZXR1cm5zIHtGZXRjaH0gSW5zdGFuY2Ugb2YgRmV0Y2guXHJcbiAqIEFuIGluc3RhbmNlIG9mIEZldGNoIGlzIGEgZnVuY3Rpb24gdGhhdCBzaW1wbHkgY2FsbHMgI3JlcXVlc3Qgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXHJcbiAqIEBkZXNjcmlwdGlvbiBDbGFzcyBmb3IgZmV0Y2hpbmcgZGF0YS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgZmV0Y2ggPSBuZXcgRmV0Y2goKTtcclxuICpcclxuICogZmV0Y2goJy9kYXRhJykudGhlbigocmVzKSA9PiB7XHJcbiAqICAgY29uc29sZS5sb2cocmVzKTtcclxuICogfSk7XHJcbiAqL1xyXG5jbGFzcyBGZXRjaCBleHRlbmRzIEZ1bmN0aW9uIHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgcmV0dXJuIGZldGNoLnJlcXVlc3QuYXBwbHkoZmV0Y2gsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29uZiA9IG5ldyBTdXBlcih7fSkuZGVlcEFzc2lnbihkZWZhdWx0cywgY29uZmlnKS4kO1xyXG5cclxuICAgIGlmIChjb25mLmJlZm9yZS5pbmRleE9mKGZldGNoQmVmb3JlTWlkZGxld2FyZSkgPT09IC0xKSB7XHJcbiAgICAgIGNvbmYuYmVmb3JlLnB1c2goZmV0Y2hCZWZvcmVNaWRkbGV3YXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge0ZldGNoQ29uZmlnfSBGZXRjaCMkJFxyXG4gICAgICogQHR5cGUge0ZldGNoQ29uZmlnfVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uIEZldGNoIGNvbmZpZy5cclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZldGNoLCAnJCQnLCB7IHZhbHVlOiBjb25mIH0pO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZldGNoLCBGZXRjaC5wcm90b3R5cGUpO1xyXG5cclxuICAgIHJldHVybiBmZXRjaDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjYWZ0ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtGZXRjaEFmdGVyTWlkZGxld2FyZXxGZXRjaEVycm9yQWZ0ZXJNaWRkbGV3YXJlfSBtaWRkbGV3YXJlIC0gTWlkZGxld2FyZSB0byBhZGQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFthZnRlckFsbCA9IHRydWVdIC0gQm9vbGVhbiBwYXJhbWV0ZXIgd2hlcmUgdG8gcHV0IHRoZSBtaWRkbGV3YXJlLlxyXG4gICAqIFRydXRoeSBwYXJhbWV0ZXIgc3RhbmRzIGZvciBcInRvIHRoZSBlbmRcIiBhbmQgZmFsc2V5IGZvciBcInRvIHRoZSBiZWdpbm5pbmdcIi5cclxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWlkZGxld2FyZSB0aGF0IGlzIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdC5cclxuICAgKiBJZiB0aGUgbWlkZGxld2FyZSBoYXMgMiBvciBsZXNzIGFyZ3VtZW50cyBpdCdzIHRyZWF0ZWQgYXMgc3VjY2VzcyBtaWRkbGV3YXJlIG90aGVyd2lzZSBhcyBhbiBlcnJvciBvbmUuXHJcbiAgICogSWYgdGhlIG1pZGRsZXdhcmUgcmV0dXJucyBhIHByb21pc2UgaXQgYmVjb21lcyBhIHBhcnQgb2YgdGhlIG1pZGRsZXdhcmUgY2hhaW4uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKClcclxuICAgKiAgIC5hZnRlcigoZXJyLCByZXMpID0+IHtcclxuICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgKlxyXG4gICAqICAgICB0aHJvdyBlcnI7XHJcbiAgICogICB9KVxyXG4gICAqICAgLmFmdGVyKChyZXMpID0+IHtcclxuICAgKiAgICAgcmVzLmpzb24gPSBEKHJlcy5kYXRhKS5wYXJzZUpTT04oKTpcclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG4gIGFmdGVyKG1pZGRsZXdhcmUsIGFmdGVyQWxsID0gdHJ1ZSkge1xyXG4gICAgdmFsaWRhdGUoW21pZGRsZXdhcmVdLCBbJ2Z1bmN0aW9uJ10sICdGZXRjaCNhZnRlcicpO1xyXG5cclxuICAgIGNvbnN0IHsgYWZ0ZXIgfSA9IHRoaXMuJCQ7XHJcblxyXG4gICAgaWYgKGFmdGVyQWxsKSB7XHJcbiAgICAgIGFmdGVyLnB1c2gobWlkZGxld2FyZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZnRlci51bnNoaWZ0KG1pZGRsZXdhcmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGZXRjaCNiZWZvcmVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtGZXRjaEJlZm9yZU1pZGRsZXdhcmV8RmV0Y2hFcnJvckJlZm9yZU1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBNaWRkbGV3YXJlIHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW58Kn0gW2JlZm9yZUFsbCA9IHRydWVdIC0gQm9vbGVhbiBwYXJhbWV0ZXIgd2hlcmUgdG8gcHV0IHRoZSBtaWRkbGV3YXJlLlxyXG4gICAqIFRydXRoeSBwYXJhbWV0ZXIgc3RhbmRzIGZvciBcInRvIHRoZSBiZWdpbm5pbmdcIiBhbmQgZmFsc2V5IGZvciBcInRvIHRoZSBlbmRcIi5cclxuICAgKiBAcmV0dXJucyB7RmV0Y2h9IFJldHVybnMgdGhpcy5cclxuICAgKiBAZGVzY3JpcHRpb24gTWlkZGxld2FyZSB0aGF0IGlzIGNhbGxlZCBiZWZvcmUgdGhlIHJlcXVlc3QuXHJcbiAgICogSWYgdGhlIG1pZGRsZXdhcmUgaGFzIDIgb3IgbGVzcyBhcmd1bWVudHMgaXQncyB0cmVhdGVkIGFzIHN1Y2Nlc3MgbWlkZGxld2FyZSBvdGhlcndpc2UgYXMgYW4gZXJyb3Igb25lLlxyXG4gICAqIElmIHRoZSBtaWRkbGV3YXJlIHJldHVybnMgYSBwcm9taXNlIGl0IGJlY29tZXMgYSBwYXJ0IG9mIHRoZSBtaWRkbGV3YXJlIGNoYWluLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpXHJcbiAgICogICAuYmVmb3JlKChlcnIsIHJlcSkgPT4ge1xyXG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAqXHJcbiAgICogICAgIHRocm93IGVycjtcclxuICAgKiAgIH0pXHJcbiAgICogICAuYmVmb3JlKChyZXEpID0+IHtcclxuICAgKiAgICAgaWYgKHJlcS51cmwgPT09ICcvdmVyeUxvbmdSZXF1ZXN0Jykge1xyXG4gICAqICAgICAgIHJlcS50aW1lb3V0ID0gMzAwMDA7XHJcbiAgICogICAgIH1cclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG4gIGJlZm9yZShtaWRkbGV3YXJlLCBiZWZvcmVBbGwgPSB0cnVlKSB7XHJcbiAgICB2YWxpZGF0ZShbbWlkZGxld2FyZV0sIFsnZnVuY3Rpb24nXSwgJ0ZldGNoI2JlZm9yZScpO1xyXG5cclxuICAgIGNvbnN0IHsgYmVmb3JlIH0gPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmIChiZWZvcmVBbGwpIHtcclxuICAgICAgYmVmb3JlLnVuc2hpZnQobWlkZGxld2FyZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiZWZvcmUucHVzaChtaWRkbGV3YXJlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjY29uZmlnXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZldGNoQ29uZmlnfEZldGNoQ29uZmlnRnVuY3Rpb259IFtwcm9wZXJ0eV0gLSBJZiBpdCdzIGEgZnVuY3Rpb25cclxuICAgKiBpdCdzIGNhbGxlZCB3aXRoIHRoZSBmZXRjaCBjb25maWcgYXJndW1lbnQsIGlmIGl0J3MgYSBzdHJpbmcgdGhlIHZhbHVlIGFyZ3VtZW50XHJcbiAgICogaXMgdXNlZCBmb3IgYXNzaWduaW5nIHRoaXMgcHJvcGVydHkgdG8gdGhlIGZldGNoIGNvbmZpZ1xyXG4gICAqIG90aGVyd2lzZSBpdCdzIGFzc2lnbmVkIHRvIHRoZSBmZXRjaCBjb25maWcuXHJcbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gU2VlIHRoZSBwcm9wZXJ0eSBhcmd1bWVudC5cclxuICAgKiBAcmV0dXJucyB7RmV0Y2h8RmV0Y2hDb25maWd9IElmIHRoZSBhcmd1bWVudCBpcyBwcmVzZW50IHRoaXMgaXMgcmV0dXJuZWQgb3RoZXJ3aXNlIHRoZSBmZXRjaCBjb25maWcgaXMgcmV0dXJuZWQuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyBjb25maWcuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKCk7XHJcbiAgICpcclxuICAgKiBmZXRjaC5jb25maWcoeyBiYXNlVVJMOiA1MDAwIH0pO1xyXG4gICAqIGZldGNoLmNvbmZpZygpLnRpbWVvdXQ7IC8vIDUwMDBcclxuICAgKlxyXG4gICAqIGZldGNoLmNvbmZpZygoY29uZmlnKSA9PiB7XHJcbiAgICogICBjb25maWcuYmFzZVVSTCArPSAnL2FwaSc7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgY29uZmlnKHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgY29uc3QgY29uZiA9IHRoaXMuJCQ7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBjb25mO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Z1bmN0aW9uKHByb3BlcnR5KSkge1xyXG4gICAgICBwcm9wZXJ0eShjb25mKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmV3IFN1cGVyKGNvbmYpLmRlZXBBc3NpZ24ocHJvcGVydHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGZXRjaCNkZWxldGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt1cmxdIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgZGVsZXRlIHJlcXVlc3RzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRmV0Y2goKS5kZWxldGUoJy9kYXRhJykudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIGRlbGV0ZSh1cmwsIGNvbmZpZyA9IHt9KSB7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgY29uZmlnID0gdXJsO1xyXG4gICAgICB1cmwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwsIGFzc2lnbih7IG1ldGhvZDogJ2RlbGV0ZScgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI2dldFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBnZXQgcmVxdWVzdHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG5ldyBGZXRjaCgpLmdldCgnL2RhdGEnKS50aGVuKChyZXMpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgZ2V0KHVybCwgY29uZmlnID0ge30pIHtcclxuICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICBjb25maWcgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjaGVhZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBoZWFkIHJlcXVlc3RzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRmV0Y2goKS5oZWFkKCcvZGF0YScpLnRoZW4oKHJlcykgPT4ge1xyXG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICBoZWFkKHVybCwgY29uZmlnID0ge30pIHtcclxuICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICBjb25maWcgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAnaGVhZCcgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI2hlYWRlcnNcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIFN0cmluZ3xTdHJpbmdbXT59IGhlYWRlciAtIEEgaGVhZGVyIHN0cmluZyBvciBhbiBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XHJcbiAgICogeyBbaGVhZGVyXTogW3ZhbHVlMSwgdmFsdWUyLCAuLi5dIH0uXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFt2YWx1ZV0gLSBIZWFkZXIgdmFsdWUuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xyXG4gICAqIHRoaXMgaGFzIHRvIGJlIGEgaGVhZGVyIHZhbHVlIG9yIGFuIGFycmF5IG9mIGhlYWRlciB2YWx1ZXMuXHJcbiAgICogQHJldHVybnMge0ZldGNofSBSZXR1cm5zIHRoaXMuXHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igc2V0dGluZyByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGNvbnN0IGZldGNoID0gbmV3IEZldGNoKClcclxuICAgKiAgIC5oZWFkZXJzKCdIZWFkZXIxJywgJ1ZhbHVlJylcclxuICAgKiAgIC5oZWFkZXJzKCdIZWFkZXIyJywgWydWYWx1ZTEnLCAnVmFsdWUyJ10pXHJcbiAgICogICAuaGVhZGVycyh7XHJcbiAgICogICAgIEhlYWRlcjM6IFsnVmFsdWUxJywgJ1ZhbHVlMiddXHJcbiAgICogICB9KTtcclxuICAgKi9cclxuICBoZWFkZXJzKGhlYWRlciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gdGhpcy4kJDtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGhlYWRlciA9IHsgW2hlYWRlcl06IHZhbHVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgaXRlcmF0ZShoZWFkZXIsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5ID0gaGVhZGVyc1toZWFkZXJdIHx8IFtdO1xyXG4gICAgICBjb25zdCB0b1B1c2ggPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcclxuXHJcbiAgICAgIChoZWFkZXJzW2hlYWRlcl0gPSBhcnJheSkucHVzaC5hcHBseShhcnJheSwgdG9QdXNoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBGZXRjaCNpbnN0YW5jZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIE5ldyBjb25maWcgaWYgbmVlZGVkLlxyXG4gICAqIEByZXR1cm5zIHtGZXRjaH0gTmV3IGluc3RhbmNlIG9mIEZldGNoLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBmZXRjaCBpbnN0YW5jZXMgYmFzZWQgb24gYWxyZWFkeSBleGlzdGVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgbWFpbkZldGNoID0gbmV3IEZldGNoKHtcclxuICAgKiAgIGJhc2VVUkw6ICcvL290aGVyLmRvbWFpbi5jb20vYXBpJyxcclxuICAgKiAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZVxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogY29uc3QgbG9uZ0ZldGNoID0gbWFpbkZldGNoLmluc3RhbmNlKHtcclxuICAgKiAgIHRpbWVvdXQ6IDEwMDAwXHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgaW5zdGFuY2UoY29uZmlnID0ge30pIHtcclxuICAgIGNvbnN0IGRhdGFDb25maWcgPSBuZXcgU3VwZXIoY29uZmlnKS5oYXNPd24oJ2RhdGEnKVxyXG4gICAgICA/IHsgZGF0YTogY29uZmlnLmRhdGEgfVxyXG4gICAgICA6IHt9O1xyXG5cclxuICAgIGRlbGV0ZSBjb25maWcuZGF0YTtcclxuXHJcbiAgICBjb25zdCBjb25mID0gbmV3IFN1cGVyKHt9KVxyXG4gICAgICAuZGVlcEFzc2lnbih0aGlzLiQkLCBjb25maWcpXHJcbiAgICAgIC5hc3NpZ24oZGF0YUNvbmZpZylcclxuICAgICAgLiQ7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBGZXRjaChjb25mKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjcGF0Y2hcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt1cmxdIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyIGZvciB1cGxvYWRpbmcgZGF0YS5cclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgaGVhZCByZXF1ZXN0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEZldGNoKCkucGF0Y2goJy9kYXRhJywgeyB1c2VyOiAnSm9obicgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHBhdGNoKHVybCwgZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgIWlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgY29uZmlnID0gZGF0YTtcclxuICAgICAgZGF0YSA9IHVybDtcclxuICAgICAgdXJsID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsLCBhc3NpZ24oeyBtZXRob2Q6ICdwYXRjaCcsIGRhdGEgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI3Bvc3RcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt1cmxdIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyIGZvciB1cGxvYWRpbmcgZGF0YS5cclxuICAgKiBAcGFyYW0ge0ZldGNoQ29uZmlnfSBbY29uZmlnXSAtIFNlZSB7QGxpbmsgRmV0Y2gjcmVxdWVzdH0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2UuPEZldGNoUmVzcG9uc2UsIEVycm9yPn0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAZGVzY3JpcHRpb24gU2hvcnRoYW5kIGZvciAjcmVxdWVzdCBmb3IgaGVhZCByZXF1ZXN0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogbmV3IEZldGNoKCkucG9zdCgnL2RhdGEnLCB7IHVzZXI6ICdKb2huJyB9KS50aGVuKChyZXMpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHJlcyk7XHJcbiAgICogfSk7XHJcbiAgICovXHJcbiAgcG9zdCh1cmwsIGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmICFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgIGNvbmZpZyA9IGRhdGE7XHJcbiAgICAgIGRhdGEgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAncG9zdCcsIGRhdGEgfSwgY29uZmlnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIEZldGNoI3B1dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXIgZm9yIHVwbG9hZGluZyBkYXRhLlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gU2VlIHtAbGluayBGZXRjaCNyZXF1ZXN0fS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48RmV0Y2hSZXNwb25zZSwgRXJyb3I+fSBTZWUge0BsaW5rIEZldGNoI3JlcXVlc3R9LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgZm9yICNyZXF1ZXN0IGZvciBoZWFkIHJlcXVlc3RzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBuZXcgRmV0Y2goKS5wdXQoJy9kYXRhJywgeyB1c2VyOiAnSm9obicgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqL1xyXG4gIHB1dCh1cmwsIGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmICFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgIGNvbmZpZyA9IGRhdGE7XHJcbiAgICAgIGRhdGEgPSB1cmw7XHJcbiAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgYXNzaWduKHsgbWV0aG9kOiAncHV0JywgZGF0YSB9LCBjb25maWcpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgRmV0Y2gjcmVxdWVzdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3VybF0gLSBVUkwgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IFtjb25maWddIC0gQWRkaXRpb25hbCBjb25maWcgZm9yIHRoaXMgcGFydGljdWxhciByZXF1ZXN0LlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxGZXRjaFJlc3BvbnNlLCBFcnJvcj59IFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXF1ZXN0IHJlc3BvbnNlLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBNYWluIGZ1bmN0aW9uIGZvciBtYWtpbmcgcmVxdWVzdHMuIEFsbCByZXF1ZXN0IG1ldGhvZHMgY2FsbCB0aGlzIG1ldGhvZFxyXG4gICAqIGluY2x1ZGluZyB0aGUgZmV0Y2ggaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpO1xyXG4gICAqXHJcbiAgICogZmV0Y2gucmVxdWVzdCgnL2RhdGEnLCB7IHRpbWVvdXQ6IDEwMDAgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogZmV0Y2gucmVxdWVzdCh7IHRpbWVvdXQ6IDEwMDAgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogZmV0Y2gucmVxdWVzdCgpLnRoZW4oKHJlcykgPT4ge1xyXG4gICAqICAgY29uc29sZS5sb2cocmVzKTtcclxuICAgKiB9KTtcclxuICAgKi9cclxuICByZXF1ZXN0KHVybCwgY29uZmlnID0ge30pIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgIGNvbmZpZyA9IHVybDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhQ29uZmlnID0gbmV3IFN1cGVyKGNvbmZpZykuaGFzT3duKCdkYXRhJylcclxuICAgICAgPyB7IGRhdGE6IGNvbmZpZy5kYXRhIH1cclxuICAgICAgOiB7fTtcclxuICAgIGNvbnN0IHVybENvbmZpZyA9IGlzU3RyaW5nKHVybClcclxuICAgICAgPyB7IHVybCB9XHJcbiAgICAgIDoge307XHJcblxyXG4gICAgZGVsZXRlIGNvbmZpZy5kYXRhO1xyXG5cclxuICAgIGNvbnN0IGNvbmYgPSBuZXcgU3VwZXIodGhpcy4kJClcclxuICAgICAgLmRlZXBDbG9uZSgpXHJcbiAgICAgIC5kZWVwQXNzaWduKHVybENvbmZpZywgY29uZmlnKVxyXG4gICAgICAuYXNzaWduKGRhdGFDb25maWcpXHJcbiAgICAgIC4kO1xyXG5cclxuICAgIGxldCB4aHI7XHJcbiAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5cclxuICAgIGl0ZXJhdGUoY29uZi5iZWZvcmUsIChtaWRkbGV3YXJlKSA9PiB7XHJcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIGlmIChtaWRkbGV3YXJlLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgIHJlc29sdmUobWlkZGxld2FyZShjb25mKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sIChlcnIpID0+IHtcclxuICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZShtaWRkbGV3YXJlKGVyciwgY29uZikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgYWZ0ZXIsXHJcbiAgICAgICAgYXV0aDoge1xyXG4gICAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgICBwYXNzd29yZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIG1ldGhvZCxcclxuICAgICAgICBvbnByb2dyZXNzLFxyXG4gICAgICAgIHJlc3BvbnNlVHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHVybCxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHNcclxuICAgICAgfSA9IGNvbmY7XHJcblxyXG4gICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlLCB1c2VybmFtZSwgcGFzc3dvcmQpO1xyXG5cclxuICAgICAgaXRlcmF0ZShoZWFkZXJzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChvbnByb2dyZXNzKSB7XHJcbiAgICAgICAgaWYgKHVwbG9hZE1ldGhvZHMuaW5kZXhPZlN0cmljdChtZXRob2QpID09PSAtMSkge1xyXG4gICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBvbnByb2dyZXNzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBvbnByb2dyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIGFib3J0ZWQnKTtcclxuXHJcbiAgICAgICAgZXJyb3IudHlwZSA9ICdBQk9SVF9FUlJPUic7XHJcblxyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcblxyXG4gICAgICAgIHhociA9IG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB4aHIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpO1xyXG5cclxuICAgICAgICBlcnJvci50eXBlID0gJ05FVFdPUktfRVJST1InO1xyXG5cclxuICAgICAgICByZWplY3QoZXJyb3IpO1xyXG5cclxuICAgICAgICB4aHIgPSBudWxsO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgeGhyLm9udGltZW91dCA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCB0aW1lIGV4Y2VlZGVkJyk7XHJcblxyXG4gICAgICAgIGVycm9yLnR5cGUgPSAnVElNRU9VVF9FUlJPUic7XHJcblxyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcblxyXG4gICAgICAgIHhociA9IG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICgheGhyIHx8ICF4aHIuc3RhdHVzIHx8IHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcclxuICAgICAgICAgIGNvbmZpZzogY29uZixcclxuICAgICAgICAgIGRhdGE6ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyB4aHIucmVzcG9uc2VUZXh0IDogeGhyLnJlc3BvbnNlLFxyXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSksXHJcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHhoci5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgeGhyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuXHJcbiAgICAgICAgaXRlcmF0ZShhZnRlciwgKG1pZGRsZXdhcmUpID0+IHtcclxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShtaWRkbGV3YXJlKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWlkZGxld2FyZS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgIHJlc29sdmUobWlkZGxld2FyZShlcnIsIHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlc29sdmUocHJvbWlzZVxyXG4gICAgICAgICAgLnRoZW4oKCkgPT4gcmVzcG9uc2UpXHJcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGVyci5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICB4aHIudGltZW91dCA9IE51bWJlcih0aW1lb3V0KSB8fCAwO1xyXG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISF3aXRoQ3JlZGVudGlhbHM7XHJcblxyXG4gICAgICB4aHIuc2VuZChkYXRhKTtcclxuICAgIH0pKTtcclxuXHJcbiAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XHJcbiAgICAgIGlmICh4aHIpIHtcclxuICAgICAgICB4aHIuYWJvcnQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG4gIH1cclxufVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhGZXRjaC5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0ZldGNoJ1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gZmV0Y2hCZWZvcmVNaWRkbGV3YXJlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RmV0Y2hDb25maWd9IGNvbmZpZ1xyXG4gKiBAZGVzY3JpcHRpb24gQnVpbHQtaW4gYmVmb3JlIG1pZGRsZXdhcmUgZm9yIHVybCwgZGF0YSwgbWV0aG9kLCBoZWFkZXJzIGNvbnN0cnVjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGZldGNoQmVmb3JlTWlkZGxld2FyZShjb25maWcpIHtcclxuICBjb25zdCB7XHJcbiAgICBiYXNlVVJMLFxyXG4gICAgZGF0YSxcclxuICAgIGhlYWRlcnMsXHJcbiAgICBtZXRob2QsXHJcbiAgICBwYXJhbXMsXHJcbiAgICBxdWVyeSxcclxuICAgIHVybFxyXG4gIH0gPSBjb25maWc7XHJcbiAgY29uc3QgTUVUSE9EID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gIGNvbmZpZy5tZXRob2QgPSBNRVRIT0Q7XHJcbiAgY29uZmlnLnVybCA9IGNvbnN0cnVjdFVSTChiYXNlVVJMLCB1cmwsIHBhcmFtcywgcXVlcnkpO1xyXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShkYXRhLCBNRVRIT0QsIGhlYWRlcnMpO1xyXG4gIGNvbmZpZy5oZWFkZXJzID0gbmV3IFN1cGVyKGhlYWRlcnMpLm9iamVjdCgoaGVhZGVycywgdmFsdWVzLCBoZWFkZXIpID0+IHtcclxuICAgIGhlYWRlciA9IG5ldyBTdHIoaGVhZGVyKVxyXG4gICAgICAudG9DYXBpdGFsQ2FzZSgpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJylcclxuICAgICAgLiQ7XHJcblxyXG4gICAgaGVhZGVyc1toZWFkZXJdID0gdmFsdWVzLmpvaW4oJywgJyk7XHJcbiAgfSkuJDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7RmV0Y2h9IGZldGNoXHJcbiAqIEB0eXBlIHtGZXRjaH1cclxuICogQHB1YmxpY1xyXG4gKiBAZGVzY3JpcHRpb24gRW1wdHkgaW5zdGFuY2Ugb2YgRmV0Y2guXHJcbiAqL1xyXG5jb25zdCBmZXRjaCA9IG5ldyBGZXRjaCgpO1xyXG5cclxuZXhwb3J0IHsgRmV0Y2gsIGZldGNoIH07XHJcbiIsIi8qKlxuICogQG1vZHVsZSBSb3V0ZXJcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIFJvdXRlci5cbiAqL1xuXG5pbXBvcnQgeyBBcnIgfSBmcm9tICcuL0Fycic7XG5pbXBvcnQgeyBFbGVtLCB3aW4gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHsgc2VsZiB9IGZyb20gJy4vRnVuYyc7XG5pbXBvcnQgeyBTdHIgfSBmcm9tICcuL1N0cic7XG5pbXBvcnQgeyBTdXBlciB9IGZyb20gJy4vU3VwZXInO1xuaW1wb3J0IHsgc3dpdGNoZXIgfSBmcm9tICcuL1N3aXRjaGVyJztcbmltcG9ydCB7IGFzc2lnbiwgaXNOaWwsIGlzUmVnRXhwLCBpc1N0cmluZyB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgY29uc3RydWN0VVJMIGZyb20gJy4vaGVscGVycy9jb25zdHJ1Y3RVUkwnO1xuaW1wb3J0IHJlc29sdmVVUkwgZnJvbSAnLi9oZWxwZXJzL3Jlc29sdmVVUkwnO1xuXG5jb25zdCBSb3V0ZXMgPSBuZXcgQXJyKFtdKTtcbmNvbnN0IGN1cnJlbnRSb3V0ZXMgPSBuZXcgQXJyKFtdKTtcbmNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFN1cGVyKHt9KTtcbmNvbnN0IHtcbiAgaGlzdG9yeSxcbiAgbG9jYXRpb24sXG4gIGxvY2F0aW9uOiB7XG4gICAgb3JpZ2luLFxuICAgIGhyZWZcbiAgfVxufSA9IGdsb2JhbDtcbmxldCBpbml0aWFsaXplZDtcbmxldCBwdXNoZWQ7XG5sZXQgd2FzUm9vdDtcbmxldCB3YXNEZWZhdWx0O1xubGV0IHJvb3RSb3V0ZTtcbmxldCByZWRpcmVjdFJvdXRlO1xubGV0IFJlZGlyZWN0Um91dGU7XG5sZXQgZGVmYXVsdFJvdXRlO1xubGV0IERlZmF1bHRSb3V0ZTtcbmxldCBjdXJyZW50Um91dGU7XG5sZXQgY3VycmVudFJvdXRlUGFyYW1zO1xuXG5jb25zdCBwYXRoU3dpdGNoZXIgPSBzd2l0Y2hlcignY2FsbCcsICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcsIGEgcmVndWxhciBleHByZXNzaW9uIG9yIHVuZGVmaW5lZCEgKGF0IHJlZ2lzdGVyU3RhdGUpJyk7XG59KVxuICAuY2FzZShpc1JlZ0V4cCwgKHBhdGgpID0+ICh7XG4gICAgcGF0aDogcGF0aC5zb3VyY2UucmVwbGFjZSgvXFxcXFxcLy9nLCAnLycpLFxuICAgIHVybDogcGF0aCxcbiAgICBwYXJhbXM6IHt9XG4gIH0pKVxuICAuY2FzZShpc05pbCwgKCkgPT4gKHtcbiAgICBwYXRoOiAnLycsXG4gICAgdXJsOiAnLycsXG4gICAgcGFyYW1zOiB7fVxuICB9KSlcbiAgLmNhc2UoaXNTdHJpbmcsIChwYXRoKSA9PiB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIHJvdXRlIHBhdGggaXMgYSBzdHJpbmcgaXQgbXVzdCBzdGFydCB3aXRoIFwiL1wiISAoYXQgcmVnaXN0ZXJTdGF0ZSknKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBTdXBlcih7fSk7XG4gICAgbGV0IG5ld1VSTCA9ICcnO1xuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgU3RyKHBhdGgpXG4gICAgICAuc2xpY2UoMCwgaW5kZXggPT09IC0xID8gcGF0aC5sZW5ndGggOiBpbmRleClcbiAgICAgIC5yZXBsYWNlKC9eXFwvfFxcLyQvZylcbiAgICAgIC5zcGxpdCgvXFwvLylcbiAgICAgIC5tYXAoKHBhcnQsIGksIGFycmF5KSA9PiB7XG4gICAgICAgIGlmICghcGFydCAmJiBhcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiByb3V0ZSBwYXRoIGlzIGEgc3RyaW5nIGl0IG11c3Qgbm90IGNvbnRhaW4gXCIvL1wiIG9yIGVuZCB3aXRoIFwiL1wiISAoYXQgbWFrZVJvdXRlKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJ0LmluZGV4T2YoJzonKTtcblxuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiByb3V0ZSBwYXRoIGlzIGEgc3RyaW5nIHJlc291cmNlIHBhcnQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gVVJMIHBhcmFtZXRlciEgKGF0IG1ha2VSb3V0ZSknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiBwYXJ0LFxuICAgICAgICAgICAgdmFsdWU6IHBhcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcmVnZXhwID0gL1teL10qL1xuICAgICAgICB9ID0gcmVzb2x2ZVBhcmFtZXRlcihcbiAgICAgICAgICBwYXJ0LnNsaWNlKDEpLFxuICAgICAgICAgICdVUkwgcGFyYW1ldGVyIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBvciBjb250YWluIGNoYXJhY3RlcnMgYmVzaWRlcyBcImEtekEtWl8kXCIhIChhdCBtYWtlUm91dGUpJyxcbiAgICAgICAgICAnVVJMIHBhcmFtZXRlciByZWdleHAgdmFsaWRhdG9yIG11c3QgYmUgd2l0aGluIHBhcmVudGhlc2VzIChlLmcuIDp1c2VySWQoXFxcXGQrKSBhbmQgbm90IGNvbnRhaW4gb25lcykhIChhdCBtYWtlUm91dGUpJ1xuICAgICAgICApO1xuXG4gICAgICAgIHBhcmFtcy4kW25hbWVdID0gcGFyYW1zLmNvdW50O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3BhcmFtJyxcbiAgICAgICAgICB1cmw6IGA6JHsgbmFtZSB9YCxcbiAgICAgICAgICB2YWx1ZTogcmVnZXhwXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICAgLndvcmQoKHsgdHlwZSwgdXJsLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGxldCBuZXdQYXRoO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAncGFyYW0nKSB7XG4gICAgICAgICAgbmV3UGF0aCA9IGAoJHsgdmFsdWUuc291cmNlLnJlcGxhY2UoL1xcXFxcXC8vZywgJy8nKSB9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UGF0aCA9IG5ldyBTdHIodmFsdWUpLmVzY2FwZVJlZ0V4cCgpLiQ7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdVUkwgKz0gYC8keyB1cmwgfWA7XG5cbiAgICAgICAgcmV0dXJuIGAvJHsgbmV3UGF0aCB9YDtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICB1cmw6IG5ld1VSTCxcbiAgICAgIHBhcmFtczogcGFyYW1zLiRcbiAgICB9O1xuICB9KTtcblxuY2xhc3MgUm91dGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcGF0aCA9ICcvJyxcbiAgICAgIGFic3RyYWN0ID0gZmFsc2UsXG4gICAgICBwYXJlbnQsXG4gICAgICBkZWNvZGVRdWVyeSA9IHRydWUsXG4gICAgICBlbmNvZGVRdWVyeSA9IHRydWUsXG4gICAgICBkZWNvZGVQYXJhbXMgPSB0cnVlLFxuICAgICAgZW5jb2RlUGFyYW1zID0gdHJ1ZVxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHtcbiAgICAgIHVybDogcmVsYXRpdmVVUkwsXG4gICAgICBwYXRoOiByZWxhdGl2ZVBhdGgsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gcGF0aFN3aXRjaGVyKHBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5ID0ge307XG5cbiAgICBuZXcgU3VwZXIodGhpcykuYXNzaWduKHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnROYW1lOiBwYXJlbnQsXG4gICAgICBhYnN0cmFjdDogISFhYnN0cmFjdCxcbiAgICAgIGNoaWxkcmVuOiBuZXcgQXJyKFtdKSxcbiAgICAgIGRlY29kZVBhcmFtczogISFkZWNvZGVQYXJhbXMsXG4gICAgICBkZWNvZGVRdWVyeTogISFkZWNvZGVRdWVyeSxcbiAgICAgIGVuY29kZVBhcmFtczogISFlbmNvZGVQYXJhbXMsXG4gICAgICBlbmNvZGVRdWVyeTogISFlbmNvZGVRdWVyeSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHF1ZXJ5LFxuICAgICAgcmVsYXRpdmVQYXRoLFxuICAgICAgcmVsYXRpdmVVUkxcbiAgICB9KTtcblxuICAgIGNvbnN0IGluZGV4ID0gaXNTdHJpbmcocGF0aCkgPyBwYXRoLmluZGV4T2YoJz8nKSA6IC0xO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbmV3IFN0cihwYXRoKVxuICAgICAgICAucmVwbGFjZSgvJiQvKVxuICAgICAgICAuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAuc3BsaXQoJyYnKVxuICAgICAgICAuZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcmVnZXhwID0gL1tcXHNcXFNdKi9cbiAgICAgICAgICB9ID0gcmVzb2x2ZVBhcmFtZXRlcihcbiAgICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgICAgJ1F1ZXJ5IHBhcmFtZXRlciBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcgb3IgY29udGFpbiBjaGFyYWN0ZXJzIGJlc2lkZXMgXCJhLXpBLVpfJFwiISAoYXQgbWFrZVJvdXRlKScsXG4gICAgICAgICAgICAnUXVlcnkgcGFyYW1ldGVyIHJlZ2V4cCB2YWxpZGF0b3IgbXVzdCBiZSB3aXRoaW4gcGFyZW50aGVzZXMgKGUuZy4gOnVzZXJJZChcXFxcZCspKSBhbmQgbm90IGNvbnRhaW4gdGhlbSEgKGF0IG1ha2VSb3V0ZSknXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHF1ZXJ5W25hbWVdID0gbmV3IFJlZ0V4cChgXiR7IHJlZ2V4cC5zb3VyY2UucmVwbGFjZSgvXFxcXFxcLy9nLCAnLycpIH0kYCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBkZWZhdWx0Um91dGUgJiYgKFxuICAgICAgICBuZXcgU3VwZXIocGFyYW1zKS5jb3VudFxuICAgICAgICB8fCBuZXcgU3VwZXIocXVlcnkpLmNvdW50XG4gICAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgcm91dGUgbXVzdCBub3QgaGF2ZSBVUkwgb3IgcXVlcnkgcGFyYW1zISAoYXQgbWFrZVJvdXRlKScpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBiYXNlUm91dGUgPSBuZXcgUm91dGUoKTtcblxuZnVuY3Rpb24gaW5pdFJvdXRlcigpIHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBSZWRpcmVjdFJvdXRlID0gKFJvdXRlcy5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gcmVkaXJlY3RSb3V0ZSkgfHwge30pLnZhbHVlO1xuICBEZWZhdWx0Um91dGUgPSAoUm91dGVzLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkZWZhdWx0Um91dGUpIHx8IHt9KS52YWx1ZTtcblxuICBpZiAocmVkaXJlY3RSb3V0ZSAmJiAhUmVkaXJlY3RSb3V0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gc3BlY2lmaWVkIGZhbGxiYWNrIHJvdXRlIChcIiR7IHJlZGlyZWN0Um91dGUgfVwiKSEgKGF0IGluaXRSb3V0ZXIpYCk7XG4gIH1cblxuICBSb3V0ZXNcbiAgICAuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IHJvdXRlO1xuICAgICAgY29uc3QgUGFyZW50TmFtZSA9IHBhcmVudE5hbWUgfHwgcm9vdFJvdXRlO1xuICAgICAgY29uc3QgeyB2YWx1ZTogcGFyZW50IH0gPSBSb3V0ZXMuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IFBhcmVudE5hbWUpIHx8IHt9O1xuXG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggcGFyZW50IHJvdXRlIChcIiR7IFBhcmVudE5hbWUgfVwiKSBmb3VuZCBmb3IgdGhlIHJvdXRlIChcIiR7IG5hbWUgfVwiKSEgKGF0IGluaXRSb3V0ZXIpYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50LmFic3RyYWN0ICYmIG5hbWUgIT09IHJvb3RSb3V0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmVudCByb3V0ZSBtdXN0IGJlIGFic3RyYWN0IChmb3IgXCIkeyBuYW1lIH1cIikhIChhdCBpbml0Um91dGVyKWApO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPT0gcm9vdFJvdXRlKSB7XG4gICAgICAgIHJvdXRlLnBhcmVudE5hbWUgPSBQYXJlbnROYW1lO1xuICAgICAgfVxuXG4gICAgICByb3V0ZS5wYXJlbnQgPSBuYW1lID09PSByb290Um91dGVcbiAgICAgICAgPyBiYXNlUm91dGVcbiAgICAgICAgOiBwYXJlbnQ7XG4gICAgfSlcbiAgICAuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFyYW1zOiBwYXJlbnRQYXJhbXMsXG4gICAgICAgICAgcXVlcnk6IHBhcmVudFF1ZXJ5LFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgcmVsYXRpdmVVUkwsXG4gICAgICAgIHJlbGF0aXZlUGF0aFxuICAgICAgfSA9IHJvdXRlO1xuICAgICAgbGV0IHByb3RvID0gcm91dGU7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgbGV0IG5ld1BhdGggPSByZWxhdGl2ZVBhdGg7XG4gICAgICBsZXQgbmV3VVJMID0gJyc7XG5cbiAgICAgIGlmIChpc1JlZ0V4cChwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCByZWdleHAgcm91dGUgY2Fubm90IGJlIGV4dGVuZGVkISAoYXQgaW5pdFJvdXRlciknKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHByb3RvID0gcHJvdG8ucGFyZW50KSB7XG4gICAgICAgIGNvdW50ICs9IG5ldyBTdXBlcihwcm90by5wYXJhbXMpLmNvdW50O1xuICAgICAgICBuZXdQYXRoID0gcHJvdG8ucmVsYXRpdmVQYXRoICsgbmV3UGF0aDtcbiAgICAgICAgbmV3VVJMID0gcHJvdG8ucmVsYXRpdmVVUkwgKyBuZXdVUkw7XG5cbiAgICAgICAgcHJvdG8uY2hpbGRyZW4ucHVzaChyb3V0ZSk7XG4gICAgICB9XG5cbiAgICAgIG5ld1BhdGggPSBuZXcgUmVnRXhwKGBeJHsgbmV3UGF0aC5yZXBsYWNlKC9cXC8rL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycgfSRgKTtcbiAgICAgIG5ld1VSTCA9IGlzUmVnRXhwKHJlbGF0aXZlVVJMKVxuICAgICAgICA/IG5ld1BhdGhcbiAgICAgICAgOiAobmV3VVJMICsgcmVsYXRpdmVVUkwpLnJlcGxhY2UoL1xcLysvZywgJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJztcblxuICAgICAgbmV3IFN1cGVyKHF1ZXJ5KS5wcm90byhwYXJlbnRRdWVyeSk7XG4gICAgICBuZXcgU3VwZXIocGFyYW1zKVxuICAgICAgICAucHJvdG8ocGFyZW50UGFyYW1zKVxuICAgICAgICAuZm9yRWFjaCgodmFsdWUsIGtleSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gKz0gY291bnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAobmFtZSA9PT0gZGVmYXVsdFJvdXRlICYmIChcbiAgICAgICAgICBuZXcgU3VwZXIocGFyYW1zKS5jb3VudFxuICAgICAgICAgIHx8IG5ldyBTdXBlcihxdWVyeSkuY291bnRcbiAgICAgICAgKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgcm91dGUgbXVzdCBub3QgaGF2ZSBVUkwgb3IgcXVlcnkgcGFyYW1zISAoYXQgaW5pdFJvdXRlciknKTtcbiAgICAgIH1cblxuICAgICAgcm91dGUudXJsID0gbmV3VVJMO1xuICAgICAgcm91dGUudmFsaWRhdGVQYXRoID0gbmV3UGF0aDtcbiAgICB9KTtcblxuICBjaGFuZ2VSb3V0ZSgpO1xuXG4gIHdpbi5vbih7XG4gICAgcG9wc3RhdGUoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaHJlZiAhPT0gaHJlZikge1xuICAgICAgICBwdXNoZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHVzaGVkKSB7XG4gICAgICAgIGNoYW5nZVJvdXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGljayhlKSB7XG4gICAgICBjb25zdCBjbG9zZXN0TGluayA9IG5ldyBFbGVtKGUudGFyZ2V0KS5jbG9zZXN0KCdhJyk7XG5cbiAgICAgIGlmIChjbG9zZXN0TGluay5sZW5ndGggJiYgY2xvc2VzdExpbmsuYXR0cigndGFyZ2V0JykgIT09ICdfYmxhbmsnKSB7XG4gICAgICAgIGNvbnN0IHB1c2ggPSAhY2xvc2VzdExpbmsuaGFzQXR0cigncmVwbGFjZScpO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBmb3J3YXJkKGNsb3Nlc3RMaW5rLmF0dHIoJ2hyZWYnKSB8fCAnJywgcHVzaCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZVJvdXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIChCbG9jaykgPT4ge1xuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMsIEJsb2NrLnJvdXRlck9wdGlvbnMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHBhdGgsXG4gICAgICBhYnN0cmFjdCxcbiAgICAgIHJvb3QsXG4gICAgICBmYWxsYmFja1RvLFxuICAgICAgZGVmYXVsdDogaXNEZWZhdWx0XG4gICAgfSA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignUm91dGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkIChhdCBtYWtlUm91dGUpJyk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGlmICh3YXNSb290ICYmIHJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgY2FuJ3QgYmUgdHdvIHJvb3Qgcm91dGVzIChcIiR7IHJvb3RSb3V0ZSB9XCIgYW5kIFwiJHsgbmFtZSB9XCIpISAoYXQgbWFrZVJvdXRlKWApO1xuICAgIH1cblxuICAgIGlmICh3YXNEZWZhdWx0ICYmIGlzRGVmYXVsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBjYW4ndCBiZSB0d28gZGVmYXVsdCByb3V0ZXMgKFwiJHsgZGVmYXVsdFJvdXRlIH1cIiBhbmQgXCIkeyBuYW1lIH1cIikhIChhdCBtYWtlUm91dGUpYCk7XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG11c3QgaGF2ZSBhIG5vbi1lbXB0eSBzdHJpbmcgXCJuYW1lXCIgcHJvcGVydHkhIChhdCBtYWtlUm91dGUpJyk7XG4gICAgfVxuXG4gICAgaWYgKFJvdXRlcy5zb21lKCh7IG5hbWU6IE5hbWUgfSkgPT4gTmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGUgbXVzdCBoYXZlIHVuaXF1ZSBcIm5hbWVcIiBwcm9wZXJ0eSEgKGF0IG1ha2VSb3V0ZSknKTtcbiAgICB9XG5cbiAgICBpZiAocm9vdCkge1xuICAgICAgd2FzUm9vdCA9IHRydWU7XG4gICAgICByb290Um91dGUgPSBuYW1lO1xuICAgICAgb3B0aW9ucy5wYXJlbnQgPSBudWxsO1xuXG4gICAgICBpZiAoZmFsbGJhY2tUbykge1xuICAgICAgICByZWRpcmVjdFJvdXRlID0gZmFsbGJhY2tUbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICB3YXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRSb3V0ZSA9IG5hbWU7XG5cbiAgICAgIGlmIChhYnN0cmFjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgcm91dGUgY2FuXFwndCBiZSBhYnN0cmFjdCEgKGF0IG1ha2VSb3V0ZSknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUmVnRXhwKHBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCByb3V0ZSBjYW5cXCd0IGhhdmUgYSByZWdleHAgcGF0aCEgKGF0IG1ha2VSb3V0ZSknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZSA9IG5ldyBSb3V0ZShvcHRpb25zKTtcblxuICAgIFJvdXRlcy5wdXNoKHJvdXRlKTtcblxuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBsZXQgcm91dGVMb2FkZWQ7XG5cbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAvKiBlc2xpbnQgcHJlZmVyLXRlbXBsYXRlOiAwICovXG4gICAgICBzdGF0aWMgdGVtcGxhdGUgPSAnPGRpdidcbiAgICAgICAgKyBgIGNsYXNzPVwiZHdheW5lLXJvdXRlIHJvdXRlLSR7IG5hbWUgfVwiYFxuICAgICAgICArICcgZC1jbGFzcz1cInt7IFxcJ2FjdGl2ZS1yb3V0ZVxcJzogX19pc0N1cnJlbnRSb3V0ZV9fIH19XCInXG4gICAgICAgICsgJyBkLXNob3c9XCJ7X19pc0N1cnJlbnRSb3V0ZV9ffVwiJ1xuICAgICAgICArICc+J1xuICAgICAgICArIEJsb2NrLnRlbXBsYXRlXG4gICAgICAgICsgJzwvZGl2Pic7XG5cbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG5cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICBpbml0Um91dGVyKCk7XG5cbiAgICAgICAgICBjb25zdCByb3V0ZXIgPSB7XG4gICAgICAgICAgICBidWlsZFVSTChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogcm91dGUgfSA9IFJvdXRlcy5maW5kKCh7IG5hbWU6IG4gfSkgPT4gbiA9PT0gbmFtZSkgfHwge307XG5cbiAgICAgICAgICAgICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgYXJlIG5vIHJvdXRlcyB3aXRoIG5hbWUgXCIkeyBuYW1lIH1cIiEgKGF0IHJvdXRlci5idWlsZFVSTClgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZW5jb2RlUGFyYW1zLFxuICAgICAgICAgICAgICAgIGVuY29kZVF1ZXJ5XG4gICAgICAgICAgICAgIH0gPSByb3V0ZTtcblxuICAgICAgICAgICAgICBpZiAoaXNSZWdFeHAodXJsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIGNhbiBiZSBidWlsdCBvbmx5IGZyb20gdGhlIHN0cmluZyBVUkxzISAoYXQgcm91dGVyLmJ1aWxkVVJMKScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHt9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge30sXG4gICAgICAgICAgICAgICAgaGFzaCA9ICcnXG4gICAgICAgICAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RVUkwob3JpZ2luLCB1cmwsIHBhcmFtcywgcXVlcnksIGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGVuY29kZVBhcmFtcyxcbiAgICAgICAgICAgICAgICBxdWVyeTogZW5jb2RlUXVlcnlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ28obmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICBmb3J3YXJkKHJvdXRlci5idWlsZFVSTChuYW1lLCBvcHRpb25zKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ29Ub1VSTCh1cmwpIHtcbiAgICAgICAgICAgICAgZm9yd2FyZCh1cmwsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1c2hVUkwodXJsKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUhpc3RvcnkodXJsLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWRpcmVjdChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIGZvcndhcmQocm91dGVyLmJ1aWxkVVJMKG5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWRpcmVjdFRvVVJMKHVybCkge1xuICAgICAgICAgICAgICBmb3J3YXJkKHVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVwbGFjZVVSTCh1cmwpIHtcbiAgICAgICAgICAgICAgY2hhbmdlSGlzdG9yeSh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbC5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fcm91dGVySW5zdGFuY2VfXyA9IHJvdXRlO1xuICAgICAgICB0aGlzLl9faXNDdXJyZW50Um91dGVfXyA9IChcbiAgICAgICAgICByb3V0ZSA9PT0gY3VycmVudFJvdXRlXG4gICAgICAgICAgfHwgcm91dGUuY2hpbGRyZW4uaW5kZXhPZihjdXJyZW50Um91dGUpICE9PSAtMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmFyZ3Mucm91dGUgPSBjdXJyZW50Um91dGVQYXJhbXM7XG5cbiAgICAgICAgcm91dGVMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUobmFtZSwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFJvdXRlID0gKFxuICAgICAgICAgICAgcm91dGUgPT09IGN1cnJlbnRSb3V0ZVxuICAgICAgICAgICAgfHwgcm91dGUuY2hpbGRyZW4uaW5kZXhPZihjdXJyZW50Um91dGUpICE9PSAtMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoaXNDdXJyZW50Um91dGUpIHtcbiAgICAgICAgICAgIGNhbGxCZWZvcmVMb2FkKHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsQmVmb3JlTGVhdmUodGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvdXRlID09PSBjdXJyZW50Um91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXJncy5yb3V0ZSA9IGN1cnJlbnRSb3V0ZVBhcmFtcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9faXNDdXJyZW50Um91dGVfXyA9IGlzQ3VycmVudFJvdXRlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fX2lzQ3VycmVudFJvdXRlX18pIHtcbiAgICAgICAgICBjYWxsQmVmb3JlTG9hZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgICAgY2FsbEJlZm9yZUxlYXZlKHRoaXMpO1xuICAgICAgICBzdXBlci5iZWZvcmVSZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsbEJlZm9yZUxvYWQocm91dGUpIHtcbiAgICAgIGlmIChyb3V0ZUxvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgICAkJDoge1xuICAgICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyKFtyb3V0ZV0pXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJsb2NrLiQkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gYmVmb3JlTG9hZChibG9jaykge1xuICAgICAgICBjb25zdCByb3V0ZSA9IGJsb2NrLl9fcm91dGVySW5zdGFuY2VfXztcblxuICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRSb3V0ZXMuaW5kZXhPZihibG9jayk7XG4gICAgICAgICAgY29uc3QgaXNDdXJyZW50Um91dGUgPSAoXG4gICAgICAgICAgICByb3V0ZSA9PT0gY3VycmVudFJvdXRlXG4gICAgICAgICAgICB8fCByb3V0ZS5jaGlsZHJlbi5pbmRleE9mKGN1cnJlbnRSb3V0ZSkgIT09IC0xXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEgfHwgIWlzQ3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFJvdXRlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIG1peGluc1xuICAgICAgICB9ID0gYmxvY2suJCQ7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChiZWZvcmVMb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICBtaXhpbnMuZm9yRWFjaChiZWZvcmVMb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jay5iZWZvcmVMb2FkUm91dGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmxvY2suYmVmb3JlTG9hZFJvdXRlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYmVmb3JlTGVhdmU6YCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByb3V0ZUxvYWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbEJlZm9yZUxlYXZlKHJvdXRlKSB7XG4gICAgICBpZiAoIXJvdXRlTG9hZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAgICQkOiB7XG4gICAgICAgICAgY2hpbGRyZW46IG5ldyBBcnIoW3JvdXRlXSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYmxvY2suJCQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiBiZWZvcmVMZWF2ZShibG9jaykge1xuICAgICAgICBjb25zdCByb3V0ZSA9IGJsb2NrLl9fcm91dGVySW5zdGFuY2VfXztcblxuICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRSb3V0ZXMuaW5kZXhPZihibG9jayk7XG4gICAgICAgICAgY29uc3QgaXNDdXJyZW50Um91dGUgPSAoXG4gICAgICAgICAgICByb3V0ZSA9PT0gY3VycmVudFJvdXRlXG4gICAgICAgICAgICB8fCByb3V0ZS5jaGlsZHJlbi5pbmRleE9mKGN1cnJlbnRSb3V0ZSkgIT09IC0xXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgaXNDdXJyZW50Um91dGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50Um91dGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICBtaXhpbnNcbiAgICAgICAgfSA9IGJsb2NrLiQkO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goYmVmb3JlTGVhdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1peGlucykge1xuICAgICAgICAgIG1peGlucy5mb3JFYWNoKGJlZm9yZUxlYXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jay5iZWZvcmVMZWF2ZVJvdXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJsb2NrLmJlZm9yZUxlYXZlUm91dGUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNiZWZvcmVMZWF2ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJvdXRlTG9hZGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUobmFtZSwgY2FsbGJhY2spIHtcbiAgc3Vic2NyaWJlcnMuJFtuYW1lXSA9IGNhbGxiYWNrO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgc3Vic2NyaWJlcnMuZGVsZXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkKHVybCwgcHVzaCkge1xuICBjaGFuZ2VIaXN0b3J5KHVybCwgcHVzaCk7XG4gIGNoYW5nZVJvdXRlKCk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVJvdXRlKCkge1xuICBjb25zdCByb3V0ZSA9IGZpbmRSb3V0ZUJ5VVJMKCk7XG5cbiAgaWYgKHJvdXRlKSB7XG4gICAgKHtcbiAgICAgIHJvdXRlOiBjdXJyZW50Um91dGUsXG4gICAgICAuLi5jdXJyZW50Um91dGVQYXJhbXNcbiAgICB9ID0gcm91dGUpO1xuICAgIGFzc2lnbihjdXJyZW50Um91dGVQYXJhbXMsIHtcbiAgICAgIG5hbWU6IGN1cnJlbnRSb3V0ZS5uYW1lLFxuICAgICAgaG9zdDogbG9jYXRpb24uaG9zdCxcbiAgICAgIGhvc3RuYW1lOiBsb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgIGhyZWY6IGxvY2F0aW9uLmhyZWYsXG4gICAgICBvcmlnaW46IGxvY2F0aW9uLm9yaWdpbixcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHBvcnQ6IGxvY2F0aW9uLnBvcnQsXG4gICAgICBwcm90b2NvbDogbG9jYXRpb24ucHJvdG9jb2wsXG4gICAgICBzZWFyY2g6IGxvY2F0aW9uLnNlYXJjaFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChyZWRpcmVjdFJvdXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgZW5jb2RlUGFyYW1zLFxuICAgICAgICBlbmNvZGVRdWVyeVxuICAgICAgfSA9IFJlZGlyZWN0Um91dGU7XG5cbiAgICAgIHJldHVybiBmb3J3YXJkKGNvbnN0cnVjdFVSTChvcmlnaW4sIHVybCwge30sIHt9LCAnJywge1xuICAgICAgICBwYXJhbXM6IGVuY29kZVBhcmFtcyxcbiAgICAgICAgcXVlcnk6IGVuY29kZVF1ZXJ5XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgY3VycmVudFJvdXRlID0gbnVsbDtcbiAgICBjdXJyZW50Um91dGVQYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xufVxuXG5mdW5jdGlvbiBmaW5kUm91dGVCeVVSTCgpIHtcbiAgY29uc3QgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCAnLyc7XG4gIGNvbnN0IHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgbGV0IHVybFBhcmFtcztcblxuICBSb3V0ZXMuc29tZSgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUuYWJzdHJhY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB1cmw6IHJvdXRlVVJMLFxuICAgICAgdmFsaWRhdGVQYXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgcXVlcnk6IHJlcXVpcmVkUXVlcnksXG4gICAgICBkZWNvZGVQYXJhbXMsXG4gICAgICBkZWNvZGVRdWVyeVxuICAgIH0gPSByb3V0ZTtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVVUkwoZGVjb2RlUXVlcnkpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFN1cGVyKHJlc29sdmVkLnF1ZXJ5KTtcbiAgICBjb25zdCBldmVudHVhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1hdGNoID0gKFxuICAgICAgKHBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKSArXG4gICAgICAoaXNSZWdFeHAocm91dGVVUkwpID8gc2VhcmNoIDogJycpXG4gICAgKS5tYXRjaCh2YWxpZGF0ZVBhdGgpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICBmb3IgKGNvbnN0IHBhcmFtIGluIHJlcXVpcmVkUXVlcnkpIHtcbiAgICAgIGlmICghcXVlcnkuaGFzT3duKHBhcmFtKSB8fCAhcmVxdWlyZWRRdWVyeVtwYXJhbV0udGVzdChxdWVyeS4kW3BhcmFtXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hdGNoLnNoaWZ0KCk7XG5cbiAgICBmb3IgKGNvbnN0IHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgZXZlbnR1YWxQYXJhbXNbcGFyYW1dID0gZGVjb2RlKG1hdGNoW3BhcmFtc1twYXJhbV1dLCBkZWNvZGVQYXJhbXMpO1xuICAgIH1cblxuICAgIHVybFBhcmFtcyA9IHtcbiAgICAgIHJvdXRlLFxuICAgICAgcGFyYW1zOiBldmVudHVhbFBhcmFtcyxcbiAgICAgIHF1ZXJ5OiBxdWVyeS4kLFxuICAgICAgaGFzaDogcmVzb2x2ZWQuaGFzaFxuICAgIH07XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHVybFBhcmFtcykge1xuICAgIHJldHVybiB1cmxQYXJhbXM7XG4gIH1cblxuICBpZiAoIWRlZmF1bHRSb3V0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm91dGU6IERlZmF1bHRSb3V0ZSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIC4uLnJlc29sdmVVUkwoRGVmYXVsdFJvdXRlLmRlY29kZVF1ZXJ5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBkZWNvZGVQYXJhbXMpIHtcbiAgcmV0dXJuIGRlY29kZVBhcmFtc1xuICAgID8gZGVjb2RlVVJJQ29tcG9uZW50KHN0cmluZylcbiAgICA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gY2hhbmdlSGlzdG9yeSh1cmwsIHB1c2gpIHtcbiAgdHJ5IHtcbiAgICBoaXN0b3J5W3B1c2ggPyAncHVzaFN0YXRlJyA6ICdyZXBsYWNlU3RhdGUnXShudWxsLCBudWxsLCB1cmwpO1xuICAgIHB1c2hlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhcmFtZXRlcihwYXJhbSwgbmFtZUVycm9yTmFtZSwgdmFsdWVFcnJvck5hbWUpIHtcbiAgY29uc3QgbmFtZU1hdGNoID0gcGFyYW0ubWF0Y2goL15bYS16XyRdKy9pKTtcblxuICBpZiAoIW5hbWVNYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lRXJyb3JOYW1lKTtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBuYW1lTWF0Y2hbMF07XG4gIGNvbnN0IHZhbHVlID0gcGFyYW0uc2xpY2UobmFtZS5sZW5ndGgpO1xuICBsZXQgcmVnZXhwO1xuXG4gIGlmICh2YWx1ZSAmJiAodmFsdWUuaW5kZXhPZignKCcpIHx8IHZhbHVlLmluZGV4T2YoJyknKSAhPT0gdmFsdWUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWVFcnJvck5hbWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgcmVnZXhwID0gbmV3IFJlZ0V4cCh2YWx1ZS5zbGljZSgxLCAtMSkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHJlZ2V4cFxuICB9O1xufVxuXG5leHBvcnQgeyBtYWtlUm91dGUgfTtcbiIsIi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xyXG4vKiBlc2xpbnQgbm8tbmVnYXRlZC1jb25kaXRpb246IDAgKi9cclxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2FwcGxpZWRSZWdFeHBzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRpZmZlcmVudCB0eXBlcyBvZiBzeW50YXggZm9yIHtAbGluayBFbGVtI2FwcGx5fS5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIG1hdGNoQXBwbGllZEV4cHJDYWxsYmFja1xyXG4gKiBAcGFyYW0ge0VsZW19IGVsZW0gLSBELWVsZW0gb2YgYW4gZWxlbWVudCB0byBhcHBseSBleHByZXNzaW9uIHRvLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gTWF0Y2hlZCBhcHBsaWVkIG5hbWUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmcgLSBBcmd1bWVudCB3aXRoaW4gdGhlIHBhcmVudGhlc2VzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIG1hdGNoQXBwbGllZEV4cHJDYWxsYmFja3xPYmplY3QuPFN0cmluZywgbWF0Y2hBcHBsaWVkRXhwckNhbGxiYWNrPj59XHJcbiAqIEBkZXNjcmlwdGlvbiBPYmplY3Qgb2YgZGlmZmVyZW50IHR5cGVzIG9mIHN5bnRheC5cclxuICovXHJcblxyXG5leHBvcnQgY29uc3QgYXBwbGllZFJlZ0V4cHMgPSB7XHJcbiAgJyMnKGVsZW0sIGlkKSB7XHJcbiAgICBlbGVtLmlkKGlkKTtcclxuICB9LFxyXG4gICcuJyhlbGVtLCBjbHMpIHtcclxuICAgIGVsZW0uYWRkQ2xhc3MoY2xzKTtcclxuICB9LFxyXG4gICQoZWxlbSwgYXR0ciwgdmFsdWUpIHtcclxuICAgIGVsZW0uYXR0cihhdHRyLCB2YWx1ZSk7XHJcbiAgfSxcclxuICAnQCcoZWxlbSwgcHJvcCwgdmFsdWUpIHtcclxuICAgIGVsZW0uY3NzKHByb3AsIHZhbHVlKTtcclxuICB9LFxyXG4gICcmJyhlbGVtLCBuYW1lLCBodG1sKSB7XHJcbiAgICBlbGVtLmh0bWwoaHRtbCk7XHJcbiAgfSxcclxuICAnKicoZWxlbSwgbmFtZSwgdGV4dCkge1xyXG4gICAgZWxlbS50ZXh0KHRleHQpO1xyXG4gIH0sXHJcbiAgJy0nOiB7XHJcbiAgICAnLicoZWxlbSwgY2xzKSB7XHJcbiAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcclxuICAgIH0sXHJcbiAgICAkKGVsZW0sIGF0dHIpIHtcclxuICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xyXG4gICAgfSxcclxuICAgICdAJyhlbGVtLCBwcm9wKSB7XHJcbiAgICAgIGVsZW0ucmVtb3ZlQ1NTKHByb3ApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2VsZW1lbnRzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRpZmZlcmVudCBjYW52YXMgbWV0aG9kcyBmb3Ige0BsaW5rIEVsZW19IGZvciBjcmVhdGluZyBodG1sLWVsZW1lbnRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY29uc3RcclxuICogQHR5cGUge1N0cmluZ1tdfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbnZhc0dldE1ldGhvZHMgPSBbXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY3JlYXRlSW1hZ2VEYXRhXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtJbWFnZURhdGF8dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY3JlYXRlSW1hZ2VEYXRhXHJcbiAgICovXHJcbiAgJ2NyZWF0ZUltYWdlRGF0YScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NyZWF0ZUxpbmVhckdyYWRpZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtDYW52YXNHcmFkaWVudHx2b2lkfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jcmVhdGVMaW5lYXJHcmFkaWVudFxyXG4gICAqL1xyXG4gICdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NyZWF0ZVBhdHRlcm5cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0NhbnZhc1BhdHRlcm58dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY3JlYXRlUGF0dGVyblxyXG4gICAqL1xyXG4gICdjcmVhdGVQYXR0ZXJuJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY3JlYXRlUmFkaWFsR3JhZGllbnRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0NhbnZhc0dyYWRpZW50fHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NyZWF0ZVJhZGlhbEdyYWRpZW50XHJcbiAgICovXHJcbiAgJ2NyZWF0ZVJhZGlhbEdyYWRpZW50JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZ2V0SW1hZ2VEYXRhXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtJbWFnZURhdGF8dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2V0SW1hZ2VEYXRhXHJcbiAgICovXHJcbiAgJ2dldEltYWdlRGF0YScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dldExpbmVEYXNoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJbXXx2b2lkfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nZXRMaW5lRGFzaFxyXG4gICAqL1xyXG4gICdnZXRMaW5lRGFzaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2lzUG9pbnRJblBhdGhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW58dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvaXNQb2ludEluUGF0aFxyXG4gICAqL1xyXG4gICdpc1BvaW50SW5QYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaXNQb2ludEluU3Ryb2tlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufHZvaWR9XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2lzUG9pbnRJblN0cm9rZVxyXG4gICAqL1xyXG4gICdpc1BvaW50SW5TdHJva2UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZWFzdXJlVGV4dFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7VGV4dE1ldHJpY3N8dm9pZH1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvbWVhc3VyZVRleHRcclxuICAgKi9cclxuICAnbWVhc3VyZVRleHQnXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgY2FudmFzUmVzdE1ldGhvZHMgPSBbXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYXJjXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9hcmNcclxuICAgKi9cclxuICAnYXJjJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYXJjVG9cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2FyY1RvXHJcbiAgICovXHJcbiAgJ2FyY1RvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYmVnaW5QYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9iZWdpblBhdGhcclxuICAgKi9cclxuICAnYmVnaW5QYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYmV6aWVyQ3VydmVUb1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvYmV6aWVyQ3VydmVUb1xyXG4gICAqL1xyXG4gICdiZXppZXJDdXJ2ZVRvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2xlYXJSZWN0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jbGVhclJlY3RcclxuICAgKi9cclxuICAnY2xlYXJSZWN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2xpcFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvY2xpcFxyXG4gICAqL1xyXG4gICdjbGlwJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY2xvc2VQYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jbG9zZVBhdGhcclxuICAgKi9cclxuICAnY2xvc2VQYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZHJhd0ZvY3VzSWZOZWVkZWRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2RyYXdGb2N1c0lmTmVlZGVkXHJcbiAgICovXHJcbiAgJ2RyYXdGb2N1c0lmTmVlZGVkJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZHJhd0ltYWdlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9kcmF3SW1hZ2VcclxuICAgKi9cclxuICAnZHJhd0ltYWdlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZWxsaXBzZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZWxsaXBzZVxyXG4gICAqL1xyXG4gICdlbGxpcHNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmlsbFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZmlsbFxyXG4gICAqL1xyXG4gICdmaWxsJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmlsbFJlY3RcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxSZWN0XHJcbiAgICovXHJcbiAgJ2ZpbGxSZWN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmlsbFRleHRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxUZXh0XHJcbiAgICovXHJcbiAgJ2ZpbGxUZXh0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGluZVRvXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9saW5lVG9cclxuICAgKi9cclxuICAnbGluZVRvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbW92ZVRvXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9tb3ZlVG9cclxuICAgKi9cclxuICAnbW92ZVRvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcHV0SW1hZ2VEYXRhXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9wdXRJbWFnZURhdGFcclxuICAgKi9cclxuICAncHV0SW1hZ2VEYXRhJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcXVhZHJhdGljQ3VydmVUb1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcXVhZHJhdGljQ3VydmVUb1xyXG4gICAqL1xyXG4gICdxdWFkcmF0aWNDdXJ2ZVRvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcmVjdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcmVjdFxyXG4gICAqL1xyXG4gICdyZWN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcmVzZXRUcmFuc2Zvcm1cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3Jlc2V0VHJhbnNmb3JtXHJcbiAgICovXHJcbiAgJ3Jlc2V0VHJhbnNmb3JtJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcmVzdG9yZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcmVzdG9yZVxyXG4gICAqL1xyXG4gICdyZXN0b3JlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcm90YXRlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9yb3RhdGVcclxuICAgKi9cclxuICAncm90YXRlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2F2ZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2F2ZVxyXG4gICAqL1xyXG4gICdzYXZlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2NhbGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NjYWxlXHJcbiAgICovXHJcbiAgJ3NjYWxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2V0TGluZURhc2hcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoXHJcbiAgICovXHJcbiAgJ3NldExpbmVEYXNoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2V0VHJhbnNmb3JtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRUcmFuc2Zvcm1cclxuICAgKi9cclxuICAnc2V0VHJhbnNmb3JtJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3Ryb2tlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zdHJva2VcclxuICAgKi9cclxuICAnc3Ryb2tlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3Ryb2tlUmVjdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc3Ryb2tlUmVjdFxyXG4gICAqL1xyXG4gICdzdHJva2VSZWN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3Ryb2tlVGV4dFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc3Ryb2tlVGV4dFxyXG4gICAqL1xyXG4gICdzdHJva2VUZXh0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdHJhbnNmb3JtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC90cmFuc2Zvcm1cclxuICAgKi9cclxuICAndHJhbnNmb3JtJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdHJhbnNsYXRlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC90cmFuc2xhdGVcclxuICAgKi9cclxuICAndHJhbnNsYXRlJ1xyXG5dO1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBjb25zdGFudHMvY29uc3RydWN0b3JzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGNvbnN0cnVjdG9ycyBsZXZlbHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7QXJyYXlbXX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3RvcnMgPSBbXHJcbiAgW10sXHJcbiAgW10sXHJcbiAgW11cclxuXTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgY29uc3RhbnRzL2VsZW1lbnRzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIG1ldGhvZHMgZm9yIHtAbGluayBFbGVtfSBmb3IgY3JlYXRpbmcgaHRtbC1lbGVtZW50cy5cclxuICovXHJcblxyXG4vKipcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtTdHJpbmdbXX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBodG1sRWxlbWVudHMgPSBbXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2EnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhYmJyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYWJicicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FkZHJlc3NcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhZGRyZXNzJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYXJlYVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FyZWEnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhcnRpY2xlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYXJ0aWNsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2F1ZGlvXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYXVkaW8nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNiXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Jhc2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdiYXNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYmRpXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYmRpJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYmRvXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYmRvJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYmxvY2txdW90ZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2Jsb2NrcXVvdGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNib2R5XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYm9keScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2JyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYnInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNidXR0b25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdidXR0b24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjYW52YXNcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjYW52YXMnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjYXB0aW9uXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY2FwdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NpdGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjaXRlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29kZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2NvZGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjb2xcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjb2wnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjb2xncm91cFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2NvbGdyb3VwJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY29udGVudFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2NvbnRlbnQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkYXRhbGlzdFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2RhdGFsaXN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RlbFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2RlbCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2RldGFpbHNcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkZXRhaWxzJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGZuXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGZuJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGlhbG9nXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGlhbG9nJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGl2XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGl2JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGxcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkbCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2R0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZHQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNlbGVtZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZWxlbWVudCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2VtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZW0nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNlbWJlZFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2VtYmVkJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmllbGRzZXRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmaWVsZHNldCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZpZ2NhcHRpb25cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmaWdjYXB0aW9uJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmlndXJlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmlndXJlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9vdGVyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZm9vdGVyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9ybVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2Zvcm0nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoMVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2gxJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaDJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoMicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2gzXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaDMnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoNFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2g0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaDVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoNScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2g2XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaDYnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoZWFkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaGVhZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hlYWRlclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2hlYWRlcicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hncm91cFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2hncm91cCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2hyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaHInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2lmcmFtZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2lmcmFtZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ltZ1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ltZycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2lucHV0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaW5wdXQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNpbnNcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdpbnMnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNrYmRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdrYmQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsYWJlbFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2xhYmVsJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGVnZW5kXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbGVnZW5kJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbGlcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdsaScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2xpbmtcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdsaW5rJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWFpblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21haW4nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtYXJrXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWFyaycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lbnVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZW51JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVudWl0ZW1cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZW51aXRlbScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21ldGFcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZXRhJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWV0ZXJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZXRlcicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI25hdlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ25hdicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI25vc2NyaXB0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbm9zY3JpcHQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNvbFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ29sJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jb3B0Z3JvdXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdvcHRncm91cCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI29wdGlvblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ29wdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI291dHB1dFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ291dHB1dCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdwJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcGFyYW1cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdwYXJhbScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3ByZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3ByZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Byb2dyZXNzXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncHJvZ3Jlc3MnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNxXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JwXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncnAnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNydFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3J0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcnRjXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncnRjJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcnVieVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3J1YnknLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3NhbXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzYW1wJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2NyaXB0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc2NyaXB0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2VjdGlvblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NlY3Rpb24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzZWxlY3RcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzZWxlY3QnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzaGFkb3dcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzaGFkb3cnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzbWFsbFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NtYWxsJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc291cmNlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc291cmNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3BhblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NwYW4nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHJvbmdcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzdHJvbmcnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdHlsZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3N0eWxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3ViXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3ViJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc3VtbWFyeVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3N1bW1hcnknLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzdXAnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0YWJsZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RhYmxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGJvZHlcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0Ym9keScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RkXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0ZW1wbGF0ZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RlbXBsYXRlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGV4dGFyZWFcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0ZXh0YXJlYScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3Rmb290XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndGZvb3QnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGhlYWRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0aGVhZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RpbWVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0aW1lJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdGl0bGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd0aXRsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3RyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndHInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0cmFja1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RyYWNrJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN1bFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3VsJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdmFyXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndmFyJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdmlkZW9cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd2aWRlbycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3diclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3dicidcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBzdmdFbGVtZW50cyA9IFtcclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhbHRHbHlwaFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FsdEdseXBoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYWx0R2x5cGhEZWZcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhbHRHbHlwaERlZicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FsdEdseXBoSXRlbVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FsdEdseXBoSXRlbScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2FuaW1hdGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdhbmltYXRlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYW5pbWF0ZUNvbG9yXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYW5pbWF0ZUNvbG9yJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jYW5pbWF0ZU1vdGlvblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2FuaW1hdGVNb3Rpb24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNhbmltYXRlVHJhbnNmb3JtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnYW5pbWF0ZVRyYW5zZm9ybScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NpcmNsZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2NpcmNsZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2NsaXBQYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY2xpcFBhdGgnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNjb2xvclByb2ZpbGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdjb2xvci1wcm9maWxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jY3Vyc29yXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnY3Vyc29yJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZGVmc1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2RlZnMnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNkZXNjXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZGVzYycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2Rpc2NhcmRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdkaXNjYXJkJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZWxsaXBzZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2VsbGlwc2UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUJsZW5kXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVCbGVuZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlQ29sb3JNYXRyaXhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUNvbG9yTWF0cml4JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVDb21wb25lbnRUcmFuc2ZlclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUNvbXBvc2l0ZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlQ29tcG9zaXRlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVDb252b2x2ZU1hdHJpeFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlQ29udm9sdmVNYXRyaXgnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZURpZmZ1c2VMaWdodGluZ1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlRGlmZnVzZUxpZ2h0aW5nJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVEaXNwbGFjZW1lbnRNYXBcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZURpc3BsYWNlbWVudE1hcCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRGlzdGFudExpZ2h0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVEaXN0YW50TGlnaHQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZURyb3BTaGFkb3dcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZURyb3BTaGFkb3cnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUZsb29kXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVGbG9vZCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRnVuY0FcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUZ1bmNBJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVGdW5jQlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlRnVuY0InLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZUZ1bmNHXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVGdW5jRycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlRnVuY1JcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUZ1bmNSJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVHYXVzc2lhbkJsdXJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUdhdXNzaWFuQmx1cicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlSW1hZ2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZUltYWdlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVNZXJnZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlTWVyZ2UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZU1lcmdlTm9kZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlTWVyZ2VOb2RlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVNb3JwaG9sb2d5XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVNb3JwaG9sb2d5JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZmVPZmZzZXRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZU9mZnNldCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlUG9pbnRMaWdodFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlUG9pbnRMaWdodCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlU3BlY3VsYXJMaWdodGluZ1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZlU3BvdExpZ2h0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZmVTcG90TGlnaHQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZVRpbGVcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZVRpbGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmZVR1cmJ1bGVuY2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmZVR1cmJ1bGVuY2UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb250XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZm9udCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ZvbnRGYWNlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZm9udC1mYWNlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VGb3JtYXRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdmb250LWZhY2UtZm9ybWF0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZm9udEZhY2VOYW1lXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZm9udC1mYWNlLW5hbWUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb250RmFjZVNyY1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZvbnQtZmFjZS1zcmMnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb250RmFjZVVyaVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2ZvbnQtZmFjZS11cmknLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNmb3JlaWduT2JqZWN0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZm9yZWlnbk9iamVjdCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdnJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jZ2x5cGhcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdnbHlwaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2dseXBoUmVmXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnZ2x5cGhSZWYnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNoYXRjaFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ2hhdGNoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaGF0Y2hwYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaGF0Y2hwYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jaGtlcm5cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdoa2VybicsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2ltYWdlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnaW1hZ2UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNsaW5lXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbGluZScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI2xpbmVhckdyYWRpZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbGluZWFyR3JhZGllbnQnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtYXJrZXJcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtYXJrZXInLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtYXNrXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWFzaycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21lc2hcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdtZXNoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVzaGdyYWRpZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWVzaGdyYWRpZW50JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVzaHBhdGNoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWVzaHBhdGNoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWVzaHJvd1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21lc2hyb3cnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNtZXRhZGF0YVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ21ldGFkYXRhJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jbWlzc2luZ0dseXBoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbWlzc2luZy1nbHlwaCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI21wYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnbXBhdGgnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwYXRoXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAncGF0aCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3BhdHRlcm5cclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdwYXR0ZXJuJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcG9seWdvblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3BvbHlnb24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNwb2x5bGluZVxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3BvbHlsaW5lJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jcmFkaWFsR3JhZGllbnRcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdyYWRpYWxHcmFkaWVudCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3JlY3RcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdyZWN0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc2V0XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc2V0JyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jc29saWRjb2xvclxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3NvbGlkY29sb3InLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdG9wXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3RvcCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3N0eWxlXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAnc3R5bGUnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzdmdcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzdmcnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzd2l0Y2hcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzd2l0Y2gnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSNzeW1ib2xcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICdzeW1ib2wnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0ZXh0UGF0aFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RleHRQYXRoJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdHJlZlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RyZWYnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN0c3BhblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3RzcGFuJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1lbWJlciB7RnVuY3Rpb259IEVsZW0jdW5rbm93blxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gYXBwbGllZEV4cHJlc3Npb25zXHJcbiAgICogQHJldHVybnMge0VsZW19XHJcbiAgICovXHJcbiAgJ3Vua25vd24nLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN1c2VcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGFwcGxpZWRFeHByZXNzaW9uc1xyXG4gICAqIEByZXR1cm5zIHtFbGVtfVxyXG4gICAqL1xyXG4gICd1c2UnLFxyXG5cclxuICAvKipcclxuICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gRWxlbSN2aWV3XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndmlldycsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBFbGVtI3ZrZXJuXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBhcHBsaWVkRXhwcmVzc2lvbnNcclxuICAgKiBAcmV0dXJucyB7RWxlbX1cclxuICAgKi9cclxuICAndmtlcm4nXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3Qgdm9pZEVsZW1lbnRzID0gW1xyXG4gICdhcmVhJyxcclxuICAnYmFzZScsXHJcbiAgJ2JyJyxcclxuICAnY29sJyxcclxuICAnY29tbWFuZCcsXHJcbiAgJ2VtYmVkJyxcclxuICAnaHInLFxyXG4gICdpbWcnLFxyXG4gICdpbnB1dCcsXHJcbiAgJ2tleWdlbicsXHJcbiAgJ2xpbmsnLFxyXG4gICdtZXRhJyxcclxuICAncGFyYW0nLFxyXG4gICdzb3VyY2UnLFxyXG4gICd0cmFjaycsXHJcbiAgJ3dicidcclxuXTtcclxuIiwiZXhwb3J0IGNvbnN0IGh0bWxBbGxvd2VkVGFnU3ltYm9scyA9ICdbYS16XVthLXpcXFxcZFxcXFwtXy46IUAjXFxcXCQlXFxcXF4mKigpXFxcXFtcXFxcXXt9XFxcXFxcXFw9XFwnXCJdKic7XHJcbmV4cG9ydCBjb25zdCBodG1sQWxsb3dlZEF0dHJTeW1ib2xzID0gJ1teXFxcXHUwMDAwLVxcXFx1MDAyMFxcXFxzXCJcXCc+Lz1dKyc7XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGNvbnN0YW50cy9yZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIFJlZ0V4cC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNvbnN0XHJcbiAqIEBuYW1lIG1vZHVsZTpjb25zdGFudHMvcmVnZXhwU3BlY2lhbENoYXJhY3RlcnN+cmVnZXhwU3BlY2lhbENoYXJhY3RlcnNcclxuICogQHR5cGUge1N0cmluZ1tdfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gW1xyXG4gICcuJyxcclxuICAnKycsICcqJywgJz8nLFxyXG4gICcoJywgJyknLFxyXG4gICdbJywgJ10nLFxyXG4gICd7JywgJ30nLFxyXG4gICc8JywgJz4nLFxyXG4gICdeJywgJyQnLFxyXG4gICchJyxcclxuICAnPScsXHJcbiAgJzonLFxyXG4gICctJyxcclxuICAnfCcsXHJcbiAgJywnLFxyXG4gICdcXFxcJ1xyXG5dO1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBjb25zdGFudHMvdmFsaWRhdGVDaGVja0V4cHJlc3Npb25zXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGRpZmZlcmVudCB0eXBlcyBvZiB2YWxpZGF0ZSBleHByZXNzaW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpoZWxwZXJzL3ZhbGlkYXRlfS5cclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBtZXRob2RzIGZyb20gJy4uL2hlbHBlcnMvY2hlY2tUeXBlcyc7XHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIGNoZWNrVmFsaWRpdHlDYWxsYmFja1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZhbGlkYXRlRXhwclxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIHRocm93biBlcnJvci5cclxuICogQHByb3BlcnR5IHtFcnJvcn0gZXJyb3IgLSBUeXBlIG9mIHRoZSB0aHJvd24gZXJyb3IuXHJcbiAqIEBwcm9wZXJ0eSB7Y2hlY2tWYWxpZGl0eUNhbGxiYWNrfSBjaGVjayAtIENhbGxiYWNrIGZvciBjaGVja2luZyB2YWx1ZS5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGUge3ZhbGlkYXRlRXhwcltdfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gT2JqZWN0IG9mIGRpZmZlcmVudCB0eXBlcyBvZiB2YWxpZGF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQ2hlY2tFeHByZXNzaW9ucyA9IHtcclxuICAnPjAnOiB7XHJcbiAgICBjaGVjazogKG4pID0+IG4gPiAwLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgcG9zaXRpdmUhJyxcclxuICAgIGVycm9yOiBSYW5nZUVycm9yXHJcbiAgfSxcclxuICAnPj0wJzoge1xyXG4gICAgY2hlY2s6IChuKSA9PiBuID49IDAsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBub24tbmVnYXRpdmUhJyxcclxuICAgIGVycm9yOiBSYW5nZUVycm9yXHJcbiAgfSxcclxuICAnPDAnOiB7XHJcbiAgICBjaGVjazogKG4pID0+IG4gPCAwLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbmVnYXRpdmUhJyxcclxuICAgIGVycm9yOiBSYW5nZUVycm9yXHJcbiAgfSxcclxuICAnPD0wJzoge1xyXG4gICAgY2hlY2s6IChuKSA9PiBuIDw9IDAsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBub24tcG9zaXRpdmUhJyxcclxuICAgIGVycm9yOiBSYW5nZUVycm9yXHJcbiAgfSxcclxuICAnISEnOiB7XHJcbiAgICBjaGVjazogKHYpID0+ICFtZXRob2RzLmlzTmlsKHYpLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbm90IG51bGwgb3IgdW5kZWZpbmVkIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICBhcnJheToge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNBcnJheSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICAnYXJyYXl8fCEnOiB7XHJcbiAgICBjaGVjazogKGEpID0+IG1ldGhvZHMuaXNBcnJheShhKSB8fCBtZXRob2RzLmlzTmlsKGEpLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXksIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgYXJyYXlMaWtlOiB7XHJcbiAgICBjaGVjazogbWV0aG9kcy5pc0FycmF5TGlrZSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFycmF5LWxpa2UhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdhcnJheUxpa2V8fCEnOiB7XHJcbiAgICBjaGVjazogKGEpID0+IG1ldGhvZHMuaXNBcnJheUxpa2UoYSkgfHwgbWV0aG9kcy5pc05pbChhKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFycmF5LWxpa2UsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgZGF0ZToge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNEYXRlLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBkYXRlIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICAnZGF0ZXx8ISc6IHtcclxuICAgIGNoZWNrOiAoZCkgPT4gbWV0aG9kcy5pc0RhdGUoZCkgfHwgbWV0aG9kcy5pc05pbChkKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgZGF0ZSwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICBkYXRlTGlrZToge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNEYXRlTGlrZSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGRhdGUtbGlrZSEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ2RhdGVMaWtlfHwhJzoge1xyXG4gICAgY2hlY2s6IChkKSA9PiBtZXRob2RzLmlzRGF0ZUxpa2UoZCkgfHwgbWV0aG9kcy5pc05pbChkKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGRhdGUtbGlrZSwgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICBmdW5jdGlvbjoge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNGdW5jdGlvbixcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24hJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdmdW5jdGlvbnx8ISc6IHtcclxuICAgIGNoZWNrOiAoZikgPT4gbWV0aG9kcy5pc0Z1bmN0aW9uKGYpIHx8IG1ldGhvZHMuaXNOaWwoZiksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIGludDoge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNJbnRlZ2VyLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ2ludHx8ISc6IHtcclxuICAgIGNoZWNrOiAoaSkgPT4gbWV0aG9kcy5pc0ludGVnZXIoaSkgfHwgbWV0aG9kcy5pc05pbChpKSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgaW50TGlrZToge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNJbnRlZ2VyTGlrZSxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGludGVnZXItbGlrZSEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ2ludExpa2V8fCEnOiB7XHJcbiAgICBjaGVjazogKGkpID0+IG1ldGhvZHMuaXNJbnRlZ2VyTGlrZShpKSB8fCBtZXRob2RzLmlzTmlsKGkpLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgaW50ZWdlci1saWtlLCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIG51bWJlcjoge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNOdW1iZXIsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ251bWJlcnx8ISc6IHtcclxuICAgIGNoZWNrOiAobikgPT4gbWV0aG9kcy5pc051bWJlcihuKSB8fCBtZXRob2RzLmlzTmlsKG4pLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgbnVtYmVyTGlrZToge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNOdW1iZXJMaWtlLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbnVtYmVyLWxpa2UhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gICdudW1iZXJMaWtlfHwhJzoge1xyXG4gICAgY2hlY2s6IChuKSA9PiBtZXRob2RzLmlzTnVtYmVyTGlrZShuKSB8fCBtZXRob2RzLmlzTmlsKG4pLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgbnVtYmVyLWxpa2UsIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgb2JqZWN0OiB7XHJcbiAgICBjaGVjazogbWV0aG9kcy5pc09iamVjdCxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ29iamVjdHx8ISc6IHtcclxuICAgIGNoZWNrOiAobykgPT4gbWV0aG9kcy5pc09iamVjdChvKSB8fCBtZXRob2RzLmlzTmlsKG8pLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LCBvciB1bmRlZmluZWQsIG9yIG51bGwhJyxcclxuICAgIGVycm9yOiBUeXBlRXJyb3JcclxuICB9LFxyXG4gIHJlZ2V4cDoge1xyXG4gICAgY2hlY2s6IG1ldGhvZHMuaXNSZWdFeHAsXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgJ3JlZ2V4cHx8ISc6IHtcclxuICAgIGNoZWNrOiAocikgPT4gbWV0aG9kcy5pc1JlZ0V4cChyKSB8fCBtZXRob2RzLmlzTmlsKHIpLFxyXG4gICAgdGV4dDogJyRuIGFyZ3VtZW50IG11c3QgYmUgYSByZWd1bGFyIGV4cHJlc3Npb24sIG9yIHVuZGVmaW5lZCwgb3IgbnVsbCEnLFxyXG4gICAgZXJyb3I6IFR5cGVFcnJvclxyXG4gIH0sXHJcbiAgc3RyaW5nOiB7XHJcbiAgICBjaGVjazogbWV0aG9kcy5pc1N0cmluZyxcclxuICAgIHRleHQ6ICckbiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfSxcclxuICAnc3RyaW5nfHwhJzoge1xyXG4gICAgY2hlY2s6IChzKSA9PiBtZXRob2RzLmlzU3RyaW5nKHMpIHx8IG1ldGhvZHMuaXNOaWwocyksXHJcbiAgICB0ZXh0OiAnJG4gYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgb3IgdW5kZWZpbmVkLCBvciBudWxsIScsXHJcbiAgICBlcnJvcjogVHlwZUVycm9yXHJcbiAgfVxyXG59O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL1N5bWJvbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBTeW1ib2wgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgfHwge1xyXG4gIHRvU3RyaW5nVGFnOiAnU3ltYm9sLnRvU3RyaW5nVGFnJyxcclxuICBpdGVyYXRvcjogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNilcclxufTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgUHJvbWlzZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWl4aW5cclxuICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgUHJvbWlzZSBjbGFzcy5cclxuICovXHJcblxyXG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBkZWZpbmVQcm9wZXJ0aWVzLCBTeW1ib2wgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gUHJvbWlzZSB2YWx1ZS5cclxuICogQHBhcmFtIHtCb29sZWFufSBzdWNjZXNzIC0gSWYgdGhlIHByZXZpb3VzIHByb21pc2UgaXMgZnVsZmlsbGVkIGl0J3MgdHJ1ZSBhbmQgZmFsc2UgaWYgcmVqZWN0ZWQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBvblJlamVjdGVkXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtFcnJvcnwqfSBlcnIgLSBQcm9taXNlIGVycm9yLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgb25GdWxmaWxsZWRcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gUHJvbWlzZSB2YWx1ZS5cclxuICovXHJcblxyXG5jb25zdCBzZWNyZXQgPSB7fTtcclxuY29uc3QgaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFByb21pc2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciAtIEZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIGFyZ3VtZW50czogcmVzb2x2ZSBhbmQgcmVqZWN0IGZ1bmN0aW9ucy5cclxuICogQ2FsbCB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB3aGVuIHlvdSBuZWVkIHRvIGZ1bGZpbGwgdGhlIHByb21pc2UgYW5kIGNhbGwgdGhlIHJlamVjdCBvbmVcclxuICogd2hlbiB5b3UgbmVlZCB0byByZWplY3QgaXQuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBJbnN0YW5jZSBvZiBQcm9taXNlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2VcclxuICogQGRlc2NyaXB0aW9uIENsYXNzIHdpdGggYWxtb3N0IGlkZW50aWNhbCBBUEkgdG9cclxuICogW0VTNiBQcm9taXNlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlfS5cclxuICogVGhlcmUgaXMgYSBjb3VwbGUgZGlmZmVyZW5jZXM6IHNldCBQcm9taXNlLm9uRXJyb3IgdG8gYSBmdW5jdGlvbiB3aXRoIHdoaWNoIHlvdSB3YW50IHRvXHJcbiAqIHN1YnNjcmliZSB0byBhIHByb21pc2UgZXJyb3IgYW5kIHNldCBQcm9taXNlLm9uVW5oYW5kbGVkUmVqZWN0aW9uIHRvIGEgZnVuY3Rpb24gd2l0aCB3aGljaFxyXG4gKiB5b3Ugd2FudCB0byBzdWJzY3JpYmUgdG8gYW4gdW5oYW5kbGVkIGVycm9yXHJcbiAqIChkZWZhdWx0cyB0byBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgJyVzICVvJywgJ1VuY2F1Z2h0IChpbiBwcm9taXNlKScpKS5cclxuICovXHJcbmNsYXNzIFByb21pc2Uge1xyXG4gIHN0YXRpYyBvbkVycm9yID0gbnVsbDtcclxuICBzdGF0aWMgb25VbmhhbmRsZWRSZWplY3Rpb24gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgJyVzICVvJywgJ1VuY2F1Z2h0IChpbiBwcm9taXNlKScpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xyXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGV4ZWN1dG9yKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9taXNlIHJlc29sdmVyICR7IHt9LnRvU3RyaW5nLmNhbGwoZXhlY3V0b3IpIH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaGlkZGVuU3RhdHVzO1xyXG4gICAgbGV0IGhpZGRlblZhbHVlO1xyXG5cclxuICAgIGNvbnN0XHRvbkZ1bGZpbGwgPSBbXTtcclxuICAgIGNvbnN0IG9uUmVqZWN0ID0gW107XHJcbiAgICBjb25zdCByZWFsUHJvbWlzZSA9IHRoaXM7XHJcbiAgICBjb25zdCBoaWRkZW5Qcm9taXNlID0ge1xyXG4gICAgICBoYW5kbGVkOiBmYWxzZSxcclxuICAgICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gaGlkZGVuU3RhdHVzO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQgc3RhdHVzKHZhbHVlKSB7XHJcbiAgICAgICAgaGlkZGVuU3RhdHVzID0gdmFsdWU7XHJcbiAgICAgICAgcmVhbFByb21pc2Uuc3RhdHVzID0gdmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gaGlkZGVuVmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldCB2YWx1ZSh2YWwpIHtcclxuICAgICAgICBoaWRkZW5WYWx1ZSA9IHZhbDtcclxuICAgICAgICByZWFsUHJvbWlzZS52YWx1ZSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBoaWRkZW5Qcm9taXNlLnN0YXR1cyA9ICdwZW5kaW5nJztcclxuICAgIGhpZGRlblByb21pc2UudmFsdWUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBoaWRkZW5Qcm9taXNlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gaGFuZGxlZCAtIElmIHRoZSBwcm9taXNlIGlzIGhhbmRsZWQgb3Igbm90LlxyXG4gICAgICogQHByb3BlcnR5IHsncGVuZGluZyd8J2Z1bGZpbGxlZCd8J3JlamVjdGVkJ30gc3RhdHVzIC0gU3RhdHVzIG9mIHRoZSBwcm9taXNlLlxyXG4gICAgICogQHByb3BlcnR5IHsqfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gaGlkZGVuUHJvbWlzZSNoYW5kbGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geygncmVqZWN0J3wncmVzb2x2ZScpfSBldmVudCAtIFR5cGUgb2YgdGhlIGV2ZW50IHRvIGhhbmRsZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBIYW5kbGVyIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgLSBSZXNvbHZlIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IC0gUmVqZWN0IGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlY3JldCAtIFNlY3JldC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBQcml2YXRlIG1ldGhvZCBmb3IgaGFuZGxpbmcgcHJvbWlzZXMuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge2hpZGRlblByb21pc2V9IFByb21pc2UjJCRcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLiQkID0ge30sIHtcclxuICAgICAgJ2dldC9zZXQgaGFuZGxlZCc6IHtcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICByZXR1cm4gaGlkZGVuUHJvbWlzZS5oYW5kbGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KGtleSkge1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gc2VjcmV0KSB7XHJcbiAgICAgICAgICAgIGhpZGRlblByb21pc2UuaGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBoYW5kbGUoc3RhdHVzLCBmLCByZXNvbHZlLCByZWplY3QsIGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHNlY3JldCkge1xyXG4gICAgICAgICAgY29uc3QgcHJveHkgPSBpc0Z1bmN0aW9uKGYpID8gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShmKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IDogbnVsbDtcclxuXHJcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSAncmVzb2x2ZScpIHtcclxuICAgICAgICAgICAgb25GdWxmaWxsLnB1c2gocHJveHkgfHwgKCh2YWx1ZSkgPT4gcmVzb2x2ZSh2YWx1ZSkpKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAncmVqZWN0Jykge1xyXG4gICAgICAgICAgICBvblJlamVjdC5wdXNoKHByb3h5IHx8ICgoZXJyKSA9PiByZWplY3QoZXJyKSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgJ2dldCBzdGF0dXMnKCkge1xyXG4gICAgICAgIHJldHVybiBoaWRkZW5Qcm9taXNlLnN0YXR1cztcclxuICAgICAgfSxcclxuICAgICAgJ2dldCB2YWx1ZScoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhpZGRlblByb21pc2UudmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcmVqZWN0KGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KGVycikge1xyXG4gICAgICBpZiAoaGlkZGVuUHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgIGhpZGRlblByb21pc2Uuc3RhdHVzID0gJ3JlamVjdGVkJztcclxuICAgICAgICBoaWRkZW5Qcm9taXNlLnZhbHVlID0gZXJyO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gb25SZWplY3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGhpZGRlblByb21pc2UuaGFuZGxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgb25SZWplY3RbaV0oZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIG9uVW5oYW5kbGVkUmVqZWN0aW9uLFxyXG4gICAgICAgICAgb25FcnJvclxyXG4gICAgICAgIH0gPSBQcm9taXNlO1xyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvbkVycm9yKSkge1xyXG4gICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWhpZGRlblByb21pc2UuaGFuZGxlZCAmJiBpc0Z1bmN0aW9uKG9uVW5oYW5kbGVkUmVqZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBvblVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xyXG4gICAgICBpZiAoaGlkZGVuUHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICB9LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoaWRkZW5Qcm9taXNlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xyXG4gICAgICAgIGhpZGRlblByb21pc2UudmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG9uRnVsZmlsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaGlkZGVuUHJvbWlzZS5oYW5kbGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICBvbkZ1bGZpbGxbaV0odmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBQcm9taXNlLmFsbFxyXG4gICAqIEBwYXJhbSB7KEFycmF5fEl0ZXJhYmxlKS48UHJvbWlzZXwqPn0gaXRlcmFibGUgLSBJdGVyYWJsZSBvYmplY3QgKGxpa2UgYXJyYXkpIG9mIHByb21pc2VzXHJcbiAgICogb3IgYW55IHZhbHVlcy5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL2FsbFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhbGwoaXRlcmFibGUpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gW107XHJcblxyXG4gICAgbGV0IHRvUmVzb2x2ZSA9IDA7XHJcblxyXG4gICAgaWYgKGl0ZXJhYmxlW2l0ZXJhdG9yXSkge1xyXG4gICAgICBpdGVyYWJsZSA9IGl0ZXJhYmxlW2l0ZXJhdG9yXSgpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICghKG5leHQgPSBpdGVyYWJsZS5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV4dC52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgdG9SZXNvbHZlKys7XHJcblxyXG4gICAgICAgICAgKChpKSA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2UudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICB0b1Jlc29sdmUtLTtcclxuICAgICAgICAgICAgICBhcnJheVtpXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUgJiYgIXRvUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGFycmF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pKGkrKyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWkpIHtcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoO1xyXG5cclxuICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgfVxyXG5cclxuICAgIHRvUmVzb2x2ZSA9IGxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpdGVyYWJsZVtpXSk7XHJcblxyXG4gICAgICAgIHByb21pc2UudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRvUmVzb2x2ZS0tO1xyXG4gICAgICAgICAgYXJyYXlbaV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICBpZiAoIXRvUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlKGFycmF5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgUHJvbWlzZS5yYWNlXHJcbiAgICogQHBhcmFtIHsoQXJyYXl8SXRlcmFibGUpLjxQcm9taXNlfCo+fSBpdGVyYWJsZSAtIEl0ZXJhYmxlIG9iamVjdCAobGlrZSBhcnJheSkgb2YgcHJvbWlzZXNcclxuICAgKiBvciBhbnkgdmFsdWVzLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvcmFjZVxyXG4gICAqL1xyXG4gIHN0YXRpYyByYWNlKGl0ZXJhYmxlKSB7XHJcbiAgICBpZiAoaXRlcmFibGVbaXRlcmF0b3JdKSB7XHJcbiAgICAgIGl0ZXJhYmxlID0gaXRlcmFibGVbaXRlcmF0b3JdKCk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG5cclxuICAgICAgICB3aGlsZSAoIShuZXh0ID0gaXRlcmFibGUubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICBuZXh0LnZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZXJhYmxlW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIFByb21pc2UucmVqZWN0XHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIHJlamVjdC5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL3JlamVjdFxyXG4gICAqL1xyXG4gIHN0YXRpYyByZWplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJlamVjdCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgUHJvbWlzZS5yZXNvbHZlXHJcbiAgICogQHBhcmFtIHtQcm9taXNlfFRoZW5hYmxlfCp9IHZhbHVlIC0gUHJvbWlzZSwgdGhlbmFibGUgb3IgYW55IHZhbHVlIHRvIHJlc29sdmUuXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IE5ldyBpbnN0YW5jZSBvZiBQcm9taXNlLlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yZXNvbHZlXHJcbiAgICovXHJcbiAgc3RhdGljIHJlc29sdmUodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFib3J0KCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBQcm9taXNlI2NhdGNoXHJcbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSBvblJlamVjdGVkIC0gb25SZWplY3RlZCBjYWxsYmFjay5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gTmV3IGluc3RhbmNlIG9mIFByb21pc2UuXHJcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL2NhdGNoXHJcbiAgICovXHJcbiAgY2F0Y2gob25SZWplY3RlZCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgUHJvbWlzZSNmaW5hbGx5XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7b25GdWxmaWxsZWRPclJlamVjdGVkfSBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgLSBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgY2FsbGJhY2suXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgY2F0Y2hpbmcgYm90aCBmdWxmaWxsZWQgYW5kIHJlamVjdGVkIHByb21pc2VzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBzcGlubmVyLnNob3coKTtcclxuICAgKiBmZXRjaERhdGEoKVxyXG4gICAqICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggZGF0YVxyXG4gICAqICAgfSlcclxuICAgKiAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICogICAgIC8vIGhhbmRsZSBlcnJvciBzb21laG93XHJcbiAgICogICB9KVxyXG4gICAqICAgLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAqICAgICBzcGlubmVyLmhpZGUoKTtcclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG4gIGZpbmFsbHkob25GdWxmaWxsZWRPclJlamVjdGVkKSB7XHJcbiAgICBjb25zdCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9uRnVsZmlsbGVkT3JSZWplY3RlZCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGhlbigodmFsdWUpID0+IChcclxuICAgICAgUHJvbWlzZVxyXG4gICAgICAgIC5yZXNvbHZlKFxyXG4gICAgICAgICAgaXNGdW5jXHJcbiAgICAgICAgICAgID8gb25GdWxmaWxsZWRPclJlamVjdGVkKHZhbHVlLCB0cnVlKVxyXG4gICAgICAgICAgICA6IDBcclxuICAgICAgICApXHJcbiAgICAgICAgLnRoZW4oKCkgPT4gdmFsdWUpXHJcbiAgICApLCAoZXJyKSA9PiAoXHJcbiAgICAgIFByb21pc2VcclxuICAgICAgICAucmVzb2x2ZShcclxuICAgICAgICAgIGlzRnVuY1xyXG4gICAgICAgICAgICA/IG9uRnVsZmlsbGVkT3JSZWplY3RlZChlcnIsIGZhbHNlKVxyXG4gICAgICAgICAgICA6IDBcclxuICAgICAgICApXHJcbiAgICAgICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5yZWplY3QoZXJyKSlcclxuICAgICkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBQcm9taXNlI3RoZW5cclxuICAgKiBAcGFyYW0ge29uRnVsZmlsbGVkfSBbb25GdWxmaWxsZWRdIC0gb25GdWxmaWxsZWQgY2FsbGJhY2suXHJcbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSBbb25SZWplY3RlZF0gLSBvblJlamVjdGVkIGNhbGxiYWNrLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBOZXcgaW5zdGFuY2Ugb2YgUHJvbWlzZS5cclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvdGhlblxyXG4gICAqL1xyXG4gIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLiQkO1xyXG5cclxuICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcHJvbWlzZS5oYW5kbGUoJ3JlamVjdCcsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCwgc2VjcmV0KTtcclxuICAgICAgICBwcm9taXNlLmhhbmRsZSgncmVzb2x2ZScsIG9uRnVsZmlsbGVkLCByZXNvbHZlLCByZWplY3QsIHNlY3JldCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb21pc2UuaGFuZGxlZCA9IHNlY3JldDtcclxuXHJcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBwcm9taXNlO1xyXG5cclxuICAgIGxldCBtZXRob2Q7XHJcbiAgICBsZXQgaGFuZGxlcjtcclxuXHJcbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XHJcbiAgICAgIG1ldGhvZCA9ICdyZXNvbHZlJztcclxuICAgICAgaGFuZGxlciA9IG9uRnVsZmlsbGVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWV0aG9kID0gJ3JlamVjdCc7XHJcbiAgICAgIGhhbmRsZXIgPSBvblJlamVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZVttZXRob2RdKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIodmFsdWUpKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmRlZmluZVByb3BlcnRpZXMoUHJvbWlzZS5wcm90b3R5cGUsIHtcclxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1Byb21pc2UnXHJcbn0pO1xyXG5cclxuZXhwb3J0IHsgUHJvbWlzZSB9O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3BhcnNlSGVhZGVyc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBwYXJzZUhlYWRlcnMgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XHJcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICcuL2l0ZXJhdGUnO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBwYXJzZUhlYWRlcnNcclxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgLSBSYXcgaGVhZGVycy5cclxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBvYmplY3RcclxuICogQGRlc2NyaXB0aW9uIEZ1bmN0aW9uIGZvciBwYXJzaW5nIHJhdyBoZWFkZXJzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgKHJhd0hlYWRlcnMpID0+IHtcclxuICBjb25zdCBoZWFkZXJzID0ge307XHJcblxyXG4gIGl0ZXJhdGUoKHJhd0hlYWRlcnMgfHwgJycpLnNwbGl0KCdcXG4nKSwgKHZhbHVlKSA9PiB7XHJcbiAgICBjb25zdCBpbmRleCA9IHZhbHVlLmluZGV4T2YoJzonKTtcclxuICAgIGNvbnN0IGtleSA9IG5ldyBTdHIodmFsdWUuc3Vic3RyaW5nKDAsIGluZGV4KSlcclxuICAgICAgLnRyaW0oKVxyXG4gICAgICAudG9DYW1lbENhc2UoKS4kO1xyXG4gICAgY29uc3QgdmFsID0gbmV3IFN0cih2YWx1ZS5zdWJzdHJpbmcoaW5kZXggKyAxKSkudHJpbSgpLiQ7XHJcblxyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICBoZWFkZXJzW2tleV0gPSAoaGVhZGVyc1trZXldID8gYCR7IGhlYWRlcnNba2V5XSB9LCBgIDogJycpICsgdmFsO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gaGVhZGVycztcclxufTtcclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy90cmFuc2Zvcm1EYXRhXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRyYW5zZm9ybURhdGEgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFyciB9IGZyb20gJy4uL0Fycic7XHJcbmltcG9ydCB7IFN1cGVyIH0gZnJvbSAnLi4vU3VwZXInO1xyXG5pbXBvcnQgeyBpc09iamVjdCwgdG9TdHJpbmdUYWcgfSBmcm9tICcuLyc7XHJcblxyXG5jb25zdCBub3RUb1RyYW5zZm9ybSA9IG5ldyBBcnIoWydGb3JtRGF0YScsICdGaWxlJywgJ0Jsb2InLCAnQXJyYXlCdWZmZXInLCAnU3RyaW5nJywgJ051bWJlciddKTtcclxuY29uc3Qgd2l0aG91dEJvZHkgPSBuZXcgQXJyKFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJ10pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIERhdGEgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBIVFRQIG1ldGhvZC5cclxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgLSBPYmplY3Qgd2l0aCBoZWFkZXJzLlxyXG4gKiBAcmV0dXJucyB7Kn0gLSBUcmFuc2Zvcm1lZCBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgKGRhdGEsIG1ldGhvZCwgaGVhZGVycykgPT4ge1xyXG4gIGRhdGEgPSBuZXcgU3VwZXIoZGF0YSkuJDtcclxuXHJcbiAgaWYgKHdpdGhvdXRCb2R5LmluZGV4T2ZTdHJpY3QobWV0aG9kKSAhPT0gLTEpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzT2JqZWN0KGRhdGEpICYmIG5vdFRvVHJhbnNmb3JtLmluZGV4T2ZTdHJpY3QodG9TdHJpbmdUYWcoZGF0YSkpID09PSAtMSkge1xyXG4gICAgaWYgKCFoZWFkZXJzLmNvbnRlbnRUeXBlKSB7XHJcbiAgICAgIGhlYWRlcnMuY29udGVudFR5cGUgPSBbJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCddO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgU3VwZXIoZGF0YSkuanNvbigpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGE7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvcmVzb2x2ZVVSTFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZGVzY3JpcHRpb24gRXhwb3J0cyBPYmplY3QuYXNzaWduLWxpa2UgbWV0aG9kLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN0ciB9IGZyb20gJy4uL1N0cic7XHJcblxyXG5jb25zdCB7IGxvY2F0aW9uIH0gPSBnbG9iYWw7XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZGVjb2RlUXVlcnkpID0+IHtcclxuICBjb25zdCB7XHJcbiAgICBzZWFyY2g6IHF1ZXJ5LFxyXG4gICAgaGFzaFxyXG4gIH0gPSBsb2NhdGlvbjtcclxuICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICBxdWVyeToge30sXHJcbiAgICBoYXNoOiBoYXNoLnJlcGxhY2UoL14jLywgJycpXHJcbiAgfTtcclxuXHJcbiAgaWYgKCFxdWVyeSkge1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIG5ldyBTdHIocXVlcnkucmVwbGFjZSgvXlxcPy8sICcnKSlcclxuICAgIC5zcGxpdCgnJicpXHJcbiAgICAuZm9yRWFjaCgocmF3UGFyYW0pID0+IHtcclxuICAgICAgbGV0IFtwYXJhbSwgdmFsdWUgPSAnJ10gPSByYXdQYXJhbS5zcGxpdCgnPScpO1xyXG5cclxuICAgICAgcGFyYW0gPSBkZWNvZGVRdWVyeSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBwYXJhbTtcclxuICAgICAgdmFsdWUgPSBkZWNvZGVRdWVyeSA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcbiAgICAgIGlmICghL15bXltdKy8udGVzdChwYXJhbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBwYXJhbU5hbWU7XHJcbiAgICAgIGxldCBwYXJhbU9iamVjdCA9IHBhcmFtcy5xdWVyeTtcclxuXHJcbiAgICAgIG5ldyBTdHIocGFyYW0pXHJcbiAgICAgICAgLm1hdGNoKC9eW15bXFxdXSp8XFxbW15bXFxdXSpdL2cpXHJcbiAgICAgICAgLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ1snKSkge1xyXG4gICAgICAgICAgICBwYXJhbU5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcclxuXHJcbiAgICAgICAgICBwYXJhbU9iamVjdCA9IHBhcmFtT2JqZWN0W3BhcmFtTmFtZV0gPSBwYXJhbU9iamVjdFtwYXJhbU5hbWVdIHx8IChuYW1lID8ge30gOiBbXSk7XHJcbiAgICAgICAgICBwYXJhbU5hbWUgPSBuYW1lIHx8IHBhcmFtT2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIHBhcmFtT2JqZWN0W3BhcmFtTmFtZV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICByZXR1cm4gcGFyYW1zO1xyXG59O1xyXG4iLCJpbXBvcnQgKiBhcyBzdGF0aWNzIGZyb20gJy4vbGliL2Jyb3dzZXInO1xyXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL2xpYi9oZWxwZXJzL2Fzc2lnbic7XHJcblxyXG5jb25zdCB7IEQgfSA9IHN0YXRpY3M7XHJcblxyXG5hc3NpZ24oRCwgc3RhdGljcyk7XHJcblxyXG5kZWxldGUgRC5EO1xyXG5cclxuZ2xvYmFsLkQgPSBEO1xyXG4iXSwibmFtZXMiOlsidG9TdHJpbmdUYWciLCJvYmplY3QiLCJ0b1N0cmluZyIsImNhbGwiLCJyZXBsYWNlIiwiaXNBcnJheSIsInZhbHVlIiwiaXNBcnJheUxpa2UiLCJpc0Z1bmN0aW9uIiwibGVuZ3RoIiwiaXNJbnRlZ2VyIiwiaXNCb29sZWFuIiwiaXNEYXRlIiwiaXNEYXRlTGlrZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJpc0VsZW1lbnQiLCJ0ZXN0IiwiaXNGaW5pdGUiLCJpc051bWJlciIsIk51bWJlciIsIkluZmluaXR5IiwiaXNJbnRlZ2VyTGlrZSIsInBhcnNlSW50IiwiaXNOdWxsIiwiaXNOaWwiLCJpc051bWJlckxpa2UiLCJpc09iamVjdCIsIk9iamVjdCIsImlzUGxhaW5PYmplY3QiLCJpc1ByaW1pdGl2ZSIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsImlzUmVnRXhwIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiRCIsImkiLCJjb25zdHJ1Y3RvcnMiLCJsZXZlbENvbnN0cnVjdG9ycyIsImsiLCJsZW4iLCJjbHMiLCJjaGVjayIsIml0ZXJhdGUiLCJjYWxsYmFjayIsImFycmF5IiwiaXRlcmF0ZWRLZXlzIiwiaXRlcmF0ZWQiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImFzc2lnbiIsInRhcmdldCIsIm9iamVjdHMiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJpbmRleCIsImR5bmFtaWNEZWZpbmVQcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsInByb3BlcnR5R2VuZXJhdG9yIiwibmFtZSIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydGllcyIsIm1ldGhvZCIsInVuZGVmaW5lZCIsImdldCIsInNldCIsInRvQXJyYXkiLCJjcmVhdGVOZXdBcnJheSIsInB1c2giLCJ2YWxpZGF0ZSIsImFyZ3MiLCJvcHRpb25zIiwibnVtYmVyIiwiY2hlY2tlciIsInZhbGlkYXRlQ2hlY2tFeHByZXNzaW9ucyIsImVycm9yIiwidGV4dCIsIm51bWJlcnMiLCJjaGFyIiwiYWxwaGFiZXQiLCJzdHJpbmciLCJyYW5nZXMiLCJzcGxpdCIsInJhbmdlIiwiRXJyb3IiLCJzdGFydCIsImNoYXJDb2RlQXQiLCJlbmQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJBbHBoYWJldCIsInN3aXRjaGVyIiwiY2FzZXMiLCJtb2RlIiwiZGVmYXVsdFZhbHVlIiwiU3dpdGNoZXIiLCJ3aGVuIiwiY29uZGl0aW9uIiwidmFsdWUxIiwidmFsdWUyIiwiZGVlcEFzc2lnbiIsImRlZXBDbG9uZSIsImNsb25lIiwiY2xvbmVTd2l0Y2hlciIsImRlZXBFcXVhbCIsIm8xIiwibzIiLCJzdHJpY3QiLCJtYXRjaCIsImxhc3RJbmRleCIsInAxIiwicDIiLCJrZXlzIiwiZGVlcEV2ZXJ5IiwibiIsInRyZWUiLCJuZXdUcmVlIiwiY29uY2F0IiwiZGVlcEZpbHRlciIsIm51bCIsIm8iLCJmaWx0ZXJlZCIsImRlZXBGaW5kIiwicmVzdWx0IiwiZGVlcEZvckVhY2giLCJkZWVwRm9yRWFjaEVudHJ5IiwiZGVlcEZyZWV6ZSIsImZyZWV6ZSIsImRlZXBNYXAiLCJkZWVwUmVkdWNlIiwiSVYiLCJkZWVwU29tZSIsIngiLCJhcHBseSIsIm5vb3AiLCJwcm9wIiwic2VsZiIsInJhbmQiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJhc2MiLCJ5IiwiQXJyIiwiYmxvYiIsImJsb2JQYXJ0cyIsIkJsb2JPYmplY3QiLCJCbG9iIiwidHJpbSIsInBhcnNlSlNPTiIsImpzb24iLCJKU09OIiwicGFyc2UiLCJkYXRlcyIsInBhcnNlZCIsInRoaXMiLCJmaW5kIiwibWFya3VwIiwiZWxlbSIsIm1hdGNoZXMiLCJyYXdUZXh0U3dpdGNoZXIiLCJTdXBlciIsImNvbnN0cnVjdENsb3NlVGFnUmVnRXhwIiwiTk9ERV9SRUdFWF9TRVQiLCJtYXAiLCJyZWdleCIsInJldHVybmluZyIsImF0dHJzIiwic3RhcnRNYXJrdXAiLCJjbG9zZU1hdGNoIiwic2VsZkNsb3NpbmciLCJzbGljZSIsIlRBR19PUEVOX0NMT1NFIiwiYXR0ciIsIkFUVFJJQlVURSIsIm1pbiIsIk5hTiIsInRhZ05hbWUiLCJSZWdFeHAiLCJuZWFyU3RyaW5nIiwicGFyc2VDaGFyYWN0ZXJEYXRhIiwiaW5uZXJIVE1MIiwiZGl2IiwidGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJ0b0ZpbmQiLCJpc0VsZW0iLCJFbGVtIiwiaXNXaW5kb3ciLCJpc0hUTUxEb2N1bWVudCIsImlzRG9jdW1lbnRGcmFnbWVudCIsImlzU3R5bGVSdWxlIiwiaXNDb21tZW50T3JUZXh0IiwidGFnIiwiZ2V0RWxlbSIsIiQiLCJlbXB0eURpdiIsImdldE5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiYWRkRHdheW5lRGF0YSIsIndpbmRvd3NEd2F5bmVEYXRhIiwic29tZSIsImVsZW1lbnQiLCJnZXRDb250ZXh0Iiwic2VsZWN0b3IiLCJiYXNlIiwibmF0aXZlRG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyc2VIVE1MIiwiaHRtbCIsImNvbGxhcHNlV2hpdGVTcGFjZSIsIm1hcmt1cFRvSlNPTiIsInRlbXBsYXRlIiwiZG9jIiwiY29udGVudCIsImZvckVhY2giLCJmb3JFYWNoTm9kZSIsIm5vZGUiLCJwYXJlbnQiLCJjaGlsZHJlbiIsInBhcmVudE5vZGUiLCJjcmVhdGUiLCJweCIsInNpemUiLCJyZWdpc3RlckRCbG9jayIsIkJsb2NrIiwiREJsb2NrIiwiZWxlbXMiLCIkJCIsImZvdW5kIiwicmVnaXN0ZXJERWFjaCIsImNyZWF0ZUJsb2NrIiwiREVhY2giLCJvcHRzIiwiaXRlbSIsIml0ZW1OYW1lIiwiaW5kZXhOYW1lIiwiX3RoaXMiLCJ1aWQiLCJjb25zdHJ1Y3RWYWx1ZXMiLCJ3YXRjaEFyZ3MiLCJwYXJlbnRFbGVtIiwidWlkcyIsInNjb3BlIiwiVUlEIiwiJHVpZHMiLCJuZXdLZXlzIiwibmV3VUlEcyIsImV2YWx1YXRlIiwiaXRlbXMiLCJzcGxpY2UiLCJJdGVtIiwicmVtb3ZlIiwiYWZ0ZXIiLCJibG9jayIsInNoaWZ0IiwicHJldiIsImluc2VydEFmdGVyIiwidmFsdWVzIiwicmVnaXN0ZXJERWxlbWVudHMiLCJERWxlbWVudHMiLCJfdGhpczIiLCJtaXhpbnMiLCJ3YXRjaGVyc1RvUmVtb3ZlIiwiY2hpbGQiLCJtaXhpbiIsImZpbHRlciIsIndhdGNoZXJzIiwid2F0Y2hlciIsImZvckRFbGVtZW50cyIsImluZGV4T2YiLCJuZXdDb250ZW50IiwiYWRkIiwicmVnaXN0ZXJESWYiLCJESWYiLCJjb25kIiwiZXZhbHVhdGVBbmRXYXRjaCIsImlmIiwibmV3VmFsdWUiLCJCb29sZWFuIiwicmVnaXN0ZXJESXRlbSIsIkRJdGVtIiwicmVnaXN0ZXJEU3dpdGNoIiwiRFN3aXRjaCIsIndhc0RlZmF1bHQiLCJ2YWwiLCJlcXVhbHMiLCJyZWdpc3RlckRUZXh0IiwiRFRleHQiLCJyZWdpc3RlckRBdHRyIiwiTWl4aW4iLCJEQXR0ciIsIm9sZFZhbHVlIiwicmVtb3ZlQXR0ciIsInJlZ2lzdGVyREJpbmQiLCJEQmluZCIsIm9mZiIsIm9uIiwicmVnaXN0ZXJEQ2xhc3MiLCJEQ2xhc3MiLCJjbGFzc2VzIiwibmV3Q2xhc3NlcyIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJyZWdpc3RlckRFbGVtIiwiREVsZW0iLCJldmFsdWF0ZU9uY2UiLCJyZWdpc3RlckRIaWRlIiwiREhpZGUiLCJoaWRlIiwic2hvdyIsInJlZ2lzdGVyRE9uIiwiRE9uIiwicmVnaXN0ZXJEU2hvdyIsIkRTaG93IiwicmVnaXN0ZXJEU3R5bGUiLCJEU3R5bGUiLCJyZW1vdmVDU1MiLCJjc3MiLCJyZWdpc3RlckRWYWxpZGF0ZSIsIkRWYWxpZGF0ZSIsInZhbGlkYXRvciIsImxpc3RlbmVyU3dpdGNoZXIiLCJyZWdpc3RlckRWYWx1ZSIsIkRWYWx1ZSIsIl92YWx1ZSIsInR5cGUiLCJpbml0aWFsU2NvcGVWYWx1ZSIsInByb3BTd2l0Y2hlciIsImN1cnJlbnRWYWx1ZSIsInNldFByb3AiLCJpbml0aWFsRWxlbVZhbHVlIiwiZ2V0UHJvcCIsImlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIiwiaXNDaGVja2JveCIsImNoYW5nZVNjb3BlIiwiZSIsIm9wdGlvbiIsInNlbGVjdGVkIiwic2V0VmFsdWVTd2l0Y2hlciIsImluaXQiLCJnZXRWYWx1ZVN3aXRjaGVyIiwiaW5pdEFwcCIsImJsb2NrcyIsImNyZWF0ZUNvbW1lbnQiLCJpbnRvIiwicmVnaXN0ZXJCdWlsdElucyIsInJlZ2lzdGVyIiwiX2h0bWwiLCJkZWVwQ2xvbmVDaGlsZHJlbiIsIl9tYXRjaCIsIlN0ciIsImVzY2FwZVJlZ0V4cCIsInBhcmVudEJsb2NrIiwicGFyZW50U2NvcGUiLCJzdmdOUyIsInN2ZyIsImxvY2FsQmxvY2tzIiwibnMiLCJfYmxvY2tzIiwibG9jYWxNaXhpbnMiLCJfbWl4aW5zIiwiZEJsb2NrTWF0Y2giLCJleHByZXNzaW9uUmVnRXhwIiwiY3VycmVudE1peGlucyIsImxvY2FsTWF0Y2giLCJibG9ja0luc3RhbmNlIiwiZ2xvYmFsIiwiQXJncyIsImxvY2FscyIsImNvbnN0cnVjdFByaXZhdGVTY29wZSIsInNjb3BlVmFsdWVzIiwiREl0ZW1Gb3VuZCIsInByaXZhdGVTY29wZSIsImFmdGVyQ29uc3RydWN0IiwiZXJyIiwiYWZ0ZXJSZW5kZXIiLCJjcmVhdGVNaXhpbiIsImFmdGVyVXBkYXRlIiwibmV3Q2hpbGQiLCJ0cmFuc2Zvcm1ESWZDaGlsZHJlbiIsImlmRWxzZSIsImlzSW5zdGFuY2VPZkJsb2NrIiwiaXNQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImlzSW5zdGFuY2VPZk1peGluIiwicmVtb3ZlV2F0Y2hlcnMiLCJjb25zdHJ1Y3RQdWJsaWNTY29wZSIsImRlZmluZSIsImV2YWxNb2RlIiwiZ2V0dGluZyIsInRlbXAiLCJjaGFuZ2VkIiwib2xkVGVtcFdhdGNoZXJzIiwib25SZW1vdmUiLCJ3YXMiLCJwZXJtIiwicm91bmQiLCJkaWdpdHMiLCJ6ZXJvZXMiLCJ6ZXJvIiwicmVwZWF0Iiwibm93IiwiZGF0ZSIsIkRhdCIsImlzQWJzb2x1dGUiLCJ1cmwiLCJhYnNvbHV0ZVVSTFJlZ2V4cCIsImVuY29kZSIsImlzRW5jb2RlZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZldGNoQmVmb3JlTWlkZGxld2FyZSIsImNvbmZpZyIsImJhc2VVUkwiLCJkYXRhIiwiaGVhZGVycyIsInBhcmFtcyIsInF1ZXJ5IiwiTUVUSE9EIiwidG9VcHBlckNhc2UiLCJjb25zdHJ1Y3RVUkwiLCJ0cmFuc2Zvcm1EYXRhIiwiaGVhZGVyIiwidG9DYXBpdGFsQ2FzZSIsImpvaW4iLCJpbml0Um91dGVyIiwiaW5pdGlhbGl6ZWQiLCJSb3V0ZXMiLCJyZWRpcmVjdFJvdXRlIiwiZGVmYXVsdFJvdXRlIiwiUmVkaXJlY3RSb3V0ZSIsInJvdXRlIiwicGFyZW50TmFtZSIsIlBhcmVudE5hbWUiLCJyb290Um91dGUiLCJhYnN0cmFjdCIsImJhc2VSb3V0ZSIsInBhcmVudFBhcmFtcyIsInBhcmVudFF1ZXJ5IiwicGF0aCIsInJlbGF0aXZlVVJMIiwicmVsYXRpdmVQYXRoIiwiY291bnQiLCJuZXdQYXRoIiwibmV3VVJMIiwidmFsaWRhdGVQYXRoIiwibG9jYXRpb24iLCJocmVmIiwicHVzaGVkIiwiY2xvc2VzdExpbmsiLCJjbG9zZXN0IiwiaGFzQXR0ciIsInByZXZlbnREZWZhdWx0IiwibWFrZVJvdXRlIiwiY2FsbEJlZm9yZUxvYWQiLCJyb3V0ZUxvYWRlZCIsImJlZm9yZUxvYWQiLCJfX3JvdXRlckluc3RhbmNlX18iLCJjdXJyZW50Um91dGVzIiwiaXNDdXJyZW50Um91dGUiLCJjdXJyZW50Um91dGUiLCJiZWZvcmVMb2FkUm91dGUiLCJjYWxsQmVmb3JlTGVhdmUiLCJiZWZvcmVMZWF2ZSIsImJlZm9yZUxlYXZlUm91dGUiLCJyb3V0ZXJPcHRpb25zIiwicm9vdCIsImZhbGxiYWNrVG8iLCJpc0RlZmF1bHQiLCJkZWZhdWx0Iiwid2FybiIsIndhc1Jvb3QiLCJOYW1lIiwiUm91dGUiLCJ1bnN1YnNjcmliZSIsInJvdXRlciIsImVuY29kZVBhcmFtcyIsImVuY29kZVF1ZXJ5IiwiaGFzaCIsIm9yaWdpbiIsImJ1aWxkVVJMIiwiX19pc0N1cnJlbnRSb3V0ZV9fIiwiY3VycmVudFJvdXRlUGFyYW1zIiwic3Vic2NyaWJlIiwiZGVsZXRlIiwiZm9yd2FyZCIsImNoYW5nZVJvdXRlIiwiZmluZFJvdXRlQnlVUkwiLCJob3N0IiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInBvcnQiLCJwcm90b2NvbCIsInNlYXJjaCIsInVybFBhcmFtcyIsInJvdXRlVVJMIiwicmVxdWlyZWRRdWVyeSIsImRlY29kZVBhcmFtcyIsImRlY29kZVF1ZXJ5IiwicmVzb2x2ZWQiLCJyZXNvbHZlVVJMIiwiZXZlbnR1YWxQYXJhbXMiLCJwYXJhbSIsImhhc093biIsImRlY29kZSIsIkRlZmF1bHRSb3V0ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImNoYW5nZUhpc3RvcnkiLCJyZXNvbHZlUGFyYW1ldGVyIiwibmFtZUVycm9yTmFtZSIsInZhbHVlRXJyb3JOYW1lIiwibmFtZU1hdGNoIiwicmVnZXhwIiwid2luZG93IiwiYXBwbGllZFJlZ0V4cHMiLCJpZCIsImNhbnZhc0dldE1ldGhvZHMiLCJjYW52YXNSZXN0TWV0aG9kcyIsImh0bWxFbGVtZW50cyIsInN2Z0VsZW1lbnRzIiwidm9pZEVsZW1lbnRzIiwiaHRtbEFsbG93ZWRUYWdTeW1ib2xzIiwiaHRtbEFsbG93ZWRBdHRyU3ltYm9scyIsInJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzIiwiUmFuZ2VFcnJvciIsInYiLCJtZXRob2RzIiwiVHlwZUVycm9yIiwiYSIsImQiLCJmIiwiciIsInMiLCJTeW1ib2wiLCJjaGFycyIsIndvcmQiLCJ0b2tlbiIsImRlZiIsInJldCIsIkNhc2UiLCJjYXNlIiwiZXZlbnR1YWxDYXNlcyIsInNldFByb3RvdHlwZU9mIiwiRnVuY3Rpb24iLCJkZWVwIiwic3VtIiwiZnVuYyIsImRlc2NyaXB0b3JzIiwicHJvcGVydHkiLCJkZXNjcmlwdG9yIiwicHJvcHMiLCJnZXR0ZXIiLCJpc0Zyb3plbiIsInJlcGxhY2VyIiwic3BhY2UiLCJ1bnNoaWZ0Iiwic3RyaW5naWZ5IiwibWF4Iiwib2JqIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImlzQ29udGV4dE9iamVjdCIsInN0YXJ0S2V5Iiwic2V0dGVyIiwicmVkdWNlIiwic2VjcmV0IiwiaXRlcmF0b3IiLCJQcm9taXNlIiwiZXhlY3V0b3IiLCJyZWplY3QiLCJoaWRkZW5Qcm9taXNlIiwic3RhdHVzIiwib25SZWplY3QiLCJoYW5kbGVkIiwib25VbmhhbmRsZWRSZWplY3Rpb24iLCJvbkVycm9yIiwicmVzb2x2ZSIsInRoZW4iLCJvbkZ1bGZpbGwiLCJoaWRkZW5TdGF0dXMiLCJoaWRkZW5WYWx1ZSIsInJlYWxQcm9taXNlIiwicHJveHkiLCJvblJlamVjdGVkIiwib25GdWxmaWxsZWRPclJlamVjdGVkIiwiaXNGdW5jIiwib25GdWxmaWxsZWQiLCJwcm9taXNlIiwiaGFuZGxlIiwiaGFuZGxlciIsIml0ZXJhYmxlIiwidG9SZXNvbHZlIiwibmV4dCIsImRvbmUiLCJjb25zb2xlIiwiYmluZCIsIkZ1bmMiLCJjYWxsZWQiLCJjYW5CZUNhbGxlZCIsImJlZm9yZSIsInN5bmMiLCJjb250ZXh0TG9ja2VkIiwiY29udGV4dCIsIm1pZGRsZXdhcmUiLCJhZnRlckFsbCIsImJlZm9yZUFsbCIsImJpbmRDb250ZXh0IiwiYmluZEFyZ3MiLCJ0aW1lcyIsImxvY2tDb250ZXh0IiwibG9ja0FyZ3MiLCJhcmdzTG9ja2VkIiwibWFyayIsInRpbWUiLCJ0aW1lRW5kIiwidW5iaW5kQ29udGV4dCIsInVuYmluZEFyZ3MiLCJ0b1JhZGlhbiIsIlBJIiwidG9EZWdyZWUiLCJsbjIiLCJMTjIiLCJsbjEwIiwiTE4xMCIsIk51bSIsInRvRGVncmVlcyIsImFjb3MiLCJhc2luIiwiYXRhbiIsImFzRGVncmVlcyIsImNvcyIsImFib3J0IiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsImFib3J0ZWQiLCJzZXRUaW1lb3V0IiwiaW50ZXJ2YWwiLCJsb2ciLCJwb3dlciIsInBvdyIsInNpbiIsInRhbiIsInJlaiIsImZyYWN0aW9uRGlnaXRzIiwidG9FeHBvbmVudGlhbCIsInRvRml4ZWQiLCJwcmVjaXNpb24iLCJ0b1ByZWNpc2lvbiIsImFicyIsInNxcnQiLCJjYnJ0IiwiY2VpbCIsImV4cCIsImxuIiwic2lnbiIsImtleU9mIiwia2V5T2ZTdHJpY3QiLCJzZXBhcmF0b3IiLCJwb3AiLCJyZXZlcnNlIiwicmFuZG9tSW5kZXgiLCJiZWdpbiIsImNvbXBhcmVGdW5jdGlvbiIsInNvcnQiLCJkZWxldGVDb3VudCIsIlVSTCIsInByb2dyZXNzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInRvUmVqZWN0Iiwib25wcm9ncmVzcyIsIm9uZXJyb3IiLCJvbmxvYWQiLCJhbmNob3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkYXRhVVJMIiwic2V0QXR0cmlidXRlIiwiY2xpY2siLCJjcmVhdGVPYmplY3RVUkwiLCJodG1sU3BlY2lhbHMiLCJyZWdleHBTcGVjaWFsc1JlZ2V4cCIsInNlYXJjaFN0cmluZyIsInBvc2l0aW9uIiwicmV2ZXJ0Iiwic3RhcnRzV2l0aCIsImVzY2FwZWQiLCJzeW1ib2wiLCJzZWFyY2hWYWx1ZSIsImZyb21JbmRleCIsImxhc3RJbmRleE9mIiwic3RyIiwiYmVnaW5TbGljZSIsImVuZFNsaWNlIiwic3Vic3RyIiwiaW5kZXhTdGFydCIsImluZGV4RW5kIiwic3Vic3RyaW5nIiwic3VibWl0U3RyaW5nIiwibm9kZVN3aXRjaGVyIiwiSW50ZXJuYWxQYXJzaW5nRXJyb3IiLCJQYXJzaW5nRXJyb3IiLCJ0aHJvd1VuZXhwZWN0ZWRFcnJvciIsImdsb2JhbEluZGV4IiwiZWxlbWVudHMiLCJldmVudFNlcGFyYXRvciIsInRleHRQcm9wZXJ0eSIsIk5vZGUiLCJwcm9wZXJ0eURlc2NyaXB0b3IiLCJpbnB1dEVsZW1lbnRzIiwieG1sTlMiLCJ4bGlua05TIiwieGh0bWxOUyIsInR5cGVTd2l0Y2hlciIsImRvY3VtZW50RWxlbWVudCIsIm5hbWVzcGFjZVVSSSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRleHROb2RlIiwicmVmU3dpdGNoZXIiLCJmaWx0ZXJTd2l0Y2hlciIsImlzIiwiaW5uZXJTd2l0Y2hlciIsInBhZGRpbmdzIiwiYm9yZGVycyIsIm91dGVyU3dpdGNoZXIiLCJhdHRyTlNTd2l0Y2hlciIsImxpc3QiLCJjbGFzc0xpc3QiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJzdHlsZSIsInNoZWV0IiwiY3NzUnVsZXMiLCJydWxlcyIsInRvSHlwaGVuQ2FzZSIsImluc2VydFJ1bGUiLCJkd2F5bmVEYXRhIiwic3RyaW5ncyIsImFwcGxpZWQiLCJzZXRBcHBsaWVkIiwibnAxIiwiYXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJfdGhpczQiLCJmaXJzdCIsImxvYWQiLCJpc0Jyb2tlbiIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd0ltYWdlIiwiYnl0ZVN0cmluZyIsImF0b2IiLCJhYiIsIkFycmF5QnVmZmVyIiwiaWEiLCJVaW50OEFycmF5IiwiYmx1ciIsInBzZXVkbyIsImdldENvbXB1dGVkU3R5bGUiLCJydWxlIiwiY2hpbGROb2RlcyIsImNsYXNzTmFtZSIsImNsb25lTm9kZSIsImNvbnRhaW5zIiwiYXBwbGllZEV4cHJlc3Npb25zIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiY3NzVGV4dCIsInRvQ2FtZWxDYXNlIiwiY3R4IiwiZGF0YXNldCIsImVuY29kZXJPcHRpb25zIiwidG9EYXRhVVJMIiwiZGVsZXRlUnVsZSIsImV2ZW50IiwiZXZlbnRJbml0IiwiZGV0YWlscyIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZmluYWxFdmVudCIsIkV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZm9jdXMiLCJzZWxlY3RvclRleHQiLCJoYXNBdHRyaWJ1dGUiLCJoYXNBdHRyaWJ1dGVOUyIsImN1cnJlbnREaXNwbGF5IiwicHJldmlvdXNEaXNwbGF5IiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJmaXJzdENoaWxkIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwiY29tcGxldGUiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiaW1hZ2VzIiwiYWxsIiwiJGVsZW0iLCJyZW1vdmVMaXN0ZW5lcnMiLCJwcm9wZXIiLCJicm9rZW4iLCJuZXh0U2libGluZyIsImV2ZW50cyIsImxpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJhbGxMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsImhhcyIsIm5ld0xpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmV2aW91c1NpYmxpbmciLCJsaW5rIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsIjIiLCIxIiwiY3JlYXRlZCIsInR4dCIsIl9hcmd1bWVudHM2IiwiaGFzQ2xhc3MiLCJsZXZlbCIsInZhbGlkYXRvcldyYXAiLCJpbnB1dCIsImVycm9ycyIsInZhbGlkaXR5IiwidmFsaWQiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsInZhbGlkYXRvcnMiLCJmb3JtRXJyb3JzIiwiZm9ybSIsImlucHV0cyIsImRpc3BhdGNoIiwiaW5wdXRFcnJvciIsImV2ZXJ5IiwiaW5uZXJIZWlnaHQiLCJjYWxjQ1NTIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJveFNpemluZyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiaW5uZXJXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIm91dGVySGVpZ2h0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwib3V0ZXJXaWR0aCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIndpbiIsImJvZHkiLCJoZWFkIiwiaW5wdXRWYWx1ZSIsInJvb3RCbG9ja3MiLCJyb290TWl4aW5zIiwiYXR0ck5hbWUiLCJvbkV2YWxFcnJvciIsImV4cHJlc3Npb24iLCJvcmlnaW5hbEFyZ3MiLCJvbkNoYW5nZSIsImluc3RhbmNlIiwiZm9yREl0ZW0iLCJmb3JERWFjaCIsImV4cHIiLCJEd2F5bmVTdG9yZSIsInN0b3JlIiwibG9jYWxXYXRjaGVycyIsIm5ld1Jlc3VsdCIsIndhdGNoZXJCbG9jayIsImluZGV4MSIsImluZGV4MiIsImFyZyIsIkR3YXluZUJsb2NrIiwiU3ViY2xhc3MiLCJpc1BhcmVudFNpZ25hbCIsImJlZm9yZVJlbW92ZSIsInZhcmlhYmxlIiwiX3RoaXM1IiwiX3RoaXM2IiwibG9jYWwiLCJfdGhpczciLCJCbG9ja3MiLCJNaXhpbnMiLCJkYXlzT2ZUaGVXZWVrTmFtZXMiLCJkYXlzT2ZUaGVXZWVrQWxpYXNlcyIsIm1vbnRoc05hbWVzIiwibW9udGhzQWxpYXNlcyIsInV0YyIsImNvZWZmcyIsImdldFN3aXRjaGVyIiwic2V0U3dpdGNoZXIiLCJ3aGF0IiwicHJlZml4IiwiZm9ybWF0cyIsImZvcm1hdCIsInJlcGxhY2VTdHJpbmciLCJkYXRlMSIsImRhdGUyIiwiaXNCZWZvcmUiLCJzdGFydGVkIiwiY29lZmYiLCJ3Iiwic2V0VGltZSIsInRvSVNPU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJ2YWx1ZU9mIiwicXVlcnlTd2l0Y2hlciIsInF1ZXJ5UGFyYW1zIiwiZW5jb2RlT3B0aW9ucyIsInJhd0hlYWRlcnMiLCJub3RUb1RyYW5zZm9ybSIsIndpdGhvdXRCb2R5IiwiaW5kZXhPZlN0cmljdCIsImNvbnRlbnRUeXBlIiwiZGVmYXVsdHMiLCJ1cGxvYWRNZXRob2RzIiwiRmV0Y2giLCJmZXRjaCIsInJlcXVlc3QiLCJjb25mIiwidG9QdXNoIiwiZGF0YUNvbmZpZyIsInVybENvbmZpZyIsInhociIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicmVzcG9uc2VUeXBlIiwid2l0aENyZWRlbnRpYWxzIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsInVwbG9hZCIsIm9uYWJvcnQiLCJvbnRpbWVvdXQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJwYXJzZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzdGF0dXNUZXh0IiwiY2F0Y2giLCJzZW5kIiwicmF3UGFyYW0iLCJwYXJhbU5hbWUiLCJwYXJhbU9iamVjdCIsInN1YnNjcmliZXJzIiwiaGlzdG9yeSIsInBhdGhTd2l0Y2hlciIsInBhcnQiLCJzdGF0aWNzIl0sIm1hcHBpbmdzIjoid0JBWUEsU0FBZ0JBLEdBQVlDLFlBQ2hCQyxTQUFTQyxLQUFLRixHQUFRRyxRQUFRLGlCQUFrQixJQ081RCxRQUFnQkMsR0FBUUMsU0FDUSxVQUF2Qk4sRUFBWU0sR0Fn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QVNBLGVBR1dDLElBUVgsTUFTQSxRQVNBLFlBU0EsZ0JBU0EsWUFTQSxPQVNBLFlBU0Esb0JBU0EsWUFTQSxVQVNBLE9BU0EsV0FTQSxXQVNBLFNBU0EsU0FTQSxlQVNBLG1CQVNBLE9BU0EsaUJBU0EsVUFTQSxTQVNBLE9BU0EsUUFTQSxjQVNBLGVBU0EsU0FTQSxhQVNBLGFBU0EsWUFTQSxhQ2hXV2plLGNDQUFrZSxJQU9YLElBUUEsT0FRQSxVQVFBLE9BUUEsVUFRQSxRQVFBLElBUUEsT0FRQSxNQVFBLE1BUUEsYUFRQSxPQVFBLEtBUUEsU0FRQSxTQVFBLFVBUUEsT0FRQSxPQVFBLE1BUUEsV0FRQSxVQVFBLFdBUUEsS0FRQSxNQVFBLFVBUUEsTUFRQSxTQVFBLE1BUUEsS0FRQSxLQVFBLFVBUUEsS0FRQSxRQVFBLFdBUUEsYUFRQSxTQVFBLFNBUUEsT0FRQSxLQVFBLEtBUUEsS0FRQSxLQVFBLEtBUUEsS0FRQSxPQVFBLFNBUUEsU0FRQSxLQVFBLElBUUEsU0FRQSxNQVFBLFFBUUEsTUFRQSxNQVFBLFFBUUEsU0FRQSxLQVFBLE9BUUEsT0FRQSxPQVFBLE9BUUEsV0FRQSxPQVFBLFFBUUEsTUFRQSxXQVFBLEtBUUEsV0FRQSxTQVFBLFNBUUEsSUFRQSxRQVFBLE1BUUEsV0FRQSxJQVFBLEtBUUEsS0FRQSxNQVFBLE9BUUEsSUFRQSxPQVFBLFNBUUEsVUFRQSxTQVFBLFNBUUEsUUFRQSxTQVFBLE9BUUEsU0FRQSxRQVFBLE1BUUEsVUFRQSxNQVFBLFFBUUEsUUFRQSxLQVFBLFdBUUEsV0FRQSxRQVFBLEtBUUEsUUFRQSxPQVFBLFFBUUEsS0FRQSxRQVFBLElBUUEsS0FRQSxNQVFBLFFBUUEsT0FHV0MsSUFPWCxXQVFBLGNBUUEsZUFRQSxVQVFBLGVBUUEsZ0JBUUEsbUJBUUEsU0FRQSxXQVFBLGdCQVFBLFNBUUEsT0FRQSxPQVFBLFVBUUEsVUFRQSxVQVFBLGdCQVFBLHNCQVFBLGNBUUEsbUJBUUEsb0JBUUEsb0JBUUEsaUJBUUEsZUFRQSxVQVFBLFVBUUEsVUFRQSxVQVFBLFVBUUEsaUJBUUEs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"}