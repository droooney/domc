{"version":3,"file":"dwayne.min.js","sources":["../src/utils/array.js","../src/utils/object.js","../src/utils/defineProperty.js","../src/utils/toStringTag.js","../src/utils/is.js","../src/utils/escapeRegex.js","../src/utils/noop.js","../src/utils/toCase.js","../src/helpers/Elem/addAttr.js","../src/helpers/Elem/addCSSProp.js","../src/helpers/Elem/addDataAttr.js","../src/helpers/Elem/addNext.js","../src/helpers/Elem/addParent.js","../src/helpers/Elem/addPrev.js","../src/helpers/Elem/createHideStyleNode.js","../src/helpers/Elem/getAttrNS.js","../src/helpers/Elem/is.js","../src/helpers/Elem/getEvent.js","../src/helpers/Elem/hide.js","../src/helpers/Elem/matches.js","../src/helpers/Elem/remove.js","../src/helpers/Elem/show.js","../src/helpers/Elem/toElem.js","../src/find.js","../src/helpers/Block/calculateArgs.js","../src/helpers/Block/cleanProperty.js","../src/helpers/Block/constructMixinRegex.js","../src/helpers/Block/mixinMatch.js","../src/helpers/Block/transformRestAttrs.js","../src/helpers/Block/executeMixinWatchers.js","../src/helpers/Block/createMixin.js","../src/helpers/Block/calculateAttrs.js","../src/helpers/Block/constructPrivateScope.js","../src/helpers/Block/removeWatcher.js","../src/helpers/Block/constructPublicScope.js","../src/helpers/Block/createBlock.js","../src/helpers/Block/isInstanceOf.js","../src/helpers/Block/remove.js","../src/helpers/Block/wrap.js","../src/mixins/d-style.js","../src/mixins/d-value.js","../src/insertTemplates.js","../src/initApp.js","../src/removeApp.js","../src/global.js","../src/utils/objectStatics.js","../src/constants.js","../src/Elem.js","../src/utils/setSymbolSpecies.js","../src/Mixin.js","../src/Block.js","../src/blocks/d-block.js","../src/blocks/d-item.js","../src/blocks/d-each.js","../src/blocks/d-elements.js","../src/blocks/d-if.js","../src/blocks/d-switch.js","../src/mixins/d-attr.js","../src/mixins/d-bind.js","../src/mixins/d-class.js","../src/mixins/d-elem.js","../src/mixins/d-hide.js","../src/mixins/d-node.js","../src/mixins/d-on.js","../src/mixins/d-show.js","../src/helpers/Block/registerBuiltins.js","../src/elems.js"],"sourcesContent":["export function collectFromArray(array, callback, initialValue = {}) {\n  iterateArray(array, (value, index) => {\n    callback(initialValue, value, index, array);\n  });\n\n  return initialValue;\n}\n\nexport function findInArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    const value = array[i];\n\n    if (callback(value, i, array)) {\n      return {\n        key: i,\n        value\n      };\n    }\n  }\n}\n\nexport function iterateArray(array, callback) {\n  for (let i = 0, length = array.length; i < length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\nexport function removeArrayElem(array, elem) {\n  const index = array.indexOf(elem);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nexport function toObjectKeys(array) {\n  return collectFromArray(array, addKey);\n}\n\nfunction addKey(vars, variable) {\n  vars[variable] = true;\n}\n","import { iterateArray } from './array';\n\nconst {\n  hasOwnProperty: has\n} = {};\nconst { slice } = [];\n\nexport function assign(target) {\n  iterateArray(arguments, (source, index) => {\n    if (index) {\n      iterateObject(source, (value, key) => {\n        target[key] = value;\n      });\n    }\n  });\n\n  return target;\n}\n\nexport function collectFromObject(object, callback, initialValue = {}) {\n  iterateObject(object, (value, key) => {\n    callback(initialValue, value, key, object);\n  });\n\n  return initialValue;\n}\n\nexport function except(object) {\n  const newObject = {};\n  const paths = arguments::slice(1);\n\n  iterateObject(object, (value, key) => {\n    if (paths.indexOf(key) === -1) {\n      newObject[key] = value;\n    }\n  });\n\n  return newObject;\n}\n\nexport function hasOwnProperty(object, key) {\n  return object::has(key);\n}\n\nexport function iterateObject(object, callback) {\n  for (const key in object) {\n    if (hasOwnProperty(object, key)) {\n      callback(object[key], key, object);\n    }\n  }\n}\n\nexport function mapObject(object, callback) {\n  const newObject = {};\n\n  iterateObject(object, (value, key) => {\n    newObject[key] = callback(value, key, object);\n  });\n\n  return newObject;\n}\n","import { iterateObject } from './object';\n\n/**\n * @function defineProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining properties of an object.\n */\nexport const { defineProperties } = Object;\n\nexport function definePrototypeProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n  });\n}\n\n/**\n * @function defineFrozenProperties\n * @param {Object} target - Target to define properties for.\n * @param {Object} properties - Object with properties needed to be assign to the target.\n * @returns {void}\n * @description Function for defining frozen properties of an object.\n */\nexport function defineFrozenProperties(target, properties) {\n  iterateObject(properties, (value, name) => {\n    Object.defineProperty(target, name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  });\n}\n","import { definePrototypeProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nconst { toString } = {};\n\n/**\n * @function toStringTag\n * @param {*} object - Object to get toStringTag of.\n * @returns {String} Cut string.\n * @description Cut \"Type\" string from \"[object Type]\" string that gotten from {}.toString,call(object).\n */\nexport function toStringTag(object) {\n  return object::toString().slice(8, -1);\n}\n\nexport function setToStringTag(klass, tag) {\n  if (Symbol.toStringTag) {\n    definePrototypeProperties(klass.prototype, {\n      [Symbol.toStringTag]: tag\n    });\n  }\n}\n","/**\n * @module helpers/checkTypes\n * @private\n * @mixin\n * @description Exports is<Type> methods.\n */\n\nimport { toStringTag } from './toStringTag';\n\n/**\n * @function isArray\n * @public\n * @param {*} value - Value to check if it is an array.\n * @returns {Boolean} If the argument is an array or not.\n * \n * @example\n * isArray([]);                             // true\n * isArray(0);                              // true\n * isArray(document.querySelectorAll('*')); // false\n */\nexport const { isArray } = Array;\n\n/**\n * @function isFunction\n * @public\n * @param {*} value - Value to check if it is a function.\n * @returns {Boolean} If the argument is a function or not.\n * \n * @example\n * isFunction(() => {});            // true\n * \n * const func = () => {};\n * Object.setPrototypeOf(func, {});\n * isFunction(func);                // true\n */\nexport function isFunction(value) {\n  return toStringTag(value) === 'Function' || typeof value === 'function';\n}\n\n/**\n * @function isNil\n * @public\n * @param {*} value - Value to check if it is null or undefined.\n * @returns {Boolean} If the argument is null or undefined or not.\n *\n * @example\n * isNil(null);      // true\n * isNil(undefined); // true\n * isNil(false);     // false\n */\nexport function isNil(value) {\n  /* eslint eqeqeq: 0 */\n  return value == null;\n}\n\n/**\n * @function isString\n * @public\n * @param {*} value - Value to check if it is a string.\n * @returns {Boolean} If the argument is a string or not.\n *\n * @example\n * isString('0');             // true\n * isString(new String('0')); // true\n */\nexport function isString(value) {\n  return toStringTag(value) === 'String';\n}\n","const regexpSpecialCharacters = [\n  '.',\n  '+', '*', '?',\n  '(', ')',\n  '[', ']',\n  '{', '}',\n  '<', '>',\n  '^', '$',\n  '!',\n  '=',\n  ':',\n  '-',\n  '|',\n  ',',\n  '\\\\'\n];\nconst regexpSpecialsRegexp = new RegExp(\n  regexpSpecialCharacters\n    .map((s) => `\\\\${ s }`)\n    .join('|'),\n  'g'\n);\n\nexport function escapeRegex(string) {\n  return string.replace(regexpSpecialsRegexp, '\\\\$&');\n}\n","export function noop() {}\n","const DASHED_SYMBOL_REGEX = /-[a-z]/g;\nconst UPPERCASED_SYMBOL_REGEX = /[A-Z]/g;\n\nexport function toCamelCase(value) {\n  return value.replace(DASHED_SYMBOL_REGEX, capitalize);\n}\n\nexport function toHyphenCase(value) {\n  return value.replace(UPPERCASED_SYMBOL_REGEX, hyphenize);\n}\n\nfunction capitalize(match) {\n  return match[1].toUpperCase();\n}\n\nfunction hyphenize(match) {\n  return `-${ match[0].toLowerCase() }`;\n}\n","export function addAttr(attrs, attr) {\n  attrs[attr.name] = attr.value;\n}\n","import { toCamelCase } from '../../utils';\n\nconst CSS_PROP_VALUE_SEPARATOR_REGEX = /: /;\n\nexport function addCSSProp(css, value) {\n  if (value) {\n    const property = value.split(CSS_PROP_VALUE_SEPARATOR_REGEX);\n\n    css[toCamelCase(property[0])] = property[1];\n  }\n}\n","export function addDataAttr(data, value, key) {\n  data[key] = value;\n}\n","export function addNext(add, elem) {\n  add(elem.nextSibling);\n}\n","export function addParent(add, elem) {\n  add(elem.parentNode);\n}\n","export function addPrev(add, elem) {\n  add(elem.previousSibling);\n}\n","import { HIDE_CLASS } from '../../constants';\n\nexport function createHideStyleNode(head) {\n  const style = head.find(`style#${ HIDE_CLASS }`);\n\n  if (style.length) {\n    return;\n  }\n\n  head\n    .create('style')\n    .prop('id', HIDE_CLASS)\n    .text(`.${ HIDE_CLASS }{display:none !important;}`);\n}\n","import { Elem } from '../../Elem';\n\nconst X_LINK_ATTR_FIND_REGEX = /^xlink:\\w/;\nconst X_LINK_ATTR_REPLACE_REGEX = /^xlink:/;\nconst XML_NS = 'http://www.w3.org/2000/xmlns/';\nconst X_LINK_NS = 'http://www.w3.org/1999/xlink';\nconst Null = {\n  ns: null\n};\n\nexport function getAttrNS(attr, elem) {\n  const isXmlNs = attr === 'xmlns';\n\n  if (isXmlNs || attr === 'xmlns:xlink') {\n    if (elem.nodeName !== 'SVG') {\n      return Null;\n    }\n\n    return {\n      ns: XML_NS,\n      name: isXmlNs\n        ? 'xmlns'\n        : 'xlink'\n    };\n  }\n\n  if (X_LINK_ATTR_FIND_REGEX.test(attr)) {\n    if (!new Elem(elem).closest('svg').length) {\n      return Null;\n    }\n\n    return {\n      ns: X_LINK_NS,\n      name: attr.replace(X_LINK_ATTR_REPLACE_REGEX, '')\n    };\n  }\n\n  return Null;\n}\n","import { toStringTag, isArray } from '../../utils';\nimport { Elem } from '../../Elem';\n\nconst HTML_COLLECTION_REGEX = /^(HTMLCollection|NodeList)$/;\nconst DOCUMENT_REGEX = /Document$/;\nconst ELEMENT_REGEX = /Element$/;\n\nexport function isDocument(value) {\n  return DOCUMENT_REGEX.test(toStringTag(value));\n}\n\nexport function isElem(value) {\n  return value instanceof Elem;\n}\n\nexport function isElementsCollection(value) {\n  return (\n    HTML_COLLECTION_REGEX.test(toStringTag(value))\n    || isElem(value)\n    || isArray(value)\n  );\n}\n\nexport function isValidNode(value) {\n  const tag = toStringTag(value);\n\n  return (\n    ELEMENT_REGEX.test(tag)\n    || DOCUMENT_REGEX.test(tag)\n    || tag === 'Text'\n    || tag === 'DocumentFragment'\n    || tag === 'Comment'\n  );\n}\n","import { assign, toStringTag } from '../../utils';\nimport { isDocument } from './is';\n\nconst EVENT_REGEX = /Event$/;\n\nexport function getEvent(event, bubbles, cancelable, realDetails, elem) {\n  let finalEvent = event;\n\n  if (!EVENT_REGEX.test(toStringTag(finalEvent))) {\n    try {\n      finalEvent = new Event(finalEvent, { bubbles, cancelable });\n      assign(finalEvent, realDetails);\n    } catch (err) {\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      finalEvent = document.createEvent('Event');\n      finalEvent.initEvent(event, bubbles, cancelable);\n\n      assign(finalEvent, realDetails);\n    }\n  }\n\n  return finalEvent;\n}\n","import { createHideStyleNode } from './createHideStyleNode';\nimport { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function hide(elem) {\n  createHideStyleNode(new Elem(elem.ownerDocument.head));\n  new Elem(elem).addClass(HIDE_CLASS);\n}\n","import { isDocument } from './is';\n\nconst { indexOf } = [];\n\nexport function getMatchesFunction(elem) {\n  return (\n    elem.matches\n    || elem.matchesSelector\n    || elem.webkitMatchesSelector\n    || elem.mozMatchesSelector\n    || elem.msMatchesSelector\n    || elem.oMatchesSelector\n    || matches\n  );\n}\n\nfunction matches(selector) {\n  const document = isDocument(this)\n    ? this\n    : this.ownerDocument;\n\n  return document.querySelectorAll(selector)::indexOf(this) !== -1;\n}\n","export function remove(elem) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    parent.removeChild(elem);\n  }\n}\n","import { HIDE_CLASS } from '../../constants';\nimport { Elem } from '../../Elem';\n\nexport function show(elem) {\n  new Elem(elem).removeClass(HIDE_CLASS);\n}\n","import { isElem } from './is';\nimport { Elem } from '../../Elem';\n\nexport function toElem(elem) {\n  return isElem(elem)\n    ? elem\n    : new Elem(elem);\n}\n","import { Elem } from './Elem';\nimport { document } from './constants';\n\n/**\n * @function find\n * @public\n * @param {String} selector - Selector to find.\n * @param {Element|Node} [base = document] - Base to find in.\n * @returns {Elem} New instance of Elem.\n * @description Synonym for\n * [Document#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Document/querySelectorAll}.\n */\nexport function find(selector, base = document) {\n  return new Elem(base.querySelectorAll(String(selector)));\n}\n","import { iterateArray, keys } from '../../utils';\n\nexport function calculateArgs(args, argsObject) {\n  iterateArray(keys(argsObject), (arg) => {\n    if (!(arg in args)) {\n      argsObject[arg] = undefined;\n    }\n  });\n\n  /* eslint guard-for-in: 0 */\n  for (const arg in args) {\n    argsObject[arg] = args[arg];\n  }\n}\n","export function cleanProperty(value, arg, object) {\n  delete object[arg];\n}\n","import { escapeRegex } from '../../utils';\n\nexport function constructMixinRegex(name) {\n  return new RegExp(`^${ escapeRegex(name) }(?:\\\\(([^\\\\)]*)\\\\))?(?:#([\\\\s\\\\S]*))?$`);\n}\n","const COMMA_REGEX = /,/;\n\nexport function mixinMatch(mixins, attr) {\n  let match;\n\n  /* eslint guard-for-in: 0 */\n  for (const name in mixins) {\n    const Mixin = mixins[name];\n    const localMatch = attr.match(Mixin._match);\n\n    if (localMatch) {\n      const argsMatch = localMatch[1];\n      let args;\n\n      if (argsMatch === '') {\n        args = [];\n      } else if (argsMatch) {\n        args = argsMatch.split(COMMA_REGEX);\n      }\n\n      match = {\n        args,\n        comment: localMatch[2],\n        Mixin,\n        name\n      };\n\n      break;\n    }\n  }\n\n  return match;\n}\n","import { collectFromObject, assign } from '../../utils';\nimport { D_REST_REGEX } from '../../constants';\nimport { mixinMatch } from './mixinMatch';\n\nexport function transformRestAttrs(attrs, mixins, mixinDefaultOpts) {\n  return collectFromObject(attrs, (eventualAttrs, value, attr) => {\n    if (D_REST_REGEX.test(attr)) {\n      return assign(eventualAttrs, transformRestAttrs(value, mixins, mixinDefaultOpts));\n    }\n\n    const match = mixinMatch(mixins, attr);\n\n    if (match) {\n      eventualAttrs[attr] = {\n        type: 'mixin',\n        dynamic: true,\n        opts: {\n          value,\n          ...match,\n          ...mixinDefaultOpts\n        },\n        value\n      };\n\n      return;\n    }\n\n    eventualAttrs[attr] = {\n      type: 'attr',\n      value\n    };\n  });\n}\n\nexport function transformRestArgs(args) {\n  return collectFromObject(args, addArgs);\n}\n\nfunction addArgs(args, value, arg) {\n  if (D_REST_REGEX.test(arg)) {\n    assign(args, transformRestArgs(value));\n  } else {\n    args[arg] = value;\n  }\n}\n","import { iterateArray } from '../../utils';\n\nexport function executeMixinWatchers(mixin, value) {\n  const oldValue = mixin.$$.value;\n\n  mixin.$$.value = value;\n\n  iterateArray(mixin.$$.watchers, (watcher) => {\n    watcher(value, oldValue);\n  });\n}\n","export function createMixin({\n  name, Mixin, dynamic,\n  value, args, comment, elem,\n  parentBlock, parentScope, parentTemplate\n}) {\n  const mixin = new Mixin({\n    name,\n    value,\n    dynamic,\n    args,\n    comment,\n    elem,\n    parentBlock,\n    parentScope,\n    parentTemplate\n  });\n\n  if (Mixin.evaluate) {\n    const value = mixin.value = mixin.evaluate((newValue, oldValue) => {\n      mixin.value = newValue;\n\n      try {\n        mixin.afterUpdate(newValue, oldValue);\n      } catch (err) {\n        console.error(`Uncaught error in ${ name }#afterUpdate:`, err);\n      }\n    });\n\n    mixin.afterUpdate(value);\n  }\n\n  return mixin;\n}\n","import { iterateObject, iterateArray } from '../../utils';\nimport { executeMixinWatchers } from './executeMixinWatchers';\nimport { createMixin } from './createMixin';\n\nexport function calculateAttrs(attrs, attrsObject, elem, firstTime) {\n  iterateObject(attrsObject, ({ type, value }, attr) => {\n    if (!attrs[attr]) {\n      if (type === 'attr') {\n        elem.removeAttr(attr);\n      } else {\n        value.$$.remove();\n      }\n\n      delete attrsObject[attr];\n    }\n  });\n\n  const mixins = [];\n\n  /* eslint guard-for-in: 0 */\n  for (const attr in attrs) {\n    const {\n      type,\n      dynamic,\n      value,\n      opts\n    } = attrs[attr];\n    let nextType;\n    let nextDynamic;\n    let nextValue;\n\n    if (attrsObject[attr]) {\n      const {\n        type: prevType,\n        value: prevValue\n      } = attrsObject[attr];\n\n      if (type === 'attr') {\n        if (prevType === 'mixin') {\n          prevValue.$$.remove();\n        }\n\n        if (prevValue !== value) {\n          elem.attr(attr, value);\n        }\n\n        nextValue = value;\n      } else {\n        const mixin = prevValue;\n\n        if (prevType === 'attr') {\n          elem.removeAttr(attr);\n        }\n\n        mixin.$$.isDynamic = dynamic;\n\n        if (dynamic) {\n          executeMixinWatchers(mixin, value);\n        } else if (!mixin.$$.evaluated && opts.Mixin.evaluate) {\n          const newValue = mixin.$$.parentScope.$$.evaluate(value, (newValue) => {\n            const {\n              type,\n              dynamic\n            } = attrs[attr];\n\n            if (type === 'mixin' && !dynamic) {\n              executeMixinWatchers(mixin, newValue);\n            }\n          }, mixin);\n\n          mixin.$$.evaluated = true;\n\n          executeMixinWatchers(mixin, newValue);\n        }\n\n        nextValue = mixin;\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    } else {\n      if (type === 'attr') {\n        elem.attr(attr, value);\n\n        nextValue = value;\n      } else {\n        const buildMixin = () => {\n          opts.dynamic = dynamic;\n\n          const mixin = createMixin(opts);\n\n          if (!dynamic && opts.Mixin.evaluate) {\n            const {\n              parentScope,\n              value\n            } = opts;\n            const firstValue = parentScope.$$.evaluate(value, (newValue) => {\n              const {\n                type,\n                dynamic\n              } = attrs[attr];\n\n              if (type === 'mixin' && !dynamic) {\n                executeMixinWatchers(mixin, newValue);\n              }\n            }, mixin);\n\n            mixin.$$.evaluated = true;\n            mixin.$$.value = firstValue;\n          }\n\n          nextValue = mixin;\n\n          return {\n            attr,\n            opts: {\n              type,\n              dynamic,\n              value: mixin\n            }\n          };\n        };\n\n        if (firstTime) {\n          mixins.push(buildMixin);\n        } else {\n          buildMixin();\n        }\n      }\n\n      nextType = type;\n      nextDynamic = dynamic;\n    }\n\n    attrsObject[attr] = {\n      type: nextType,\n      dynamic: nextDynamic,\n      value: nextValue\n    };\n  }\n\n  if (firstTime) {\n    return () => {\n      iterateArray(mixins, (buildMixin) => {\n        const {\n          attr,\n          opts\n        } = buildMixin();\n\n        attrsObject[attr] = opts;\n      });\n    };\n  }\n}\n","import { create, collectFromObject } from '../../utils';\n\nexport function constructPrivateScope(object, type, parentScope) {\n  let scope = {};\n\n  if (type === 'globals') {\n    scope = create(\n      parentScope\n        ? parentScope.$$.globals\n        : null\n    );\n  }\n\n  return collectFromObject(object, (scope, value, key) => {\n    scope[key] = {\n      value,\n      watchers: []\n    };\n  }, scope);\n}\n","import { removeArrayElem, iterateArray } from '../../utils';\n\nexport function removeTempWatcher(watcher) {\n  watcher();\n}\n\nexport function removeWatchers(watchersToRemove) {\n  iterateArray(watchersToRemove, removeWatcher);\n}\n\nfunction removeWatcher({ watcher, watchers }) {\n  removeArrayElem(watchers, watcher);\n}\n","import { defineProperties, mapObject, iterateArray } from '../../utils';\nimport { gettingVars, evalMode } from '../../Block';\nimport { removeTempWatcher } from './removeWatcher';\n\nexport function constructPublicScope(scope, scopeValues, privateScope) {\n  defineProperties(scope, mapObject(scopeValues, (value, key) => {\n    const scope = privateScope[key];\n\n    return {\n      configurable: false,\n      enumerable: true,\n      get() {\n        if (evalMode) {\n          if (gettingVars.indexOf(scope.watchers) === -1) {\n            gettingVars.push(scope.watchers);\n          }\n        }\n\n        return scope.value;\n      },\n      set(value) {\n        if (value === scope.value) {\n          return;\n        }\n\n        const oldTempWatchers = scope.watchers.slice();\n\n        scope.watchers = [];\n        scope.value = value;\n\n        iterateArray(oldTempWatchers, removeTempWatcher);\n      }\n    };\n  }));\n}\n","import {\n  except, create, assign,\n  iterateObject, iterateArray,\n  isNil\n} from '../../utils';\nimport { Elem } from '../../Elem';\nimport {\n  SVG_NS, D_REST_REGEX\n} from '../../constants';\nimport { cleanProperty } from './cleanProperty';\nimport { transformRestAttrs } from './transformRestAttrs';\nimport { calculateAttrs } from './calculateAttrs';\nimport { mixinMatch } from './mixinMatch';\nimport { constructPrivateScope } from './constructPrivateScope';\nimport { constructPublicScope } from './constructPublicScope';\nimport { Block } from '../../Block';\n\nconst NAMED_D_BLOCK_REGEX = /^d-block:([\\s\\S]+)$/;\n\nexport function createBlock({ node, parent, parentElem, parentBlock, parentScope, parentTemplate, prevBlock }) {\n  const doc = new Elem(parentElem[0].ownerDocument);\n  const elem = parentElem[0].namespaceURI === SVG_NS\n    ? doc.create('svg')\n    : doc;\n  const localBlocks = parentTemplate ? parentTemplate.$$.ns._blocks : Block._blocks;\n  const localMixins = parentTemplate ? parentTemplate.$$.ns._mixins : Block._mixins;\n  const { children } = node;\n  const args = node.attrs || {};\n  const name = node.name || 'UnknownBlock';\n  let constructor = node.Constructor || (node.name && localBlocks[node.name]);\n  let dBlockMatch;\n  let dBlockName;\n  let dBlockArgs;\n\n  if (name === 'd-block' && args.name) {\n    dBlockArgs = except(args, 'name');\n  } else if (name === 'd-block' && args.Constructor) {\n    dBlockArgs = except(args, 'Constructor');\n  } else if ((dBlockMatch = name.match(NAMED_D_BLOCK_REGEX)) || name === 'd-block') {\n    constructor = Block._blocks['d-block'];\n    dBlockName = dBlockMatch ? dBlockMatch[1] : null;\n  }\n\n  let blockInstance;\n\n  if (constructor) {\n    try {\n      blockInstance = new constructor({\n        name,\n        args,\n        dBlockName,\n        dBlockArgs,\n        children,\n        parent,\n        parentElem,\n        parentBlock,\n        parentScope,\n        parentTemplate,\n        prevBlock\n      });\n    } catch (err) {\n      console.error(`Uncaught error in new ${ name }:`, err);\n      constructor = null;\n    }\n  }\n\n  if (!constructor) {\n    const {\n      value,\n      children\n    } = node;\n\n    const element = elem.create(name);\n    const currentAttrs = create(null);\n    let attrs = create(null);\n    let wasDRest;\n    const mixinDefaultOpts = {\n      elem: element,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    };\n\n    iterateObject(args, (value, attr) => {\n      const isDRest = D_REST_REGEX.test(attr);\n      const localAttrs = isDRest || wasDRest\n        ? create(attrs)\n        : attrs;\n\n      attrs = localAttrs;\n\n      if (isDRest) {\n        const restAttrs = parentScope.$$.evaluate(value, (value) => {\n          setTimeout(() => {\n            iterateObject(localAttrs, cleanProperty);\n            assign(localAttrs, transformRestAttrs(\n              value, localMixins, mixinDefaultOpts\n            ));\n            calculateAttrs(attrs, currentAttrs, element, false);\n          }, 0);\n        }, parentBlock);\n\n        wasDRest = true;\n\n        return assign(localAttrs, transformRestAttrs(\n          restAttrs, localMixins, mixinDefaultOpts\n        ));\n      }\n\n      const match = mixinMatch(localMixins, attr);\n\n      wasDRest = false;\n\n      if (match) {\n        localAttrs[attr] = {\n          type: 'mixin',\n          dynamic: false,\n          opts: {\n            value,\n            ...match,\n            ...mixinDefaultOpts\n          },\n          value\n        };\n\n        return;\n      }\n\n      localAttrs[attr] = {\n        type: 'attr',\n        value: parentScope.$$.evaluate(value, (value) => {\n          localAttrs[attr] = {\n            type: 'attr',\n            value\n          };\n          calculateAttrs(attrs, currentAttrs, element, false);\n        }, parentBlock)\n      };\n    });\n\n    const createMixins = calculateAttrs(attrs, currentAttrs, element, true);\n\n    if (name === '#comment') {\n      element.text(value);\n    }\n\n    if (name === '#text') {\n      let text = parentScope.$$.evaluate(value, (value) => {\n        if (isNil(value)) {\n          value = '';\n        }\n\n        element.text(`${ value }`);\n      }, parentBlock);\n\n      if (isNil(text)) {\n        text = '';\n      }\n\n      element.text(`${ text }`);\n    }\n\n    if (children) {\n      let prevBlock;\n      let parentElem = element;\n\n      if (name === 'template') {\n        parentElem = new Elem(element[0].content);\n      } else if (name === 'iframe') {\n        if (!('src' in attrs)) {\n          const document = element[0].contentDocument;\n\n          new Elem(document.documentElement).remove();\n\n          parentElem = new Elem(document);\n        }\n      }\n\n      iterateArray(children, (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: parentElem,\n          parentElem,\n          parentBlock,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }\n\n    const isParentBlock = parent instanceof Block;\n\n    if (prevBlock instanceof Block) {\n      prevBlock.$$.insertAfterIt(element, false);\n    } else if (prevBlock) {\n      element.insertAfter(prevBlock);\n\n      if (isParentBlock) {\n        parent.$$.addContent(element);\n      }\n    } else if (isParentBlock) {\n      parent.$$.insertInStartOfIt(element, false);\n    } else {\n      element.into(parentElem, false);\n    }\n\n    createMixins();\n\n    return element;\n  }\n\n  const {\n    $$,\n    args: Args,\n    globals,\n    ...locals\n  } = blockInstance;\n\n  const html = name === 'd-elements'\n    ? Args.value || []\n    : constructor.template.value;\n\n  $$.args = constructPrivateScope(Args);\n  $$.locals = constructPrivateScope(locals);\n  $$.globals = constructPrivateScope(globals, 'globals', parentScope);\n\n  if (name === '#d-item') {\n    const scopeValues = {\n      [node.itemName]: node.item,\n      [node.indexName]: node.index\n    };\n    const scope = parentScope.$$.name === '#d-item'\n      ? parentScope.$$.scope\n      : parentScope;\n\n    $$.ns = parentScope.$$.ns;\n    $$.privateScope = constructPrivateScope(scopeValues);\n    constructPublicScope($$.scope = create(scope), scopeValues, $$.privateScope);\n  }\n\n  if (name === 'd-each') {\n    $$.scope = create(parentScope.$$.name === '#d-item' ? parentScope.$$.scope : parentScope, {\n      [Args.item || '$item']: {\n        value: null,\n        writable: true\n      },\n      [Args.index || '$index']: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  constructPublicScope(Args, Args, $$.args);\n  constructPublicScope(globals, globals, $$.globals);\n  constructPublicScope(blockInstance, locals, $$.locals);\n\n  try {\n    blockInstance.afterConstruct();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterConstruct:`, err);\n  }\n\n  prevBlock = undefined;\n  parentScope = name === 'd-elements'\n    ? Args.parentScope\n    : blockInstance;\n  parentTemplate = name === 'd-elements'\n    ? Args.parentTemplate\n    : blockInstance;\n\n  iterateArray(html, (child) => {\n    prevBlock = createBlock({\n      node: child,\n      parent: blockInstance,\n      parentElem,\n      parentBlock: blockInstance,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    });\n  });\n\n  blockInstance.$$.isRendered = true;\n\n  try {\n    blockInstance.afterRender();\n  } catch (err) {\n    console.error(`Uncaught error in ${ name }#afterRender:`, err);\n  }\n\n  return blockInstance;\n}\n","const { isPrototypeOf } = {};\n\nexport function isInstanceOf(Class, Subclass) {\n  return Class::isPrototypeOf(Subclass) && Class.prototype::isPrototypeOf(Subclass.prototype);\n}\n","export function removeWithParentSignal(child) {\n  child.$$.remove(true);\n}\n\nexport function remove(child) {\n  child.$$.remove();\n}\n","import { isInstanceOf } from './isInstanceOf';\nimport { Block } from '../../Block';\nimport { Mixin } from '../../Mixin';\n\nexport function wrapBlock(block, wrapper) {\n  const returnValue = wrapper(block);\n\n  return isInstanceOf(Block, returnValue)\n    ? returnValue\n    : block;\n}\n\nexport function wrapMixin(mixin, wrapper) {\n  const returnValue = wrapper(mixin);\n\n  return isInstanceOf(Mixin, returnValue)\n    ? returnValue\n    : mixin;\n}\n","import {\n  isString, iterateObject, keys,\n  collectFromObject, collectFromArray\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst CSS_STYLES_SEPARATOR_REGEX = /\\s*;\\s*/;\nconst CSS_STYLE_SEPARATOR_REGEX = /\\s*:\\s*/;\n\nrootMixins['d-style'] = class DStyle extends Mixin {\n  css = {};\n\n  afterUpdate(newValue, oldValue) {\n    const {\n      elem,\n      args,\n      css\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (css, prop) => {\n        css[prop] = newValue;\n      });\n    }\n\n    if (isString(newValue)) {\n      newValue = collectFromArray(\n        newValue\n          .split(CSS_STYLES_SEPARATOR_REGEX)\n          .filter(Boolean)\n          .map(constructStyleFromString),\n        addCSSProp\n      );\n    }\n\n    iterateObject(css, (value, prop) => {\n      if (!newValue[prop]) {\n        elem.removeCSS(prop);\n      }\n    });\n    elem.css(newValue);\n\n    this.css = newValue;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      css\n    } = this;\n\n    elem.removeCSS.apply(elem, keys(css));\n  }\n};\n\nfunction addCSSProp(css, item) {\n  const [prop, value] = item;\n\n  css[prop] = value;\n}\n\nfunction constructStyleFromString(style) {\n  const split = style.split(CSS_STYLE_SEPARATOR_REGEX);\n\n  return [\n    split[0].trim(),\n    split[1].trim()\n  ];\n}\n","import {\n  isFunction, isNil,\n  collectFromArray\n} from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-value'] = class DValue extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    const name = elem.name();\n    const type = elem.prop('type');\n    const value = this.evaluate();\n    let initialScopeValue = null;\n\n    this.prop = getProp(name, type, elem);\n    this.name = name;\n    this.type = type;\n    this.value = value;\n    this.options = elem.find('option');\n    this.scope = parentTemplate;\n\n    if (args) {\n      this.scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      this.value = args[0];\n    }\n\n    if (!isFunction(this.value)) {\n      initialScopeValue = this.scope.$$.evaluate((scope) => scope[this.value], (newValue) => {\n        if (this.currentValue !== newValue) {\n          this.currentValue = newValue;\n          this.setProp(newValue);\n        }\n      }, this);\n    }\n\n    const initialElemValue = this.getProp(initialScopeValue, true);\n    const isInitialScopeValueNull = isNil(initialScopeValue);\n    const isCheckbox = type === 'checkbox';\n    const changeScope = () => {\n      this.currentValue = this.getProp(this.currentValue, false);\n      this.changeScope();\n    };\n\n    if (isInitialScopeValueNull || isCheckbox) {\n      this.currentValue = initialElemValue;\n      this.changeScope();\n\n      if (!isInitialScopeValueNull && isCheckbox) {\n        this.setProp(initialScopeValue);\n      }\n    } else {\n      this.currentValue = initialScopeValue;\n      this.setProp(initialScopeValue);\n    }\n\n    this.offElemListener = elem.on(getListenerName(name, type), changeScope);\n    this.offFormListener = elem.closest('form').on('reset', () => {\n      setTimeout(changeScope, 0);\n    });\n  }\n\n  changeScope() {\n    const {\n      scope,\n      value,\n      currentValue\n    } = this;\n\n    if (isFunction(value)) {\n      value(currentValue);\n    } else {\n      scope[value] = currentValue;\n    }\n  }\n\n  setProp(value) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    if (prop === 'text') {\n      elem.text(value);\n    } else if (prop === 'multiple-select') {\n      options.forEach((option) => {\n        option.selected = value.indexOf(option.value) !== -1;\n      });\n    } else {\n      elem.prop(prop, getValueForSetting(name, value, type, node.value));\n    }\n  }\n\n  getProp(values, init) {\n    const {\n      elem,\n      name,\n      prop,\n      type,\n      node,\n      options\n    } = this;\n\n    return prop === 'text'\n      ? elem.text()\n      : getValueForGetting(name, elem.prop(prop), type, node.value, values, options, init, prop === 'multiple-select');\n  }\n\n  beforeRemove() {\n    this.offElemListener();\n    this.offFormListener();\n  }\n};\n\nfunction getProp(name, type, elem) {\n  switch (name) {\n    case 'select': {\n      return elem.hasAttr('multiple')\n        ? 'multiple-select'\n        : 'value';\n    }\n\n    case 'input': {\n      if (type === 'file') {\n        return 'files';\n      }\n\n      return type === 'radio' || type === 'checkbox'\n        ? 'checked'\n        : 'value';\n    }\n\n    default: {\n      return elem.hasAttr('contentEditable')\n        ? 'text'\n        : 'value';\n    }\n  }\n}\n\nfunction getValueForSetting(name, value, type, inputValue) {\n  if (name !== 'input') {\n    return value;\n  }\n\n  const isRadio = type === 'radio';\n\n  if (!isRadio && type !== 'checkbox') {\n    return value;\n  }\n\n  return isRadio\n    ? value === inputValue\n    : value.indexOf(inputValue) !== -1;\n}\n\nfunction getValueForGetting(name, value, type, inputValue, values, options, init, isMultiple) {\n  switch (name) {\n    case 'select': {\n      if (!isMultiple) {\n        return value;\n      }\n\n      return collectFromArray(options, addValue, []);\n    }\n\n    case 'input': {\n      if (type !== 'radio' && type !== 'checkbox') {\n        return value;\n      }\n\n      if (type === 'radio') {\n        return value\n          ? inputValue\n          : null;\n      }\n\n      values = values || [];\n\n      if (!value && init) {\n        return values;\n      }\n\n      if (value) {\n        return values.indexOf(inputValue) === -1\n          ? values.concat(inputValue)\n          : values;\n      }\n\n      const index = values.indexOf(inputValue);\n\n      if (index !== -1) {\n        return [\n          ...values.slice(0, index),\n          ...values.slice(index + 1)\n        ];\n      }\n\n      return values;\n    }\n\n    default: {\n      return value;\n    }\n  }\n}\n\nfunction getListenerName(name, type) {\n  switch (name) {\n    case 'select': {\n      return 'change';\n    }\n\n    case 'input': {\n      return (\n        type === 'radio'\n        || type === 'checkbox'\n        || type === 'color'\n        || type === 'file'\n      )\n        ? 'change'\n        : 'change input';\n    }\n\n    default: {\n      return 'input';\n    }\n  }\n}\n\nfunction addValue(values, { selected, value }) {\n  if (selected && values.indexOf(value) === -1) {\n    values.push(value);\n  }\n}\n","import {\n  toObjectKeys,\n  assign, keys, create\n} from './utils';\n\nexport function insertTemplates(template, templates) {\n  const {\n    vars,\n    value\n  } = template;\n  const newTemplates = create(null);\n  const newVars = toObjectKeys(vars);\n\n  assign(newTemplates, templates);\n  iterateAndChangeChildren(value);\n\n  function iterateAndChangeChildren(nodes = []) {\n    for (let i = 0; i < nodes.length; i++) {\n      const {\n        name,\n        value,\n        children\n      } = nodes[i];\n\n      if (name === '#comment') {\n        const trimmed = value.trim();\n\n        if (newTemplates[trimmed]) {\n          const newTemplate = newTemplates[trimmed].value;\n\n          nodes.splice(i, 1, ...newTemplate);\n          assign(newVars, toObjectKeys(newTemplates[trimmed].vars));\n\n          i += newTemplate.length - 1;\n        }\n      } else {\n        iterateAndChangeChildren(children);\n      }\n    }\n  }\n\n  vars.length = 0;\n  vars.push(...keys(newVars));\n\n  return template;\n}\n","import { isArray, isString } from './utils';\nimport { createBlock, isInstanceOf } from './helpers/Block';\nimport { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function initApp\n * @public\n * @param {Template|ScopelessTemplate|String|typeof Block} block - Root template (may be scopeless),\n * string defining a name of the root block or a block subclass.\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for initializing app.\n *\n * @example\n * import { initApp, doc } from 'dwayne';\n *\n * initApp(html`<App/>`, doc.create('div'));\n * initApp(htmlScopeless`<App/>`, doc.create('div'));\n * initApp('App', doc.create('div'));\n * initApp(App, doc.create('div'));\n */\nexport function initApp(block, container) {\n  const parentElem = new Elem(container).elem(0);\n\n  if (!parentElem.length) {\n    throw new Error('No valid element to insert the app into was given! (initApp)');\n  }\n\n  if (parentElem.prop('DwayneRootBlock')) {\n    throw new Error('There already exists a Dwayne app inside the given element! (initApp)');\n  }\n\n  if (isString(block)) {\n    block = {\n      vars: [],\n      value: [{\n        name: block\n      }]\n    };\n  }\n\n  if (isArray(block)) {\n    block = {\n      vars: [],\n      value: block\n    };\n  }\n\n  let Constructor;\n\n  if (isInstanceOf(Block, block)) {\n    Constructor = block;\n  } else {\n    Constructor = class RootBlock extends Block {\n      static template = block;\n    };\n  }\n\n  const rootBlock = createBlock({\n    node: {\n      name: '#RootBlock',\n      Constructor\n    },\n    parent: parentElem,\n    parentElem\n  });\n\n  parentElem\n    .prop('DwayneRootBlock', rootBlock)\n    .attr('dwayne-root', '');\n}\n","import { Block } from './Block';\nimport { Elem } from './Elem';\n\n/**\n * @function removeApp\n * @public\n * @param {Elem|Element} container - Container of the app.\n * @returns {void}\n * @description Method for removing app.\n *\n * @example\n * import { removeApp, find } from 'dwayne';\n *\n * removeApp(find('.root'));\n */\nexport function removeApp(container) {\n  const elem = new Elem(container).elem(0);\n\n  if (!elem.length) {\n    throw new Error('No valid element to remove the app from was given! (removeApp)');\n  }\n\n  container = elem[0];\n\n  const { DwayneRootBlock } = container;\n\n  if (!(DwayneRootBlock instanceof Block)) {\n    throw new Error('No app registered inside the given element! (removeApp)');\n  }\n\n  DwayneRootBlock.$$.remove();\n  elem.removeAttr('dwayne-root');\n\n  delete container.DwayneRootBlock;\n}\n","/* eslint no-nested-ternary: 0 */\n/* eslint no-negated-condition: 0 */\nexport default typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n","export const {\n  create,\n  keys,\n  getPrototypeOf: getProto\n} = Object;\n\nexport const setProto = Object.setPrototypeOf || ((target, proto) => {\n  /* eslint no-proto: 0 */\n  target.__proto__ = proto;\n});\n","import { create } from './utils/objectStatics';\n\nexport const HIDE_CLASS = '__dwayne-hidden__';\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const D_REST_REGEX = /^d-rest(?:#|$)/;\n\nexport const rootBlocks = create(null);\nexport const rootMixins = create(null);\nexport const {\n  document = {},\n  Symbol = {}\n} = global;\n","import {\n  isNil, isString,\n  definePrototypeProperties,\n  collectFromArray, collectFromObject,\n  iterateArray, iterateObject,\n  toHyphenCase, setSymbolSpecies,\n  setToStringTag, setProto\n} from './utils';\nimport {\n  isDocument, isValidNode, getMatchesFunction,\n  addAttr, addCSSProp, addDataAttr,\n  addNext, addParent, addPrev,\n  toElem, isElementsCollection,\n  getAttrNS, getEvent, hide, show, remove\n} from './helpers/Elem';\nimport { SVG_NS } from './constants';\nimport { find } from './find';\n\n/**\n * @typedef {String} ElemEventString\n * @public\n * @description A string containing events separated by a comma with zero or more spaces or just spaces.\n */\n\n/**\n * @callback ElemListener\n * @public\n * @param {Event} e - Fired event.\n * @param {Element} elem - Element on which the listener was called.\n * @param {Number} index - Index of the element on which the listener was called.\n */\n\n/**\n * @callback ElemRemoveListeners\n * @public\n * @param {...ElemEventString} events - If at least one argument present only removes event listeners specified\n * by the events in the arguments.\n */\n\n/**\n * @callback IterationCallback\n * @public\n * @param {Element|Node} node - Iteration element.\n * @param {Number} index - Iteration index.\n * @param {Elem} elem - Initial set.\n */\n\n/**\n * @callback ElemMethod\n * @public\n * @this Elem\n */\n\nconst EVENT_SEPARATOR_REGEX = /(?:,| ) */;\nconst CSS_STYLES_SEPARATOR_REGEX = /; ?/;\nconst CSS_IMPORTANT_REGEX = / ?!important$/;\nconst XHTML_NS = 'http://www.w3.org/1999/xhtml';\nconst emptyCollection = [];\n\n/**\n * @class Elem\n * @extends Array.<Element|Node>\n * @public\n * @param {Element|Element[]} [elem = []] - An element or an array of elements to wrap.\n * @returns {Elem} Instance of Elem.\n * @description Wrap of an elements set.\n *\n * @example\n * new Elem(document.body);\n * new Elem(document.querySelectorAll('.cls'));\n * new Elem(document.getElementsByClassName('cls'));\n */\nclass Elem extends Array {\n  /**\n   * @method Elem.addMethods\n   * @public\n   * @param {String|Object.<String, ElemMethod>} methodName - Name of the method or object of\n   * method names and methods.\n   * @param {ElemMethod} [method] - If the first argument is a string this should be the method itself.\n   * @returns {typeof Elem}\n   */\n  static addMethods(methodName, method) {\n    if (arguments.length >= 2) {\n      methodName = { [methodName]: method };\n    }\n\n    definePrototypeProperties(this.prototype, methodName);\n\n    return this;\n  }\n\n  constructor(elem = emptyCollection) {\n    super();\n\n    if (!isElementsCollection(elem)) {\n      elem = [elem];\n    }\n\n    setProto(this, Elem.prototype);\n\n    iterateArray(elem, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!this.includes(elem) && isValidNode(elem)) {\n          this.push(elem);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#add\n   * @public\n   * @param {...(Elem|Element|Element[])} elements - Each argument is a Elem, or Element, or array of Elements.\n   * @returns {Elem} Returns this.\n   * @description Method for adding new elements to the set.\n   *\n   * @example\n   * elem1.find('.cls1')\n   *   .add(elem2.find('.cls2'))\n   *   .hide();\n   */\n  add() {\n    const elems = this.slice();\n\n    iterateArray(arguments, (elem) => {\n      if (!isElementsCollection(elem)) {\n        elem = [elem];\n      }\n\n      iterateArray(elem, (elem) => {\n        if (!elems.includes(elem) && isValidNode(elem)) {\n          elems.push(elem);\n        }\n      });\n    });\n\n    return elems;\n  }\n\n  /**\n   * @method Elem#addClass\n   * @public\n   * @param {...String} classes - Classes to add.\n   * @returns {Elem} Returns this.\n   * @description Method for adding classes to the all the elements in the set.\n   *\n   * @example\n   * elem.addClass('red', 'round');\n   */\n  addClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.add(cls));\n    });\n  }\n\n  /**\n   * @method Elem#attr\n   * @public\n   * @param {String|Object.<String, String>} [attr] - Name of the attribute to get or\n   * an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string\n   * it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of attributes of the first element in the set\n   * returned, if 1 string argument is passed the value of the attribute of the first element in the set\n   * returned otherwise returns this.\n   * @description Method for getting/setting attributes.\n   *\n   * @example\n   * elem.attr('attr1', 'value1'); // attribute attr1 set to 'value1' and this returned\n   * elem.attr('attr1');           // 'value1'\n   * elem.attr({\n   *   attr1: 'value3',            // attribute attr1 set to 'value3'\n   *   attr2: 'value2'             // attribute attr2 set to 'value2'\n   * });                           // this returned\n   * elem.attr();                  // { attr1: 'value3', attr2: 'value2' }\n   */\n  attr(attr, value) {\n    const elem = this[0];\n\n    if (!arguments.length) {\n      if (!elem) {\n        return {};\n      }\n\n      return collectFromArray(elem.attributes, addAttr);\n    }\n\n    if (arguments.length <= 1 && isString(attr)) {\n      if (!elem) {\n        return null;\n      }\n\n      const {\n        ns,\n        name\n      } = getAttrNS(attr, elem);\n\n      return ns\n        ? elem.getAttributeNS(ns, name)\n        : elem.getAttribute(attr);\n    }\n\n    if (arguments.length >= 2) {\n      attr = { [attr]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(attr, (value, key) => {\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeAttr(key);\n        }\n\n        value = value === true ? '' : value;\n\n        const { ns } = getAttrNS(key, elem);\n\n        if (ns) {\n          elem.setAttributeNS(ns, key, value);\n        } else {\n          elem.setAttribute(key, value);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#children\n   * @public\n   * @returns {Elem} D-Wrap of the children of the first element in the set.\n   * @description Method for getting element's children.\n   *\n   * @example\n   * const children = elem.children();\n   */\n  children() {\n    return new Elem(this.length ? this[0].childNodes : []);\n  }\n\n  /**\n   * @method Elem#closest\n   * @public\n   * @param {String} selector - See the link.\n   * @returns {Elem} Set of the closest elements.\n   * @description Synonym for\n   * [Element#closest]{@link https://developer.mozilla.org/en/docs/Web/API/Element/closest}.\n   */\n  closest(selector) {\n    return this.collect((add, elem) => {\n      while (elem) {\n        if (new Elem(elem).is(selector)) {\n          return add(elem);\n        }\n\n        elem = elem.parentNode;\n      }\n    });\n  }\n\n  collect(callback) {\n    const elements = [];\n    const cb = ::elements.push;\n\n    this.forEach((elem, index) => {\n      callback(cb, elem, index, this);\n    });\n\n    return new Elem(elements);\n  }\n\n  /**\n   * @method Elem#contains\n   * @public\n   * @param {Elem|Element} element - Element to find out if it's within the first element in the set.\n   * @returns {Boolean} Returns if the argument within this element.\n   * @description Method is extension for\n   * [Node#contains]{@link https://developer.mozilla.org/en/docs/Web/API/Node/contains}.\n   *\n   * @example\n   * elem.contains(elem2);   // true|false\n   */\n  contains(element) {\n    const parent = this[0];\n    const child = toElem(element)[0];\n\n    return !parent || !child\n      ? false\n      : parent.contains(child);\n  }\n\n  /**\n   * @method Elem#create\n   * @public\n   * @param {String} type - Type of created element. If type is \"#text\" a text node is created.\n   * If type is \"#comment\" a comment node is created.\n   * @returns {Elem} New instance of Elem - wrap of the created elements.\n   * @description Method for creating elements inside this element.\n   * If this element is not an Element the element is just created.\n   *\n   * @example\n   * elem.create('div');\n   */\n  create(type) {\n    return this.collect((add, elem) => {\n      let el = null;\n      const isText = type === '#text';\n      const document = isDocument(elem)\n        ? elem\n        : elem.ownerDocument;\n\n      if (isText || type === '#comment') {\n        el = isText\n          ? document.createTextNode('')\n          : document.createComment('');\n      } else {\n        el = type === 'svg'\n          ? document.createElementNS(SVG_NS, type)\n          : document.createElement(type);\n      }\n\n      if (!isDocument(elem)) {\n        new Elem(el).into(elem);\n      }\n\n      add(el);\n    });\n  }\n\n  /**\n   * @method Elem#css\n   * @public\n   * @param {String|Object.<String, String>} [property] - Name of the property to get or\n   * an object of the format { [property]: value, ... } to set styles.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that property.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of css styles of the element returned,\n   * if 1 string argument is passed the value of the property returned otherwise returns this.\n   * @description Method for getting/setting styles. Supports !important.\n   *\n   * @example\n   * elem.css('display', 'none'); // display set to 'none' and this returned\n   * elem.css('display');         // 'none'\n   * elem.css({\n   *   display: 'inline',         // display set to 'inline'\n   *   cursor: 'pointer'          // cursor set to 'pointer'\n   * });                          // this returned\n   * elem.css();                  // { display: 'none', cursor: 'pointer' }\n   */\n  css(property, value) {\n    const { style } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!style) {\n        return {};\n      }\n\n      return collectFromArray(style.cssText.split(CSS_STYLES_SEPARATOR_REGEX), addCSSProp);\n    }\n\n    if (arguments.length <= 1 && isString(property)) {\n      if (!style) {\n        return '';\n      }\n\n      property = toHyphenCase(property);\n\n      return style.getPropertyValue(property) + (style.getPropertyPriority(property) ? ' !important' : '');\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, property) => {\n        property = toHyphenCase(property);\n\n        if (isNil(value) || value === false) {\n          return new Elem(elem).removeCSS(property);\n        }\n\n        elem.style.removeProperty(property);\n        elem.style.setProperty(\n          property,\n          value.replace(CSS_IMPORTANT_REGEX, ''),\n          CSS_IMPORTANT_REGEX.test(value) ? 'important' : ''\n        );\n      });\n    });\n  }\n\n  /**\n   * @method Elem#data\n   * @public\n   * @param {String|Object.<String, String>} [key] - Name of the data attribute (without data- prefix)\n   * to get or an object of the format { [attrName]: value, ... } to set attributes.\n   * @param {String} [value] - If the first argument is a string it should be a value to set for that attribute.\n   * @returns {Object|String|Elem} If no arguments passed, D-Wrap of dataset of the element returned,\n   * if 1 string argument is passed the value of the data attribute returned otherwise returns this.\n   * @description Method for getting/setting data attributes. See\n   * [HTMLElement#dataset]{@link https://developer.mozilla.org/en/docs/Web/API/HTMLElement/dataset}.\n   *\n   * @example\n   * elem.data('someKey1', 'value'); // attribute data-some-key1 set to 'value1' and this returned\n   * elem.data('someKey1');          // 'value1'\n   * elem.data({\n   *   someKey1: 'value3',           // attribute data-some-key1 set to 'value3'\n   *   someKey2: 'value2'            // attribute data-some-key2 set to 'value2'\n   * });                             // this returned\n   * elem.data();                    // { someKey1: 'value3', someKey2: 'value2' }\n   */\n  data(key, value) {\n    const { dataset } = this[0] || {};\n\n    if (!arguments.length) {\n      if (!dataset) {\n        return {};\n      }\n\n      return collectFromObject(dataset, addDataAttr);\n    }\n\n    if (arguments.length === 1 && isString(key)) {\n      if (!dataset) {\n        return;\n      }\n\n      return dataset[key];\n    }\n\n    if (arguments.length >= 2) {\n      key = { [key]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(key, (value, key) => {\n        elem.dataset[key] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#dispatch\n   * @public\n   * @param {String|Event} event - Event or a string (new Event(event) is created).\n   * @param {Object} [details = {}] - Object that is assigned to the event.\n   * @returns {Elem} Returns this.\n   * @see https://developer.mozilla.org/en/docs/Web/API/Event/Event\n   * @description Synonym for\n   * [EventTarget#dispatchEvent]{@link https://developer.mozilla.org/en/docs/Web/API/EventTarget/dispatchEvent}.\n   *\n   * @example\n   * elem.dispatch('click');\n   * elem.dispatch('click', { bubbles: false, cancellable: false, data: 1 });\n   * elem.dispatch(new CustomEvent('custom-event'));\n   */\n  dispatch(event, details = {}) {\n    const {\n      bubbles = true,\n      cancelable = true,\n      ...realDetails\n    } = details;\n\n    return this.forEach((elem) => {\n      elem.dispatchEvent(getEvent(\n        event,\n        bubbles,\n        cancelable,\n        realDetails,\n        elem\n      ));\n    });\n  }\n\n  /**\n   * @method Elem#elem\n   * @public\n   * @param {Number} [index = 0] - Index of the element of the set to get. Negative index means elem.length + index.\n   * @returns {Elem} New instance of Elem.\n   *\n   * @example\n   * elem.elem(1); // a wrap of the element in the set that has index 1\n   * elem.elem();  // a wrap of the element in the set that has index 0\n   */\n  elem(index = 0) {\n    if (index < 0) {\n      index = this.length + index;\n    }\n\n    return new Elem(this[index]);\n  }\n\n  /**\n   * @method Elem#filter\n   * @public\n   * @param {IterationCallback|String} filter - Filter function or a selector.\n   * @returns {Elem} New instance of Elem.\n   * @description Method for filtering elements.\n   *\n   * @example\n   * elem.filter((elem) => new Elem(elem).closest('.parent'));\n   */\n  filter(filter) {\n    if (isString(filter)) {\n      const selector = filter;\n\n      filter = (elem) => (\n        new Elem(elem).is(selector)\n      );\n    }\n\n    return this.collect((add, elem, index) => {\n      if (filter(elem, index, this)) {\n        add(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#find\n   * @public\n   * @param {String} selector - Selector to find.\n   * @returns {Elem} New instance of Elem.\n   * @description Synonym for\n   * [Element#querySelectorAll]{@link https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll}.\n   */\n  find(selector) {\n    return this.collect((add, elem) => {\n      add(find(selector, elem));\n    });\n  }\n\n  /**\n   * @method Elem#forEach\n   * @public\n   * @param {IterationCallback} callback - Called on each iteration.\n   * @returns {Elem} Returns this.\n   * @description Method for iterating over the set.\n   *\n   * @example\n   * find('.cls').forEach((element, index, set) => {\n   *   // do something\n   * });\n   */\n  forEach(callback) {\n    iterateArray(this, (value, key) => {\n      callback(value, key, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * @method Elem#hasAttr\n   * @public\n   * @param {String} attr - Name of the attribute.\n   * @returns {Boolean} If the first element in the set has the attribute.\n   * @description Method that returns if the first element in the set has the attribute or not.\n   *\n   * @example\n   * elem.attr('attr', 'value').hasAttr('attr'); // true\n   * elem.removeAttr('attr').hasAttr('attr');    // false\n   */\n  hasAttr(attr) {\n    const elem = this[0];\n\n    if (!elem) {\n      return false;\n    }\n\n    const { ns } = getAttrNS(attr, elem);\n\n    return ns\n      ? elem.hasAttributeNS(ns, attr)\n      : elem.hasAttribute(attr);\n  }\n\n  /**\n   * @method Elem#hasClass\n   * @public\n   * @param {String} cls - Name of the class.\n   * @returns {Boolean} If the first element in the set has the class.\n   * @description Method that returns if the first element in the set has the class or not.\n   *\n   * @example\n   * elem.addClass('cls').hasClass('cls');    // true\n   * elem.removeClass('cls').hasClass('cls'); // false\n   */\n  hasClass(cls) {\n    const elem = this[0];\n\n    return elem\n      ? elem.classList.contains(cls)\n      : false;\n  }\n\n  /**\n   * @method Elem#hide\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Hides all elements in the set.\n   *\n   * @example\n   * elem.hide();\n   */\n  hide() {\n    return this.forEach(hide);\n  }\n\n  /**\n   * @method Elem#html\n   * @public\n   * @param {String|*} [html] - HTML to write instead of current HTML.\n   * @returns {Elem|String} If no arguments passed HTML of the first element in the set returned.\n   * Otherwise all elements HTML in the set are set to the html argument.\n   * @description Gets or sets HTML.\n   *\n   * @example\n   * elem.html('<div>1</div>');\n   * elem.html(); // '<div>1</div>'\n   */\n  html(html) {\n    if (!arguments.length) {\n      const elem = this[0];\n\n      return elem\n        ? elem.innerHTML\n        : '';\n    }\n\n    return this.forEach((elem) => {\n      elem.innerHTML = html;\n    });\n  }\n\n  includes(elem) {\n    return this.indexOf(elem) !== -1;\n  }\n\n  /**\n   * @method Elem#insertAfter\n   * @public\n   * @param {Elem|Element} element - Element to insert this element after.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set after the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertAfter(elem2);\n   * elem.insertAfter(document.getElementById('id'));\n   * elem.insertAfter('#id div.c1');\n   */\n  insertAfter(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element.next()[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      if (elem === element) {\n        element = element.nextSibling;\n\n        return;\n      }\n\n      if (element) {\n        parent.insertBefore(elem, element);\n      } else {\n        parent.appendChild(elem);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#insertBefore\n   * @public\n   * @param {Elem|Element} element - Element to insert this element before.\n   * @returns {Elem} Returns this.\n   * @description Puts the elements from the set before the element specified by the argument.\n   * The elements remain in the same order.\n   *\n   * @example\n   * elem.insertBefore(elem2);\n   * elem.insertBefore(document.getElementById('id'));\n   * elem.insertBefore('#id div.c1');\n   */\n  insertBefore(element) {\n    element = toElem(element).elem(0);\n\n    let parent = element.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    element = element[0];\n    parent = parent[0];\n\n    return this.forEach((elem) => {\n      parent.insertBefore(elem, element);\n    });\n  }\n\n  /**\n   * @method Elem#into\n   * @public\n   * @param {Elem|Element} element - Element to put this elements into.\n   * @param {Boolean} end - If the elements should be inserted to the end. If false they are inserted to the start.\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#appendChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/appendChild}.\n   *\n   * @example\n   * elem.into(elem2);\n   * elem.into(document.getElementById('id'));\n   * elem.into('#id div.c1');\n   */\n  into(element, end = true) {\n    element = toElem(element)[0];\n\n    if (!element) {\n      return this;\n    }\n\n    if (!end && element.firstChild) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        element.insertBefore(this[i], element.firstChild);\n      }\n\n      return this;\n    }\n\n    return this.forEach((elem) => {\n      element.appendChild(elem);\n    });\n  }\n\n  /**\n   * @method Elem#is\n   * @public\n   * @param {String} selector\n   * @returns {Boolean} If the first element in the set matches the selector.\n   * @description Synonym for\n   * [Element#matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches}.\n   *\n   * @example\n   * elem.addClass('cls');\n   * elem.is('.cls');         // true\n   *\n   * elem.removeClass('cls');\n   * elem.is('.cls');         // false\n   */\n  is(selector) {\n    if (!this.length) {\n      return false;\n    }\n\n    const elem = this[0];\n    const matches = getMatchesFunction(elem);\n\n    return elem::matches(selector);\n  }\n\n  /**\n   * @method Elem#name\n   * @public\n   * @returns {String|void} nodeName (lowercased) of the first element in the set.\n   * @description Method for getting name of the first element in the set.\n   *\n   * @example\n   * elem.create('div').name() // 'div'\n   */\n  name() {\n    const elem = this[0];\n\n    return elem\n      ? elem.nodeName.toLowerCase()\n      : undefined;\n  }\n\n  /**\n   * @method Elem#next\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding next element to each element in the set.\n   *\n   * @example\n   * elem.next(); // finds next element to each element in the set\n   */\n  next() {\n    return this.collect(addNext);\n  }\n\n  /**\n   * @method Elem#on\n   * @public\n   * @param {ElemEventString|Object.<ElemEventString|ElemListener>} event - Either a {@link ElemEventString} string\n   * or an object with event keys (a key is also ElemEventString) and listeners values.\n   * @param {ElemListener} [listener] - If the first argument is a string it must be a listener function for\n   * specified event(s).\n   * @returns {ElemRemoveListeners} Function that takes optional event argument.\n   * @description Adds event listeners for all the elements in the set.\n   *\n   * @example\n   * elem.on(\n   *   'change, input',\n   *   'input, select, textarea, datalist, keygen, output',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   'change, input',\n   *   (e, elem, index) => console.log(elem.value)\n   * );\n   * elem.on(\n   *   {\n   *     'change, input': (e, elem, index) => console.log(elem.value),\n   *     'blur': () => console.log('blur')\n   *   },\n   *   'input, select, textarea, datalist, keygen, output'\n   * );\n   *\n   * const removeListeners = elem.on({\n   *   'change, input': (e, elem, index) => console.log(elem.value),\n   *   'blur': () => console.log('blur')\n   * });\n   *\n   * removeListeners('click');\n   * removeListeners('blur, change');\n   * removeListeners('blur, change', 'input');\n   * removeListeners();\n   */\n  on(event, listener) {\n    if (isString(event)) {\n      event = { [event]: listener };\n    }\n\n    const newEvents = {};\n    const allListeners = {};\n\n    iterateObject(event, (listener, event) => {\n      iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n        (newEvents[event] = newEvents[event] || []).push(listener);\n      });\n    });\n\n    this.forEach((elem) => {\n      iterateObject(newEvents, (listeners, event) => {\n        iterateArray(listeners, (listener) => {\n          elem.addEventListener(event, listener, false);\n          (allListeners[event] = allListeners[event] || []).push(() => {\n            elem.removeEventListener(event, listener);\n          });\n        });\n      });\n    });\n\n    return function removeEventListeners(event) {\n      if (arguments.length) {\n        iterateArray(arguments, (event) => {\n          iterateArray(event.split(EVENT_SEPARATOR_REGEX), (event) => {\n            const removeListeners = allListeners[event];\n\n            if (removeListeners) {\n              iterateArray(removeListeners, (removeListener) => removeListener());\n\n              delete allListeners[event];\n            }\n          });\n        });\n      } else {\n        iterateObject(allListeners, (removeListeners, event) => {\n          iterateArray(removeListeners, (removeListener) => removeListener());\n\n          delete allListeners[event];\n        });\n      }\n    };\n  }\n\n  /**\n   * @method Elem#parent\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method returns wrap of the set of the parent elements of each element in the set.\n   */\n  parent() {\n    return this.collect(addParent);\n  }\n\n  /**\n   * @method Elem#prev\n   * @public\n   * @returns {Elem} New instance of Elem.\n   * @description Method for finding previous element to each element in the set.\n   *\n   * @example\n   * elem.prev(); // finds previous element to each element in the set\n   */\n  prev() {\n    return this.collect(addPrev);\n  }\n\n  /**\n   * @method Elem#prop\n   * @public\n   * @param {String|Object.<String, *>} property - Either a string of a property or an assigned object.\n   * @param {*} [value] - If a property parameter is a string\n   * this has to be an assigned value if it's present.\n   * @returns {Elem|*} Returns this if it's setter or a value if getter.\n   * @description Method that is either a property getter for the first element in the set\n   * or a setter for every element in the set.\n   *\n   * @example\n   * elem.prop('draggable', false);\n   * elem.prop('draggable'); // false\n   */\n  prop(property, value) {\n    if (arguments.length <= 1 && isString(property)) {\n      return this[0] ? this[0][property] : undefined;\n    }\n\n    if (arguments.length >= 2) {\n      property = { [property]: value };\n    }\n\n    return this.forEach((elem) => {\n      iterateObject(property, (value, prop) => {\n        elem[prop] = value;\n      });\n    });\n  }\n\n  /**\n   * @method Elem#remove\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Removes all the elements from the set from the document.\n   * Note: it doesn't remove them from the set so watch out for the memory leaks.\n   *\n   * @example\n   * elem.remove();\n   */\n  remove() {\n    return this.forEach(remove);\n  }\n\n  /**\n   * @method Elem#removeAttr\n   * @public\n   * @param {...String} attributes - Attributes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the attributes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeAttr('foo', 'bar', 'baz');\n   */\n  removeAttr() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (attr) => {\n        const { ns } = getAttrNS(attr, elem);\n\n        if (ns) {\n          elem.removeAttributeNS(ns, attr);\n        } else {\n          elem.removeAttribute(attr);\n        }\n      });\n    });\n  }\n\n  /**\n   * @method Elem#removeClass\n   * @public\n   * @param {...String} classes - Classes to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the classes from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeClass('foo', 'bar', 'baz');\n   */\n  removeClass() {\n    return this.forEach((elem) => {\n      const list = elem.classList;\n\n      iterateArray(arguments, (cls) => list.remove(cls));\n    });\n  }\n\n  /**\n   * @method Elem#removeCSS\n   * @public\n   * @param {...String} props - CSS properties to remove.\n   * @returns {Elem} Returns this.\n   * @description Removes all the CSS properties from arguments from all the elements in the set.\n   *\n   * @example\n   * elem.removeCSS('display', 'position', 'margin');\n   */\n  removeCSS() {\n    return this.forEach((elem) => {\n      iterateArray(arguments, (css) => {\n        elem.style.removeProperty(toHyphenCase(css));\n      });\n    });\n  }\n\n  /**\n   * @method Elem#replace\n   * @public\n   * @param {Elem|Element} element - Element to replace the first element in the set\n   * with a set of elements specified by the argument (Element or Elem).\n   * @returns {Elem} Returns this.\n   * @description Method is similar to\n   * [Node#replaceChild]{@link https://developer.mozilla.org/en/docs/Web/API/Node/replaceChild}.\n   *\n   * @example\n   * elem.replace(elem2);\n   * elem.replace(document.getElementById('id'));\n   * elem.replace('#id div.c1');\n   */\n  replace(element) {\n    element = toElem(element);\n\n    const first = this.elem(0);\n    const parent = first.parent();\n\n    if (!parent.length) {\n      return this;\n    }\n\n    let elem = parent;\n    let method = 'into';\n    const next = first.next()[0];\n    const prev = first.prev()[0];\n\n    if (next) {\n      elem = next;\n      method = 'insertBefore';\n    } else if (prev) {\n      elem = prev;\n      method = 'insertAfter';\n    }\n\n    first.remove();\n\n    element[method](elem);\n  }\n\n  /**\n   * @method Elem#show\n   * @public\n   * @returns {Elem} Returns this.\n   * @description Shows all elements in the set.\n   * If an element was hidden using {@link Elem#hide} previous display is set.\n   *\n   * @example\n   * elem.show();\n   */\n  show() {\n    return this.forEach(show);\n  }\n\n  slice() {\n    return new Elem(super.slice.apply(this, arguments));\n  }\n\n  /**\n   * @method Elem#text\n   * @public\n   * @param {String|*} [text] - Text to write instead of current text.\n   * @returns {Elem|String} If no arguments passed text of the first element in the set returned.\n   * Otherwise all elements texts in the set are set to the text argument.\n   * @description Gets or sets text.\n   *\n   * @example\n   * elem.text('123');\n   * elem.text(); // '123'\n   */\n  text(text) {\n    if (!arguments.length) {\n      return this.prop('textContent');\n    }\n\n    return this.forEach((elem) => {\n      elem.textContent = text;\n    });\n  }\n\n  /**\n   * @method Elem#toggleAttr\n   * @public\n   * @param {String} attr - Attribute to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the attribute\n   * with the '' value and if falsey method removes the attribute. If not present method adds\n   * the attribute if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling attributes.\n   *\n   * @example\n   * elem.toggleAttr('attr');\n   * elem.toggleAttr('attr', someCondition);\n   */\n  toggleAttr(attr, condition) {\n    return this.forEach((elem) => {\n      elem = new Elem(elem);\n\n      if (arguments.length < 2 ? !elem.hasAttr(attr) : condition) {\n        elem.attr(attr, '');\n      } else {\n        elem.removeAttr(attr);\n      }\n    });\n  }\n\n  /**\n   * @method Elem#toggleClass\n   * @public\n   * @param {String} cls - Class to toggle.\n   * @param {Boolean|*} [condition] - If present and the condition is truthy method adds the class\n   * and if falsey method removes the class. If not present method adds\n   * the class if it doesn't exist and removes if it does.\n   * @returns {Elem} Returns this.\n   * @description Method for toggling classes.\n   *\n   * @example\n   * elem.toggleClass('cls');\n   * elem.toggleClass('cls', someCondition);\n   */\n  toggleClass(cls, condition) {\n    return this.forEach((elem) => {\n      const { classList } = elem;\n\n      classList.toggle(cls, arguments.length < 2 ? !classList.contains(cls) : condition);\n    });\n  }\n}\n\nsetToStringTag(Elem, 'Elem');\nsetSymbolSpecies(Elem, Array);\n\nexport { Elem };\n","import { defineProperties } from './defineProperty';\nimport { Symbol } from '../constants';\n\nexport function setSymbolSpecies(klass, species) {\n  if (Symbol.species) {\n    defineProperties(klass, {\n      [Symbol.species]: {\n        get() {\n          return species;\n        }\n      }\n    });\n  }\n}\n","import {\n  defineFrozenProperties,\n  removeArrayElem, setToStringTag\n} from './utils';\nimport { wrapMixin, removeWatchers } from './helpers/Block';\n\n/**\n * @class Mixin\n * @public\n * @param {Object} opts - Mixin options.\n * @returns {Mixin} Instance of Mixin.\n */\nclass Mixin {\n  /**\n   * @member {Boolean} [Mixin.evaluate = true]\n   * @type {Boolean}\n   * @public\n   * @description If the mixin value should be evaluated and watched or not.\n   */\n  static evaluate = true;\n\n  /**\n   * @method Mixin.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped mixin.\n   * @returns {typeof Mixin} New mixin.\n   * @description Method for wrapping mixins.\n   * It is considered best practice to just extends the old mixin with a new one.\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapMixin, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      value,\n      dynamic,\n      elem,\n      args,\n      comment,\n      parentBlock,\n      parentScope,\n      parentTemplate\n    } = opts;\n    const watchersToRemove = [];\n    const watchers = [];\n\n    defineFrozenProperties(this, {\n      $$: {\n        name,\n        _value: value,\n        value,\n        isDynamic: dynamic,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        watchers,\n        watchersToRemove,\n        isRemoved: false,\n        evaluate: (watcher) => {\n          const {\n            isDynamic,\n            value,\n            _value\n          } = this.$$;\n          const currentValue = isDynamic\n            ? value\n            : parentScope.$$.evaluate(_value);\n\n          if (watcher) {\n            watchers.push(watcher);\n          }\n\n          return currentValue;\n        },\n        remove: (isParentSignal) => {\n          isParentSignal = !!isParentSignal;\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          try {\n            this.beforeRemove(isParentSignal);\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal) {\n            removeArrayElem(parentBlock.$$.mixins, this);\n          }\n        }\n      }\n    });\n\n    /**\n     * @member {String[]} [Mixin#args]\n     * @type {String[]}\n     * @public\n     */\n    this.args = args;\n\n    /**\n     * @member {String} [Mixin#comment]\n     * @type {String}\n     * @public\n     */\n    this.comment = comment;\n\n    /**\n     * @member {Block} [Mixin#parentBlock]\n     * @type {Block}\n     * @public\n     */\n    this.parentBlock = parentBlock;\n\n    /**\n     * @member {Block} [Mixin#parentScope]\n     * @type {Block}\n     * @public\n     */\n    this.parentScope = parentScope;\n\n    /**\n     * @member {Block} [Mixin#parentTemplate]\n     * @type {Block}\n     * @public\n     */\n    this.parentTemplate = parentTemplate;\n\n    /**\n     * @member {Elem} Mixin#elem\n     * @type {Elem}\n     * @public\n     */\n    this.elem = elem;\n\n    /**\n     * @member {Element} Mixin#node\n     * @type {Element}\n     * @public\n     */\n    this.node = elem[0];\n\n    parentBlock.$$.mixins.push(this);\n  }\n\n  afterUpdate() {}\n\n  /**\n   * @method Mixin#beforeRemove\n   * @public\n   * @param {Boolean} isElementRemoved - If element removed as well.\n   * @description Is called before the mixin removal.\n   */\n  beforeRemove(isElementRemoved) {}\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Watcher} [callback] - If present, callback which is called when the mixin value is changed.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating the mixin value and watching for the changes.\n   */\n  evaluate(callback) {\n    return this.$$.evaluate(callback);\n  }\n\n  toString() {\n    return '[object Mixin]';\n  }\n}\n\nsetToStringTag(Mixin, 'Mixin');\n\nexport { Mixin };\n","import { Elem } from './Elem';\nimport {\n  defineFrozenProperties,\n  assign, iterateArray, iterateObject,\n  isFunction, isArray,\n  setToStringTag, hasOwnProperty,\n  removeArrayElem, create,\n  getProto, setProto\n} from './utils';\nimport {\n  constructMixinRegex, isInstanceOf,\n  removeWatchers, removeWithParentSignal, cleanProperty,\n  transformRestArgs, calculateArgs, wrapBlock\n} from './helpers/Block';\nimport {\n  D_REST_REGEX,\n  rootBlocks, rootMixins\n} from './constants';\nimport { Mixin } from './Mixin';\n\n/**\n * @typedef {Object} Template\n * @public\n * @property {String[]} vars - Template used vars.\n * @property {Object[]} value - Template itself.\n */\n\n/**\n * @typedef {Object[]} ScopelessTemplate\n * @public\n */\n\n/**\n * @typedef {Error} EvaluationError\n * @public\n * @property {Function} func - Function which caused eval error.\n * @property {String} original - Evaluated expression original js.\n * @property {Block} block - Block in context of which the expression has been evaluated with the error.\n */\n\n/**\n * @callback Watcher\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n */\n\n/**\n * @callback Wrapper\n * @public\n * @param {typeof Block|typeof Mixin} Block class to wrap.\n * @returns {typeof Block} New Block class.\n */\n\n/**\n * @callback AfterUpdate\n * @public\n * @param {*} newValue - New value.\n * @param {*} oldValue - Old value.\n * @param {Mixin} mixin - Mixin instance.\n */\n\n/**\n * @callback BlockRegisterHook\n * @public\n * @param {typeof Block} Block - Registering block.\n * @param {String} name - Block name.\n * @returns Return value is used for registering the block.\n * If Block subclass returned it's registered instead of the initial block, otherwise\n * the initial block is used.\n */\n\n/**\n * @callback MixinRegisterHook\n * @public\n * @param {typeof Mixin} Mixin - Registering mixin.\n * @param {String} name - Mixin name.\n * @returns Return value is used for registering the mixin.\n * If Mixin subclass returned it's registered instead of the initial mixin, otherwise\n * the initial mixin is used.\n */\n\n/**\n * @callback RemoveHook\n * @public\n */\n\nconst blockHooks = [];\nconst mixinHooks = [];\nconst TAG_NAME_REGEX = /^[a-z][a-z\\d\\-_.:!@#$%^&*()[\\]{}='\"\\\\]*$/i;\nconst ATTR_NAME_REGEX = /^[^\\u0000-\\u0020\\s'\">/=]+$/;\nconst toStringTag = '[object Block]';\nconst afterElem = new Elem();\nconst emptyObject = {};\nlet evalMode = false;\nlet gettingVars = [];\n\n/**\n * @class Block\n * @extends null\n * @public\n * @param {Object} opts - Block options.\n * @returns {Block} Instance of Block.\n *\n * @example\n * import { Block, initApp } from 'dwayne';\n *\n * class App extends Block {\n *   static template = '<Hello text=\"{text}\"/> ({ this.times })';\n *\n *   constructor(opts) {\n *     super(opts);\n *\n *     this.text = 'world';\n *     this.times = 0;\n *\n *     this.setInterval();\n *   }\n *\n *   setInterval() {\n *     this.interval = setInterval(() => {\n *       this.times++;\n *     });\n *   }\n *\n *   beforeRemove() {\n *     clearInterval(this.interval);\n *   }\n * }\n *\n * Block.block('App', App);\n * Block.block('Hello', html`Hello, {args.text}!`);\n *\n * initApp('App', document.getElementById('root'));\n */\nclass Block {\n  /**\n   * @member {Object.<String, typeof Block>} Block._blocks\n   * @type {Object.<String, typeof Block>}\n   * @protected\n   * @description Block namespace blocks.\n   */\n  static _blocks = create(rootBlocks);\n\n  /**\n   * @member {Object.<String, typeof Mixin>} Block._mixins\n   * @type {Object.<String, typeof Mixin>}\n   * @protected\n   * @description Block namespace mixins.\n   */\n  static _mixins = create(rootMixins);\n\n  /**\n   * @member {Object} [Block.defaultArgs = null]\n   * @type {Object}\n   * @public\n   * @description Block default args.\n   */\n  static defaultArgs = null;\n\n  /**\n   * @member {Object} [Block.defaultLocals = null]\n   * @type {Object}\n   * @public\n   * @description Block default locals.\n   */\n  static defaultLocals = null;\n\n  /**\n   * @member {Object} [Block.template = { vars: [], value: [] }]\n   * @type {Object}\n   * @public\n   * @description Block template.\n   */\n  static template = {\n    vars: [],\n    value: []\n  };\n\n  /**\n   * @method Block.onEvalError\n   * @public\n   * @param {EvaluationError} err - The method is called when an evaluation error occurs.\n   */\n  static onEvalError(err) {\n    console.error(`Eval error (evaluating \"${ err.original || err.func }\" in context of ${ err.block.$$.name }):`, err);\n  }\n\n  /**\n   * @method Block.beforeRegisterBlock\n   * @public\n   * @param {BlockRegisterHook} hook - Block register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterBlock(hook) {\n    blockHooks.push(hook);\n\n    return () => {\n      removeArrayElem(blockHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.beforeRegisterMixin\n   * @public\n   * @param {MixinRegisterHook} hook - Mixin register hook.\n   * @returns {RemoveHook}\n   */\n  static beforeRegisterMixin(hook) {\n    mixinHooks.push(hook);\n\n    return () => {\n      removeArrayElem(mixinHooks, hook);\n    };\n  }\n\n  /**\n   * @method Block.block\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {Template|ScopelessTemplate|typeof Block} Subclass - Subclass of Block or template string of it.\n   * @returns {typeof Block|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register block in the namespace of this.\n   */\n  static block(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Block, Subclass)) {\n      const constructor = Subclass;\n\n      Subclass = class extends Block {\n        static template = constructor.template;\n\n        constructor(opts) {\n          super(opts);\n          this::constructor(opts);\n        }\n      };\n    }\n\n    if (!isFunction(Subclass) && isArray(Subclass)) {\n      Subclass = class extends Block {\n        static template = {\n          vars: [],\n          value: Subclass\n        };\n      };\n    }\n\n    if (!isFunction(Subclass) && Subclass.vars && Subclass.value) {\n      Subclass = class extends Block {\n        static template = Subclass;\n      };\n    }\n\n    if (!isInstanceOf(Block, Subclass)) {\n      console.warn(`Block must be a template (array or an object from an html loader), a function or a class that extends Block class (name: \"${ name }\") (Block.block)`);\n\n      return;\n    }\n\n    if (rootBlocks[name]) {\n      console.warn(`The \"${ name }\" block is a built-in block so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!TAG_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for blocks so the block will not be registered (Block.block)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_blocks')) {\n      this._blocks = create(getProto(this)._blocks);\n    }\n\n    if (!hasOwnProperty(this, 'defaultLocals')) {\n      this.defaultLocals = {};\n    }\n\n    if (!hasOwnProperty(this, 'defaultArgs')) {\n      this.defaultArgs = create(null);\n    }\n\n    try {\n      Subclass = blockHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Block, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterBlock\" hook:', err);\n    }\n\n    if (isArray(Subclass.template)) {\n      Subclass.template = {\n        vars: [],\n        value: Subclass.template\n      };\n    }\n\n    const {\n      vars,\n      value\n    } = Subclass.template;\n\n    Subclass._blocks = hasOwnProperty(Subclass, '_blocks')\n      ? Subclass._blocks\n      : create(this._blocks);\n    Subclass._mixins = hasOwnProperty(Subclass, '_mixins')\n      ? Subclass._mixins\n      : create(this._mixins);\n\n    if (hasOwnProperty(Subclass, 'defaultArgs')) {\n      setProto(Subclass.defaultArgs, null);\n    }\n\n    this._blocks[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.get\n   * @public\n   * @param {String} name - Block name.\n   * @returns {typeof Block|undefined} Returns registered Block with specified name.\n   */\n  static get(name) {\n    return this._blocks[name];\n  }\n\n  /**\n   * @method Block.getMixin\n   * @public\n   * @param {String} name - Mixin name.\n   * @returns {typeof Mixin|undefined} Returns registered Mixin with specified name.\n   */\n  static getMixin(name) {\n    return this._mixins[name];\n  }\n\n  /**\n   * @method Block.mixin\n   * @public\n   * @param {String} name - Block or mixin name.\n   * @param {typeof Mixin|AfterUpdate} Subclass - Subclass of Mixin or AfterUpdate callback.\n   * @returns {typeof Mixin|undefined} Returns registered Block or undefined if the block hasn't been registered.\n   * @description Register mixin in the namespace of this.\n   */\n  static mixin(name, Subclass) {\n    if (isFunction(Subclass) && !isInstanceOf(Mixin, Subclass)) {\n      const afterUpdate = Subclass;\n\n      Subclass = class extends Mixin {\n        afterUpdate(newValue, oldValue) {\n          this::afterUpdate(newValue, oldValue, this);\n        }\n      };\n    }\n\n    if (!isInstanceOf(Mixin, Subclass)) {\n      console.warn(`The \"${ name }\" class does not extend Mixin or is not an afterUpdate function, so it will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (rootMixins[name] || name === 'd-rest') {\n      console.warn(`The \"${ name }\" mixin is a built-in mixin so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!ATTR_NAME_REGEX.test(name)) {\n      console.warn(`Name \"${ name }\" is not allowed for mixins so the mixin will not be registered (Block.mixin)`);\n\n      return;\n    }\n\n    if (!hasOwnProperty(this, '_mixins')) {\n      this._mixins = create(getProto(this)._mixins);\n    }\n\n    try {\n      Subclass = mixinHooks.reduce((returnValue, hook) => {\n        const currentReturnValue = hook(returnValue, name, this);\n\n        return isInstanceOf(Mixin, currentReturnValue)\n          ? currentReturnValue\n          : returnValue;\n      }, Subclass);\n    } catch (err) {\n      console.error('Uncaught error in \"beforeRegisterMixin\" hook:', err);\n    }\n\n    Subclass._match = constructMixinRegex(name);\n\n    this._mixins[name] = Subclass;\n\n    return Subclass;\n  }\n\n  /**\n   * @method Block.wrap\n   * @public\n   * @param {...Wrapper} wrappers - Functions that return wrapped block.\n   * @returns {typeof Block} New block.\n   * @description Method for wrapping blocks into another blocks.\n   * It is considered best practice to just extends the old block with a new one.\n   *\n   * @example\n   * class MyBlock extends Block {\n   *   static template = '<div>123</div>';\n   * }\n   *\n   * MyBlock.wrap((Block) => {\n   *   return class extends Block {\n   *     static template = `<section class=\"wrapper\">${ Block.template }</section>`;\n   *\n   *     constructor(opts) {\n   *       super(opts);\n   *\n   *       this.additionalVar = 'additional';\n   *     }\n   *   };\n   * });\n   */\n  static wrap(...wrappers) {\n    return wrappers.reduce(wrapBlock, this);\n  }\n\n  constructor(opts) {\n    const {\n      name,\n      args: originalArgs,\n      dBlockName,\n      dBlockArgs,\n      children,\n      parent,\n      parentElem,\n      parentBlock,\n      parentScope,\n      parentTemplate,\n      prevBlock\n    } = opts;\n    const watchersToRemove = [];\n    const constructor = getProto(this).constructor;\n    const childrenBlocks = [];\n    const mixins = [];\n    const isParentBlock = parent instanceof Block;\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#$$\n       * @type {Object}\n       * @protected\n       * @property {Object} Block#$$.args - Private args scope.\n       * @property {Block[]} Block#$$.children - Child blocks.\n       * @property {Elem} Block#$$.content - Content elements.\n       * @property {String|void} Block#$$.dBlockName - d-block name.\n       * @property {Object|void} Block#$$.dBlockName - d-block args.\n       * @property {Block[]} Block#$$.dBlocks - d-block's within the block.\n       * @property {Function} Block#$$.evaluate - Evaluate function.\n       * @property {Object} Block#$$.globals - Private globals scope.\n       * @property {Object[]} Block#$$.htmlChildren - Block html children.\n       * @property {Boolean} Block#$$.isRemoved - If the block is removed.\n       * @property {Boolean} Block#$$.isRendered - If the block is rendered.\n       * @property {Object} Block#$$.locals - Private locals scope.\n       * @property {Mixin[]} Block#$$.mixins - Child mixins.\n       * @property {String} Block#$$.name - Block name.\n       * @property {typeof Block} Block#$$.ns - Block constructor.\n       * @property {Block|Elem|void} Block#$$.parent - Parent block or elem.\n       * @property {Block|void} Block#$$.parentBlock - Parent block.\n       * @property {Elem} parentElem - Parent element.\n       * @property {Block|void} Block#$$.parentScope - Parent scope.\n       * @property {Block|void} Block#$$.parentTemplate - Parent template.\n       * @property {Block|Elem|void} Block#$$.prevBlock - Parent template.\n       * @property {Watcher[]} Block#$$.watchers - Temporary vars watchers.\n       * @property {Object[]} Block#$$.watchersToRemove - Watchers to remove before removing element.\n       */\n      $$: {\n        name,\n        dBlockName,\n        dBlockArgs,\n        dBlocks: [],\n        parent,\n        parentElem,\n        parentScope,\n        parentBlock,\n        parentTemplate,\n        content: new Elem(),\n        ns: constructor,\n        htmlChildren: children || [],\n        children: childrenBlocks,\n        mixins,\n        prevBlock,\n        watchersToRemove,\n        isRemoved: false,\n        isRendered: false,\n        evaluate: (func, onChange, targetBlock, forDElements, forDItem, forDEach) => {\n          if (!isFunction(func)) {\n            return func;\n          }\n\n          forDElements = !!forDElements;\n          forDItem = !!forDItem;\n\n          const scope = (name === '#d-item' && !forDItem) || forDEach\n            ? (forDEach || this).$$.scope\n            : this;\n          const { watchersToRemove } = targetBlock ? targetBlock.$$ : emptyObject;\n          const onChangeFlag = !!onChange;\n\n          const evaluate = () => {\n            let result;\n\n            if (onChangeFlag) {\n              evalMode = true;\n              gettingVars = [];\n            }\n\n            try {\n              result = func(scope);\n            } catch (err) {\n              err.func = func;\n              err.original = func.original;\n              err.block = this;\n\n              if (isFunction(constructor.onEvalError)) {\n                try {\n                  constructor.onEvalError(err);\n                } catch (e) {\n                  console.error(`Uncaught error in ${ name }.onEvalError:`, e);\n                }\n              }\n            }\n\n            if (onChangeFlag) {\n              const localWatchers = [];\n\n              iterateArray(gettingVars, (watchers) => {\n                const watcher = () => {\n                  iterateArray(localWatchers, (watcherBlock) => {\n                    const {\n                      watcher,\n                      watchers\n                    } = watcherBlock;\n\n                    removeArrayElem(watchersToRemove, watcherBlock);\n                    removeArrayElem(watchers, watcher);\n                  });\n\n                  const newResult = evaluate();\n\n                  if (newResult !== result && !targetBlock.$$.isRemoved && !this.$$.isRemoved) {\n                    onChange(newResult, result);\n                  }\n                };\n                const watcherBlock = {\n                  forDElements,\n                  watcher,\n                  watchers\n                };\n\n                localWatchers.push(watcherBlock);\n                watchersToRemove.push(watcherBlock);\n                watchers.push(watcher);\n              });\n\n              evalMode = false;\n              gettingVars = [];\n            }\n\n            return result;\n          };\n\n          return evaluate();\n        },\n        remove: (isParentSignal) => {\n          this.$$.isRemoved = true;\n\n          removeWatchers(watchersToRemove);\n\n          iterateArray(childrenBlocks, removeWithParentSignal);\n          iterateArray(mixins, removeWithParentSignal);\n\n          try {\n            this.beforeRemove();\n          } catch (err) {\n            console.error(`Uncaught error in ${ name }#beforeRemove:`, err);\n          }\n\n          if (!isParentSignal && isParentBlock) {\n            parent.$$.removeContent(this.$$.content);\n          }\n\n          if (!isParentSignal && parentBlock) {\n            removeArrayElem(parentBlock.$$.children, this);\n          }\n\n          this.$$.content.remove();\n        },\n        changeContent: (newContent) => {\n          this.$$.content = newContent;\n\n          if (this.$$.isRendered && !this.$$.isRemoved) {\n            try {\n              this.afterDOMChange();\n            } catch (err) {\n              console.error(`Uncaught error in ${ name }#afterDOMChange:`, err);\n            }\n          }\n        },\n        addContent: (contentToAdd, notRecursive) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToAdd[0].previousSibling) + 1;\n          let newContent;\n\n          if (index === 0) {\n            newContent = contentToAdd.add(oldContent);\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(contentToAdd, oldContent.slice(index));\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && !notRecursive) {\n            parent.$$.addContent(contentToAdd, notRecursive);\n          }\n        },\n        moveContent: (contentToMove, after) => {\n          const oldContent = this.$$.content;\n          const index = oldContent.indexOf(contentToMove[0]);\n          const indexToPut = oldContent.indexOf(after[0]) + 1;\n          let newContent;\n\n          if (indexToPut === 0) {\n            newContent = contentToMove.add(\n              oldContent.slice(indexToPut, index),\n              oldContent.slice(index + contentToMove.length)\n            );\n          } else if (index > indexToPut) {\n            newContent = oldContent\n              .slice(0, indexToPut)\n              .add(\n                contentToMove,\n                oldContent.slice(indexToPut, index),\n                oldContent.slice(index + contentToMove.length)\n              );\n          } else {\n            newContent = oldContent\n              .slice(0, index)\n              .add(\n                oldContent.slice(index + contentToMove.length, indexToPut),\n                contentToMove,\n                oldContent.slice(indexToPut)\n              );\n          }\n\n          this.$$.changeContent(newContent);\n\n          if (isParentBlock && indexToPut) {\n            parent.$$.moveContent(contentToMove, after);\n          }\n        },\n        removeContent: (contentToRemove) => {\n          this.$$.changeContent(this.$$.content.filter((elem) => (\n            contentToRemove.indexOf(elem) === -1\n          )));\n\n          if (isParentBlock) {\n            parent.$$.removeContent(contentToRemove);\n          }\n        },\n        insertInStartOfIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n\n          if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            contentToInsert.insertAfter(prevBlock);\n\n            if (isParentBlock) {\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, true);\n              }\n            }\n          } else if (isParentBlock) {\n            const { prevBlock } = parent.$$;\n\n            if (prevBlock) {\n              let notRecursive;\n\n              if (prevBlock instanceof Block) {\n                after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n                notRecursive = true;\n              } else {\n                after = prevBlock;\n                notRecursive = false;\n                contentToInsert.insertAfter(prevBlock);\n              }\n\n              if (moveFlag) {\n                parent.$$.moveContent(contentToInsert, after);\n              } else {\n                parent.$$.addContent(contentToInsert, notRecursive);\n              }\n            } else {\n              after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n            }\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (moveFlag) {\n            this.$$.moveContent(contentToInsert, after);\n          } else {\n            this.$$.addContent(contentToInsert, true);\n          }\n\n          return after;\n        },\n        insertAfterIt: (contentToInsert, moveFlag) => {\n          const { prevBlock } = this.$$;\n          let after = afterElem;\n          let tryToAddOrMove;\n\n          if (this.$$.content.length) {\n            after = this.$$.content.elem(-1);\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(after);\n          } else if (prevBlock instanceof Block) {\n            after = prevBlock.$$.insertAfterIt(contentToInsert, moveFlag);\n          } else if (prevBlock) {\n            after = prevBlock;\n            tryToAddOrMove = true;\n            contentToInsert.insertAfter(prevBlock);\n          } else if (isParentBlock) {\n            after = parent.$$.insertInStartOfIt(contentToInsert, moveFlag);\n          } else {\n            contentToInsert.into(parentElem, false);\n          }\n\n          if (isParentBlock && tryToAddOrMove) {\n            if (moveFlag) {\n              parent.$$.moveContent(contentToInsert, after);\n            } else {\n              parent.$$.addContent(contentToInsert);\n            }\n          }\n\n          return after;\n        }\n      }\n    });\n\n    iterateObject(constructor.defaultLocals, (value, variable) => {\n      this[variable] = value;\n    });\n    iterateArray(constructor.template.vars, (variable) => {\n      this[variable] = this[variable];\n    });\n\n    const argsObject = create(null);\n    let args = create(constructor.defaultArgs || null);\n    let wasDRest;\n\n    iterateObject(originalArgs, (value, arg) => {\n      const isDRest = D_REST_REGEX.test(arg);\n      const localArgs = isDRest || wasDRest\n        ? create(args)\n        : args;\n\n      args = localArgs;\n\n      if (isDRest) {\n        const restArgs = parentScope.$$.evaluate(value, (value) => {\n          iterateObject(localArgs, cleanProperty);\n          assign(localArgs, transformRestArgs(value));\n          calculateArgs(args, argsObject);\n        }, this);\n\n        wasDRest = true;\n\n        return assign(localArgs, transformRestArgs(restArgs));\n      }\n\n      const isDElements = name === 'd-elements';\n      const forDElements = isDElements && arg === 'value';\n\n      wasDRest = false;\n\n      if (name !== 'd-each' || arg !== 'uid') {\n        value = parentScope.$$.evaluate(value, (value) => {\n          localArgs[arg] = value;\n          calculateArgs(args, argsObject);\n        }, this, forDElements, isDElements && parentBlock.$$.name === '#d-item');\n      }\n\n      localArgs[arg] = value;\n    });\n\n    defineFrozenProperties(this, {\n      /**\n       * @member {Object} Block#args\n       * @type {Object}\n       * @public\n       */\n      args: argsObject,\n\n      /**\n       * @member {Object} Block#globals\n       * @type {Object}\n       * @public\n       */\n      globals: create(\n        parentScope\n          ? parentScope.globals\n          : null\n      )\n    });\n\n    calculateArgs(args, argsObject);\n\n    if (parentBlock) {\n      parentBlock.$$.children.push(this);\n    }\n  }\n\n  /**\n   * @method Block#afterConstruct\n   * @public\n   * @description Is called after block construction (including all scopes)\n   * but before rendering the block and its children.\n   */\n  afterConstruct() {}\n\n  /**\n   * @method Block#afterDOMChange\n   * @public\n   * @description Is called after block DOM structure has changed. Note that\n   * it's important not to modify the DOM structure within the block. You can only insert\n   * elements to empty elements (which Dwayne considers empty) and remove ones from them.\n   */\n  afterDOMChange() {}\n\n  /**\n   * @method Block#afterRender\n   * @public\n   * @description Is called after block has been rendered.\n   */\n  afterRender() {}\n\n  /**\n   * @method Block#beforeRemove\n   * @public\n   * @description Is called before the block removal.\n   */\n  beforeRemove() {}\n\n  /**\n   * @method Block#getDOM\n   * @public\n   * @returns {Elem}\n   * @description Returns DOM contents of the block.\n   */\n  getDOM() {\n    return this.$$.content.slice();\n  }\n\n  /**\n   * @method Block#getName\n   * @public\n   * @returns {String}\n   * @description Returns Block name.\n   */\n  getName() {\n    return this.$$.name;\n  }\n\n  /**\n   * @method Block#getParentElem\n   * @public\n   * @returns {Elem|void}\n   * @description Returns parent Elem.\n   */\n  getParentElem() {\n    return this.$$.parentElem.slice();\n  }\n\n  /**\n   * @method Block#getTopBlock\n   * @public\n   * @returns {Block|void}\n   * @description Returns block in which template the block is located in.\n   */\n  getTopBlock() {\n    return this.$$.parentTemplate;\n  }\n\n  /**\n   * @method Block#evaluate\n   * @public\n   * @param {Function} func - Function to evaluate.\n   * @param {Watcher} [callback] - If present, callback which is called when the expression value is changed.\n   * @param {Block|Mixin} [target = this] - What block or mixin requests the value.\n   * @returns {*} Evaluation result.\n   * @description Method for evaluating an expression in context of the block and watching for the changes.\n   */\n  evaluate(func, callback, target = this) {\n    return this.$$.evaluate(func, callback, target);\n  }\n\n  toString() {\n    return toStringTag;\n  }\n}\n\nsetToStringTag(Block, 'Block');\nsetProto(Block.prototype, null);\n\nexport { Block, gettingVars, evalMode };\n","import { findInArray, isFunction } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchNameArgs = js`args.name`;\nconst watchConstructorArgs = js`args.Constructor`;\n\nclass DBlock extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{ParentScope}\"\n      parentTemplate=\"{ParentTemplate}\"\n    />\n  `;\n\n  afterConstruct(opts) {\n    const {\n      parentScope: {\n        $$: {\n          parentScope: parentParentScope,\n          parentTemplate: parentParentTemplate,\n          htmlChildren: children\n        }\n      },\n      htmlChildren: ownChildren,\n      parentScope,\n      parentTemplate,\n      dBlockName: DBlockName\n    } = this.$$;\n    const {\n      name,\n      Constructor\n    } = this.args;\n    let found;\n\n    this.ParentScope = parentScope;\n    this.ParentTemplate = parentTemplate;\n\n    if (name) {\n      this.constructDynamicNameBlock(\n        this.evaluate(watchNameArgs, this.constructDynamicNameBlock)\n      );\n\n      return;\n    }\n\n    if (Constructor) {\n      this.constructDynamicConstructorBlock(\n        this.evaluate(watchConstructorArgs, this.constructDynamicConstructorBlock)\n      );\n\n      return;\n    }\n\n    if (ownChildren.length) {\n      parentTemplate.$$.dBlocks.push(this);\n\n      return;\n    }\n\n    this.ParentScope = parentParentScope;\n    this.ParentTemplate = parentParentTemplate;\n\n    if (DBlockName) {\n      found = findInArray(children, ({ name: nodeName }) => nodeName === `d-block:${ DBlockName }`);\n\n      if (!found) {\n        found = findInArray(parentTemplate.$$.dBlocks, ({ $$: { dBlockName } }) => dBlockName === DBlockName);\n\n        if (found) {\n          this.ParentScope = parentTemplate;\n          this.ParentTemplate = parentTemplate;\n          found.value = {\n            children: found.value.$$.htmlChildren\n          };\n        }\n      }\n\n      this.elems = found\n        ? found.value.children\n        : null;\n    } else {\n      this.elems = children;\n    }\n  }\n\n  constructDynamicNameBlock = (name) => {\n    const {\n      htmlChildren,\n      dBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      name,\n      attrs: dBlockArgs,\n      children: htmlChildren\n    }];\n  };\n\n  constructDynamicConstructorBlock = (Constructor) => {\n    if (!isFunction(Constructor)) {\n      this.elems = null;\n\n      return;\n    }\n\n    const {\n      htmlChildren,\n      dBlockArgs\n    } = this.$$;\n\n    this.elems = [{\n      Constructor,\n      attrs: dBlockArgs,\n      children: htmlChildren\n    }];\n  };\n}\n\nrootBlocks['d-block'] = DBlock;\n\nexport { DBlock };\n","import { Block } from '../Block';\n\nconst template = html`\n  <d-elements\n    value=\"{$$.htmlChildren}\"\n    parentScope=\"{this}\"\n    parentTemplate=\"{$$.parentTemplate}\"\n  />\n`;\n\nclass DItem extends Block {\n  static template = template;\n}\n\nexport { DItem };\n","import {\n  assign, iterateArray, iterateObject,\n  isArray, isFunction\n} from '../utils';\nimport { remove, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\nimport { DItem } from './d-item';\n\nconst watchArgs = js`[\n  args.set,\n  args.filterBy,\n  args.sortBy\n]`;\n\nrootBlocks['d-each'] = class DEach extends Block {\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args: {\n        item: itemName = '$item',\n        index: indexName = '$index'\n      }\n    } = this;\n\n    assign(this.$$, {\n      itemsByUIDs: {},\n      UID: this.args.uid || undefined,\n      itemName,\n      indexName\n    });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, this.renderSet);\n    this.renderSet();\n  }\n\n  renderSet = () => {\n    const {\n      htmlChildren,\n      itemsByUIDs,\n      parentScope,\n      parentElem,\n      parentTemplate,\n      scope,\n      itemName,\n      indexName,\n      UID\n    } = this.$$;\n    const {\n      args: { sortBy }\n    } = this;\n    const newItemsByUIDs = {};\n    const newUIDsCounter = {};\n    const newUIDs = {};\n    let {\n      set,\n      filterBy\n    } = this.args;\n    const isArr = isArray(set);\n    const iterate = isArr\n      ? iterateArray\n      : iterateObject;\n\n    if (isArr && isFunction(sortBy)) {\n      set = set\n        .slice()\n        .sort(sortBy);\n    }\n\n    if (isFunction(filterBy)) {\n      filterBy = [filterBy];\n    }\n\n    if (isArray(filterBy)) {\n      iterateArray(filterBy, (filter) => {\n        set = set.filter(filter);\n      });\n    }\n\n    iterate(set, (item, index) => {\n      scope[itemName] = item;\n      scope[indexName] = index;\n\n      const uid = parentScope.$$.evaluate(UID, null, null, false, false, this);\n\n      newUIDsCounter[uid] = (newUIDsCounter[uid] || 0) + 1;\n      newUIDs[index] = uid;\n    });\n\n    scope[itemName] = null;\n    scope[indexName] = null;\n\n    iterateObject(itemsByUIDs, (items, uid) => {\n      if (!newUIDsCounter[uid]) {\n        iterateArray(items, remove);\n\n        return;\n      }\n\n      iterateArray(items.splice(newUIDsCounter[uid]), remove);\n    });\n\n    let prevBlock;\n\n    iterate(set, (item, index) => {\n      const uid = newUIDs[index];\n      let block;\n\n      if (itemsByUIDs[uid] && itemsByUIDs[uid].length) {\n        block = itemsByUIDs[uid].shift();\n        block.$$.scope[indexName] = index;\n        block.$$.scope[itemName] = item;\n\n        const {\n          prevBlock: prevPrevBlock\n        } = block.$$;\n\n        if (prevPrevBlock && prevPrevBlock !== prevBlock) {\n          const { content } = block.$$;\n\n          if (prevBlock) {\n            prevBlock.$$.insertAfterIt(content, true);\n          } else {\n            this.$$.insertInStartOfIt(content, true);\n          }\n        }\n      } else {\n        block = createBlock({\n          node: {\n            itemName,\n            indexName,\n            item,\n            index,\n            name: '#d-item',\n            Constructor: DItem,\n            children: htmlChildren\n          },\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      }\n\n      (newItemsByUIDs[uid] = newItemsByUIDs[uid] || []).push(block);\n      block.$$.prevBlock = prevBlock;\n      prevBlock = block;\n    });\n\n    this.$$.itemsByUIDs = newItemsByUIDs;\n  };\n};\n","import { iterateArray, removeArrayElem } from '../utils';\nimport { removeWithParentSignal, createBlock } from '../helpers/Block';\nimport { Block } from '../Block';\nimport { Elem } from '../Elem';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`args.value`;\n\nrootBlocks['d-elements'] = class DElements extends Block {\n  afterConstruct() {\n    const { parentElem } = this.$$;\n    const {\n      parentScope,\n      parentTemplate\n    } = this.args;\n\n    this.$$.evaluate(watchArgs, (value) => {\n      const {\n        children,\n        mixins,\n        parent,\n        watchersToRemove,\n        content\n      } = this.$$;\n\n      iterateArray(children, removeWithParentSignal);\n      iterateArray(mixins, removeWithParentSignal);\n      content.remove();\n\n      if (parent instanceof Block) {\n        parent.$$.removeContent(content);\n      }\n\n      this.$$.children = [];\n      this.$$.mixins = [];\n      this.$$.watchersToRemove = watchersToRemove.filter(({ watchers, watcher, forDElements }) => {\n        if (forDElements) {\n          return true;\n        }\n\n        removeArrayElem(watchers, watcher);\n      });\n      this.$$.content = new Elem();\n\n      let prevBlock;\n\n      iterateArray(value || [], (child) => {\n        prevBlock = createBlock({\n          node: child,\n          parent: this,\n          parentElem,\n          parentBlock: this,\n          parentScope,\n          parentTemplate,\n          prevBlock\n        });\n      });\n    }, this, true);\n  }\n};\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nrootBlocks['d-if'] = class DIf extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      parentScope,\n      htmlChildren\n    } = this.$$;\n    let index = Infinity;\n    const values = htmlChildren.map((child, i) => {\n      const {\n        name,\n        attrs = {},\n        children\n      } = child;\n      let cond = attrs.if;\n\n      if (name !== 'd-else' && cond) {\n        cond = parentScope.$$.evaluate(cond, (newValue) => {\n          if (!!newValue === values[i]) {\n            return;\n          }\n\n          values[i] = !!newValue;\n\n          if (i > index) {\n            return;\n          }\n\n          if (i < index && newValue) {\n            index = i;\n            this.elems = children;\n\n            return;\n          }\n\n          const found = findInArray(values, Boolean);\n\n          if (found) {\n            index = found.key;\n            this.elems = htmlChildren[found.key].children;\n          } else {\n            index = Infinity;\n            this.elems = null;\n          }\n        }, this);\n      } else {\n        cond = true;\n      }\n\n      if (cond && index === Infinity) {\n        index = i;\n        this.elems = children;\n      }\n\n      return !!cond;\n    });\n  }\n};\n","import { findInArray } from '../utils';\nimport { Block } from '../Block';\nimport { rootBlocks } from '../constants';\n\nconst watchArgs = js`[\n  args.value,\n  args.compareFn\n]`;\n\nrootBlocks['d-switch'] = class DSwitch extends Block {\n  static template = html`\n    <d-elements\n      value=\"{elems}\"\n      parentScope=\"{$$.parentScope}\"\n      parentTemplate=\"{$$.parentTemplate}\"\n    />\n  `;\n  static defaultArgs = {\n    compareFn(switchValue, caseValue) {\n      return (\n        switchValue === caseValue\n        || (switchValue !== switchValue && caseValue !== caseValue)\n      );\n    }\n  };\n\n  index = Infinity;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      $$: {\n        htmlChildren,\n        parentScope\n      },\n      args,\n      args: { value }\n    } = this;\n\n    this.values = htmlChildren.map((child, i) => {\n      const {\n        name,\n        attrs = {},\n        children\n      } = child;\n      let val;\n\n      if (name !== 'd-default') {\n        val = parentScope.$$.evaluate(attrs.if, (newValue) => {\n          this.values[i].value = newValue;\n\n          if (i > this.index) {\n            return;\n          }\n\n          const found = findInArray(this.values, ({ name, value }) => (\n            name === 'd-default'\n            || this.args.compareFn(args.value, value)\n          ));\n\n          this.index = found\n            ? found.key\n            : Infinity;\n          this.elems = found\n            ? found.value.children\n            : null;\n        }, this);\n      }\n\n      if (this.index === Infinity && (\n        name === 'd-default'\n        || this.args.compareFn(value, val)\n      )) {\n        this.index = i;\n        this.elems = children;\n      }\n\n      return {\n        name,\n        children,\n        value: val\n      };\n    });\n  }\n\n  afterConstruct() {\n    this.evaluate(watchArgs, () => {\n      const {\n        value: newValue,\n        compareFn\n      } = this.args;\n\n      this.index = Infinity;\n\n      this.values.some(({ name, value, children }, i) => {\n        if (\n          name === 'd-default'\n          || compareFn(newValue, value)\n        ) {\n          this.index = i;\n          this.elems = children;\n\n          return true;\n        }\n      });\n\n      if (this.index === Infinity) {\n        this.elems = null;\n      }\n    });\n  }\n};\n","import { collectFromObject, iterateObject, keys } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-attr'] = class DAttr extends Mixin {\n  attrs = {};\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      attrs\n    } = this;\n\n    if (args) {\n      newValue = collectFromObject(args, (attrs, attr) => {\n        attrs[attr] = newValue;\n      });\n    }\n\n    iterateObject(attrs, (value, prop) => {\n      if (!(prop in newValue)) {\n        elem.removeAttr(prop);\n      }\n    });\n    elem.attr(newValue);\n\n    this.attrs = newValue;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      attrs\n    } = this;\n\n    elem.removeAttr.apply(elem, keys(attrs));\n  }\n};\n\n","import { isFunction, noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-bind'] = class DBind extends Mixin {\n  off = noop;\n\n  afterUpdate(value) {\n    this.off();\n\n    if (!isFunction(value)) {\n      return;\n    }\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), value);\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-bind\" mixin with an event names (like \"d-bind(click)\" or \"d-bind(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove() {\n    this.off();\n  }\n};\n","import {\n  isArray, isString,\n  iterateArray, iterateObject\n} from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nconst EMPTY_SPACE_REGEX = /\\s+/;\n\nrootMixins['d-class'] = class DClass extends Mixin {\n  classes = [];\n\n  afterUpdate(newValue) {\n    const {\n      elem,\n      args,\n      classes\n    } = this;\n    const newClasses = [];\n\n    if (args) {\n      newValue = newValue\n        ? args\n        : [];\n    }\n\n    if (isString(newValue)) {\n      newValue = newValue.split(EMPTY_SPACE_REGEX);\n    }\n\n    if (isArray(newValue)) {\n      iterateArray(classes, (cls) => {\n        if (newValue.indexOf(cls) === -1) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateArray(newValue, (cls) => {\n        if (isString(cls)) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    } else {\n      iterateArray(classes, (cls) => {\n        if (!newValue || !newValue[cls]) {\n          elem.removeClass(cls);\n        }\n      });\n      iterateObject(newValue, (val, cls) => {\n        if (val) {\n          newClasses.push(cls);\n          elem.addClass(cls);\n        }\n      });\n    }\n\n    this.classes = newClasses;\n  }\n\n  beforeRemove() {\n    const {\n      elem,\n      classes\n    } = this;\n\n    elem.removeClass.apply(elem, classes);\n  }\n};\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-elem'] = class DElem extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      elem\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(elem);\n    } else if (isString(value)) {\n      scope[value] = elem;\n    }\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nclass DHide extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.hide();\n    } else {\n      elem.show();\n    }\n  }\n\n  beforeRemove() {\n    this.elem.show();\n  }\n}\n\nrootMixins['d-hide'] = DHide;\n\nexport { DHide };\n","import { isFunction, isString } from '../utils';\nimport { Block } from '../Block';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-node'] = class DNode extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    const {\n      args,\n      parentTemplate,\n      node\n    } = this;\n    let scope = parentTemplate;\n    let value = this.evaluate();\n\n    if (args) {\n      scope = value instanceof Block\n        ? value\n        : parentTemplate;\n      value = args[0];\n    }\n\n    if (isFunction(value)) {\n      value(node);\n    } else if (isString(value)) {\n      scope[value] = node;\n    }\n  }\n};\n","import { noop } from '../utils';\nimport { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-on'] = class DOn extends Mixin {\n  static evaluate = false;\n\n  constructor(opts) {\n    super(opts);\n\n    if (this.args) {\n      this.off = this.elem.on(this.args.join(','), () => {\n        this.evaluate();\n      });\n    } else {\n      this.off = noop;\n\n      console.error('Provide \"d-on\" mixin with an event names (like \"d-on(click)\" or \"d-on(keyup, keypress)\")!');\n    }\n  }\n\n  beforeRemove() {\n    this.off();\n  }\n};\n","import { Mixin } from '../Mixin';\nimport { rootMixins } from '../constants';\n\nrootMixins['d-show'] = class DShow extends Mixin {\n  afterUpdate(value) {\n    const { elem } = this;\n\n    if (value) {\n      elem.show();\n    } else {\n      elem.hide();\n    }\n  }\n\n  beforeRemove() {\n    this.elem.show();\n  }\n};\n","import { iterateObject } from '../../utils';\nimport { rootMixins } from '../../constants';\nimport { constructMixinRegex } from './constructMixinRegex';\n\niterateObject(rootMixins, (Mixin, name) => {\n  Mixin._match = constructMixinRegex(name);\n});\n","import { Elem } from './Elem';\nimport { createHideStyleNode } from './helpers/Elem';\nimport { document } from './constants';\n\n/**\n * @const {Elem} doc\n * @type {Elem}\n * @public\n * @description Elem instance of document.\n */\nexport const doc = new Elem(document);\n\n/**\n * @const {Elem} html\n * @type {Elem}\n * @public\n * @description Elem instance of document.documentElement.\n */\nexport const html = new Elem(document.documentElement);\n\n/**\n * @const {Elem} body\n * @type {Elem}\n * @public\n * @description Elem instance of document.body.\n */\nexport const body = new Elem(document.body);\n\n/**\n * @const {Elem} head\n * @type {Elem}\n * @public\n * @description Elem instance of document.head.\n */\nexport const head = new Elem(document.head);\n\ncreateHideStyleNode(head);\n"],"names":["collectFromArray","array","callback","initialValue","value","index","findInArray","i","length","iterateArray","removeArrayElem","elem","indexOf","splice","toObjectKeys","addKey","vars","variable","assign","target","arguments","source","key","collectFromObject","object","except","newObject","paths","slice","hasOwnProperty","has","iterateObject","mapObject","definePrototypeProperties","properties","name","defineProperty","defineFrozenProperties","toStringTag","toString","setToStringTag","klass","tag","Symbol","prototype","isFunction","isNil","isString","escapeRegex","string","replace","regexpSpecialsRegexp","noop","toCamelCase","DASHED_SYMBOL_REGEX","capitalize","toHyphenCase","UPPERCASED_SYMBOL_REGEX","hyphenize","match","toUpperCase","toLowerCase","addAttr","attrs","attr","addCSSProp","css","property","split","CSS_PROP_VALUE_SEPARATOR_REGEX","addDataAttr","data","addNext","add","nextSibling","addParent","parentNode","addPrev","previousSibling","createHideStyleNode","head","find","HIDE_CLASS","create","prop","text","getAttrNS","isXmlNs","nodeName","Null","XML_NS","X_LINK_ATTR_FIND_REGEX","test","Elem","closest","X_LINK_NS","X_LINK_ATTR_REPLACE_REGEX","isDocument","DOCUMENT_REGEX","isElem","isElementsCollection","HTML_COLLECTION_REGEX","isArray","isValidNode","ELEMENT_REGEX","getEvent","event","bubbles","cancelable","realDetails","finalEvent","EVENT_REGEX","Event","err","document","ownerDocument","createEvent","initEvent","hide","addClass","getMatchesFunction","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","this","querySelectorAll","remove","parent","removeChild","show","removeClass","toElem","base","String","calculateArgs","args","argsObject","keys","arg","undefined","cleanProperty","constructMixinRegex","RegExp","mixinMatch","mixins","Mixin","localMatch","_match","argsMatch","COMMA_REGEX","transformRestAttrs","mixinDefaultOpts","eventualAttrs","D_REST_REGEX","transformRestArgs","addArgs","executeMixinWatchers","mixin","oldValue","$$","watchers","watcher","createMixin","dynamic","comment","parentBlock","parentScope","parentTemplate","evaluate","newValue","afterUpdate","error","calculateAttrs","attrsObject","firstTime","type","removeAttr","opts","nextType","nextDynamic","nextValue","prevType","prevValue","isDynamic","evaluated","buildMixin","firstValue","push","constructPrivateScope","scope","globals","removeTempWatcher","removeWatchers","watchersToRemove","removeWatcher","constructPublicScope","scopeValues","privateScope","evalMode","gettingVars","oldTempWatchers","createBlock","node","parentElem","prevBlock","doc","namespaceURI","SVG_NS","localBlocks","ns","_blocks","Block","localMixins","_mixins","children","constructor","Constructor","dBlockMatch","dBlockName","dBlockArgs","NAMED_D_BLOCK_REGEX","blockInstance","element","currentAttrs","wasDRest","isDRest","localAttrs","restAttrs","createMixins","content","contentDocument","documentElement","child","isParentBlock","insertAfterIt","insertAfter","addContent","insertInStartOfIt","into","Args","locals","html","template","itemName","item","indexName","afterConstruct","isRendered","afterRender","isInstanceOf","Class","Subclass","isPrototypeOf","removeWithParentSignal","wrapBlock","block","wrapper","returnValue","wrapMixin","constructStyleFromString","style","CSS_STYLE_SEPARATOR_REGEX","trim","getProp","hasAttr","getValueForSetting","inputValue","isRadio","getValueForGetting","values","options","init","isMultiple","addValue","concat","getListenerName","selected","insertTemplates","templates","iterateAndChangeChildren","nodes","trimmed","newTemplates","newTemplate","newVars","initApp","container","Error","rootBlock","removeApp","DwayneRootBlock","defineProperties","Object","window","global","self","getProto","getPrototypeOf","setProto","setPrototypeOf","proto","__proto__","rootBlocks","rootMixins","Array","regexpSpecialCharacters","map","s","join","CSS_IMPORTANT_REGEX","emptyCollection","_this","includes","methodName","method","elems","forEach","list","classList","cls","attributes","getAttributeNS","getAttribute","setAttributeNS","setAttribute","childNodes","collect","is","elements","cb","contains","el","isText","createTextNode","createComment","createElementNS","createElement","getPropertyValue","getPropertyPriority","removeCSS","removeProperty","setProperty","cssText","dataset","details","dispatchEvent","filter","hasAttributeNS","hasAttribute","innerHTML","next","insertBefore","appendChild","end","firstChild","listener","newEvents","allListeners","listeners","addEventListener","removeEventListener","removeListeners","removeListener","removeAttributeNS","removeAttribute","first","prev","babelHelpers.get","apply","textContent","condition","_arguments5","toggle","_arguments6","species","_value","currentValue","isParentSignal","isRemoved","beforeRemove","wrappers","reduce","isElementRemoved","blockHooks","mixinHooks","TAG_NAME_REGEX","ATTR_NAME_REGEX","afterElem","emptyObject","originalArgs","childrenBlocks","func","onChange","targetBlock","forDElements","forDItem","forDEach","onChangeFlag","result","original","onEvalError","e","localWatchers","watcherBlock","newResult","_this7","removeContent","newContent","afterDOMChange","contentToAdd","notRecursive","oldContent","changeContent","contentToMove","after","indexToPut","moveContent","contentToRemove","contentToInsert","moveFlag","tryToAddOrMove","defaultLocals","defaultArgs","localArgs","restArgs","isDElements","hook","warn","currentReturnValue","watchNameArgs","watchConstructorArgs","DBlock","constructDynamicNameBlock","htmlChildren","constructDynamicConstructorBlock","parentParentScope","parentParentTemplate","ownChildren","DBlockName","found","ParentScope","ParentTemplate","dBlocks","DItem","watchArgs","uid","renderSet","_this2","itemsByUIDs","UID","sortBy","newItemsByUIDs","newUIDsCounter","newUIDs","set","filterBy","isArr","iterate","sort","items","shift","prevPrevBlock","Infinity","cond","if","Boolean","val","compareFn","some","switchValue","caseValue","off","on","classes","newClasses","DHide","initialScopeValue","setProp","initialElemValue","isInitialScopeValueNull","isCheckbox","changeScope","offElemListener","offFormListener","option","body"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHdheW5lLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvYXJyYXkuanMiLCIuLi9zcmMvdXRpbHMvb2JqZWN0LmpzIiwiLi4vc3JjL3V0aWxzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vc3JjL3V0aWxzL3RvU3RyaW5nVGFnLmpzIiwiLi4vc3JjL3V0aWxzL2lzLmpzIiwiLi4vc3JjL3V0aWxzL2VzY2FwZVJlZ2V4LmpzIiwiLi4vc3JjL3V0aWxzL25vb3AuanMiLCIuLi9zcmMvdXRpbHMvdG9DYXNlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRBdHRyLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRDU1NQcm9wLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGREYXRhQXR0ci5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkTmV4dC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vYWRkUGFyZW50LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9hZGRQcmV2LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9jcmVhdGVIaWRlU3R5bGVOb2RlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRBdHRyTlMuanMiLCIuLi9zcmMvaGVscGVycy9FbGVtL2lzLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9nZXRFdmVudC5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vaGlkZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vbWF0Y2hlcy5qcyIsIi4uL3NyYy9oZWxwZXJzL0VsZW0vcmVtb3ZlLmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS9zaG93LmpzIiwiLi4vc3JjL2hlbHBlcnMvRWxlbS90b0VsZW0uanMiLCIuLi9zcmMvZmluZC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NhbGN1bGF0ZUFyZ3MuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jbGVhblByb3BlcnR5LmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0TWl4aW5SZWdleC5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL21peGluTWF0Y2guanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay90cmFuc2Zvcm1SZXN0QXR0cnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9leGVjdXRlTWl4aW5XYXRjaGVycy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2NyZWF0ZU1peGluLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY2FsY3VsYXRlQXR0cnMuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jb25zdHJ1Y3RQcml2YXRlU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9yZW1vdmVXYXRjaGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQmxvY2svY29uc3RydWN0UHVibGljU2NvcGUuanMiLCIuLi9zcmMvaGVscGVycy9CbG9jay9jcmVhdGVCbG9jay5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL2lzSW5zdGFuY2VPZi5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlbW92ZS5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3dyYXAuanMiLCIuLi9zcmMvbWl4aW5zL2Qtc3R5bGUuanMiLCIuLi9zcmMvbWl4aW5zL2QtdmFsdWUuanMiLCIuLi9zcmMvaW5zZXJ0VGVtcGxhdGVzLmpzIiwiLi4vc3JjL2luaXRBcHAuanMiLCIuLi9zcmMvcmVtb3ZlQXBwLmpzIiwiLi4vc3JjL2dsb2JhbC5qcyIsIi4uL3NyYy91dGlscy9vYmplY3RTdGF0aWNzLmpzIiwiLi4vc3JjL2NvbnN0YW50cy5qcyIsIi4uL3NyYy9FbGVtLmpzIiwiLi4vc3JjL3V0aWxzL3NldFN5bWJvbFNwZWNpZXMuanMiLCIuLi9zcmMvTWl4aW4uanMiLCIuLi9zcmMvQmxvY2suanMiLCIuLi9zcmMvYmxvY2tzL2QtYmxvY2suanMiLCIuLi9zcmMvYmxvY2tzL2QtaXRlbS5qcyIsIi4uL3NyYy9ibG9ja3MvZC1lYWNoLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWVsZW1lbnRzLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLWlmLmpzIiwiLi4vc3JjL2Jsb2Nrcy9kLXN3aXRjaC5qcyIsIi4uL3NyYy9taXhpbnMvZC1hdHRyLmpzIiwiLi4vc3JjL21peGlucy9kLWJpbmQuanMiLCIuLi9zcmMvbWl4aW5zL2QtY2xhc3MuanMiLCIuLi9zcmMvbWl4aW5zL2QtZWxlbS5qcyIsIi4uL3NyYy9taXhpbnMvZC1oaWRlLmpzIiwiLi4vc3JjL21peGlucy9kLW5vZGUuanMiLCIuLi9zcmMvbWl4aW5zL2Qtb24uanMiLCIuLi9zcmMvbWl4aW5zL2Qtc2hvdy5qcyIsIi4uL3NyYy9oZWxwZXJzL0Jsb2NrL3JlZ2lzdGVyQnVpbHRpbnMuanMiLCIuLi9zcmMvZWxlbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tQXJyYXkoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUgPSB7fSkge1xuICBpdGVyYXRlQXJyYXkoYXJyYXksICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjYWxsYmFjayhpbml0aWFsVmFsdWUsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICB9KTtcblxuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVBcnJheShhcnJheSwgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXJyYXlFbGVtKGFycmF5LCBlbGVtKSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYmplY3RLZXlzKGFycmF5KSB7XG4gIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KGFycmF5LCBhZGRLZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRLZXkodmFycywgdmFyaWFibGUpIHtcbiAgdmFyc1t2YXJpYWJsZV0gPSB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZUFycmF5IH0gZnJvbSAnLi9hcnJheSc7XG5cbmNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc1xufSA9IHt9O1xuY29uc3QgeyBzbGljZSB9ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChzb3VyY2UsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSA9IHt9KSB7XG4gIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGNhbGxiYWNrKGluaXRpYWxWYWx1ZSwgdmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VwdChvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG4gIGNvbnN0IHBhdGhzID0gYXJndW1lbnRzOjpzbGljZSgxKTtcblxuICBpdGVyYXRlT2JqZWN0KG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAocGF0aHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0OjpoYXMoa2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVPYmplY3Qob2JqZWN0LCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG5cbiAgaXRlcmF0ZU9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgbmV3T2JqZWN0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICB9KTtcblxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuIiwiaW1wb3J0IHsgaXRlcmF0ZU9iamVjdCB9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcGVydGllcykge1xuICBpdGVyYXRlT2JqZWN0KHByb3BlcnRpZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gZGVmaW5lRnJvemVuUHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRhcmdldCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgbmVlZGVkIHRvIGJlIGFzc2lnbiB0byB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gZm9yIGRlZmluaW5nIGZyb3plbiBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUZyb3plblByb3BlcnRpZXModGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGl0ZXJhdGVPYmplY3QocHJvcGVydGllcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgdmFsdWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIH0gZnJvbSAnLi9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBTeW1ib2wgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB7IHRvU3RyaW5nIH0gPSB7fTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdG9TdHJpbmdUYWdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGdldCB0b1N0cmluZ1RhZyBvZi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEN1dCBzdHJpbmcuXG4gKiBAZGVzY3JpcHRpb24gQ3V0IFwiVHlwZVwiIHN0cmluZyBmcm9tIFwiW29iamVjdCBUeXBlXVwiIHN0cmluZyB0aGF0IGdvdHRlbiBmcm9tIHt9LnRvU3RyaW5nLGNhbGwob2JqZWN0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0Ojp0b1N0cmluZygpLnNsaWNlKDgsIC0xKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKGtsYXNzLCB0YWcpIHtcbiAgaWYgKFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMoa2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogdGFnXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2NoZWNrVHlwZXNcbiAqIEBwcml2YXRlXG4gKiBAbWl4aW5cbiAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIGlzPFR5cGU+IG1ldGhvZHMuXG4gKi9cblxuaW1wb3J0IHsgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3RvU3RyaW5nVGFnJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNBcnJheVxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGFycmF5LlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvciBub3QuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBpc0FycmF5KFtdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzQXJyYXkoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNBcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpOyAvLyBmYWxzZVxuICovXG5leHBvcnQgY29uc3QgeyBpc0FycmF5IH0gPSBBcnJheTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogXG4gKiBAZXhhbXBsZVxuICogaXNGdW5jdGlvbigoKSA9PiB7fSk7ICAgICAgICAgICAgLy8gdHJ1ZVxuICogXG4gKiBjb25zdCBmdW5jID0gKCkgPT4ge307XG4gKiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZnVuYywge30pO1xuICogaXNGdW5jdGlvbihmdW5jKTsgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNOaWxcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc05pbChudWxsKTsgICAgICAvLyB0cnVlXG4gKiBpc05pbCh1bmRlZmluZWQpOyAvLyB0cnVlXG4gKiBpc05pbChmYWxzZSk7ICAgICAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcgb3Igbm90LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc1N0cmluZygnMCcpOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1N0cmluZyhuZXcgU3RyaW5nKCcwJykpOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmdUYWcodmFsdWUpID09PSAnU3RyaW5nJztcbn1cbiIsImNvbnN0IHJlZ2V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gW1xuICAnLicsXG4gICcrJywgJyonLCAnPycsXG4gICcoJywgJyknLFxuICAnWycsICddJyxcbiAgJ3snLCAnfScsXG4gICc8JywgJz4nLFxuICAnXicsICckJyxcbiAgJyEnLFxuICAnPScsXG4gICc6JyxcbiAgJy0nLFxuICAnfCcsXG4gICcsJyxcbiAgJ1xcXFwnXG5dO1xuY29uc3QgcmVnZXhwU3BlY2lhbHNSZWdleHAgPSBuZXcgUmVnRXhwKFxuICByZWdleHBTcGVjaWFsQ2hhcmFjdGVyc1xuICAgIC5tYXAoKHMpID0+IGBcXFxcJHsgcyB9YClcbiAgICAuam9pbignfCcpLFxuICAnZydcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4cFNwZWNpYWxzUmVnZXhwLCAnXFxcXCQmJyk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJjb25zdCBEQVNIRURfU1lNQk9MX1JFR0VYID0gLy1bYS16XS9nO1xuY29uc3QgVVBQRVJDQVNFRF9TWU1CT0xfUkVHRVggPSAvW0EtWl0vZztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKERBU0hFRF9TWU1CT0xfUkVHRVgsIGNhcGl0YWxpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IeXBoZW5DYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYLCBoeXBoZW5pemUpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBoeXBoZW5pemUobWF0Y2gpIHtcbiAgcmV0dXJuIGAtJHsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSB9YDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRBdHRyKGF0dHJzLCBhdHRyKSB7XG4gIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xufVxuIiwiaW1wb3J0IHsgdG9DYW1lbENhc2UgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IENTU19QUk9QX1ZBTFVFX1NFUEFSQVRPUl9SRUdFWCA9IC86IC87XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDU1NQcm9wKGNzcywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZS5zcGxpdChDU1NfUFJPUF9WQUxVRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gICAgY3NzW3RvQ2FtZWxDYXNlKHByb3BlcnR5WzBdKV0gPSBwcm9wZXJ0eVsxXTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZERhdGFBdHRyKGRhdGEsIHZhbHVlLCBrZXkpIHtcbiAgZGF0YVtrZXldID0gdmFsdWU7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkTmV4dChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ubmV4dFNpYmxpbmcpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZFBhcmVudChhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucGFyZW50Tm9kZSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYWRkUHJldihhZGQsIGVsZW0pIHtcbiAgYWRkKGVsZW0ucHJldmlvdXNTaWJsaW5nKTtcbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGlkZVN0eWxlTm9kZShoZWFkKSB7XG4gIGNvbnN0IHN0eWxlID0gaGVhZC5maW5kKGBzdHlsZSMkeyBISURFX0NMQVNTIH1gKTtcblxuICBpZiAoc3R5bGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGVhZFxuICAgIC5jcmVhdGUoJ3N0eWxlJylcbiAgICAucHJvcCgnaWQnLCBISURFX0NMQVNTKVxuICAgIC50ZXh0KGAuJHsgSElERV9DTEFTUyB9e2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50O31gKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuY29uc3QgWF9MSU5LX0FUVFJfRklORF9SRUdFWCA9IC9eeGxpbms6XFx3LztcbmNvbnN0IFhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVggPSAvXnhsaW5rOi87XG5jb25zdCBYTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgWF9MSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgTnVsbCA9IHtcbiAgbnM6IG51bGxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyTlMoYXR0ciwgZWxlbSkge1xuICBjb25zdCBpc1htbE5zID0gYXR0ciA9PT0gJ3htbG5zJztcblxuICBpZiAoaXNYbWxOcyB8fCBhdHRyID09PSAneG1sbnM6eGxpbmsnKSB7XG4gICAgaWYgKGVsZW0ubm9kZU5hbWUgIT09ICdTVkcnKSB7XG4gICAgICByZXR1cm4gTnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbnM6IFhNTF9OUyxcbiAgICAgIG5hbWU6IGlzWG1sTnNcbiAgICAgICAgPyAneG1sbnMnXG4gICAgICAgIDogJ3hsaW5rJ1xuICAgIH07XG4gIH1cblxuICBpZiAoWF9MSU5LX0FUVFJfRklORF9SRUdFWC50ZXN0KGF0dHIpKSB7XG4gICAgaWYgKCFuZXcgRWxlbShlbGVtKS5jbG9zZXN0KCdzdmcnKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBOdWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuczogWF9MSU5LX05TLFxuICAgICAgbmFtZTogYXR0ci5yZXBsYWNlKFhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVgsICcnKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gTnVsbDtcbn1cbiIsImltcG9ydCB7IHRvU3RyaW5nVGFnLCBpc0FycmF5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5jb25zdCBIVE1MX0NPTExFQ1RJT05fUkVHRVggPSAvXihIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdCkkLztcbmNvbnN0IERPQ1VNRU5UX1JFR0VYID0gL0RvY3VtZW50JC87XG5jb25zdCBFTEVNRU5UX1JFR0VYID0gL0VsZW1lbnQkLztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIERPQ1VNRU5UX1JFR0VYLnRlc3QodG9TdHJpbmdUYWcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50c0NvbGxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBIVE1MX0NPTExFQ1RJT05fUkVHRVgudGVzdCh0b1N0cmluZ1RhZyh2YWx1ZSkpXG4gICAgfHwgaXNFbGVtKHZhbHVlKVxuICAgIHx8IGlzQXJyYXkodmFsdWUpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTm9kZSh2YWx1ZSkge1xuICBjb25zdCB0YWcgPSB0b1N0cmluZ1RhZyh2YWx1ZSk7XG5cbiAgcmV0dXJuIChcbiAgICBFTEVNRU5UX1JFR0VYLnRlc3QodGFnKVxuICAgIHx8IERPQ1VNRU5UX1JFR0VYLnRlc3QodGFnKVxuICAgIHx8IHRhZyA9PT0gJ1RleHQnXG4gICAgfHwgdGFnID09PSAnRG9jdW1lbnRGcmFnbWVudCdcbiAgICB8fCB0YWcgPT09ICdDb21tZW50J1xuICApO1xufVxuIiwiaW1wb3J0IHsgYXNzaWduLCB0b1N0cmluZ1RhZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGlzRG9jdW1lbnQgfSBmcm9tICcuL2lzJztcblxuY29uc3QgRVZFTlRfUkVHRVggPSAvRXZlbnQkLztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50LCBidWJibGVzLCBjYW5jZWxhYmxlLCByZWFsRGV0YWlscywgZWxlbSkge1xuICBsZXQgZmluYWxFdmVudCA9IGV2ZW50O1xuXG4gIGlmICghRVZFTlRfUkVHRVgudGVzdCh0b1N0cmluZ1RhZyhmaW5hbEV2ZW50KSkpIHtcbiAgICB0cnkge1xuICAgICAgZmluYWxFdmVudCA9IG5ldyBFdmVudChmaW5hbEV2ZW50LCB7IGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG4gICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KGVsZW0pXG4gICAgICAgID8gZWxlbVxuICAgICAgICA6IGVsZW0ub3duZXJEb2N1bWVudDtcblxuICAgICAgZmluYWxFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZmluYWxFdmVudC5pbml0RXZlbnQoZXZlbnQsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG4gICAgICBhc3NpZ24oZmluYWxFdmVudCwgcmVhbERldGFpbHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbEV2ZW50O1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlSGlkZVN0eWxlTm9kZSB9IGZyb20gJy4vY3JlYXRlSGlkZVN0eWxlTm9kZSc7XG5pbXBvcnQgeyBISURFX0NMQVNTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGUoZWxlbSkge1xuICBjcmVhdGVIaWRlU3R5bGVOb2RlKG5ldyBFbGVtKGVsZW0ub3duZXJEb2N1bWVudC5oZWFkKSk7XG4gIG5ldyBFbGVtKGVsZW0pLmFkZENsYXNzKEhJREVfQ0xBU1MpO1xufVxuIiwiaW1wb3J0IHsgaXNEb2N1bWVudCB9IGZyb20gJy4vaXMnO1xuXG5jb25zdCB7IGluZGV4T2YgfSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF0Y2hlc0Z1bmN0aW9uKGVsZW0pIHtcbiAgcmV0dXJuIChcbiAgICBlbGVtLm1hdGNoZXNcbiAgICB8fCBlbGVtLm1hdGNoZXNTZWxlY3RvclxuICAgIHx8IGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICB8fCBlbGVtLm1zTWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgZWxlbS5vTWF0Y2hlc1NlbGVjdG9yXG4gICAgfHwgbWF0Y2hlc1xuICApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gIGNvbnN0IGRvY3VtZW50ID0gaXNEb2N1bWVudCh0aGlzKVxuICAgID8gdGhpc1xuICAgIDogdGhpcy5vd25lckRvY3VtZW50O1xuXG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTo6aW5kZXhPZih0aGlzKSAhPT0gLTE7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsZW0pIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEhJREVfQ0xBU1MgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4uLy4uL0VsZW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hvdyhlbGVtKSB7XG4gIG5ldyBFbGVtKGVsZW0pLnJlbW92ZUNsYXNzKEhJREVfQ0xBU1MpO1xufVxuIiwiaW1wb3J0IHsgaXNFbGVtIH0gZnJvbSAnLi9pcyc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi4vLi4vRWxlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0VsZW0oZWxlbSkge1xuICByZXR1cm4gaXNFbGVtKGVsZW0pXG4gICAgPyBlbGVtXG4gICAgOiBuZXcgRWxlbShlbGVtKTtcbn1cbiIsImltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGZ1bmN0aW9uIGZpbmRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gW2Jhc2UgPSBkb2N1bWVudF0gLSBCYXNlIHRvIGZpbmQgaW4uXG4gKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAqIFtEb2N1bWVudCNxdWVyeVNlbGVjdG9yQWxsXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBiYXNlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBFbGVtKGJhc2UucXVlcnlTZWxlY3RvckFsbChTdHJpbmcoc2VsZWN0b3IpKSk7XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIGtleXMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpIHtcbiAgaXRlcmF0ZUFycmF5KGtleXMoYXJnc09iamVjdCksIChhcmcpID0+IHtcbiAgICBpZiAoIShhcmcgaW4gYXJncykpIHtcbiAgICAgIGFyZ3NPYmplY3RbYXJnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgZm9yIChjb25zdCBhcmcgaW4gYXJncykge1xuICAgIGFyZ3NPYmplY3RbYXJnXSA9IGFyZ3NbYXJnXTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsZWFuUHJvcGVydHkodmFsdWUsIGFyZywgb2JqZWN0KSB7XG4gIGRlbGV0ZSBvYmplY3RbYXJnXTtcbn1cbiIsImltcG9ydCB7IGVzY2FwZVJlZ2V4IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0TWl4aW5SZWdleChuYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHsgZXNjYXBlUmVnZXgobmFtZSkgfSg/OlxcXFwoKFteXFxcXCldKilcXFxcKSk/KD86IyhbXFxcXHNcXFxcU10qKSk/JGApO1xufVxuIiwiY29uc3QgQ09NTUFfUkVHRVggPSAvLC87XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbk1hdGNoKG1peGlucywgYXR0cikge1xuICBsZXQgbWF0Y2g7XG5cbiAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gbWl4aW5zKSB7XG4gICAgY29uc3QgTWl4aW4gPSBtaXhpbnNbbmFtZV07XG4gICAgY29uc3QgbG9jYWxNYXRjaCA9IGF0dHIubWF0Y2goTWl4aW4uX21hdGNoKTtcblxuICAgIGlmIChsb2NhbE1hdGNoKSB7XG4gICAgICBjb25zdCBhcmdzTWF0Y2ggPSBsb2NhbE1hdGNoWzFdO1xuICAgICAgbGV0IGFyZ3M7XG5cbiAgICAgIGlmIChhcmdzTWF0Y2ggPT09ICcnKSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc01hdGNoKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzTWF0Y2guc3BsaXQoQ09NTUFfUkVHRVgpO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgY29tbWVudDogbG9jYWxNYXRjaFsyXSxcbiAgICAgICAgTWl4aW4sXG4gICAgICAgIG5hbWVcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cbiIsImltcG9ydCB7IGNvbGxlY3RGcm9tT2JqZWN0LCBhc3NpZ24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBEX1JFU1RfUkVHRVggfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgbWl4aW5NYXRjaCB9IGZyb20gJy4vbWl4aW5NYXRjaCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SZXN0QXR0cnMoYXR0cnMsIG1peGlucywgbWl4aW5EZWZhdWx0T3B0cykge1xuICByZXR1cm4gY29sbGVjdEZyb21PYmplY3QoYXR0cnMsIChldmVudHVhbEF0dHJzLCB2YWx1ZSwgYXR0cikgPT4ge1xuICAgIGlmIChEX1JFU1RfUkVHRVgudGVzdChhdHRyKSkge1xuICAgICAgcmV0dXJuIGFzc2lnbihldmVudHVhbEF0dHJzLCB0cmFuc2Zvcm1SZXN0QXR0cnModmFsdWUsIG1peGlucywgbWl4aW5EZWZhdWx0T3B0cykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gbWl4aW5NYXRjaChtaXhpbnMsIGF0dHIpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudHVhbEF0dHJzW2F0dHJdID0ge1xuICAgICAgICB0eXBlOiAnbWl4aW4nLFxuICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgLi4ubWl4aW5EZWZhdWx0T3B0c1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50dWFsQXR0cnNbYXR0cl0gPSB7XG4gICAgICB0eXBlOiAnYXR0cicsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUmVzdEFyZ3MoYXJncykge1xuICByZXR1cm4gY29sbGVjdEZyb21PYmplY3QoYXJncywgYWRkQXJncyk7XG59XG5cbmZ1bmN0aW9uIGFkZEFyZ3MoYXJncywgdmFsdWUsIGFyZykge1xuICBpZiAoRF9SRVNUX1JFR0VYLnRlc3QoYXJnKSkge1xuICAgIGFzc2lnbihhcmdzLCB0cmFuc2Zvcm1SZXN0QXJncyh2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbYXJnXSA9IHZhbHVlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgdmFsdWUpIHtcbiAgY29uc3Qgb2xkVmFsdWUgPSBtaXhpbi4kJC52YWx1ZTtcblxuICBtaXhpbi4kJC52YWx1ZSA9IHZhbHVlO1xuXG4gIGl0ZXJhdGVBcnJheShtaXhpbi4kJC53YXRjaGVycywgKHdhdGNoZXIpID0+IHtcbiAgICB3YXRjaGVyKHZhbHVlLCBvbGRWYWx1ZSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1peGluKHtcbiAgbmFtZSwgTWl4aW4sIGR5bmFtaWMsXG4gIHZhbHVlLCBhcmdzLCBjb21tZW50LCBlbGVtLFxuICBwYXJlbnRCbG9jaywgcGFyZW50U2NvcGUsIHBhcmVudFRlbXBsYXRlXG59KSB7XG4gIGNvbnN0IG1peGluID0gbmV3IE1peGluKHtcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIGR5bmFtaWMsXG4gICAgYXJncyxcbiAgICBjb21tZW50LFxuICAgIGVsZW0sXG4gICAgcGFyZW50QmxvY2ssXG4gICAgcGFyZW50U2NvcGUsXG4gICAgcGFyZW50VGVtcGxhdGVcbiAgfSk7XG5cbiAgaWYgKE1peGluLmV2YWx1YXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBtaXhpbi52YWx1ZSA9IG1peGluLmV2YWx1YXRlKChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIG1peGluLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1peGluLmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyVXBkYXRlOmAsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtaXhpbi5hZnRlclVwZGF0ZSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbWl4aW47XG59XG4iLCJpbXBvcnQgeyBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBleGVjdXRlTWl4aW5XYXRjaGVycyB9IGZyb20gJy4vZXhlY3V0ZU1peGluV2F0Y2hlcnMnO1xuaW1wb3J0IHsgY3JlYXRlTWl4aW4gfSBmcm9tICcuL2NyZWF0ZU1peGluJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBhdHRyc09iamVjdCwgZWxlbSwgZmlyc3RUaW1lKSB7XG4gIGl0ZXJhdGVPYmplY3QoYXR0cnNPYmplY3QsICh7IHR5cGUsIHZhbHVlIH0sIGF0dHIpID0+IHtcbiAgICBpZiAoIWF0dHJzW2F0dHJdKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihhdHRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLiQkLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgYXR0cnNPYmplY3RbYXR0cl07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBtaXhpbnMgPSBbXTtcblxuICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gIGZvciAoY29uc3QgYXR0ciBpbiBhdHRycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBkeW5hbWljLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRzXG4gICAgfSA9IGF0dHJzW2F0dHJdO1xuICAgIGxldCBuZXh0VHlwZTtcbiAgICBsZXQgbmV4dER5bmFtaWM7XG4gICAgbGV0IG5leHRWYWx1ZTtcblxuICAgIGlmIChhdHRyc09iamVjdFthdHRyXSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlOiBwcmV2VHlwZSxcbiAgICAgICAgdmFsdWU6IHByZXZWYWx1ZVxuICAgICAgfSA9IGF0dHJzT2JqZWN0W2F0dHJdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgIGlmIChwcmV2VHlwZSA9PT0gJ21peGluJykge1xuICAgICAgICAgIHByZXZWYWx1ZS4kJC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgZWxlbS5hdHRyKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWl4aW4gPSBwcmV2VmFsdWU7XG5cbiAgICAgICAgaWYgKHByZXZUeXBlID09PSAnYXR0cicpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHIoYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICBtaXhpbi4kJC5pc0R5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgZXhlY3V0ZU1peGluV2F0Y2hlcnMobWl4aW4sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghbWl4aW4uJCQuZXZhbHVhdGVkICYmIG9wdHMuTWl4aW4uZXZhbHVhdGUpIHtcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG1peGluLiQkLnBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZHluYW1pY1xuICAgICAgICAgICAgfSA9IGF0dHJzW2F0dHJdO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21peGluJyAmJiAhZHluYW1pYykge1xuICAgICAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1peGluKTtcblxuICAgICAgICAgIG1peGluLiQkLmV2YWx1YXRlZCA9IHRydWU7XG5cbiAgICAgICAgICBleGVjdXRlTWl4aW5XYXRjaGVycyhtaXhpbiwgbmV3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFZhbHVlID0gbWl4aW47XG4gICAgICB9XG5cbiAgICAgIG5leHRUeXBlID0gdHlwZTtcbiAgICAgIG5leHREeW5hbWljID0gZHluYW1pYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdhdHRyJykge1xuICAgICAgICBlbGVtLmF0dHIoYXR0ciwgdmFsdWUpO1xuXG4gICAgICAgIG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVpbGRNaXhpbiA9ICgpID0+IHtcbiAgICAgICAgICBvcHRzLmR5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgICAgICAgY29uc3QgbWl4aW4gPSBjcmVhdGVNaXhpbihvcHRzKTtcblxuICAgICAgICAgIGlmICghZHluYW1pYyAmJiBvcHRzLk1peGluLmV2YWx1YXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IG9wdHM7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBkeW5hbWljXG4gICAgICAgICAgICAgIH0gPSBhdHRyc1thdHRyXTtcblxuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21peGluJyAmJiAhZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVNaXhpbldhdGNoZXJzKG1peGluLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1peGluKTtcblxuICAgICAgICAgICAgbWl4aW4uJCQuZXZhbHVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1peGluLiQkLnZhbHVlID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0VmFsdWUgPSBtaXhpbjtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkeW5hbWljLFxuICAgICAgICAgICAgICB2YWx1ZTogbWl4aW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICBtaXhpbnMucHVzaChidWlsZE1peGluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsZE1peGluKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFR5cGUgPSB0eXBlO1xuICAgICAgbmV4dER5bmFtaWMgPSBkeW5hbWljO1xuICAgIH1cblxuICAgIGF0dHJzT2JqZWN0W2F0dHJdID0ge1xuICAgICAgdHlwZTogbmV4dFR5cGUsXG4gICAgICBkeW5hbWljOiBuZXh0RHluYW1pYyxcbiAgICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZpcnN0VGltZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCAoYnVpbGRNaXhpbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXR0cixcbiAgICAgICAgICBvcHRzXG4gICAgICAgIH0gPSBidWlsZE1peGluKCk7XG5cbiAgICAgICAgYXR0cnNPYmplY3RbYXR0cl0gPSBvcHRzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlLCBjb2xsZWN0RnJvbU9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFByaXZhdGVTY29wZShvYmplY3QsIHR5cGUsIHBhcmVudFNjb3BlKSB7XG4gIGxldCBzY29wZSA9IHt9O1xuXG4gIGlmICh0eXBlID09PSAnZ2xvYmFscycpIHtcbiAgICBzY29wZSA9IGNyZWF0ZShcbiAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgID8gcGFyZW50U2NvcGUuJCQuZ2xvYmFsc1xuICAgICAgICA6IG51bGxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3RGcm9tT2JqZWN0KG9iamVjdCwgKHNjb3BlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgc2NvcGVba2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgd2F0Y2hlcnM6IFtdXG4gICAgfTtcbiAgfSwgc2NvcGUpO1xufVxuIiwiaW1wb3J0IHsgcmVtb3ZlQXJyYXlFbGVtLCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUZW1wV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHdhdGNoZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpIHtcbiAgaXRlcmF0ZUFycmF5KHdhdGNoZXJzVG9SZW1vdmUsIHJlbW92ZVdhdGNoZXIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVXYXRjaGVyKHsgd2F0Y2hlciwgd2F0Y2hlcnMgfSkge1xuICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgbWFwT2JqZWN0LCBpdGVyYXRlQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBnZXR0aW5nVmFycywgZXZhbE1vZGUgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyByZW1vdmVUZW1wV2F0Y2hlciB9IGZyb20gJy4vcmVtb3ZlV2F0Y2hlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RQdWJsaWNTY29wZShzY29wZSwgc2NvcGVWYWx1ZXMsIHByaXZhdGVTY29wZSkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCBtYXBPYmplY3Qoc2NvcGVWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBwcml2YXRlU2NvcGVba2V5XTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGV2YWxNb2RlKSB7XG4gICAgICAgICAgaWYgKGdldHRpbmdWYXJzLmluZGV4T2Yoc2NvcGUud2F0Y2hlcnMpID09PSAtMSkge1xuICAgICAgICAgICAgZ2V0dGluZ1ZhcnMucHVzaChzY29wZS53YXRjaGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHNjb3BlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2xkVGVtcFdhdGNoZXJzID0gc2NvcGUud2F0Y2hlcnMuc2xpY2UoKTtcblxuICAgICAgICBzY29wZS53YXRjaGVycyA9IFtdO1xuICAgICAgICBzY29wZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGl0ZXJhdGVBcnJheShvbGRUZW1wV2F0Y2hlcnMsIHJlbW92ZVRlbXBXYXRjaGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSk7XG59XG4iLCJpbXBvcnQge1xuICBleGNlcHQsIGNyZWF0ZSwgYXNzaWduLFxuICBpdGVyYXRlT2JqZWN0LCBpdGVyYXRlQXJyYXksXG4gIGlzTmlsXG59IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi8uLi9FbGVtJztcbmltcG9ydCB7XG4gIFNWR19OUywgRF9SRVNUX1JFR0VYXG59IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjbGVhblByb3BlcnR5IH0gZnJvbSAnLi9jbGVhblByb3BlcnR5JztcbmltcG9ydCB7IHRyYW5zZm9ybVJlc3RBdHRycyB9IGZyb20gJy4vdHJhbnNmb3JtUmVzdEF0dHJzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUF0dHJzIH0gZnJvbSAnLi9jYWxjdWxhdGVBdHRycyc7XG5pbXBvcnQgeyBtaXhpbk1hdGNoIH0gZnJvbSAnLi9taXhpbk1hdGNoJztcbmltcG9ydCB7IGNvbnN0cnVjdFByaXZhdGVTY29wZSB9IGZyb20gJy4vY29uc3RydWN0UHJpdmF0ZVNjb3BlJztcbmltcG9ydCB7IGNvbnN0cnVjdFB1YmxpY1Njb3BlIH0gZnJvbSAnLi9jb25zdHJ1Y3RQdWJsaWNTY29wZSc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uLy4uL0Jsb2NrJztcblxuY29uc3QgTkFNRURfRF9CTE9DS19SRUdFWCA9IC9eZC1ibG9jazooW1xcc1xcU10rKSQvO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmxvY2soeyBub2RlLCBwYXJlbnQsIHBhcmVudEVsZW0sIHBhcmVudEJsb2NrLCBwYXJlbnRTY29wZSwgcGFyZW50VGVtcGxhdGUsIHByZXZCbG9jayB9KSB7XG4gIGNvbnN0IGRvYyA9IG5ldyBFbGVtKHBhcmVudEVsZW1bMF0ub3duZXJEb2N1bWVudCk7XG4gIGNvbnN0IGVsZW0gPSBwYXJlbnRFbGVtWzBdLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05TXG4gICAgPyBkb2MuY3JlYXRlKCdzdmcnKVxuICAgIDogZG9jO1xuICBjb25zdCBsb2NhbEJsb2NrcyA9IHBhcmVudFRlbXBsYXRlID8gcGFyZW50VGVtcGxhdGUuJCQubnMuX2Jsb2NrcyA6IEJsb2NrLl9ibG9ja3M7XG4gIGNvbnN0IGxvY2FsTWl4aW5zID0gcGFyZW50VGVtcGxhdGUgPyBwYXJlbnRUZW1wbGF0ZS4kJC5ucy5fbWl4aW5zIDogQmxvY2suX21peGlucztcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcbiAgY29uc3QgYXJncyA9IG5vZGUuYXR0cnMgfHwge307XG4gIGNvbnN0IG5hbWUgPSBub2RlLm5hbWUgfHwgJ1Vua25vd25CbG9jayc7XG4gIGxldCBjb25zdHJ1Y3RvciA9IG5vZGUuQ29uc3RydWN0b3IgfHwgKG5vZGUubmFtZSAmJiBsb2NhbEJsb2Nrc1tub2RlLm5hbWVdKTtcbiAgbGV0IGRCbG9ja01hdGNoO1xuICBsZXQgZEJsb2NrTmFtZTtcbiAgbGV0IGRCbG9ja0FyZ3M7XG5cbiAgaWYgKG5hbWUgPT09ICdkLWJsb2NrJyAmJiBhcmdzLm5hbWUpIHtcbiAgICBkQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICduYW1lJyk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2QtYmxvY2snICYmIGFyZ3MuQ29uc3RydWN0b3IpIHtcbiAgICBkQmxvY2tBcmdzID0gZXhjZXB0KGFyZ3MsICdDb25zdHJ1Y3RvcicpO1xuICB9IGVsc2UgaWYgKChkQmxvY2tNYXRjaCA9IG5hbWUubWF0Y2goTkFNRURfRF9CTE9DS19SRUdFWCkpIHx8IG5hbWUgPT09ICdkLWJsb2NrJykge1xuICAgIGNvbnN0cnVjdG9yID0gQmxvY2suX2Jsb2Nrc1snZC1ibG9jayddO1xuICAgIGRCbG9ja05hbWUgPSBkQmxvY2tNYXRjaCA/IGRCbG9ja01hdGNoWzFdIDogbnVsbDtcbiAgfVxuXG4gIGxldCBibG9ja0luc3RhbmNlO1xuXG4gIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgIHRyeSB7XG4gICAgICBibG9ja0luc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrQXJncyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50QmxvY2ssXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgcHJldkJsb2NrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluIG5ldyAkeyBuYW1lIH06YCwgZXJyKTtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBub2RlO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW0uY3JlYXRlKG5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRycyA9IGNyZWF0ZShudWxsKTtcbiAgICBsZXQgYXR0cnMgPSBjcmVhdGUobnVsbCk7XG4gICAgbGV0IHdhc0RSZXN0O1xuICAgIGNvbnN0IG1peGluRGVmYXVsdE9wdHMgPSB7XG4gICAgICBlbGVtOiBlbGVtZW50LFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfTtcblxuICAgIGl0ZXJhdGVPYmplY3QoYXJncywgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBpc0RSZXN0ID0gRF9SRVNUX1JFR0VYLnRlc3QoYXR0cik7XG4gICAgICBjb25zdCBsb2NhbEF0dHJzID0gaXNEUmVzdCB8fCB3YXNEUmVzdFxuICAgICAgICA/IGNyZWF0ZShhdHRycylcbiAgICAgICAgOiBhdHRycztcblxuICAgICAgYXR0cnMgPSBsb2NhbEF0dHJzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXR0cnMgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZSh2YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXR0cnMsIGNsZWFuUHJvcGVydHkpO1xuICAgICAgICAgICAgYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICAgICAgdmFsdWUsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGNhbGN1bGF0ZUF0dHJzKGF0dHJzLCBjdXJyZW50QXR0cnMsIGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSwgcGFyZW50QmxvY2spO1xuXG4gICAgICAgIHdhc0RSZXN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsQXR0cnMsIHRyYW5zZm9ybVJlc3RBdHRycyhcbiAgICAgICAgICByZXN0QXR0cnMsIGxvY2FsTWl4aW5zLCBtaXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaCA9IG1peGluTWF0Y2gobG9jYWxNaXhpbnMsIGF0dHIpO1xuXG4gICAgICB3YXNEUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgICB0eXBlOiAnbWl4aW4nLFxuICAgICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgICAuLi5taXhpbkRlZmF1bHRPcHRzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWxBdHRyc1thdHRyXSA9IHtcbiAgICAgICAgdHlwZTogJ2F0dHInLFxuICAgICAgICB2YWx1ZTogcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUodmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxvY2FsQXR0cnNbYXR0cl0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXR0cicsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsY3VsYXRlQXR0cnMoYXR0cnMsIGN1cnJlbnRBdHRycywgZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9LCBwYXJlbnRCbG9jaylcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCBjcmVhdGVNaXhpbnMgPSBjYWxjdWxhdGVBdHRycyhhdHRycywgY3VycmVudEF0dHJzLCBlbGVtZW50LCB0cnVlKTtcblxuICAgIGlmIChuYW1lID09PSAnI2NvbW1lbnQnKSB7XG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnI3RleHQnKSB7XG4gICAgICBsZXQgdGV4dCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnRleHQoYCR7IHZhbHVlIH1gKTtcbiAgICAgIH0sIHBhcmVudEJsb2NrKTtcblxuICAgICAgaWYgKGlzTmlsKHRleHQpKSB7XG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC50ZXh0KGAkeyB0ZXh0IH1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGxldCBwcmV2QmxvY2s7XG4gICAgICBsZXQgcGFyZW50RWxlbSA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmIChuYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShlbGVtZW50WzBdLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnaWZyYW1lJykge1xuICAgICAgICBpZiAoISgnc3JjJyBpbiBhdHRycykpIHtcbiAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGVsZW1lbnRbMF0uY29udGVudERvY3VtZW50O1xuXG4gICAgICAgICAgbmV3IEVsZW0oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5yZW1vdmUoKTtcblxuICAgICAgICAgIHBhcmVudEVsZW0gPSBuZXcgRWxlbShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRFbGVtLFxuICAgICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIHByZXZCbG9ja1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzUGFyZW50QmxvY2sgPSBwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaztcblxuICAgIGlmIChwcmV2QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoZWxlbWVudCwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICBlbGVtZW50Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG5cbiAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgcGFyZW50LiQkLmluc2VydEluU3RhcnRPZkl0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjcmVhdGVNaXhpbnMoKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgY29uc3Qge1xuICAgICQkLFxuICAgIGFyZ3M6IEFyZ3MsXG4gICAgZ2xvYmFscyxcbiAgICAuLi5sb2NhbHNcbiAgfSA9IGJsb2NrSW5zdGFuY2U7XG5cbiAgY29uc3QgaHRtbCA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy52YWx1ZSB8fCBbXVxuICAgIDogY29uc3RydWN0b3IudGVtcGxhdGUudmFsdWU7XG5cbiAgJCQuYXJncyA9IGNvbnN0cnVjdFByaXZhdGVTY29wZShBcmdzKTtcbiAgJCQubG9jYWxzID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKGxvY2Fscyk7XG4gICQkLmdsb2JhbHMgPSBjb25zdHJ1Y3RQcml2YXRlU2NvcGUoZ2xvYmFscywgJ2dsb2JhbHMnLCBwYXJlbnRTY29wZSk7XG5cbiAgaWYgKG5hbWUgPT09ICcjZC1pdGVtJykge1xuICAgIGNvbnN0IHNjb3BlVmFsdWVzID0ge1xuICAgICAgW25vZGUuaXRlbU5hbWVdOiBub2RlLml0ZW0sXG4gICAgICBbbm9kZS5pbmRleE5hbWVdOiBub2RlLmluZGV4XG4gICAgfTtcbiAgICBjb25zdCBzY29wZSA9IHBhcmVudFNjb3BlLiQkLm5hbWUgPT09ICcjZC1pdGVtJ1xuICAgICAgPyBwYXJlbnRTY29wZS4kJC5zY29wZVxuICAgICAgOiBwYXJlbnRTY29wZTtcblxuICAgICQkLm5zID0gcGFyZW50U2NvcGUuJCQubnM7XG4gICAgJCQucHJpdmF0ZVNjb3BlID0gY29uc3RydWN0UHJpdmF0ZVNjb3BlKHNjb3BlVmFsdWVzKTtcbiAgICBjb25zdHJ1Y3RQdWJsaWNTY29wZSgkJC5zY29wZSA9IGNyZWF0ZShzY29wZSksIHNjb3BlVmFsdWVzLCAkJC5wcml2YXRlU2NvcGUpO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09ICdkLWVhY2gnKSB7XG4gICAgJCQuc2NvcGUgPSBjcmVhdGUocGFyZW50U2NvcGUuJCQubmFtZSA9PT0gJyNkLWl0ZW0nID8gcGFyZW50U2NvcGUuJCQuc2NvcGUgOiBwYXJlbnRTY29wZSwge1xuICAgICAgW0FyZ3MuaXRlbSB8fCAnJGl0ZW0nXToge1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBbQXJncy5pbmRleCB8fCAnJGluZGV4J106IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RQdWJsaWNTY29wZShBcmdzLCBBcmdzLCAkJC5hcmdzKTtcbiAgY29uc3RydWN0UHVibGljU2NvcGUoZ2xvYmFscywgZ2xvYmFscywgJCQuZ2xvYmFscyk7XG4gIGNvbnN0cnVjdFB1YmxpY1Njb3BlKGJsb2NrSW5zdGFuY2UsIGxvY2FscywgJCQubG9jYWxzKTtcblxuICB0cnkge1xuICAgIGJsb2NrSW5zdGFuY2UuYWZ0ZXJDb25zdHJ1Y3QoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2FmdGVyQ29uc3RydWN0OmAsIGVycik7XG4gIH1cblxuICBwcmV2QmxvY2sgPSB1bmRlZmluZWQ7XG4gIHBhcmVudFNjb3BlID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnXG4gICAgPyBBcmdzLnBhcmVudFNjb3BlXG4gICAgOiBibG9ja0luc3RhbmNlO1xuICBwYXJlbnRUZW1wbGF0ZSA9IG5hbWUgPT09ICdkLWVsZW1lbnRzJ1xuICAgID8gQXJncy5wYXJlbnRUZW1wbGF0ZVxuICAgIDogYmxvY2tJbnN0YW5jZTtcblxuICBpdGVyYXRlQXJyYXkoaHRtbCwgKGNoaWxkKSA9PiB7XG4gICAgcHJldkJsb2NrID0gY3JlYXRlQmxvY2soe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXJlbnQ6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50QmxvY2s6IGJsb2NrSW5zdGFuY2UsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgcHJldkJsb2NrXG4gICAgfSk7XG4gIH0pO1xuXG4gIGJsb2NrSW5zdGFuY2UuJCQuaXNSZW5kZXJlZCA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICBibG9ja0luc3RhbmNlLmFmdGVyUmVuZGVyKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfSNhZnRlclJlbmRlcjpgLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIGJsb2NrSW5zdGFuY2U7XG59XG4iLCJjb25zdCB7IGlzUHJvdG90eXBlT2YgfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKENsYXNzLCBTdWJjbGFzcykge1xuICByZXR1cm4gQ2xhc3M6OmlzUHJvdG90eXBlT2YoU3ViY2xhc3MpICYmIENsYXNzLnByb3RvdHlwZTo6aXNQcm90b3R5cGVPZihTdWJjbGFzcy5wcm90b3R5cGUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdpdGhQYXJlbnRTaWduYWwoY2hpbGQpIHtcbiAgY2hpbGQuJCQucmVtb3ZlKHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gIGNoaWxkLiQkLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgaXNJbnN0YW5jZU9mIH0gZnJvbSAnLi9pc0luc3RhbmNlT2YnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi8uLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uLy4uL01peGluJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBCbG9jayhibG9jaywgd3JhcHBlcikge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHdyYXBwZXIoYmxvY2spO1xuXG4gIHJldHVybiBpc0luc3RhbmNlT2YoQmxvY2ssIHJldHVyblZhbHVlKVxuICAgID8gcmV0dXJuVmFsdWVcbiAgICA6IGJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1peGluKG1peGluLCB3cmFwcGVyKSB7XG4gIGNvbnN0IHJldHVyblZhbHVlID0gd3JhcHBlcihtaXhpbik7XG5cbiAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgcmV0dXJuVmFsdWUpXG4gICAgPyByZXR1cm5WYWx1ZVxuICAgIDogbWl4aW47XG59XG4iLCJpbXBvcnQge1xuICBpc1N0cmluZywgaXRlcmF0ZU9iamVjdCwga2V5cyxcbiAgY29sbGVjdEZyb21PYmplY3QsIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVggPSAvXFxzKjtcXHMqLztcbmNvbnN0IENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVggPSAvXFxzKjpcXHMqLztcblxucm9vdE1peGluc1snZC1zdHlsZSddID0gY2xhc3MgRFN0eWxlIGV4dGVuZHMgTWl4aW4ge1xuICBjc3MgPSB7fTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXJncyxcbiAgICAgIGNzc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21PYmplY3QoYXJncywgKGNzcywgcHJvcCkgPT4ge1xuICAgICAgICBjc3NbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhuZXdWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29sbGVjdEZyb21BcnJheShcbiAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAuc3BsaXQoQ1NTX1NUWUxFU19TRVBBUkFUT1JfUkVHRVgpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgIC5tYXAoY29uc3RydWN0U3R5bGVGcm9tU3RyaW5nKSxcbiAgICAgICAgYWRkQ1NTUHJvcFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNzcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIW5ld1ZhbHVlW3Byb3BdKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ1NTKHByb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVsZW0uY3NzKG5ld1ZhbHVlKTtcblxuICAgIHRoaXMuY3NzID0gbmV3VmFsdWU7XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGNzc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgZWxlbS5yZW1vdmVDU1MuYXBwbHkoZWxlbSwga2V5cyhjc3MpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYWRkQ1NTUHJvcChjc3MsIGl0ZW0pIHtcbiAgY29uc3QgW3Byb3AsIHZhbHVlXSA9IGl0ZW07XG5cbiAgY3NzW3Byb3BdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyhzdHlsZSkge1xuICBjb25zdCBzcGxpdCA9IHN0eWxlLnNwbGl0KENTU19TVFlMRV9TRVBBUkFUT1JfUkVHRVgpO1xuXG4gIHJldHVybiBbXG4gICAgc3BsaXRbMF0udHJpbSgpLFxuICAgIHNwbGl0WzFdLnRyaW0oKVxuICBdO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNGdW5jdGlvbiwgaXNOaWwsXG4gIGNvbGxlY3RGcm9tQXJyYXlcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLXZhbHVlJ10gPSBjbGFzcyBEVmFsdWUgZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuYW1lID0gZWxlbS5uYW1lKCk7XG4gICAgY29uc3QgdHlwZSA9IGVsZW0ucHJvcCgndHlwZScpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZSgpO1xuICAgIGxldCBpbml0aWFsU2NvcGVWYWx1ZSA9IG51bGw7XG5cbiAgICB0aGlzLnByb3AgPSBnZXRQcm9wKG5hbWUsIHR5cGUsIGVsZW0pO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gZWxlbS5maW5kKCdvcHRpb24nKTtcbiAgICB0aGlzLnNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgdGhpcy5zY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdGhpcy52YWx1ZSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHRoaXMudmFsdWUpKSB7XG4gICAgICBpbml0aWFsU2NvcGVWYWx1ZSA9IHRoaXMuc2NvcGUuJCQuZXZhbHVhdGUoKHNjb3BlKSA9PiBzY29wZVt0aGlzLnZhbHVlXSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0UHJvcChuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxFbGVtVmFsdWUgPSB0aGlzLmdldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsID0gaXNOaWwoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgIGNvbnN0IGlzQ2hlY2tib3ggPSB0eXBlID09PSAnY2hlY2tib3gnO1xuICAgIGNvbnN0IGNoYW5nZVNjb3BlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLmdldFByb3AodGhpcy5jdXJyZW50VmFsdWUsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzSW5pdGlhbFNjb3BlVmFsdWVOdWxsIHx8IGlzQ2hlY2tib3gpIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbEVsZW1WYWx1ZTtcbiAgICAgIHRoaXMuY2hhbmdlU2NvcGUoKTtcblxuICAgICAgaWYgKCFpc0luaXRpYWxTY29wZVZhbHVlTnVsbCAmJiBpc0NoZWNrYm94KSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcChpbml0aWFsU2NvcGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5pdGlhbFNjb3BlVmFsdWU7XG4gICAgICB0aGlzLnNldFByb3AoaW5pdGlhbFNjb3BlVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMub2ZmRWxlbUxpc3RlbmVyID0gZWxlbS5vbihnZXRMaXN0ZW5lck5hbWUobmFtZSwgdHlwZSksIGNoYW5nZVNjb3BlKTtcbiAgICB0aGlzLm9mZkZvcm1MaXN0ZW5lciA9IGVsZW0uY2xvc2VzdCgnZm9ybScpLm9uKCdyZXNldCcsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoY2hhbmdlU2NvcGUsIDApO1xuICAgIH0pO1xuICB9XG5cbiAgY2hhbmdlU2NvcGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NvcGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGN1cnJlbnRWYWx1ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgc2V0UHJvcCh2YWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBuYW1lLFxuICAgICAgcHJvcCxcbiAgICAgIHR5cGUsXG4gICAgICBub2RlLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3AgPT09ICd0ZXh0Jykge1xuICAgICAgZWxlbS50ZXh0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKSB7XG4gICAgICBvcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmRleE9mKG9wdGlvbi52YWx1ZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0ucHJvcChwcm9wLCBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIG5vZGUudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcm9wKHZhbHVlcywgaW5pdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBuYW1lLFxuICAgICAgcHJvcCxcbiAgICAgIHR5cGUsXG4gICAgICBub2RlLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIHByb3AgPT09ICd0ZXh0J1xuICAgICAgPyBlbGVtLnRleHQoKVxuICAgICAgOiBnZXRWYWx1ZUZvckdldHRpbmcobmFtZSwgZWxlbS5wcm9wKHByb3ApLCB0eXBlLCBub2RlLnZhbHVlLCB2YWx1ZXMsIG9wdGlvbnMsIGluaXQsIHByb3AgPT09ICdtdWx0aXBsZS1zZWxlY3QnKTtcbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICB0aGlzLm9mZkVsZW1MaXN0ZW5lcigpO1xuICAgIHRoaXMub2ZmRm9ybUxpc3RlbmVyKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFByb3AobmFtZSwgdHlwZSwgZWxlbSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICByZXR1cm4gZWxlbS5oYXNBdHRyKCdtdWx0aXBsZScpXG4gICAgICAgID8gJ211bHRpcGxlLXNlbGVjdCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICByZXR1cm4gJ2ZpbGVzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94J1xuICAgICAgICA/ICdjaGVja2VkJ1xuICAgICAgICA6ICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cignY29udGVudEVkaXRhYmxlJylcbiAgICAgICAgPyAndGV4dCdcbiAgICAgICAgOiAndmFsdWUnO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclNldHRpbmcobmFtZSwgdmFsdWUsIHR5cGUsIGlucHV0VmFsdWUpIHtcbiAgaWYgKG5hbWUgIT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBpc1JhZGlvID0gdHlwZSA9PT0gJ3JhZGlvJztcblxuICBpZiAoIWlzUmFkaW8gJiYgdHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpc1JhZGlvXG4gICAgPyB2YWx1ZSA9PT0gaW5wdXRWYWx1ZVxuICAgIDogdmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yR2V0dGluZyhuYW1lLCB2YWx1ZSwgdHlwZSwgaW5wdXRWYWx1ZSwgdmFsdWVzLCBvcHRpb25zLCBpbml0LCBpc011bHRpcGxlKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbUFycmF5KG9wdGlvbnMsIGFkZFZhbHVlLCBbXSk7XG4gICAgfVxuXG4gICAgY2FzZSAnaW5wdXQnOiB7XG4gICAgICBpZiAodHlwZSAhPT0gJ3JhZGlvJyAmJiB0eXBlICE9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgPyBpbnB1dFZhbHVlXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW107XG5cbiAgICAgIGlmICghdmFsdWUgJiYgaW5pdCkge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpID09PSAtMVxuICAgICAgICAgID8gdmFsdWVzLmNvbmNhdChpbnB1dFZhbHVlKVxuICAgICAgICAgIDogdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKGlucHV0VmFsdWUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4udmFsdWVzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAuLi52YWx1ZXMuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJOYW1lKG5hbWUsIHR5cGUpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgcmV0dXJuICdjaGFuZ2UnO1xuICAgIH1cblxuICAgIGNhc2UgJ2lucHV0Jzoge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZSA9PT0gJ3JhZGlvJ1xuICAgICAgICB8fCB0eXBlID09PSAnY2hlY2tib3gnXG4gICAgICAgIHx8IHR5cGUgPT09ICdjb2xvcidcbiAgICAgICAgfHwgdHlwZSA9PT0gJ2ZpbGUnXG4gICAgICApXG4gICAgICAgID8gJ2NoYW5nZSdcbiAgICAgICAgOiAnY2hhbmdlIGlucHV0JztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gJ2lucHV0JztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUodmFsdWVzLCB7IHNlbGVjdGVkLCB2YWx1ZSB9KSB7XG4gIGlmIChzZWxlY3RlZCAmJiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICB0b09iamVjdEtleXMsXG4gIGFzc2lnbiwga2V5cywgY3JlYXRlXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0VGVtcGxhdGVzKHRlbXBsYXRlLCB0ZW1wbGF0ZXMpIHtcbiAgY29uc3Qge1xuICAgIHZhcnMsXG4gICAgdmFsdWVcbiAgfSA9IHRlbXBsYXRlO1xuICBjb25zdCBuZXdUZW1wbGF0ZXMgPSBjcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5ld1ZhcnMgPSB0b09iamVjdEtleXModmFycyk7XG5cbiAgYXNzaWduKG5ld1RlbXBsYXRlcywgdGVtcGxhdGVzKTtcbiAgaXRlcmF0ZUFuZENoYW5nZUNoaWxkcmVuKHZhbHVlKTtcblxuICBmdW5jdGlvbiBpdGVyYXRlQW5kQ2hhbmdlQ2hpbGRyZW4obm9kZXMgPSBbXSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gbm9kZXNbaV07XG5cbiAgICAgIGlmIChuYW1lID09PSAnI2NvbW1lbnQnKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5ld1RlbXBsYXRlc1t0cmltbWVkXSkge1xuICAgICAgICAgIGNvbnN0IG5ld1RlbXBsYXRlID0gbmV3VGVtcGxhdGVzW3RyaW1tZWRdLnZhbHVlO1xuXG4gICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm5ld1RlbXBsYXRlKTtcbiAgICAgICAgICBhc3NpZ24obmV3VmFycywgdG9PYmplY3RLZXlzKG5ld1RlbXBsYXRlc1t0cmltbWVkXS52YXJzKSk7XG5cbiAgICAgICAgICBpICs9IG5ld1RlbXBsYXRlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFycy5sZW5ndGggPSAwO1xuICB2YXJzLnB1c2goLi4ua2V5cyhuZXdWYXJzKSk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuIiwiaW1wb3J0IHsgaXNBcnJheSwgaXNTdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUJsb2NrLCBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuL0VsZW0nO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpbml0QXBwXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1RlbXBsYXRlfFNjb3BlbGVzc1RlbXBsYXRlfFN0cmluZ3x0eXBlb2YgQmxvY2t9IGJsb2NrIC0gUm9vdCB0ZW1wbGF0ZSAobWF5IGJlIHNjb3BlbGVzcyksXG4gKiBzdHJpbmcgZGVmaW5pbmcgYSBuYW1lIG9mIHRoZSByb290IGJsb2NrIG9yIGEgYmxvY2sgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIG9mIHRoZSBhcHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGluaXRpYWxpemluZyBhcHAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGluaXRBcHAsIGRvYyB9IGZyb20gJ2R3YXluZSc7XG4gKlxuICogaW5pdEFwcChodG1sYDxBcHAvPmAsIGRvYy5jcmVhdGUoJ2RpdicpKTtcbiAqIGluaXRBcHAoaHRtbFNjb3BlbGVzc2A8QXBwLz5gLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKCdBcHAnLCBkb2MuY3JlYXRlKCdkaXYnKSk7XG4gKiBpbml0QXBwKEFwcCwgZG9jLmNyZWF0ZSgnZGl2JykpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEFwcChibG9jaywgY29udGFpbmVyKSB7XG4gIGNvbnN0IHBhcmVudEVsZW0gPSBuZXcgRWxlbShjb250YWluZXIpLmVsZW0oMCk7XG5cbiAgaWYgKCFwYXJlbnRFbGVtLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgZWxlbWVudCB0byBpbnNlcnQgdGhlIGFwcCBpbnRvIHdhcyBnaXZlbiEgKGluaXRBcHApJyk7XG4gIH1cblxuICBpZiAocGFyZW50RWxlbS5wcm9wKCdEd2F5bmVSb290QmxvY2snKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgYWxyZWFkeSBleGlzdHMgYSBEd2F5bmUgYXBwIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCEgKGluaXRBcHApJyk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcoYmxvY2spKSB7XG4gICAgYmxvY2sgPSB7XG4gICAgICB2YXJzOiBbXSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBibG9ja1xuICAgICAgfV1cbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoYmxvY2spKSB7XG4gICAgYmxvY2sgPSB7XG4gICAgICB2YXJzOiBbXSxcbiAgICAgIHZhbHVlOiBibG9ja1xuICAgIH07XG4gIH1cblxuICBsZXQgQ29uc3RydWN0b3I7XG5cbiAgaWYgKGlzSW5zdGFuY2VPZihCbG9jaywgYmxvY2spKSB7XG4gICAgQ29uc3RydWN0b3IgPSBibG9jaztcbiAgfSBlbHNlIHtcbiAgICBDb25zdHJ1Y3RvciA9IGNsYXNzIFJvb3RCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IGJsb2NrO1xuICAgIH07XG4gIH1cblxuICBjb25zdCByb290QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgbm9kZToge1xuICAgICAgbmFtZTogJyNSb290QmxvY2snLFxuICAgICAgQ29uc3RydWN0b3JcbiAgICB9LFxuICAgIHBhcmVudDogcGFyZW50RWxlbSxcbiAgICBwYXJlbnRFbGVtXG4gIH0pO1xuXG4gIHBhcmVudEVsZW1cbiAgICAucHJvcCgnRHdheW5lUm9vdEJsb2NrJywgcm9vdEJsb2NrKVxuICAgIC5hdHRyKCdkd2F5bmUtcm9vdCcsICcnKTtcbn1cbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi9CbG9jayc7XG5pbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gcmVtb3ZlQXBwXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIG9mIHRoZSBhcHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHJlbW92aW5nIGFwcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcmVtb3ZlQXBwLCBmaW5kIH0gZnJvbSAnZHdheW5lJztcbiAqXG4gKiByZW1vdmVBcHAoZmluZCgnLnJvb3QnKSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBcHAoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW0gPSBuZXcgRWxlbShjb250YWluZXIpLmVsZW0oMCk7XG5cbiAgaWYgKCFlbGVtLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgZWxlbWVudCB0byByZW1vdmUgdGhlIGFwcCBmcm9tIHdhcyBnaXZlbiEgKHJlbW92ZUFwcCknKTtcbiAgfVxuXG4gIGNvbnRhaW5lciA9IGVsZW1bMF07XG5cbiAgY29uc3QgeyBEd2F5bmVSb290QmxvY2sgfSA9IGNvbnRhaW5lcjtcblxuICBpZiAoIShEd2F5bmVSb290QmxvY2sgaW5zdGFuY2VvZiBCbG9jaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFwcCByZWdpc3RlcmVkIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCEgKHJlbW92ZUFwcCknKTtcbiAgfVxuXG4gIER3YXluZVJvb3RCbG9jay4kJC5yZW1vdmUoKTtcbiAgZWxlbS5yZW1vdmVBdHRyKCdkd2F5bmUtcm9vdCcpO1xuXG4gIGRlbGV0ZSBjb250YWluZXIuRHdheW5lUm9vdEJsb2NrO1xufVxuIiwiLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG4vKiBlc2xpbnQgbm8tbmVnYXRlZC1jb25kaXRpb246IDAgKi9cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG4iLCJleHBvcnQgY29uc3Qge1xuICBjcmVhdGUsXG4gIGtleXMsXG4gIGdldFByb3RvdHlwZU9mOiBnZXRQcm90b1xufSA9IE9iamVjdDtcblxuZXhwb3J0IGNvbnN0IHNldFByb3RvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgodGFyZ2V0LCBwcm90bykgPT4ge1xuICAvKiBlc2xpbnQgbm8tcHJvdG86IDAgKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHByb3RvO1xufSk7XG4iLCJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICcuL3V0aWxzL29iamVjdFN0YXRpY3MnO1xuXG5leHBvcnQgY29uc3QgSElERV9DTEFTUyA9ICdfX2R3YXluZS1oaWRkZW5fXyc7XG5leHBvcnQgY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmV4cG9ydCBjb25zdCBEX1JFU1RfUkVHRVggPSAvXmQtcmVzdCg/OiN8JCkvO1xuXG5leHBvcnQgY29uc3Qgcm9vdEJsb2NrcyA9IGNyZWF0ZShudWxsKTtcbmV4cG9ydCBjb25zdCByb290TWl4aW5zID0gY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IHtcbiAgZG9jdW1lbnQgPSB7fSxcbiAgU3ltYm9sID0ge31cbn0gPSBnbG9iYWw7XG4iLCJpbXBvcnQge1xuICBpc05pbCwgaXNTdHJpbmcsXG4gIGRlZmluZVByb3RvdHlwZVByb3BlcnRpZXMsXG4gIGNvbGxlY3RGcm9tQXJyYXksIGNvbGxlY3RGcm9tT2JqZWN0LFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3QsXG4gIHRvSHlwaGVuQ2FzZSwgc2V0U3ltYm9sU3BlY2llcyxcbiAgc2V0VG9TdHJpbmdUYWcsIHNldFByb3RvXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgaXNEb2N1bWVudCwgaXNWYWxpZE5vZGUsIGdldE1hdGNoZXNGdW5jdGlvbixcbiAgYWRkQXR0ciwgYWRkQ1NTUHJvcCwgYWRkRGF0YUF0dHIsXG4gIGFkZE5leHQsIGFkZFBhcmVudCwgYWRkUHJldixcbiAgdG9FbGVtLCBpc0VsZW1lbnRzQ29sbGVjdGlvbixcbiAgZ2V0QXR0ck5TLCBnZXRFdmVudCwgaGlkZSwgc2hvdywgcmVtb3ZlXG59IGZyb20gJy4vaGVscGVycy9FbGVtJztcbmltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd9IEVsZW1FdmVudFN0cmluZ1xuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIGNvbnRhaW5pbmcgZXZlbnRzIHNlcGFyYXRlZCBieSBhIGNvbW1hIHdpdGggemVybyBvciBtb3JlIHNwYWNlcyBvciBqdXN0IHNwYWNlcy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtTGlzdGVuZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBGaXJlZCBldmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIEVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIHdhcyBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgbGlzdGVuZXIgd2FzIGNhbGxlZC5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGVtUmVtb3ZlTGlzdGVuZXJzXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gey4uLkVsZW1FdmVudFN0cmluZ30gZXZlbnRzIC0gSWYgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IHByZXNlbnQgb25seSByZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBldmVudHMgaW4gdGhlIGFyZ3VtZW50cy5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBJdGVyYXRpb25DYWxsYmFja1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9IG5vZGUgLSBJdGVyYXRpb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEl0ZXJhdGlvbiBpbmRleC5cbiAqIEBwYXJhbSB7RWxlbX0gZWxlbSAtIEluaXRpYWwgc2V0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsZW1NZXRob2RcbiAqIEBwdWJsaWNcbiAqIEB0aGlzIEVsZW1cbiAqL1xuXG5jb25zdCBFVkVOVF9TRVBBUkFUT1JfUkVHRVggPSAvKD86LHwgKSAqLztcbmNvbnN0IENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYID0gLzsgPy87XG5jb25zdCBDU1NfSU1QT1JUQU5UX1JFR0VYID0gLyA/IWltcG9ydGFudCQvO1xuY29uc3QgWEhUTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBlbXB0eUNvbGxlY3Rpb24gPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgRWxlbVxuICogQGV4dGVuZHMgQXJyYXkuPEVsZW1lbnR8Tm9kZT5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IFtlbGVtID0gW11dIC0gQW4gZWxlbWVudCBvciBhbiBhcnJheSBvZiBlbGVtZW50cyB0byB3cmFwLlxuICogQHJldHVybnMge0VsZW19IEluc3RhbmNlIG9mIEVsZW0uXG4gKiBAZGVzY3JpcHRpb24gV3JhcCBvZiBhbiBlbGVtZW50cyBzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmJvZHkpO1xuICogbmV3IEVsZW0oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNscycpKTtcbiAqIG5ldyBFbGVtKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NscycpKTtcbiAqL1xuY2xhc3MgRWxlbSBleHRlbmRzIEFycmF5IHtcbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbS5hZGRNZXRob2RzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsIEVsZW1NZXRob2Q+fSBtZXRob2ROYW1lIC0gTmFtZSBvZiB0aGUgbWV0aG9kIG9yIG9iamVjdCBvZlxuICAgKiBtZXRob2QgbmFtZXMgYW5kIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7RWxlbU1ldGhvZH0gW21ldGhvZF0gLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgdGhpcyBzaG91bGQgYmUgdGhlIG1ldGhvZCBpdHNlbGYuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgRWxlbX1cbiAgICovXG4gIHN0YXRpYyBhZGRNZXRob2RzKG1ldGhvZE5hbWUsIG1ldGhvZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIG1ldGhvZE5hbWUgPSB7IFttZXRob2ROYW1lXTogbWV0aG9kIH07XG4gICAgfVxuXG4gICAgZGVmaW5lUHJvdG90eXBlUHJvcGVydGllcyh0aGlzLnByb3RvdHlwZSwgbWV0aG9kTmFtZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGVsZW0gPSBlbXB0eUNvbGxlY3Rpb24pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKCFpc0VsZW1lbnRzQ29sbGVjdGlvbihlbGVtKSkge1xuICAgICAgZWxlbSA9IFtlbGVtXTtcbiAgICB9XG5cbiAgICBzZXRQcm90byh0aGlzLCBFbGVtLnByb3RvdHlwZSk7XG5cbiAgICBpdGVyYXRlQXJyYXkoZWxlbSwgKGVsZW0pID0+IHtcbiAgICAgIGlmICghaXNFbGVtZW50c0NvbGxlY3Rpb24oZWxlbSkpIHtcbiAgICAgICAgZWxlbSA9IFtlbGVtXTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUFycmF5KGVsZW0sIChlbGVtKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlcyhlbGVtKSAmJiBpc1ZhbGlkTm9kZShlbGVtKSkge1xuICAgICAgICAgIHRoaXMucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2FkZFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uKEVsZW18RWxlbWVudHxFbGVtZW50W10pfSBlbGVtZW50cyAtIEVhY2ggYXJndW1lbnQgaXMgYSBFbGVtLCBvciBFbGVtZW50LCBvciBhcnJheSBvZiBFbGVtZW50cy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgYWRkaW5nIG5ldyBlbGVtZW50cyB0byB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtMS5maW5kKCcuY2xzMScpXG4gICAqICAgLmFkZChlbGVtMi5maW5kKCcuY2xzMicpKVxuICAgKiAgIC5oaWRlKCk7XG4gICAqL1xuICBhZGQoKSB7XG4gICAgY29uc3QgZWxlbXMgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoZWxlbSkgPT4ge1xuICAgICAgaWYgKCFpc0VsZW1lbnRzQ29sbGVjdGlvbihlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlQXJyYXkoZWxlbSwgKGVsZW0pID0+IHtcbiAgICAgICAgaWYgKCFlbGVtcy5pbmNsdWRlcyhlbGVtKSAmJiBpc1ZhbGlkTm9kZShlbGVtKSkge1xuICAgICAgICAgIGVsZW1zLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNhZGRDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBjbGFzc2VzIC0gQ2xhc3NlcyB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGFkZGluZyBjbGFzc2VzIHRvIHRoZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ3JlZCcsICdyb3VuZCcpO1xuICAgKi9cbiAgYWRkQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoY2xzKSA9PiBsaXN0LmFkZChjbHMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jYXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbYXR0cl0gLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0IG9yXG4gICAqIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW2F0dHJOYW1lXTogdmFsdWUsIC4uLiB9IHRvIHNldCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICAgKiBpdCBzaG91bGQgYmUgYSB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN0cmluZ3xFbGVtfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkLCBELVdyYXAgb2YgYXR0cmlidXRlcyBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHJldHVybmVkLCBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuICAgKiByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hdHRyKCdhdHRyMScsICd2YWx1ZTEnKTsgLy8gYXR0cmlidXRlIGF0dHIxIHNldCB0byAndmFsdWUxJyBhbmQgdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmF0dHIoJ2F0dHIxJyk7ICAgICAgICAgICAvLyAndmFsdWUxJ1xuICAgKiBlbGVtLmF0dHIoe1xuICAgKiAgIGF0dHIxOiAndmFsdWUzJywgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgYXR0cjEgc2V0IHRvICd2YWx1ZTMnXG4gICAqICAgYXR0cjI6ICd2YWx1ZTInICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBhdHRyMiBzZXQgdG8gJ3ZhbHVlMidcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmF0dHIoKTsgICAgICAgICAgICAgICAgICAvLyB7IGF0dHIxOiAndmFsdWUzJywgYXR0cjI6ICd2YWx1ZTInIH1cbiAgICovXG4gIGF0dHIoYXR0ciwgdmFsdWUpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tQXJyYXkoZWxlbS5hdHRyaWJ1dGVzLCBhZGRBdHRyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKGF0dHIpKSB7XG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbnMsXG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBnZXRBdHRyTlMoYXR0ciwgZWxlbSk7XG5cbiAgICAgIHJldHVybiBuc1xuICAgICAgICA/IGVsZW0uZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpXG4gICAgICAgIDogZWxlbS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgYXR0ciA9IHsgW2F0dHJdOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QoYXR0ciwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQXR0cihrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWU7XG5cbiAgICAgICAgY29uc3QgeyBucyB9ID0gZ2V0QXR0ck5TKGtleSwgZWxlbSk7XG5cbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGVOUyhucywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjaGlsZHJlblxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBELVdyYXAgb2YgdGhlIGNoaWxkcmVuIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGdldHRpbmcgZWxlbWVudCdzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBjaGlsZHJlbiA9IGVsZW0uY2hpbGRyZW4oKTtcbiAgICovXG4gIGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBuZXcgRWxlbSh0aGlzLmxlbmd0aCA/IHRoaXNbMF0uY2hpbGROb2RlcyA6IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY2xvc2VzdFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlZSB0aGUgbGluay5cbiAgICogQHJldHVybnMge0VsZW19IFNldCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50cy5cbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFbGVtZW50I2Nsb3Nlc3Rde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3R9LlxuICAgKi9cbiAgY2xvc2VzdChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgd2hpbGUgKGVsZW0pIHtcbiAgICAgICAgaWYgKG5ldyBFbGVtKGVsZW0pLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBhZGQoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29sbGVjdChjYWxsYmFjaykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgY29uc3QgY2IgPSA6OmVsZW1lbnRzLnB1c2g7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0sIGluZGV4KSA9PiB7XG4gICAgICBjYWxsYmFjayhjYiwgZWxlbSwgaW5kZXgsIHRoaXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBFbGVtKGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jY29udGFpbnNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gZmluZCBvdXQgaWYgaXQncyB3aXRoaW4gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgaWYgdGhlIGFyZ3VtZW50IHdpdGhpbiB0aGlzIGVsZW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgZXh0ZW5zaW9uIGZvclxuICAgKiBbTm9kZSNjb250YWluc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvY29udGFpbnN9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNvbnRhaW5zKGVsZW0yKTsgICAvLyB0cnVlfGZhbHNlXG4gICAqL1xuICBjb250YWlucyhlbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1swXTtcbiAgICBjb25zdCBjaGlsZCA9IHRvRWxlbShlbGVtZW50KVswXTtcblxuICAgIHJldHVybiAhcGFyZW50IHx8ICFjaGlsZFxuICAgICAgPyBmYWxzZVxuICAgICAgOiBwYXJlbnQuY29udGFpbnMoY2hpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjcmVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFR5cGUgb2YgY3JlYXRlZCBlbGVtZW50LiBJZiB0eXBlIGlzIFwiI3RleHRcIiBhIHRleHQgbm9kZSBpcyBjcmVhdGVkLlxuICAgKiBJZiB0eXBlIGlzIFwiI2NvbW1lbnRcIiBhIGNvbW1lbnQgbm9kZSBpcyBjcmVhdGVkLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0gLSB3cmFwIG9mIHRoZSBjcmVhdGVkIGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBjcmVhdGluZyBlbGVtZW50cyBpbnNpZGUgdGhpcyBlbGVtZW50LlxuICAgKiBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnQgdGhlIGVsZW1lbnQgaXMganVzdCBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNyZWF0ZSgnZGl2Jyk7XG4gICAqL1xuICBjcmVhdGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoKGFkZCwgZWxlbSkgPT4ge1xuICAgICAgbGV0IGVsID0gbnVsbDtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHR5cGUgPT09ICcjdGV4dCc7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbSlcbiAgICAgICAgPyBlbGVtXG4gICAgICAgIDogZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICBpZiAoaXNUZXh0IHx8IHR5cGUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgZWwgPSBpc1RleHRcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IHR5cGUgPT09ICdzdmcnXG4gICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0RvY3VtZW50KGVsZW0pKSB7XG4gICAgICAgIG5ldyBFbGVtKGVsKS5pbnRvKGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBhZGQoZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNjc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3Byb3BlcnR5XSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldCBvclxuICAgKiBhbiBvYmplY3Qgb2YgdGhlIGZvcm1hdCB7IFtwcm9wZXJ0eV06IHZhbHVlLCAuLi4gfSB0byBzZXQgc3R5bGVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBzaG91bGQgYmUgYSB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfEVsZW19IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQsIEQtV3JhcCBvZiBjc3Mgc3R5bGVzIG9mIHRoZSBlbGVtZW50IHJldHVybmVkLFxuICAgKiBpZiAxIHN0cmluZyBhcmd1bWVudCBpcyBwYXNzZWQgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSByZXR1cm5lZCBvdGhlcndpc2UgcmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nL3NldHRpbmcgc3R5bGVzLiBTdXBwb3J0cyAhaW1wb3J0YW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmNzcygnZGlzcGxheScsICdub25lJyk7IC8vIGRpc3BsYXkgc2V0IHRvICdub25lJyBhbmQgdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmNzcygnZGlzcGxheScpOyAgICAgICAgIC8vICdub25lJ1xuICAgKiBlbGVtLmNzcyh7XG4gICAqICAgZGlzcGxheTogJ2lubGluZScsICAgICAgICAgLy8gZGlzcGxheSBzZXQgdG8gJ2lubGluZSdcbiAgICogICBjdXJzb3I6ICdwb2ludGVyJyAgICAgICAgICAvLyBjdXJzb3Igc2V0IHRvICdwb2ludGVyJ1xuICAgKiB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcmV0dXJuZWRcbiAgICogZWxlbS5jc3MoKTsgICAgICAgICAgICAgICAgICAvLyB7IGRpc3BsYXk6ICdub25lJywgY3Vyc29yOiAncG9pbnRlcicgfVxuICAgKi9cbiAgY3NzKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXNbMF0gfHwge307XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdEZyb21BcnJheShzdHlsZS5jc3NUZXh0LnNwbGl0KENTU19TVFlMRVNfU0VQQVJBVE9SX1JFR0VYKSwgYWRkQ1NTUHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSAmJiBpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBwcm9wZXJ0eSA9IHRvSHlwaGVuQ2FzZShwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSArIChzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHByb3BlcnR5KSA/ICcgIWltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgcHJvcGVydHkgPSB7IFtwcm9wZXJ0eV06IHZhbHVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgaXRlcmF0ZU9iamVjdChwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBwcm9wZXJ0eSA9IHRvSHlwaGVuQ2FzZShwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW0oZWxlbSkucmVtb3ZlQ1NTKHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlLnJlcGxhY2UoQ1NTX0lNUE9SVEFOVF9SRUdFWCwgJycpLFxuICAgICAgICAgIENTU19JTVBPUlRBTlRfUkVHRVgudGVzdCh2YWx1ZSkgPyAnaW1wb3J0YW50JyA6ICcnXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZGF0YVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBba2V5XSAtIE5hbWUgb2YgdGhlIGRhdGEgYXR0cmlidXRlICh3aXRob3V0IGRhdGEtIHByZWZpeClcbiAgICogdG8gZ2V0IG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybWF0IHsgW2F0dHJOYW1lXTogdmFsdWUsIC4uLiB9IHRvIHNldCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBzaG91bGQgYmUgYSB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN0cmluZ3xFbGVtfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkLCBELVdyYXAgb2YgZGF0YXNldCBvZiB0aGUgZWxlbWVudCByZXR1cm5lZCxcbiAgICogaWYgMSBzdHJpbmcgYXJndW1lbnQgaXMgcGFzc2VkIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YSBhdHRyaWJ1dGUgcmV0dXJuZWQgb3RoZXJ3aXNlIHJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZ2V0dGluZy9zZXR0aW5nIGRhdGEgYXR0cmlidXRlcy4gU2VlXG4gICAqIFtIVE1MRWxlbWVudCNkYXRhc2V0XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvZGF0YXNldH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZGF0YSgnc29tZUtleTEnLCAndmFsdWUnKTsgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkxIHNldCB0byAndmFsdWUxJyBhbmQgdGhpcyByZXR1cm5lZFxuICAgKiBlbGVtLmRhdGEoJ3NvbWVLZXkxJyk7ICAgICAgICAgIC8vICd2YWx1ZTEnXG4gICAqIGVsZW0uZGF0YSh7XG4gICAqICAgc29tZUtleTE6ICd2YWx1ZTMnLCAgICAgICAgICAgLy8gYXR0cmlidXRlIGRhdGEtc29tZS1rZXkxIHNldCB0byAndmFsdWUzJ1xuICAgKiAgIHNvbWVLZXkyOiAndmFsdWUyJyAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBkYXRhLXNvbWUta2V5MiBzZXQgdG8gJ3ZhbHVlMidcbiAgICogfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJldHVybmVkXG4gICAqIGVsZW0uZGF0YSgpOyAgICAgICAgICAgICAgICAgICAgLy8geyBzb21lS2V5MTogJ3ZhbHVlMycsIHNvbWVLZXkyOiAndmFsdWUyJyB9XG4gICAqL1xuICBkYXRhKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXNbMF0gfHwge307XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghZGF0YXNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0RnJvbU9iamVjdChkYXRhc2V0LCBhZGREYXRhQXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNTdHJpbmcoa2V5KSkge1xuICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFzZXRba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBrZXkgPSB7IFtrZXldOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3Qoa2V5LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBlbGVtLmRhdGFzZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2Rpc3BhdGNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR9IGV2ZW50IC0gRXZlbnQgb3IgYSBzdHJpbmcgKG5ldyBFdmVudChldmVudCkgaXMgY3JlYXRlZCkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlscyA9IHt9XSAtIE9iamVjdCB0aGF0IGlzIGFzc2lnbmVkIHRvIHRoZSBldmVudC5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnQvRXZlbnRcbiAgICogQGRlc2NyaXB0aW9uIFN5bm9ueW0gZm9yXG4gICAqIFtFdmVudFRhcmdldCNkaXNwYXRjaEV2ZW50XXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvZGlzcGF0Y2hFdmVudH0uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJyk7XG4gICAqIGVsZW0uZGlzcGF0Y2goJ2NsaWNrJywgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsbGFibGU6IGZhbHNlLCBkYXRhOiAxIH0pO1xuICAgKiBlbGVtLmRpc3BhdGNoKG5ldyBDdXN0b21FdmVudCgnY3VzdG9tLWV2ZW50JykpO1xuICAgKi9cbiAgZGlzcGF0Y2goZXZlbnQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1YmJsZXMgPSB0cnVlLFxuICAgICAgY2FuY2VsYWJsZSA9IHRydWUsXG4gICAgICAuLi5yZWFsRGV0YWlsc1xuICAgIH0gPSBkZXRhaWxzO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGdldEV2ZW50KFxuICAgICAgICBldmVudCxcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZSxcbiAgICAgICAgcmVhbERldGFpbHMsXG4gICAgICAgIGVsZW1cbiAgICAgICkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNlbGVtXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleCA9IDBdIC0gSW5kZXggb2YgdGhlIGVsZW1lbnQgb2YgdGhlIHNldCB0byBnZXQuIE5lZ2F0aXZlIGluZGV4IG1lYW5zIGVsZW0ubGVuZ3RoICsgaW5kZXguXG4gICAqIEByZXR1cm5zIHtFbGVtfSBOZXcgaW5zdGFuY2Ugb2YgRWxlbS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5lbGVtKDEpOyAvLyBhIHdyYXAgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIHNldCB0aGF0IGhhcyBpbmRleCAxXG4gICAqIGVsZW0uZWxlbSgpOyAgLy8gYSB3cmFwIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXQgdGhhdCBoYXMgaW5kZXggMFxuICAgKi9cbiAgZWxlbShpbmRleCA9IDApIHtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMubGVuZ3RoICsgaW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFbGVtKHRoaXNbaW5kZXhdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jZmlsdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja3xTdHJpbmd9IGZpbHRlciAtIEZpbHRlciBmdW5jdGlvbiBvciBhIHNlbGVjdG9yLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbHRlcmluZyBlbGVtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5maWx0ZXIoKGVsZW0pID0+IG5ldyBFbGVtKGVsZW0pLmNsb3Nlc3QoJy5wYXJlbnQnKSk7XG4gICAqL1xuICBmaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKGZpbHRlcikpIHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZmlsdGVyO1xuXG4gICAgICBmaWx0ZXIgPSAoZWxlbSkgPT4gKFxuICAgICAgICBuZXcgRWxlbShlbGVtKS5pcyhzZWxlY3RvcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGZpbHRlcihlbGVtLCBpbmRleCwgdGhpcykpIHtcbiAgICAgICAgYWRkKGVsZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmaW5kXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gZmluZC5cbiAgICogQHJldHVybnMge0VsZW19IE5ldyBpbnN0YW5jZSBvZiBFbGVtLlxuICAgKiBAZGVzY3JpcHRpb24gU3lub255bSBmb3JcbiAgICogW0VsZW1lbnQjcXVlcnlTZWxlY3RvckFsbF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcXVlcnlTZWxlY3RvckFsbH0uXG4gICAqL1xuICBmaW5kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCgoYWRkLCBlbGVtKSA9PiB7XG4gICAgICBhZGQoZmluZChzZWxlY3RvciwgZWxlbSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNmb3JFYWNoXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtJdGVyYXRpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgb24gZWFjaCBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGZpbmQoJy5jbHMnKS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCwgc2V0KSA9PiB7XG4gICAqICAgLy8gZG8gc29tZXRoaW5nXG4gICAqIH0pO1xuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIGl0ZXJhdGVBcnJheSh0aGlzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY2FsbGJhY2sodmFsdWUsIGtleSwgdGhpcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGF0dHJpYnV0ZS5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0aGF0IHJldHVybnMgaWYgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgdGhlIGF0dHJpYnV0ZSBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYXR0cignYXR0cicsICd2YWx1ZScpLmhhc0F0dHIoJ2F0dHInKTsgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2F0dHInKS5oYXNBdHRyKCdhdHRyJyk7ICAgIC8vIGZhbHNlXG4gICAqL1xuICBoYXNBdHRyKGF0dHIpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIGlmICghZWxlbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgIHJldHVybiBuc1xuICAgICAgPyBlbGVtLmhhc0F0dHJpYnV0ZU5TKG5zLCBhdHRyKVxuICAgICAgOiBlbGVtLmhhc0F0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaGFzQ2xhc3NcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIC0gTmFtZSBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyB0aGUgY2xhc3MuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdGhhdCByZXR1cm5zIGlmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIHRoZSBjbGFzcyBvciBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uYWRkQ2xhc3MoJ2NscycpLmhhc0NsYXNzKCdjbHMnKTsgICAgLy8gdHJ1ZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdjbHMnKS5oYXNDbGFzcygnY2xzJyk7IC8vIGZhbHNlXG4gICAqL1xuICBoYXNDbGFzcyhjbHMpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNscylcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2hpZGVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gSGlkZXMgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0uaGlkZSgpO1xuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGhpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNodG1sXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd8Kn0gW2h0bWxdIC0gSFRNTCB0byB3cml0ZSBpbnN0ZWFkIG9mIGN1cnJlbnQgSFRNTC5cbiAgICogQHJldHVybnMge0VsZW18U3RyaW5nfSBJZiBubyBhcmd1bWVudHMgcGFzc2VkIEhUTUwgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldCByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIGFsbCBlbGVtZW50cyBIVE1MIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgaHRtbCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyBIVE1MLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmh0bWwoJzxkaXY+MTwvZGl2PicpO1xuICAgKiBlbGVtLmh0bWwoKTsgLy8gJzxkaXY+MTwvZGl2PidcbiAgICovXG4gIGh0bWwoaHRtbCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgIHJldHVybiBlbGVtXG4gICAgICAgID8gZWxlbS5pbm5lckhUTUxcbiAgICAgICAgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH1cblxuICBpbmNsdWRlcyhlbGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEFmdGVyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGluc2VydCB0aGlzIGVsZW1lbnQgYWZ0ZXIuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBQdXRzIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzZXQgYWZ0ZXIgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRBZnRlcihlbGVtMik7XG4gICAqIGVsZW0uaW5zZXJ0QWZ0ZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmluc2VydEFmdGVyKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRBZnRlcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRvRWxlbShlbGVtZW50KS5lbGVtKDApO1xuXG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHQoKVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpZiAoZWxlbSA9PT0gZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbSwgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI2luc2VydEJlZm9yZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7RWxlbXxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBpbnNlcnQgdGhpcyBlbGVtZW50IGJlZm9yZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFB1dHMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNldCBiZWZvcmUgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudC5cbiAgICogVGhlIGVsZW1lbnRzIHJlbWFpbiBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5pbnNlcnRCZWZvcmUoZWxlbTIpO1xuICAgKiBlbGVtLmluc2VydEJlZm9yZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWQnKSk7XG4gICAqIGVsZW0uaW5zZXJ0QmVmb3JlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICBpbnNlcnRCZWZvcmUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudCkuZWxlbSgwKTtcblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXG4gICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudFswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNpbnRvXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtfEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHB1dCB0aGlzIGVsZW1lbnRzIGludG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kIC0gSWYgdGhlIGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgZW5kLiBJZiBmYWxzZSB0aGV5IGFyZSBpbnNlcnRlZCB0byB0aGUgc3RhcnQuXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgaXMgc2ltaWxhciB0b1xuICAgKiBbTm9kZSNhcHBlbmRDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvYXBwZW5kQ2hpbGR9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLmludG8oZWxlbTIpO1xuICAgKiBlbGVtLmludG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lkJykpO1xuICAgKiBlbGVtLmludG8oJyNpZCBkaXYuYzEnKTtcbiAgICovXG4gIGludG8oZWxlbWVudCwgZW5kID0gdHJ1ZSkge1xuICAgIGVsZW1lbnQgPSB0b0VsZW0oZWxlbWVudClbMF07XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZW5kICYmIGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpc1tpXSwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jaXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBTeW5vbnltIGZvclxuICAgKiBbRWxlbWVudCNtYXRjaGVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5hZGRDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0uaXMoJy5jbHMnKTsgICAgICAgICAvLyB0cnVlXG4gICAqXG4gICAqIGVsZW0ucmVtb3ZlQ2xhc3MoJ2NscycpO1xuICAgKiBlbGVtLmlzKCcuY2xzJyk7ICAgICAgICAgLy8gZmFsc2VcbiAgICovXG4gIGlzKHNlbGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSB0aGlzWzBdO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRNYXRjaGVzRnVuY3Rpb24oZWxlbSk7XG5cbiAgICByZXR1cm4gZWxlbTo6bWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfHZvaWR9IG5vZGVOYW1lIChsb3dlcmNhc2VkKSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciBnZXR0aW5nIG5hbWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5jcmVhdGUoJ2RpdicpLm5hbWUoKSAvLyAnZGl2J1xuICAgKi9cbiAgbmFtZSgpIHtcbiAgICBjb25zdCBlbGVtID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtXG4gICAgICA/IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI25leHRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm5leHQoKTsgLy8gZmluZHMgbmV4dCBlbGVtZW50IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqL1xuICBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3QoYWRkTmV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI29uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFbGVtRXZlbnRTdHJpbmd8T2JqZWN0LjxFbGVtRXZlbnRTdHJpbmd8RWxlbUxpc3RlbmVyPn0gZXZlbnQgLSBFaXRoZXIgYSB7QGxpbmsgRWxlbUV2ZW50U3RyaW5nfSBzdHJpbmdcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggZXZlbnQga2V5cyAoYSBrZXkgaXMgYWxzbyBFbGVtRXZlbnRTdHJpbmcpIGFuZCBsaXN0ZW5lcnMgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0VsZW1MaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBpdCBtdXN0IGJlIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yXG4gICAqIHNwZWNpZmllZCBldmVudChzKS5cbiAgICogQHJldHVybnMge0VsZW1SZW1vdmVMaXN0ZW5lcnN9IEZ1bmN0aW9uIHRoYXQgdGFrZXMgb3B0aW9uYWwgZXZlbnQgYXJndW1lbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGRhdGFsaXN0LCBrZXlnZW4sIG91dHB1dCcsXG4gICAqICAgKGUsIGVsZW0sIGluZGV4KSA9PiBjb25zb2xlLmxvZyhlbGVtLnZhbHVlKVxuICAgKiApO1xuICAgKiBlbGVtLm9uKFxuICAgKiAgICdjaGFuZ2UsIGlucHV0JyxcbiAgICogICAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpXG4gICAqICk7XG4gICAqIGVsZW0ub24oXG4gICAqICAge1xuICAgKiAgICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICAgJ2JsdXInOiAoKSA9PiBjb25zb2xlLmxvZygnYmx1cicpXG4gICAqICAgfSxcbiAgICogICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGRhdGFsaXN0LCBrZXlnZW4sIG91dHB1dCdcbiAgICogKTtcbiAgICpcbiAgICogY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZWxlbS5vbih7XG4gICAqICAgJ2NoYW5nZSwgaW5wdXQnOiAoZSwgZWxlbSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGVsZW0udmFsdWUpLFxuICAgKiAgICdibHVyJzogKCkgPT4gY29uc29sZS5sb2coJ2JsdXInKVxuICAgKiB9KTtcbiAgICpcbiAgICogcmVtb3ZlTGlzdGVuZXJzKCdjbGljaycpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoJ2JsdXIsIGNoYW5nZScsICdpbnB1dCcpO1xuICAgKiByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICovXG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChpc1N0cmluZyhldmVudCkpIHtcbiAgICAgIGV2ZW50ID0geyBbZXZlbnRdOiBsaXN0ZW5lciB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0V2ZW50cyA9IHt9O1xuICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IHt9O1xuXG4gICAgaXRlcmF0ZU9iamVjdChldmVudCwgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgaXRlcmF0ZUFycmF5KGV2ZW50LnNwbGl0KEVWRU5UX1NFUEFSQVRPUl9SRUdFWCksIChldmVudCkgPT4ge1xuICAgICAgICAobmV3RXZlbnRzW2V2ZW50XSA9IG5ld0V2ZW50c1tldmVudF0gfHwgW10pLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3RXZlbnRzLCAobGlzdGVuZXJzLCBldmVudCkgPT4ge1xuICAgICAgICBpdGVyYXRlQXJyYXkobGlzdGVuZXJzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgKGFsbExpc3RlbmVyc1tldmVudF0gPSBhbGxMaXN0ZW5lcnNbZXZlbnRdIHx8IFtdKS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkoZXZlbnQuc3BsaXQoRVZFTlRfU0VQQVJBVE9SX1JFR0VYKSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuXG4gICAgICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGl0ZXJhdGVBcnJheShyZW1vdmVMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcikgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGFsbExpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZU9iamVjdChhbGxMaXN0ZW5lcnMsIChyZW1vdmVMaXN0ZW5lcnMsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaXRlcmF0ZUFycmF5KHJlbW92ZUxpc3RlbmVycywgKHJlbW92ZUxpc3RlbmVyKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcblxuICAgICAgICAgIGRlbGV0ZSBhbGxMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNwYXJlbnRcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB3cmFwIG9mIHRoZSBzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICovXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGFkZFBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3ByZXZcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gTmV3IGluc3RhbmNlIG9mIEVsZW0uXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGZpbmRpbmcgcHJldmlvdXMgZWxlbWVudCB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5wcmV2KCk7IC8vIGZpbmRzIHByZXZpb3VzIGVsZW1lbnQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICovXG4gIHByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChhZGRQcmV2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcHJvcFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLCAqPn0gcHJvcGVydHkgLSBFaXRoZXIgYSBzdHJpbmcgb2YgYSBwcm9wZXJ0eSBvciBhbiBhc3NpZ25lZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIElmIGEgcHJvcGVydHkgcGFyYW1ldGVyIGlzIGEgc3RyaW5nXG4gICAqIHRoaXMgaGFzIHRvIGJlIGFuIGFzc2lnbmVkIHZhbHVlIGlmIGl0J3MgcHJlc2VudC5cbiAgICogQHJldHVybnMge0VsZW18Kn0gUmV0dXJucyB0aGlzIGlmIGl0J3Mgc2V0dGVyIG9yIGEgdmFsdWUgaWYgZ2V0dGVyLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRoYXQgaXMgZWl0aGVyIGEgcHJvcGVydHkgZ2V0dGVyIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIG9yIGEgc2V0dGVyIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucHJvcCgnZHJhZ2dhYmxlJywgZmFsc2UpO1xuICAgKiBlbGVtLnByb3AoJ2RyYWdnYWJsZScpOyAvLyBmYWxzZVxuICAgKi9cbiAgcHJvcChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxICYmIGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBwcm9wZXJ0eSA9IHsgW3Byb3BlcnR5XTogdmFsdWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlT2JqZWN0KHByb3BlcnR5LCAodmFsdWUsIHByb3ApID0+IHtcbiAgICAgICAgZWxlbVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfSBSZXR1cm5zIHRoaXMuXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGZyb20gdGhlIGRvY3VtZW50LlxuICAgKiBOb3RlOiBpdCBkb2Vzbid0IHJlbW92ZSB0aGVtIGZyb20gdGhlIHNldCBzbyB3YXRjaCBvdXQgZm9yIHRoZSBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVsZW0ucmVtb3ZlKCk7XG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChyZW1vdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSNyZW1vdmVBdHRyXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUF0dHIoJ2ZvbycsICdiYXInLCAnYmF6Jyk7XG4gICAqL1xuICByZW1vdmVBdHRyKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGl0ZXJhdGVBcnJheShhcmd1bWVudHMsIChhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IGdldEF0dHJOUyhhdHRyLCBlbGVtKTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBhdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlbW92ZUNsYXNzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IGNsYXNzZXMgLSBDbGFzc2VzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIHRoZSBjbGFzc2VzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUNsYXNzKCdmb28nLCAnYmFyJywgJ2JheicpO1xuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xuXG4gICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoY2xzKSA9PiBsaXN0LnJlbW92ZShjbHMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jcmVtb3ZlQ1NTXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IHByb3BzIC0gQ1NTIHByb3BlcnRpZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgdGhlIENTUyBwcm9wZXJ0aWVzIGZyb20gYXJndW1lbnRzIGZyb20gYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnJlbW92ZUNTUygnZGlzcGxheScsICdwb3NpdGlvbicsICdtYXJnaW4nKTtcbiAgICovXG4gIHJlbW92ZUNTUygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBpdGVyYXRlQXJyYXkoYXJndW1lbnRzLCAoY3NzKSA9PiB7XG4gICAgICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkodG9IeXBoZW5DYXNlKGNzcykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3JlcGxhY2VcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0VsZW18RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gcmVwbGFjZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAqIHdpdGggYSBzZXQgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBhcmd1bWVudCAoRWxlbWVudCBvciBFbGVtKS5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpcyBzaW1pbGFyIHRvXG4gICAqIFtOb2RlI3JlcGxhY2VDaGlsZF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL05vZGUvcmVwbGFjZUNoaWxkfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5yZXBsYWNlKGVsZW0yKTtcbiAgICogZWxlbS5yZXBsYWNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZCcpKTtcbiAgICogZWxlbS5yZXBsYWNlKCcjaWQgZGl2LmMxJyk7XG4gICAqL1xuICByZXBsYWNlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdG9FbGVtKGVsZW1lbnQpO1xuXG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmVsZW0oMCk7XG4gICAgY29uc3QgcGFyZW50ID0gZmlyc3QucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBlbGVtID0gcGFyZW50O1xuICAgIGxldCBtZXRob2QgPSAnaW50byc7XG4gICAgY29uc3QgbmV4dCA9IGZpcnN0Lm5leHQoKVswXTtcbiAgICBjb25zdCBwcmV2ID0gZmlyc3QucHJldigpWzBdO1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIGVsZW0gPSBuZXh0O1xuICAgICAgbWV0aG9kID0gJ2luc2VydEJlZm9yZSc7XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbGVtID0gcHJldjtcbiAgICAgIG1ldGhvZCA9ICdpbnNlcnRBZnRlcic7XG4gICAgfVxuXG4gICAgZmlyc3QucmVtb3ZlKCk7XG5cbiAgICBlbGVtZW50W21ldGhvZF0oZWxlbSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3Nob3dcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gU2hvd3MgYWxsIGVsZW1lbnRzIGluIHRoZSBzZXQuXG4gICAqIElmIGFuIGVsZW1lbnQgd2FzIGhpZGRlbiB1c2luZyB7QGxpbmsgRWxlbSNoaWRlfSBwcmV2aW91cyBkaXNwbGF5IGlzIHNldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS5zaG93KCk7XG4gICAqL1xuICBzaG93KCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goc2hvdyk7XG4gIH1cblxuICBzbGljZSgpIHtcbiAgICByZXR1cm4gbmV3IEVsZW0oc3VwZXIuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBFbGVtI3RleHRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ3wqfSBbdGV4dF0gLSBUZXh0IHRvIHdyaXRlIGluc3RlYWQgb2YgY3VycmVudCB0ZXh0LlxuICAgKiBAcmV0dXJucyB7RWxlbXxTdHJpbmd9IElmIG5vIGFyZ3VtZW50cyBwYXNzZWQgdGV4dCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0IHJldHVybmVkLlxuICAgKiBPdGhlcndpc2UgYWxsIGVsZW1lbnRzIHRleHRzIGluIHRoZSBzZXQgYXJlIHNldCB0byB0aGUgdGV4dCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIEdldHMgb3Igc2V0cyB0ZXh0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnRleHQoJzEyMycpO1xuICAgKiBlbGVtLnRleHQoKTsgLy8gJzEyMydcbiAgICovXG4gIHRleHQodGV4dCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcCgndGV4dENvbnRlbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEVsZW0jdG9nZ2xlQXR0clxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIC0gQXR0cmlidXRlIHRvIHRvZ2dsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufCp9IFtjb25kaXRpb25dIC0gSWYgcHJlc2VudCBhbmQgdGhlIGNvbmRpdGlvbiBpcyB0cnV0aHkgbWV0aG9kIGFkZHMgdGhlIGF0dHJpYnV0ZVxuICAgKiB3aXRoIHRoZSAnJyB2YWx1ZSBhbmQgaWYgZmFsc2V5IG1ldGhvZCByZW1vdmVzIHRoZSBhdHRyaWJ1dGUuIElmIG5vdCBwcmVzZW50IG1ldGhvZCBhZGRzXG4gICAqIHRoZSBhdHRyaWJ1dGUgaWYgaXQgZG9lc24ndCBleGlzdCBhbmQgcmVtb3ZlcyBpZiBpdCBkb2VzLlxuICAgKiBAcmV0dXJucyB7RWxlbX0gUmV0dXJucyB0aGlzLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGZvciB0b2dnbGluZyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbGVtLnRvZ2dsZUF0dHIoJ2F0dHInKTtcbiAgICogZWxlbS50b2dnbGVBdHRyKCdhdHRyJywgc29tZUNvbmRpdGlvbik7XG4gICAqL1xuICB0b2dnbGVBdHRyKGF0dHIsIGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0gPSBuZXcgRWxlbShlbGVtKTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIWVsZW0uaGFzQXR0cihhdHRyKSA6IGNvbmRpdGlvbikge1xuICAgICAgICBlbGVtLmF0dHIoYXR0ciwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgRWxlbSN0b2dnbGVDbGFzc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMgLSBDbGFzcyB0byB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnwqfSBbY29uZGl0aW9uXSAtIElmIHByZXNlbnQgYW5kIHRoZSBjb25kaXRpb24gaXMgdHJ1dGh5IG1ldGhvZCBhZGRzIHRoZSBjbGFzc1xuICAgKiBhbmQgaWYgZmFsc2V5IG1ldGhvZCByZW1vdmVzIHRoZSBjbGFzcy4gSWYgbm90IHByZXNlbnQgbWV0aG9kIGFkZHNcbiAgICogdGhlIGNsYXNzIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHJlbW92ZXMgaWYgaXQgZG9lcy5cbiAgICogQHJldHVybnMge0VsZW19IFJldHVybnMgdGhpcy5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgdG9nZ2xpbmcgY2xhc3Nlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWxlbS50b2dnbGVDbGFzcygnY2xzJyk7XG4gICAqIGVsZW0udG9nZ2xlQ2xhc3MoJ2NscycsIHNvbWVDb25kaXRpb24pO1xuICAgKi9cbiAgdG9nZ2xlQ2xhc3MoY2xzLCBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gZWxlbTtcblxuICAgICAgY2xhc3NMaXN0LnRvZ2dsZShjbHMsIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gIWNsYXNzTGlzdC5jb250YWlucyhjbHMpIDogY29uZGl0aW9uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhFbGVtLCAnRWxlbScpO1xuc2V0U3ltYm9sU3BlY2llcyhFbGVtLCBBcnJheSk7XG5cbmV4cG9ydCB7IEVsZW0gfTtcbiIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTeW1ib2xTcGVjaWVzKGtsYXNzLCBzcGVjaWVzKSB7XG4gIGlmIChTeW1ib2wuc3BlY2llcykge1xuICAgIGRlZmluZVByb3BlcnRpZXMoa2xhc3MsIHtcbiAgICAgIFtTeW1ib2wuc3BlY2llc106IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIGRlZmluZUZyb3plblByb3BlcnRpZXMsXG4gIHJlbW92ZUFycmF5RWxlbSwgc2V0VG9TdHJpbmdUYWdcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB3cmFwTWl4aW4sIHJlbW92ZVdhdGNoZXJzIH0gZnJvbSAnLi9oZWxwZXJzL0Jsb2NrJztcblxuLyoqXG4gKiBAY2xhc3MgTWl4aW5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gTWl4aW4gb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtNaXhpbn0gSW5zdGFuY2Ugb2YgTWl4aW4uXG4gKi9cbmNsYXNzIE1peGluIHtcbiAgLyoqXG4gICAqIEBtZW1iZXIge0Jvb2xlYW59IFtNaXhpbi5ldmFsdWF0ZSA9IHRydWVdXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJZiB0aGUgbWl4aW4gdmFsdWUgc2hvdWxkIGJlIGV2YWx1YXRlZCBhbmQgd2F0Y2hlZCBvciBub3QuXG4gICAqL1xuICBzdGF0aWMgZXZhbHVhdGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1peGluLndyYXBcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gey4uLldyYXBwZXJ9IHdyYXBwZXJzIC0gRnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgbWl4aW4uXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgTWl4aW59IE5ldyBtaXhpbi5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3Igd3JhcHBpbmcgbWl4aW5zLlxuICAgKiBJdCBpcyBjb25zaWRlcmVkIGJlc3QgcHJhY3RpY2UgdG8ganVzdCBleHRlbmRzIHRoZSBvbGQgbWl4aW4gd2l0aCBhIG5ldyBvbmUuXG4gICAqL1xuICBzdGF0aWMgd3JhcCguLi53cmFwcGVycykge1xuICAgIHJldHVybiB3cmFwcGVycy5yZWR1Y2Uod3JhcE1peGluLCB0aGlzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBkeW5hbWljLFxuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjb21tZW50LFxuICAgICAgcGFyZW50QmxvY2ssXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3Qgd2F0Y2hlcnNUb1JlbW92ZSA9IFtdO1xuICAgIGNvbnN0IHdhdGNoZXJzID0gW107XG5cbiAgICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICQkOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIF92YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc0R5bmFtaWM6IGR5bmFtaWMsXG4gICAgICAgIHBhcmVudFNjb3BlLFxuICAgICAgICBwYXJlbnRCbG9jayxcbiAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgIHdhdGNoZXJzLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBpc1JlbW92ZWQ6IGZhbHNlLFxuICAgICAgICBldmFsdWF0ZTogKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc0R5bmFtaWMsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIF92YWx1ZVxuICAgICAgICAgIH0gPSB0aGlzLiQkO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGlzRHluYW1pY1xuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShfdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoaXNQYXJlbnRTaWduYWwpID0+IHtcbiAgICAgICAgICBpc1BhcmVudFNpZ25hbCA9ICEhaXNQYXJlbnRTaWduYWw7XG4gICAgICAgICAgdGhpcy4kJC5pc1JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgcmVtb3ZlV2F0Y2hlcnMod2F0Y2hlcnNUb1JlbW92ZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVSZW1vdmUoaXNQYXJlbnRTaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUFycmF5RWxlbShwYXJlbnRCbG9jay4kJC5taXhpbnMsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IFtNaXhpbiNhcmdzXVxuICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5hcmdzID0gYXJncztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gW01peGluI2NvbW1lbnRdXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jsb2NrfSBbTWl4aW4jcGFyZW50QmxvY2tdXG4gICAgICogQHR5cGUge0Jsb2NrfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudEJsb2NrID0gcGFyZW50QmxvY2s7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCbG9ja30gW01peGluI3BhcmVudFNjb3BlXVxuICAgICAqIEB0eXBlIHtCbG9ja31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QmxvY2t9IFtNaXhpbiNwYXJlbnRUZW1wbGF0ZV1cbiAgICAgKiBAdHlwZSB7QmxvY2t9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMucGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0VsZW19IE1peGluI2VsZW1cbiAgICAgKiBAdHlwZSB7RWxlbX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IE1peGluI25vZGVcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5ub2RlID0gZWxlbVswXTtcblxuICAgIHBhcmVudEJsb2NrLiQkLm1peGlucy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1peGluI2JlZm9yZVJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFbGVtZW50UmVtb3ZlZCAtIElmIGVsZW1lbnQgcmVtb3ZlZCBhcyB3ZWxsLlxuICAgKiBAZGVzY3JpcHRpb24gSXMgY2FsbGVkIGJlZm9yZSB0aGUgbWl4aW4gcmVtb3ZhbC5cbiAgICovXG4gIGJlZm9yZVJlbW92ZShpc0VsZW1lbnRSZW1vdmVkKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2V2YWx1YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtXYXRjaGVyfSBbY2FsbGJhY2tdIC0gSWYgcHJlc2VudCwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIG1peGluIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0aW9uIHJlc3VsdC5cbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBmb3IgZXZhbHVhdGluZyB0aGUgbWl4aW4gdmFsdWUgYW5kIHdhdGNoaW5nIGZvciB0aGUgY2hhbmdlcy5cbiAgICovXG4gIGV2YWx1YXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuJCQuZXZhbHVhdGUoY2FsbGJhY2spO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0IE1peGluXSc7XG4gIH1cbn1cblxuc2V0VG9TdHJpbmdUYWcoTWl4aW4sICdNaXhpbicpO1xuXG5leHBvcnQgeyBNaXhpbiB9O1xuIiwiaW1wb3J0IHsgRWxlbSB9IGZyb20gJy4vRWxlbSc7XG5pbXBvcnQge1xuICBkZWZpbmVGcm96ZW5Qcm9wZXJ0aWVzLFxuICBhc3NpZ24sIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCxcbiAgaXNGdW5jdGlvbiwgaXNBcnJheSxcbiAgc2V0VG9TdHJpbmdUYWcsIGhhc093blByb3BlcnR5LFxuICByZW1vdmVBcnJheUVsZW0sIGNyZWF0ZSxcbiAgZ2V0UHJvdG8sIHNldFByb3RvXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgY29uc3RydWN0TWl4aW5SZWdleCwgaXNJbnN0YW5jZU9mLFxuICByZW1vdmVXYXRjaGVycywgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCwgY2xlYW5Qcm9wZXJ0eSxcbiAgdHJhbnNmb3JtUmVzdEFyZ3MsIGNhbGN1bGF0ZUFyZ3MsIHdyYXBCbG9ja1xufSBmcm9tICcuL2hlbHBlcnMvQmxvY2snO1xuaW1wb3J0IHtcbiAgRF9SRVNUX1JFR0VYLFxuICByb290QmxvY2tzLCByb290TWl4aW5zXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi9NaXhpbic7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGVtcGxhdGVcbiAqIEBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IHZhcnMgLSBUZW1wbGF0ZSB1c2VkIHZhcnMuXG4gKiBAcHJvcGVydHkge09iamVjdFtdfSB2YWx1ZSAtIFRlbXBsYXRlIGl0c2VsZi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3RbXX0gU2NvcGVsZXNzVGVtcGxhdGVcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFcnJvcn0gRXZhbHVhdGlvbkVycm9yXG4gKiBAcHVibGljXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gd2hpY2ggY2F1c2VkIGV2YWwgZXJyb3IuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gb3JpZ2luYWwgLSBFdmFsdWF0ZWQgZXhwcmVzc2lvbiBvcmlnaW5hbCBqcy5cbiAqIEBwcm9wZXJ0eSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgaW4gY29udGV4dCBvZiB3aGljaCB0aGUgZXhwcmVzc2lvbiBoYXMgYmVlbiBldmFsdWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2F0Y2hlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgLSBPbGQgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV3JhcHBlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHt0eXBlb2YgQmxvY2t8dHlwZW9mIE1peGlufSBCbG9jayBjbGFzcyB0byB3cmFwLlxuICogQHJldHVybnMge3R5cGVvZiBCbG9ja30gTmV3IEJsb2NrIGNsYXNzLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEFmdGVyVXBkYXRlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gTmV3IHZhbHVlLlxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSAtIE9sZCB2YWx1ZS5cbiAqIEBwYXJhbSB7TWl4aW59IG1peGluIC0gTWl4aW4gaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQmxvY2tSZWdpc3Rlckhvb2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIEJsb2NrfSBCbG9jayAtIFJlZ2lzdGVyaW5nIGJsb2NrLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBuYW1lLlxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIHRoZSBibG9jay5cbiAqIElmIEJsb2NrIHN1YmNsYXNzIHJldHVybmVkIGl0J3MgcmVnaXN0ZXJlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsIGJsb2NrLCBvdGhlcndpc2VcbiAqIHRoZSBpbml0aWFsIGJsb2NrIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWl4aW5SZWdpc3Rlckhvb2tcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7dHlwZW9mIE1peGlufSBNaXhpbiAtIFJlZ2lzdGVyaW5nIG1peGluLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBNaXhpbiBuYW1lLlxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIHRoZSBtaXhpbi5cbiAqIElmIE1peGluIHN1YmNsYXNzIHJldHVybmVkIGl0J3MgcmVnaXN0ZXJlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsIG1peGluLCBvdGhlcndpc2VcbiAqIHRoZSBpbml0aWFsIG1peGluIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVtb3ZlSG9va1xuICogQHB1YmxpY1xuICovXG5cbmNvbnN0IGJsb2NrSG9va3MgPSBbXTtcbmNvbnN0IG1peGluSG9va3MgPSBbXTtcbmNvbnN0IFRBR19OQU1FX1JFR0VYID0gL15bYS16XVthLXpcXGRcXC1fLjohQCMkJV4mKigpW1xcXXt9PSdcIlxcXFxdKiQvaTtcbmNvbnN0IEFUVFJfTkFNRV9SRUdFWCA9IC9eW15cXHUwMDAwLVxcdTAwMjBcXHMnXCI+Lz1dKyQvO1xuY29uc3QgdG9TdHJpbmdUYWcgPSAnW29iamVjdCBCbG9ja10nO1xuY29uc3QgYWZ0ZXJFbGVtID0gbmV3IEVsZW0oKTtcbmNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG5sZXQgZXZhbE1vZGUgPSBmYWxzZTtcbmxldCBnZXR0aW5nVmFycyA9IFtdO1xuXG4vKipcbiAqIEBjbGFzcyBCbG9ja1xuICogQGV4dGVuZHMgbnVsbFxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBCbG9jayBvcHRpb25zLlxuICogQHJldHVybnMge0Jsb2NrfSBJbnN0YW5jZSBvZiBCbG9jay5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQmxvY2ssIGluaXRBcHAgfSBmcm9tICdkd2F5bmUnO1xuICpcbiAqIGNsYXNzIEFwcCBleHRlbmRzIEJsb2NrIHtcbiAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxIZWxsbyB0ZXh0PVwie3RleHR9XCIvPiAoeyB0aGlzLnRpbWVzIH0pJztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAqICAgICBzdXBlcihvcHRzKTtcbiAqXG4gKiAgICAgdGhpcy50ZXh0ID0gJ3dvcmxkJztcbiAqICAgICB0aGlzLnRpbWVzID0gMDtcbiAqXG4gKiAgICAgdGhpcy5zZXRJbnRlcnZhbCgpO1xuICogICB9XG4gKlxuICogICBzZXRJbnRlcnZhbCgpIHtcbiAqICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICogICAgICAgdGhpcy50aW1lcysrO1xuICogICAgIH0pO1xuICogICB9XG4gKlxuICogICBiZWZvcmVSZW1vdmUoKSB7XG4gKiAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAqICAgfVxuICogfVxuICpcbiAqIEJsb2NrLmJsb2NrKCdBcHAnLCBBcHApO1xuICogQmxvY2suYmxvY2soJ0hlbGxvJywgaHRtbGBIZWxsbywge2FyZ3MudGV4dH0hYCk7XG4gKlxuICogaW5pdEFwcCgnQXBwJywgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKSk7XG4gKi9cbmNsYXNzIEJsb2NrIHtcbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdC48U3RyaW5nLCB0eXBlb2YgQmxvY2s+fSBCbG9jay5fYmxvY2tzXG4gICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgdHlwZW9mIEJsb2NrPn1cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgbmFtZXNwYWNlIGJsb2Nrcy5cbiAgICovXG4gIHN0YXRpYyBfYmxvY2tzID0gY3JlYXRlKHJvb3RCbG9ja3MpO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPFN0cmluZywgdHlwZW9mIE1peGluPn0gQmxvY2suX21peGluc1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIHR5cGVvZiBNaXhpbj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIG5hbWVzcGFjZSBtaXhpbnMuXG4gICAqL1xuICBzdGF0aWMgX21peGlucyA9IGNyZWF0ZShyb290TWl4aW5zKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBbQmxvY2suZGVmYXVsdEFyZ3MgPSBudWxsXVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBCbG9jayBkZWZhdWx0IGFyZ3MuXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdEFyZ3MgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IFtCbG9jay5kZWZhdWx0TG9jYWxzID0gbnVsbF1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHB1YmxpY1xuICAgKiBAZGVzY3JpcHRpb24gQmxvY2sgZGVmYXVsdCBsb2NhbHMuXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdExvY2FscyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gW0Jsb2NrLnRlbXBsYXRlID0geyB2YXJzOiBbXSwgdmFsdWU6IFtdIH1dXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIEJsb2NrIHRlbXBsYXRlLlxuICAgKi9cbiAgc3RhdGljIHRlbXBsYXRlID0ge1xuICAgIHZhcnM6IFtdLFxuICAgIHZhbHVlOiBbXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLm9uRXZhbEVycm9yXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtFdmFsdWF0aW9uRXJyb3J9IGVyciAtIFRoZSBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYW4gZXZhbHVhdGlvbiBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBzdGF0aWMgb25FdmFsRXJyb3IoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXZhbCBlcnJvciAoZXZhbHVhdGluZyBcIiR7IGVyci5vcmlnaW5hbCB8fCBlcnIuZnVuYyB9XCIgaW4gY29udGV4dCBvZiAkeyBlcnIuYmxvY2suJCQubmFtZSB9KTpgLCBlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2suYmVmb3JlUmVnaXN0ZXJCbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7QmxvY2tSZWdpc3Rlckhvb2t9IGhvb2sgLSBCbG9jayByZWdpc3RlciBob29rLlxuICAgKiBAcmV0dXJucyB7UmVtb3ZlSG9va31cbiAgICovXG4gIHN0YXRpYyBiZWZvcmVSZWdpc3RlckJsb2NrKGhvb2spIHtcbiAgICBibG9ja0hvb2tzLnB1c2goaG9vayk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlQXJyYXlFbGVtKGJsb2NrSG9va3MsIGhvb2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5iZWZvcmVSZWdpc3Rlck1peGluXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtNaXhpblJlZ2lzdGVySG9va30gaG9vayAtIE1peGluIHJlZ2lzdGVyIGhvb2suXG4gICAqIEByZXR1cm5zIHtSZW1vdmVIb29rfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZVJlZ2lzdGVyTWl4aW4oaG9vaykge1xuICAgIG1peGluSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW1vdmVBcnJheUVsZW0obWl4aW5Ib29rcywgaG9vayk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrLmJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBCbG9jayBvciBtaXhpbiBuYW1lLlxuICAgKiBAcGFyYW0ge1RlbXBsYXRlfFNjb3BlbGVzc1RlbXBsYXRlfHR5cGVvZiBCbG9ja30gU3ViY2xhc3MgLSBTdWJjbGFzcyBvZiBCbG9jayBvciB0ZW1wbGF0ZSBzdHJpbmcgb2YgaXQuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t8dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgQmxvY2sgb3IgdW5kZWZpbmVkIGlmIHRoZSBibG9jayBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgYmxvY2sgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGlzLlxuICAgKi9cbiAgc3RhdGljIGJsb2NrKG5hbWUsIFN1YmNsYXNzKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oU3ViY2xhc3MpICYmICFpc0luc3RhbmNlT2YoQmxvY2ssIFN1YmNsYXNzKSkge1xuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBTdWJjbGFzcztcblxuICAgICAgU3ViY2xhc3MgPSBjbGFzcyBleHRlbmRzIEJsb2NrIHtcbiAgICAgICAgc3RhdGljIHRlbXBsYXRlID0gY29uc3RydWN0b3IudGVtcGxhdGU7XG5cbiAgICAgICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICAgIHRoaXM6OmNvbnN0cnVjdG9yKG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbihTdWJjbGFzcykgJiYgaXNBcnJheShTdWJjbGFzcykpIHtcbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBCbG9jayB7XG4gICAgICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHtcbiAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICB2YWx1ZTogU3ViY2xhc3NcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiBTdWJjbGFzcy52YXJzICYmIFN1YmNsYXNzLnZhbHVlKSB7XG4gICAgICBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgICAgICBzdGF0aWMgdGVtcGxhdGUgPSBTdWJjbGFzcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0luc3RhbmNlT2YoQmxvY2ssIFN1YmNsYXNzKSkge1xuICAgICAgY29uc29sZS53YXJuKGBCbG9jayBtdXN0IGJlIGEgdGVtcGxhdGUgKGFycmF5IG9yIGFuIG9iamVjdCBmcm9tIGFuIGh0bWwgbG9hZGVyKSwgYSBmdW5jdGlvbiBvciBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBCbG9jayBjbGFzcyAobmFtZTogXCIkeyBuYW1lIH1cIikgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJvb3RCbG9ja3NbbmFtZV0pIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIFwiJHsgbmFtZSB9XCIgYmxvY2sgaXMgYSBidWlsdC1pbiBibG9jayBzbyB0aGUgYmxvY2sgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2suYmxvY2spYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIVRBR19OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTmFtZSBcIiR7IG5hbWUgfVwiIGlzIG5vdCBhbGxvd2VkIGZvciBibG9ja3Mgc28gdGhlIGJsb2NrIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLmJsb2NrKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnX2Jsb2NrcycpKSB7XG4gICAgICB0aGlzLl9ibG9ja3MgPSBjcmVhdGUoZ2V0UHJvdG8odGhpcykuX2Jsb2Nrcyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdExvY2FscycpKSB7XG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdkZWZhdWx0QXJncycpKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBcmdzID0gY3JlYXRlKG51bGwpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBTdWJjbGFzcyA9IGJsb2NrSG9va3MucmVkdWNlKChyZXR1cm5WYWx1ZSwgaG9vaykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50UmV0dXJuVmFsdWUgPSBob29rKHJldHVyblZhbHVlLCBuYW1lLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gaXNJbnN0YW5jZU9mKEJsb2NrLCBjdXJyZW50UmV0dXJuVmFsdWUpXG4gICAgICAgICAgPyBjdXJyZW50UmV0dXJuVmFsdWVcbiAgICAgICAgICA6IHJldHVyblZhbHVlO1xuICAgICAgfSwgU3ViY2xhc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgZXJyb3IgaW4gXCJiZWZvcmVSZWdpc3RlckJsb2NrXCIgaG9vazonLCBlcnIpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KFN1YmNsYXNzLnRlbXBsYXRlKSkge1xuICAgICAgU3ViY2xhc3MudGVtcGxhdGUgPSB7XG4gICAgICAgIHZhcnM6IFtdLFxuICAgICAgICB2YWx1ZTogU3ViY2xhc3MudGVtcGxhdGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgdmFycyxcbiAgICAgIHZhbHVlXG4gICAgfSA9IFN1YmNsYXNzLnRlbXBsYXRlO1xuXG4gICAgU3ViY2xhc3MuX2Jsb2NrcyA9IGhhc093blByb3BlcnR5KFN1YmNsYXNzLCAnX2Jsb2NrcycpXG4gICAgICA/IFN1YmNsYXNzLl9ibG9ja3NcbiAgICAgIDogY3JlYXRlKHRoaXMuX2Jsb2Nrcyk7XG4gICAgU3ViY2xhc3MuX21peGlucyA9IGhhc093blByb3BlcnR5KFN1YmNsYXNzLCAnX21peGlucycpXG4gICAgICA/IFN1YmNsYXNzLl9taXhpbnNcbiAgICAgIDogY3JlYXRlKHRoaXMuX21peGlucyk7XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkoU3ViY2xhc3MsICdkZWZhdWx0QXJncycpKSB7XG4gICAgICBzZXRQcm90byhTdWJjbGFzcy5kZWZhdWx0QXJncywgbnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmxvY2tzW25hbWVdID0gU3ViY2xhc3M7XG5cbiAgICByZXR1cm4gU3ViY2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5nZXRcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG5hbWUuXG4gICAqIEByZXR1cm5zIHt0eXBlb2YgQmxvY2t8dW5kZWZpbmVkfSBSZXR1cm5zIHJlZ2lzdGVyZWQgQmxvY2sgd2l0aCBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay5nZXRNaXhpblxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTWl4aW4gbmFtZS5cbiAgICogQHJldHVybnMge3R5cGVvZiBNaXhpbnx1bmRlZmluZWR9IFJldHVybnMgcmVnaXN0ZXJlZCBNaXhpbiB3aXRoIHNwZWNpZmllZCBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldE1peGluKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4aW5zW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2subWl4aW5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIEJsb2NrIG9yIG1peGluIG5hbWUuXG4gICAqIEBwYXJhbSB7dHlwZW9mIE1peGlufEFmdGVyVXBkYXRlfSBTdWJjbGFzcyAtIFN1YmNsYXNzIG9mIE1peGluIG9yIEFmdGVyVXBkYXRlIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIE1peGlufHVuZGVmaW5lZH0gUmV0dXJucyByZWdpc3RlcmVkIEJsb2NrIG9yIHVuZGVmaW5lZCBpZiB0aGUgYmxvY2sgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogQGRlc2NyaXB0aW9uIFJlZ2lzdGVyIG1peGluIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhpcy5cbiAgICovXG4gIHN0YXRpYyBtaXhpbihuYW1lLCBTdWJjbGFzcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKFN1YmNsYXNzKSAmJiAhaXNJbnN0YW5jZU9mKE1peGluLCBTdWJjbGFzcykpIHtcbiAgICAgIGNvbnN0IGFmdGVyVXBkYXRlID0gU3ViY2xhc3M7XG5cbiAgICAgIFN1YmNsYXNzID0gY2xhc3MgZXh0ZW5kcyBNaXhpbiB7XG4gICAgICAgIGFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgIHRoaXM6OmFmdGVyVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0luc3RhbmNlT2YoTWl4aW4sIFN1YmNsYXNzKSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgXCIkeyBuYW1lIH1cIiBjbGFzcyBkb2VzIG5vdCBleHRlbmQgTWl4aW4gb3IgaXMgbm90IGFuIGFmdGVyVXBkYXRlIGZ1bmN0aW9uLCBzbyBpdCB3aWxsIG5vdCBiZSByZWdpc3RlcmVkIChCbG9jay5taXhpbilgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyb290TWl4aW5zW25hbWVdIHx8IG5hbWUgPT09ICdkLXJlc3QnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBcIiR7IG5hbWUgfVwiIG1peGluIGlzIGEgYnVpbHQtaW4gbWl4aW4gc28gdGhlIG1peGluIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWQgKEJsb2NrLm1peGluKWApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFBVFRSX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBOYW1lIFwiJHsgbmFtZSB9XCIgaXMgbm90IGFsbG93ZWQgZm9yIG1peGlucyBzbyB0aGUgbWl4aW4gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZCAoQmxvY2subWl4aW4pYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHRoaXMsICdfbWl4aW5zJykpIHtcbiAgICAgIHRoaXMuX21peGlucyA9IGNyZWF0ZShnZXRQcm90byh0aGlzKS5fbWl4aW5zKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgU3ViY2xhc3MgPSBtaXhpbkhvb2tzLnJlZHVjZSgocmV0dXJuVmFsdWUsIGhvb2spID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJldHVyblZhbHVlID0gaG9vayhyZXR1cm5WYWx1ZSwgbmFtZSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZihNaXhpbiwgY3VycmVudFJldHVyblZhbHVlKVxuICAgICAgICAgID8gY3VycmVudFJldHVyblZhbHVlXG4gICAgICAgICAgOiByZXR1cm5WYWx1ZTtcbiAgICAgIH0sIFN1YmNsYXNzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuY2F1Z2h0IGVycm9yIGluIFwiYmVmb3JlUmVnaXN0ZXJNaXhpblwiIGhvb2s6JywgZXJyKTtcbiAgICB9XG5cbiAgICBTdWJjbGFzcy5fbWF0Y2ggPSBjb25zdHJ1Y3RNaXhpblJlZ2V4KG5hbWUpO1xuXG4gICAgdGhpcy5fbWl4aW5zW25hbWVdID0gU3ViY2xhc3M7XG5cbiAgICByZXR1cm4gU3ViY2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jay53cmFwXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsuLi5XcmFwcGVyfSB3cmFwcGVycyAtIEZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIGJsb2NrLlxuICAgKiBAcmV0dXJucyB7dHlwZW9mIEJsb2NrfSBOZXcgYmxvY2suXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIHdyYXBwaW5nIGJsb2NrcyBpbnRvIGFub3RoZXIgYmxvY2tzLlxuICAgKiBJdCBpcyBjb25zaWRlcmVkIGJlc3QgcHJhY3RpY2UgdG8ganVzdCBleHRlbmRzIHRoZSBvbGQgYmxvY2sgd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNsYXNzIE15QmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gICAqICAgc3RhdGljIHRlbXBsYXRlID0gJzxkaXY+MTIzPC9kaXY+JztcbiAgICogfVxuICAgKlxuICAgKiBNeUJsb2NrLndyYXAoKEJsb2NrKSA9PiB7XG4gICAqICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgQmxvY2sge1xuICAgKiAgICAgc3RhdGljIHRlbXBsYXRlID0gYDxzZWN0aW9uIGNsYXNzPVwid3JhcHBlclwiPiR7IEJsb2NrLnRlbXBsYXRlIH08L3NlY3Rpb24+YDtcbiAgICpcbiAgICogICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICogICAgICAgc3VwZXIob3B0cyk7XG4gICAqXG4gICAqICAgICAgIHRoaXMuYWRkaXRpb25hbFZhciA9ICdhZGRpdGlvbmFsJztcbiAgICogICAgIH1cbiAgICogICB9O1xuICAgKiB9KTtcbiAgICovXG4gIHN0YXRpYyB3cmFwKC4uLndyYXBwZXJzKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJzLnJlZHVjZSh3cmFwQmxvY2ssIHRoaXMpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzOiBvcmlnaW5hbEFyZ3MsXG4gICAgICBkQmxvY2tOYW1lLFxuICAgICAgZEJsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50RWxlbSxcbiAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIHByZXZCbG9ja1xuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHdhdGNoZXJzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldFByb3RvKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNoaWxkcmVuQmxvY2tzID0gW107XG4gICAgY29uc3QgbWl4aW5zID0gW107XG4gICAgY29uc3QgaXNQYXJlbnRCbG9jayA9IHBhcmVudCBpbnN0YW5jZW9mIEJsb2NrO1xuXG4gICAgZGVmaW5lRnJvemVuUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH0gQmxvY2sjJCRcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQuYXJncyAtIFByaXZhdGUgYXJncyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2tbXX0gQmxvY2sjJCQuY2hpbGRyZW4gLSBDaGlsZCBibG9ja3MuXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IEJsb2NrIyQkLmNvbnRlbnQgLSBDb250ZW50IGVsZW1lbnRzLlxuICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd8dm9pZH0gQmxvY2sjJCQuZEJsb2NrTmFtZSAtIGQtYmxvY2sgbmFtZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fHZvaWR9IEJsb2NrIyQkLmRCbG9ja05hbWUgLSBkLWJsb2NrIGFyZ3MuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrW119IEJsb2NrIyQkLmRCbG9ja3MgLSBkLWJsb2NrJ3Mgd2l0aGluIHRoZSBibG9jay5cbiAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IEJsb2NrIyQkLmV2YWx1YXRlIC0gRXZhbHVhdGUgZnVuY3Rpb24uXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gQmxvY2sjJCQuZ2xvYmFscyAtIFByaXZhdGUgZ2xvYmFscyBzY29wZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IEJsb2NrIyQkLmh0bWxDaGlsZHJlbiAtIEJsb2NrIGh0bWwgY2hpbGRyZW4uXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IEJsb2NrIyQkLmlzUmVtb3ZlZCAtIElmIHRoZSBibG9jayBpcyByZW1vdmVkLlxuICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBCbG9jayMkJC5pc1JlbmRlcmVkIC0gSWYgdGhlIGJsb2NrIGlzIHJlbmRlcmVkLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IEJsb2NrIyQkLmxvY2FscyAtIFByaXZhdGUgbG9jYWxzIHNjb3BlLlxuICAgICAgICogQHByb3BlcnR5IHtNaXhpbltdfSBCbG9jayMkJC5taXhpbnMgLSBDaGlsZCBtaXhpbnMuXG4gICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gQmxvY2sjJCQubmFtZSAtIEJsb2NrIG5hbWUuXG4gICAgICAgKiBAcHJvcGVydHkge3R5cGVvZiBCbG9ja30gQmxvY2sjJCQubnMgLSBCbG9jayBjb25zdHJ1Y3Rvci5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8RWxlbXx2b2lkfSBCbG9jayMkJC5wYXJlbnQgLSBQYXJlbnQgYmxvY2sgb3IgZWxlbS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gQmxvY2sjJCQucGFyZW50QmxvY2sgLSBQYXJlbnQgYmxvY2suXG4gICAgICAgKiBAcHJvcGVydHkge0VsZW19IHBhcmVudEVsZW0gLSBQYXJlbnQgZWxlbWVudC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7QmxvY2t8dm9pZH0gQmxvY2sjJCQucGFyZW50U2NvcGUgLSBQYXJlbnQgc2NvcGUuXG4gICAgICAgKiBAcHJvcGVydHkge0Jsb2NrfHZvaWR9IEJsb2NrIyQkLnBhcmVudFRlbXBsYXRlIC0gUGFyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHByb3BlcnR5IHtCbG9ja3xFbGVtfHZvaWR9IEJsb2NrIyQkLnByZXZCbG9jayAtIFBhcmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7V2F0Y2hlcltdfSBCbG9jayMkJC53YXRjaGVycyAtIFRlbXBvcmFyeSB2YXJzIHdhdGNoZXJzLlxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gQmxvY2sjJCQud2F0Y2hlcnNUb1JlbW92ZSAtIFdhdGNoZXJzIHRvIHJlbW92ZSBiZWZvcmUgcmVtb3ZpbmcgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgJCQ6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZEJsb2NrTmFtZSxcbiAgICAgICAgZEJsb2NrQXJncyxcbiAgICAgICAgZEJsb2NrczogW10sXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgIHBhcmVudEJsb2NrLFxuICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgY29udGVudDogbmV3IEVsZW0oKSxcbiAgICAgICAgbnM6IGNvbnN0cnVjdG9yLFxuICAgICAgICBodG1sQ2hpbGRyZW46IGNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5CbG9ja3MsXG4gICAgICAgIG1peGlucyxcbiAgICAgICAgcHJldkJsb2NrLFxuICAgICAgICB3YXRjaGVyc1RvUmVtb3ZlLFxuICAgICAgICBpc1JlbW92ZWQ6IGZhbHNlLFxuICAgICAgICBpc1JlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgZXZhbHVhdGU6IChmdW5jLCBvbkNoYW5nZSwgdGFyZ2V0QmxvY2ssIGZvckRFbGVtZW50cywgZm9yREl0ZW0sIGZvckRFYWNoKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JERWxlbWVudHMgPSAhIWZvckRFbGVtZW50cztcbiAgICAgICAgICBmb3JESXRlbSA9ICEhZm9yREl0ZW07XG5cbiAgICAgICAgICBjb25zdCBzY29wZSA9IChuYW1lID09PSAnI2QtaXRlbScgJiYgIWZvckRJdGVtKSB8fCBmb3JERWFjaFxuICAgICAgICAgICAgPyAoZm9yREVhY2ggfHwgdGhpcykuJCQuc2NvcGVcbiAgICAgICAgICAgIDogdGhpcztcbiAgICAgICAgICBjb25zdCB7IHdhdGNoZXJzVG9SZW1vdmUgfSA9IHRhcmdldEJsb2NrID8gdGFyZ2V0QmxvY2suJCQgOiBlbXB0eU9iamVjdDtcbiAgICAgICAgICBjb25zdCBvbkNoYW5nZUZsYWcgPSAhIW9uQ2hhbmdlO1xuXG4gICAgICAgICAgY29uc3QgZXZhbHVhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAob25DaGFuZ2VGbGFnKSB7XG4gICAgICAgICAgICAgIGV2YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZ2V0dGluZ1ZhcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhzY29wZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyLmZ1bmMgPSBmdW5jO1xuICAgICAgICAgICAgICBlcnIub3JpZ2luYWwgPSBmdW5jLm9yaWdpbmFsO1xuICAgICAgICAgICAgICBlcnIuYmxvY2sgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnN0cnVjdG9yLm9uRXZhbEVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5vbkV2YWxFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuY2F1Z2h0IGVycm9yIGluICR7IG5hbWUgfS5vbkV2YWxFcnJvcjpgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlRmxhZykge1xuICAgICAgICAgICAgICBjb25zdCBsb2NhbFdhdGNoZXJzID0gW107XG5cbiAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KGdldHRpbmdWYXJzLCAod2F0Y2hlcnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUFycmF5KGxvY2FsV2F0Y2hlcnMsICh3YXRjaGVyQmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgfSA9IHdhdGNoZXJCbG9jaztcblxuICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnNUb1JlbW92ZSwgd2F0Y2hlckJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXJyYXlFbGVtKHdhdGNoZXJzLCB3YXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZXN1bHQgPSBldmFsdWF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3UmVzdWx0ICE9PSByZXN1bHQgJiYgIXRhcmdldEJsb2NrLiQkLmlzUmVtb3ZlZCAmJiAhdGhpcy4kJC5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3UmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hlckJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgZm9yREVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICAgICAgICAgIHdhdGNoZXJzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxvY2FsV2F0Y2hlcnMucHVzaCh3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJzVG9SZW1vdmUucHVzaCh3YXRjaGVyQmxvY2spO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGV2YWxNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGdldHRpbmdWYXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChpc1BhcmVudFNpZ25hbCkgPT4ge1xuICAgICAgICAgIHRoaXMuJCQuaXNSZW1vdmVkID0gdHJ1ZTtcblxuICAgICAgICAgIHJlbW92ZVdhdGNoZXJzKHdhdGNoZXJzVG9SZW1vdmUpO1xuXG4gICAgICAgICAgaXRlcmF0ZUFycmF5KGNoaWxkcmVuQmxvY2tzLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gJHsgbmFtZSB9I2JlZm9yZVJlbW92ZTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNQYXJlbnRTaWduYWwgJiYgaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgcGFyZW50LiQkLnJlbW92ZUNvbnRlbnQodGhpcy4kJC5jb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzUGFyZW50U2lnbmFsICYmIHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheUVsZW0ocGFyZW50QmxvY2suJCQuY2hpbGRyZW4sIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY29udGVudC5yZW1vdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlQ29udGVudDogKG5ld0NvbnRlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNvbnRlbnQgPSBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKHRoaXMuJCQuaXNSZW5kZXJlZCAmJiAhdGhpcy4kJC5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMuYWZ0ZXJET01DaGFuZ2UoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmNhdWdodCBlcnJvciBpbiAkeyBuYW1lIH0jYWZ0ZXJET01DaGFuZ2U6YCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZENvbnRlbnQ6IChjb250ZW50VG9BZGQsIG5vdFJlY3Vyc2l2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLiQkLmNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvbGRDb250ZW50LmluZGV4T2YoY29udGVudFRvQWRkWzBdLnByZXZpb3VzU2libGluZykgKyAxO1xuICAgICAgICAgIGxldCBuZXdDb250ZW50O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudFRvQWRkLmFkZChvbGRDb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKGNvbnRlbnRUb0FkZCwgb2xkQ29udGVudC5zbGljZShpbmRleCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJCQuY2hhbmdlQ29udGVudChuZXdDb250ZW50KTtcblxuICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrICYmICFub3RSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0FkZCwgbm90UmVjdXJzaXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVDb250ZW50OiAoY29udGVudFRvTW92ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGRDb250ZW50ID0gdGhpcy4kJC5jb250ZW50O1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gb2xkQ29udGVudC5pbmRleE9mKGNvbnRlbnRUb01vdmVbMF0pO1xuICAgICAgICAgIGNvbnN0IGluZGV4VG9QdXQgPSBvbGRDb250ZW50LmluZGV4T2YoYWZ0ZXJbMF0pICsgMTtcbiAgICAgICAgICBsZXQgbmV3Q29udGVudDtcblxuICAgICAgICAgIGlmIChpbmRleFRvUHV0ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudFRvTW92ZS5hZGQoXG4gICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4ICsgY29udGVudFRvTW92ZS5sZW5ndGgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiBpbmRleFRvUHV0KSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gb2xkQ29udGVudFxuICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXhUb1B1dClcbiAgICAgICAgICAgICAgLmFkZChcbiAgICAgICAgICAgICAgICBjb250ZW50VG9Nb3ZlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXhUb1B1dCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IG9sZENvbnRlbnRcbiAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAuYWRkKFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnQuc2xpY2UoaW5kZXggKyBjb250ZW50VG9Nb3ZlLmxlbmd0aCwgaW5kZXhUb1B1dCksXG4gICAgICAgICAgICAgICAgY29udGVudFRvTW92ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50LnNsaWNlKGluZGV4VG9QdXQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kJC5jaGFuZ2VDb250ZW50KG5ld0NvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2sgJiYgaW5kZXhUb1B1dCkge1xuICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb01vdmUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNvbnRlbnQ6IChjb250ZW50VG9SZW1vdmUpID0+IHtcbiAgICAgICAgICB0aGlzLiQkLmNoYW5nZUNvbnRlbnQodGhpcy4kJC5jb250ZW50LmZpbHRlcigoZWxlbSkgPT4gKFxuICAgICAgICAgICAgY29udGVudFRvUmVtb3ZlLmluZGV4T2YoZWxlbSkgPT09IC0xXG4gICAgICAgICAgKSkpO1xuXG4gICAgICAgICAgaWYgKGlzUGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHBhcmVudC4kJC5yZW1vdmVDb250ZW50KGNvbnRlbnRUb1JlbW92ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRJblN0YXJ0T2ZJdDogKGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBhZnRlckVsZW07XG5cbiAgICAgICAgICBpZiAocHJldkJsb2NrIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrLiQkLmluc2VydEFmdGVySXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKHByZXZCbG9jayk7XG5cbiAgICAgICAgICAgIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChtb3ZlRmxhZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BhcmVudEJsb2NrKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gcGFyZW50LiQkO1xuXG4gICAgICAgICAgICBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICAgIGxldCBub3RSZWN1cnNpdmU7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBwcmV2QmxvY2suJCQuaW5zZXJ0QWZ0ZXJJdChjb250ZW50VG9JbnNlcnQsIG1vdmVGbGFnKTtcbiAgICAgICAgICAgICAgICBub3RSZWN1cnNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gcHJldkJsb2NrO1xuICAgICAgICAgICAgICAgIG5vdFJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LiQkLm1vdmVDb250ZW50KGNvbnRlbnRUb0luc2VydCwgYWZ0ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCwgbm90UmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW92ZUZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuJCQubW92ZUNvbnRlbnQoY29udGVudFRvSW5zZXJ0LCBhZnRlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCQuYWRkQ29udGVudChjb250ZW50VG9JbnNlcnQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZnRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXJJdDogKGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByZXZCbG9jayB9ID0gdGhpcy4kJDtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBhZnRlckVsZW07XG4gICAgICAgICAgbGV0IHRyeVRvQWRkT3JNb3ZlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuJCQuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy4kJC5jb250ZW50LmVsZW0oLTEpO1xuICAgICAgICAgICAgdHJ5VG9BZGRPck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGVudFRvSW5zZXJ0Lmluc2VydEFmdGVyKGFmdGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZCbG9jayBpbnN0YW5jZW9mIEJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnRUb0luc2VydCwgbW92ZUZsYWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgICBhZnRlciA9IHByZXZCbG9jaztcbiAgICAgICAgICAgIHRyeVRvQWRkT3JNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnNlcnRBZnRlcihwcmV2QmxvY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQYXJlbnRCbG9jaykge1xuICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQuJCQuaW5zZXJ0SW5TdGFydE9mSXQoY29udGVudFRvSW5zZXJ0LCBtb3ZlRmxhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb0luc2VydC5pbnRvKHBhcmVudEVsZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNQYXJlbnRCbG9jayAmJiB0cnlUb0FkZE9yTW92ZSkge1xuICAgICAgICAgICAgaWYgKG1vdmVGbGFnKSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5tb3ZlQ29udGVudChjb250ZW50VG9JbnNlcnQsIGFmdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC4kJC5hZGRDb250ZW50KGNvbnRlbnRUb0luc2VydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdGVyYXRlT2JqZWN0KGNvbnN0cnVjdG9yLmRlZmF1bHRMb2NhbHMsICh2YWx1ZSwgdmFyaWFibGUpID0+IHtcbiAgICAgIHRoaXNbdmFyaWFibGVdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgaXRlcmF0ZUFycmF5KGNvbnN0cnVjdG9yLnRlbXBsYXRlLnZhcnMsICh2YXJpYWJsZSkgPT4ge1xuICAgICAgdGhpc1t2YXJpYWJsZV0gPSB0aGlzW3ZhcmlhYmxlXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgbGV0IGFyZ3MgPSBjcmVhdGUoY29uc3RydWN0b3IuZGVmYXVsdEFyZ3MgfHwgbnVsbCk7XG4gICAgbGV0IHdhc0RSZXN0O1xuXG4gICAgaXRlcmF0ZU9iamVjdChvcmlnaW5hbEFyZ3MsICh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgICBjb25zdCBpc0RSZXN0ID0gRF9SRVNUX1JFR0VYLnRlc3QoYXJnKTtcbiAgICAgIGNvbnN0IGxvY2FsQXJncyA9IGlzRFJlc3QgfHwgd2FzRFJlc3RcbiAgICAgICAgPyBjcmVhdGUoYXJncylcbiAgICAgICAgOiBhcmdzO1xuXG4gICAgICBhcmdzID0gbG9jYWxBcmdzO1xuXG4gICAgICBpZiAoaXNEUmVzdCkge1xuICAgICAgICBjb25zdCByZXN0QXJncyA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBpdGVyYXRlT2JqZWN0KGxvY2FsQXJncywgY2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgYXNzaWduKGxvY2FsQXJncywgdHJhbnNmb3JtUmVzdEFyZ3ModmFsdWUpKTtcbiAgICAgICAgICBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB3YXNEUmVzdCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbihsb2NhbEFyZ3MsIHRyYW5zZm9ybVJlc3RBcmdzKHJlc3RBcmdzKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzREVsZW1lbnRzID0gbmFtZSA9PT0gJ2QtZWxlbWVudHMnO1xuICAgICAgY29uc3QgZm9yREVsZW1lbnRzID0gaXNERWxlbWVudHMgJiYgYXJnID09PSAndmFsdWUnO1xuXG4gICAgICB3YXNEUmVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtZWFjaCcgfHwgYXJnICE9PSAndWlkJykge1xuICAgICAgICB2YWx1ZSA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKHZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICBsb2NhbEFyZ3NbYXJnXSA9IHZhbHVlO1xuICAgICAgICAgIGNhbGN1bGF0ZUFyZ3MoYXJncywgYXJnc09iamVjdCk7XG4gICAgICAgIH0sIHRoaXMsIGZvckRFbGVtZW50cywgaXNERWxlbWVudHMgJiYgcGFyZW50QmxvY2suJCQubmFtZSA9PT0gJyNkLWl0ZW0nKTtcbiAgICAgIH1cblxuICAgICAgbG9jYWxBcmdzW2FyZ10gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIGRlZmluZUZyb3plblByb3BlcnRpZXModGhpcywge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJsb2NrI2FyZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGFyZ3M6IGFyZ3NPYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBCbG9jayNnbG9iYWxzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBnbG9iYWxzOiBjcmVhdGUoXG4gICAgICAgIHBhcmVudFNjb3BlXG4gICAgICAgICAgPyBwYXJlbnRTY29wZS5nbG9iYWxzXG4gICAgICAgICAgOiBudWxsXG4gICAgICApXG4gICAgfSk7XG5cbiAgICBjYWxjdWxhdGVBcmdzKGFyZ3MsIGFyZ3NPYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudEJsb2NrKSB7XG4gICAgICBwYXJlbnRCbG9jay4kJC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2FmdGVyQ29uc3RydWN0XG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBhZnRlciBibG9jayBjb25zdHJ1Y3Rpb24gKGluY2x1ZGluZyBhbGwgc2NvcGVzKVxuICAgKiBidXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgYmxvY2sgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIGFmdGVyQ29uc3RydWN0KCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlckRPTUNoYW5nZVxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgRE9NIHN0cnVjdHVyZSBoYXMgY2hhbmdlZC4gTm90ZSB0aGF0XG4gICAqIGl0J3MgaW1wb3J0YW50IG5vdCB0byBtb2RpZnkgdGhlIERPTSBzdHJ1Y3R1cmUgd2l0aGluIHRoZSBibG9jay4gWW91IGNhbiBvbmx5IGluc2VydFxuICAgKiBlbGVtZW50cyB0byBlbXB0eSBlbGVtZW50cyAod2hpY2ggRHdheW5lIGNvbnNpZGVycyBlbXB0eSkgYW5kIHJlbW92ZSBvbmVzIGZyb20gdGhlbS5cbiAgICovXG4gIGFmdGVyRE9NQ2hhbmdlKCkge31cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNhZnRlclJlbmRlclxuICAgKiBAcHVibGljXG4gICAqIEBkZXNjcmlwdGlvbiBJcyBjYWxsZWQgYWZ0ZXIgYmxvY2sgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAqL1xuICBhZnRlclJlbmRlcigpIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjYmVmb3JlUmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICogQGRlc2NyaXB0aW9uIElzIGNhbGxlZCBiZWZvcmUgdGhlIGJsb2NrIHJlbW92YWwuXG4gICAqL1xuICBiZWZvcmVSZW1vdmUoKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldERPTVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBET00gY29udGVudHMgb2YgdGhlIGJsb2NrLlxuICAgKi9cbiAgZ2V0RE9NKCkge1xuICAgIHJldHVybiB0aGlzLiQkLmNvbnRlbnQuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEJsb2NrI2dldE5hbWVcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBCbG9jayBuYW1lLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZ2V0UGFyZW50RWxlbVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtFbGVtfHZvaWR9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHBhcmVudCBFbGVtLlxuICAgKi9cbiAgZ2V0UGFyZW50RWxlbSgpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5wYXJlbnRFbGVtLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBCbG9jayNnZXRUb3BCbG9ja1xuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtCbG9ja3x2b2lkfVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBibG9jayBpbiB3aGljaCB0ZW1wbGF0ZSB0aGUgYmxvY2sgaXMgbG9jYXRlZCBpbi5cbiAgICovXG4gIGdldFRvcEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLiQkLnBhcmVudFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgQmxvY2sjZXZhbHVhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSB7V2F0Y2hlcn0gW2NhbGxiYWNrXSAtIElmIHByZXNlbnQsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7QmxvY2t8TWl4aW59IFt0YXJnZXQgPSB0aGlzXSAtIFdoYXQgYmxvY2sgb3IgbWl4aW4gcmVxdWVzdHMgdGhlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGlvbiByZXN1bHQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiBpbiBjb250ZXh0IG9mIHRoZSBibG9jayBhbmQgd2F0Y2hpbmcgZm9yIHRoZSBjaGFuZ2VzLlxuICAgKi9cbiAgZXZhbHVhdGUoZnVuYywgY2FsbGJhY2ssIHRhcmdldCA9IHRoaXMpIHtcbiAgICByZXR1cm4gdGhpcy4kJC5ldmFsdWF0ZShmdW5jLCBjYWxsYmFjaywgdGFyZ2V0KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZztcbiAgfVxufVxuXG5zZXRUb1N0cmluZ1RhZyhCbG9jaywgJ0Jsb2NrJyk7XG5zZXRQcm90byhCbG9jay5wcm90b3R5cGUsIG51bGwpO1xuXG5leHBvcnQgeyBCbG9jaywgZ2V0dGluZ1ZhcnMsIGV2YWxNb2RlIH07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IHdhdGNoTmFtZUFyZ3MgPSBqc2BhcmdzLm5hbWVgO1xuY29uc3Qgd2F0Y2hDb25zdHJ1Y3RvckFyZ3MgPSBqc2BhcmdzLkNvbnN0cnVjdG9yYDtcblxuY2xhc3MgREJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7UGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwie1BhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcblxuICBhZnRlckNvbnN0cnVjdChvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGU6IHtcbiAgICAgICAgJCQ6IHtcbiAgICAgICAgICBwYXJlbnRTY29wZTogcGFyZW50UGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGU6IHBhcmVudFBhcmVudFRlbXBsYXRlLFxuICAgICAgICAgIGh0bWxDaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGh0bWxDaGlsZHJlbjogb3duQ2hpbGRyZW4sXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgZEJsb2NrTmFtZTogREJsb2NrTmFtZVxuICAgIH0gPSB0aGlzLiQkO1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBDb25zdHJ1Y3RvclxuICAgIH0gPSB0aGlzLmFyZ3M7XG4gICAgbGV0IGZvdW5kO1xuXG4gICAgdGhpcy5QYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgIHRoaXMuUGFyZW50VGVtcGxhdGUgPSBwYXJlbnRUZW1wbGF0ZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdER5bmFtaWNOYW1lQmxvY2soXG4gICAgICAgIHRoaXMuZXZhbHVhdGUod2F0Y2hOYW1lQXJncywgdGhpcy5jb25zdHJ1Y3REeW5hbWljTmFtZUJsb2NrKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5jb25zdHJ1Y3REeW5hbWljQ29uc3RydWN0b3JCbG9jayhcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSh3YXRjaENvbnN0cnVjdG9yQXJncywgdGhpcy5jb25zdHJ1Y3REeW5hbWljQ29uc3RydWN0b3JCbG9jaylcbiAgICAgICk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3duQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBwYXJlbnRUZW1wbGF0ZS4kJC5kQmxvY2tzLnB1c2godGhpcyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50UGFyZW50U2NvcGU7XG4gICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFBhcmVudFRlbXBsYXRlO1xuXG4gICAgaWYgKERCbG9ja05hbWUpIHtcbiAgICAgIGZvdW5kID0gZmluZEluQXJyYXkoY2hpbGRyZW4sICh7IG5hbWU6IG5vZGVOYW1lIH0pID0+IG5vZGVOYW1lID09PSBgZC1ibG9jazokeyBEQmxvY2tOYW1lIH1gKTtcblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICBmb3VuZCA9IGZpbmRJbkFycmF5KHBhcmVudFRlbXBsYXRlLiQkLmRCbG9ja3MsICh7ICQkOiB7IGRCbG9ja05hbWUgfSB9KSA9PiBkQmxvY2tOYW1lID09PSBEQmxvY2tOYW1lKTtcblxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICB0aGlzLlBhcmVudFNjb3BlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICAgICAgdGhpcy5QYXJlbnRUZW1wbGF0ZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgICAgICAgIGZvdW5kLnZhbHVlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGZvdW5kLnZhbHVlLiQkLmh0bWxDaGlsZHJlblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kXG4gICAgICAgID8gZm91bmQudmFsdWUuY2hpbGRyZW5cbiAgICAgICAgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0RHluYW1pY05hbWVCbG9jayA9IChuYW1lKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaHRtbENoaWxkcmVuLFxuICAgICAgZEJsb2NrQXJnc1xuICAgIH0gPSB0aGlzLiQkO1xuXG4gICAgdGhpcy5lbGVtcyA9IFt7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cnM6IGRCbG9ja0FyZ3MsXG4gICAgICBjaGlsZHJlbjogaHRtbENoaWxkcmVuXG4gICAgfV07XG4gIH07XG5cbiAgY29uc3RydWN0RHluYW1pY0NvbnN0cnVjdG9yQmxvY2sgPSAoQ29uc3RydWN0b3IpID0+IHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aGlzLmVsZW1zID0gbnVsbDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIGRCbG9ja0FyZ3NcbiAgICB9ID0gdGhpcy4kJDtcblxuICAgIHRoaXMuZWxlbXMgPSBbe1xuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBhdHRyczogZEJsb2NrQXJncyxcbiAgICAgIGNoaWxkcmVuOiBodG1sQ2hpbGRyZW5cbiAgICB9XTtcbiAgfTtcbn1cblxucm9vdEJsb2Nrc1snZC1ibG9jayddID0gREJsb2NrO1xuXG5leHBvcnQgeyBEQmxvY2sgfTtcbiIsImltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuXG5jb25zdCB0ZW1wbGF0ZSA9IGh0bWxgXG4gIDxkLWVsZW1lbnRzXG4gICAgdmFsdWU9XCJ7JCQuaHRtbENoaWxkcmVufVwiXG4gICAgcGFyZW50U2NvcGU9XCJ7dGhpc31cIlxuICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gIC8+XG5gO1xuXG5jbGFzcyBESXRlbSBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gdGVtcGxhdGU7XG59XG5cbmV4cG9ydCB7IERJdGVtIH07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sIGl0ZXJhdGVBcnJheSwgaXRlcmF0ZU9iamVjdCxcbiAgaXNBcnJheSwgaXNGdW5jdGlvblxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyByZW1vdmUsIGNyZWF0ZUJsb2NrIH0gZnJvbSAnLi4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgREl0ZW0gfSBmcm9tICcuL2QtaXRlbSc7XG5cbmNvbnN0IHdhdGNoQXJncyA9IGpzYFtcbiAgYXJncy5zZXQsXG4gIGFyZ3MuZmlsdGVyQnksXG4gIGFyZ3Muc29ydEJ5XG5dYDtcblxucm9vdEJsb2Nrc1snZC1lYWNoJ10gPSBjbGFzcyBERWFjaCBleHRlbmRzIEJsb2NrIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJnczoge1xuICAgICAgICBpdGVtOiBpdGVtTmFtZSA9ICckaXRlbScsXG4gICAgICAgIGluZGV4OiBpbmRleE5hbWUgPSAnJGluZGV4J1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuXG4gICAgYXNzaWduKHRoaXMuJCQsIHtcbiAgICAgIGl0ZW1zQnlVSURzOiB7fSxcbiAgICAgIFVJRDogdGhpcy5hcmdzLnVpZCB8fCB1bmRlZmluZWQsXG4gICAgICBpdGVtTmFtZSxcbiAgICAgIGluZGV4TmFtZVxuICAgIH0pO1xuICB9XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsIHRoaXMucmVuZGVyU2V0KTtcbiAgICB0aGlzLnJlbmRlclNldCgpO1xuICB9XG5cbiAgcmVuZGVyU2V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgIGl0ZW1zQnlVSURzLFxuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRFbGVtLFxuICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICBzY29wZSxcbiAgICAgIGl0ZW1OYW1lLFxuICAgICAgaW5kZXhOYW1lLFxuICAgICAgVUlEXG4gICAgfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgYXJnczogeyBzb3J0QnkgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0l0ZW1zQnlVSURzID0ge307XG4gICAgY29uc3QgbmV3VUlEc0NvdW50ZXIgPSB7fTtcbiAgICBjb25zdCBuZXdVSURzID0ge307XG4gICAgbGV0IHtcbiAgICAgIHNldCxcbiAgICAgIGZpbHRlckJ5XG4gICAgfSA9IHRoaXMuYXJncztcbiAgICBjb25zdCBpc0FyciA9IGlzQXJyYXkoc2V0KTtcbiAgICBjb25zdCBpdGVyYXRlID0gaXNBcnJcbiAgICAgID8gaXRlcmF0ZUFycmF5XG4gICAgICA6IGl0ZXJhdGVPYmplY3Q7XG5cbiAgICBpZiAoaXNBcnIgJiYgaXNGdW5jdGlvbihzb3J0QnkpKSB7XG4gICAgICBzZXQgPSBzZXRcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnNvcnQoc29ydEJ5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXJCeSkpIHtcbiAgICAgIGZpbHRlckJ5ID0gW2ZpbHRlckJ5XTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShmaWx0ZXJCeSkpIHtcbiAgICAgIGl0ZXJhdGVBcnJheShmaWx0ZXJCeSwgKGZpbHRlcikgPT4ge1xuICAgICAgICBzZXQgPSBzZXQuZmlsdGVyKGZpbHRlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpdGVyYXRlKHNldCwgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBzY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuICAgICAgc2NvcGVbaW5kZXhOYW1lXSA9IGluZGV4O1xuXG4gICAgICBjb25zdCB1aWQgPSBwYXJlbnRTY29wZS4kJC5ldmFsdWF0ZShVSUQsIG51bGwsIG51bGwsIGZhbHNlLCBmYWxzZSwgdGhpcyk7XG5cbiAgICAgIG5ld1VJRHNDb3VudGVyW3VpZF0gPSAobmV3VUlEc0NvdW50ZXJbdWlkXSB8fCAwKSArIDE7XG4gICAgICBuZXdVSURzW2luZGV4XSA9IHVpZDtcbiAgICB9KTtcblxuICAgIHNjb3BlW2l0ZW1OYW1lXSA9IG51bGw7XG4gICAgc2NvcGVbaW5kZXhOYW1lXSA9IG51bGw7XG5cbiAgICBpdGVyYXRlT2JqZWN0KGl0ZW1zQnlVSURzLCAoaXRlbXMsIHVpZCkgPT4ge1xuICAgICAgaWYgKCFuZXdVSURzQ291bnRlclt1aWRdKSB7XG4gICAgICAgIGl0ZXJhdGVBcnJheShpdGVtcywgcmVtb3ZlKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVBcnJheShpdGVtcy5zcGxpY2UobmV3VUlEc0NvdW50ZXJbdWlkXSksIHJlbW92ZSk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgaXRlcmF0ZShzZXQsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdWlkID0gbmV3VUlEc1tpbmRleF07XG4gICAgICBsZXQgYmxvY2s7XG5cbiAgICAgIGlmIChpdGVtc0J5VUlEc1t1aWRdICYmIGl0ZW1zQnlVSURzW3VpZF0ubGVuZ3RoKSB7XG4gICAgICAgIGJsb2NrID0gaXRlbXNCeVVJRHNbdWlkXS5zaGlmdCgpO1xuICAgICAgICBibG9jay4kJC5zY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG4gICAgICAgIGJsb2NrLiQkLnNjb3BlW2l0ZW1OYW1lXSA9IGl0ZW07XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHByZXZCbG9jazogcHJldlByZXZCbG9ja1xuICAgICAgICB9ID0gYmxvY2suJCQ7XG5cbiAgICAgICAgaWYgKHByZXZQcmV2QmxvY2sgJiYgcHJldlByZXZCbG9jayAhPT0gcHJldkJsb2NrKSB7XG4gICAgICAgICAgY29uc3QgeyBjb250ZW50IH0gPSBibG9jay4kJDtcblxuICAgICAgICAgIGlmIChwcmV2QmxvY2spIHtcbiAgICAgICAgICAgIHByZXZCbG9jay4kJC5pbnNlcnRBZnRlckl0KGNvbnRlbnQsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQkLmluc2VydEluU3RhcnRPZkl0KGNvbnRlbnQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgaXRlbU5hbWUsXG4gICAgICAgICAgICBpbmRleE5hbWUsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBuYW1lOiAnI2QtaXRlbScsXG4gICAgICAgICAgICBDb25zdHJ1Y3RvcjogREl0ZW0sXG4gICAgICAgICAgICBjaGlsZHJlbjogaHRtbENoaWxkcmVuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgcGFyZW50RWxlbSxcbiAgICAgICAgICBwYXJlbnRCbG9jazogdGhpcyxcbiAgICAgICAgICBwYXJlbnRTY29wZSxcbiAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBwcmV2QmxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIChuZXdJdGVtc0J5VUlEc1t1aWRdID0gbmV3SXRlbXNCeVVJRHNbdWlkXSB8fCBbXSkucHVzaChibG9jayk7XG4gICAgICBibG9jay4kJC5wcmV2QmxvY2sgPSBwcmV2QmxvY2s7XG4gICAgICBwcmV2QmxvY2sgPSBibG9jaztcbiAgICB9KTtcblxuICAgIHRoaXMuJCQuaXRlbXNCeVVJRHMgPSBuZXdJdGVtc0J5VUlEcztcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBpdGVyYXRlQXJyYXksIHJlbW92ZUFycmF5RWxlbSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW92ZVdpdGhQYXJlbnRTaWduYWwsIGNyZWF0ZUJsb2NrIH0gZnJvbSAnLi4vaGVscGVycy9CbG9jayc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IEVsZW0gfSBmcm9tICcuLi9FbGVtJztcbmltcG9ydCB7IHJvb3RCbG9ja3MgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB3YXRjaEFyZ3MgPSBqc2BhcmdzLnZhbHVlYDtcblxucm9vdEJsb2Nrc1snZC1lbGVtZW50cyddID0gY2xhc3MgREVsZW1lbnRzIGV4dGVuZHMgQmxvY2sge1xuICBhZnRlckNvbnN0cnVjdCgpIHtcbiAgICBjb25zdCB7IHBhcmVudEVsZW0gfSA9IHRoaXMuJCQ7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBwYXJlbnRUZW1wbGF0ZVxuICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICB0aGlzLiQkLmV2YWx1YXRlKHdhdGNoQXJncywgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtaXhpbnMsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgd2F0Y2hlcnNUb1JlbW92ZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IHRoaXMuJCQ7XG5cbiAgICAgIGl0ZXJhdGVBcnJheShjaGlsZHJlbiwgcmVtb3ZlV2l0aFBhcmVudFNpZ25hbCk7XG4gICAgICBpdGVyYXRlQXJyYXkobWl4aW5zLCByZW1vdmVXaXRoUGFyZW50U2lnbmFsKTtcbiAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG5cbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICBwYXJlbnQuJCQucmVtb3ZlQ29udGVudChjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kJC5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy4kJC5taXhpbnMgPSBbXTtcbiAgICAgIHRoaXMuJCQud2F0Y2hlcnNUb1JlbW92ZSA9IHdhdGNoZXJzVG9SZW1vdmUuZmlsdGVyKCh7IHdhdGNoZXJzLCB3YXRjaGVyLCBmb3JERWxlbWVudHMgfSkgPT4ge1xuICAgICAgICBpZiAoZm9yREVsZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVBcnJheUVsZW0od2F0Y2hlcnMsIHdhdGNoZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiQkLmNvbnRlbnQgPSBuZXcgRWxlbSgpO1xuXG4gICAgICBsZXQgcHJldkJsb2NrO1xuXG4gICAgICBpdGVyYXRlQXJyYXkodmFsdWUgfHwgW10sIChjaGlsZCkgPT4ge1xuICAgICAgICBwcmV2QmxvY2sgPSBjcmVhdGVCbG9jayh7XG4gICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgIHBhcmVudEVsZW0sXG4gICAgICAgICAgcGFyZW50QmxvY2s6IHRoaXMsXG4gICAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICAgICAgcGFyZW50VGVtcGxhdGUsXG4gICAgICAgICAgcHJldkJsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcywgdHJ1ZSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBmaW5kSW5BcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgcm9vdEJsb2NrcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RCbG9ja3NbJ2QtaWYnXSA9IGNsYXNzIERJZiBleHRlbmRzIEJsb2NrIHtcbiAgc3RhdGljIHRlbXBsYXRlID0gaHRtbGBcbiAgICA8ZC1lbGVtZW50c1xuICAgICAgdmFsdWU9XCJ7ZWxlbXN9XCJcbiAgICAgIHBhcmVudFNjb3BlPVwieyQkLnBhcmVudFNjb3BlfVwiXG4gICAgICBwYXJlbnRUZW1wbGF0ZT1cInskJC5wYXJlbnRUZW1wbGF0ZX1cIlxuICAgIC8+XG4gIGA7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NvcGUsXG4gICAgICBodG1sQ2hpbGRyZW5cbiAgICB9ID0gdGhpcy4kJDtcbiAgICBsZXQgaW5kZXggPSBJbmZpbml0eTtcbiAgICBjb25zdCB2YWx1ZXMgPSBodG1sQ2hpbGRyZW4ubWFwKChjaGlsZCwgaSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBhdHRycyA9IHt9LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgbGV0IGNvbmQgPSBhdHRycy5pZjtcblxuICAgICAgaWYgKG5hbWUgIT09ICdkLWVsc2UnICYmIGNvbmQpIHtcbiAgICAgICAgY29uZCA9IHBhcmVudFNjb3BlLiQkLmV2YWx1YXRlKGNvbmQsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgIGlmICghIW5ld1ZhbHVlID09PSB2YWx1ZXNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZXNbaV0gPSAhIW5ld1ZhbHVlO1xuXG4gICAgICAgICAgaWYgKGkgPiBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpIDwgaW5kZXggJiYgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZvdW5kID0gZmluZEluQXJyYXkodmFsdWVzLCBCb29sZWFuKTtcblxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3VuZC5rZXk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gaHRtbENoaWxkcmVuW2ZvdW5kLmtleV0uY2hpbGRyZW47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25kICYmIGluZGV4ID09PSBJbmZpbml0eSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIHRoaXMuZWxlbXMgPSBjaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEhY29uZDtcbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGZpbmRJbkFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tICcuLi9CbG9jayc7XG5pbXBvcnQgeyByb290QmxvY2tzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3Qgd2F0Y2hBcmdzID0ganNgW1xuICBhcmdzLnZhbHVlLFxuICBhcmdzLmNvbXBhcmVGblxuXWA7XG5cbnJvb3RCbG9ja3NbJ2Qtc3dpdGNoJ10gPSBjbGFzcyBEU3dpdGNoIGV4dGVuZHMgQmxvY2sge1xuICBzdGF0aWMgdGVtcGxhdGUgPSBodG1sYFxuICAgIDxkLWVsZW1lbnRzXG4gICAgICB2YWx1ZT1cIntlbGVtc31cIlxuICAgICAgcGFyZW50U2NvcGU9XCJ7JCQucGFyZW50U2NvcGV9XCJcbiAgICAgIHBhcmVudFRlbXBsYXRlPVwieyQkLnBhcmVudFRlbXBsYXRlfVwiXG4gICAgLz5cbiAgYDtcbiAgc3RhdGljIGRlZmF1bHRBcmdzID0ge1xuICAgIGNvbXBhcmVGbihzd2l0Y2hWYWx1ZSwgY2FzZVZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzd2l0Y2hWYWx1ZSA9PT0gY2FzZVZhbHVlXG4gICAgICAgIHx8IChzd2l0Y2hWYWx1ZSAhPT0gc3dpdGNoVmFsdWUgJiYgY2FzZVZhbHVlICE9PSBjYXNlVmFsdWUpXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBpbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICQkOiB7XG4gICAgICAgIGh0bWxDaGlsZHJlbixcbiAgICAgICAgcGFyZW50U2NvcGVcbiAgICAgIH0sXG4gICAgICBhcmdzLFxuICAgICAgYXJnczogeyB2YWx1ZSB9XG4gICAgfSA9IHRoaXM7XG5cbiAgICB0aGlzLnZhbHVlcyA9IGh0bWxDaGlsZHJlbi5tYXAoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGF0dHJzID0ge30sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBsZXQgdmFsO1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2QtZGVmYXVsdCcpIHtcbiAgICAgICAgdmFsID0gcGFyZW50U2NvcGUuJCQuZXZhbHVhdGUoYXR0cnMuaWYsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMudmFsdWVzW2ldLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICBpZiAoaSA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmb3VuZCA9IGZpbmRJbkFycmF5KHRoaXMudmFsdWVzLCAoeyBuYW1lLCB2YWx1ZSB9KSA9PiAoXG4gICAgICAgICAgICBuYW1lID09PSAnZC1kZWZhdWx0J1xuICAgICAgICAgICAgfHwgdGhpcy5hcmdzLmNvbXBhcmVGbihhcmdzLnZhbHVlLCB2YWx1ZSlcbiAgICAgICAgICApKTtcblxuICAgICAgICAgIHRoaXMuaW5kZXggPSBmb3VuZFxuICAgICAgICAgICAgPyBmb3VuZC5rZXlcbiAgICAgICAgICAgIDogSW5maW5pdHk7XG4gICAgICAgICAgdGhpcy5lbGVtcyA9IGZvdW5kXG4gICAgICAgICAgICA/IGZvdW5kLnZhbHVlLmNoaWxkcmVuXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gSW5maW5pdHkgJiYgKFxuICAgICAgICBuYW1lID09PSAnZC1kZWZhdWx0J1xuICAgICAgICB8fCB0aGlzLmFyZ3MuY29tcGFyZUZuKHZhbHVlLCB2YWwpXG4gICAgICApKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB2YWx1ZTogdmFsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgYWZ0ZXJDb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5ldmFsdWF0ZSh3YXRjaEFyZ3MsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICBjb21wYXJlRm5cbiAgICAgIH0gPSB0aGlzLmFyZ3M7XG5cbiAgICAgIHRoaXMuaW5kZXggPSBJbmZpbml0eTtcblxuICAgICAgdGhpcy52YWx1ZXMuc29tZSgoeyBuYW1lLCB2YWx1ZSwgY2hpbGRyZW4gfSwgaSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmFtZSA9PT0gJ2QtZGVmYXVsdCdcbiAgICAgICAgICB8fCBjb21wYXJlRm4obmV3VmFsdWUsIHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB0aGlzLmVsZW1zID0gY2hpbGRyZW47XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmluZGV4ID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmVsZW1zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGNvbGxlY3RGcm9tT2JqZWN0LCBpdGVyYXRlT2JqZWN0LCBrZXlzIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1hdHRyJ10gPSBjbGFzcyBEQXR0ciBleHRlbmRzIE1peGluIHtcbiAgYXR0cnMgPSB7fTtcblxuICBhZnRlclVwZGF0ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBhcmdzLFxuICAgICAgYXR0cnNcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBuZXdWYWx1ZSA9IGNvbGxlY3RGcm9tT2JqZWN0KGFyZ3MsIChhdHRycywgYXR0cikgPT4ge1xuICAgICAgICBhdHRyc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXRlcmF0ZU9iamVjdChhdHRycywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIShwcm9wIGluIG5ld1ZhbHVlKSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHIocHJvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWxlbS5hdHRyKG5ld1ZhbHVlKTtcblxuICAgIHRoaXMuYXR0cnMgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtLFxuICAgICAgYXR0cnNcbiAgICB9ID0gdGhpcztcblxuICAgIGVsZW0ucmVtb3ZlQXR0ci5hcHBseShlbGVtLCBrZXlzKGF0dHJzKSk7XG4gIH1cbn07XG5cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4uL01peGluJztcbmltcG9ydCB7IHJvb3RNaXhpbnMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5yb290TWl4aW5zWydkLWJpbmQnXSA9IGNsYXNzIERCaW5kIGV4dGVuZHMgTWl4aW4ge1xuICBvZmYgPSBub29wO1xuXG4gIGFmdGVyVXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5vZmYoKTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLm9mZiA9IHRoaXMuZWxlbS5vbih0aGlzLmFyZ3Muam9pbignLCcpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmID0gbm9vcDtcblxuICAgICAgY29uc29sZS5lcnJvcignUHJvdmlkZSBcImQtYmluZFwiIG1peGluIHdpdGggYW4gZXZlbnQgbmFtZXMgKGxpa2UgXCJkLWJpbmQoY2xpY2spXCIgb3IgXCJkLWJpbmQoa2V5dXAsIGtleXByZXNzKVwiKSEnKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5vZmYoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIGlzQXJyYXksIGlzU3RyaW5nLFxuICBpdGVyYXRlQXJyYXksIGl0ZXJhdGVPYmplY3Rcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgRU1QVFlfU1BBQ0VfUkVHRVggPSAvXFxzKy87XG5cbnJvb3RNaXhpbnNbJ2QtY2xhc3MnXSA9IGNsYXNzIERDbGFzcyBleHRlbmRzIE1peGluIHtcbiAgY2xhc3NlcyA9IFtdO1xuXG4gIGFmdGVyVXBkYXRlKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbSxcbiAgICAgIGFyZ3MsXG4gICAgICBjbGFzc2VzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3Q2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWVcbiAgICAgICAgPyBhcmdzXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKG5ld1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zcGxpdChFTVBUWV9TUEFDRV9SRUdFWCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICBpZiAobmV3VmFsdWUuaW5kZXhPZihjbHMpID09PSAtMSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoY2xzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlQXJyYXkobmV3VmFsdWUsIChjbHMpID0+IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNscykpIHtcbiAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKGNscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlQXJyYXkoY2xhc3NlcywgKGNscykgPT4ge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8ICFuZXdWYWx1ZVtjbHNdKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVPYmplY3QobmV3VmFsdWUsICh2YWwsIGNscykgPT4ge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICAgICAgZWxlbS5hZGRDbGFzcyhjbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzZXMgPSBuZXdDbGFzc2VzO1xuICB9XG5cbiAgYmVmb3JlUmVtb3ZlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW0sXG4gICAgICBjbGFzc2VzXG4gICAgfSA9IHRoaXM7XG5cbiAgICBlbGVtLnJlbW92ZUNsYXNzLmFwcGx5KGVsZW0sIGNsYXNzZXMpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gJy4uL0Jsb2NrJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2QtZWxlbSddID0gY2xhc3MgREVsZW0gZXh0ZW5kcyBNaXhpbiB7XG4gIHN0YXRpYyBldmFsdWF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBwYXJlbnRUZW1wbGF0ZSxcbiAgICAgIGVsZW1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQgc2NvcGUgPSBwYXJlbnRUZW1wbGF0ZTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKCk7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgc2NvcGUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2NrXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJlbnRUZW1wbGF0ZTtcbiAgICAgIHZhbHVlID0gYXJnc1swXTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlKGVsZW0pO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBzY29wZVt2YWx1ZV0gPSBlbGVtO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNsYXNzIERIaWRlIGV4dGVuZHMgTWl4aW4ge1xuICBhZnRlclVwZGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbSB9ID0gdGhpcztcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICB0aGlzLmVsZW0uc2hvdygpO1xuICB9XG59XG5cbnJvb3RNaXhpbnNbJ2QtaGlkZSddID0gREhpZGU7XG5cbmV4cG9ydCB7IERIaWRlIH07XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnLi4vQmxvY2snO1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1ub2RlJ10gPSBjbGFzcyBETm9kZSBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYXJncyxcbiAgICAgIHBhcmVudFRlbXBsYXRlLFxuICAgICAgbm9kZVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBzY29wZSA9IHBhcmVudFRlbXBsYXRlO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZXZhbHVhdGUoKTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBzY29wZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHBhcmVudFRlbXBsYXRlO1xuICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUobm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHNjb3BlW3ZhbHVlXSA9IG5vZGU7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1peGluIH0gZnJvbSAnLi4vTWl4aW4nO1xuaW1wb3J0IHsgcm9vdE1peGlucyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbnJvb3RNaXhpbnNbJ2Qtb24nXSA9IGNsYXNzIERPbiBleHRlbmRzIE1peGluIHtcbiAgc3RhdGljIGV2YWx1YXRlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgdGhpcy5vZmYgPSB0aGlzLmVsZW0ub24odGhpcy5hcmdzLmpvaW4oJywnKSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmV2YWx1YXRlKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYgPSBub29wO1xuXG4gICAgICBjb25zb2xlLmVycm9yKCdQcm92aWRlIFwiZC1vblwiIG1peGluIHdpdGggYW4gZXZlbnQgbmFtZXMgKGxpa2UgXCJkLW9uKGNsaWNrKVwiIG9yIFwiZC1vbihrZXl1cCwga2V5cHJlc3MpXCIpIScpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZVJlbW92ZSgpIHtcbiAgICB0aGlzLm9mZigpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgTWl4aW4gfSBmcm9tICcuLi9NaXhpbic7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxucm9vdE1peGluc1snZC1zaG93J10gPSBjbGFzcyBEU2hvdyBleHRlbmRzIE1peGluIHtcbiAgYWZ0ZXJVcGRhdGUodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW0gfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW0uc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVSZW1vdmUoKSB7XG4gICAgdGhpcy5lbGVtLnNob3coKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGl0ZXJhdGVPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyByb290TWl4aW5zIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbnN0cnVjdE1peGluUmVnZXggfSBmcm9tICcuL2NvbnN0cnVjdE1peGluUmVnZXgnO1xuXG5pdGVyYXRlT2JqZWN0KHJvb3RNaXhpbnMsIChNaXhpbiwgbmFtZSkgPT4ge1xuICBNaXhpbi5fbWF0Y2ggPSBjb25zdHJ1Y3RNaXhpblJlZ2V4KG5hbWUpO1xufSk7XG4iLCJpbXBvcnQgeyBFbGVtIH0gZnJvbSAnLi9FbGVtJztcbmltcG9ydCB7IGNyZWF0ZUhpZGVTdHlsZU5vZGUgfSBmcm9tICcuL2hlbHBlcnMvRWxlbSc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGRvY1xuICogQHR5cGUge0VsZW19XG4gKiBAcHVibGljXG4gKiBAZGVzY3JpcHRpb24gRWxlbSBpbnN0YW5jZSBvZiBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IG5ldyBFbGVtKGRvY3VtZW50KTtcblxuLyoqXG4gKiBAY29uc3Qge0VsZW19IGh0bWxcbiAqIEB0eXBlIHtFbGVtfVxuICogQHB1YmxpY1xuICogQGRlc2NyaXB0aW9uIEVsZW0gaW5zdGFuY2Ugb2YgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IG5ldyBFbGVtKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBib2R5XG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmJvZHkuXG4gKi9cbmV4cG9ydCBjb25zdCBib2R5ID0gbmV3IEVsZW0oZG9jdW1lbnQuYm9keSk7XG5cbi8qKlxuICogQGNvbnN0IHtFbGVtfSBoZWFkXG4gKiBAdHlwZSB7RWxlbX1cbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBFbGVtIGluc3RhbmNlIG9mIGRvY3VtZW50LmhlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFkID0gbmV3IEVsZW0oZG9jdW1lbnQuaGVhZCk7XG5cbmNyZWF0ZUhpZGVTdHlsZU5vZGUoaGVhZCk7XG4iXSwibmFtZXMiOlsiY29sbGVjdEZyb21BcnJheSIsImFycmF5IiwiY2FsbGJhY2siLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZSIsImluZGV4IiwiZmluZEluQXJyYXkiLCJpIiwibGVuZ3RoIiwiaXRlcmF0ZUFycmF5IiwicmVtb3ZlQXJyYXlFbGVtIiwiZWxlbSIsImluZGV4T2YiLCJzcGxpY2UiLCJ0b09iamVjdEtleXMiLCJhZGRLZXkiLCJ2YXJzIiwidmFyaWFibGUiLCJhc3NpZ24iLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJrZXkiLCJjb2xsZWN0RnJvbU9iamVjdCIsIm9iamVjdCIsImV4Y2VwdCIsIm5ld09iamVjdCIsInBhdGhzIiwic2xpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsIml0ZXJhdGVPYmplY3QiLCJtYXBPYmplY3QiLCJkZWZpbmVQcm90b3R5cGVQcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0eSIsImRlZmluZUZyb3plblByb3BlcnRpZXMiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwic2V0VG9TdHJpbmdUYWciLCJrbGFzcyIsInRhZyIsIlN5bWJvbCIsInByb3RvdHlwZSIsImlzRnVuY3Rpb24iLCJpc05pbCIsImlzU3RyaW5nIiwiZXNjYXBlUmVnZXgiLCJzdHJpbmciLCJyZXBsYWNlIiwicmVnZXhwU3BlY2lhbHNSZWdleHAiLCJub29wIiwidG9DYW1lbENhc2UiLCJEQVNIRURfU1lNQk9MX1JFR0VYIiwiY2FwaXRhbGl6ZSIsInRvSHlwaGVuQ2FzZSIsIlVQUEVSQ0FTRURfU1lNQk9MX1JFR0VYIiwiaHlwaGVuaXplIiwibWF0Y2giLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiYWRkQXR0ciIsImF0dHJzIiwiYXR0ciIsImFkZENTU1Byb3AiLCJjc3MiLCJwcm9wZXJ0eSIsInNwbGl0IiwiQ1NTX1BST1BfVkFMVUVfU0VQQVJBVE9SX1JFR0VYIiwiYWRkRGF0YUF0dHIiLCJkYXRhIiwiYWRkTmV4dCIsImFkZCIsIm5leHRTaWJsaW5nIiwiYWRkUGFyZW50IiwicGFyZW50Tm9kZSIsImFkZFByZXYiLCJwcmV2aW91c1NpYmxpbmciLCJjcmVhdGVIaWRlU3R5bGVOb2RlIiwiaGVhZCIsImZpbmQiLCJISURFX0NMQVNTIiwiY3JlYXRlIiwicHJvcCIsInRleHQiLCJnZXRBdHRyTlMiLCJpc1htbE5zIiwibm9kZU5hbWUiLCJOdWxsIiwiWE1MX05TIiwiWF9MSU5LX0FUVFJfRklORF9SRUdFWCIsInRlc3QiLCJFbGVtIiwiY2xvc2VzdCIsIlhfTElOS19OUyIsIlhfTElOS19BVFRSX1JFUExBQ0VfUkVHRVgiLCJpc0RvY3VtZW50IiwiRE9DVU1FTlRfUkVHRVgiLCJpc0VsZW0iLCJpc0VsZW1lbnRzQ29sbGVjdGlvbiIsIkhUTUxfQ09MTEVDVElPTl9SRUdFWCIsImlzQXJyYXkiLCJpc1ZhbGlkTm9kZSIsIkVMRU1FTlRfUkVHRVgiLCJnZXRFdmVudCIsImV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJyZWFsRGV0YWlscyIsImZpbmFsRXZlbnQiLCJFVkVOVF9SRUdFWCIsIkV2ZW50IiwiZXJyIiwiZG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJoaWRlIiwiYWRkQ2xhc3MiLCJnZXRNYXRjaGVzRnVuY3Rpb24iLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwic2VsZWN0b3IiLCJ0aGlzIiwicXVlcnlTZWxlY3RvckFsbCIsInJlbW92ZSIsInBhcmVudCIsInJlbW92ZUNoaWxkIiwic2hvdyIsInJlbW92ZUNsYXNzIiwidG9FbGVtIiwiYmFzZSIsIlN0cmluZyIsImNhbGN1bGF0ZUFyZ3MiLCJhcmdzIiwiYXJnc09iamVjdCIsImtleXMiLCJhcmciLCJ1bmRlZmluZWQiLCJjbGVhblByb3BlcnR5IiwiY29uc3RydWN0TWl4aW5SZWdleCIsIlJlZ0V4cCIsIm1peGluTWF0Y2giLCJtaXhpbnMiLCJNaXhpbiIsImxvY2FsTWF0Y2giLCJfbWF0Y2giLCJhcmdzTWF0Y2giLCJDT01NQV9SRUdFWCIsInRyYW5zZm9ybVJlc3RBdHRycyIsIm1peGluRGVmYXVsdE9wdHMiLCJldmVudHVhbEF0dHJzIiwiRF9SRVNUX1JFR0VYIiwidHJhbnNmb3JtUmVzdEFyZ3MiLCJhZGRBcmdzIiwiZXhlY3V0ZU1peGluV2F0Y2hlcnMiLCJtaXhpbiIsIm9sZFZhbHVlIiwiJCQiLCJ3YXRjaGVycyIsIndhdGNoZXIiLCJjcmVhdGVNaXhpbiIsImR5bmFtaWMiLCJjb21tZW50IiwicGFyZW50QmxvY2siLCJwYXJlbnRTY29wZSIsInBhcmVudFRlbXBsYXRlIiwiZXZhbHVhdGUiLCJuZXdWYWx1ZSIsImFmdGVyVXBkYXRlIiwiZXJyb3IiLCJjYWxjdWxhdGVBdHRycyIsImF0dHJzT2JqZWN0IiwiZmlyc3RUaW1lIiwidHlwZSIsInJlbW92ZUF0dHIiLCJvcHRzIiwibmV4dFR5cGUiLCJuZXh0RHluYW1pYyIsIm5leHRWYWx1ZSIsInByZXZUeXBlIiwicHJldlZhbHVlIiwiaXNEeW5hbWljIiwiZXZhbHVhdGVkIiwiYnVpbGRNaXhpbiIsImZpcnN0VmFsdWUiLCJwdXNoIiwiY29uc3RydWN0UHJpdmF0ZVNjb3BlIiwic2NvcGUiLCJnbG9iYWxzIiwicmVtb3ZlVGVtcFdhdGNoZXIiLCJyZW1vdmVXYXRjaGVycyIsIndhdGNoZXJzVG9SZW1vdmUiLCJyZW1vdmVXYXRjaGVyIiwiY29uc3RydWN0UHVibGljU2NvcGUiLCJzY29wZVZhbHVlcyIsInByaXZhdGVTY29wZSIsImV2YWxNb2RlIiwiZ2V0dGluZ1ZhcnMiLCJvbGRUZW1wV2F0Y2hlcnMiLCJjcmVhdGVCbG9jayIsIm5vZGUiLCJwYXJlbnRFbGVtIiwicHJldkJsb2NrIiwiZG9jIiwibmFtZXNwYWNlVVJJIiwiU1ZHX05TIiwibG9jYWxCbG9ja3MiLCJucyIsIl9ibG9ja3MiLCJCbG9jayIsImxvY2FsTWl4aW5zIiwiX21peGlucyIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvciIsImRCbG9ja01hdGNoIiwiZEJsb2NrTmFtZSIsImRCbG9ja0FyZ3MiLCJOQU1FRF9EX0JMT0NLX1JFR0VYIiwiYmxvY2tJbnN0YW5jZSIsImVsZW1lbnQiLCJjdXJyZW50QXR0cnMiLCJ3YXNEUmVzdCIsImlzRFJlc3QiLCJsb2NhbEF0dHJzIiwicmVzdEF0dHJzIiwiY3JlYXRlTWl4aW5zIiwiY29udGVudCIsImNvbnRlbnREb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNoaWxkIiwiaXNQYXJlbnRCbG9jayIsImluc2VydEFmdGVySXQiLCJpbnNlcnRBZnRlciIsImFkZENvbnRlbnQiLCJpbnNlcnRJblN0YXJ0T2ZJdCIsImludG8iLCJBcmdzIiwibG9jYWxzIiwiaHRtbCIsInRlbXBsYXRlIiwiaXRlbU5hbWUiLCJpdGVtIiwiaW5kZXhOYW1lIiwiYWZ0ZXJDb25zdHJ1Y3QiLCJpc1JlbmRlcmVkIiwiYWZ0ZXJSZW5kZXIiLCJpc0luc3RhbmNlT2YiLCJDbGFzcyIsIlN1YmNsYXNzIiwiaXNQcm90b3R5cGVPZiIsInJlbW92ZVdpdGhQYXJlbnRTaWduYWwiLCJ3cmFwQmxvY2siLCJibG9jayIsIndyYXBwZXIiLCJyZXR1cm5WYWx1ZSIsIndyYXBNaXhpbiIsImNvbnN0cnVjdFN0eWxlRnJvbVN0cmluZyIsInN0eWxlIiwiQ1NTX1NUWUxFX1NFUEFSQVRPUl9SRUdFWCIsInRyaW0iLCJnZXRQcm9wIiwiaGFzQXR0ciIsImdldFZhbHVlRm9yU2V0dGluZyIsImlucHV0VmFsdWUiLCJpc1JhZGlvIiwiZ2V0VmFsdWVGb3JHZXR0aW5nIiwidmFsdWVzIiwib3B0aW9ucyIsImluaXQiLCJpc011bHRpcGxlIiwiYWRkVmFsdWUiLCJjb25jYXQiLCJnZXRMaXN0ZW5lck5hbWUiLCJzZWxlY3RlZCIsImluc2VydFRlbXBsYXRlcyIsInRlbXBsYXRlcyIsIml0ZXJhdGVBbmRDaGFuZ2VDaGlsZHJlbiIsIm5vZGVzIiwidHJpbW1lZCIsIm5ld1RlbXBsYXRlcyIsIm5ld1RlbXBsYXRlIiwibmV3VmFycyIsImluaXRBcHAiLCJjb250YWluZXIiLCJFcnJvciIsInJvb3RCbG9jayIsInJlbW92ZUFwcCIsIkR3YXluZVJvb3RCbG9jayIsImRlZmluZVByb3BlcnRpZXMiLCJPYmplY3QiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInNldFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJwcm90byIsIl9fcHJvdG9fXyIsInJvb3RCbG9ja3MiLCJyb290TWl4aW5zIiwiQXJyYXkiLCJyZWdleHBTcGVjaWFsQ2hhcmFjdGVycyIsIm1hcCIsInMiLCJqb2luIiwiQ1NTX0lNUE9SVEFOVF9SRUdFWCIsImVtcHR5Q29sbGVjdGlvbiIsIl90aGlzIiwiaW5jbHVkZXMiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiZWxlbXMiLCJmb3JFYWNoIiwibGlzdCIsImNsYXNzTGlzdCIsImNscyIsImF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVOUyIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlIiwiY2hpbGROb2RlcyIsImNvbGxlY3QiLCJpcyIsImVsZW1lbnRzIiwiY2IiLCJjb250YWlucyIsImVsIiwiaXNUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlRWxlbWVudCIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRQcm9wZXJ0eVByaW9yaXR5IiwicmVtb3ZlQ1NTIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImNzc1RleHQiLCJkYXRhc2V0IiwiZGV0YWlscyIsImRpc3BhdGNoRXZlbnQiLCJmaWx0ZXIiLCJoYXNBdHRyaWJ1dGVOUyIsImhhc0F0dHJpYnV0ZSIsImlubmVySFRNTCIsIm5leHQiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImVuZCIsImZpcnN0Q2hpbGQiLCJsaXN0ZW5lciIsIm5ld0V2ZW50cyIsImFsbExpc3RlbmVycyIsImxpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsImZpcnN0IiwicHJldiIsImJhYmVsSGVscGVycy5nZXQiLCJhcHBseSIsInRleHRDb250ZW50IiwiY29uZGl0aW9uIiwiX2FyZ3VtZW50czUiLCJ0b2dnbGUiLCJfYXJndW1lbnRzNiIsInNwZWNpZXMiLCJfdmFsdWUiLCJjdXJyZW50VmFsdWUiLCJpc1BhcmVudFNpZ25hbCIsImlzUmVtb3ZlZCIsImJlZm9yZVJlbW92ZSIsIndyYXBwZXJzIiwicmVkdWNlIiwiaXNFbGVtZW50UmVtb3ZlZCIsImJsb2NrSG9va3MiLCJtaXhpbkhvb2tzIiwiVEFHX05BTUVfUkVHRVgiLCJBVFRSX05BTUVfUkVHRVgiLCJhZnRlckVsZW0iLCJlbXB0eU9iamVjdCIsIm9yaWdpbmFsQXJncyIsImNoaWxkcmVuQmxvY2tzIiwiZnVuYyIsIm9uQ2hhbmdlIiwidGFyZ2V0QmxvY2siLCJmb3JERWxlbWVudHMiLCJmb3JESXRlbSIsImZvckRFYWNoIiwib25DaGFuZ2VGbGFnIiwicmVzdWx0Iiwib3JpZ2luYWwiLCJvbkV2YWxFcnJvciIsImUiLCJsb2NhbFdhdGNoZXJzIiwid2F0Y2hlckJsb2NrIiwibmV3UmVzdWx0IiwiX3RoaXM3IiwicmVtb3ZlQ29udGVudCIsIm5ld0NvbnRlbnQiLCJhZnRlckRPTUNoYW5nZSIsImNvbnRlbnRUb0FkZCIsIm5vdFJlY3Vyc2l2ZSIsIm9sZENvbnRlbnQiLCJjaGFuZ2VDb250ZW50IiwiY29udGVudFRvTW92ZSIsImFmdGVyIiwiaW5kZXhUb1B1dCIsIm1vdmVDb250ZW50IiwiY29udGVudFRvUmVtb3ZlIiwiY29udGVudFRvSW5zZXJ0IiwibW92ZUZsYWciLCJ0cnlUb0FkZE9yTW92ZSIsImRlZmF1bHRMb2NhbHMiLCJkZWZhdWx0QXJncyIsImxvY2FsQXJncyIsInJlc3RBcmdzIiwiaXNERWxlbWVudHMiLCJob29rIiwid2FybiIsImN1cnJlbnRSZXR1cm5WYWx1ZSIsIndhdGNoTmFtZUFyZ3MiLCJ3YXRjaENvbnN0cnVjdG9yQXJncyIsIkRCbG9jayIsImNvbnN0cnVjdER5bmFtaWNOYW1lQmxvY2siLCJodG1sQ2hpbGRyZW4iLCJjb25zdHJ1Y3REeW5hbWljQ29uc3RydWN0b3JCbG9jayIsInBhcmVudFBhcmVudFNjb3BlIiwicGFyZW50UGFyZW50VGVtcGxhdGUiLCJvd25DaGlsZHJlbiIsIkRCbG9ja05hbWUiLCJmb3VuZCIsIlBhcmVudFNjb3BlIiwiUGFyZW50VGVtcGxhdGUiLCJkQmxvY2tzIiwiREl0ZW0iLCJ3YXRjaEFyZ3MiLCJ1aWQiLCJyZW5kZXJTZXQiLCJfdGhpczIiLCJpdGVtc0J5VUlEcyIsIlVJRCIsInNvcnRCeSIsIm5ld0l0ZW1zQnlVSURzIiwibmV3VUlEc0NvdW50ZXIiLCJuZXdVSURzIiwic2V0IiwiZmlsdGVyQnkiLCJpc0FyciIsIml0ZXJhdGUiLCJzb3J0IiwiaXRlbXMiLCJzaGlmdCIsInByZXZQcmV2QmxvY2siLCJJbmZpbml0eSIsImNvbmQiLCJpZiIsIkJvb2xlYW4iLCJ2YWwiLCJjb21wYXJlRm4iLCJzb21lIiwic3dpdGNoVmFsdWUiLCJjYXNlVmFsdWUiLCJvZmYiLCJvbiIsImNsYXNzZXMiLCJuZXdDbGFzc2VzIiwiREhpZGUiLCJpbml0aWFsU2NvcGVWYWx1ZSIsInNldFByb3AiLCJpbml0aWFsRWxlbVZhbHVlIiwiaXNJbml0aWFsU2NvcGVWYWx1ZU51bGwiLCJpc0NoZWNrYm94IiwiY2hhbmdlU2NvcGUiLCJvZmZFbGVtTGlzdGVuZXIiLCJvZmZGb3JtTGlzdGVuZXIiLCJvcHRpb24iLCJib2R5Il0sIm1hcHBpbmdzIjoieUJBQU8sU0FBU0EsR0FBaUJDLEVBQU9DLE1BQVVDLHNFQUNuQ0YsRUFBTyxTQUFDRyxFQUFPQyxLQUNqQkYsRUFBY0MsRUFBT0MsRUFBT0osS0FHaENFLEVBR1QsUUFBZ0JHLEdBQVlMLEVBQU9DLE9BQzVCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsSUFBSyxJQUNoREgsR0FBUUgsRUFBTU0sTUFFaEJMLEVBQVNFLEVBQU9HLEVBQUdOLGNBRWRNLFlBT2IsUUFBZ0JFLEdBQWFSLEVBQU9DLE9BQzdCLEdBQUlLLEdBQUksRUFBR0MsRUFBU1AsRUFBTU8sT0FBUUQsRUFBSUMsRUFBUUQsTUFDeENOLEVBQU1NLEdBQUlBLEVBQUdOLEdBSTFCLFFBQWdCUyxHQUFnQlQsRUFBT1UsTUFDL0JOLEdBQVFKLEVBQU1XLFFBQVFELElBRWIsSUFBWE4sS0FDSVEsT0FBT1IsRUFBTyxHQUl4QixRQUFnQlMsR0FBYWIsU0FDcEJELEdBQWlCQyxFQUFPYyxHQUdqQyxRQUFTQSxHQUFPQyxFQUFNQyxLQUNmQSxJQUFZLEVDakNuQixRQUFnQkMsR0FBT0MsWUFDUkMsVUFBVyxTQUFDQyxFQUFRaEIsR0FDM0JBLEtBQ1lnQixFQUFRLFNBQUNqQixFQUFPa0IsS0FDckJBLEdBQU9sQixNQUtiZSxFQUdULFFBQWdCSSxHQUFrQkMsRUFBUXRCLE1BQVVDLHNFQUNwQ3FCLEVBQVEsU0FBQ3BCLEVB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"}